/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 81 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct __anonstruct_S_25 {
   unsigned char *string ;
   off_t length ;
};
#line 81 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
union __anonunion_start_24 {
   off_t N ;
   struct __anonstruct_S_25 S ;
};
#line 81 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct __anonstruct_S_27 {
   unsigned char *string ;
   off_t length ;
};
#line 81 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
union __anonunion_stop_26 {
   off_t M ;
   struct __anonstruct_S_27 S ;
};
#line 81 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct block {
   int type ;
   union __anonunion_start_24 start ;
   union __anonunion_stop_26 stop ;
};
#line 103 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct command_list {
   char letter ;
   off_t offset ;
   off_t count ;
   unsigned char *s1 ;
   off_t s1_len ;
   unsigned char *s2 ;
   off_t s2_len ;
   int rpos ;
   off_t fpos ;
   FILE *fd ;
   struct command_list *next ;
};
#line 117 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct commands {
   struct command_list *block_start ;
   struct command_list *byte ;
   struct command_list *block_end ;
};
#line 124 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct io_file {
   char *file ;
   int fd ;
   off_t start_offset ;
   struct io_file *next ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 132 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct input_buffer {
   unsigned char *buffer ;
   unsigned char *read_pos ;
   unsigned char *low_pos ;
   unsigned char *block_end ;
   unsigned char *stream_end ;
   off_t stream_offset ;
   off_t block_offset ;
   off_t block_num ;
};
#line 144 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct output_buffer {
   unsigned char *buffer ;
   unsigned char *end ;
   unsigned char *write_pos ;
   unsigned char *low_pos ;
   off_t block_offset ;
};
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 32 "/usr/include/error.h"
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) error)(int __status ,
                                                                                                        int __errnum ,
                                                                                                        char const   *__format 
                                                                                                        , ...) ;
#line 35
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) error_at_line)(int __status ,
                                                                                                                int __errnum ,
                                                                                                                char const   *__fname ,
                                                                                                                unsigned int __line ,
                                                                                                                char const   *__format 
                                                                                                                , ...) ;
#line 25 "/usr/include/bits/error.h"
extern void ( /* format attribute */  __error_alias)(int __status , int __errnum ,
                                                     char const   *__format  , ...)  __asm__("error")  ;
#line 37 "/usr/include/bits/error.h"
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) error)(int __status ,
                                                                                                        int __errnum ,
                                                                                                        char const   *__format 
                                                                                                        , ...) 
{ 


  {
  {
  {
#line 43
  __error_alias(__status, __errnum, __format, __builtin_va_arg_pack());
  }
  }
#line 44
  return;
}
}
#line 47
extern void ( /* format attribute */  __error_at_line_alias)(int __status , int __errnum ,
                                                             char const   *__fname ,
                                                             unsigned int __line ,
                                                             char const   *__format 
                                                             , ...)  __asm__("error_at_line")  ;
#line 64 "/usr/include/bits/error.h"
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) error_at_line)(int __status ,
                                                                                                                int __errnum ,
                                                                                                                char const   *__fname ,
                                                                                                                unsigned int __line ,
                                                                                                                char const   *__format 
                                                                                                                , ...) 
{ 


  {
  {
  {
#line 72
  __error_at_line_alias(__status, __errnum, __fname, __line, __format, __builtin_va_arg_pack());
  }
  }
#line 74
  return;
}
}
#line 155 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
void panic(char *msg , char *info , char *syserror ) ;
#line 158
void *xmalloc(size_t size ) ;
#line 224
char *xstrdup(char *str ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 29 "/home/wslee/benchmarks/bbe-0.2.2/src/xmalloc.c"
void *xmalloc(size_t size ) 
{ 
  register void *value ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 32
  tmp = malloc(size);
  }
#line 32
  value = tmp;
  }
#line 33
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
    {
#line 33
    panic((char *)"Out of memory", (char *)((void *)0), (char *)((void *)0));
    }
    }
  }
#line 34
  return (value);
}
}
#line 37 "/home/wslee/benchmarks/bbe-0.2.2/src/xmalloc.c"
char *xstrdup(char *str ) 
{ 
  char *ret ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 40
  tmp = strdup((char const   *)str);
  }
#line 40
  ret = tmp;
  }
#line 41
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
    {
#line 41
    panic((char *)"Out of memory", (char *)((void *)0), (char *)((void *)0));
    }
    }
  }
#line 42
  return (ret);
}
}
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 651
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 161 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
void set_output_file(char *file___1 ) ;
#line 164
void set_input_file(char *file___1 ) ;
#line 167
void init_buffer(void) ;
#line 197
void init_commands(struct commands *commands___0 ) ;
#line 200
void close_commands(struct commands *commands___0 ) ;
#line 209
void execute_program(struct commands *commands___0 ) ;
#line 228 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct block block  ;
#line 230
struct io_file out_stream ;
#line 233
int output_only_block ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 346
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 38 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char *program  =    (char *)"bbe";
#line 44 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char *version  =    (char *)"0.2.2";
#line 50 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char *email_address  =    (char *)"tjsa@iki.fi";
#line 60 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
struct commands cmds  ;
#line 63 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
char *panic_info  =    (char *)((void *)0);
#line 66 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
int output_only_block  =    0;
#line 69 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
char *convert_strings[3]  = {      (char *)"BCDASC",      (char *)"ASCBCD",      (char *)""};
#line 84 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
char *p_formats  =    (char *)"DOHAB";
#line 87 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
char *FB_formats  =    (char *)"DOH";
#line 89 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char short_opts[12]  = 
#line 89
  {      (char )'b',      (char )':',      (char )'e',      (char )':', 
        (char )'f',      (char )':',      (char )'o',      (char )':', 
        (char )'s',      (char )'?',      (char )'V',      (char )'\000'};
#line 92 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static struct option long_opts[8]  = 
#line 92
  {      {"block", 1, (int *)((void *)0), 'b'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"help", 0, (int *)((void *)0), '?'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"suppress", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 104 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void panic(char *msg , char *info , char *syserror ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 107
  if ((unsigned long )panic_info != (unsigned long )((void *)0)) {
    {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s",
            program, panic_info);
    }
    }
  }
#line 109
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 109
    if ((unsigned long )syserror == (unsigned long )((void *)0)) {
      {
      {
#line 111
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              program, msg);
      }
      }
    } else {
#line 109
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 112
  if ((unsigned long )info != (unsigned long )((void *)0)) {
#line 112
    if ((unsigned long )syserror == (unsigned long )((void *)0)) {
      {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program, msg, info);
      }
      }
    } else {
#line 112
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 115
  if ((unsigned long )info != (unsigned long )((void *)0)) {
#line 115
    if ((unsigned long )syserror != (unsigned long )((void *)0)) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s; %s\n",
              program, msg, info, syserror);
      }
      }
    } else {
#line 115
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 118
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 118
    if ((unsigned long )syserror != (unsigned long )((void *)0)) {
      {
      {
#line 120
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s; %s\n",
              program, msg, syserror);
      }
      }
    }
  }
  {
  {
#line 122
  exit(1);
  }
  }
}
}
#line 126 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
off_t parse_long(char *long_int ) 
{ 
  long long l ;
  char *scan ;
  char type ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 130
  scan = long_int;
#line 131
  type = (char )'d';
#line 134
  if ((int )*scan == 48) {
#line 136
    type = (char )'o';
#line 137
    scan ++;
#line 138
    if ((int )*scan == 120) {
#line 139
      type = (char )'x';
#line 140
      scan ++;
    } else
#line 138
    if ((int )*scan == 88) {
#line 139
      type = (char )'x';
#line 140
      scan ++;
    }
  }
  {
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 144
    if (! ((int )*scan != 0)) {
#line 144
      goto while_break;
    }
    {
#line 148
    if ((int )type == 100) {
#line 148
      goto case_100;
    }
#line 151
    if ((int )type == 111) {
#line 151
      goto case_111;
    }
#line 154
    if ((int )type == 120) {
#line 154
      goto case_120;
    }
#line 146
    goto switch_break;
    case_100: /* CIL Label */ 
    {
    {
#line 149
    tmp = __ctype_b_loc();
    }
    }
#line 149
    if (! ((int const   )*(*tmp + (int )*scan) & 2048)) {
      {
      {
#line 149
      panic((char *)"Error in number", long_int, (char *)((void *)0));
      }
      }
    }
#line 150
    goto switch_break;
    case_111: /* CIL Label */ 
    {
    {
#line 152
    tmp___0 = __ctype_b_loc();
    }
    }
#line 152
    if ((int const   )*(*tmp___0 + (int )*scan) & 2048) {
#line 152
      if ((int )*scan >= 56) {
        {
        {
#line 152
        panic((char *)"Error in number", long_int, (char *)((void *)0));
        }
        }
      }
    } else {
      {
      {
#line 152
      panic((char *)"Error in number", long_int, (char *)((void *)0));
      }
      }
    }
#line 153
    goto switch_break;
    case_120: /* CIL Label */ 
    {
    {
#line 155
    tmp___1 = __ctype_b_loc();
    }
    }
#line 155
    if (! ((int const   )*(*tmp___1 + (int )*scan) & 4096)) {
      {
      {
#line 155
      panic((char *)"Error in number", long_int, (char *)((void *)0));
      }
      }
    }
#line 156
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 158
    scan ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 161
  tmp___2 = sscanf((char const   */* __restrict  */)long_int, (char const   */* __restrict  */)"%lli",
                   & l);
  }
  }
#line 161
  if (tmp___2 != 1) {
    {
    {
#line 163
    panic((char *)"Error in number", long_int, (char *)((void *)0));
    }
    }
  }
#line 165
  return (l);
}
}
#line 170 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
unsigned char *parse_string(char *string___3 , off_t *length ) 
{ 
  char *p ;
  int j ;
  int k ;
  int i ;
  int min_len ;
  unsigned char buf[16385] ;
  char num[5] ;
  unsigned char *ret ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  void *tmp___14 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 174
  i = 0;
#line 180
  p = string___3;
  {
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((int )*p != 0)) {
#line 182
      goto while_break;
    }
#line 184
    if ((int )*p == 92) {
      {
#line 186
      p ++;
      {
#line 187
      tmp___12 = strchr("\\;abtnvfr", (int )*p);
      }
      }
#line 187
      if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
        {
#line 191
        if ((int )*p == 97) {
#line 191
          goto case_97;
        }
#line 194
        if ((int )*p == 98) {
#line 194
          goto case_98;
        }
#line 197
        if ((int )*p == 116) {
#line 197
          goto case_116;
        }
#line 200
        if ((int )*p == 110) {
#line 200
          goto case_110;
        }
#line 203
        if ((int )*p == 118) {
#line 203
          goto case_118;
        }
#line 206
        if ((int )*p == 102) {
#line 206
          goto case_102;
        }
#line 209
        if ((int )*p == 114) {
#line 209
          goto case_114;
        }
#line 212
        goto switch_default;
        case_97: /* CIL Label */ 
#line 192
        buf[i] = (unsigned char )'\a';
#line 193
        goto switch_break;
        case_98: /* CIL Label */ 
#line 195
        buf[i] = (unsigned char )'\b';
#line 196
        goto switch_break;
        case_116: /* CIL Label */ 
#line 198
        buf[i] = (unsigned char )'\t';
#line 199
        goto switch_break;
        case_110: /* CIL Label */ 
#line 201
        buf[i] = (unsigned char )'\n';
#line 202
        goto switch_break;
        case_118: /* CIL Label */ 
#line 204
        buf[i] = (unsigned char )'\v';
#line 205
        goto switch_break;
        case_102: /* CIL Label */ 
#line 207
        buf[i] = (unsigned char )'\f';
#line 208
        goto switch_break;
        case_114: /* CIL Label */ 
#line 210
        buf[i] = (unsigned char )'\r';
#line 211
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 213
        buf[i] = (unsigned char )*p;
        switch_break: /* CIL Label */ ;
        }
#line 215
        p ++;
      } else {
#line 218
        j = 0;
        {
#line 222
        if ((int )*p == 88) {
#line 222
          goto case_88;
        }
#line 222
        if ((int )*p == 120) {
#line 222
          goto case_88;
        }
#line 228
        if ((int )*p == 48) {
#line 228
          goto case_48;
        }
#line 232
        goto switch_default___0;
        case_88: /* CIL Label */ 
        case_120: /* CIL Label */ 
#line 223
        tmp = j;
#line 223
        j ++;
#line 223
        num[tmp] = (char )'0';
#line 224
        tmp___0 = j;
#line 224
        j ++;
#line 224
        tmp___1 = p;
#line 224
        p ++;
#line 224
        num[tmp___0] = *tmp___1;
        {
        {
#line 225
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
          {
#line 225
          tmp___4 = __ctype_b_loc();
          }
          }
#line 225
          if ((int const   )*(*tmp___4 + (int )*p) & 4096) {
#line 225
            if (! (j < 4)) {
#line 225
              goto while_break___0;
            }
          } else {
#line 225
            goto while_break___0;
          }
#line 225
          tmp___2 = j;
#line 225
          j ++;
#line 225
          tmp___3 = p;
#line 225
          p ++;
#line 225
          num[tmp___2] = *tmp___3;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 226
        min_len = 3;
#line 227
        goto switch_break___0;
        case_48: /* CIL Label */ 
        {
        {
#line 229
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
          {
          {
#line 229
          tmp___7 = __ctype_b_loc();
          }
          }
#line 229
          if ((int const   )*(*tmp___7 + (int )*p) & 2048) {
#line 229
            if ((int )*p < 56) {
#line 229
              if (! (j < 4)) {
#line 229
                goto while_break___1;
              }
            } else {
#line 229
              goto while_break___1;
            }
          } else {
#line 229
            goto while_break___1;
          }
#line 229
          tmp___5 = j;
#line 229
          j ++;
#line 229
          tmp___6 = p;
#line 229
          p ++;
#line 229
          num[tmp___5] = *tmp___6;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 230
        min_len = 1;
#line 231
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
        {
#line 233
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
          {
          {
#line 233
          tmp___10 = __ctype_b_loc();
          }
          }
#line 233
          if ((int const   )*(*tmp___10 + (int )*p) & 2048) {
#line 233
            if (! (j < 3)) {
#line 233
              goto while_break___2;
            }
          } else {
#line 233
            goto while_break___2;
          }
#line 233
          tmp___8 = j;
#line 233
          j ++;
#line 233
          tmp___9 = p;
#line 233
          p ++;
#line 233
          num[tmp___8] = *tmp___9;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 234
        min_len = 1;
#line 235
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 237
        num[j] = (char)0;
        {
#line 238
        tmp___11 = sscanf((char const   */* __restrict  */)(num), (char const   */* __restrict  */)"%i",
                          & k);
        }
        }
#line 238
        if (tmp___11 != 1) {
          {
          {
#line 240
          panic((char *)"Syntax error in escape code", string___3, (char *)((void *)0));
          }
          }
        } else
#line 238
        if (j < min_len) {
          {
          {
#line 240
          panic((char *)"Syntax error in escape code", string___3, (char *)((void *)0));
          }
          }
        }
#line 242
        if (k < 0) {
          {
          {
#line 244
          panic((char *)"Escape code not in range (0-255)", string___3, (char *)((void *)0));
          }
          }
        } else
#line 242
        if (k > 255) {
          {
          {
#line 244
          panic((char *)"Escape code not in range (0-255)", string___3, (char *)((void *)0));
          }
          }
        }
#line 246
        buf[i] = (unsigned char )k;
      }
    } else {
#line 250
      tmp___13 = p;
#line 250
      p ++;
#line 250
      buf[i] = (unsigned char )*tmp___13;
    }
#line 252
    if (i > 16384) {
      {
      {
#line 254
      panic((char *)"string too long", string___3, (char *)((void *)0));
      }
      }
    }
#line 256
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if (i) {
    {
    {
#line 260
    tmp___14 = xmalloc((size_t )i);
    }
#line 260
    ret = (unsigned char *)tmp___14;
    {
#line 261
    memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)(buf), (size_t )i);
    }
    }
  } else {
#line 264
    ret = (unsigned char *)((void *)0);
  }
#line 266
  *length = (off_t )i;
#line 267
  return (ret);
}
}
#line 272 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static void parse_block(char *bs ) 
{ 
  char slash_char ;
  char *p ;
  int i ;
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  unsigned short const   **tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  unsigned short const   **tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  unsigned short const   **tmp___30 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 276
  p = bs;
#line 277
  i = 0;
  {
#line 280
  tmp = strlen((char const   *)bs);
  }
  }
#line 280
  if (tmp > 131072U) {
    {
    {
#line 282
    panic((char *)"Block definition too long", (char *)((void *)0), (char *)((void *)0));
    }
    }
  }
  {
  {
#line 285
  tmp___0 = xmalloc((size_t )131072);
  }
#line 285
  buf = (char *)tmp___0;
  }
#line 287
  if ((int )*p == 58) {
#line 289
    block.start.S.length = (off_t )0;
#line 290
    block.type |= 2;
  } else
#line 293
  if ((int )*p == 120) {
#line 293
    goto _L;
  } else
#line 293
  if ((int )*p == 88) {
#line 293
    goto _L;
  } else {
    {
    {
#line 293
    tmp___15 = __ctype_b_loc();
    }
    }
#line 293
    if ((int const   )*(*tmp___15 + (int )*p) & 2048) {
      _L: /* CIL Label */ 
      {
#line 298
      if ((int )*p == 88) {
#line 298
        goto case_88;
      }
#line 298
      if ((int )*p == 120) {
#line 298
        goto case_88;
      }
#line 303
      if ((int )*p == 48) {
#line 303
        goto case_48;
      }
#line 306
      goto switch_default;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
#line 299
      tmp___1 = i;
#line 299
      i ++;
#line 299
      *(buf + tmp___1) = (char )'0';
#line 300
      tmp___2 = i;
#line 300
      i ++;
#line 300
      tmp___3 = p;
#line 300
      p ++;
#line 300
      *(buf + tmp___2) = *tmp___3;
      {
      {
#line 301
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 301
        tmp___6 = __ctype_b_loc();
        }
        }
#line 301
        if (! ((int const   )*(*tmp___6 + (int )*p) & 4096)) {
#line 301
          goto while_break;
        }
#line 301
        tmp___4 = i;
#line 301
        i ++;
#line 301
        tmp___5 = p;
#line 301
        p ++;
#line 301
        *(buf + tmp___4) = *tmp___5;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 302
      goto switch_break;
      case_48: /* CIL Label */ 
      {
      {
#line 304
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 304
        tmp___9 = __ctype_b_loc();
        }
        }
#line 304
        if ((int const   )*(*tmp___9 + (int )*p) & 2048) {
#line 304
          if (! ((int )*p < 56)) {
#line 304
            goto while_break___0;
          }
        } else {
#line 304
          goto while_break___0;
        }
#line 304
        tmp___7 = i;
#line 304
        i ++;
#line 304
        tmp___8 = p;
#line 304
        p ++;
#line 304
        *(buf + tmp___7) = *tmp___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 305
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 307
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 307
        tmp___12 = __ctype_b_loc();
        }
        }
#line 307
        if (! ((int const   )*(*tmp___12 + (int )*p) & 2048)) {
#line 307
          goto while_break___1;
        }
#line 307
        tmp___10 = i;
#line 307
        i ++;
#line 307
        tmp___11 = p;
#line 307
        p ++;
#line 307
        *(buf + tmp___10) = *tmp___11;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 308
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 311
      *(buf + i) = (char)0;
      {
#line 312
      block.start.N = parse_long(buf);
      }
#line 313
      block.type |= 1;
      }
    } else {
#line 316
      slash_char = *p;
#line 317
      p ++;
      {
      {
#line 318
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 318
        if ((int )*p != (int )slash_char) {
#line 318
          if (! ((int )*p != 0)) {
#line 318
            goto while_break___2;
          }
        } else {
#line 318
          goto while_break___2;
        }
#line 318
        tmp___13 = i;
#line 318
        i ++;
#line 318
        tmp___14 = p;
#line 318
        p ++;
#line 318
        *(buf + tmp___13) = *tmp___14;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 319
      if ((int )*p == (int )slash_char) {
#line 319
        p ++;
      }
      {
#line 320
      *(buf + i) = (char)0;
      {
#line 321
      block.start.S.string = parse_string(buf, & block.start.S.length);
      }
#line 322
      block.type |= 2;
      }
    }
  }
#line 326
  if ((int )*p != 58) {
    {
    {
#line 328
    panic((char *)"Error in block definition", bs, (char *)((void *)0));
    }
    }
  }
#line 331
  p ++;
#line 333
  if ((int )*p == 0) {
#line 335
    block.stop.S.length = (off_t )0;
#line 336
    block.type |= 8;
  } else {
#line 339
    i = 0;
#line 340
    if ((int )*p == 120) {
#line 340
      goto _L___0;
    } else
#line 340
    if ((int )*p == 88) {
#line 340
      goto _L___0;
    } else {
      {
      {
#line 340
      tmp___30 = __ctype_b_loc();
      }
      }
#line 340
      if ((int const   )*(*tmp___30 + (int )*p) & 4096) {
        _L___0: /* CIL Label */ 
        {
#line 345
        if ((int )*p == 88) {
#line 345
          goto case_88___0;
        }
#line 345
        if ((int )*p == 120) {
#line 345
          goto case_88___0;
        }
#line 350
        if ((int )*p == 48) {
#line 350
          goto case_48___0;
        }
#line 353
        goto switch_default___0;
        case_88___0: /* CIL Label */ 
        case_120___0: /* CIL Label */ 
#line 346
        tmp___16 = i;
#line 346
        i ++;
#line 346
        *(buf + tmp___16) = (char )'0';
#line 347
        tmp___17 = i;
#line 347
        i ++;
#line 347
        tmp___18 = p;
#line 347
        p ++;
#line 347
        *(buf + tmp___17) = *tmp___18;
        {
        {
#line 348
        while (1) {
          while_continue___11: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
          {
          {
#line 348
          tmp___21 = __ctype_b_loc();
          }
          }
#line 348
          if (! ((int const   )*(*tmp___21 + (int )*p) & 4096)) {
#line 348
            goto while_break___3;
          }
#line 348
          tmp___19 = i;
#line 348
          i ++;
#line 348
          tmp___20 = p;
#line 348
          p ++;
#line 348
          *(buf + tmp___19) = *tmp___20;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 349
        goto switch_break___0;
        case_48___0: /* CIL Label */ 
        {
        {
#line 351
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
          {
          {
#line 351
          tmp___24 = __ctype_b_loc();
          }
          }
#line 351
          if ((int const   )*(*tmp___24 + (int )*p) & 2048) {
#line 351
            if (! ((int )*p < 56)) {
#line 351
              goto while_break___4;
            }
          } else {
#line 351
            goto while_break___4;
          }
#line 351
          tmp___22 = i;
#line 351
          i ++;
#line 351
          tmp___23 = p;
#line 351
          p ++;
#line 351
          *(buf + tmp___22) = *tmp___23;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 352
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
        {
#line 354
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
          {
          {
#line 354
          tmp___27 = __ctype_b_loc();
          }
          }
#line 354
          if (! ((int const   )*(*tmp___27 + (int )*p) & 2048)) {
#line 354
            goto while_break___5;
          }
#line 354
          tmp___25 = i;
#line 354
          i ++;
#line 354
          tmp___26 = p;
#line 354
          p ++;
#line 354
          *(buf + tmp___25) = *tmp___26;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 355
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 357
        *(buf + i) = (char)0;
        {
#line 358
        block.stop.M = parse_long(buf);
        }
        }
#line 359
        if (block.stop.M == 0LL) {
          {
          {
#line 359
          panic((char *)"Block length must be greater than zero", (char *)((void *)0),
                (char *)((void *)0));
          }
          }
        }
#line 360
        block.type |= 4;
      } else
#line 363
      if ((int )*p == 36) {
#line 365
        block.stop.S.length = (off_t )0;
#line 366
        p ++;
      } else {
#line 369
        slash_char = *p;
#line 370
        p ++;
        {
        {
#line 371
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 371
          if ((int )*p != (int )slash_char) {
#line 371
            if (! ((int )*p != 0)) {
#line 371
              goto while_break___6;
            }
          } else {
#line 371
            goto while_break___6;
          }
#line 371
          tmp___28 = i;
#line 371
          i ++;
#line 371
          tmp___29 = p;
#line 371
          p ++;
#line 371
          *(buf + tmp___28) = *tmp___29;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 372
        if ((int )*p == (int )slash_char) {
#line 374
          p ++;
        } else {
          {
          {
#line 377
          panic((char *)"syntax error in block definition", bs, (char *)((void *)0));
          }
          }
        }
        {
#line 379
        *(buf + i) = (char)0;
        {
#line 380
        block.stop.S.string = parse_string(buf, & block.stop.S.length);
        }
#line 381
        block.type |= 8;
        }
      }
    }
  }
#line 385
  if ((int )*p != 0) {
    {
    {
#line 387
    panic((char *)"syntax error in block definition", bs, (char *)((void *)0));
    }
    }
  }
  {
  {
#line 389
  free((void *)buf);
  }
  }
#line 390
  return;
}
}
#line 393 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void parse_command(char *command_string ) 
{ 
  struct command_list *curr ;
  struct command_list *new ;
  struct command_list **start ;
  char *c ;
  char *p ;
  char *buf ;
  char *f ;
  char *token[10] ;
  char slash_char ;
  int i ;
  int j ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  void *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;

  {
#line 404
  p = command_string;
  {
  {
#line 405
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 405
    tmp = __ctype_b_loc();
    }
    }
#line 405
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 405
      goto while_break;
    }
#line 405
    p ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if ((int )*(p + 0) == 0) {
#line 406
    return;
  }
#line 407
  if ((int )*(p + 0) == 35) {
#line 407
    return;
  }
  {
  {
#line 409
  c = xstrdup(p);
  }
#line 411
  i = 0;
  {
#line 412
  token[i] = strtok((char */* __restrict  */)c, (char const   */* __restrict  */)" \t\n");
  }
#line 413
  i ++;
  }
  {
  {
#line 414
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 414
    if ((unsigned long )token[i - 1] != (unsigned long )((void *)0)) {
#line 414
      if (! (i < 10)) {
#line 414
        goto while_break___0;
      }
    } else {
#line 414
      goto while_break___0;
    }
    {
#line 414
    tmp___0 = i;
#line 414
    i ++;
    {
#line 414
    token[tmp___0] = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 415
  i --;
  {
#line 417
  tmp___3 = strchr("DIJLFBN>", (int )*(token[0] + 0));
  }
  }
#line 417
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 419
    curr = cmds.block_start;
#line 420
    start = & cmds.block_start;
  } else {
    {
    {
#line 421
    tmp___2 = strchr("acdirsywjpl&|^~ufx", (int )*(token[0] + 0));
    }
    }
#line 421
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 423
      curr = cmds.byte;
#line 424
      start = & cmds.byte;
    } else {
      {
      {
#line 425
      tmp___1 = strchr("A<", (int )*(token[0] + 0));
      }
      }
#line 425
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 427
        curr = cmds.block_end;
#line 428
        start = & cmds.block_end;
      } else {
        {
        {
#line 431
        panic((char *)"Error in command", command_string, (char *)((void *)0));
        }
        }
      }
    }
  }
#line 434
  if ((unsigned long )curr != (unsigned long )((void *)0)) {
    {
    {
#line 436
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 436
      if (! ((unsigned long )curr->next != (unsigned long )((void *)0))) {
#line 436
        goto while_break___1;
      }
#line 436
      curr = curr->next;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  {
#line 438
  tmp___4 = xmalloc((size_t )sizeof(struct command_list ));
  }
#line 438
  new = (struct command_list *)tmp___4;
#line 439
  new->next = (struct command_list *)((void *)0);
  }
#line 440
  if ((unsigned long )curr == (unsigned long )((void *)0)) {
#line 442
    *start = new;
  } else {
#line 445
    curr->next = new;
  }
#line 449
  new->letter = *(token[0] + 0);
  {
#line 452
  if ((int )new->letter == 68) {
#line 452
    goto case_68;
  }
#line 464
  if ((int )new->letter == 73) {
#line 464
    goto case_73;
  }
#line 464
  if ((int )new->letter == 65) {
#line 464
    goto case_73;
  }
#line 470
  if ((int )new->letter == 62) {
#line 470
    goto case_62;
  }
#line 470
  if ((int )new->letter == 60) {
#line 470
    goto case_62;
  }
#line 470
  if ((int )new->letter == 119) {
#line 470
    goto case_62;
  }
#line 475
  if ((int )new->letter == 74) {
#line 475
    goto case_74;
  }
#line 475
  if ((int )new->letter == 106) {
#line 475
    goto case_74;
  }
#line 480
  if ((int )new->letter == 76) {
#line 480
    goto case_76;
  }
#line 480
  if ((int )new->letter == 108) {
#line 480
    goto case_76;
  }
#line 485
  if ((int )new->letter == 105) {
#line 485
    goto case_105;
  }
#line 485
  if ((int )new->letter == 114) {
#line 485
    goto case_105;
  }
#line 490
  if ((int )new->letter == 100) {
#line 490
    goto case_100;
  }
#line 503
  if ((int )new->letter == 99) {
#line 503
    goto case_99;
  }
#line 518
  if ((int )new->letter == 121) {
#line 518
    goto case_121;
  }
#line 518
  if ((int )new->letter == 115) {
#line 518
    goto case_121;
  }
#line 547
  if ((int )new->letter == 66) {
#line 547
    goto case_66;
  }
#line 547
  if ((int )new->letter == 70) {
#line 547
    goto case_66;
  }
#line 549
  if ((int )new->letter == 112) {
#line 549
    goto case_112;
  }
#line 567
  if ((int )new->letter == 78) {
#line 567
    goto case_78;
  }
#line 572
  if ((int )new->letter == 94) {
#line 572
    goto case_94;
  }
#line 572
  if ((int )new->letter == 124) {
#line 572
    goto case_94;
  }
#line 572
  if ((int )new->letter == 38) {
#line 572
    goto case_94;
  }
#line 578
  if ((int )new->letter == 120) {
#line 578
    goto case_120;
  }
#line 578
  if ((int )new->letter == 126) {
#line 578
    goto case_120;
  }
#line 582
  if ((int )new->letter == 102) {
#line 582
    goto case_102;
  }
#line 582
  if ((int )new->letter == 117) {
#line 582
    goto case_102;
  }
#line 588
  goto switch_default;
  case_68: /* CIL Label */ 
#line 453
  if (i < 1) {
    {
    {
#line 453
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else
#line 453
  if (i > 2) {
    {
    {
#line 453
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 453
    tmp___5 = strlen((char const   *)token[0]);
    }
    }
#line 453
    if (tmp___5 > 1U) {
      {
      {
#line 453
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
#line 454
  if (i == 2) {
    {
    {
#line 456
    new->offset = parse_long(token[1]);
    }
    }
#line 457
    if (new->offset < 1LL) {
      {
      {
#line 457
      panic((char *)"n for D-command must be at least 1", (char *)((void *)0), (char *)((void *)0));
      }
      }
    }
  } else {
#line 460
    new->offset = (off_t )0;
  }
#line 462
  goto switch_break;
  case_73: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 465
  if (i != 2) {
    {
    {
#line 465
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 465
    tmp___6 = strlen((char const   *)token[0]);
    }
    }
#line 465
    if (tmp___6 > 1U) {
      {
      {
#line 465
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 466
  new->s1 = parse_string(token[1], & new->s1_len);
  }
  }
#line 467
  goto switch_break;
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_119: /* CIL Label */ 
#line 471
  if (i != 2) {
    {
    {
#line 471
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 471
    tmp___7 = strlen((char const   *)token[0]);
    }
    }
#line 471
    if (tmp___7 > 1U) {
      {
      {
#line 471
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 472
  tmp___8 = xstrdup(token[1]);
  }
#line 472
  new->s1 = (unsigned char *)tmp___8;
  }
#line 473
  goto switch_break;
  case_74: /* CIL Label */ 
  case_106: /* CIL Label */ 
#line 476
  if (i != 2) {
    {
    {
#line 476
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 476
    tmp___9 = strlen((char const   *)token[0]);
    }
    }
#line 476
    if (tmp___9 > 1U) {
      {
      {
#line 476
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 477
  new->count = parse_long(token[1]);
  }
  }
#line 478
  goto switch_break;
  case_76: /* CIL Label */ 
  case_108: /* CIL Label */ 
#line 481
  if (i != 2) {
    {
    {
#line 481
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 481
    tmp___10 = strlen((char const   *)token[0]);
    }
    }
#line 481
    if (tmp___10 > 1U) {
      {
      {
#line 481
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 482
  new->count = parse_long(token[1]);
  }
  }
#line 483
  goto switch_break;
  case_105: /* CIL Label */ 
  case_114: /* CIL Label */ 
#line 486
  if (i != 3) {
    {
    {
#line 486
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 486
    tmp___11 = strlen((char const   *)token[0]);
    }
    }
#line 486
    if (tmp___11 > 1U) {
      {
      {
#line 486
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 487
  new->offset = parse_long(token[1]);
  }
  {
#line 488
  new->s1 = parse_string(token[2], & new->s1_len);
  }
  }
#line 489
  goto switch_break;
  case_100: /* CIL Label */ 
#line 491
  if (i < 2) {
    {
    {
#line 491
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else
#line 491
  if (i > 3) {
    {
    {
#line 491
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 491
    tmp___12 = strlen((char const   *)token[0]);
    }
    }
#line 491
    if (tmp___12 > 1U) {
      {
      {
#line 491
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 492
  new->offset = parse_long(token[1]);
  }
  }
#line 494
  if ((int )*(token[2] + 0) == 42) {
#line 494
    if (! *(token[2] + 1)) {
#line 496
      new->count = (off_t )0;
    } else {
#line 494
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 499
    new->count = parse_long(token[2]);
    }
    }
#line 500
    if (new->count < 1LL) {
      {
      {
#line 500
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
#line 502
  goto switch_break;
  case_99: /* CIL Label */ 
#line 504
  if (i != 3) {
    {
    {
#line 504
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 504
    tmp___13 = strlen((char const   *)token[1]);
    }
    }
#line 504
    if (tmp___13 != 3U) {
      {
      {
#line 504
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    } else {
      {
      {
#line 504
      tmp___14 = strlen((char const   *)token[2]);
      }
      }
#line 504
      if (tmp___14 != 3U) {
        {
        {
#line 504
        panic((char *)"Error in command", command_string, (char *)((void *)0));
        }
        }
      } else {
        {
        {
#line 504
        tmp___15 = strlen((char const   *)token[0]);
        }
        }
#line 504
        if (tmp___15 > 1U) {
          {
          {
#line 504
          panic((char *)"Error in command", command_string, (char *)((void *)0));
          }
          }
        }
      }
    }
  }
  {
  {
#line 505
  tmp___16 = strlen((char const   *)token[1]);
  }
  {
#line 505
  tmp___17 = strlen((char const   *)token[2]);
  }
  {
#line 505
  tmp___18 = xmalloc((tmp___16 + tmp___17) + 2U);
  }
#line 505
  new->s1 = (unsigned char *)tmp___18;
  {
#line 506
  strcpy((char */* __restrict  */)new->s1, (char const   */* __restrict  */)token[1]);
  }
  {
#line 507
  strcat((char */* __restrict  */)new->s1, (char const   */* __restrict  */)token[2]);
  }
#line 508
  j = 0;
  }
  {
  {
#line 509
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 509
    if (! ((int )*(new->s1 + j) != 0)) {
#line 509
      goto while_break___2;
    }
    {
    {
#line 510
    tmp___19 = toupper((int )*(new->s1 + j));
    }
#line 510
    *(new->s1 + j) = (unsigned char )tmp___19;
#line 511
    j ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 513
  j = 0;
  {
  {
#line 514
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 514
    if ((int )*(convert_strings[j]) != 0) {
      {
      {
#line 514
      tmp___20 = strcmp((char const   *)convert_strings[j], (char const   *)new->s1);
      }
      }
#line 514
      if (! (tmp___20 != 0)) {
#line 514
        goto while_break___3;
      }
    } else {
#line 514
      goto while_break___3;
    }
#line 514
    j ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 515
  if ((int )*(convert_strings[j]) == 0) {
    {
    {
#line 515
    panic((char *)"Unknown conversion", command_string, (char *)((void *)0));
    }
    }
  }
#line 516
  goto switch_break;
  case_121: /* CIL Label */ 
  case_115: /* CIL Label */ 
  {
  {
#line 519
  tmp___21 = strlen((char const   *)command_string);
  }
  }
#line 519
  if (tmp___21 < 4U) {
    {
    {
#line 519
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
  {
  {
#line 521
  tmp___22 = xmalloc((size_t )65537);
  }
#line 521
  buf = (char *)tmp___22;
#line 523
  slash_char = *(command_string + 1);
#line 524
  p = command_string;
#line 525
  p += 2;
#line 526
  j = 0;
  }
  {
  {
#line 527
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 527
    if ((int )*p != 0) {
#line 527
      if ((int )*p != (int )slash_char) {
#line 527
        if (! (j < 65536)) {
#line 527
          goto while_break___4;
        }
      } else {
#line 527
        goto while_break___4;
      }
    } else {
#line 527
      goto while_break___4;
    }
#line 527
    tmp___23 = j;
#line 527
    j ++;
#line 527
    tmp___24 = p;
#line 527
    p ++;
#line 527
    *(buf + tmp___23) = *tmp___24;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 528
  if ((int )*p != (int )slash_char) {
    {
    {
#line 528
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
  {
#line 529
  *(buf + j) = (char)0;
  {
#line 530
  new->s1 = parse_string(buf, & new->s1_len);
  }
  }
#line 531
  if (new->s1_len > 16384LL) {
    {
    {
#line 531
    panic((char *)"String in command too long", command_string, (char *)((void *)0));
    }
    }
  }
#line 532
  if (new->s1_len == 0LL) {
    {
    {
#line 532
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
#line 534
  p ++;
#line 536
  j = 0;
  {
  {
#line 537
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 537
    if ((int )*p != 0) {
#line 537
      if ((int )*p != (int )slash_char) {
#line 537
        if (! (j < 65536)) {
#line 537
          goto while_break___5;
        }
      } else {
#line 537
        goto while_break___5;
      }
    } else {
#line 537
      goto while_break___5;
    }
#line 537
    tmp___25 = j;
#line 537
    j ++;
#line 537
    tmp___26 = p;
#line 537
    p ++;
#line 537
    *(buf + tmp___25) = *tmp___26;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 538
  *(buf + j) = (char)0;
#line 539
  if ((int )*p != (int )slash_char) {
    {
    {
#line 539
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
  {
  {
#line 540
  new->s2 = parse_string(buf, & new->s2_len);
  }
  }
#line 541
  if (new->s2_len > 16384LL) {
    {
    {
#line 541
    panic((char *)"String in command too long", command_string, (char *)((void *)0));
    }
    }
  }
#line 543
  if ((int )new->letter == 121) {
#line 543
    if (new->s1_len != new->s2_len) {
      {
      {
#line 543
      panic((char *)"Strings in y-command must have equal length", command_string,
            (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 544
  free((void *)buf);
  }
  }
#line 545
  goto switch_break;
  case_66: /* CIL Label */ 
  case_70: /* CIL Label */ 
#line 548
  if (i > 1) {
    {
    {
#line 548
    tmp___27 = strlen((char const   *)token[1]);
    }
    }
#line 548
    if (tmp___27 != 1U) {
      {
      {
#line 548
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  case_112: /* CIL Label */ 
#line 550
  if (i != 2) {
    {
    {
#line 550
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 550
    tmp___28 = strlen((char const   *)token[0]);
    }
    }
#line 550
    if (tmp___28 > 1U) {
      {
      {
#line 550
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 551
  new->s1 = parse_string(token[1], & new->s1_len);
  }
#line 552
  j = 0;
  }
  {
  {
#line 553
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 553
    if (! ((int )*(new->s1 + j) != 0)) {
#line 553
      goto while_break___6;
    }
    {
    {
#line 554
    tmp___29 = toupper((int )*(new->s1 + j));
    }
#line 554
    *(new->s1 + j) = (unsigned char )tmp___29;
#line 555
    j ++;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 557
  if ((int )new->letter == 112) {
#line 559
    f = p_formats;
  } else {
#line 562
    f = FB_formats;
  }
  {
  {
#line 564
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 564
    if ((int )*f != 0) {
      {
      {
#line 564
      tmp___30 = strchr((char const   *)new->s1, (int )*f);
      }
      }
#line 564
      if (! ((unsigned long )tmp___30 == (unsigned long )((void *)0))) {
#line 564
        goto while_break___7;
      }
    } else {
#line 564
      goto while_break___7;
    }
#line 564
    f ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 565
  if ((int )*f == 0) {
    {
    {
#line 565
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
#line 566
  goto switch_break;
  case_78: /* CIL Label */ 
#line 568
  if (i != 1) {
    {
    {
#line 568
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 568
    tmp___31 = strlen((char const   *)token[0]);
    }
    }
#line 568
    if (tmp___31 > 1U) {
      {
      {
#line 568
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
#line 569
  goto switch_break;
  case_94: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_38: /* CIL Label */ 
#line 573
  if (i != 2) {
    {
    {
#line 573
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 573
    tmp___32 = strlen((char const   *)token[0]);
    }
    }
#line 573
    if (tmp___32 > 1U) {
      {
      {
#line 573
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 574
  new->s1 = parse_string(token[1], & new->s1_len);
  }
  }
#line 575
  if (new->s1_len != 1LL) {
    {
    {
#line 575
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
#line 576
  goto switch_break;
  case_120: /* CIL Label */ 
  case_126: /* CIL Label */ 
#line 579
  if (i != 1) {
    {
    {
#line 579
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 579
    tmp___33 = strlen((char const   *)token[0]);
    }
    }
#line 579
    if (tmp___33 > 1U) {
      {
      {
#line 579
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
#line 580
  goto switch_break;
  case_102: /* CIL Label */ 
  case_117: /* CIL Label */ 
#line 583
  if (i != 3) {
    {
    {
#line 583
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  } else {
    {
    {
#line 583
    tmp___34 = strlen((char const   *)token[0]);
    }
    }
#line 583
    if (tmp___34 > 1U) {
      {
      {
#line 583
      panic((char *)"Error in command", command_string, (char *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 584
  new->offset = parse_long(token[1]);
  }
  {
#line 585
  new->s1 = parse_string(token[2], & new->s1_len);
  }
  }
#line 586
  if (new->s1_len != 1LL) {
    {
    {
#line 586
    panic((char *)"Error in command", command_string, (char *)((void *)0));
    }
    }
  }
#line 587
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 589
  panic((char *)"Unknown command", command_string, (char *)((void *)0));
  }
  }
#line 590
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 592
  free((void *)c);
  }
  }
#line 593
  return;
}
}
#line 598 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void parse_commands(char *command_string ) 
{ 
  char *c ;
  char *start ;
  int inside_d ;
  int inside_s ;

  {
#line 603
  inside_d = 0;
#line 604
  inside_s = 0;
#line 606
  c = command_string;
#line 607
  start = c;
  {
  {
#line 609
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 609
    if (! ((int )*start != 0)) {
#line 609
      goto while_break;
    }
    {
#line 613
    if ((int )*c == 92) {
#line 613
      goto case_92;
    }
#line 616
    if ((int )*c == 34) {
#line 616
      goto case_34;
    }
#line 625
    if ((int )*c == 39) {
#line 625
      goto case_39;
    }
#line 634
    if ((int )*c == 59) {
#line 634
      goto case_59;
    }
#line 642
    if ((int )*c == 0) {
#line 642
      goto case_0;
    }
#line 611
    goto switch_break;
    case_92: /* CIL Label */ 
#line 614
    c ++;
#line 615
    goto switch_break;
    case_34: /* CIL Label */ 
#line 617
    if (inside_d) {
#line 619
      inside_d --;
    } else {
#line 622
      inside_d ++;
    }
#line 624
    goto switch_break;
    case_39: /* CIL Label */ 
#line 626
    if (inside_s) {
#line 628
      inside_s --;
    } else {
#line 631
      inside_s ++;
    }
#line 633
    goto switch_break;
    case_59: /* CIL Label */ 
#line 635
    if (! inside_d) {
#line 635
      if (! inside_s) {
        {
#line 637
        *c = (char)0;
        {
#line 638
        parse_command(start);
        }
#line 639
        start = c + 1;
        }
      }
    }
#line 641
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 643
    parse_command(start);
    }
#line 644
    start = c;
    }
#line 645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 647
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return;
}
}
#line 655 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void parse_command_file(char *file___1 ) 
{ 
  FILE *fp ;
  char *line ;
  char *info ;
  size_t line_len ;
  int line_no ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  __ssize_t tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 661
  line_len = (size_t )8192;
#line 662
  line_no = 0;
  {
#line 664
  tmp = xmalloc(line_len);
  }
#line 664
  line = (char *)tmp;
  {
#line 665
  tmp___0 = strlen((char const   *)file___1);
  }
  {
#line 665
  tmp___1 = xmalloc(tmp___0 + 100U);
  }
#line 665
  info = (char *)tmp___1;
  {
#line 667
  fp = fopen((char const   */* __restrict  */)file___1, (char const   */* __restrict  */)"r");
  }
  }
#line 668
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 668
    tmp___2 = __errno_location();
    }
    {
#line 668
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 668
    panic((char *)"Error in opening file", file___1, tmp___3);
    }
    }
  }
  {
  {
#line 671
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 671
    tmp___4 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& line_len),
                      (FILE */* __restrict  */)fp);
    }
    }
#line 671
    if (! (tmp___4 != -1)) {
#line 671
      goto while_break;
    }
    {
#line 676
    line_no ++;
    {
#line 677
    sprintf((char */* __restrict  */)info, (char const   */* __restrict  */)"Error in file \'%s\' in line %d\n",
            file___1, line_no);
    }
#line 678
    panic_info = info;
    {
#line 679
    parse_commands(line);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 682
  free((void *)line);
  }
  {
#line 683
  free((void *)info);
  }
  {
#line 684
  fclose(fp);
  }
#line 685
  panic_info = (char *)((void *)0);
  }
#line 686
  return;
}
}
#line 688 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void help(FILE *stream ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 691
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Usage: %s [OPTION]...\n\n",
          program);
  }
  {
#line 693
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-b, --block=BLOCK\n");
  }
  {
#line 694
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tBlock definition.\n");
  }
  {
#line 695
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-e, --expression=COMMAND\n");
  }
  {
#line 696
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tAdd command to the commands to be executed.\n");
  }
  {
#line 697
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-f, --file=script-file\n");
  }
  {
#line 698
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tAdd commands from script-file to the commands to be executed.\n");
  }
  {
#line 699
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-o, --output=name\n");
  }
  {
#line 700
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tWrite output to name instead of standard output.\n");
  }
  {
#line 701
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-s, --suppress\n");
  }
  {
#line 702
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tSuppress normal output, print only block contents.\n");
  }
  {
#line 703
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-?, --help\n");
  }
  {
#line 704
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tDisplay this help and exit.\n");
  }
  {
#line 705
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-V, --version\n");
  }
  {
#line 721
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tShow version and exit.\n");
  }
  {
#line 722
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nAll remaining arguments are names of input files;\n");
  }
  {
#line 723
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"if no input files are specified, then the standard input is read.\n");
  }
  {
#line 724
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nSend bug reports to %s.\n",
          email_address);
  }
  }
#line 725
  return;
}
}
#line 727 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void usage(int opt ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 730
  printf((char const   */* __restrict  */)"Unknown option \'-%c\'\n", (int )((char )opt));
  }
  {
#line 731
  help(stderr);
  }
  }
#line 732
  return;
}
}
#line 734 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
void print_version(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 737
  printf((char const   */* __restrict  */)"%s version %s\n", program, version);
  }
  {
#line 738
  printf((char const   */* __restrict  */)"Copyright (c) 2005 Timo Savinen\n\n");
  }
  {
#line 739
  printf((char const   */* __restrict  */)"This is free software; see the source for copying conditions.\n");
  }
  {
#line 740
  printf((char const   */* __restrict  */)"There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
  }
#line 741
  return;
}
}
#line 744 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 749
  block.type = 0;
#line 750
  cmds.block_start = (struct command_list *)((void *)0);
#line 751
  cmds.byte = (struct command_list *)((void *)0);
#line 752
  cmds.block_end = (struct command_list *)((void *)0);
  {
  {
#line 754
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 754
    opt = getopt_long(argc, (char * const  *)argv, (char const   *)(short_opts), (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
    }
#line 754
    if (! (opt != -1)) {
#line 754
      goto while_break;
    }
    {
#line 761
    if (opt == 98) {
#line 761
      goto case_98;
    }
#line 765
    if (opt == 101) {
#line 765
      goto case_101;
    }
#line 768
    if (opt == 102) {
#line 768
      goto case_102;
    }
#line 771
    if (opt == 111) {
#line 771
      goto case_111;
    }
#line 774
    if (opt == 115) {
#line 774
      goto case_115;
    }
#line 777
    if (opt == 63) {
#line 777
      goto case_63;
    }
#line 781
    if (opt == 86) {
#line 781
      goto case_86;
    }
#line 785
    goto switch_default;
    case_98: /* CIL Label */ 
#line 762
    if (block.type) {
      {
      {
#line 762
      panic((char *)"Only one -b option allowed", (char *)((void *)0), (char *)((void *)0));
      }
      }
    }
    {
    {
#line 763
    parse_block(optarg);
    }
    }
#line 764
    goto switch_break;
    case_101: /* CIL Label */ 
    {
    {
#line 766
    parse_commands(optarg);
    }
    }
#line 767
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 769
    parse_command_file(optarg);
    }
    }
#line 770
    goto switch_break;
    case_111: /* CIL Label */ 
    {
    {
#line 772
    set_output_file(optarg);
    }
    }
#line 773
    goto switch_break;
    case_115: /* CIL Label */ 
#line 775
    output_only_block = 1;
#line 776
    goto switch_break;
    case_63: /* CIL Label */ 
    {
    {
#line 778
    help(stdout);
    }
    {
#line 779
    exit(0);
    }
    }
#line 780
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 782
    print_version();
    }
    {
#line 783
    exit(0);
    }
    }
#line 784
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 786
    usage(opt);
    }
    {
#line 787
    exit(1);
    }
    }
#line 788
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 791
  if (! block.type) {
    {
    {
#line 791
    parse_block((char *)"0:$");
    }
    }
  }
#line 792
  if ((unsigned long )out_stream.file == (unsigned long )((void *)0)) {
    {
    {
#line 792
    set_output_file((char *)((void *)0));
    }
    }
  }
#line 794
  if (optind < argc) {
    {
    {
#line 796
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 796
      if (! (optind < argc)) {
#line 796
        goto while_break___0;
      }
      {
#line 796
      tmp = optind;
#line 796
      optind ++;
      {
#line 796
      set_input_file(*(argv + tmp));
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 799
    set_input_file((char *)"-");
    }
    }
  }
  {
  {
#line 802
  init_buffer();
  }
  {
#line 803
  init_commands(& cmds);
  }
  {
#line 804
  execute_program(& cmds);
  }
  {
#line 805
  close_commands(& cmds);
  }
  {
#line 806
  exit(0);
  }
  }
}
}
#line 842 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 754
extern int fseeko(FILE *__stream , __off64_t __off , int __whence )  __asm__("fseeko64")  ;
#line 170 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
unsigned char read_byte(void) ;
#line 173
int get_next_byte(void) ;
#line 179
int find_block(void) ;
#line 182
int last_byte(void) ;
#line 185
void write_buffer(unsigned char *buf , off_t length ) ;
#line 188
void put_byte(unsigned char byte ) ;
#line 191
void write_next_byte(void) ;
#line 194
void flush_buffer(void) ;
#line 203
void close_output_stream(void) ;
#line 206
void write_w_command(unsigned char *buf , size_t length ) ;
#line 212
void write_string(char *string___3 ) ;
#line 215
char *get_current_file(void) ;
#line 218
unsigned char *read_pos(void) ;
#line 221
unsigned char *block_end_pos(void) ;
#line 231
struct input_buffer in_buffer ;
#line 232
struct output_buffer out_buffer ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 33 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int delete_this_byte  ;
#line 36 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int delete_this_block  ;
#line 39 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int skip_this_block  ;
#line 42 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int inserting  ;
#line 47 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int w_commands_block_num  =    0;
#line 50 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static struct command_list *current_byte_commands  ;
#line 62 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static char string[128]  ;
#line 59 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
char *byte_to_string(unsigned char byte , char format ) 
{ 
  int i ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 67
  if ((int )format == 72) {
#line 67
    goto case_72;
  }
#line 70
  if ((int )format == 68) {
#line 70
    goto case_68;
  }
#line 73
  if ((int )format == 79) {
#line 73
    goto case_79;
  }
#line 76
  if ((int )format == 65) {
#line 76
    goto case_65;
  }
#line 79
  if ((int )format == 66) {
#line 79
    goto case_66;
  }
#line 88
  goto switch_default;
  case_72: /* CIL Label */ 
  {
  {
#line 68
  sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"x%02x",
          (int )byte);
  }
  }
#line 69
  goto switch_break;
  case_68: /* CIL Label */ 
  {
  {
#line 71
  sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"%3d",
          (int )byte);
  }
  }
#line 72
  goto switch_break;
  case_79: /* CIL Label */ 
  {
  {
#line 74
  sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"%03o",
          (int )byte);
  }
  }
#line 75
  goto switch_break;
  case_65: /* CIL Label */ 
  {
  {
#line 77
  tmp___1 = __ctype_b_loc();
  }
  }
#line 77
  if ((int const   )*(*tmp___1 + (int )byte) & 16384) {
#line 77
    tmp___0 = (int )byte;
  } else {
#line 77
    tmp___0 = ' ';
  }
  {
  {
#line 77
  sprintf((char */* __restrict  */)(string), (char const   */* __restrict  */)"%c",
          tmp___0);
  }
  }
#line 78
  goto switch_break;
  case_66: /* CIL Label */ 
#line 80
  i = 0;
  {
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (((1 << (sizeof(unsigned char ) * 8UL - 1UL)) >> i) & (int )byte) {
#line 83
      string[i] = (char )'1';
    } else {
#line 83
      string[i] = (char )'0';
    }
#line 84
    i ++;
#line 81
    if (! ((1 << (sizeof(unsigned char ) * 8UL - 1UL)) >> i)) {
#line 81
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  string[i] = (char)0;
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 89
  string[0] = (char)0;
#line 90
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 92
  return (string);
}
}
#line 99 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static char string___0[128]  ;
#line 96 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
char *off_t_to_string(off_t number , char format ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 103
  if ((int )format == 72) {
#line 103
    goto case_72;
  }
#line 106
  if ((int )format == 68) {
#line 106
    goto case_68;
  }
#line 109
  if ((int )format == 79) {
#line 109
    goto case_79;
  }
#line 112
  goto switch_default;
  case_72: /* CIL Label */ 
  {
  {
#line 104
  sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)"x%llx",
          number);
  }
  }
#line 105
  goto switch_break;
  case_68: /* CIL Label */ 
  {
  {
#line 107
  sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)"%lld",
          number);
  }
  }
#line 108
  goto switch_break;
  case_79: /* CIL Label */ 
  {
  {
#line 110
  sprintf((char */* __restrict  */)(string___0), (char const   */* __restrict  */)"0%llo",
          number);
  }
  }
#line 111
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 113
  string___0[0] = (char)0;
#line 114
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 116
  return (string___0);
}
}
#line 132 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static unsigned char ioblock[8192]  ;
#line 124 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void execute_commands(struct command_list *c ) 
{ 
  register int i ;
  unsigned char a ;
  unsigned char b ;
  unsigned char *p ;
  char *str ;
  off_t read_count ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp16 ;

  {
#line 134
  if (skip_this_block) {
#line 134
    return;
  }
  {
  {
#line 136
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 136
      goto while_break;
    }
    {
#line 141
    if ((int )c->letter == 73) {
#line 141
      goto case_73;
    }
#line 141
    if ((int )c->letter == 65) {
#line 141
      goto case_73;
    }
#line 144
    if ((int )c->letter == 100) {
#line 144
      goto case_100;
    }
#line 163
    if ((int )c->letter == 68) {
#line 163
      goto case_68;
    }
#line 166
    if ((int )c->letter == 105) {
#line 166
      goto case_105;
    }
#line 189
    if ((int )c->letter == 114) {
#line 189
      goto case_114;
    }
#line 196
    if ((int )c->letter == 115) {
#line 196
      goto case_115;
    }
#line 271
    if ((int )c->letter == 121) {
#line 271
      goto case_121;
    }
#line 276
    if ((int )c->letter == 99) {
#line 276
      goto case_99;
    }
#line 346
    if ((int )c->letter == 106) {
#line 346
      goto case_106;
    }
#line 352
    if ((int )c->letter == 74) {
#line 352
      goto case_74;
    }
#line 359
    if ((int )c->letter == 108) {
#line 359
      goto case_108;
    }
#line 365
    if ((int )c->letter == 76) {
#line 365
      goto case_76;
    }
#line 372
    if ((int )c->letter == 112) {
#line 372
      goto case_112;
    }
#line 389
    if ((int )c->letter == 70) {
#line 389
      goto case_70;
    }
#line 395
    if ((int )c->letter == 66) {
#line 395
      goto case_66___1;
    }
#line 401
    if ((int )c->letter == 78) {
#line 401
      goto case_78;
    }
#line 406
    if ((int )c->letter == 38) {
#line 406
      goto case_38;
    }
#line 409
    if ((int )c->letter == 124) {
#line 409
      goto case_124;
    }
#line 412
    if ((int )c->letter == 94) {
#line 412
      goto case_94;
    }
#line 415
    if ((int )c->letter == 126) {
#line 415
      goto case_126;
    }
#line 419
    if ((int )c->letter == 62) {
#line 419
      goto case_62;
    }
#line 419
    if ((int )c->letter == 60) {
#line 419
      goto case_62;
    }
#line 427
    if ((int )c->letter == 117) {
#line 427
      goto case_117;
    }
#line 433
    if ((int )c->letter == 102) {
#line 433
      goto case_102;
    }
#line 439
    if ((int )c->letter == 119) {
#line 439
      goto case_119;
    }
#line 441
    if ((int )c->letter == 120) {
#line 441
      goto case_120;
    }
#line 138
    goto switch_break;
    case_73: /* CIL Label */ 
    case_65: /* CIL Label */ 
    {
    {
#line 142
    write_buffer(c->s1, c->s1_len);
    }
    }
#line 143
    goto switch_break;
    case_100: /* CIL Label */ 
#line 145
    if (c->rpos) {
#line 145
      goto _L___0;
    } else
#line 145
    if (c->offset == in_buffer.block_offset) {
      _L___0: /* CIL Label */ 
#line 147
      if ((off_t )c->rpos < c->count) {
#line 147
        goto _L;
      } else
#line 147
      if (c->count == 0LL) {
        _L: /* CIL Label */ 
#line 149
        if (inserting) {
#line 151
          inserting = 0;
        } else {
#line 154
          delete_this_byte = 1;
        }
#line 156
        (c->rpos) ++;
      } else {
#line 159
        c->rpos = 0;
      }
    }
#line 162
    goto switch_break;
    case_68: /* CIL Label */ 
#line 164
    if (c->offset == in_buffer.block_num) {
#line 164
      delete_this_block = 1;
    } else
#line 164
    if (c->offset == 0LL) {
#line 164
      delete_this_block = 1;
    }
#line 165
    goto switch_break;
    case_105: /* CIL Label */ 
#line 167
    if (c->offset == in_buffer.block_offset) {
#line 167
      if (! c->rpos) {
#line 169
        c->rpos = 1;
#line 170
        inserting = 1;
#line 171
        goto switch_break;
      }
    }
#line 173
    if (c->rpos > 0) {
#line 173
      if ((off_t )c->rpos <= c->s1_len) {
#line 175
        if ((off_t )c->rpos <= c->s1_len) {
          {
          {
#line 177
          put_byte(*(c->s1 + (c->rpos - 1)));
          }
          }
#line 178
          if (delete_this_byte) {
#line 180
            delete_this_byte = 0;
          } else
#line 183
          if ((off_t )c->rpos < c->s1_len) {
#line 183
            inserting = 1;
          }
        }
#line 186
        (c->rpos) ++;
      }
    }
#line 188
    goto switch_break;
    case_114: /* CIL Label */ 
#line 190
    if (in_buffer.block_offset >= c->offset) {
#line 190
      if (in_buffer.block_offset < c->offset + c->s1_len) {
        {
        {
#line 193
        put_byte(*(c->s1 + (in_buffer.block_offset - c->offset)));
        }
        }
      }
    }
#line 195
    goto switch_break;
    case_115: /* CIL Label */ 
#line 197
    if (c->rpos) {
#line 199
      if ((off_t )c->rpos < c->s1_len) {
#line 199
        if ((off_t )c->rpos < c->s2_len) {
          {
          {
#line 201
          put_byte(*(c->s2 + c->rpos));
          }
          }
        } else {
#line 199
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 202
      if ((off_t )c->rpos < c->s1_len) {
#line 202
        if ((off_t )c->rpos >= c->s2_len) {
#line 204
          if (inserting) {
#line 206
            inserting = 0;
          } else {
#line 209
            delete_this_byte = 1;
          }
        } else {
#line 202
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 211
      if ((off_t )c->rpos >= c->s1_len) {
#line 211
        if ((off_t )c->rpos < c->s2_len) {
          {
          {
#line 213
          put_byte(*(c->s2 + c->rpos));
          }
          }
        }
      }
#line 216
      if ((off_t )c->rpos >= c->s1_len - 1LL) {
#line 216
        if ((off_t )c->rpos < c->s2_len - 1LL) {
#line 218
          if (delete_this_byte) {
#line 220
            delete_this_byte = 0;
          } else {
#line 223
            inserting = 1;
          }
        }
      }
#line 227
      (c->rpos) ++;
#line 228
      if ((off_t )c->rpos >= c->s1_len) {
#line 228
        if ((off_t )c->rpos >= c->s2_len) {
#line 230
          c->rpos = 0;
        }
      }
#line 232
      goto switch_break;
    }
#line 234
    if (delete_this_byte) {
#line 234
      goto switch_break;
    }
#line 235
    if (c->fpos == in_buffer.block_offset) {
#line 235
      goto switch_break;
    }
#line 236
    p = out_buffer.write_pos;
#line 237
    i = 0;
    {
    {
#line 238
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 238
      if ((int )*p == (int )*(c->s1 + i)) {
#line 238
        if (! ((off_t )i < c->s1_len)) {
#line 238
          goto while_break___0;
        }
      } else {
#line 238
        goto while_break___0;
      }
#line 240
      if ((unsigned long )p == (unsigned long )out_buffer.write_pos) {
        {
        {
#line 240
        p = read_pos();
        }
        }
      }
      {
      {
#line 241
      tmp = block_end_pos();
      }
      }
#line 241
      if ((unsigned long )p == (unsigned long )tmp) {
#line 241
        if (c->s1_len - 1LL > (off_t )i) {
#line 241
          goto while_break___0;
        }
      }
#line 242
      i ++;
#line 243
      p ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 245
    if ((off_t )i == c->s1_len) {
#line 247
      c->fpos = in_buffer.block_offset;
#line 248
      if (c->s1_len > 1LL) {
#line 248
        c->rpos = 1;
      } else
#line 248
      if (c->s2_len > 1LL) {
#line 248
        c->rpos = 1;
      }
#line 249
      if (c->s2_len) {
        {
        {
#line 251
        put_byte(*(c->s2 + 0));
        }
        }
#line 252
        if (delete_this_byte) {
#line 254
          delete_this_byte = 0;
        } else
#line 257
        if (c->s1_len == 1LL) {
#line 257
          if (c->s2_len > 1LL) {
#line 257
            inserting = 1;
          }
        }
      } else
#line 261
      if (inserting) {
#line 263
        inserting = 0;
      } else {
#line 266
        delete_this_byte = 1;
      }
    }
#line 270
    goto switch_break;
    case_121: /* CIL Label */ 
#line 272
    i = 0;
    {
    {
#line 273
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 273
      if ((int )*(c->s1 + i) != (int )*(out_buffer.write_pos)) {
#line 273
        if (! ((off_t )i < c->s1_len)) {
#line 273
          goto while_break___1;
        }
      } else {
#line 273
        goto while_break___1;
      }
#line 273
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 274
    if ((int )*(c->s1 + i) == (int )*(out_buffer.write_pos)) {
#line 274
      if ((off_t )i < c->s1_len) {
        {
        {
#line 274
        put_byte(*(c->s2 + i));
        }
        }
      }
    }
#line 275
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 279
    if ((int )*(c->s1 + 0) == 65) {
#line 279
      goto case_65___0;
    }
#line 319
    if ((int )*(c->s1 + 0) == 66) {
#line 319
      goto case_66___0;
    }
#line 277
    goto switch_break___0;
    case_65___0: /* CIL Label */ 
    {
#line 282
    if ((int )*(c->s1 + 3) == 66) {
#line 282
      goto case_66;
    }
#line 280
    goto switch_break___1;
    case_66: /* CIL Label */ 
#line 283
    if (c->rpos) {
#line 283
      goto _L___3;
    } else {
      {
      {
#line 283
      tmp___1 = last_byte();
      }
      }
#line 283
      if (tmp___1) {
#line 283
        if (out_buffer.block_offset == 0LL) {
          _L___3: /* CIL Label */ 
          {
#line 285
          c->rpos = 0;
          {
#line 286
          tmp___0 = last_byte();
          }
          }
#line 286
          if (tmp___0) {
#line 288
            if ((int )*(out_buffer.write_pos) >= 48) {
#line 288
              if ((int )*(out_buffer.write_pos) <= 57) {
#line 290
                a = (unsigned char )((int )*(out_buffer.write_pos) - 48);
#line 291
                a = (unsigned char )(((int )a << 4) & 240);
#line 292
                b = (unsigned char)15;
#line 293
                *(out_buffer.write_pos) = (unsigned char )((int )a | (int )b);
              }
            }
          }
#line 296
          goto switch_break___1;
        }
      }
    }
#line 298
    if (out_buffer.block_offset == 0LL) {
#line 298
      goto switch_break___1;
    } else
#line 298
    if (delete_this_byte) {
#line 298
      goto switch_break___1;
    }
#line 299
    if ((int )*(out_buffer.write_pos + -1) >= 48) {
#line 299
      if ((int )*(out_buffer.write_pos + -1) <= 57) {
#line 301
        a = (unsigned char )((int )*(out_buffer.write_pos + -1) - 48);
#line 302
        a = (unsigned char )(((int )a << 4) & 240);
#line 303
        if ((int )*(out_buffer.write_pos) >= 48) {
#line 303
          if ((int )*(out_buffer.write_pos) <= 57) {
#line 305
            b = (unsigned char )((int )*(out_buffer.write_pos) - 48);
#line 306
            b = (unsigned char )((int )b & 15);
#line 307
            delete_this_byte = 1;
#line 308
            c->rpos = 1;
          } else {
#line 303
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 311
          b = (unsigned char)15;
#line 312
          if ((int )*(out_buffer.write_pos) == 70) {
#line 312
            delete_this_byte = 1;
          } else
#line 312
          if ((int )*(out_buffer.write_pos) == 102) {
#line 312
            delete_this_byte = 1;
          }
        }
#line 314
        *(out_buffer.write_pos + -1) = (unsigned char )((int )a | (int )b);
      }
    }
#line 316
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 318
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 322
    if ((int )*(c->s1 + 3) == 65) {
#line 322
      goto case_65___1;
    }
#line 320
    goto switch_break___2;
    case_65___1: /* CIL Label */ 
#line 323
    if ((((int )*(out_buffer.write_pos) >> 4) & 15) <= 9) {
#line 323
      if (((int )*(out_buffer.write_pos) & 15) <= 9) {
#line 323
        goto _L___5;
      } else
#line 323
      if (((int )*(out_buffer.write_pos) & 15) == 15) {
        _L___5: /* CIL Label */ 
#line 326
        a = (unsigned char )(((int )*(out_buffer.write_pos) >> 4) & 15);
#line 327
        b = (unsigned char )((int )*(out_buffer.write_pos) & 15);
#line 328
        *(out_buffer.write_pos) = (unsigned char )(48 + (int )a);
#line 329
        if (! delete_this_byte) {
          {
          {
#line 331
          write_next_byte();
          }
          }
#line 332
          if ((int )b == 15) {
#line 334
            *(out_buffer.write_pos) = (unsigned char )'F';
          } else {
#line 337
            *(out_buffer.write_pos) = (unsigned char )(48 + (int )b);
          }
        }
      }
    }
#line 341
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 343
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 345
    goto switch_break;
    case_106: /* CIL Label */ 
#line 347
    if (in_buffer.block_offset < c->count) {
      {
      {
#line 349
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 349
        if (! ((unsigned long )c->next != (unsigned long )((void *)0))) {
#line 349
          goto while_break___2;
        }
#line 349
        c = c->next;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 351
    goto switch_break;
    case_74: /* CIL Label */ 
#line 353
    if (in_buffer.block_num <= c->count) {
#line 355
      skip_this_block = 1;
#line 356
      return;
    }
#line 358
    goto switch_break;
    case_108: /* CIL Label */ 
#line 360
    if (in_buffer.block_offset >= c->count) {
      {
      {
#line 362
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 362
        if (! ((unsigned long )c->next != (unsigned long )((void *)0))) {
#line 362
          goto while_break___3;
        }
#line 362
        c = c->next;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 364
    goto switch_break;
    case_76: /* CIL Label */ 
#line 366
    if (in_buffer.block_num > c->count) {
#line 368
      skip_this_block = 1;
#line 369
      return;
    }
#line 371
    goto switch_break;
    case_112: /* CIL Label */ 
#line 373
    if (delete_this_byte) {
#line 373
      goto switch_break;
    }
#line 374
    i = 0;
#line 375
    a = *(out_buffer.write_pos);
    {
    {
#line 376
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 376
      if (! ((off_t )i < c->s1_len)) {
#line 376
        goto while_break___4;
      }
      {
      {
#line 378
      str = byte_to_string(a, (char )*(c->s1 + i));
      }
      {
#line 379
      write_string(str);
      }
#line 380
      i ++;
      }
#line 381
      if ((off_t )i < c->s1_len) {
        {
        {
#line 383
        put_byte((unsigned char )'-');
        }
        {
#line 384
        write_next_byte();
        }
        }
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    {
#line 387
    put_byte((unsigned char )' ');
    }
    }
#line 388
    goto switch_break;
    case_70: /* CIL Label */ 
    {
    {
#line 390
    str = off_t_to_string(in_buffer.stream_offset + (off_t )(in_buffer.read_pos - in_buffer.buffer),
                          (char )*(c->s1 + 0));
    }
    {
#line 391
    write_string(str);
    }
    {
#line 392
    put_byte((unsigned char )':');
    }
    {
#line 393
    write_next_byte();
    }
    }
#line 394
    goto switch_break;
    case_66___1: /* CIL Label */ 
    {
    {
#line 396
    str = off_t_to_string(in_buffer.block_num, (char )*(c->s1 + 0));
    }
    {
#line 397
    write_string(str);
    }
    {
#line 398
    put_byte((unsigned char )':');
    }
    {
#line 399
    write_next_byte();
    }
    }
#line 400
    goto switch_break;
    case_78: /* CIL Label */ 
    {
    {
#line 402
    tmp___2 = get_current_file();
    }
    {
#line 402
    write_string(tmp___2);
    }
    {
#line 403
    put_byte((unsigned char )':');
    }
    {
#line 404
    write_next_byte();
    }
    }
#line 405
    goto switch_break;
    case_38: /* CIL Label */ 
    {
    {
#line 407
    put_byte((unsigned char )((int )*(out_buffer.write_pos) & (int )*(c->s1 + 0)));
    }
    }
#line 408
    goto switch_break;
    case_124: /* CIL Label */ 
    {
    {
#line 410
    put_byte((unsigned char )((int )*(out_buffer.write_pos) | (int )*(c->s1 + 0)));
    }
    }
#line 411
    goto switch_break;
    case_94: /* CIL Label */ 
    {
    {
#line 413
    put_byte((unsigned char )((int )*(out_buffer.write_pos) ^ (int )*(c->s1 + 0)));
    }
    }
#line 414
    goto switch_break;
    case_126: /* CIL Label */ 
    {
    {
#line 416
    put_byte((unsigned char )(~ ((int )*(out_buffer.write_pos))));
    }
    }
#line 417
    goto switch_break;
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
    {
    {
#line 420
    tmp___5 = fseeko(c->fd, (__off64_t )0, 0);
    }
    }
#line 420
    if (tmp___5) {
      {
      {
#line 420
      tmp___3 = __errno_location();
      }
      {
#line 420
      tmp___4 = strerror(*tmp___3);
      }
      {
#line 420
      panic((char *)"Cannot seek file", (char *)c->s1, tmp___4);
      }
      }
    }
    {
    {
#line 421
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
      {
      {
#line 423
      tmp___6 = fread((void */* __restrict  */)(ioblock), (size_t )1, (size_t )8192,
                      (FILE */* __restrict  */)c->fd);
      }
#line 423
      read_count = (off_t )tmp___6;
      {
#line 424
      write_buffer(ioblock, read_count);
      }
      }
#line 421
      if (! read_count) {
#line 421
        goto while_break___5;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 426
    goto switch_break;
    case_117: /* CIL Label */ 
#line 428
    if (in_buffer.block_offset <= c->offset) {
      {
      {
#line 430
      put_byte(*(c->s1 + 0));
      }
      }
    }
#line 432
    goto switch_break;
    case_102: /* CIL Label */ 
#line 434
    if (in_buffer.block_offset >= c->offset) {
      {
      {
#line 436
      put_byte(*(c->s1 + 0));
      }
      }
    }
#line 438
    goto switch_break;
    case_119: /* CIL Label */ 
#line 440
    goto switch_break;
    case_120: /* CIL Label */ 
    {
    {
#line 442
    put_byte((unsigned char )((((int )*(out_buffer.write_pos) << 4) & 240) | (((int )*(out_buffer.write_pos) >> 4) & 15)));
    }
    }
#line 443
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 445
    c = c->next;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 450 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void write_w_command(unsigned char *buf , size_t length ) 
{ 
  struct command_list *c ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 455
  if (skip_this_block) {
#line 455
    return;
  }
#line 457
  c = current_byte_commands;
  {
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 459
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 459
      goto while_break;
    }
#line 461
    if ((int )c->letter == 119) {
      {
      {
#line 463
      tmp___1 = fwrite((void const   */* __restrict  */)buf, (size_t )1, length, (FILE */* __restrict  */)c->fd);
      }
      }
#line 463
      if (tmp___1 != length) {
        {
        {
#line 463
        tmp = __errno_location();
        }
        {
#line 463
        tmp___0 = strerror(*tmp);
        }
        {
#line 463
        panic((char *)"Cannot write to file", (char *)c->s2, tmp___0);
        }
        }
      }
#line 464
      if (length) {
#line 464
        c->count = (off_t )1;
      }
    }
#line 466
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return;
}
}
#line 473 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
char *find_block_w_file(char *file___1 , int *len ) 
{ 
  char *f ;
  char *ppos ;
  unsigned short const   **tmp ;

  {
#line 478
  f = file___1;
  {
  {
#line 480
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 480
    if (! ((int )*f != 0)) {
#line 480
      goto while_break;
    }
#line 482
    if ((int )*f == 37) {
#line 484
      ppos = f;
#line 485
      f ++;
      {
      {
#line 486
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 486
        if (f - ppos < 4L) {
          {
          {
#line 486
          tmp = __ctype_b_loc();
          }
          }
#line 486
          if (! ((int const   )*(*tmp + (int )*f) & 2048)) {
#line 486
            goto while_break___0;
          }
        } else {
#line 486
          goto while_break___0;
        }
#line 486
        f ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 487
      if ((int )*f == 66) {
#line 489
        *len = (int )(f - ppos) + 1;
#line 490
        return (ppos);
      }
#line 492
      f = ppos;
    }
#line 494
    f ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  return ((char *)((void *)0));
}
}
#line 500 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void bn_printf(char *file___1 , char *str , off_t block_number ) 
{ 
  char *bstart ;
  char *f ;
  char num[128] ;
  char format[64] ;
  int blen ;
  size_t tmp ;
  size_t tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 507
  f = str;
#line 508
  *(file___1 + 0) = (char)0;
  {
  {
#line 510
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 510
    bstart = find_block_w_file(f, & blen);
    }
    }
#line 510
    if (! ((unsigned long )bstart != (unsigned long )((void *)0))) {
#line 510
      goto while_break;
    }
    {
#line 512
    num[0] = (char)0;
#line 513
    format[0] = (char)0;
    {
#line 514
    strncat((char */* __restrict  */)file___1, (char const   */* __restrict  */)f,
            (size_t )(bstart - f));
    }
    {
#line 515
    strncpy((char */* __restrict  */)(format), (char const   */* __restrict  */)bstart,
            (size_t )(blen - 1));
    }
#line 516
    format[blen - 1] = (char)0;
    {
#line 517
    strcat((char */* __restrict  */)(format), (char const   */* __restrict  */)"lld");
    }
    {
#line 518
    sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)(format),
            block_number);
    }
    {
#line 519
    tmp = strlen((char const   *)file___1);
    }
    {
#line 519
    tmp___0 = strlen((char const   *)(num));
    }
    }
#line 519
    if (tmp + tmp___0 >= 4096U) {
      {
      {
#line 519
      panic((char *)"Filename for w-command too long", str, (char *)((void *)0));
      }
      }
    }
    {
    {
#line 520
    strcat((char */* __restrict  */)file___1, (char const   */* __restrict  */)(num));
    }
#line 521
    f = bstart + blen;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 523
  strcat((char */* __restrict  */)file___1, (char const   */* __restrict  */)f);
  }
  }
#line 524
  return;
}
}
#line 531 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static char file[4096]  ;
#line 527 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void open_w_files(off_t block_number ) 
{ 
  struct command_list *c ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 533
  c = current_byte_commands;
  {
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 535
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 535
      goto while_break;
    }
#line 537
    if ((int )c->letter == 119) {
#line 537
      if (c->offset) {
#line 539
        if ((unsigned long )c->fd != (unsigned long )((void *)0)) {
          {
          {
#line 541
          tmp___1 = fclose(c->fd);
          }
          }
#line 541
          if (tmp___1 != 0) {
            {
            {
#line 541
            tmp = __errno_location();
            }
            {
#line 541
            tmp___0 = strerror(*tmp);
            }
            {
#line 541
            panic((char *)"Error closing file", (char *)c->s2, tmp___0);
            }
            }
          }
#line 542
          if (! c->count) {
#line 542
            if ((unsigned long )c->s2 != (unsigned long )((void *)0)) {
              {
              {
#line 544
              unlink((char const   *)c->s2);
              }
              }
            }
          }
#line 546
          c->fd = (FILE *)((void *)0);
        }
        {
        {
#line 549
        bn_printf(file, (char *)c->s1, block_number);
        }
        {
#line 550
        c->fd = fopen((char const   */* __restrict  */)(file), (char const   */* __restrict  */)"w");
        }
        }
#line 551
        if ((unsigned long )c->fd == (unsigned long )((void *)0)) {
          {
          {
#line 551
          tmp___2 = __errno_location();
          }
          {
#line 551
          tmp___3 = strerror(*tmp___2);
          }
          {
#line 551
          panic((char *)"Cannot open file for writing", file, tmp___3);
          }
          }
        }
#line 552
        c->count = (off_t )0;
#line 553
        if ((unsigned long )c->s2 != (unsigned long )((void *)0)) {
          {
          {
#line 553
          free((void *)c->s2);
          }
          }
        }
        {
        {
#line 554
        tmp___4 = xstrdup(file);
        }
#line 554
        c->s2 = (unsigned char *)tmp___4;
        }
      }
    }
#line 556
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 558
  return;
}
}
#line 563 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void init_commands(struct commands *commands___0 ) 
{ 
  struct command_list *c ;
  int wlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 569
  c = commands___0->byte;
  {
  {
#line 571
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 571
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 571
      goto while_break;
    }
    {
#line 575
    if ((int )c->letter == 119) {
#line 575
      goto case_119;
    }
#line 573
    goto switch_break;
    case_119: /* CIL Label */ 
    {
    {
#line 576
    tmp___2 = find_block_w_file((char *)c->s1, & wlen);
    }
    }
#line 576
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 578
      c->fd = (FILE *)((void *)0);
#line 579
      c->offset = (off_t )1;
#line 580
      w_commands_block_num = 1;
#line 581
      c->s2 = (unsigned char *)((void *)0);
    } else {
      {
      {
#line 584
      c->fd = fopen((char const   */* __restrict  */)c->s1, (char const   */* __restrict  */)"w");
      }
      }
#line 585
      if ((unsigned long )c->fd == (unsigned long )((void *)0)) {
        {
        {
#line 585
        tmp = __errno_location();
        }
        {
#line 585
        tmp___0 = strerror(*tmp);
        }
        {
#line 585
        panic((char *)"Cannot open file for writing", (char *)c->s1, tmp___0);
        }
        }
      }
      {
#line 586
      c->offset = (off_t )0;
      {
#line 587
      tmp___1 = xstrdup((char *)c->s1);
      }
#line 587
      c->s2 = (unsigned char *)tmp___1;
      }
    }
#line 589
    c->count = (off_t )0;
#line 590
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 592
    c = c->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  c = commands___0->block_start;
  {
  {
#line 597
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 597
      goto while_break___0;
    }
    {
#line 601
    if ((int )c->letter == 62) {
#line 601
      goto case_62;
    }
#line 599
    goto switch_break___0;
    case_62: /* CIL Label */ 
    {
    {
#line 602
    c->fd = fopen((char const   */* __restrict  */)c->s1, (char const   */* __restrict  */)"r");
    }
    }
#line 603
    if ((unsigned long )c->fd == (unsigned long )((void *)0)) {
      {
      {
#line 603
      tmp___3 = __errno_location();
      }
      {
#line 603
      tmp___4 = strerror(*tmp___3);
      }
      {
#line 603
      panic((char *)"Cannot open file for reading", (char *)c->s1, tmp___4);
      }
      }
    }
#line 604
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 606
    c = c->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  c = commands___0->block_end;
  {
  {
#line 611
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 611
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 611
      goto while_break___1;
    }
    {
#line 615
    if ((int )c->letter == 60) {
#line 615
      goto case_60;
    }
#line 613
    goto switch_break___1;
    case_60: /* CIL Label */ 
    {
    {
#line 616
    c->fd = fopen((char const   */* __restrict  */)c->s1, (char const   */* __restrict  */)"r");
    }
    }
#line 617
    if ((unsigned long )c->fd == (unsigned long )((void *)0)) {
      {
      {
#line 617
      tmp___5 = __errno_location();
      }
      {
#line 617
      tmp___6 = strerror(*tmp___5);
      }
      {
#line 617
      panic((char *)"Cannot open file for reading", (char *)c->s1, tmp___6);
      }
      }
    }
#line 618
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 620
    c = c->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 623
  return;
}
}
#line 627 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void close_commands(struct commands *commands___0 ) 
{ 
  struct command_list *c ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 632
  c = commands___0->byte;
  {
  {
#line 634
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 634
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 634
      goto while_break;
    }
    {
#line 638
    if ((int )c->letter == 119) {
#line 638
      goto case_119;
    }
#line 636
    goto switch_break;
    case_119: /* CIL Label */ 
#line 639
    if ((unsigned long )c->fd != (unsigned long )((void *)0)) {
      {
      {
#line 641
      tmp___1 = fclose(c->fd);
      }
      }
#line 641
      if (tmp___1 != 0) {
        {
        {
#line 641
        tmp = __errno_location();
        }
        {
#line 641
        tmp___0 = strerror(*tmp);
        }
        {
#line 641
        panic((char *)"Error in closing file", (char *)c->s2, tmp___0);
        }
        }
      }
#line 642
      if (! c->count) {
#line 642
        if ((unsigned long )c->s2 != (unsigned long )((void *)0)) {
          {
          {
#line 644
          unlink((char const   *)c->s2);
          }
          }
        }
      }
    }
#line 647
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 649
    c = c->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  c = commands___0->block_start;
  {
  {
#line 654
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 654
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 654
      goto while_break___0;
    }
    {
#line 658
    if ((int )c->letter == 62) {
#line 658
      goto case_62;
    }
#line 656
    goto switch_break___0;
    case_62: /* CIL Label */ 
    {
    {
#line 659
    fclose(c->fd);
    }
    }
#line 660
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 662
    c = c->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 665
  c = commands___0->block_end;
  {
  {
#line 667
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 667
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 667
      goto while_break___1;
    }
    {
#line 671
    if ((int )c->letter == 60) {
#line 671
      goto case_60;
    }
#line 669
    goto switch_break___1;
    case_60: /* CIL Label */ 
    {
    {
#line 672
    fclose(c->fd);
    }
    }
#line 673
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 675
    c = c->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 680 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
__inline void reset_rpos(struct command_list *c ) 
{ 


  {
  {
  {
#line 683
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 683
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 683
      goto while_break;
    }
#line 685
    c->rpos = 0;
#line 686
    c->fpos = (off_t )-1;
#line 687
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  return;
}
}
#line 694 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
void execute_program(struct commands *commands___0 ) 
{ 
  int block_end ;
  unsigned char tmp ;
  int tmp___0 ;

  {
#line 699
  current_byte_commands = commands___0->byte;
  {
  {
#line 701
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 701
    tmp___0 = find_block();
    }
    }
#line 701
    if (! tmp___0) {
#line 701
      goto while_break;
    }
    {
    {
#line 703
    reset_rpos(commands___0->byte);
    }
#line 704
    delete_this_block = 0;
#line 705
    out_buffer.block_offset = (off_t )0;
#line 706
    skip_this_block = 0;
    }
#line 707
    if (w_commands_block_num) {
      {
      {
#line 707
      open_w_files(in_buffer.block_num);
      }
      }
    }
    {
    {
#line 708
    execute_commands(commands___0->block_start);
    }
    }
    {
    {
#line 709
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
#line 711
      delete_this_byte = 0;
#line 712
      inserting = 0;
      {
#line 713
      block_end = last_byte();
      }
      {
#line 714
      tmp = read_byte();
      }
      {
#line 714
      put_byte(tmp);
      }
      {
#line 715
      execute_commands(commands___0->byte);
      }
      }
#line 716
      if (! delete_this_byte) {
#line 716
        if (! delete_this_block) {
          {
          {
#line 718
          write_next_byte();
          }
          }
        }
      }
#line 720
      if (! block_end) {
#line 720
        if (! inserting) {
          {
          {
#line 720
          get_next_byte();
          }
          }
        }
      }
#line 709
      if (! (! block_end)) {
#line 709
        if (! inserting) {
#line 709
          goto while_break___0;
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 722
    execute_commands(commands___0->block_end);
    }
    {
#line 723
    flush_buffer();
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 725
  close_output_stream();
  }
  }
#line 726
  return;
}
}
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 176 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
void mark_block_end(void) ;
#line 230 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct io_file out_stream  ;
#line 231 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct input_buffer in_buffer  ;
#line 232 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.h"
struct output_buffer out_buffer  ;
#line 76 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 35 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
struct io_file *in_stream  =    (struct io_file *)((void *)0);
#line 36 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
struct io_file *in_stream_start  =    (struct io_file *)((void *)0);
#line 45 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void set_output_file(char *file___1 ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 48
  if ((unsigned long )out_stream.file != (unsigned long )((void *)0)) {
    {
    {
#line 48
    panic((char *)"Only one output file can be defined", (char *)((void *)0), (char *)((void *)0));
    }
    }
  }
#line 50
  if ((unsigned long )file___1 == (unsigned long )((void *)0)) {
#line 52
    out_stream.fd = 1;
#line 53
    out_stream.file = (char *)"(stdout)";
  } else {
    {
    {
#line 56
    out_stream.fd = open((char const   *)file___1, 577, ((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3));
    }
    }
#line 57
    if (out_stream.fd == -1) {
      {
      {
#line 57
      tmp = __errno_location();
      }
      {
#line 57
      tmp___0 = strerror(*tmp);
      }
      {
#line 57
      panic((char *)"Cannot open for writing", file___1, tmp___0);
      }
      }
    }
    {
    {
#line 58
    out_stream.file = xstrdup(file___1);
    }
    }
  }
#line 60
  return;
}
}
#line 63 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void write_output_stream(unsigned char *buffer , ssize_t length ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 66
  tmp___1 = write(out_stream.fd, (void const   *)buffer, (size_t )length);
  }
  }
#line 66
  if (tmp___1 == -1) {
    {
    {
#line 66
    tmp = __errno_location();
    }
    {
#line 66
    tmp___0 = strerror(*tmp);
    }
    {
#line 66
    panic((char *)"Error writing to", out_stream.file, tmp___0);
    }
    }
  }
#line 67
  return;
}
}
#line 71 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void set_input_file(char *file___1 ) 
{ 
  struct io_file *new ;
  struct io_file *curr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 76
  tmp = xmalloc((size_t )sizeof(struct io_file ));
  }
#line 76
  new = (struct io_file *)tmp;
#line 77
  new->next = (struct io_file *)((void *)0);
  }
#line 79
  if ((unsigned long )in_stream == (unsigned long )((void *)0)) {
#line 81
    in_stream = new;
#line 82
    in_stream_start = in_stream;
  } else {
#line 85
    curr = in_stream;
    {
    {
#line 86
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 86
      if (! ((unsigned long )curr->next != (unsigned long )((void *)0))) {
#line 86
        goto while_break;
      }
#line 88
      curr = curr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 90
    curr->next = new;
  }
#line 93
  new->start_offset = (off_t )0;
#line 94
  if ((int )*(file___1 + 0) == 45) {
#line 94
    if ((int )*(file___1 + 1) == 0) {
#line 96
      new->fd = 0;
#line 97
      new->file = (char *)"(stdin)";
    } else {
#line 94
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 100
    new->fd = open((char const   *)file___1, 0);
    }
    }
#line 101
    if (new->fd == -1) {
      {
      {
#line 101
      tmp___0 = __errno_location();
      }
      {
#line 101
      tmp___1 = strerror(*tmp___0);
      }
      {
#line 101
      panic((char *)"Cannot open file for reading", file___1, tmp___1);
      }
      }
    }
    {
    {
#line 102
    new->file = xstrdup(file___1);
    }
    }
  }
#line 104
  return;
}
}
#line 107 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
char *get_current_file(void) 
{ 
  struct io_file *f ;
  struct io_file *prev ;
  off_t current_offset ;
  char *__cil_tmp4 ;

  {
#line 110
  f = in_stream_start;
#line 112
  current_offset = in_buffer.stream_offset + (off_t )(in_buffer.read_pos - in_buffer.buffer);
#line 114
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 114
    return ((char *)"");
  }
  {
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
#line 118
    prev = f;
#line 119
    f = f->next;
#line 120
    if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 120
      if (f->start_offset == 0LL) {
#line 122
        f = (struct io_file *)((void *)0);
      } else
#line 120
      if (f->start_offset > current_offset) {
#line 122
        f = (struct io_file *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (prev->file);
}
}
#line 131 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void init_buffer(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 134
  tmp = xmalloc((size_t )262144);
  }
#line 134
  in_buffer.buffer = (unsigned char *)tmp;
#line 135
  in_buffer.read_pos = (unsigned char *)((void *)0);
#line 136
  in_buffer.stream_end = (unsigned char *)((void *)0);
#line 137
  in_buffer.low_pos = in_buffer.buffer + 245760;
#line 138
  in_buffer.block_num = (off_t )0;
  {
#line 140
  tmp___0 = xmalloc((size_t )262144);
  }
#line 140
  out_buffer.buffer = (unsigned char *)tmp___0;
#line 141
  out_buffer.end = out_buffer.buffer + 262144;
#line 142
  out_buffer.write_pos = out_buffer.buffer;
#line 143
  out_buffer.low_pos = out_buffer.buffer + 245760;
  }
#line 144
  return;
}
}
#line 146 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
ssize_t read_input_stream(void) 
{ 
  ssize_t read_count ;
  ssize_t last_read ;
  ssize_t to_be_read ;
  ssize_t to_be_saved ;
  unsigned char *buffer_write_pos ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 152
  if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 152
    return (0);
  }
#line 154
  if ((unsigned long )in_buffer.read_pos == (unsigned long )((void *)0)) {
#line 156
    to_be_read = 262144;
#line 157
    to_be_saved = 0;
#line 158
    buffer_write_pos = in_buffer.buffer;
#line 159
    in_buffer.stream_offset = (off_t )0;
  } else {
#line 162
    to_be_read = (ssize_t )(in_buffer.read_pos - in_buffer.buffer);
#line 163
    to_be_saved = 262144 - to_be_read;
#line 164
    if (to_be_saved > 131072) {
      {
      {
#line 164
      panic((char *)"buffer error: reading to half full buffer", (char *)((void *)0),
            (char *)((void *)0));
      }
      }
    }
    {
    {
#line 165
    memcpy((void */* __restrict  */)in_buffer.buffer, (void const   */* __restrict  */)in_buffer.read_pos,
           (size_t )to_be_saved);
    }
#line 166
    buffer_write_pos = in_buffer.buffer + to_be_saved;
#line 167
    in_buffer.stream_offset += (off_t )to_be_read;
    }
#line 168
    if ((unsigned long )in_buffer.block_end != (unsigned long )((void *)0)) {
#line 168
      in_buffer.block_end -= to_be_read;
    }
  }
#line 171
  in_buffer.read_pos = in_buffer.buffer;
#line 173
  read_count = 0;
  {
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 176
    last_read = read(in_stream->fd, (void *)(buffer_write_pos + read_count), (size_t )(to_be_read - read_count));
    }
    }
#line 177
    if (last_read == -1) {
      {
      {
#line 177
      tmp = __errno_location();
      }
      {
#line 177
      tmp___0 = strerror(*tmp);
      }
      {
#line 177
      panic((char *)"Error reading file", in_stream->file, tmp___0);
      }
      }
    }
#line 178
    if (last_read == 0) {
      {
      {
#line 180
      tmp___3 = close(in_stream->fd);
      }
      }
#line 180
      if (tmp___3 == -1) {
        {
        {
#line 180
        tmp___1 = __errno_location();
        }
        {
#line 180
        tmp___2 = strerror(*tmp___1);
        }
        {
#line 180
        panic((char *)"Error in closing file", in_stream->file, tmp___2);
        }
        }
      }
#line 181
      in_stream = in_stream->next;
#line 182
      if ((unsigned long )in_stream != (unsigned long )((void *)0)) {
#line 183
        in_stream->start_offset = (in_buffer.stream_offset + (off_t )read_count) + (off_t )to_be_saved;
      }
    }
#line 185
    read_count += last_read;
#line 174
    if ((unsigned long )in_stream != (unsigned long )((void *)0)) {
#line 174
      if (! (read_count < to_be_read)) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (read_count < to_be_read) {
#line 188
    in_buffer.stream_end = (buffer_write_pos + read_count) - 1;
  }
#line 190
  return (read_count);
}
}
#line 194 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
unsigned char read_byte(void) 
{ 


  {
#line 197
  return (*(in_buffer.read_pos));
}
}
#line 201 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
unsigned char *read_pos(void) 
{ 


  {
#line 204
  return (in_buffer.read_pos);
}
}
#line 208 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
unsigned char *block_end_pos(void) 
{ 


  {
#line 211
  return (in_buffer.block_end);
}
}
#line 217 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
int get_next_byte(void) 
{ 


  {
#line 220
  if ((unsigned long )in_buffer.read_pos >= (unsigned long )in_buffer.low_pos) {
    {
    {
#line 222
    read_input_stream();
    }
    }
#line 223
    if ((unsigned long )in_buffer.block_end == (unsigned long )((void *)0)) {
      {
      {
#line 223
      mark_block_end();
      }
      }
    }
  }
#line 226
  if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 228
    if ((unsigned long )in_buffer.read_pos >= (unsigned long )in_buffer.stream_end) {
#line 230
      return (0);
    }
  }
#line 234
  (in_buffer.read_pos) ++;
#line 235
  (in_buffer.block_offset) ++;
#line 236
  return (1);
}
}
#line 240 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void mark_block_end(void) 
{ 
  unsigned char *safe_search ;
  unsigned char *scan ;
  int i ;
  char *__cil_tmp4 ;

  {
#line 246
  if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 248
    safe_search = in_buffer.stream_end;
  } else {
#line 251
    safe_search = in_buffer.buffer + 262144;
  }
#line 254
  in_buffer.block_end = (unsigned char *)((void *)0);
#line 256
  if (block.type & 4) {
#line 258
    in_buffer.block_end = in_buffer.read_pos + ((block.stop.M - in_buffer.block_offset) - 1LL);
#line 259
    if ((unsigned long )in_buffer.block_end > (unsigned long )safe_search) {
#line 259
      in_buffer.block_end = (unsigned char *)((void *)0);
    }
  }
#line 263
  if (block.type & 8) {
#line 265
    scan = in_buffer.read_pos;
#line 266
    if (block.stop.S.length) {
#line 268
      if (block.type & 2) {
#line 268
        if (in_buffer.block_offset < block.start.S.length) {
#line 269
          scan += block.start.S.length - in_buffer.block_offset;
        }
      }
#line 270
      i = 0;
      {
      {
#line 271
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 271
        if ((unsigned long )scan <= (unsigned long )((safe_search - block.stop.S.length) + 1)) {
#line 271
          if (! ((off_t )i < block.stop.S.length)) {
#line 271
            goto while_break;
          }
        } else {
#line 271
          goto while_break;
        }
#line 273
        i = 0;
        {
        {
#line 274
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 274
          if ((int )*scan == (int )*(block.stop.S.string + i)) {
#line 274
            if (! ((off_t )i < block.stop.S.length)) {
#line 274
              goto while_break___0;
            }
          } else {
#line 274
            goto while_break___0;
          }
#line 276
          scan ++;
#line 277
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 279
        if (i) {
#line 281
          scan -= i - 1;
        } else {
#line 284
          scan ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 288
      if ((off_t )i == block.stop.S.length) {
#line 290
        scan += i - 2;
#line 291
        in_buffer.block_end = scan;
      }
    } else
#line 295
    if (block.type & 2) {
#line 297
      if (block.start.S.length) {
#line 299
        if (in_buffer.block_offset < block.start.S.length) {
#line 300
          scan += block.start.S.length - in_buffer.block_offset;
        }
#line 302
        i = 0;
        {
        {
#line 304
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 304
          if ((unsigned long )scan <= (unsigned long )((safe_search - block.start.S.length) + 1)) {
#line 304
            if (! ((off_t )i < block.start.S.length)) {
#line 304
              goto while_break___1;
            }
          } else {
#line 304
            goto while_break___1;
          }
#line 306
          i = 0;
          {
          {
#line 307
          while (1) {
            while_continue___6: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 307
            if ((int )*scan == (int )*(block.start.S.string + i)) {
#line 307
              if (! ((off_t )i < block.start.S.length)) {
#line 307
                goto while_break___2;
              }
            } else {
#line 307
              goto while_break___2;
            }
#line 309
            scan ++;
#line 310
            i ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 312
          if (i) {
#line 314
            scan -= i - 1;
          } else {
#line 317
            scan ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 321
        if ((off_t )i == block.start.S.length) {
#line 323
          in_buffer.block_end = scan - 2;
        }
      } else {
        {
        {
#line 327
        panic((char *)"Both block start and stop zero size", (char *)((void *)0),
              (char *)((void *)0));
        }
        }
      }
    }
  }
#line 333
  if ((unsigned long )in_buffer.block_end == (unsigned long )((void *)0)) {
#line 333
    if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 334
      in_buffer.block_end = in_buffer.stream_end;
    }
  }
#line 335
  return;
}
}
#line 338 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
int last_byte(void) 
{ 


  {
#line 341
  return ((unsigned long )in_buffer.block_end == (unsigned long )in_buffer.read_pos);
}
}
#line 345 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
__inline int end_of_stream(void) 
{ 


  {
#line 348
  if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 348
    if ((unsigned long )in_buffer.stream_end == (unsigned long )in_buffer.read_pos) {
#line 350
      return (1);
    } else {
#line 353
      return (0);
    }
  } else {
#line 353
    return (0);
  }
}
}
#line 359 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
int find_block(void) 
{ 
  unsigned char *safe_search ;
  unsigned char *scan_start ;
  register int i ;
  int found ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 366
  found = 0;
  {
#line 368
  tmp = end_of_stream();
  }
  }
#line 368
  if (tmp) {
    {
    {
#line 368
    tmp___0 = last_byte();
    }
    }
#line 368
    if (tmp___0) {
#line 368
      return (0);
    }
  }
#line 370
  if ((unsigned long )in_buffer.read_pos == (unsigned long )((void *)0)) {
    {
    {
#line 372
    tmp___1 = read_input_stream();
    }
    }
#line 372
    if (! tmp___1) {
#line 372
      return (0);
    }
  }
#line 375
  in_buffer.block_offset = (off_t )0;
  {
  {
#line 378
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 380
    if ((unsigned long )in_buffer.read_pos >= (unsigned long )in_buffer.low_pos) {
      {
      {
#line 380
      read_input_stream();
      }
      }
    }
    {
    {
#line 382
    tmp___2 = last_byte();
    }
    }
#line 382
    if (tmp___2) {
#line 382
      (in_buffer.read_pos) ++;
    }
#line 383
    in_buffer.block_end = (unsigned char *)((void *)0);
#line 385
    scan_start = in_buffer.read_pos;
#line 387
    if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 389
      safe_search = in_buffer.stream_end;
    } else {
#line 392
      safe_search = in_buffer.low_pos;
    }
#line 395
    if ((unsigned long )in_buffer.read_pos <= (unsigned long )safe_search) {
#line 397
      if (block.type & 1) {
#line 399
        if (block.start.N >= in_buffer.stream_offset + (off_t )(in_buffer.read_pos - in_buffer.buffer)) {
#line 399
          if (block.start.N <= in_buffer.stream_offset + (off_t )(safe_search - in_buffer.buffer)) {
#line 402
            in_buffer.read_pos = in_buffer.buffer + (block.start.N - in_buffer.stream_offset);
#line 403
            found = 1;
          } else {
#line 406
            in_buffer.read_pos = safe_search;
          }
        } else {
#line 406
          in_buffer.read_pos = safe_search;
        }
      }
#line 410
      if (block.type & 2) {
#line 412
        if (block.start.S.length > 0LL) {
#line 414
          i = 0;
#line 415
          if ((unsigned long )in_buffer.stream_end == (unsigned long )((void *)0)) {
#line 415
            safe_search += block.start.S.length - 1LL;
          }
          {
          {
#line 416
          while (1) {
            while_continue___3: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
#line 416
            if ((unsigned long )in_buffer.read_pos <= (unsigned long )((safe_search - block.start.S.length) + 1)) {
#line 416
              if (! ((off_t )i < block.start.S.length)) {
#line 416
                goto while_break___0;
              }
            } else {
#line 416
              goto while_break___0;
            }
#line 418
            i = 0;
            {
            {
#line 419
            while (1) {
              while_continue___4: /* CIL Label */ ;
              while_continue___1: /* CIL Label */ ;
#line 419
              if ((int )*(in_buffer.read_pos) == (int )*(block.start.S.string + i)) {
#line 419
                if (! ((off_t )i < block.start.S.length)) {
#line 419
                  goto while_break___1;
                }
              } else {
#line 419
                goto while_break___1;
              }
#line 421
              (in_buffer.read_pos) ++;
#line 422
              i ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 424
            if (i) {
#line 426
              in_buffer.read_pos -= i - 1;
            } else {
#line 429
              (in_buffer.read_pos) ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 433
          if ((off_t )i == block.start.S.length) {
#line 435
            (in_buffer.read_pos) --;
#line 436
            found = 1;
          } else
#line 437
          if ((unsigned long )scan_start == (unsigned long )in_buffer.read_pos) {
#line 439
            (in_buffer.read_pos) ++;
          }
#line 442
          if ((unsigned long )in_buffer.read_pos > (unsigned long )in_buffer.stream_end) {
#line 442
            if ((unsigned long )in_buffer.stream_end != (unsigned long )((void *)0)) {
#line 442
              (in_buffer.read_pos) --;
            }
          }
        } else {
#line 446
          found = 1;
        }
      }
#line 449
      if ((unsigned long )in_buffer.read_pos > (unsigned long )scan_start) {
#line 449
        if (! output_only_block) {
          {
          {
#line 450
          write_output_stream(scan_start, (ssize_t )(in_buffer.read_pos - scan_start));
          }
          }
        }
      }
#line 451
      if (found) {
        {
        {
#line 451
        mark_block_end();
        }
        }
      }
    }
#line 378
    if (! found) {
      {
      {
#line 378
      tmp___3 = end_of_stream();
      }
      }
#line 378
      if (tmp___3) {
#line 378
        goto while_break;
      }
    } else {
#line 378
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 454
  tmp___4 = end_of_stream();
  }
  }
#line 454
  if (tmp___4) {
#line 454
    if (! found) {
#line 454
      if (! output_only_block) {
        {
        {
#line 454
        write_output_stream(in_buffer.read_pos, 1);
        }
        }
      }
    }
  }
#line 455
  if (found) {
#line 455
    (in_buffer.block_num) ++;
  }
#line 456
  return (found);
}
}
#line 460 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void write_string(char *string___3 ) 
{ 
  register char *f ;

  {
#line 465
  f = string___3;
  {
  {
#line 467
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 467
    if (! ((int )*f != 0)) {
#line 467
      goto while_break;
    }
#line 467
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 469
  write_buffer((unsigned char *)string___3, (off_t )(f - string___3));
  }
  }
#line 470
  return;
}
}
#line 473 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void write_buffer(unsigned char *buf , off_t length ) 
{ 
  char *__cil_tmp3 ;

  {
#line 477
  if (! length) {
#line 477
    return;
  }
#line 479
  if ((unsigned long )(out_buffer.write_pos + length) >= (unsigned long )out_buffer.end) {
#line 481
    if ((unsigned long )out_buffer.write_pos == (unsigned long )out_buffer.buffer) {
      {
      {
#line 481
      panic((char *)"Out buffer too small, should not happen!", (char *)((void *)0),
            (char *)((void *)0));
      }
      }
    }
    {
    {
#line 482
    flush_buffer();
    }
    }
  }
  {
  {
#line 484
  memcpy((void */* __restrict  */)out_buffer.write_pos, (void const   */* __restrict  */)buf,
         (size_t )length);
  }
#line 485
  out_buffer.write_pos += length;
#line 486
  out_buffer.block_offset += length;
  }
#line 487
  return;
}
}
#line 490 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void put_byte(unsigned char byte ) 
{ 


  {
#line 493
  *(out_buffer.write_pos) = byte;
#line 494
  return;
}
}
#line 498 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void write_next_byte(void) 
{ 


  {
#line 501
  (out_buffer.write_pos) ++;
#line 502
  (out_buffer.block_offset) ++;
#line 503
  if ((unsigned long )out_buffer.write_pos >= (unsigned long )out_buffer.end) {
    {
    {
#line 505
    flush_buffer();
    }
    }
  }
#line 507
  return;
}
}
#line 510 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void flush_buffer(void) 
{ 


  {
  {
  {
#line 513
  write_output_stream(out_buffer.buffer, (ssize_t )(out_buffer.write_pos - out_buffer.buffer));
  }
  {
#line 514
  write_w_command(out_buffer.buffer, (size_t )(out_buffer.write_pos - out_buffer.buffer));
  }
#line 515
  out_buffer.write_pos = out_buffer.buffer;
  }
#line 516
  return;
}
}
#line 519 "/home/wslee/benchmarks/bbe-0.2.2/src/buffer.c"
void close_output_stream(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 522
  tmp___1 = close(out_stream.fd);
  }
  }
#line 522
  if (tmp___1 == -1) {
    {
    {
#line 522
    tmp = __errno_location();
    }
    {
#line 522
    tmp___0 = strerror(*tmp);
    }
    {
#line 522
    panic((char *)"Error closing output stream", out_stream.file, tmp___0);
    }
    }
  }
#line 523
  return;
}
}
#line 38 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char *program___0  =    (char *)"bbe";
#line 44 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char *version___0  =    (char *)"0.2.2";
#line 50 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char *email_address___0  =    (char *)"tjsa@iki.fi";
#line 89 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static char short_opts___0[12]  = 
#line 89
  {      (char )'b',      (char )':',      (char )'e',      (char )':', 
        (char )'f',      (char )':',      (char )'o',      (char )':', 
        (char )'s',      (char )'?',      (char )'V',      (char )'\000'};
#line 92 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static struct option long_opts___0[8]  = 
#line 92
  {      {"block", 1, (int *)((void *)0), 'b'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"help", 0, (int *)((void *)0), '?'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"suppress", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 272 "/home/wslee/benchmarks/bbe-0.2.2/src/bbe.c"
static void parse_block___0(char *bs ) 
{ 
  char slash_char ;
  char *p ;
  int i ;
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  unsigned short const   **tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  unsigned short const   **tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  unsigned short const   **tmp___30 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 276
  p = bs;
#line 277
  i = 0;
  {
#line 280
  tmp = strlen((char const   *)bs);
  }
  }
#line 280
  if (tmp > 131072U) {
    {
    {
#line 282
    panic((char *)"Block definition too long", (char *)((void *)0), (char *)((void *)0));
    }
    }
  }
  {
  {
#line 285
  tmp___0 = xmalloc((size_t )131072);
  }
#line 285
  buf = (char *)tmp___0;
  }
#line 287
  if ((int )*p == 58) {
#line 289
    block.start.S.length = (off_t )0;
#line 290
    block.type |= 2;
  } else
#line 293
  if ((int )*p == 120) {
#line 293
    goto _L;
  } else
#line 293
  if ((int )*p == 88) {
#line 293
    goto _L;
  } else {
    {
    {
#line 293
    tmp___15 = __ctype_b_loc();
    }
    }
#line 293
    if ((int const   )*(*tmp___15 + (int )*p) & 2048) {
      _L: /* CIL Label */ 
      {
#line 298
      if ((int )*p == 88) {
#line 298
        goto case_88;
      }
#line 298
      if ((int )*p == 120) {
#line 298
        goto case_88;
      }
#line 303
      if ((int )*p == 48) {
#line 303
        goto case_48;
      }
#line 306
      goto switch_default;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
#line 299
      tmp___1 = i;
#line 299
      i ++;
#line 299
      *(buf + tmp___1) = (char )'0';
#line 300
      tmp___2 = i;
#line 300
      i ++;
#line 300
      tmp___3 = p;
#line 300
      p ++;
#line 300
      *(buf + tmp___2) = *tmp___3;
      {
      {
#line 301
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 301
        tmp___6 = __ctype_b_loc();
        }
        }
#line 301
        if (! ((int const   )*(*tmp___6 + (int )*p) & 4096)) {
#line 301
          goto while_break;
        }
#line 301
        tmp___4 = i;
#line 301
        i ++;
#line 301
        tmp___5 = p;
#line 301
        p ++;
#line 301
        *(buf + tmp___4) = *tmp___5;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 302
      goto switch_break;
      case_48: /* CIL Label */ 
      {
      {
#line 304
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 304
        tmp___9 = __ctype_b_loc();
        }
        }
#line 304
        if ((int const   )*(*tmp___9 + (int )*p) & 2048) {
#line 304
          if (! ((int )*p < 56)) {
#line 304
            goto while_break___0;
          }
        } else {
#line 304
          goto while_break___0;
        }
#line 304
        tmp___7 = i;
#line 304
        i ++;
#line 304
        tmp___8 = p;
#line 304
        p ++;
#line 304
        *(buf + tmp___7) = *tmp___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 305
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 307
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 307
        tmp___12 = __ctype_b_loc();
        }
        }
#line 307
        if (! ((int const   )*(*tmp___12 + (int )*p) & 2048)) {
#line 307
          goto while_break___1;
        }
#line 307
        tmp___10 = i;
#line 307
        i ++;
#line 307
        tmp___11 = p;
#line 307
        p ++;
#line 307
        *(buf + tmp___10) = *tmp___11;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 308
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 311
      *(buf + i) = (char)0;
      {
#line 312
      block.start.N = parse_long(buf);
      }
#line 313
      block.type |= 1;
      }
    } else {
#line 316
      slash_char = *p;
#line 317
      p ++;
      {
      {
#line 318
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 318
        if ((int )*p != (int )slash_char) {
#line 318
          if (! ((int )*p != 0)) {
#line 318
            goto while_break___2;
          }
        } else {
#line 318
          goto while_break___2;
        }
#line 318
        tmp___13 = i;
#line 318
        i ++;
#line 318
        tmp___14 = p;
#line 318
        p ++;
#line 318
        *(buf + tmp___13) = *tmp___14;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 319
      if ((int )*p == (int )slash_char) {
#line 319
        p ++;
      }
      {
#line 320
      *(buf + i) = (char)0;
      {
#line 321
      block.start.S.string = parse_string(buf, & block.start.S.length);
      }
#line 322
      block.type |= 2;
      }
    }
  }
#line 326
  if ((int )*p != 58) {
    {
    {
#line 328
    panic((char *)"Error in block definition", bs, (char *)((void *)0));
    }
    }
  }
#line 331
  p ++;
#line 333
  if ((int )*p == 0) {
#line 335
    block.stop.S.length = (off_t )0;
#line 336
    block.type |= 8;
  } else {
#line 339
    i = 0;
#line 340
    if ((int )*p == 120) {
#line 340
      goto _L___0;
    } else
#line 340
    if ((int )*p == 88) {
#line 340
      goto _L___0;
    } else {
      {
      {
#line 340
      tmp___30 = __ctype_b_loc();
      }
      }
#line 340
      if ((int const   )*(*tmp___30 + (int )*p) & 4096) {
        _L___0: /* CIL Label */ 
        {
#line 345
        if ((int )*p == 88) {
#line 345
          goto case_88___0;
        }
#line 345
        if ((int )*p == 120) {
#line 345
          goto case_88___0;
        }
#line 350
        if ((int )*p == 48) {
#line 350
          goto case_48___0;
        }
#line 353
        goto switch_default___0;
        case_88___0: /* CIL Label */ 
        case_120___0: /* CIL Label */ 
#line 346
        tmp___16 = i;
#line 346
        i ++;
#line 346
        *(buf + tmp___16) = (char )'0';
#line 347
        tmp___17 = i;
#line 347
        i ++;
#line 347
        tmp___18 = p;
#line 347
        p ++;
#line 347
        *(buf + tmp___17) = *tmp___18;
        {
        {
#line 348
        while (1) {
          while_continue___11: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
          {
          {
#line 348
          tmp___21 = __ctype_b_loc();
          }
          }
#line 348
          if (! ((int const   )*(*tmp___21 + (int )*p) & 4096)) {
#line 348
            goto while_break___3;
          }
#line 348
          tmp___19 = i;
#line 348
          i ++;
#line 348
          tmp___20 = p;
#line 348
          p ++;
#line 348
          *(buf + tmp___19) = *tmp___20;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 349
        goto switch_break___0;
        case_48___0: /* CIL Label */ 
        {
        {
#line 351
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
          {
          {
#line 351
          tmp___24 = __ctype_b_loc();
          }
          }
#line 351
          if ((int const   )*(*tmp___24 + (int )*p) & 2048) {
#line 351
            if (! ((int )*p < 56)) {
#line 351
              goto while_break___4;
            }
          } else {
#line 351
            goto while_break___4;
          }
#line 351
          tmp___22 = i;
#line 351
          i ++;
#line 351
          tmp___23 = p;
#line 351
          p ++;
#line 351
          *(buf + tmp___22) = *tmp___23;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 352
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
        {
#line 354
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
          {
          {
#line 354
          tmp___27 = __ctype_b_loc();
          }
          }
#line 354
          if (! ((int const   )*(*tmp___27 + (int )*p) & 2048)) {
#line 354
            goto while_break___5;
          }
#line 354
          tmp___25 = i;
#line 354
          i ++;
#line 354
          tmp___26 = p;
#line 354
          p ++;
#line 354
          *(buf + tmp___25) = *tmp___26;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 355
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 357
        *(buf + i) = (char)0;
        {
#line 358
        block.stop.M = parse_long(buf);
        }
        }
#line 359
        if (block.stop.M == 0LL) {
          {
          {
#line 359
          panic((char *)"Block length must be greater than zero", (char *)((void *)0),
                (char *)((void *)0));
          }
          }
        }
#line 360
        block.type |= 4;
      } else
#line 363
      if ((int )*p == 36) {
#line 365
        block.stop.S.length = (off_t )0;
#line 366
        p ++;
      } else {
#line 369
        slash_char = *p;
#line 370
        p ++;
        {
        {
#line 371
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 371
          if ((int )*p != (int )slash_char) {
#line 371
            if (! ((int )*p != 0)) {
#line 371
              goto while_break___6;
            }
          } else {
#line 371
            goto while_break___6;
          }
#line 371
          tmp___28 = i;
#line 371
          i ++;
#line 371
          tmp___29 = p;
#line 371
          p ++;
#line 371
          *(buf + tmp___28) = *tmp___29;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 372
        if ((int )*p == (int )slash_char) {
#line 374
          p ++;
        } else {
          {
          {
#line 377
          panic((char *)"syntax error in block definition", bs, (char *)((void *)0));
          }
          }
        }
        {
#line 379
        *(buf + i) = (char)0;
        {
#line 380
        block.stop.S.string = parse_string(buf, & block.stop.S.length);
        }
#line 381
        block.type |= 8;
        }
      }
    }
  }
#line 385
  if ((int )*p != 0) {
    {
    {
#line 387
    panic((char *)"syntax error in block definition", bs, (char *)((void *)0));
    }
    }
  }
  {
  {
#line 389
  free((void *)buf);
  }
  }
#line 390
  return;
}
}
#line 33 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int delete_this_byte___0  ;
#line 36 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int delete_this_block___0  ;
#line 39 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int skip_this_block___0  ;
#line 42 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int inserting___0  ;
#line 47 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static int w_commands_block_num___0  =    0;
#line 50 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static struct command_list *current_byte_commands___0  ;
#line 62 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static char string___1[128]  ;
#line 99 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static char string___2[128]  ;
#line 132 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static unsigned char ioblock___0[8192]  ;
#line 531 "/home/wslee/benchmarks/bbe-0.2.2/src/execute.c"
static char file___0[4096]  ;
