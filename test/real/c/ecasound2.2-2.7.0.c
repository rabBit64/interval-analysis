/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 37 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 40 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_21 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_21 __sigset_t;
#line 50 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_24 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_26 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_27 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_28 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_22 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_23 _kill ;
   struct __anonstruct__timer_24 _timer ;
   struct __anonstruct__rt_25 _rt ;
   struct __anonstruct__sigchld_26 _sigchld ;
   struct __anonstruct__sigfault_27 _sigfault ;
   struct __anonstruct__sigpoll_28 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_22 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_40 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_40 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 33 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc.h"
typedef void *eci_handle_t;
#line 140 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
struct eci_string_s {
   char *d ;
   int slen ;
   int size ;
};
#line 145 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
typedef struct eci_string_s eci_string;
#line 147 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
struct eci_los_list {
   struct eci_los_list *prev_repp ;
   struct eci_los_list *next_repp ;
   eci_string data_repp ;
};
#line 153 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
struct eci_parser {
   int state_rep ;
   int state_msg_rep ;
   double last_f_rep ;
   long last_li_rep ;
   int last_i_rep ;
   int last_counter_rep ;
   char last_type_repp[4] ;
   struct eci_los_list *last_los_repp ;
   eci_string last_error_repp ;
   eci_string last_s_repp ;
   eci_string buffer_rep ;
   int msgsize_rep ;
   int loglevel_rep ;
   int token_phase_rep ;
   int buffer_current_rep ;
   _Bool sync_lost_rep ;
};
#line 178 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
struct eci_internal {
   int pid_of_child_rep ;
   int pid_of_parent_rep ;
   int cmd_read_fd_rep ;
   int cmd_write_fd_rep ;
   char last_command_repp[64] ;
   int commands_counter_rep ;
   struct eci_parser *parser_repp ;
   char farg_buf_repp[32] ;
   char raw_buffer_repp[65536] ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 170 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 24 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   __time_t st_atime ;
   unsigned long st_atimensec ;
   __time_t st_mtime ;
   unsigned long st_mtimensec ;
   __time_t st_ctime ;
   unsigned long st_ctimensec ;
   __ino64_t st_ino ;
};
#line 67 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecalength.c"
struct options {
   char adjust ;
   char format ;
   char total ;
   char script ;
   char human ;
   char bits ;
   char ccount ;
   char rate ;
   char samples ;
};
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 255
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 145 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 148
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 151
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 58 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 598
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 684
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 39 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc.h"
void eci_init(void) ;
#line 40
eci_handle_t eci_init_r(void) ;
#line 42
int eci_ready(void) ;
#line 43
int eci_ready_r(eci_handle_t ptr ) ;
#line 45
void eci_cleanup(void) ;
#line 46
void eci_cleanup_r(eci_handle_t ptr ) ;
#line 52
void eci_command(char const   *command ) ;
#line 53
void eci_command_r(eci_handle_t ptr , char const   *command ) ;
#line 55
void eci_command_float_arg(char const   *command , double arg ) ;
#line 56
void eci_command_float_arg_r(eci_handle_t ptr , char const   *command , double arg ) ;
#line 62
int eci_last_string_list_count(void) ;
#line 63
int eci_last_string_list_count_r(eci_handle_t ptr ) ;
#line 65
char const   *eci_last_string_list_item(int n ) ;
#line 66
char const   *eci_last_string_list_item_r(eci_handle_t ptr , int n ) ;
#line 68
char const   *eci_last_string(void) ;
#line 69
char const   *eci_last_string_r(eci_handle_t ptr ) ;
#line 71
double eci_last_float(void) ;
#line 72
double eci_last_float_r(eci_handle_t ptr ) ;
#line 74
int eci_last_integer(void) ;
#line 75
int eci_last_integer_r(eci_handle_t ptr ) ;
#line 77
long eci_last_long_integer(void) ;
#line 78
long eci_last_long_integer_r(eci_handle_t ptr ) ;
#line 80
char const   *eci_last_error(void) ;
#line 81
char const   *eci_last_error_r(eci_handle_t ptr ) ;
#line 83
char const   *eci_last_type(void) ;
#line 84
char const   *eci_last_type_r(eci_handle_t ptr ) ;
#line 86
int eci_error(void) ;
#line 87
int eci_error_r(eci_handle_t ptr ) ;
#line 93
int eci_events_available(void) ;
#line 94
int eci_events_available_r(eci_handle_t ptr ) ;
#line 96
void eci_next_event(void) ;
#line 97
void eci_next_event_r(eci_handle_t ptr ) ;
#line 99
char const   *eci_current_event(void) ;
#line 100
char const   *eci_current_event_r(eci_handle_t ptr ) ;
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep  =    (eci_handle_t )0;
#line 202 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_str_no_ecasound_env  =    "\n***********************************************************************\n* Message from libecasoundc:\n* \n* \'ECASOUND\' environment variable not set. Using the default value \n* value \'ECASOUND=ecasound\'.\n***********************************************************************\n\n";
#line 212 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_str_null_handle  =    "\n***********************************************************************\n* Message from libecasoundc:\n* \n* A null client handle detected. This is usually caused by a bug \n* in the ECI application. Please report this bug to the author of\n* the program.\n***********************************************************************\n\n";
#line 223 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_str_sync_lost  =    "\n***********************************************************************\n* Message from libecasoundc:\n* \n* Connection to the processing engine was lost. Check that ecasound \n* is correctly installed. Also make sure that ecasound is either \n* in some directory listed in PATH, or the environment variable\n* \'ECASOUND\' contains the path to a working ecasound executable.\n***********************************************************************\n\n";
#line 239
static void eci_impl_check_handle(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item(struct eci_los_list *head ,
                                                       char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item(void) ;
#line 247
static void eci_impl_los_list_clear(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state(struct eci_parser *parser , char c ) ;
#line 262 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 264
  if (! ((unsigned long )static_eci_rep == (unsigned long )((void *)0))) {
    {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "static_eci_rep == NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            264);
    }
    }
  }
  {
  {
#line 265
  static_eci_rep = eci_init_r();
  }
  }
#line 266
  return;
}
}
#line 274 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
eci_handle_t eci_init_r(void) 
{ 
  struct eci_internal *eci_rep ;
  int cmd_send_pipe[2] ;
  int cmd_receive_pipe[2] ;
  char const   *ecasound_exec ;
  char const   *tmp ;
  int fork_pid ;
  __pid_t tmp___0 ;
  char const   *args[4] ;
  int res ;
  struct sigaction sa ;
  pid_t pid ;
  __pid_t tmp___1 ;
  int res___0 ;
  char buf[1] ;
  int status ;
  int pid___0 ;
  struct sigaction ign_handler ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 276
  eci_rep = (struct eci_internal *)((void *)0);
  {
#line 278
  tmp = eci_impl_get_ecasound_path();
  }
#line 278
  ecasound_exec = tmp;
  }
#line 281
  if ((unsigned long )ecasound_exec != (unsigned long )((void *)0)) {
    {
    {
#line 281
    tmp___7 = pipe((int *)(cmd_receive_pipe));
    }
    }
#line 281
    if (tmp___7 == 0) {
      {
      {
#line 281
      tmp___8 = pipe((int *)(cmd_send_pipe));
      }
      }
#line 281
      if (tmp___8 == 0) {
        {
        {
#line 283
        tmp___0 = fork();
        }
#line 283
        fork_pid = tmp___0;
        }
#line 285
        if (fork_pid == 0) {
          {
#line 289
          args[0] = (char const   *)((void *)0);
#line 289
          args[1] = "-c";
#line 289
          args[2] = "-D";
#line 289
          args[3] = (char const   *)((void *)0);
#line 290
          res = 0;
#line 294
          sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
          {
#line 295
          sigemptyset(& sa.sa_mask);
          }
#line 296
          sa.sa_flags = 0;
          {
#line 297
          sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
          }
          {
#line 298
          setsid();
          }
          {
#line 301
          tmp___1 = fork();
          }
          }
#line 301
          if (tmp___1 != 0) {
            {
            {
#line 302
            _exit(0);
            }
            }
          }
          {
#line 306
          args[0] = ecasound_exec;
          {
#line 310
          close(0);
          }
          {
#line 311
          close(1);
          }
          {
#line 313
          dup2(cmd_send_pipe[0], 0);
          }
          {
#line 314
          dup2(cmd_receive_pipe[1], 1);
          }
          {
#line 316
          close(cmd_receive_pipe[0]);
          }
          {
#line 317
          close(cmd_receive_pipe[1]);
          }
          {
#line 318
          close(cmd_send_pipe[0]);
          }
          {
#line 319
          close(cmd_send_pipe[1]);
          }
          {
#line 321
          freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                  (FILE */* __restrict  */)stderr);
          }
          {
#line 324
          pid = getpid();
          }
          {
#line 325
          write(1, (void const   *)(& pid), (size_t )sizeof(pid));
          }
          {
#line 328
          res = write(1, (void const   *)(args), (size_t )1);
          }
          {
#line 330
          res = execvp(args[0], (char * const  *)((char **)(args)));
          }
          }
#line 331
          if (res < 0) {
            {
            {
#line 331
            printf((char const   */* __restrict  */)"(ecasoundc_sa) launching ecasound FAILED!\n");
            }
            }
          }
          {
          {
#line 333
          close(0);
          }
          {
#line 334
          close(1);
          }
          {
#line 336
          _exit(res);
          }
          }
        } else {
          {
#line 348
          ign_handler.__sigaction_handler.sa_handler = (void (*)(int  ))1;
          {
#line 349
          sigemptyset(& ign_handler.sa_mask);
          }
#line 350
          ign_handler.sa_flags = 0;
          {
#line 352
          sigaction(13, (struct sigaction  const  */* __restrict  */)(& ign_handler),
                    (struct sigaction */* __restrict  */)0);
          }
          {
#line 353
          sigaction(8, (struct sigaction  const  */* __restrict  */)(& ign_handler),
                    (struct sigaction */* __restrict  */)0);
          }
          {
#line 355
          tmp___2 = calloc((size_t )1, (size_t )sizeof(struct eci_internal ));
          }
#line 355
          eci_rep = (struct eci_internal *)tmp___2;
          {
#line 356
          tmp___3 = calloc((size_t )1, (size_t )sizeof(struct eci_parser ));
          }
#line 356
          eci_rep->parser_repp = (struct eci_parser *)tmp___3;
#line 359
          eci_rep->pid_of_child_rep = fork_pid;
#line 360
          eci_rep->commands_counter_rep = 0;
#line 361
          (eci_rep->parser_repp)->last_counter_rep = 0;
#line 362
          (eci_rep->parser_repp)->token_phase_rep = 0;
#line 363
          (eci_rep->parser_repp)->buffer_current_rep = 0;
#line 364
          (eci_rep->parser_repp)->sync_lost_rep = (_Bool)0;
          {
#line 365
          eci_impl_clean_last_values(eci_rep->parser_repp);
          }
          {
#line 371
          waitpid(eci_rep->pid_of_child_rep, & status, 0);
          }
          {
#line 372
          res___0 = read(cmd_receive_pipe[0], (void *)(& pid___0), (size_t )sizeof(pid___0));
          }
          }
#line 373
          if ((unsigned long )res___0 != sizeof(pid___0)) {
            {
            {
#line 375
            eci_impl_free_parser(eci_rep);
            }
            {
#line 376
            free((void *)eci_rep);
            }
#line 377
            eci_rep = (struct eci_internal *)((void *)0);
            }
          }
          {
#line 379
          eci_rep->pid_of_child_rep = pid___0;
          {
#line 380
          eci_rep->pid_of_parent_rep = getpid();
          }
#line 382
          eci_rep->cmd_read_fd_rep = cmd_receive_pipe[0];
          {
#line 383
          close(cmd_receive_pipe[1]);
          }
#line 384
          eci_rep->cmd_write_fd_rep = cmd_send_pipe[1];
          {
#line 385
          close(cmd_send_pipe[0]);
          }
          {
#line 388
          fcntl(eci_rep->cmd_read_fd_rep, 4, 2048);
          }
          {
#line 389
          fcntl(eci_rep->cmd_write_fd_rep, 4, 2048);
          }
          {
#line 392
          res___0 = eci_impl_fd_read(eci_rep->cmd_read_fd_rep, (void *)(buf), (size_t )1,
                                     5000);
          }
          }
#line 393
          if (res___0 != 1) {
            {
            {
#line 395
            eci_impl_free_parser(eci_rep);
            }
            {
#line 396
            free((void *)eci_rep);
            }
#line 397
            eci_rep = (struct eci_internal *)((void *)0);
            }
          } else {
            {
            {
#line 400
            tmp___4 = strlen("debug 256\n");
            }
            {
#line 400
            write(eci_rep->cmd_write_fd_rep, (void const   *)"debug 256\n", tmp___4);
            }
            {
#line 401
            tmp___5 = strlen("int-set-float-to-string-precision 17\n");
            }
            {
#line 401
            write(eci_rep->cmd_write_fd_rep, (void const   *)"int-set-float-to-string-precision 17\n",
                  tmp___5);
            }
            {
#line 402
            tmp___6 = strlen("int-output-mode-wellformed\n");
            }
            {
#line 402
            write(eci_rep->cmd_write_fd_rep, (void const   *)"int-output-mode-wellformed\n",
                  tmp___6);
            }
#line 403
            (eci_rep->commands_counter_rep) ++;
            {
#line 406
            eci_impl_read_return_value(eci_rep, 5000);
            }
            }
#line 407
            if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
              {
              {
#line 409
              eci_impl_free_parser(eci_rep);
              }
              {
#line 410
              free((void *)eci_rep);
              }
#line 411
              eci_rep = (struct eci_internal *)((void *)0);
              }
            }
          }
        }
      }
    }
  }
#line 417
  return ((eci_handle_t )eci_rep);
}
}
#line 425 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_ready(void) 
{ 
  int tmp ;

  {
  {
  {
#line 427
  tmp = eci_ready_r(static_eci_rep);
  }
  }
#line 427
  return (tmp);
}
}
#line 435 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_ready_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
#line 437
  eci_rep = (struct eci_internal *)ptr;
#line 439
  if (! ptr) {
#line 440
    return (0);
  }
#line 442
  if (eci_rep->pid_of_child_rep <= 0) {
#line 445
    return (0);
  } else
#line 442
  if (eci_rep->cmd_read_fd_rep < 0) {
#line 445
    return (0);
  } else
#line 442
  if (eci_rep->cmd_write_fd_rep < 0) {
#line 445
    return (0);
  }
#line 447
  return (1);
}
}
#line 453 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_cleanup(void) 
{ 


  {
#line 455
  if ((unsigned long )static_eci_rep != (unsigned long )((void *)0)) {
    {
    {
#line 456
    eci_cleanup_r(static_eci_rep);
    }
#line 457
    static_eci_rep = (void *)0;
    }
  }
#line 459
  return;
}
}
#line 464 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_cleanup_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;
  ssize_t resread ;
  ssize_t respoll ;
  char buf[1] ;
  struct pollfd fds[1] ;
  size_t tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 466
  eci_rep = (struct eci_internal *)ptr;
#line 467
  resread = 1;
  {
#line 471
  eci_impl_check_handle(eci_rep);
  }
  {
#line 475
  tmp = strlen("quit\n");
  }
  {
#line 475
  write(eci_rep->cmd_write_fd_rep, (void const   *)"quit\n", tmp);
  }
#line 476
  (eci_rep->commands_counter_rep) ++;
  }
  {
  {
#line 486
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 486
    if (! (resread > 0)) {
#line 486
      goto while_break;
    }
    {
#line 487
    fds[0].fd = eci_rep->cmd_read_fd_rep;
#line 488
    fds[0].events = (short)1;
#line 489
    fds[0].revents = (short)0;
    {
#line 490
    respoll = poll(fds, (nfds_t )1, 30000);
    }
    }
#line 491
    if ((int )fds[0].revents & 17) {
      {
      {
#line 492
      resread = read(eci_rep->cmd_read_fd_rep, (void *)(buf), (size_t )1);
      }
      }
    } else
#line 493
    if ((int )fds[0].revents & 8) {
#line 494
      resread = -2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  if ((unsigned long )eci_rep != (unsigned long )((struct eci_internal *)0)) {
    {
    {
#line 503
    close(eci_rep->cmd_read_fd_rep);
    }
    {
#line 504
    close(eci_rep->cmd_write_fd_rep);
    }
    {
#line 507
    eci_impl_clean_last_values(eci_rep->parser_repp);
    }
    {
#line 509
    eci_impl_free_parser(eci_rep);
    }
    {
#line 510
    free((void *)eci_rep);
    }
    }
  }
#line 512
  return;
}
}
#line 522 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_command(char const   *command ) 
{ 


  {
  {
  {
#line 522
  eci_command_r(static_eci_rep, command);
  }
  }
#line 522
  return;
}
}
#line 528 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_command_r(eci_handle_t ptr , char const   *command ) 
{ 
  struct eci_internal *eci_rep ;
  int timeout ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 530
  eci_rep = (struct eci_internal *)ptr;
#line 531
  timeout = 30000;
  {
#line 533
  eci_impl_check_handle(eci_rep);
  }
  {
#line 535
  tmp = eci_ready_r(ptr);
  }
  }
#line 535
  if (tmp == 0) {
#line 537
    return;
  }
  {
  {
#line 543
  memcpy((void */* __restrict  */)(eci_rep->last_command_repp), (void const   */* __restrict  */)command,
         (size_t )64);
  }
  {
#line 545
  eci_impl_clean_last_values(eci_rep->parser_repp);
  }
  {
#line 547
  tmp___0 = strlen(command);
  }
  {
#line 547
  write(eci_rep->cmd_write_fd_rep, (void const   *)command, tmp___0);
  }
  {
#line 548
  write(eci_rep->cmd_write_fd_rep, (void const   *)"\n", (size_t )1);
  }
  {
#line 551
  tmp___1 = strncmp(command, "run", (size_t )3);
  }
  }
#line 551
  if (tmp___1 == 0) {
#line 553
    timeout = -1;
  }
#line 556
  (eci_rep->commands_counter_rep) ++;
#line 558
  if (eci_rep->commands_counter_rep - 1 != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 560
    eci_impl_dump_parser_state(ptr, "sync error");
    }
#line 561
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 564
  if (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 566
    eci_impl_read_return_value(eci_rep, timeout);
    }
    }
  }
#line 572
  if (eci_rep->commands_counter_rep > (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_sync_lost);
    }
#line 575
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 577
  return;
}
}
#line 583 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_command_float_arg(char const   *command , double arg ) 
{ 


  {
  {
  {
#line 583
  eci_command_float_arg_r(static_eci_rep, command, arg);
  }
  }
#line 583
  return;
}
}
#line 589 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_command_float_arg_r(eci_handle_t ptr , char const   *command , double arg ) 
{ 
  struct eci_internal *eci_rep ;
  char *__cil_tmp5 ;

  {
  {
#line 591
  eci_rep = (struct eci_internal *)ptr;
  {
#line 593
  eci_impl_check_handle(eci_rep);
  }
  {
#line 595
  snprintf((char */* __restrict  */)(eci_rep->farg_buf_repp), (size_t )31, (char const   */* __restrict  */)"%s %.32f",
           command, arg);
  }
  {
#line 596
  eci_command_r(ptr, (char const   *)(eci_rep->farg_buf_repp));
  }
  }
#line 597
  return;
}
}
#line 607 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_last_string_list_count(void) 
{ 
  int tmp ;

  {
  {
  {
#line 607
  tmp = eci_last_string_list_count_r(static_eci_rep);
  }
  }
#line 607
  return (tmp);
}
}
#line 613 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_last_string_list_count_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;
  struct eci_los_list *i ;
  int count ;

  {
  {
#line 615
  eci_rep = (struct eci_internal *)ptr;
#line 617
  count = 0;
  {
#line 619
  eci_impl_check_handle(eci_rep);
  }
#line 621
  i = (eci_rep->parser_repp)->last_los_repp;
  }
  {
  {
#line 621
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 621
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 621
      goto while_break;
    }
#line 624
    count ++;
#line 621
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  return (count);
}
}
#line 637 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_string_list_item(int n ) 
{ 
  char const   *tmp ;

  {
  {
  {
#line 637
  tmp = eci_last_string_list_item_r(static_eci_rep, n);
  }
  }
#line 637
  return (tmp);
}
}
#line 646 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_string_list_item_r(eci_handle_t ptr , int n ) 
{ 
  struct eci_internal *eci_rep ;
  struct eci_los_list *i ;
  int count ;
  int tmp ;

  {
  {
#line 648
  eci_rep = (struct eci_internal *)ptr;
#line 650
  count = 0;
  {
#line 652
  eci_impl_check_handle(eci_rep);
  }
#line 654
  i = (eci_rep->parser_repp)->last_los_repp;
  }
  {
  {
#line 654
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 654
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 654
      goto while_break;
    }
#line 657
    tmp = count;
#line 657
    count ++;
#line 657
    if (tmp == n) {
#line 658
      return ((char const   *)i->data_repp.d);
    }
#line 654
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return ((char const   *)((void *)0));
}
}
#line 665 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_string(void) 
{ 
  char const   *tmp ;

  {
  {
  {
#line 665
  tmp = eci_last_string_r(static_eci_rep);
  }
  }
#line 665
  return (tmp);
}
}
#line 667 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_string_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
  {
#line 669
  eci_rep = (struct eci_internal *)ptr;
  {
#line 671
  eci_impl_check_handle(eci_rep);
  }
  }
#line 673
  return ((char const   *)(eci_rep->parser_repp)->last_s_repp.d);
}
}
#line 676 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
double eci_last_float(void) 
{ 
  double tmp ;

  {
  {
  {
#line 676
  tmp = eci_last_float_r(static_eci_rep);
  }
  }
#line 676
  return (tmp);
}
}
#line 678 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
double eci_last_float_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
  {
#line 680
  eci_rep = (struct eci_internal *)ptr;
  {
#line 682
  eci_impl_check_handle(eci_rep);
  }
  }
#line 684
  return ((eci_rep->parser_repp)->last_f_rep);
}
}
#line 687 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_last_integer(void) 
{ 
  int tmp ;

  {
  {
  {
#line 687
  tmp = eci_last_integer_r(static_eci_rep);
  }
  }
#line 687
  return (tmp);
}
}
#line 689 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_last_integer_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
  {
#line 691
  eci_rep = (struct eci_internal *)ptr;
  {
#line 693
  eci_impl_check_handle(eci_rep);
  }
  }
#line 695
  return ((eci_rep->parser_repp)->last_i_rep);
}
}
#line 698 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
long eci_last_long_integer(void) 
{ 
  long tmp ;

  {
  {
  {
#line 698
  tmp = eci_last_long_integer_r(static_eci_rep);
  }
  }
#line 698
  return (tmp);
}
}
#line 700 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
long eci_last_long_integer_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
  {
#line 702
  eci_rep = (struct eci_internal *)ptr;
  {
#line 704
  eci_impl_check_handle(eci_rep);
  }
  }
#line 706
  return ((eci_rep->parser_repp)->last_li_rep);
}
}
#line 713 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_error(void) 
{ 
  char const   *tmp ;

  {
  {
  {
#line 713
  tmp = eci_last_error_r(static_eci_rep);
  }
  }
#line 713
  return (tmp);
}
}
#line 719 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_error_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
  {
#line 721
  eci_rep = (struct eci_internal *)ptr;
  {
#line 723
  eci_impl_check_handle(eci_rep);
  }
  }
#line 725
  return ((char const   *)(eci_rep->parser_repp)->last_error_repp.d);
}
}
#line 729 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_type(void) 
{ 
  char const   *tmp ;

  {
  {
  {
#line 729
  tmp = eci_last_type_r(static_eci_rep);
  }
  }
#line 729
  return (tmp);
}
}
#line 731 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_last_type_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;

  {
  {
#line 733
  eci_rep = (struct eci_internal *)ptr;
  {
#line 735
  eci_impl_check_handle(eci_rep);
  }
  }
#line 737
  return ((char const   *)((eci_rep->parser_repp)->last_type_repp));
}
}
#line 745 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_error(void) 
{ 
  int tmp ;

  {
  {
  {
#line 745
  tmp = eci_error_r(static_eci_rep);
  }
  }
#line 745
  return (tmp);
}
}
#line 752 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_error_r(eci_handle_t ptr ) 
{ 
  struct eci_internal *eci_rep ;
  int res ;
  int tmp ;

  {
  {
#line 754
  eci_rep = (struct eci_internal *)ptr;
  {
#line 757
  eci_impl_check_handle(eci_rep);
  }
  {
#line 759
  tmp = eci_ready_r(ptr);
  }
  }
#line 759
  if (tmp == 0) {
#line 761
    return (1);
  }
#line 764
  if ((int )(eci_rep->parser_repp)->sync_lost_rep == 1) {
#line 766
    return (1);
  }
#line 769
  if ((int )(eci_rep->parser_repp)->last_type_repp[0] == 101) {
#line 769
    res = 1;
  } else {
#line 769
    res = 0;
  }
#line 773
  return (res);
}
}
#line 780 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_events_available(void) 
{ 
  int tmp ;

  {
  {
  {
#line 780
  tmp = eci_events_available_r(static_eci_rep);
  }
  }
#line 780
  return (tmp);
}
}
#line 781 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
int eci_events_available_r(eci_handle_t ptr ) 
{ 


  {
#line 781
  return (0);
}
}
#line 782 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_next_event(void) 
{ 


  {
  {
  {
#line 782
  eci_next_event_r(static_eci_rep);
  }
  }
#line 782
  return;
}
}
#line 783 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
void eci_next_event_r(eci_handle_t ptr ) 
{ 


  {
#line 783
  return;
}
}
#line 784 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_current_event(void) 
{ 
  char const   *tmp ;

  {
  {
  {
#line 784
  tmp = eci_current_event_r(static_eci_rep);
  }
  }
#line 784
  return (tmp);
}
}
#line 785 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
char const   *eci_current_event_r(eci_handle_t ptr ) 
{ 


  {
#line 785
  return ((char const   *)0);
}
}
#line 791
static void eci_string_add(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item(struct eci_los_list *head ,
                                                       char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item();
  }
  {
#line 972
  eci_string_add(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                           timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n), 1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                     1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                     1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d, parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                 parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                   1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___0  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___0(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___0(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___0(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___0(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___0(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___0(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___0(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___0(void) ;
#line 247
static void eci_impl_los_list_clear___0(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___0(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___0(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___0(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___0(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___0(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___0(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___0(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___0(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___0(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___0(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___0(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___0(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___0(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___0(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___0(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___0(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___0(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___0(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___0(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___0(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___0(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___0(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___0(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___0();
  }
  {
#line 972
  eci_string_add___0(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___0(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___0(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___0(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___0(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___0(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___0(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___0(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___0((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___0(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___0(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___0(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___0(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___0(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___0(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___0(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___0(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___0(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___0(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___0(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___0(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___0(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___0(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___0(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___0(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___0(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___0(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___0(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___0(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___0(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 507
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 1002
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) truncate)(char const   *__file ,
                                                                                     __off64_t __length )  __asm__("truncate64")  ;
#line 217 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 49 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
int main(int argc , char **argv ) ;
#line 51
static void add_input_to_chainsetup(eci_handle_t eci , char const   *nexttrack ) ;
#line 52
static int flush_tracks(void) ;
#line 53
static char const   *get_next_track(int *tracknum , int argc , char **argv , eci_handle_t *eci ) ;
#line 54
static char *get_playlist_path(void) ;
#line 55
static char const   *get_track_cmdline(int n , int argc , char **argv ) ;
#line 56
static char const   *get_track_playlist(int *next_track ) ;
#line 57
static void initialize_chainsetup_for_playback(eci_handle_t *eci , char const   *nexttrack ,
                                               int tracknum ) ;
#line 58
static void initialize_check_output(eci_handle_t *eci ) ;
#line 59
static int list_tracks(void) ;
#line 60
static int play_tracks(int argc , char **argv ) ;
#line 61
static void print_usage___0(FILE *stream ) ;
#line 62
static int process_option(char const   *option ) ;
#line 63
static int queue_tracks(int argc , char **argv ) ;
#line 64
static int set_audio_format(eci_handle_t *eci , char const   *fmt ) ;
#line 65
static void setup_signal_handling(void) ;
#line 66
static void signal_handler(int signum ) ;
#line 89 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *ecaplay_version  =    "20061206-45";
#line 90 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char ecaplay_next[4096]  ;
#line 91 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char ecaplay_audio_format[64]  ;
#line 92 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *ecaplay_output  =    (char const   *)((void *)0);
#line 93 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_debuglevel  =    256;
#line 94 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_skip  =    0;
#line 95 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_mode  =    0;
#line 97 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_initialized  =    0;
#line 98 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static sig_atomic_t ecaplay_skip_flag  =    0;
#line 104 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int res ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 106
  res = 0;
  {
#line 109
  tmp = getenv("ECAPLAY_OUTPUT_DEVICE");
  }
#line 109
  ecaplay_output = (char const   *)tmp;
#line 112
  i = 1;
  }
  {
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < argc)) {
#line 112
      goto while_break;
    }
    {
    {
#line 112
    tmp___0 = process_option((char const   *)*(argv + i));
    }
#line 112
    res += tmp___0;
#line 112
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (res == 0) {
    {
#line 116
    if (ecaplay_mode == 1) {
#line 116
      goto case_1;
    }
#line 120
    if (ecaplay_mode == 2) {
#line 120
      goto case_2;
    }
#line 124
    if (ecaplay_mode == 4) {
#line 124
      goto case_4;
    }
#line 129
    if (ecaplay_mode == 3) {
#line 129
      goto case_3;
    }
#line 129
    if (ecaplay_mode == 0) {
#line 129
      goto case_3;
    }
#line 133
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 117
    res = flush_tracks();
    }
    }
#line 118
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 121
    res = list_tracks();
    }
    }
#line 122
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    {
#line 125
    res = queue_tracks(argc, argv);
    }
    }
#line 126
    goto switch_break;
    case_3: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
    {
#line 130
    res = play_tracks(argc, argv);
    }
    }
#line 131
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 138
  if (res != 0) {
    {
    {
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Errors encountered, return code is %d.\n",
            res);
    }
    }
  }
#line 142
  return (res);
}
}
#line 149 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void add_input_to_chainsetup(eci_handle_t eci , char const   *nexttrack ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmpbuf ;
  void *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 151
  tmp = strlen("ai-add \'");
  }
  {
#line 151
  tmp___0 = strlen(nexttrack);
  }
  {
#line 151
  tmp___1 = strlen("\'");
  }
#line 151
  len = ((tmp + tmp___0) + tmp___1) + 1U;
  {
#line 152
  tmp___2 = malloc(len);
  }
#line 152
  tmpbuf = (char *)tmp___2;
  {
#line 155
  snprintf((char */* __restrict  */)tmpbuf, len, (char const   */* __restrict  */)"ai-add \"%s\"",
           nexttrack);
  }
  {
#line 156
  eci_command_r(eci, (char const   *)tmpbuf);
  }
  {
#line 159
  eci_command_r(eci, "ai-list");
  }
  {
#line 160
  tmp___3 = eci_last_string_list_count_r(eci);
  }
  }
#line 160
  if (tmp___3 != 1) {
    {
    {
#line 161
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Warning! Failed to add input \'%s\'.\n",
            nexttrack);
    }
    }
  }
  {
  {
#line 165
  eci_command_r(eci, "ao-add null");
  }
  {
#line 166
  eci_command_r(eci, "cs-connect");
  }
  {
#line 167
  eci_command_r(eci, "ai-iselect 1");
  }
  {
#line 168
  eci_command_r(eci, "ai-get-format");
  }
  {
#line 170
  tmp___4 = eci_last_string_r(eci);
  }
  {
#line 170
  strncpy((char */* __restrict  */)(ecaplay_audio_format), (char const   */* __restrict  */)tmp___4,
          (size_t )64);
  }
#line 173
  ecaplay_audio_format[63] = (char)0;
  {
#line 176
  eci_command_r(eci, "cs-disconnect");
  }
  {
#line 177
  eci_command_r(eci, "ao-iselect 1");
  }
  {
#line 178
  eci_command_r(eci, "ao-remove");
  }
  {
#line 180
  free((void *)tmpbuf);
  }
  }
#line 181
  return;
}
}
#line 188 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int flush_tracks(void) 
{ 
  char *path ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 190
  tmp = get_playlist_path();
  }
#line 190
  path = tmp;
  {
#line 191
  tmp___0 = truncate((char const   *)path, (__off64_t )0);
  }
  }
#line 191
  if (tmp___0 != 0) {
    {
    {
#line 192
    printf((char const   */* __restrict  */)"(ecaplay) Unable to flush playlist \'%s\'.\n",
           path);
    }
    }
#line 193
    return (-1);
  }
#line 195
  return (0);
}
}
#line 209 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int once  =    1;
#line 202 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void initialize_check_output(eci_handle_t *eci ) 
{ 
  char *tmpstr ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 204
  eci_command_r((eci_handle_t )eci, "ao-list");
  }
  {
#line 205
  tmp___1 = eci_last_string_list_count_r((eci_handle_t )eci);
  }
  }
#line 205
  if (tmp___1 != 1) {
    {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Warning! Failed to add output device.\n");
    }
    }
  } else
#line 210
  if (once) {
    {
    {
#line 211
    eci_command_r((eci_handle_t )eci, "ao-iselect 1");
    }
    {
#line 212
    eci_command_r((eci_handle_t )eci, "ao-describe");
    }
    {
#line 213
    tmp = eci_last_string_r((eci_handle_t )eci);
    }
#line 213
    tmpstr = (char *)tmp;
    }
    {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 215
      if (*tmpstr) {
#line 215
        tmp___0 = tmpstr;
#line 215
        tmpstr ++;
#line 215
        if (! ((int )*tmp___0 != 58)) {
#line 215
          goto while_break;
        }
      } else {
#line 215
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 217
    printf((char const   */* __restrict  */)"(ecaplay) Output device: \'%s\'\n", tmpstr);
    }
#line 218
    once = 0;
    }
  }
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void initialize_chainsetup_for_playback(eci_handle_t *eci , char const   *nexttrack ,
                                               int tracknum ) 
{ 
  char const   *ret ;
  char tmpbuf[32] ;
  int tmp ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmpbuf___0 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 225
  ret = (char const   *)((void *)0);
  {
#line 227
  *eci = eci_init_r();
  }
#line 228
  ecaplay_initialized = 1;
  }
#line 230
  if (ecaplay_debuglevel != -1) {
    {
    {
#line 232
    snprintf((char */* __restrict  */)(tmpbuf), (size_t )32, (char const   */* __restrict  */)"debug %d",
             ecaplay_debuglevel);
    }
    {
#line 233
    eci_command_r(*eci, (char const   *)(tmpbuf));
    }
    }
  }
  {
  {
#line 236
  eci_command_r(*eci, "cs-add ecaplay_chainsetup");
  }
  {
#line 238
  eci_command_r(*eci, "cs-list");
  }
  {
#line 239
  tmp = eci_last_string_list_count_r(*eci);
  }
  }
#line 239
  if (tmp != 2) {
    {
    {
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Warning! Failed to add a new chainsetup.\n");
    }
    }
  }
  {
  {
#line 245
  eci_command_r(*eci, "c-add ecaplay_chain");
  }
  {
#line 247
  add_input_to_chainsetup(*eci, nexttrack);
  }
  {
#line 248
  set_audio_format((eci_handle_t *)*eci, (char const   *)(ecaplay_audio_format));
  }
  }
#line 250
  if ((unsigned long )ecaplay_output == (unsigned long )((void *)0)) {
    {
    {
#line 251
    eci_command_r(*eci, "ao-add-default");
    }
    {
#line 254
    initialize_check_output((eci_handle_t *)*eci);
    }
    }
  } else {
    {
    {
#line 257
    tmp___0 = strlen("ao-add ");
    }
    {
#line 257
    tmp___1 = strlen(ecaplay_output);
    }
#line 257
    len = (int )((tmp___0 + tmp___1) + 1U);
    {
#line 258
    tmp___2 = malloc((size_t )len);
    }
#line 258
    tmpbuf___0 = (char *)tmp___2;
    {
#line 259
    snprintf((char */* __restrict  */)tmpbuf___0, (size_t )len, (char const   */* __restrict  */)"ao-add %s",
             ecaplay_output);
    }
    {
#line 260
    eci_command_r(*eci, (char const   *)tmpbuf___0);
    }
    {
#line 261
    initialize_check_output((eci_handle_t *)*eci);
    }
    {
#line 262
    free((void *)tmpbuf___0);
    }
    }
  }
  {
  {
#line 267
  eci_command_r(*eci, "cs-connect");
  }
  {
#line 268
  tmp___6 = eci_error_r(*eci);
  }
  }
#line 268
  if (tmp___6) {
    {
    {
#line 269
    tmp___3 = eci_last_error_r(*eci);
    }
    {
#line 269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Unable to play file \'%s\':\n%s\n",
            nexttrack, tmp___3);
    }
    }
  } else {
    {
    {
#line 272
    eci_command_r(*eci, "cs-connected");
    }
    {
#line 273
    ret = eci_last_string_r(*eci);
    }
    {
#line 274
    tmp___4 = strlen("ecaplay_chainsetup");
    }
    {
#line 274
    tmp___5 = strncmp(ret, "ecaplay_chainsetup", tmp___4);
    }
    }
#line 274
    if (tmp___5 != 0) {
      {
      {
#line 275
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Error while playing file \'%s\' . Skipping...\n",
              nexttrack);
      }
      }
    } else {
      {
      {
#line 279
      printf((char const   */* __restrict  */)"(ecaplay) Playing %d: \'%s\' (%s).\n",
             tracknum, nexttrack, ecaplay_audio_format);
      }
      {
#line 280
      eci_command_r(*eci, "start");
      }
      }
    }
  }
#line 283
  return;
}
}
#line 285 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *get_next_track(int *tracknum , int argc , char **argv , eci_handle_t *eci ) 
{ 
  char const   *nexttrack ;

  {
#line 287
  nexttrack = (char const   *)((void *)0);
#line 289
  if (ecaplay_mode == 3) {
    {
    {
#line 290
    nexttrack = get_track_playlist(tracknum);
    }
    }
  } else {
    {
    {
#line 292
    nexttrack = get_track_cmdline(*tracknum, argc, argv);
    }
    }
  }
#line 294
  if ((unsigned long )nexttrack != (unsigned long )((void *)0)) {
#line 296
    if (ecaplay_initialized) {
      {
      {
#line 297
      eci_cleanup_r(*eci);
      }
      }
    }
    {
    {
#line 299
    initialize_chainsetup_for_playback(eci, nexttrack, *tracknum);
    }
    }
  } else
#line 303
  if (! (ecaplay_mode != 3)) {
#line 310
    *tracknum = 1;
#line 315
    if (ecaplay_mode == 3) {
      {
      {
#line 316
      nexttrack = get_track_playlist(tracknum);
      }
      }
    } else {
      {
      {
#line 318
      nexttrack = get_track_cmdline(*tracknum, argc, argv);
      }
      }
    }
#line 322
    if ((unsigned long )nexttrack != (unsigned long )((void *)0)) {
#line 324
      if (ecaplay_initialized) {
        {
        {
#line 325
        eci_cleanup_r(*eci);
        }
        }
      }
      {
      {
#line 327
      initialize_chainsetup_for_playback(eci, nexttrack, *tracknum);
      }
      }
    }
  }
#line 336
  return (nexttrack);
}
}
#line 345 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *get_track_cmdline(int n , int argc , char **argv ) 
{ 
  int i ;
  int c ;

  {
#line 347
  c = 0;
#line 351
  i = 1;
  {
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 351
    if (! (i < argc)) {
#line 351
      goto while_break;
    }
#line 353
    if ((int )*(*(argv + i) + 0) != 45) {
#line 354
      c ++;
#line 354
      if (c == n) {
#line 355
        return ((char const   *)*(argv + i));
      }
    }
#line 351
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return ((char const   *)((void *)0));
}
}
#line 370 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char *get_playlist_path(void) 
{ 
  char *path ;
  void *tmp ;
  struct stat statbuf ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 372
  tmp = malloc((size_t )4096);
  }
#line 372
  path = (char *)tmp;
  {
#line 376
  tmp___0 = getenv("HOME");
  }
  {
#line 376
  strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)tmp___0,
          (size_t )4096);
  }
  {
#line 377
  tmp___1 = strlen((char const   *)path);
  }
  {
#line 377
  strncat((char */* __restrict  */)path, (char const   */* __restrict  */)"/.ecasound",
          (4096U - tmp___1) - 1U);
  }
  {
#line 380
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& statbuf));
  }
  }
#line 380
  if (tmp___2 != 0) {
    {
    {
#line 381
    printf((char const   */* __restrict  */)"(ecaplay) Creating directory %s.\n",
           path);
    }
    {
#line 382
    mkdir((char const   *)path, (__mode_t )448);
    }
    }
  } else
#line 385
  if (! ((statbuf.st_mode & 61440U) == 16384U)) {
    {
    {
#line 387
    free((void *)path);
    }
#line 388
    path = (char *)((void *)0);
    }
  }
#line 392
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
    {
#line 394
    tmp___3 = strlen((char const   *)path);
    }
    {
#line 394
    strncat((char */* __restrict  */)path, (char const   */* __restrict  */)"/ecaplay_queue",
            (4096U - tmp___3) - 1U);
    }
    }
  }
#line 397
  return (path);
}
}
#line 411 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *get_track_playlist(int *next_track ) 
{ 
  char const   *res ;
  char *path ;
  FILE *f1 ;
  int next ;
  int c ;
  int w ;
  int cur_item ;
  char *__cil_tmp9 ;

  {
  {
#line 414
  res = (char const   *)((void *)0);
#line 417
  next = *next_track;
  {
#line 421
  path = get_playlist_path();
  }
  }
#line 422
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 423
    return ((char const   *)path);
  }
  {
  {
#line 426
  f1 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
  }
  }
#line 427
  if ((unsigned long )f1 != (unsigned long )((void *)0)) {
#line 428
    cur_item = 1;
#line 431
    w = 0;
    {
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 432
      c = fgetc(f1);
      }
      }
#line 433
      if (c == -1) {
#line 434
        if (next > cur_item) {
          {
#line 436
          next %= cur_item;
#line 437
          *next_track = next;
          {
#line 439
          fseek(f1, 0L, 0);
          }
#line 440
          cur_item = 1;
#line 441
          w = 0;
          }
#line 442
          goto __Cont;
        }
#line 444
        goto while_break;
      }
#line 447
      if (cur_item == next) {
#line 448
        if (c == 10) {
#line 449
          ecaplay_next[w] = (char)0;
#line 450
          res = (char const   *)(ecaplay_next);
#line 451
          goto while_break;
        } else {
#line 454
          ecaplay_next[w] = (char )c;
        }
#line 456
        w ++;
      }
#line 458
      if (c == 10) {
#line 459
        cur_item ++;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 464
    fclose(f1);
    }
    }
  }
  {
  {
#line 467
  free((void *)path);
  }
  }
#line 469
  return (res);
}
}
#line 477 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int list_tracks(void) 
{ 
  FILE *f1 ;
  char *path ;
  char *tmp ;
  int c ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 480
  tmp = get_playlist_path();
  }
#line 480
  path = tmp;
  {
#line 482
  f1 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
  }
  }
#line 483
  if ((unsigned long )f1 != (unsigned long )((void *)0)) {
    {
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 485
      c = fgetc(f1);
      }
      }
#line 485
      if (! (c != -1)) {
#line 485
        goto while_break;
      }
      {
      {
#line 486
      printf((char const   */* __restrict  */)"%c", c);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 488
    fclose(f1);
    }
    }
#line 489
    return (0);
  }
#line 491
  return (-1);
}
}
#line 501 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int play_tracks(int argc , char **argv ) 
{ 
  eci_handle_t eci ;
  int tracknum ;
  int stop ;
  char const   *nexttrack ;
  unsigned int timeleft ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 503
  eci = (void *)0;
#line 504
  tracknum = 1;
#line 504
  stop = 0;
#line 505
  nexttrack = (char const   *)((void *)0);
#line 510
  tracknum += ecaplay_skip;
  {
#line 512
  nexttrack = get_next_track(& tracknum, argc, argv, & eci);
  }
  }
#line 514
  if ((unsigned long )nexttrack != (unsigned long )((void *)0)) {
    {
    {
#line 515
    setup_signal_handling();
    }
    }
    {
    {
#line 517
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 517
      if (! ((unsigned long )nexttrack != (unsigned long )((void *)0))) {
#line 517
        goto while_break;
      }
#line 518
      timeleft = 3U;
      {
      {
#line 520
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 520
        if (! (timeleft > 0U)) {
#line 520
          goto while_break___0;
        }
        {
        {
#line 521
        timeleft = sleep(timeleft);
        }
        }
#line 523
        if (timeleft > 0U) {
#line 523
          if (ecaplay_skip_flag > 1) {
            {
            {
#line 524
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecaplay) Interrupted, exiting...\n");
            }
            {
#line 525
            eci_cleanup_r(eci);
            }
#line 526
            stop = 1;
            }
#line 527
            goto while_break___0;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 532
      if (stop) {
#line 532
        goto while_break;
      }
#line 534
      if (ecaplay_skip_flag == 0) {
        {
        {
#line 535
        eci_command_r(eci, "engine-status");
        }
        }
      } else {
        {
        {
#line 538
        printf((char const   */* __restrict  */)"(ecaplay) Skipping...\n");
        }
        }
      }
#line 541
      if (ecaplay_skip_flag != 0) {
        {
#line 542
        ecaplay_skip_flag = 0;
#line 543
        tracknum ++;
        {
#line 544
        nexttrack = get_next_track(& tracknum, argc, argv, & eci);
        }
        }
      } else {
        {
        {
#line 541
        tmp = eci_last_string_r(eci);
        }
        {
#line 541
        tmp___0 = strcmp(tmp, "running");
        }
        }
#line 541
        if (tmp___0 != 0) {
          {
#line 542
          ecaplay_skip_flag = 0;
#line 543
          tracknum ++;
          {
#line 544
          nexttrack = get_next_track(& tracknum, argc, argv, & eci);
          }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exiting...\n");
    }
    }
#line 552
    if (stop == 0) {
      {
      {
#line 553
      eci_cleanup_r(eci);
      }
      }
    }
  }
#line 557
  return (0);
}
}
#line 560 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void print_usage___0(FILE *stream ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 562
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Ecaplay v%s (%s)\n\n",
          ecaplay_version, "2.7.0");
  }
  {
#line 564
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Copyright (C) 1997-2005 Kai Vehmanen, released under GPL licence \n");
  }
  {
#line 565
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Ecaplay comes with ABSOLUTELY NO WARRANTY.\n");
  }
  {
#line 566
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"You may redistribute copies of ecasound under the terms of the GNU\n");
  }
  {
#line 567
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"General Public License. For more information about these matters, see\n");
  }
  {
#line 568
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"the file named COPYING.\n");
  }
  {
#line 570
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nUSAGE: ecaplay [-dfhklopq] [ file1 file2 ... fileN ]\n\n");
  }
  {
#line 572
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"See ecaplay(1) man page for more details.\n");
  }
  }
#line 573
  return;
}
}
#line 575 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int process_option(char const   *option ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *level ;
  int tmp___1 ;
  char const   *skip ;
  char const   *output ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 577
  if ((int const   )*(option + 0) == 45) {
    {
    {
#line 578
    tmp = strncmp("--help", option, (size_t )sizeof("--help"));
    }
    }
#line 578
    if (tmp == 0) {
      {
      {
#line 580
      print_usage___0(stdout);
      }
      }
#line 581
      return (0);
    } else {
      {
      {
#line 578
      tmp___0 = strncmp("--version", option, (size_t )sizeof("--version"));
      }
      }
#line 578
      if (tmp___0 == 0) {
        {
        {
#line 580
        print_usage___0(stdout);
        }
        }
#line 581
        return (0);
      }
    }
    {
#line 586
    if ((int const   )*(option + 1) == 100) {
#line 586
      goto case_100;
    }
#line 596
    if ((int const   )*(option + 1) == 102) {
#line 596
      goto case_102;
    }
#line 603
    if ((int const   )*(option + 1) == 104) {
#line 603
      goto case_104;
    }
#line 609
    if ((int const   )*(option + 1) == 107) {
#line 609
      goto case_107;
    }
#line 619
    if ((int const   )*(option + 1) == 108) {
#line 619
      goto case_108;
    }
#line 626
    if ((int const   )*(option + 1) == 111) {
#line 626
      goto case_111;
    }
#line 636
    if ((int const   )*(option + 1) == 112) {
#line 636
      goto case_112;
    }
#line 644
    if ((int const   )*(option + 1) == 113) {
#line 644
      goto case_113;
    }
#line 651
    goto switch_default;
    case_100: /* CIL Label */ 
#line 588
    level = option + 3;
#line 589
    if ((int const   )*(option + 2) != 0) {
#line 589
      if ((int const   )*(option + 3) != 0) {
        {
        {
#line 590
        tmp___1 = atoi(level);
        }
#line 590
        ecaplay_debuglevel |= tmp___1;
        {
#line 591
        printf((char const   */* __restrict  */)"(ecaplay) Setting log level to %d.\n",
               ecaplay_debuglevel);
        }
        }
      }
    }
#line 593
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 598
    ecaplay_mode = 1;
    {
#line 599
    printf((char const   */* __restrict  */)"(ecaplay) Flushing playlist.\n");
    }
    }
#line 600
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 605
    print_usage___0(stdout);
    }
    }
#line 606
    return (0);
    case_107: /* CIL Label */ 
#line 611
    skip = option + 3;
#line 612
    if ((int const   )*(option + 2) != 0) {
#line 612
      if ((int const   )*(option + 3) != 0) {
        {
        {
#line 613
        ecaplay_skip = atoi(skip);
        }
        {
#line 614
        printf((char const   */* __restrict  */)"(ecaplay) Skipping the first %d files..\n",
               ecaplay_skip);
        }
        }
      }
    }
#line 616
    goto switch_break;
    case_108: /* CIL Label */ 
#line 621
    ecaplay_mode = 2;
#line 623
    goto switch_break;
    case_111: /* CIL Label */ 
#line 628
    output = option + 3;
#line 629
    if ((int const   )*(option + 2) != 0) {
#line 629
      if ((int const   )*(option + 3) != 0) {
#line 630
        ecaplay_output = output;
      }
    }
#line 633
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 638
    ecaplay_mode = 3;
    {
#line 639
    printf((char const   */* __restrict  */)"(ecaplay) Playlist mode selected (file: %s).\n",
           "~/.ecasound/ecaplay_queue");
    }
    }
#line 641
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 646
    ecaplay_mode = 4;
    {
#line 647
    printf((char const   */* __restrict  */)"(ecaplay) Queuing tracks to playlist.\n");
    }
    }
#line 648
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 653
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Error! Unknown option \'%s\'.\n",
            option);
    }
    {
#line 654
    print_usage___0(stderr);
    }
    }
#line 655
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 660
  return (0);
}
}
#line 663 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int queue_tracks(int argc , char **argv ) 
{ 
  int i ;
  int res ;
  char *path ;
  FILE *f1 ;
  char c ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 665
  res = 0;
  {
#line 669
  path = get_playlist_path();
  }
  {
#line 672
  f1 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"a+b");
  }
  }
#line 673
  if ((unsigned long )f1 != (unsigned long )((void *)0)) {
#line 674
    i = 1;
    {
    {
#line 674
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 674
      if (! (i < argc)) {
#line 674
        goto while_break;
      }
#line 675
      c = *(*(argv + i) + 0);
#line 678
      if ((int )c != 45) {
#line 680
        if ((int )c != 47) {
          {
          {
#line 682
          tmp___0 = strlen((char const   *)*(argv + i));
          }
          {
#line 682
          tmp___1 = malloc((4096U + tmp___0) + 1U);
          }
#line 682
          tmp = (char *)tmp___1;
          {
#line 683
          tmp___3 = getcwd(tmp, (size_t )4096);
          }
          }
#line 683
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            {
            {
#line 684
            strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)"/");
            }
            {
#line 685
            strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)*(argv + i));
            }
            {
#line 686
            printf((char const   */* __restrict  */)"(ecaplay) Track \'%s\' added to playlist.\n",
                   *(argv + i));
            }
            {
#line 687
            tmp___2 = strlen((char const   *)tmp);
            }
            {
#line 687
            fwrite((void const   */* __restrict  */)tmp, (size_t )1, tmp___2, (FILE */* __restrict  */)f1);
            }
            }
          }
          {
          {
#line 689
          free((void *)tmp);
          }
          }
        } else {
          {
          {
#line 692
          printf((char const   */* __restrict  */)"(ecaplay) Track \'%s\' added to playlist.\n",
                 *(argv + i));
          }
          {
#line 693
          tmp___4 = strlen((char const   *)*(argv + i));
          }
          {
#line 693
          fwrite((void const   */* __restrict  */)*(argv + i), (size_t )1, tmp___4,
                 (FILE */* __restrict  */)f1);
          }
          }
        }
        {
        {
#line 695
        fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)f1);
        }
        }
      }
#line 674
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 698
    fclose(f1);
    }
    }
  } else {
#line 701
    res = -1;
  }
  {
  {
#line 704
  free((void *)path);
  }
  }
#line 706
  return (res);
}
}
#line 714 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int set_audio_format(eci_handle_t *eci , char const   *fmt ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmpbuf ;
  void *tmp___1 ;
  int res ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 716
  tmp = strlen("cs-set-audio-format -f:");
  }
  {
#line 716
  tmp___0 = strlen(fmt);
  }
#line 716
  len = (tmp + tmp___0) + 1U;
  {
#line 717
  tmp___1 = malloc(len);
  }
#line 717
  tmpbuf = (char *)tmp___1;
#line 718
  res = 0;
  {
#line 720
  strcpy((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"cs-set-audio-format ");
  }
  {
#line 721
  strcat((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)fmt);
  }
#line 722
  *(tmpbuf + (len - 1U)) = (char)0;
  {
#line 723
  eci_command_r((eci_handle_t )eci, (char const   *)tmpbuf);
  }
  {
#line 724
  tmp___2 = eci_error_r((eci_handle_t )eci);
  }
  }
#line 724
  if (tmp___2) {
    {
    {
#line 725
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Unknown audio format encountered.\n");
    }
#line 726
    res = -1;
    }
  }
  {
  {
#line 728
  free((void *)tmpbuf);
  }
  }
#line 730
  return (res);
}
}
#line 733 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void setup_signal_handling(void) 
{ 
  struct sigaction es_handler_int ;
  struct sigaction ign_handler ;

  {
  {
#line 738
  es_handler_int.__sigaction_handler.sa_handler = & signal_handler;
  {
#line 739
  sigemptyset(& es_handler_int.sa_mask);
  }
#line 740
  es_handler_int.sa_flags = 0;
#line 742
  ign_handler.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  {
#line 743
  sigemptyset(& ign_handler.sa_mask);
  }
#line 744
  ign_handler.sa_flags = 0;
  {
#line 747
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& es_handler_int), (struct sigaction */* __restrict  */)0);
  }
  {
#line 750
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& ign_handler), (struct sigaction */* __restrict  */)0);
  }
  {
#line 751
  sigaction(8, (struct sigaction  const  */* __restrict  */)(& ign_handler), (struct sigaction */* __restrict  */)0);
  }
  }
#line 752
  return;
}
}
#line 754 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void signal_handler(int signum ) 
{ 


  {
#line 756
  ecaplay_skip_flag ++;
#line 757
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___1  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___1(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___1(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___1(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___1(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___1(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___1(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___1(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___1(void) ;
#line 247
static void eci_impl_los_list_clear___1(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___1(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___1(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___1(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___1(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___1(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___1(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___1(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___1(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___1(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___1(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___1(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___1(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___1(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___1(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___1(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___1(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___1(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___1(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___1(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___1(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___1(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___1(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___1(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___1();
  }
  {
#line 972
  eci_string_add___1(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___1(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___1(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___1(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___1(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___1(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___1(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___1(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___1((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___1(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___1(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___1(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___1(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___1(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___1(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___1(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___1(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___1(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___1(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___1(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___1(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___1(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___1(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___1(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___1(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___1(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___1(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___1(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___1(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___1(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 63 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecalength.c"
void make_human(int length , unsigned int *min , unsigned char *sec ) ;
#line 64
void print_help(char *name ) ;
#line 65
void print_usage(char *name ) ;
#line 306 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecalength.c"
void make_human(int length , unsigned int *min , unsigned char *sec ) 
{ 


  {
#line 307
  *min = (unsigned int )(length / 60);
#line 308
  *sec = (unsigned char )(length % 60);
#line 309
  return;
}
}
#line 311 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecalength.c"
void print_help(char *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 312
  printf((char const   */* __restrict  */)"Usage: %s [-ahtsfmbcru] FILE1 [FILE2] [FILEn]\n \t-h      Prints this usage message.  (help)\n\t-a[:]bits,channels,rate     Changes the format assumed by default \n\t                            for headerless data.  (adjust)\n\t-t      Prints the summed length of all the files processed.  (total)\n\t        (Ignored if with -s) \n\t-s      Enables script mode: One info type per file per line.   (script)\n\t        (Defaults to length in secs.) \n\t-f      With -s will return the format string as info, alone it will \n\t        add it to the main display.  (format)\n\t    -b  If -s and -f are enabled with this the info printed will be \n\t        the sample\'s bitwidth.  (bits)\n\t    -c  If -s and -f are enabled with this the info printed will be \n\t        the channel count.  (channel count)\n\t    -r  If -s and -f are enabled with this the info printed will be \n\t        the sampling rate.  (rate)\n\t-m      Will print human computable time as in main display but in \n\t        batch fashion.  (minutes)\n\t        (Only with -s)\n\t-u      This batchmode option returns the length of specified files \n\t        in samples. (Smallest Unit)\n\t        (This information is worthless if you don\'t know the sampling \n\t        rate of the file.) (Only with -s)\n(Note that out of context options will be ignored.)\n\n",
         name);
  }
  }
#line 336
  return;
}
}
#line 338 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecalength.c"
void print_usage(char *name ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 339
  printf((char const   */* __restrict  */)"Usage: %s [-ahtsfmbcru] FILE1 [FILE2] [FILEn]\n\n\t Use the -h switch for help or see the man page.\n\n",
         name);
  }
  }
#line 340
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___2  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___2(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___2(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___2(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___2(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___2(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___2(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___2(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___2(void) ;
#line 247
static void eci_impl_los_list_clear___2(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___2(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___2(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___2(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___2(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___2(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___2(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___2(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___2(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___2(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___2(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___2(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___2(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___2(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___2(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___2(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___2(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___2(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___2(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___2(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___2(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___2(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___2(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___2(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___2();
  }
  {
#line 972
  eci_string_add___2(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___2(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___2(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___2(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___2(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___2(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___2(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___2(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___2((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___2(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___2(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___2(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___2(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___2(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___2(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___2(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___2(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___2(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___2(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___2(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___2(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___2(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___2(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___2(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___2(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___2(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___2(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___2(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___2(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___2(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___3  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___3(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___3(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___3(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___3(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___3(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___3(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___3(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___3(void) ;
#line 247
static void eci_impl_los_list_clear___3(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___3(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___3(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___3(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___3(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___3(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___3(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___3(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___3(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___3(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___3(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___3(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___3(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___3(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___3(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___3(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___3(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___3(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___3(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___3(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___3(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___3(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___3(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___3(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___3();
  }
  {
#line 972
  eci_string_add___3(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___3(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___3(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___3(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___3(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___3(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___3(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___3(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___3((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___3(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___3(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___3(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___3(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___3(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___3(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___3(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___3(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___3(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___3(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___3(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___3(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___3(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___3(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___3(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___3(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___3(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___3(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___3(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___3(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___3(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___4  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___4(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___4(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___4(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___4(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___4(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___4(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___4(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___4(void) ;
#line 247
static void eci_impl_los_list_clear___4(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___4(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___4(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___4(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___4(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___4(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___4(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___4(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___4(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___4(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___4(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___4(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___4(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___4(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___4(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___4(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___4(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___4(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___4(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___4(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___4(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___4(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___4(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___4(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___4();
  }
  {
#line 972
  eci_string_add___4(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___4(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___4(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___4(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___4(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___4(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___4(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___4(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___4((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___4(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___4(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___4(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___4(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___4(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___4(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___4(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___4(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___4(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___4(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___4(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___4(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___4(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___4(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___4(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___4(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___4(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___4(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___4(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___4(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___4(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 51 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void add_input_to_chainsetup___0(eci_handle_t eci , char const   *nexttrack ) ;
#line 52
static int flush_tracks___0(void) ;
#line 53
static char const   *get_next_track___0(int *tracknum , int argc , char **argv , eci_handle_t *eci ) ;
#line 54
static char *get_playlist_path___0(void) ;
#line 55
static char const   *get_track_cmdline___0(int n , int argc , char **argv ) ;
#line 56
static char const   *get_track_playlist___0(int *next_track ) ;
#line 57
static void initialize_chainsetup_for_playback___0(eci_handle_t *eci , char const   *nexttrack ,
                                                   int tracknum ) ;
#line 58
static void initialize_check_output___0(eci_handle_t *eci ) ;
#line 59
static int list_tracks___0(void) ;
#line 60
static int play_tracks___0(int argc , char **argv ) ;
#line 61
static void print_usage___1(FILE *stream ) ;
#line 62
static int process_option___0(char const   *option ) ;
#line 63
static int queue_tracks___0(int argc , char **argv ) ;
#line 64
static int set_audio_format___0(eci_handle_t *eci , char const   *fmt ) ;
#line 65
static void setup_signal_handling___0(void) ;
#line 66
static void signal_handler___0(int signum ) ;
#line 89 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *ecaplay_version___0  =    "20061206-45";
#line 90 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char ecaplay_next___0[4096]  ;
#line 91 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char ecaplay_audio_format___0[64]  ;
#line 92 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *ecaplay_output___0  =    (char const   *)((void *)0);
#line 93 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_debuglevel___0  =    256;
#line 94 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_skip___0  =    0;
#line 95 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_mode___0  =    0;
#line 97 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int ecaplay_initialized___0  =    0;
#line 98 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static sig_atomic_t ecaplay_skip_flag___0  =    0;
#line 149 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void add_input_to_chainsetup___0(eci_handle_t eci , char const   *nexttrack ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmpbuf ;
  void *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 151
  tmp = strlen("ai-add \'");
  }
  {
#line 151
  tmp___0 = strlen(nexttrack);
  }
  {
#line 151
  tmp___1 = strlen("\'");
  }
#line 151
  len = ((tmp + tmp___0) + tmp___1) + 1U;
  {
#line 152
  tmp___2 = malloc(len);
  }
#line 152
  tmpbuf = (char *)tmp___2;
  {
#line 155
  snprintf((char */* __restrict  */)tmpbuf, len, (char const   */* __restrict  */)"ai-add \"%s\"",
           nexttrack);
  }
  {
#line 156
  eci_command_r(eci, (char const   *)tmpbuf);
  }
  {
#line 159
  eci_command_r(eci, "ai-list");
  }
  {
#line 160
  tmp___3 = eci_last_string_list_count_r(eci);
  }
  }
#line 160
  if (tmp___3 != 1) {
    {
    {
#line 161
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Warning! Failed to add input \'%s\'.\n",
            nexttrack);
    }
    }
  }
  {
  {
#line 165
  eci_command_r(eci, "ao-add null");
  }
  {
#line 166
  eci_command_r(eci, "cs-connect");
  }
  {
#line 167
  eci_command_r(eci, "ai-iselect 1");
  }
  {
#line 168
  eci_command_r(eci, "ai-get-format");
  }
  {
#line 170
  tmp___4 = eci_last_string_r(eci);
  }
  {
#line 170
  strncpy((char */* __restrict  */)(ecaplay_audio_format___0), (char const   */* __restrict  */)tmp___4,
          (size_t )64);
  }
#line 173
  ecaplay_audio_format___0[63] = (char)0;
  {
#line 176
  eci_command_r(eci, "cs-disconnect");
  }
  {
#line 177
  eci_command_r(eci, "ao-iselect 1");
  }
  {
#line 178
  eci_command_r(eci, "ao-remove");
  }
  {
#line 180
  free((void *)tmpbuf);
  }
  }
#line 181
  return;
}
}
#line 188 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int flush_tracks___0(void) 
{ 
  char *path ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 190
  tmp = get_playlist_path___0();
  }
#line 190
  path = tmp;
  {
#line 191
  tmp___0 = truncate((char const   *)path, (__off64_t )0);
  }
  }
#line 191
  if (tmp___0 != 0) {
    {
    {
#line 192
    printf((char const   */* __restrict  */)"(ecaplay) Unable to flush playlist \'%s\'.\n",
           path);
    }
    }
#line 193
    return (-1);
  }
#line 195
  return (0);
}
}
#line 209 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int once___0  =    1;
#line 202 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void initialize_check_output___0(eci_handle_t *eci ) 
{ 
  char *tmpstr ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 204
  eci_command_r((eci_handle_t )eci, "ao-list");
  }
  {
#line 205
  tmp___1 = eci_last_string_list_count_r((eci_handle_t )eci);
  }
  }
#line 205
  if (tmp___1 != 1) {
    {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Warning! Failed to add output device.\n");
    }
    }
  } else
#line 210
  if (once___0) {
    {
    {
#line 211
    eci_command_r((eci_handle_t )eci, "ao-iselect 1");
    }
    {
#line 212
    eci_command_r((eci_handle_t )eci, "ao-describe");
    }
    {
#line 213
    tmp = eci_last_string_r((eci_handle_t )eci);
    }
#line 213
    tmpstr = (char *)tmp;
    }
    {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 215
      if (*tmpstr) {
#line 215
        tmp___0 = tmpstr;
#line 215
        tmpstr ++;
#line 215
        if (! ((int )*tmp___0 != 58)) {
#line 215
          goto while_break;
        }
      } else {
#line 215
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 217
    printf((char const   */* __restrict  */)"(ecaplay) Output device: \'%s\'\n", tmpstr);
    }
#line 218
    once___0 = 0;
    }
  }
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void initialize_chainsetup_for_playback___0(eci_handle_t *eci , char const   *nexttrack ,
                                                   int tracknum ) 
{ 
  char const   *ret ;
  char tmpbuf[32] ;
  int tmp ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmpbuf___0 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 225
  ret = (char const   *)((void *)0);
  {
#line 227
  *eci = eci_init_r();
  }
#line 228
  ecaplay_initialized___0 = 1;
  }
#line 230
  if (ecaplay_debuglevel___0 != -1) {
    {
    {
#line 232
    snprintf((char */* __restrict  */)(tmpbuf), (size_t )32, (char const   */* __restrict  */)"debug %d",
             ecaplay_debuglevel___0);
    }
    {
#line 233
    eci_command_r(*eci, (char const   *)(tmpbuf));
    }
    }
  }
  {
  {
#line 236
  eci_command_r(*eci, "cs-add ecaplay_chainsetup");
  }
  {
#line 238
  eci_command_r(*eci, "cs-list");
  }
  {
#line 239
  tmp = eci_last_string_list_count_r(*eci);
  }
  }
#line 239
  if (tmp != 2) {
    {
    {
#line 240
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Warning! Failed to add a new chainsetup.\n");
    }
    }
  }
  {
  {
#line 245
  eci_command_r(*eci, "c-add ecaplay_chain");
  }
  {
#line 247
  add_input_to_chainsetup___0(*eci, nexttrack);
  }
  {
#line 248
  set_audio_format___0((eci_handle_t *)*eci, (char const   *)(ecaplay_audio_format___0));
  }
  }
#line 250
  if ((unsigned long )ecaplay_output___0 == (unsigned long )((void *)0)) {
    {
    {
#line 251
    eci_command_r(*eci, "ao-add-default");
    }
    {
#line 254
    initialize_check_output___0((eci_handle_t *)*eci);
    }
    }
  } else {
    {
    {
#line 257
    tmp___0 = strlen("ao-add ");
    }
    {
#line 257
    tmp___1 = strlen(ecaplay_output___0);
    }
#line 257
    len = (int )((tmp___0 + tmp___1) + 1U);
    {
#line 258
    tmp___2 = malloc((size_t )len);
    }
#line 258
    tmpbuf___0 = (char *)tmp___2;
    {
#line 259
    snprintf((char */* __restrict  */)tmpbuf___0, (size_t )len, (char const   */* __restrict  */)"ao-add %s",
             ecaplay_output___0);
    }
    {
#line 260
    eci_command_r(*eci, (char const   *)tmpbuf___0);
    }
    {
#line 261
    initialize_check_output___0((eci_handle_t *)*eci);
    }
    {
#line 262
    free((void *)tmpbuf___0);
    }
    }
  }
  {
  {
#line 267
  eci_command_r(*eci, "cs-connect");
  }
  {
#line 268
  tmp___6 = eci_error_r(*eci);
  }
  }
#line 268
  if (tmp___6) {
    {
    {
#line 269
    tmp___3 = eci_last_error_r(*eci);
    }
    {
#line 269
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Unable to play file \'%s\':\n%s\n",
            nexttrack, tmp___3);
    }
    }
  } else {
    {
    {
#line 272
    eci_command_r(*eci, "cs-connected");
    }
    {
#line 273
    ret = eci_last_string_r(*eci);
    }
    {
#line 274
    tmp___4 = strlen("ecaplay_chainsetup");
    }
    {
#line 274
    tmp___5 = strncmp(ret, "ecaplay_chainsetup", tmp___4);
    }
    }
#line 274
    if (tmp___5 != 0) {
      {
      {
#line 275
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Error while playing file \'%s\' . Skipping...\n",
              nexttrack);
      }
      }
    } else {
      {
      {
#line 279
      printf((char const   */* __restrict  */)"(ecaplay) Playing %d: \'%s\' (%s).\n",
             tracknum, nexttrack, ecaplay_audio_format___0);
      }
      {
#line 280
      eci_command_r(*eci, "start");
      }
      }
    }
  }
#line 283
  return;
}
}
#line 285 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *get_next_track___0(int *tracknum , int argc , char **argv , eci_handle_t *eci ) 
{ 
  char const   *nexttrack ;

  {
#line 287
  nexttrack = (char const   *)((void *)0);
#line 289
  if (ecaplay_mode___0 == 3) {
    {
    {
#line 290
    nexttrack = get_track_playlist___0(tracknum);
    }
    }
  } else {
    {
    {
#line 292
    nexttrack = get_track_cmdline___0(*tracknum, argc, argv);
    }
    }
  }
#line 294
  if ((unsigned long )nexttrack != (unsigned long )((void *)0)) {
#line 296
    if (ecaplay_initialized___0) {
      {
      {
#line 297
      eci_cleanup_r(*eci);
      }
      }
    }
    {
    {
#line 299
    initialize_chainsetup_for_playback___0(eci, nexttrack, *tracknum);
    }
    }
  } else
#line 303
  if (! (ecaplay_mode___0 != 3)) {
#line 310
    *tracknum = 1;
#line 315
    if (ecaplay_mode___0 == 3) {
      {
      {
#line 316
      nexttrack = get_track_playlist___0(tracknum);
      }
      }
    } else {
      {
      {
#line 318
      nexttrack = get_track_cmdline___0(*tracknum, argc, argv);
      }
      }
    }
#line 322
    if ((unsigned long )nexttrack != (unsigned long )((void *)0)) {
#line 324
      if (ecaplay_initialized___0) {
        {
        {
#line 325
        eci_cleanup_r(*eci);
        }
        }
      }
      {
      {
#line 327
      initialize_chainsetup_for_playback___0(eci, nexttrack, *tracknum);
      }
      }
    }
  }
#line 336
  return (nexttrack);
}
}
#line 345 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *get_track_cmdline___0(int n , int argc , char **argv ) 
{ 
  int i ;
  int c ;

  {
#line 347
  c = 0;
#line 351
  i = 1;
  {
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 351
    if (! (i < argc)) {
#line 351
      goto while_break;
    }
#line 353
    if ((int )*(*(argv + i) + 0) != 45) {
#line 354
      c ++;
#line 354
      if (c == n) {
#line 355
        return ((char const   *)*(argv + i));
      }
    }
#line 351
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return ((char const   *)((void *)0));
}
}
#line 370 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char *get_playlist_path___0(void) 
{ 
  char *path ;
  void *tmp ;
  struct stat statbuf ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 372
  tmp = malloc((size_t )4096);
  }
#line 372
  path = (char *)tmp;
  {
#line 376
  tmp___0 = getenv("HOME");
  }
  {
#line 376
  strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)tmp___0,
          (size_t )4096);
  }
  {
#line 377
  tmp___1 = strlen((char const   *)path);
  }
  {
#line 377
  strncat((char */* __restrict  */)path, (char const   */* __restrict  */)"/.ecasound",
          (4096U - tmp___1) - 1U);
  }
  {
#line 380
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& statbuf));
  }
  }
#line 380
  if (tmp___2 != 0) {
    {
    {
#line 381
    printf((char const   */* __restrict  */)"(ecaplay) Creating directory %s.\n",
           path);
    }
    {
#line 382
    mkdir((char const   *)path, (__mode_t )448);
    }
    }
  } else
#line 385
  if (! ((statbuf.st_mode & 61440U) == 16384U)) {
    {
    {
#line 387
    free((void *)path);
    }
#line 388
    path = (char *)((void *)0);
    }
  }
#line 392
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    {
    {
#line 394
    tmp___3 = strlen((char const   *)path);
    }
    {
#line 394
    strncat((char */* __restrict  */)path, (char const   */* __restrict  */)"/ecaplay_queue",
            (4096U - tmp___3) - 1U);
    }
    }
  }
#line 397
  return (path);
}
}
#line 411 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static char const   *get_track_playlist___0(int *next_track ) 
{ 
  char const   *res ;
  char *path ;
  FILE *f1 ;
  int next ;
  int c ;
  int w ;
  int cur_item ;
  char *__cil_tmp9 ;

  {
  {
#line 414
  res = (char const   *)((void *)0);
#line 417
  next = *next_track;
  {
#line 421
  path = get_playlist_path___0();
  }
  }
#line 422
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 423
    return ((char const   *)path);
  }
  {
  {
#line 426
  f1 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
  }
  }
#line 427
  if ((unsigned long )f1 != (unsigned long )((void *)0)) {
#line 428
    cur_item = 1;
#line 431
    w = 0;
    {
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 432
      c = fgetc(f1);
      }
      }
#line 433
      if (c == -1) {
#line 434
        if (next > cur_item) {
          {
#line 436
          next %= cur_item;
#line 437
          *next_track = next;
          {
#line 439
          fseek(f1, 0L, 0);
          }
#line 440
          cur_item = 1;
#line 441
          w = 0;
          }
#line 442
          goto __Cont;
        }
#line 444
        goto while_break;
      }
#line 447
      if (cur_item == next) {
#line 448
        if (c == 10) {
#line 449
          ecaplay_next___0[w] = (char)0;
#line 450
          res = (char const   *)(ecaplay_next___0);
#line 451
          goto while_break;
        } else {
#line 454
          ecaplay_next___0[w] = (char )c;
        }
#line 456
        w ++;
      }
#line 458
      if (c == 10) {
#line 459
        cur_item ++;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 464
    fclose(f1);
    }
    }
  }
  {
  {
#line 467
  free((void *)path);
  }
  }
#line 469
  return (res);
}
}
#line 477 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int list_tracks___0(void) 
{ 
  FILE *f1 ;
  char *path ;
  char *tmp ;
  int c ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 480
  tmp = get_playlist_path___0();
  }
#line 480
  path = tmp;
  {
#line 482
  f1 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
  }
  }
#line 483
  if ((unsigned long )f1 != (unsigned long )((void *)0)) {
    {
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 485
      c = fgetc(f1);
      }
      }
#line 485
      if (! (c != -1)) {
#line 485
        goto while_break;
      }
      {
      {
#line 486
      printf((char const   */* __restrict  */)"%c", c);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 488
    fclose(f1);
    }
    }
#line 489
    return (0);
  }
#line 491
  return (-1);
}
}
#line 501 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int play_tracks___0(int argc , char **argv ) 
{ 
  eci_handle_t eci ;
  int tracknum ;
  int stop ;
  char const   *nexttrack ;
  unsigned int timeleft ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 503
  eci = (void *)0;
#line 504
  tracknum = 1;
#line 504
  stop = 0;
#line 505
  nexttrack = (char const   *)((void *)0);
#line 510
  tracknum += ecaplay_skip___0;
  {
#line 512
  nexttrack = get_next_track___0(& tracknum, argc, argv, & eci);
  }
  }
#line 514
  if ((unsigned long )nexttrack != (unsigned long )((void *)0)) {
    {
    {
#line 515
    setup_signal_handling___0();
    }
    }
    {
    {
#line 517
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 517
      if (! ((unsigned long )nexttrack != (unsigned long )((void *)0))) {
#line 517
        goto while_break;
      }
#line 518
      timeleft = 3U;
      {
      {
#line 520
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 520
        if (! (timeleft > 0U)) {
#line 520
          goto while_break___0;
        }
        {
        {
#line 521
        timeleft = sleep(timeleft);
        }
        }
#line 523
        if (timeleft > 0U) {
#line 523
          if (ecaplay_skip_flag___0 > 1) {
            {
            {
#line 524
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecaplay) Interrupted, exiting...\n");
            }
            {
#line 525
            eci_cleanup_r(eci);
            }
#line 526
            stop = 1;
            }
#line 527
            goto while_break___0;
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 532
      if (stop) {
#line 532
        goto while_break;
      }
#line 534
      if (ecaplay_skip_flag___0 == 0) {
        {
        {
#line 535
        eci_command_r(eci, "engine-status");
        }
        }
      } else {
        {
        {
#line 538
        printf((char const   */* __restrict  */)"(ecaplay) Skipping...\n");
        }
        }
      }
#line 541
      if (ecaplay_skip_flag___0 != 0) {
        {
#line 542
        ecaplay_skip_flag___0 = 0;
#line 543
        tracknum ++;
        {
#line 544
        nexttrack = get_next_track___0(& tracknum, argc, argv, & eci);
        }
        }
      } else {
        {
        {
#line 541
        tmp = eci_last_string_r(eci);
        }
        {
#line 541
        tmp___0 = strcmp(tmp, "running");
        }
        }
#line 541
        if (tmp___0 != 0) {
          {
#line 542
          ecaplay_skip_flag___0 = 0;
#line 543
          tracknum ++;
          {
#line 544
          nexttrack = get_next_track___0(& tracknum, argc, argv, & eci);
          }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 549
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"exiting...\n");
    }
    }
#line 552
    if (stop == 0) {
      {
      {
#line 553
      eci_cleanup_r(eci);
      }
      }
    }
  }
#line 557
  return (0);
}
}
#line 560 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void print_usage___1(FILE *stream ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 562
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Ecaplay v%s (%s)\n\n",
          ecaplay_version___0, "2.7.0");
  }
  {
#line 564
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Copyright (C) 1997-2005 Kai Vehmanen, released under GPL licence \n");
  }
  {
#line 565
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Ecaplay comes with ABSOLUTELY NO WARRANTY.\n");
  }
  {
#line 566
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"You may redistribute copies of ecasound under the terms of the GNU\n");
  }
  {
#line 567
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"General Public License. For more information about these matters, see\n");
  }
  {
#line 568
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"the file named COPYING.\n");
  }
  {
#line 570
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nUSAGE: ecaplay [-dfhklopq] [ file1 file2 ... fileN ]\n\n");
  }
  {
#line 572
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"See ecaplay(1) man page for more details.\n");
  }
  }
#line 573
  return;
}
}
#line 575 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int process_option___0(char const   *option ) 
{ 
  int tmp ;
  int tmp___0 ;
  char const   *level ;
  int tmp___1 ;
  char const   *skip ;
  char const   *output ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 577
  if ((int const   )*(option + 0) == 45) {
    {
    {
#line 578
    tmp = strncmp("--help", option, (size_t )sizeof("--help"));
    }
    }
#line 578
    if (tmp == 0) {
      {
      {
#line 580
      print_usage___1(stdout);
      }
      }
#line 581
      return (0);
    } else {
      {
      {
#line 578
      tmp___0 = strncmp("--version", option, (size_t )sizeof("--version"));
      }
      }
#line 578
      if (tmp___0 == 0) {
        {
        {
#line 580
        print_usage___1(stdout);
        }
        }
#line 581
        return (0);
      }
    }
    {
#line 586
    if ((int const   )*(option + 1) == 100) {
#line 586
      goto case_100;
    }
#line 596
    if ((int const   )*(option + 1) == 102) {
#line 596
      goto case_102;
    }
#line 603
    if ((int const   )*(option + 1) == 104) {
#line 603
      goto case_104;
    }
#line 609
    if ((int const   )*(option + 1) == 107) {
#line 609
      goto case_107;
    }
#line 619
    if ((int const   )*(option + 1) == 108) {
#line 619
      goto case_108;
    }
#line 626
    if ((int const   )*(option + 1) == 111) {
#line 626
      goto case_111;
    }
#line 636
    if ((int const   )*(option + 1) == 112) {
#line 636
      goto case_112;
    }
#line 644
    if ((int const   )*(option + 1) == 113) {
#line 644
      goto case_113;
    }
#line 651
    goto switch_default;
    case_100: /* CIL Label */ 
#line 588
    level = option + 3;
#line 589
    if ((int const   )*(option + 2) != 0) {
#line 589
      if ((int const   )*(option + 3) != 0) {
        {
        {
#line 590
        tmp___1 = atoi(level);
        }
#line 590
        ecaplay_debuglevel___0 |= tmp___1;
        {
#line 591
        printf((char const   */* __restrict  */)"(ecaplay) Setting log level to %d.\n",
               ecaplay_debuglevel___0);
        }
        }
      }
    }
#line 593
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 598
    ecaplay_mode___0 = 1;
    {
#line 599
    printf((char const   */* __restrict  */)"(ecaplay) Flushing playlist.\n");
    }
    }
#line 600
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 605
    print_usage___1(stdout);
    }
    }
#line 606
    return (0);
    case_107: /* CIL Label */ 
#line 611
    skip = option + 3;
#line 612
    if ((int const   )*(option + 2) != 0) {
#line 612
      if ((int const   )*(option + 3) != 0) {
        {
        {
#line 613
        ecaplay_skip___0 = atoi(skip);
        }
        {
#line 614
        printf((char const   */* __restrict  */)"(ecaplay) Skipping the first %d files..\n",
               ecaplay_skip___0);
        }
        }
      }
    }
#line 616
    goto switch_break;
    case_108: /* CIL Label */ 
#line 621
    ecaplay_mode___0 = 2;
#line 623
    goto switch_break;
    case_111: /* CIL Label */ 
#line 628
    output = option + 3;
#line 629
    if ((int const   )*(option + 2) != 0) {
#line 629
      if ((int const   )*(option + 3) != 0) {
#line 630
        ecaplay_output___0 = output;
      }
    }
#line 633
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 638
    ecaplay_mode___0 = 3;
    {
#line 639
    printf((char const   */* __restrict  */)"(ecaplay) Playlist mode selected (file: %s).\n",
           "~/.ecasound/ecaplay_queue");
    }
    }
#line 641
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 646
    ecaplay_mode___0 = 4;
    {
#line 647
    printf((char const   */* __restrict  */)"(ecaplay) Queuing tracks to playlist.\n");
    }
    }
#line 648
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 653
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Error! Unknown option \'%s\'.\n",
            option);
    }
    {
#line 654
    print_usage___1(stderr);
    }
    }
#line 655
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 660
  return (0);
}
}
#line 663 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int queue_tracks___0(int argc , char **argv ) 
{ 
  int i ;
  int res ;
  char *path ;
  FILE *f1 ;
  char c ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 665
  res = 0;
  {
#line 669
  path = get_playlist_path___0();
  }
  {
#line 672
  f1 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"a+b");
  }
  }
#line 673
  if ((unsigned long )f1 != (unsigned long )((void *)0)) {
#line 674
    i = 1;
    {
    {
#line 674
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 674
      if (! (i < argc)) {
#line 674
        goto while_break;
      }
#line 675
      c = *(*(argv + i) + 0);
#line 678
      if ((int )c != 45) {
#line 680
        if ((int )c != 47) {
          {
          {
#line 682
          tmp___0 = strlen((char const   *)*(argv + i));
          }
          {
#line 682
          tmp___1 = malloc((4096U + tmp___0) + 1U);
          }
#line 682
          tmp = (char *)tmp___1;
          {
#line 683
          tmp___3 = getcwd(tmp, (size_t )4096);
          }
          }
#line 683
          if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
            {
            {
#line 684
            strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)"/");
            }
            {
#line 685
            strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)*(argv + i));
            }
            {
#line 686
            printf((char const   */* __restrict  */)"(ecaplay) Track \'%s\' added to playlist.\n",
                   *(argv + i));
            }
            {
#line 687
            tmp___2 = strlen((char const   *)tmp);
            }
            {
#line 687
            fwrite((void const   */* __restrict  */)tmp, (size_t )1, tmp___2, (FILE */* __restrict  */)f1);
            }
            }
          }
          {
          {
#line 689
          free((void *)tmp);
          }
          }
        } else {
          {
          {
#line 692
          printf((char const   */* __restrict  */)"(ecaplay) Track \'%s\' added to playlist.\n",
                 *(argv + i));
          }
          {
#line 693
          tmp___4 = strlen((char const   *)*(argv + i));
          }
          {
#line 693
          fwrite((void const   */* __restrict  */)*(argv + i), (size_t )1, tmp___4,
                 (FILE */* __restrict  */)f1);
          }
          }
        }
        {
        {
#line 695
        fwrite((void const   */* __restrict  */)"\n", (size_t )1, (size_t )1, (FILE */* __restrict  */)f1);
        }
        }
      }
#line 674
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 698
    fclose(f1);
    }
    }
  } else {
#line 701
    res = -1;
  }
  {
  {
#line 704
  free((void *)path);
  }
  }
#line 706
  return (res);
}
}
#line 714 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static int set_audio_format___0(eci_handle_t *eci , char const   *fmt ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmpbuf ;
  void *tmp___1 ;
  int res ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 716
  tmp = strlen("cs-set-audio-format -f:");
  }
  {
#line 716
  tmp___0 = strlen(fmt);
  }
#line 716
  len = (tmp + tmp___0) + 1U;
  {
#line 717
  tmp___1 = malloc(len);
  }
#line 717
  tmpbuf = (char *)tmp___1;
#line 718
  res = 0;
  {
#line 720
  strcpy((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)"cs-set-audio-format ");
  }
  {
#line 721
  strcat((char */* __restrict  */)tmpbuf, (char const   */* __restrict  */)fmt);
  }
#line 722
  *(tmpbuf + (len - 1U)) = (char)0;
  {
#line 723
  eci_command_r((eci_handle_t )eci, (char const   *)tmpbuf);
  }
  {
#line 724
  tmp___2 = eci_error_r((eci_handle_t )eci);
  }
  }
#line 724
  if (tmp___2) {
    {
    {
#line 725
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(ecaplay) Unknown audio format encountered.\n");
    }
#line 726
    res = -1;
    }
  }
  {
  {
#line 728
  free((void *)tmpbuf);
  }
  }
#line 730
  return (res);
}
}
#line 733 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void setup_signal_handling___0(void) 
{ 
  struct sigaction es_handler_int ;
  struct sigaction ign_handler ;

  {
  {
#line 738
  es_handler_int.__sigaction_handler.sa_handler = & signal_handler___0;
  {
#line 739
  sigemptyset(& es_handler_int.sa_mask);
  }
#line 740
  es_handler_int.sa_flags = 0;
#line 742
  ign_handler.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  {
#line 743
  sigemptyset(& ign_handler.sa_mask);
  }
#line 744
  ign_handler.sa_flags = 0;
  {
#line 747
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& es_handler_int), (struct sigaction */* __restrict  */)0);
  }
  {
#line 750
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& ign_handler), (struct sigaction */* __restrict  */)0);
  }
  {
#line 751
  sigaction(8, (struct sigaction  const  */* __restrict  */)(& ign_handler), (struct sigaction */* __restrict  */)0);
  }
  }
#line 752
  return;
}
}
#line 754 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/ecatools/ecaplay.c"
static void signal_handler___0(int signum ) 
{ 


  {
#line 756
  ecaplay_skip_flag___0 ++;
#line 757
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___5  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___5(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___5(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___5(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___5(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___5(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___5(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___5(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___5(void) ;
#line 247
static void eci_impl_los_list_clear___5(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___5(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___5(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___5(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___5(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___5(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___5(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___5(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___5(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___5(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___5(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___5(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___5(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___5(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___5(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___5(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___5(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___5(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___5(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___5(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___5(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___5(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___5(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___5(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___5();
  }
  {
#line 972
  eci_string_add___5(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___5(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___5(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___5(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___5(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___5(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___5(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___5(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___5((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___5(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___5(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___5(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___5(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___5(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___5(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___5(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___5(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___5(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___5(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___5(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___5(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___5(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___5(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___5(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___5(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___5(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___5(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___5(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___5(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___5(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___6  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___6(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___6(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___6(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___6(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___6(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___6(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___6(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___6(void) ;
#line 247
static void eci_impl_los_list_clear___6(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___6(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___6(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___6(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___6(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___6(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___6(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___6(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___6(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___6(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___6(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___6(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___6(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___6(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___6(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___6(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___6(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___6(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___6(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___6(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___6(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___6(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___6(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___6(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___6();
  }
  {
#line 972
  eci_string_add___6(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___6(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___6(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___6(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___6(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___6(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___6(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___6(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___6((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___6(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___6(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___6(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___6(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___6(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___6(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___6(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___6(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___6(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___6(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___6(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___6(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___6(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___6(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___6(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___6(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___6(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___6(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___6(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___6(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___6(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
#line 197 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static eci_handle_t static_eci_rep___7  =    (eci_handle_t )0;
#line 239
static void eci_impl_check_handle___7(struct eci_internal *eci_rep ) ;
#line 240
static void eci_impl_free_parser___7(struct eci_internal *eci_rep ) ;
#line 241
static void eci_impl_clean_last_values___7(struct eci_parser *parser ) ;
#line 242
static void eci_impl_dump_parser_state___7(eci_handle_t ptr , char const   *message ) ;
#line 243
static ssize_t eci_impl_fd_read___7(int fd , void *buf , size_t count , int timeout ) ;
#line 244
static char const   *eci_impl_get_ecasound_path___7(void) ;
#line 245
static struct eci_los_list *eci_impl_los_list_add_item___7(struct eci_los_list *head ,
                                                           char *stmp , int len ) ;
#line 246
static struct eci_los_list *eci_impl_los_list_alloc_item___7(void) ;
#line 247
static void eci_impl_los_list_clear___7(struct eci_los_list *ptr ) ;
#line 248
static void eci_impl_read_return_value___7(struct eci_internal *eci_rep , int timeout ) ;
#line 249
static void eci_impl_set_last_los_value___7(struct eci_parser *parser ) ;
#line 250
static void eci_impl_set_last_values___7(struct eci_parser *parser ) ;
#line 251
static void eci_impl_update_state___7(struct eci_parser *parser , char c ) ;
#line 791
static void eci_string_add___7(eci_string *dst , int at , char const   *src , int len ) ;
#line 799 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_clear___7(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 801
  if (! str) {
    {
    {
#line 801
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            801);
    }
    }
  }
#line 802
  str->slen = 0;
#line 803
  if (str->size == 0) {
    {
    {
#line 804
    eci_string_add___7(str, 0, (char const   *)((void *)0), 0);
    }
    }
  } else {
#line 806
    *(str->d + 0) = (char)0;
  }
#line 807
  if (! ((int )*(str->d + 0) == 0)) {
    {
    {
#line 807
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str->d[0] == 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            807);
    }
    }
  }
#line 808
  return;
}
}
#line 815 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_init___7(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 817
  if (! str) {
    {
    {
#line 817
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            817);
    }
    }
  }
#line 818
  str->slen = 0;
#line 819
  str->size = 0;
#line 820
  str->d = (char *)0;
#line 821
  return;
}
}
#line 823 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_free___7(eci_string *str ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 825
  if (! str) {
    {
    {
#line 825
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "str", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            825);
    }
    }
  }
  {
  {
#line 826
  free((void *)str->d);
  }
#line 827
  str->size = 0;
#line 828
  str->slen = 0;
  }
#line 829
  return;
}
}
#line 844 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_string_add___7(eci_string *dst , int at , char const   *src , int len ) 
{ 
  int space_needed ;
  int newsize ;
  int tmp ;
  char *newbuf ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 846
  space_needed = (at + len) + 1;
#line 848
  if (! dst) {
    {
    {
#line 848
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "dst", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            848);
    }
    }
  }
#line 850
  if (space_needed > dst->size) {
#line 851
    if (dst->size) {
#line 851
      tmp = dst->size * 2;
    } else {
#line 851
      tmp = 64;
    }
#line 851
    newsize = tmp;
    {
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 854
      if (! (space_needed > newsize)) {
#line 854
        goto while_break;
      }
#line 855
      newsize *= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 857
    if (! (newsize <= 16777216)) {
      {
      {
#line 857
      __assert_fail("newsize <= 16777216", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    857U, "eci_string_add");
      }
      }
    }
    {
    {
#line 858
    tmp___0 = realloc((void *)dst->d, (size_t )newsize);
    }
#line 858
    newbuf = (char *)tmp___0;
    }
#line 859
    if (! newbuf) {
      {
      {
#line 859
      __assert_fail("newbuf", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
                    859U, "eci_string_add");
      }
      }
    }
#line 860
    dst->size = newsize;
#line 861
    dst->d = newbuf;
  }
#line 864
  if (! (space_needed <= dst->size)) {
    {
    {
#line 864
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "space_needed <= dst->size", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            864);
    }
    }
  }
  {
  {
#line 866
  memcpy((void */* __restrict  */)(dst->d + at), (void const   */* __restrict  */)src,
         (size_t )len);
  }
#line 867
  *(dst->d + (at + len)) = (char)0;
  }
#line 868
  return;
}
}
#line 870 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_check_handle___7(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 872
  if ((unsigned long )eci_rep == (unsigned long )((void *)0)) {
    {
    {
#line 873
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_null_handle);
    }
    }
#line 874
    if (! ((unsigned long )eci_rep != (unsigned long )((void *)0))) {
      {
      {
#line 874
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
              "eci_rep != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
              874);
      }
      }
    }
    {
    {
#line 875
    exit(-1);
    }
    }
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_free_parser___7(struct eci_internal *eci_rep ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 881
  if (! eci_rep) {
    {
    {
#line 881
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            881);
    }
    }
  }
  {
  {
#line 882
  eci_string_free___7(& (eci_rep->parser_repp)->last_error_repp);
  }
  {
#line 883
  eci_string_free___7(& (eci_rep->parser_repp)->last_s_repp);
  }
  {
#line 884
  eci_string_free___7(& (eci_rep->parser_repp)->buffer_rep);
  }
  {
#line 885
  free((void *)eci_rep->parser_repp);
  }
#line 886
  eci_rep->parser_repp = (struct eci_parser *)0;
  }
#line 887
  return;
}
}
#line 889 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_clean_last_values___7(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 891
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            891);
    }
    }
  }
  {
  {
#line 893
  eci_impl_los_list_clear___7(parser->last_los_repp);
  }
#line 894
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 895
  parser->last_i_rep = 0;
#line 896
  parser->last_li_rep = 0L;
#line 897
  parser->last_f_rep = (double )0.0f;
  {
#line 898
  eci_string_clear___7(& parser->last_error_repp);
  }
  {
#line 899
  eci_string_clear___7(& parser->last_s_repp);
  }
  }
#line 900
  return;
}
}
#line 902 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_dump_parser_state___7(eci_handle_t ptr , char const   *message ) 
{ 
  struct eci_internal *eci_rep ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 904
  eci_rep = (struct eci_internal *)ptr;
  {
#line 906
  tmp = eci_last_error_r(ptr);
  }
  {
#line 906
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n(ecasoundc_sa) Error=\'%s\', cmd=\'%s\' last_error=\'%s\' cmd_cnt=%d last_cnt=%d.\n",
          message, eci_rep->last_command_repp, tmp, eci_rep->commands_counter_rep,
          (eci_rep->parser_repp)->last_counter_rep);
  }
  }
#line 912
  return;
}
}
#line 921 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static ssize_t eci_impl_fd_read___7(int fd , void *buf , size_t count , int timeout ) 
{ 
  int nfds ;
  struct pollfd ufds ;
  ssize_t rescount ;
  int ret ;

  {
  {
#line 923
  nfds = 1;
#line 925
  rescount = 0;
#line 928
  ufds.fd = fd;
#line 929
  ufds.events = (short)3;
#line 930
  ufds.revents = (short)0;
  {
#line 932
  ret = poll(& ufds, (nfds_t )nfds, timeout);
  }
  }
#line 933
  if (ret > 0) {
#line 934
    if ((int )ufds.revents & 1) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    } else
#line 934
    if ((int )ufds.revents & 2) {
      {
      {
#line 936
      rescount = read(fd, buf, count);
      }
      }
    }
  } else
#line 939
  if (ret == 0) {
#line 941
    rescount = -1;
  }
#line 943
  return (rescount);
}
}
#line 946 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static char const   *eci_impl_get_ecasound_path___7(void) 
{ 
  char const   *result ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 948
  tmp = getenv("ECASOUND");
  }
#line 948
  result = (char const   *)tmp;
  }
#line 950
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 951
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            eci_str_no_ecasound_env);
    }
#line 952
    result = "ecasound";
    }
  }
#line 955
  return (result);
}
}
#line 959 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_add_item___7(struct eci_los_list *head ,
                                                           char *stmp , int len ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *last ;

  {
#line 961
  i = head;
#line 962
  last = (struct eci_los_list *)((void *)0);
  {
  {
#line 965
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 965
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 965
      goto while_break;
    }
#line 966
    last = i;
#line 967
    i = i->next_repp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 971
  i = eci_impl_los_list_alloc_item___7();
  }
  {
#line 972
  eci_string_add___7(& i->data_repp, 0, (char const   *)stmp, len);
  }
  }
#line 973
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 973
    last->next_repp = i;
  }
#line 978
  if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 979
    return (i);
  }
#line 982
  return (head);
}
}
#line 985 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static struct eci_los_list *eci_impl_los_list_alloc_item___7(void) 
{ 
  struct eci_los_list *item ;
  void *tmp ;
  struct eci_los_list *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 989
  tmp = calloc((size_t )1, (size_t )sizeof(struct eci_los_list ));
  }
#line 989
  item = (struct eci_los_list *)tmp;
  }
#line 990
  if (! ((unsigned long )item != (unsigned long )((void *)0))) {
    {
    {
#line 990
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "item != NULL", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            990);
    }
    }
  }
  {
#line 991
  tmp___0 = (struct eci_los_list *)((void *)0);
#line 991
  item->prev_repp = tmp___0;
#line 991
  item->next_repp = tmp___0;
  {
#line 992
  eci_string_clear___7(& item->data_repp);
  }
  }
#line 994
  return (item);
}
}
#line 997 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_los_list_clear___7(struct eci_los_list *ptr ) 
{ 
  struct eci_los_list *i ;
  struct eci_los_list *next ;

  {
#line 999
  i = ptr;
  {
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 1003
      goto while_break;
    }
    {
#line 1005
    next = i->next_repp;
    {
#line 1006
    eci_string_free___7(& i->data_repp);
    }
    {
#line 1007
    free((void *)i);
    }
#line 1008
    i = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  return;
}
}
#line 1012 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_read_return_value___7(struct eci_internal *eci_rep , int timeout ) 
{ 
  char *raw_buffer ;
  int attempts ;
  int res ;
  ssize_t tmp ;
  int n ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1014
  raw_buffer = eci_rep->raw_buffer_repp;
#line 1015
  attempts = 0;
#line 1017
  if (! (eci_rep->commands_counter_rep >= (eci_rep->parser_repp)->last_counter_rep)) {
    {
    {
#line 1017
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "eci_rep->commands_counter_rep >= eci_rep->parser_repp->last_counter_rep",
            "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1018);
    }
    }
  }
  {
  {
#line 1020
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (attempts < 9)) {
#line 1020
      goto while_break;
    }
    {
    {
#line 1021
    tmp = eci_impl_fd_read___7(eci_rep->cmd_read_fd_rep, (void *)raw_buffer, (size_t )65535,
                               timeout);
    }
#line 1021
    res = tmp;
    }
#line 1022
    if (res > 0) {
#line 1025
      *(raw_buffer + res) = (char)0;
#line 1028
      n = 0;
      {
      {
#line 1028
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1028
        if (! (n < res)) {
#line 1028
          goto while_break___0;
        }
        {
        {
#line 1030
        eci_impl_update_state___7(eci_rep->parser_repp, *(raw_buffer + n));
        }
#line 1028
        n ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1034
      if (eci_rep->commands_counter_rep == (eci_rep->parser_repp)->last_counter_rep) {
#line 1035
        goto while_break;
      }
    } else
#line 1040
    if (res < 0) {
#line 1042
      (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
#line 1043
      goto while_break;
    }
#line 1046
    attempts ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1049
  if (eci_rep->commands_counter_rep != (eci_rep->parser_repp)->last_counter_rep) {
    {
    {
#line 1051
    eci_impl_dump_parser_state___7((eci_handle_t )eci_rep, "read() error");
    }
#line 1052
    (eci_rep->parser_repp)->sync_lost_rep = (_Bool)1;
    }
  }
#line 1054
  return;
}
}
#line 1062 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_los_value___7(struct eci_parser *parser ) 
{ 
  struct eci_los_list *i ;
  int quoteflag ;
  int m ;
  int n ;
  eci_string stmp ;
  char c ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1064
  i = parser->last_los_repp;
#line 1065
  quoteflag = 0;
#line 1065
  m = 0;
  {
#line 1067
  eci_string_init___7(& stmp);
  }
  }
#line 1069
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1069
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1069);
    }
    }
  }
#line 1070
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1070
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1070);
    }
    }
  }
  {
  {
#line 1074
  eci_impl_los_list_clear___7(i);
  }
#line 1075
  parser->last_los_repp = (struct eci_los_list *)((void *)0);
#line 1077
  n = 0;
  }
  {
  {
#line 1077
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1077
    if (n < parser->buffer_current_rep) {
#line 1077
      if (! (n < parser->msgsize_rep)) {
#line 1077
        goto while_break;
      }
    } else {
#line 1077
      goto while_break;
    }
#line 1078
    c = *(parser->buffer_rep.d + n);
#line 1080
    if ((int )c == 34) {
#line 1081
      quoteflag = ! quoteflag;
    } else
#line 1083
    if ((int )c == 92) {
      {
#line 1084
      n ++;
#line 1085
      tmp = m;
#line 1085
      m ++;
      {
#line 1085
      eci_string_add___7(& stmp, tmp, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if ((int )c != 44) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___7(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else
#line 1087
    if (quoteflag == 1) {
      {
#line 1088
      tmp___0 = m;
#line 1088
      m ++;
      {
#line 1088
      eci_string_add___7(& stmp, tmp___0, (char const   *)(parser->buffer_rep.d + n),
                         1);
      }
      }
    } else {
#line 1091
      if (m == 0) {
#line 1091
        goto __Cont;
      }
      {
      {
#line 1092
      i = eci_impl_los_list_add_item___7(i, stmp.d, m);
      }
#line 1093
      m = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1077
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1096
  if (m > 0) {
    {
    {
#line 1097
    i = eci_impl_los_list_add_item___7(i, stmp.d, m);
    }
    }
  }
  {
#line 1100
  parser->last_los_repp = i;
  {
#line 1102
  eci_string_free___7(& stmp);
  }
  }
#line 1103
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_set_last_values___7(struct eci_parser *parser ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1114
  if (! ((unsigned long )parser != (unsigned long )((struct eci_parser *)0))) {
    {
    {
#line 1114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser != 0", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1114);
    }
    }
  }
#line 1115
  if (! (parser->state_rep == 10)) {
    {
    {
#line 1115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: DBC_CHECK failed - \"%s\", %s, %d.\n",
            "parser->state_rep == ECI_STATE_COMMON_LF_3", "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c",
            1115);
    }
    }
  }
  {
#line 1119
  if ((int )parser->last_type_repp[0] == 115) {
#line 1119
    goto case_115;
  }
#line 1123
  if ((int )parser->last_type_repp[0] == 83) {
#line 1123
    goto case_83;
  }
#line 1127
  if ((int )parser->last_type_repp[0] == 105) {
#line 1127
    goto case_105;
  }
#line 1131
  if ((int )parser->last_type_repp[0] == 108) {
#line 1131
    goto case_108;
  }
#line 1135
  if ((int )parser->last_type_repp[0] == 102) {
#line 1135
    goto case_102;
  }
#line 1139
  if ((int )parser->last_type_repp[0] == 101) {
#line 1139
    goto case_101;
  }
#line 1143
  goto switch_default;
  case_115: /* CIL Label */ 
  {
  {
#line 1120
  eci_string_add___7(& parser->last_s_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1121
  goto switch_break;
  case_83: /* CIL Label */ 
  {
  {
#line 1124
  eci_impl_set_last_los_value___7(parser);
  }
  }
#line 1125
  goto switch_break;
  case_105: /* CIL Label */ 
  {
  {
#line 1128
  parser->last_i_rep = atoi((char const   *)parser->buffer_rep.d);
  }
  }
#line 1129
  goto switch_break;
  case_108: /* CIL Label */ 
  {
  {
#line 1132
  parser->last_li_rep = atol((char const   *)parser->buffer_rep.d);
  }
  }
#line 1133
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 1136
  parser->last_f_rep = atof((char const   *)parser->buffer_rep.d);
  }
  }
#line 1137
  goto switch_break;
  case_101: /* CIL Label */ 
  {
  {
#line 1140
  eci_string_add___7(& parser->last_error_repp, 0, (char const   *)parser->buffer_rep.d,
                     parser->buffer_current_rep);
  }
  }
#line 1141
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/ecasound2.2-2.7.0/libecasoundc/ecasoundc_sa.c"
static void eci_impl_update_state___7(struct eci_parser *parser , char c ) 
{ 
  int len ;
  int tmp ;

  {
  {
#line 1152
  if (parser->state_rep == 0) {
#line 1152
    goto case_0;
  }
#line 1164
  if (parser->state_rep == 1) {
#line 1164
    goto case_1;
  }
#line 1186
  if (parser->state_rep == 2) {
#line 1186
    goto case_2;
  }
#line 1214
  if (parser->state_rep == 3) {
#line 1214
    goto case_3;
  }
#line 1221
  if (parser->state_rep == 4) {
#line 1221
    goto case_4;
  }
#line 1229
  if (parser->state_rep == 5) {
#line 1229
    goto case_5;
  }
#line 1252
  if (parser->state_rep == 6) {
#line 1252
    goto case_6;
  }
#line 1278
  if (parser->state_rep == 7) {
#line 1278
    goto case_7;
  }
#line 1285
  if (parser->state_rep == 8) {
#line 1285
    goto case_8;
  }
#line 1292
  if (parser->state_rep == 9) {
#line 1292
    goto case_9;
  }
#line 1299
  if (parser->state_rep == 10) {
#line 1299
    goto case_10;
  }
#line 1315
  if (parser->state_rep == 11) {
#line 1315
    goto case_11;
  }
#line 1322
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1153
  if ((int )c >= 48) {
#line 1153
    if ((int )c <= 57) {
      {
#line 1154
      parser->token_phase_rep = 1;
#line 1155
      parser->buffer_current_rep = 0;
      {
#line 1156
      eci_string_clear___7(& parser->buffer_rep);
      }
#line 1157
      parser->state_rep = 1;
      }
    } else {
#line 1160
      parser->token_phase_rep = 0;
    }
  } else {
#line 1160
    parser->token_phase_rep = 0;
  }
#line 1162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1165
  if ((int )c == 32) {
    {
    {
#line 1166
    parser->loglevel_rep = atoi((char const   *)parser->buffer_rep.d);
    }
    }
#line 1168
    if (parser->loglevel_rep == 256) {
#line 1170
      parser->state_msg_rep = 1;
    } else {
#line 1174
      parser->state_msg_rep = 0;
    }
#line 1177
    parser->state_rep = 2;
#line 1178
    parser->token_phase_rep = 0;
  } else
#line 1180
  if ((int )c < 48) {
#line 1180
    if ((int )c > 57) {
#line 1181
      parser->state_rep = 11;
    }
  }
#line 1184
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1187
  if ((int )c == 32) {
#line 1187
    if (parser->state_msg_rep == 1) {
#line 1187
      goto _L___0;
    } else {
#line 1187
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1187
  if ((int )c == 13) {
#line 1187
    if (parser->state_msg_rep == 0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 1190
      parser->msgsize_rep = atoi((char const   *)parser->buffer_rep.d);
      }
      }
#line 1194
      if (parser->state_msg_rep == 0) {
#line 1195
        parser->state_rep = 4;
      } else {
#line 1198
        parser->state_rep = 5;
      }
#line 1201
      parser->token_phase_rep = 0;
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1204
  if ((int )c < 48) {
#line 1204
    if ((int )c > 57) {
#line 1205
      parser->state_rep = 11;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1207
  if (parser->token_phase_rep == 0) {
    {
#line 1208
    parser->token_phase_rep = 1;
#line 1209
    parser->buffer_current_rep = 0;
    {
#line 1210
    eci_string_clear___7(& parser->buffer_rep);
    }
    }
  }
#line 1212
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1215
  if ((int )c == 13) {
#line 1216
    parser->state_rep = 4;
  } else {
#line 1218
    parser->state_rep = 0;
  }
#line 1219
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1222
  if ((int )c == 10) {
#line 1223
    parser->state_rep = 6;
  } else {
#line 1226
    parser->state_rep = 0;
  }
#line 1227
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1230
  if ((int )c == 13) {
#line 1233
    if (parser->buffer_current_rep < 4) {
#line 1233
      tmp = parser->buffer_current_rep;
    } else {
#line 1233
      tmp = 3;
    }
    {
#line 1233
    len = tmp;
    {
#line 1235
    memcpy((void */* __restrict  */)(parser->last_type_repp), (void const   */* __restrict  */)parser->buffer_rep.d,
           (size_t )len);
    }
#line 1236
    parser->last_type_repp[len] = (char)0;
#line 1240
    parser->state_rep = 4;
#line 1241
    parser->token_phase_rep = 0;
    }
  } else
#line 1244
  if (parser->token_phase_rep == 0) {
    {
#line 1245
    parser->token_phase_rep = 1;
#line 1246
    parser->buffer_current_rep = 0;
    {
#line 1247
    eci_string_clear___7(& parser->buffer_rep);
    }
    }
  }
#line 1250
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1253
  if ((int )c == 13) {
#line 1258
    if (parser->msgsize_rep == 0) {
      {
      {
#line 1259
      eci_string_clear___7(& parser->buffer_rep);
      }
      }
    }
#line 1267
    parser->state_rep = 8;
#line 1268
    parser->token_phase_rep = 2;
  } else
#line 1271
  if (parser->token_phase_rep == 0) {
    {
#line 1272
    parser->token_phase_rep = 1;
#line 1273
    parser->buffer_current_rep = 0;
    {
#line 1274
    eci_string_clear___7(& parser->buffer_rep);
    }
    }
  }
#line 1276
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  if ((int )c == 13) {
#line 1280
    parser->state_rep = 8;
  } else {
#line 1282
    parser->state_rep = 6;
  }
#line 1283
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1286
  if ((int )c == 10) {
#line 1287
    parser->state_rep = 9;
  } else {
#line 1289
    parser->state_rep = 6;
  }
#line 1290
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1293
  if ((int )c == 13) {
#line 1294
    parser->state_rep = 10;
  } else {
#line 1296
    parser->state_rep = 6;
  }
#line 1297
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1300
  if ((int )c == 10) {
#line 1301
    if (parser->state_msg_rep == 1) {
      {
      {
#line 1303
      eci_impl_set_last_values___7(parser);
      }
#line 1304
      (parser->last_counter_rep) ++;
      }
    }
#line 1309
    parser->state_rep = 0;
  } else {
#line 1312
    parser->state_rep = 6;
  }
#line 1313
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1316
  if ((int )c == 10) {
#line 1317
    parser->token_phase_rep = 0;
#line 1318
    parser->state_rep = 0;
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  if (parser->token_phase_rep == 1) {
    {
    {
#line 1327
    eci_string_add___7(& parser->buffer_rep, parser->buffer_current_rep, (char const   *)(& c),
                       1);
    }
#line 1328
    (parser->buffer_current_rep) ++;
    }
  }
#line 1332
  return;
}
}
