/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 137 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 322
struct _win_st;
#line 322 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 324 "/usr/include/curses.h"
typedef chtype attr_t;
#line 369
struct ldat;
#line 371 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 371 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 562
extern int putchar(int __c ) ;
#line 668
extern int puts(char const   *__s ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 471
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 551 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 554
extern int clearok(WINDOW * , _Bool  ) ;
#line 572
extern int echo(void) ;
#line 575
extern int endwin(void) ;
#line 596
extern WINDOW *initscr(void) ;
#line 611
extern int keypad(WINDOW * , _Bool  ) ;
#line 673
extern int nocbreak(void) ;
#line 675
extern int noecho(void) ;
#line 748
extern int waddch(WINDOW * , chtype const    ) ;
#line 751
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 764
extern int wclear(WINDOW * ) ;
#line 773
extern int wgetch(WINDOW * ) ;
#line 787
extern int wmove(WINDOW * , int  , int  ) ;
#line 792
extern int wrefresh(WINDOW * ) ;
#line 1325
extern WINDOW *curscr ;
#line 1327
extern WINDOW *stdscr ;
#line 1333
extern int LINES ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 40 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
char dev_labels[25][80]  = 
#line 40 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
  { {        (char )'V',        (char )'o',        (char )'l',        (char )' ', 
            (char )' ',        (char )'\000'}, 
   {        (char )'B',        (char )'a',        (char )'s',        (char )'s', 
            (char )' ',        (char )'\000'}, 
   {        (char )'T',        (char )'r',        (char )'e',        (char )'b', 
            (char )'l',        (char )'\000'}, 
   {        (char )'S',        (char )'y',        (char )'n',        (char )'t', 
            (char )'h',        (char )'\000'}, 
   {        (char )'P',        (char )'c',        (char )'m',        (char )' ', 
            (char )' ',        (char )'\000'}, 
   {        (char )'S',        (char )'p',        (char )'k',        (char )'r', 
            (char )' ',        (char )'\000'}, 
   {        (char )'L',        (char )'i',        (char )'n',        (char )'e', 
            (char )' ',        (char )'\000'}, 
   {        (char )'M',        (char )'i',        (char )'c',        (char )' ', 
            (char )' ',        (char )'\000'}, 
   {        (char )'C',        (char )'D',        (char )' ',        (char )' ', 
            (char )' ',        (char )'\000'}, 
   {        (char )'M',        (char )'i',        (char )'x',        (char )' ', 
            (char )' ',        (char )'\000'}, 
   {        (char )'P',        (char )'c',        (char )'m',        (char )'2', 
            (char )' ',        (char )'\000'}, 
   {        (char )'R',        (char )'e',        (char )'c',        (char )' ', 
            (char )' ',        (char )'\000'}, 
   {        (char )'I',        (char )'G',        (char )'a',        (char )'i', 
            (char )'n',        (char )'\000'}, 
   {        (char )'O',        (char )'G',        (char )'a',        (char )'i', 
            (char )'n',        (char )'\000'}, 
   {        (char )'L',        (char )'i',        (char )'n',        (char )'e', 
            (char )'1',        (char )'\000'}, 
   {        (char )'L',        (char )'i',        (char )'n',        (char )'e', 
            (char )'2',        (char )'\000'}, 
   {        (char )'L',        (char )'i',        (char )'n',        (char )'e', 
            (char )'3',        (char )'\000'}, 
   {        (char )'D',        (char )'i',        (char )'g',        (char )'i', 
            (char )'t',        (char )'a',        (char )'l',        (char )'1', 
            (char )'\000'}, 
   {        (char )'D',        (char )'i',        (char )'g',        (char )'i', 
            (char )'t',        (char )'a',        (char )'l',        (char )'2', 
            (char )'\000'}, 
   {        (char )'D',        (char )'i',        (char )'g',        (char )'i', 
            (char )'t',        (char )'a',        (char )'l',        (char )'3', 
            (char )'\000'}, 
   {        (char )'P',        (char )'h',        (char )'o',        (char )'n', 
            (char )'e',        (char )'I',        (char )'n',        (char )'\000'}, 
   {        (char )'P',        (char )'h',        (char )'o',        (char )'n', 
            (char )'e',        (char )'O',        (char )'u',        (char )'t', 
            (char )'\000'}, 
   {        (char )'V',        (char )'i',        (char )'d',        (char )'e', 
            (char )'o',        (char )'\000'}, 
   {        (char )'R',        (char )'a',        (char )'d',        (char )'i', 
            (char )'o',        (char )'\000'}, 
   {        (char )'M',        (char )'o',        (char )'n',        (char )'i', 
            (char )'t',        (char )'o',        (char )'r',        (char )'\000'}};
#line 41 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
char dev_names[25][80]  = 
#line 41
  { {        (char )'v',        (char )'o',        (char )'l',        (char )'\000'}, 
   {        (char )'b',        (char )'a',        (char )'s',        (char )'s', 
            (char )'\000'}, 
   {        (char )'t',        (char )'r',        (char )'e',        (char )'b', 
            (char )'l',        (char )'e',        (char )'\000'}, 
   {        (char )'s',        (char )'y',        (char )'n',        (char )'t', 
            (char )'h',        (char )'\000'}, 
   {        (char )'p',        (char )'c',        (char )'m',        (char )'\000'}, 
   {        (char )'s',        (char )'p',        (char )'e',        (char )'a', 
            (char )'k',        (char )'e',        (char )'r',        (char )'\000'}, 
   {        (char )'l',        (char )'i',        (char )'n',        (char )'e', 
            (char )'\000'}, 
   {        (char )'m',        (char )'i',        (char )'c',        (char )'\000'}, 
   {        (char )'c',        (char )'d',        (char )'\000'}, 
   {        (char )'m',        (char )'i',        (char )'x',        (char )'\000'}, 
   {        (char )'p',        (char )'c',        (char )'m',        (char )'2', 
            (char )'\000'}, 
   {        (char )'r',        (char )'e',        (char )'c',        (char )'\000'}, 
   {        (char )'i',        (char )'g',        (char )'a',        (char )'i', 
            (char )'n',        (char )'\000'}, 
   {        (char )'o',        (char )'g',        (char )'a',        (char )'i', 
            (char )'n',        (char )'\000'}, 
   {        (char )'l',        (char )'i',        (char )'n',        (char )'e', 
            (char )'1',        (char )'\000'}, 
   {        (char )'l',        (char )'i',        (char )'n',        (char )'e', 
            (char )'2',        (char )'\000'}, 
   {        (char )'l',        (char )'i',        (char )'n',        (char )'e', 
            (char )'3',        (char )'\000'}, 
   {        (char )'d',        (char )'i',        (char )'g',        (char )'1', 
            (char )'\000'}, 
   {        (char )'d',        (char )'i',        (char )'g',        (char )'2', 
            (char )'\000'}, 
   {        (char )'d',        (char )'i',        (char )'g',        (char )'3', 
            (char )'\000'}, 
   {        (char )'p',        (char )'h',        (char )'i',        (char )'n', 
            (char )'\000'}, 
   {        (char )'p',        (char )'h',        (char )'o',        (char )'u', 
            (char )'t',        (char )'\000'}, 
   {        (char )'v',        (char )'i',        (char )'d',        (char )'e', 
            (char )'o',        (char )'\000'}, 
   {        (char )'r',        (char )'a',        (char )'d',        (char )'i', 
            (char )'o',        (char )'\000'}, 
   {        (char )'m',        (char )'o',        (char )'n',        (char )'i', 
            (char )'t',        (char )'o',        (char )'r',        (char )'\000'}};
#line 42 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int dev_line[25]  ;
#line 45 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
char *mixerdev  =    (char *)"/dev/mixer";
#line 49 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int optnopt  =    0;
#line 49 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int optnerr  =    0;
#line 49 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int optnind  =    1;
#line 50 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
char *optnarg  =    (char *)((void *)0);
#line 53 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
static int optnpos  =    1;
#line 59 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int getoptn(int argc , char **argv , char *optstring ) 
{ 
  char *ptr ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 64
  if (optnind == argc) {
#line 65
    return (-1);
  } else
#line 64
  if ((int )*(*(argv + optnind)) != 45) {
#line 65
    return (-1);
  } else {
    {
    {
#line 64
    tmp = strlen((char const   *)*(argv + optnind));
    }
    }
#line 64
    if (tmp <= 1U) {
#line 65
      return (-1);
    }
  }
  {
  {
#line 67
  ptr = strchr((char const   *)optstring, (int )*(*(argv + optnind) + optnpos));
  }
  }
#line 67
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 68
    return ('?');
  } else {
#line 71
    optnopt = (int )*ptr;
#line 72
    if ((int )*(ptr + 1) == 58) {
#line 74
      if (optnind == argc - 1) {
#line 74
        return (':');
      }
#line 75
      optnarg = *(argv + (optnind + 1));
#line 76
      optnpos = 1;
#line 77
      optnind += 2;
#line 78
      return (optnopt);
    }
  }
  {
#line 86
  optnpos ++;
  {
#line 87
  tmp___0 = strlen((char const   *)*(argv + optnind));
  }
  }
#line 87
  if ((size_t )optnpos > tmp___0) {
#line 89
    optnpos = 1;
#line 90
    optnind ++;
  }
#line 93
  return (optnopt);
}
}
#line 98 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void die(char *str ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: couldn\'t %s.\n",
          str);
  }
  {
#line 101
  exit(1);
  }
  }
}
}
#line 105 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void init(int *mixfd , int *existmask , int *canrecmask , int *isrecmask , int *stereomask ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 108
  tmp = open((char const   *)mixerdev, 2);
  }
#line 108
  *mixfd = tmp;
  }
#line 108
  if (tmp < 0) {
    {
    {
#line 108
    die((char *)"open mixer device");
    }
    }
  }
  {
  {
#line 109
  tmp___0 = ioctl(*mixfd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 254U) | (sizeof(int ) << 16),
                  existmask);
  }
  }
#line 109
  if (tmp___0 == -1) {
    {
    {
#line 109
    die((char *)"ioctl");
    }
    }
  }
  {
  {
#line 110
  tmp___1 = ioctl(*mixfd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 253U) | (sizeof(int ) << 16),
                  canrecmask);
  }
  }
#line 110
  if (tmp___1 == -1) {
    {
    {
#line 110
    die((char *)"ioctl");
    }
    }
  }
  {
  {
#line 111
  tmp___2 = ioctl(*mixfd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 255U) | (sizeof(int ) << 16),
                  isrecmask);
  }
  }
#line 111
  if (tmp___2 == -1) {
    {
    {
#line 111
    die((char *)"ioctl");
    }
    }
  }
  {
  {
#line 113
  tmp___3 = ioctl(*mixfd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 251U) | (sizeof(int ) << 16),
                  stereomask);
  }
  }
#line 113
  if (tmp___3 == -1) {
#line 113
    *stereomask = 0;
  }
#line 114
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void init_term(void) 
{ 


  {
  {
  {
#line 119
  initscr();
  }
  {
#line 119
  cbreak();
  }
  {
#line 119
  noecho();
  }
  {
#line 120
  keypad(stdscr, (_Bool)1);
  }
  }
#line 121
  return;
}
}
#line 124 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void uninit(int mixfd ) 
{ 


  {
  {
  {
#line 126
  wclear(stdscr);
  }
  {
#line 126
  wrefresh(stdscr);
  }
  {
#line 127
  echo();
  }
  {
#line 127
  nocbreak();
  }
  {
#line 127
  endwin();
  }
  {
#line 128
  putchar('\n');
  }
  {
#line 129
  close(mixfd);
  }
  }
#line 130
  return;
}
}
#line 133 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void drawsel(int new , int old ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 135
  if (new != old) {
#line 137
    if (old >= 0) {
      {
      {
#line 139
      tmp = wmove(stdscr, 3 + dev_line[old], 1);
      }
      }
#line 139
      if (! (tmp == -1)) {
        {
        {
#line 139
        waddnstr(stdscr, "  ", -1);
        }
        }
      }
      {
      {
#line 140
      tmp___0 = wmove(stdscr, 3 + dev_line[old], 13);
      }
      }
#line 140
      if (! (tmp___0 == -1)) {
        {
        {
#line 140
        waddnstr(stdscr, "  ", -1);
        }
        }
      }
    }
#line 143
    if (new >= 0) {
      {
      {
#line 145
      tmp___1 = wmove(stdscr, 3 + dev_line[new], 1);
      }
      }
#line 145
      if (! (tmp___1 == -1)) {
        {
        {
#line 145
        waddnstr(stdscr, "->", -1);
        }
        }
      }
      {
      {
#line 146
      tmp___2 = wmove(stdscr, 3 + dev_line[new], 13);
      }
      }
#line 146
      if (! (tmp___2 == -1)) {
        {
        {
#line 146
        waddnstr(stdscr, "<-", -1);
        }
        }
      }
    }
  }
  {
  {
#line 151
  wmove(stdscr, 3 + dev_line[new], 0);
  }
  }
#line 152
  return;
}
}
#line 155 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int mixer_getlevel_stereo(int mixfd , int dev ) 
{ 
  int level ;

  {
  {
#line 157
  level = 0;
  {
#line 159
  ioctl(mixfd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | (unsigned int )dev) | (sizeof(int ) << 16),
        & level);
  }
  }
#line 160
  return (level);
}
}
#line 164 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int mixer_getlevel(int mixfd , int dev ) 
{ 
  int tmp ;

  {
  {
  {
#line 166
  tmp = mixer_getlevel_stereo(mixfd, dev);
  }
  }
#line 166
  return (tmp & 255);
}
}
#line 170 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void mixer_setlevel_stereo(int mixfd , int dev , int left , int right ) 
{ 


  {
  {
#line 172
  left += 256 * right;
  {
#line 173
  ioctl(mixfd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | (unsigned int )dev) | (sizeof(int ) << 16),
        & left);
  }
  }
#line 174
  return;
}
}
#line 177 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void mixer_setlevel(int mixfd , int dev , int level ) 
{ 


  {
  {
  {
#line 179
  mixer_setlevel_stereo(mixfd, dev, level, level);
  }
  }
#line 180
  return;
}
}
#line 183 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void mixer_change(int mixfd , int dev , int add ) 
{ 
  int level ;
  int tmp ;

  {
  {
  {
#line 185
  tmp = mixer_getlevel(mixfd, dev);
  }
#line 185
  level = tmp + add;
  }
#line 187
  if (level < 0) {
#line 187
    level = 0;
  }
#line 188
  if (level > 100) {
#line 188
    level = 100;
  }
  {
  {
#line 189
  mixer_setlevel(mixfd, dev, level);
  }
  }
#line 190
  return;
}
}
#line 193 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void mixer_rectoggle(int mixfd , int dev , int *isrecmask ) 
{ 


  {
  {
#line 195
  *isrecmask ^= 1 << dev;
  {
#line 196
  ioctl(mixfd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 255U) | (sizeof(int ) << 16),
        isrecmask);
  }
  }
#line 197
  return;
}
}
#line 200 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void mixer_recset(int mixfd , int dev , int *isrecmask , int on ) 
{ 


  {
#line 202
  if (on) {
#line 203
    *isrecmask |= 1 << dev;
  } else {
#line 205
    *isrecmask &= ~ (1 << dev);
  }
  {
  {
#line 206
  ioctl(mixfd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 255U) | (sizeof(int ) << 16),
        isrecmask);
  }
  }
#line 207
  return;
}
}
#line 210 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void drawlevel(int dev , int level ) 
{ 
  char buf[60] ;
  int f ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 216
  if (level < 0) {
#line 216
    level = 0;
  }
#line 217
  if (level > 100) {
#line 217
    level = 100;
  }
  {
  {
#line 219
  memset((void *)(buf), '=', (size_t )51);
  }
#line 220
  buf[51] = (char)0;
#line 221
  buf[level / 2] = (char )'|';
#line 222
  f = level / 2 + 1;
  }
  {
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 222
    if (! (f < 51)) {
#line 222
      goto while_break;
    }
#line 223
    buf[f] = (char )'-';
#line 222
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 225
  tmp = wmove(stdscr, 3 + dev_line[dev], 17);
  }
  }
#line 225
  if (! (tmp == -1)) {
    {
    {
#line 225
    waddnstr(stdscr, (char const   *)(buf), -1);
    }
    }
  }
  {
  {
#line 227
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%3d%%",
          level);
  }
  {
#line 228
  tmp___0 = wmove(stdscr, 3 + dev_line[dev], 71);
  }
  }
#line 228
  if (! (tmp___0 == -1)) {
    {
    {
#line 228
    waddnstr(stdscr, (char const   *)(buf), -1);
    }
    }
  }
#line 229
  return;
}
}
#line 232 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void drawrec(int dev , int on ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 234
  tmp___0 = wmove(stdscr, 3 + dev_line[dev], 77);
  }
  }
#line 234
  if (! (tmp___0 == -1)) {
#line 234
    if (on) {
#line 234
      tmp = 'R';
    } else {
#line 234
      tmp = ' ';
    }
    {
    {
#line 234
    waddch(stdscr, (chtype const   )tmp);
    }
    }
  }
#line 235
  return;
}
}
#line 238 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void setupframe(int existmask , int canrecmask , int *firstdevp , int *lastdevp ) 
{ 
  int f ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 241
  offset = 0;
  {
#line 243
  tmp = wmove(stdscr, 0, 36);
  }
  }
#line 243
  if (! (tmp == -1)) {
    {
    {
#line 243
    waddnstr(stdscr, "rexima", -1);
    }
    }
  }
  {
  {
#line 244
  tmp___0 = wmove(stdscr, 2, 17);
  }
  }
#line 244
  if (! (tmp___0 == -1)) {
    {
    {
#line 244
    waddnstr(stdscr, "min  .    .    .    .    :    .    .    .    .  max", -1);
    }
    }
  }
#line 248
  f = 0;
  {
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 248
    if (! (f < 25)) {
#line 248
      goto while_break;
    }
#line 250
    if (existmask & (1 << f)) {
#line 252
      if (offset == 0) {
#line 252
        *firstdevp = f;
      }
      {
#line 253
      *lastdevp = f;
#line 254
      tmp___1 = offset;
#line 254
      offset ++;
#line 254
      dev_line[f] = tmp___1;
      {
#line 255
      tmp___2 = wmove(stdscr, 3 + dev_line[f], 4);
      }
      }
#line 255
      if (! (tmp___2 == -1)) {
        {
        {
#line 255
        waddnstr(stdscr, (char const   *)(dev_labels[f]), -1);
        }
        }
      }
      {
      {
#line 256
      tmp___3 = wmove(stdscr, 3 + dev_line[f], 16);
      }
      }
#line 256
      if (! (tmp___3 == -1)) {
        {
        {
#line 256
        waddch(stdscr, (chtype const   )'[');
        }
        }
      }
      {
      {
#line 257
      tmp___4 = wmove(stdscr, 3 + dev_line[f], 68);
      }
      }
#line 257
      if (! (tmp___4 == -1)) {
        {
        {
#line 257
        waddch(stdscr, (chtype const   )']');
        }
        }
      }
#line 258
      if (canrecmask & (1 << f)) {
        {
        {
#line 259
        tmp___5 = wmove(stdscr, 3 + dev_line[f], 76);
        }
        }
#line 259
        if (! (tmp___5 == -1)) {
          {
          {
#line 259
          waddnstr(stdscr, "[ ]", -1);
          }
          }
        }
      }
    }
#line 248
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 263
  tmp___6 = wmove(stdscr, LINES - 1, 2);
  }
  }
#line 263
  if (! (tmp___6 == -1)) {
    {
    {
#line 263
    waddnstr(stdscr, "< move/alter with hjkl/cursors; space to toggle rec src; Esc/q/x to quit >",
             -1);
    }
    }
  }
#line 266
  return;
}
}
#line 270 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void usage_help(int existmask ) 
{ 
  int f ;
  int count ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 274
  puts("rexima 1.4 - copyright (c) 1996-2003 Russell Marks.\n\nusage: rexima [-hv] [-d mixer_device_file]\n\t\t    [device <level | offset | left,right | <rec | norec>>\n\t\t     [device ...]]\n\n\t-d\tspecify mixer device file to use (ordinarily /dev/mixer).\n\t-h\tgive this usage help.\n\t-v\tshow current mixer settings.\n");
  }
  {
#line 284
  printf((char const   */* __restrict  */)"\tdevice\ta device to set the level of. %s\n",
         mixerdev);
  }
  {
#line 286
  printf((char const   */* __restrict  */)"\t\twill allow the levels of these devices to be set:\n\n\t\t");
  }
#line 288
  count = 0;
#line 289
  f = 0;
  }
  {
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 289
    if (! (f < 25)) {
#line 289
      goto while_break;
    }
#line 291
    if (existmask & (1 << f)) {
      {
      {
#line 292
      printf((char const   */* __restrict  */)"%s ", dev_names[f]);
      }
#line 292
      count ++;
      }
    }
#line 293
    if (count >= 7) {
      {
      {
#line 293
      printf((char const   */* __restrict  */)"\n\t\t");
      }
#line 293
      count = 0;
      }
    }
#line 289
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 296
  puts("\n\n        level\tlevel to set specified device to.\n       offset\tamount to change level by (e.g. `-3\', `+12\').\n   left,right\tset (stereo) device\'s level with independent left/right values.\n  rec | norec\t`rec\' makes device a recording source, `norec\' makes it, well,\n\t\tnot a recording source. :-)\n\nIf invoked without any args (with the exception of `-d\'), rexima runs\ninteractively.");
  }
  }
#line 306
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
void cmdline_main(int argc , char **argv ) 
{ 
  int mixfd ;
  int existmask ;
  int canrecmask ;
  int isrecmask ;
  int stereomask ;
  int f ;
  int tmp ;
  int l ;
  int r ;
  int found ;
  char *ptr ;
  int done ;
  int want_usage ;
  int want_levels ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int offset_sign ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 317
  done = 0;
#line 317
  want_usage = 0;
#line 317
  want_levels = 0;
  {
  {
#line 319
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 320
    tmp___0 = getoptn(argc, argv, (char *)"d:hvV");
    }
    }
    {
#line 322
    if (tmp___0 == 100) {
#line 322
      goto case_100;
    }
#line 327
    if (tmp___0 == 104) {
#line 327
      goto case_104;
    }
#line 330
    if (tmp___0 == 86) {
#line 330
      goto case_86;
    }
#line 330
    if (tmp___0 == 118) {
#line 330
      goto case_86;
    }
#line 333
    if (tmp___0 == 63) {
#line 333
      goto case_63;
    }
#line 344
    if (tmp___0 == -1) {
#line 344
      goto case_neg_1;
    }
#line 320
    goto switch_break;
    case_100: /* CIL Label */ 
    {
    {
#line 323
    tmp___1 = strlen((char const   *)optnarg);
    }
    {
#line 323
    tmp___2 = malloc(tmp___1 + 1U);
    }
#line 323
    mixerdev = (char *)tmp___2;
    }
#line 323
    if ((unsigned long )mixerdev == (unsigned long )((void *)0)) {
      {
      {
#line 324
      die((char *)"allocate memory");
      }
      }
    }
    {
    {
#line 325
    strcpy((char */* __restrict  */)mixerdev, (char const   */* __restrict  */)optnarg);
    }
    }
#line 326
    goto switch_break;
    case_104: /* CIL Label */ 
#line 328
    want_usage = 1;
#line 329
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
#line 331
    want_levels = 1;
#line 332
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 336
    if (optnopt == 100) {
#line 336
      goto case_100___0;
    }
#line 340
    goto switch_default;
    case_100___0: /* CIL Label */ 
    {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: the `-d\' option needs a mixer device to be specified.\n");
    }
    }
#line 339
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
    {
#line 341
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: option `%c\' not recognised.\n",
            optnopt);
    }
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
    {
#line 343
    exit(1);
    }
    }
    case_neg_1: /* CIL Label */ 
#line 345
    done = 1;
    switch_break: /* CIL Label */ ;
    }
#line 319
    if (! (! done)) {
#line 319
      goto while_break;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (want_usage) {
    {
    {
#line 352
    init(& mixfd, & existmask, & canrecmask, & isrecmask, & stereomask);
    }
    {
#line 354
    usage_help(existmask);
    }
    {
#line 356
    exit(0);
    }
    }
  }
#line 359
  if (want_levels) {
    {
    {
#line 361
    init(& mixfd, & existmask, & canrecmask, & isrecmask, & stereomask);
    }
#line 363
    f = 0;
    }
    {
    {
#line 363
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 363
      if (! (f < 25)) {
#line 363
        goto while_break___0;
      }
#line 364
      if (existmask & (1 << f)) {
        {
        {
#line 366
        tmp = mixer_getlevel_stereo(mixfd, f);
        }
#line 367
        l = tmp & 255;
#line 367
        r = (tmp >> 8) & 255;
        {
#line 368
        printf((char const   */* __restrict  */)"%s\t%3d", dev_names[f], l);
        }
        }
#line 369
        if (stereomask & (1 << f)) {
          {
          {
#line 369
          printf((char const   */* __restrict  */)",%3d", r);
          }
          }
        }
#line 370
        if (canrecmask & (1 << f)) {
#line 371
          if (isrecmask & (1 << f)) {
#line 371
            tmp___3 = 'R';
          } else {
#line 371
            tmp___3 = ' ';
          }
          {
          {
#line 371
          printf((char const   */* __restrict  */)"\t[%c]", tmp___3);
          }
          }
        }
        {
        {
#line 372
        putchar('\n');
        }
        }
      }
#line 363
      f ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 375
    exit(0);
    }
    }
  }
#line 379
  if (optnind >= argc) {
#line 380
    return;
  }
  {
  {
#line 384
  init(& mixfd, & existmask, & canrecmask, & isrecmask, & stereomask);
  }
  }
  {
  {
#line 386
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 386
    if (! (optnind < argc)) {
#line 386
      goto while_break___1;
    }
#line 389
    found = 0;
#line 390
    f = 0;
    {
    {
#line 390
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 390
      if (! (f < 25)) {
#line 390
        goto while_break___2;
      }
#line 391
      if (existmask & (1 << f)) {
        {
        {
#line 391
        tmp___4 = strcmp((char const   *)*(argv + optnind), (char const   *)(dev_names[f]));
        }
        }
#line 391
        if (tmp___4 == 0) {
#line 393
          found = 1;
#line 394
          goto while_break___2;
        }
      }
#line 390
      f ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 397
    if (! found) {
      {
      {
#line 399
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: unavailable or unknown device `%s\'.\n",
              *(argv + optnind));
      }
      {
#line 400
      exit(1);
      }
      }
    }
#line 403
    if (argc - optnind < 2) {
      {
      {
#line 405
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: no setting specified for device `%s\'.\n",
              *(argv + optnind));
      }
      {
#line 406
      exit(1);
      }
      }
    }
    {
#line 409
    optnind ++;
#line 411
    tmp = f;
    {
#line 416
    tmp___12 = strcmp((char const   *)*(argv + optnind), "rec");
    }
    }
#line 416
    if (tmp___12 == 0) {
#line 416
      goto _L;
    } else {
      {
      {
#line 416
      tmp___13 = strcmp((char const   *)*(argv + optnind), "norec");
      }
      }
#line 416
      if (tmp___13 == 0) {
        _L: /* CIL Label */ 
#line 418
        if (! (canrecmask & (1 << f))) {
          {
          {
#line 420
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: can\'t set rec/norec on device `%s\'.\n",
                  *(argv + (optnind - 1)));
          }
          {
#line 422
          exit(1);
          }
          }
        }
        {
        {
#line 425
        mixer_recset(mixfd, tmp, & isrecmask, (int )*(*(argv + optnind) + 0) == 114);
        }
        }
      } else {
#line 429
        offset_sign = 0;
#line 432
        if ((int )*(*(argv + optnind) + 0) == 43) {
#line 433
          offset_sign = 1;
        }
#line 434
        if ((int )*(*(argv + optnind) + 0) == 45) {
#line 435
          offset_sign = -1;
        }
#line 438
        if (offset_sign) {
#line 438
          f = 1;
        } else {
#line 438
          f = 0;
        }
        {
        {
#line 438
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
          {
          {
#line 438
          tmp___6 = strlen((char const   *)*(argv + optnind));
          }
          }
#line 438
          if (! ((size_t )f < tmp___6)) {
#line 438
            goto while_break___3;
          }
          {
          {
#line 439
          tmp___5 = strchr("0123456789, \t", (int )*(*(argv + optnind) + f));
          }
          }
#line 439
          if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
            {
            {
#line 441
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: invalid level for device `%s\'.\n",
                    *(argv + (optnind - 1)));
            }
            {
#line 443
            exit(1);
            }
            }
          }
#line 438
          f ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
        {
#line 447
        ptr = strchr((char const   *)*(argv + optnind), ',');
        }
        }
#line 447
        if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 449
          if (offset_sign) {
            {
            {
#line 451
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: level offset must be mono, not stereo.\n");
            }
            {
#line 452
            exit(1);
            }
            }
          }
          {
          {
#line 455
          l = atoi((char const   *)*(argv + optnind));
          }
          {
#line 456
          r = atoi((char const   *)(ptr + 1));
          }
          {
#line 457
          mixer_setlevel_stereo(mixfd, tmp, l, r);
          }
          }
        } else
#line 462
        if (offset_sign) {
          {
          {
#line 463
          tmp___10 = strlen((char const   *)*(argv + optnind));
          }
          }
#line 463
          if (tmp___10 < 2U) {
#line 463
            tmp___9 = 2 * offset_sign;
          } else {
            {
            {
#line 463
            tmp___8 = atoi((char const   *)*(argv + optnind));
            }
#line 463
            tmp___9 = tmp___8;
            }
          }
          {
          {
#line 463
          mixer_change(mixfd, tmp, tmp___9);
          }
          }
        } else {
          {
          {
#line 467
          tmp___11 = atoi((char const   *)*(argv + optnind));
          }
          {
#line 467
          mixer_setlevel(mixfd, tmp, tmp___11);
          }
          }
        }
      }
    }
#line 471
    optnind ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 474
  exit(0);
  }
  }
}
}
#line 479 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
int main(int argc , char **argv ) 
{ 
  int quit ;
  int cursel ;
  int oldsel ;
  int mixfd ;
  int key ;
  int existmask ;
  int canrecmask ;
  int isrecmask ;
  int stereomask ;
  int firstdev ;
  int lastdev ;
  int f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp20 ;

  {
#line 481
  quit = 0;
#line 490
  if (argc > 1) {
    {
    {
#line 491
    cmdline_main(argc, argv);
    }
    }
  }
  {
  {
#line 493
  init(& mixfd, & existmask, & canrecmask, & isrecmask, & stereomask);
  }
  }
#line 496
  if (! existmask) {
    {
    {
#line 497
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rexima: mixer has no devices!\n");
    }
    {
#line 497
    exit(1);
    }
    }
  }
  {
  {
#line 499
  init_term();
  }
  {
#line 500
  setupframe(existmask, canrecmask, & firstdev, & lastdev);
  }
#line 501
  cursel = firstdev;
#line 503
  f = 0;
  }
  {
  {
#line 503
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 503
    if (! (f < 25)) {
#line 503
      goto while_break;
    }
#line 504
    if (existmask & (1 << f)) {
      {
      {
#line 506
      tmp = mixer_getlevel(mixfd, f);
      }
      {
#line 506
      drawlevel(f, tmp);
      }
      }
#line 507
      if (canrecmask & (1 << f)) {
        {
        {
#line 508
        drawrec(f, isrecmask & (1 << f));
        }
        }
      }
    }
#line 503
    f ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 511
  drawsel(cursel, -1);
  }
  {
#line 512
  wrefresh(stdscr);
  }
  }
  {
  {
#line 514
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 514
    if (! (! quit)) {
#line 514
      goto while_break___0;
    }
    {
#line 516
    oldsel = cursel;
    {
#line 518
    key = wgetch(stdscr);
    }
    }
    {
#line 522
    if (key == 27) {
#line 522
      goto case_27;
    }
#line 522
    if (key == 120) {
#line 522
      goto case_27;
    }
#line 522
    if (key == 113) {
#line 522
      goto case_27;
    }
#line 524
    if (key == 259) {
#line 524
      goto case_259;
    }
#line 524
    if (key == 107) {
#line 524
      goto case_259;
    }
#line 530
    if (key == 258) {
#line 530
      goto case_258;
    }
#line 530
    if (key == 106) {
#line 530
      goto case_258;
    }
#line 536
    if (key == 45) {
#line 536
      goto case_45;
    }
#line 536
    if (key == 260) {
#line 536
      goto case_45;
    }
#line 536
    if (key == 72) {
#line 536
      goto case_45;
    }
#line 536
    if (key == 104) {
#line 536
      goto case_45;
    }
#line 543
    if (key == 61) {
#line 543
      goto case_61;
    }
#line 543
    if (key == 43) {
#line 543
      goto case_61;
    }
#line 543
    if (key == 261) {
#line 543
      goto case_61;
    }
#line 543
    if (key == 76) {
#line 543
      goto case_61;
    }
#line 543
    if (key == 108) {
#line 543
      goto case_61;
    }
#line 550
    if (key == 32) {
#line 550
      goto case_32;
    }
#line 557
    if (key == 12) {
#line 557
      goto case_12;
    }
#line 557
    if (key == 18) {
#line 557
      goto case_12;
    }
#line 520
    goto switch_break;
    case_27: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 523
    quit = 1;
#line 523
    goto switch_break;
    case_259: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
    {
#line 525
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 526
      cursel --;
#line 525
      if (cursel >= firstdev) {
#line 525
        if (! (! (existmask & (1 << cursel)))) {
#line 525
          goto while_break___1;
        }
      } else {
#line 525
        goto while_break___1;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 528
    if (cursel < firstdev) {
#line 528
      cursel = lastdev;
    }
#line 529
    goto switch_break;
    case_258: /* CIL Label */ 
    case_106: /* CIL Label */ 
    {
    {
#line 531
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 532
      cursel ++;
#line 531
      if (cursel <= lastdev) {
#line 531
        if (! (! (existmask & (1 << cursel)))) {
#line 531
          goto while_break___2;
        }
      } else {
#line 531
        goto while_break___2;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 534
    if (cursel > lastdev) {
#line 534
      cursel = firstdev;
    }
#line 535
    goto switch_break;
    case_45: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 537
    if (existmask & (1 << cursel)) {
#line 539
      if (key == 72) {
#line 539
        tmp___0 = -1;
      } else {
#line 539
        tmp___0 = -2;
      }
      {
      {
#line 539
      mixer_change(mixfd, cursel, tmp___0);
      }
      {
#line 540
      tmp___1 = mixer_getlevel(mixfd, cursel);
      }
      {
#line 540
      drawlevel(cursel, tmp___1);
      }
      }
    }
#line 542
    goto switch_break;
    case_61: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_108: /* CIL Label */ 
#line 544
    if (existmask & (1 << cursel)) {
#line 546
      if (key == 76) {
#line 546
        tmp___2 = 1;
      } else {
#line 546
        tmp___2 = 2;
      }
      {
      {
#line 546
      mixer_change(mixfd, cursel, tmp___2);
      }
      {
#line 547
      tmp___3 = mixer_getlevel(mixfd, cursel);
      }
      {
#line 547
      drawlevel(cursel, tmp___3);
      }
      }
    }
#line 549
    goto switch_break;
    case_32: /* CIL Label */ 
#line 551
    if (canrecmask & (1 << cursel)) {
      {
      {
#line 553
      mixer_rectoggle(mixfd, cursel, & isrecmask);
      }
      {
#line 554
      drawrec(cursel, isrecmask & (1 << cursel));
      }
      }
    }
#line 556
    goto switch_break;
    case_12: /* CIL Label */ 
    case_18: /* CIL Label */ 
    {
    {
#line 558
    clearok(curscr, (_Bool)1);
    }
    }
#line 559
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 562
    drawsel(cursel, oldsel);
    }
    {
#line 564
    wrefresh(stdscr);
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 567
  uninit(mixfd);
  }
  {
#line 568
  exit(0);
  }
  }
}
}
#line 53 "/home/wslee/benchmarks/sound/rexima-1.4/rexima.c"
static int optnpos___0  =    1;
