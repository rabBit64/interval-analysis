/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 18 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.h"
struct global_config {
   int port ;
   short inetd ;
   short order ;
   short trace ;
   short recursive ;
   int debuglevel ;
   int max_clients ;
   char *username ;
   char *password ;
   char **pathlist ;
   char *program_name ;
   char *logfile ;
   char *conffile ;
   char *htmlfile ;
   char *htmlheader ;
   char *htmlmiddle ;
   char *htmlfooter ;
   char *servername ;
   char *serveraddress ;
   char *filter ;
};
#line 14 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.h"
struct node {
   int type ;
   char *name ;
   char *path ;
   off_t filesize ;
   int id3v1len ;
   int id3v2len ;
   int length ;
   char *title ;
   struct node *sibling ;
   struct node *child ;
};
#line 14 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.h"
typedef struct node mp3entry;
#line 4 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.h"
struct client_config {
   unsigned short mode ;
   char *username ;
   char *password ;
   char *requestpath ;
   long startpos ;
   long endpos ;
   FILE *stream ;
   int statussock ;
   mp3entry *mp3base ;
   short metadata ;
};
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 261 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 41 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.h"
struct childstat {
   pid_t childpid ;
   char *client ;
   char *status ;
};
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_28 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_31 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_26 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_27 _kill ;
   struct __anonstruct__timer_28 _timer ;
   struct __anonstruct__rt_29 _rt ;
   struct __anonstruct__sigchld_30 _sigchld ;
   struct __anonstruct__sigfault_31 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_26 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_44 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_44 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 102 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.h"
struct confoption {
   char *name ;
   unsigned short type ;
   void *value ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_50 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_51 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_50 __wait_terminated ;
   struct __anonstruct___wait_stopped_51 __wait_stopped ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 367
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 507 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 623
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 895
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 35 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *__xpg_basename(char *__path ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 190 "/usr/include/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 141 "/usr/include/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 143 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 59 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.h"
struct global_config gconf ;
#line 25 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.h"
char *getservername(void) ;
#line 26
void sendstatusmsg(int to , char *fmt  , ...) ;
#line 27
void logmsg(char *fmt  , ...) ;
#line 28
void debug(int priority , char *fmt  , ...) ;
#line 29
void die(char *fmt  , ...) ;
#line 30
char *mgetcwd(void) ;
#line 31
char *itoa(int integer ) ;
#line 32
char *urlencode(char *toencode ) ;
#line 33
char *htmlencode(char *toencode ) ;
#line 34
char *replacevariables(char *input , struct client_config *cconf___0 , mp3entry *entry ) ;
#line 36
short writemetadata(FILE *to , mp3entry *entry , short *metaflag ) ;
#line 37
void checkmp3info(mp3entry *entry ) ;
#line 59 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
int const   bitrate_table[2][3][16]  = { { {          (int const   )0,          (int const   )32,          (int const   )64,          (int const   )96, 
                (int const   )128,          (int const   )160,          (int const   )192,          (int const   )224, 
                (int const   )256,          (int const   )288,          (int const   )320,          (int const   )352, 
                (int const   )384,          (int const   )416,          (int const   )448,          (int const   )0}, 
     {          (int const   )0,          (int const   )32,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )160,          (int const   )192,          (int const   )224, 
                (int const   )256,          (int const   )320,          (int const   )384,          (int const   )0}, 
     {          (int const   )0,          (int const   )32,          (int const   )40,          (int const   )48, 
                (int const   )56,          (int const   )64,          (int const   )80,          (int const   )96, 
                (int const   )112,          (int const   )128,          (int const   )160,          (int const   )192, 
                (int const   )224,          (int const   )256,          (int const   )320,          (int const   )0}}, 
   { {          (int const   )0,          (int const   )32,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )144,          (int const   )160,          (int const   )176, 
                (int const   )192,          (int const   )224,          (int const   )256,          (int const   )0}, 
     {          (int const   )0,          (int const   )8,          (int const   )16,          (int const   )24, 
                (int const   )32,          (int const   )40,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )144,          (int const   )160,          (int const   )0}, 
     {          (int const   )0,          (int const   )8,          (int const   )16,          (int const   )24, 
                (int const   )32,          (int const   )40,          (int const   )48,          (int const   )56, 
                (int const   )64,          (int const   )80,          (int const   )96,          (int const   )112, 
                (int const   )128,          (int const   )144,          (int const   )160,          (int const   )0}}};
#line 76 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
int const   bs[4]  = {      (int const   )0,      (int const   )384,      (int const   )1152,      (int const   )1152};
#line 82 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
int const   freqtab[2][4]  = { {        (int const   )44100,        (int const   )48000,        (int const   )32000,        (int const   )0}, 
   {        (int const   )22050,        (int const   )24000,        (int const   )16000,        (int const   )0}};
#line 98 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
void sendstatusmsg(int to , char *fmt  , ...) 
{ 
  char buffer[1000] ;
  int length ;
  va_list argp ;
  size_t tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 105
  if (to >= 0) {
    {
    {
#line 106
    __builtin_va_start(argp, fmt);
    }
    {
#line 107
    length = vsnprintf((char */* __restrict  */)(buffer), (size_t )1000, (char const   */* __restrict  */)fmt,
                       argp);
    }
    {
#line 108
    sprintf((char */* __restrict  */)(& buffer[992]), (char const   */* __restrict  */)"<TRUNC>");
    }
    {
#line 109
    tmp = strlen((char const   *)(buffer));
    }
    {
#line 109
    send(to, (void const   *)(buffer), tmp + 1U, 0);
    }
    {
#line 110
    __builtin_va_end(argp);
    }
    }
  }
#line 112
  return;
}
}
#line 124 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static void printlogmsg(int type , char *fmt , va_list argp ) 
{ 
  char buffer[1000] ;
  int length ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __pid_t tmp___6 ;
  __pid_t tmp___7 ;
  int *tmp___8 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 130
  length = vsnprintf((char */* __restrict  */)(buffer), (size_t )1000, (char const   */* __restrict  */)fmt,
                     argp);
  }
  {
#line 131
  sprintf((char */* __restrict  */)(& buffer[992]), (char const   */* __restrict  */)"<TRUNC>");
  }
  }
#line 134
  if (! gconf.trace) {
#line 135
    if (type == 0) {
      {
      {
#line 136
      syslog(6, "%s", buffer);
      }
      }
    } else
#line 137
    if (type == 1) {
      {
      {
#line 138
      syslog(7, "%s", buffer);
      }
      }
    } else
#line 139
    if (type == 2) {
      {
      {
#line 140
      tmp___1 = __errno_location();
      }
      }
#line 140
      if (*tmp___1 != 0) {
        {
        {
#line 141
        tmp = __errno_location();
        }
        {
#line 141
        tmp___0 = strerror(*tmp);
        }
        {
#line 141
        syslog(3, "died - %s, errno: %s", buffer, tmp___0);
        }
        }
      } else {
        {
        {
#line 144
        syslog(3, "died - %s", buffer);
        }
        }
      }
      {
      {
#line 145
      exit(1);
      }
      }
    }
#line 147
    return;
  }
#line 151
  if (type == 0) {
    {
    {
#line 152
    tmp___2 = getpid();
    }
    {
#line 152
    printf((char const   */* __restrict  */)"LOG[%d]: %s", tmp___2, buffer);
    }
    }
  } else
#line 153
  if (type == 1) {
    {
    {
#line 154
    tmp___3 = getpid();
    }
    {
#line 154
    printf((char const   */* __restrict  */)"DBG[%d]: %s", tmp___3, buffer);
    }
    }
  } else
#line 155
  if (type == 2) {
    {
    {
#line 156
    tmp___8 = __errno_location();
    }
    }
#line 156
    if (*tmp___8 != 0) {
      {
      {
#line 157
      tmp___4 = __errno_location();
      }
      {
#line 157
      tmp___5 = strerror(*tmp___4);
      }
      {
#line 157
      tmp___6 = getpid();
      }
      {
#line 157
      printf((char const   */* __restrict  */)"DIE[%d]: (errno: %s) %s", tmp___6,
             tmp___5, buffer);
      }
      }
    } else {
      {
      {
#line 160
      tmp___7 = getpid();
      }
      {
#line 160
      printf((char const   */* __restrict  */)"DIE[%d]: %s", tmp___7, buffer);
      }
      }
    }
    {
    {
#line 161
    exit(1);
    }
    }
  }
  {
  {
#line 163
  fflush(stdout);
  }
  }
#line 164
  return;
}
}
#line 175 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
void logmsg(char *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
  {
#line 180
  __builtin_va_start(argp, fmt);
  }
  {
#line 181
  printlogmsg(0, fmt, argp);
  }
  {
#line 182
  __builtin_va_end(argp);
  }
  }
#line 183
  return;
}
}
#line 199 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
void debug(int priority , char *fmt  , ...) 
{ 
  va_list argp ;

  {
#line 204
  if (priority > gconf.debuglevel) {
#line 205
    return;
  }
  {
  {
#line 207
  __builtin_va_start(argp, fmt);
  }
  {
#line 208
  printlogmsg(1, fmt, argp);
  }
  {
#line 209
  __builtin_va_end(argp);
  }
  }
#line 210
  return;
}
}
#line 222 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
void die(char *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
  {
#line 227
  __builtin_va_start(argp, fmt);
  }
  {
#line 228
  printlogmsg(2, fmt, argp);
  }
  {
#line 229
  __builtin_va_end(argp);
  }
  }
#line 230
  return;
}
}
#line 233 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static void expandmalloc(void **old , size_t *size , int line ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 235
  *size *= 2U;
  {
#line 236
  debug(4, (char *)"called from %i, gonna realloc with size %i and old %p\n", line,
        *size, *old);
  }
  {
#line 238
  *old = realloc(*old, *size);
  }
  }
#line 239
  if ((unsigned long )*old == (unsigned long )((void *)0)) {
    {
    {
#line 240
    die((char *)"realloc failed\n");
    }
    }
  }
#line 241
  return;
}
}
#line 252 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
char *mgetcwd(void) 
{ 
  size_t size ;
  char *buffer ;
  void *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
#line 255
  size = (size_t )100;
  {
#line 256
  tmp = malloc(size);
  }
#line 256
  buffer = (char *)tmp;
  }
  {
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 259
    tmp___0 = getcwd(buffer, size);
    }
    }
#line 259
    if ((unsigned long )tmp___0 == (unsigned long )buffer) {
#line 260
      return (buffer);
    }
    {
    {
#line 261
    tmp___1 = __errno_location();
    }
    }
#line 261
    if (*tmp___1 != 34) {
      {
      {
#line 262
      die((char *)"getcwd");
      }
      }
    }
    {
    {
#line 263
    expandmalloc((void **)(& buffer), & size, 263);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 275 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
char *itoa(int integer ) 
{ 
  int tmp ;
  int size ;
  char *result___1 ;
  void *tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 277
  tmp = integer;
#line 281
  if (integer == 0) {
#line 282
    size = 2;
  } else
#line 283
  if (integer < 0) {
#line 284
    size = 2;
  } else
#line 285
  if (integer > 0) {
#line 286
    size = 1;
  }
  {
  {
#line 288
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 288
    if (! tmp) {
#line 288
      goto while_break;
    }
#line 289
    tmp /= 10;
#line 290
    size ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 293
  tmp___0 = malloc((size_t )size);
  }
#line 293
  result___1 = (char *)tmp___0;
  {
#line 294
  snprintf((char */* __restrict  */)result___1, (size_t )size, (char const   */* __restrict  */)"%i",
           integer);
  }
  }
#line 295
  return (result___1);
}
}
#line 307 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static char *commonencode(char *toencode , short url ) 
{ 
  char *validchars ;
  char *urlprefix ;
  char *htmlprefix ;
  char *urlsuffix ;
  char *htmlsuffix ;
  char *prefix ;
  char *suffix ;
  char *tmp ;
  char *tmp2 ;
  char *retval ;
  char buffer[3] ;
  size_t size ;
  size_t used ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 309
  validchars = (char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";
#line 310
  urlprefix = (char *)"%";
#line 311
  htmlprefix = (char *)"&#x";
#line 312
  urlsuffix = (char *)"";
#line 313
  htmlsuffix = (char *)";";
#line 320
  size = (size_t )100;
#line 321
  used = (size_t )1;
#line 323
  if (url) {
#line 324
    prefix = urlprefix;
#line 325
    suffix = urlsuffix;
  } else {
#line 327
    prefix = htmlprefix;
#line 328
    suffix = htmlsuffix;
  }
  {
  {
#line 331
  tmp___0 = malloc(size);
  }
#line 331
  retval = (char *)tmp___0;
  }
#line 332
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
    {
    {
#line 333
    die((char *)"malloc failed\n");
    }
    }
  }
#line 334
  *retval = (char )'\000';
#line 336
  tmp = toencode;
  {
  {
#line 336
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 336
    if (! ((int )*tmp != 0)) {
#line 336
      goto while_break;
    }
    {
    {
#line 337
    tmp___1 = strlen((char const   *)prefix);
    }
    {
#line 337
    tmp___2 = strlen((char const   *)suffix);
    }
    }
#line 337
    if (size - used < (tmp___1 + 2U) + tmp___2) {
      {
      {
#line 338
      expandmalloc((void **)(& retval), & size, 338);
      }
      }
    }
#line 339
    tmp2 = validchars;
    {
    {
#line 339
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 339
      if (! ((int )*tmp2 != 0)) {
#line 339
        goto while_break___0;
      }
#line 340
      if ((int )*tmp == (int )*tmp2) {
#line 341
        goto while_break___0;
      }
#line 339
      tmp2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 344
    if ((int )*tmp2 != 0) {
      {
#line 345
      buffer[0] = *tmp2;
#line 346
      buffer[1] = (char )'\000';
      {
#line 347
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)(buffer));
      }
#line 348
      used ++;
      }
    } else {
      {
      {
#line 350
      snprintf((char */* __restrict  */)(buffer), (size_t )3, (char const   */* __restrict  */)"%.2x",
               (int )((unsigned char )*tmp));
      }
      {
#line 351
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)prefix);
      }
      {
#line 352
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)(buffer));
      }
      {
#line 353
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)suffix);
      }
      {
#line 354
      tmp___3 = strlen((char const   *)prefix);
      }
      {
#line 354
      tmp___4 = strlen((char const   *)suffix);
      }
#line 354
      used += (tmp___3 + 2U) + tmp___4;
      }
    }
#line 336
    tmp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (retval);
}
}
#line 369 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
char *urlencode(char *toencode ) 
{ 
  char *tmp ;

  {
  {
  {
#line 371
  tmp = commonencode(toencode, (short)1);
  }
  }
#line 371
  return (tmp);
}
}
#line 382 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
char *htmlencode(char *toencode ) 
{ 
  char *tmp ;

  {
  {
  {
#line 384
  tmp = commonencode(toencode, (short)0);
  }
  }
#line 384
  return (tmp);
}
}
#line 404 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static char *result  =    (char *)((void *)0);
#line 401 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
char *replacevariables(char *input , struct client_config *cconf___0 , mp3entry *entry ) 
{ 
  char *str_nbsp ;
  char *str_err ;
  char *str_dir ;
  char *str_file ;
  char *str_sep ;
  char *start ;
  char *end ;
  char *variable ;
  char *encvariable ;
  char *variables[11][2] ;
  int i ;
  size_t size ;
  int used ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 406
  str_nbsp = (char *)"&nbsp;";
#line 407
  str_err = (char *)"Variable not allowed here";
#line 408
  str_dir = (char *)"DIR";
#line 409
  str_file = (char *)"FILE";
#line 410
  str_sep = (char *)"@";
#line 412
  start = input;
#line 436
  variables[0][0] = (char *)"@SERVERNAME@";
#line 436
  variables[0][1] = gconf.servername;
#line 436
  variables[1][0] = (char *)"@PORT@";
#line 436
  variables[1][1] = (char *)((void *)0);
#line 436
  variables[2][0] = (char *)"@PATH@";
#line 436
  variables[2][1] = cconf___0->requestpath;
#line 436
  variables[3][0] = (char *)"@NAME@";
#line 436
  variables[3][1] = str_err;
#line 436
  variables[4][0] = (char *)"@URL@";
#line 436
  variables[4][1] = str_err;
#line 436
  variables[5][0] = (char *)"@LENGTH@";
#line 436
  variables[5][1] = str_err;
#line 436
  variables[6][0] = (char *)"@TITLE@";
#line 436
  variables[6][1] = str_err;
#line 436
  variables[7][0] = (char *)"@SIZE@";
#line 436
  variables[7][1] = str_err;
#line 436
  variables[8][0] = (char *)"@TYPE@";
#line 436
  variables[8][1] = str_err;
#line 436
  variables[9][0] = (char *)"@FPATH@";
#line 436
  variables[9][1] = str_err;
#line 436
  variables[10][0] = (char *)((void *)0);
#line 436
  variables[10][1] = (char *)((void *)0);
#line 451
  size = (size_t )100;
#line 452
  used = 1;
#line 455
  if ((unsigned long )result != (unsigned long )((void *)0)) {
    {
    {
#line 456
    free((void *)result);
    }
#line 457
    result = (char *)((void *)0);
    }
  }
  {
  {
#line 460
  tmp = malloc(size);
  }
#line 460
  result = (char *)tmp;
  }
#line 461
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
    {
#line 462
    die((char *)"malloc failed\n");
    }
    }
  }
  {
#line 463
  *result = (char )'\000';
  {
#line 465
  variables[1][1] = itoa(gconf.port);
  }
  }
#line 466
  if (! (! entry)) {
#line 468
    if (entry->type == 0) {
      {
#line 469
      variables[3][1] = entry->name;
      {
#line 470
      tmp___0 = strlen((char const   *)entry->name);
      }
      {
#line 470
      tmp___1 = strlen("/index.html");
      }
      {
#line 470
      tmp___2 = malloc((tmp___0 + tmp___1) + 1U);
      }
#line 470
      variables[4][1] = (char *)tmp___2;
      {
#line 472
      sprintf((char */* __restrict  */)variables[4][1], (char const   */* __restrict  */)"%s/index.html",
              entry->name);
      }
#line 473
      variables[5][1] = str_nbsp;
#line 474
      variables[6][1] = str_dir;
#line 475
      variables[7][1] = str_nbsp;
#line 476
      variables[8][1] = str_dir;
#line 477
      variables[9][1] = str_nbsp;
      }
    } else {
      {
#line 479
      variables[3][1] = entry->name;
#line 480
      variables[4][1] = entry->name;
      {
#line 481
      variables[5][1] = itoa(entry->length);
      }
#line 482
      variables[6][1] = entry->title;
      {
#line 483
      variables[7][1] = itoa((int )entry->filesize);
      }
#line 484
      variables[8][1] = str_file;
#line 485
      variables[9][1] = entry->path;
      }
    }
  }
  {
  {
#line 488
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 488
    end = strchr((char const   *)start, '@');
    }
    }
#line 488
    if (! ((unsigned long )end != (unsigned long )((void *)0))) {
#line 488
      goto while_break;
    }
    {
    {
#line 489
    debug(1, (char *)"end is %s\n", end);
    }
    {
#line 490
    debug(1, (char *)"end is %p, start is %p, diff %i, used is %i, size is %i\n",
          end, start, (int )(end - start), used, size);
    }
    }
    {
    {
#line 491
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 491
      if (! ((end + used) - start > (long )size)) {
#line 491
        goto while_break___0;
      }
      {
      {
#line 492
      expandmalloc((void **)(& result), & size, 492);
      }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 494
    strncat((char */* __restrict  */)result, (char const   */* __restrict  */)start,
            (size_t )(end - start));
    }
#line 495
    used = (int )((long )used + (end - start));
#line 496
    variable = (char *)((void *)0);
#line 498
    i = 0;
    }
    {
    {
#line 498
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 498
      if (! ((unsigned long )variables[i][0] != (unsigned long )((void *)0))) {
#line 498
        goto while_break___1;
      }
      {
      {
#line 499
      tmp___6 = strlen((char const   *)variables[i][0]);
      }
      {
#line 499
      tmp___7 = strncmp((char const   *)end, (char const   *)variables[i][0], tmp___6);
      }
      }
#line 499
      if (! tmp___7) {
        {
        {
#line 501
        tmp___3 = strlen((char const   *)variables[i][0]);
        }
#line 501
        start = end + tmp___3;
#line 502
        variable = variables[i][1];
        {
#line 503
        tmp___4 = strlen((char const   *)variables[i][0]);
        }
        {
#line 503
        tmp___5 = strncmp((char const   *)variables[i][0], "@URL@", tmp___4);
        }
        }
#line 503
        if (tmp___5) {
          {
          {
#line 506
          encvariable = htmlencode(variable);
          }
          }
        } else {
          {
          {
#line 504
          encvariable = urlencode(variable);
          }
          }
        }
      }
#line 498
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 510
    if (! variable) {
#line 511
      start = end + 1;
#line 512
      variable = str_sep;
#line 513
      encvariable = str_sep;
    }
    {
    {
#line 516
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 516
      tmp___8 = strlen((char const   *)encvariable);
      }
      }
#line 516
      if (! ((size_t )used + tmp___8 > size)) {
#line 516
        goto while_break___2;
      }
      {
      {
#line 517
      expandmalloc((void **)(& result), & size, 517);
      }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 518
    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)encvariable);
    }
    {
#line 519
    tmp___9 = strlen((char const   *)encvariable);
    }
#line 519
    used = (int )((size_t )used + tmp___9);
    }
#line 521
    if ((unsigned long )encvariable != (unsigned long )str_sep) {
      {
      {
#line 522
      free((void *)encvariable);
      }
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 525
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 525
    tmp___10 = strlen((char const   *)start);
    }
    }
#line 525
    if (! ((size_t )used + tmp___10 > size)) {
#line 525
      goto while_break___3;
    }
    {
    {
#line 526
    expandmalloc((void **)(& result), & size, 526);
    }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 527
  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)start);
  }
  {
#line 528
  tmp___11 = strlen((char const   *)start);
  }
#line 528
  used = (int )((size_t )used + tmp___11);
  {
#line 530
  free((void *)variables[1][1]);
  }
  }
#line 531
  if (! (! entry)) {
#line 533
    if (entry->type == 0) {
      {
      {
#line 534
      free((void *)variables[4][1]);
      }
      }
    } else {
      {
      {
#line 536
      free((void *)variables[5][1]);
      }
      {
#line 537
      free((void *)variables[7][1]);
      }
      }
    }
  }
#line 540
  return (result);
}
}
#line 551 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static char *findfqdn(struct hostent *host ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
  {
#line 556
  tmp___0 = strchr((char const   *)host->h_name, '.');
  }
  }
#line 556
  if (tmp___0) {
    {
    {
#line 557
    tmp = strdup((char const   *)host->h_name);
    }
    }
#line 557
    return (tmp);
  }
#line 559
  i = 0;
  {
  {
#line 559
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 559
    if (! ((unsigned long )*(host->h_aliases + i) != (unsigned long )((void *)0))) {
#line 559
      goto while_break;
    }
    {
    {
#line 560
    tmp___4 = strchr((char const   *)*(host->h_aliases + i), '.');
    }
    }
#line 560
    if (tmp___4) {
      {
      {
#line 562
      tmp___2 = strlen((char const   *)host->h_name);
      }
      {
#line 562
      tmp___3 = strncasecmp((char const   *)*(host->h_aliases + i), (char const   *)host->h_name,
                            tmp___2);
      }
      }
#line 562
      if (! tmp___3) {
        {
        {
#line 563
        tmp___1 = strdup((char const   *)*(host->h_aliases + i));
        }
        }
#line 563
        return (tmp___1);
      }
    }
#line 559
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return ((char *)((void *)0));
}
}
#line 578 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
char *getservername(void) 
{ 
  char buf[257] ;
  char *hostname ;
  struct hostent *host ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 586
  hostname = (char *)((void *)0);
  {
#line 589
  tmp___1 = gethostname(buf, (size_t )(sizeof(buf) - 1UL));
  }
  }
#line 589
  if (tmp___1 == 0) {
    {
#line 590
    buf[sizeof(buf) - 1UL] = (char )'\000';
    {
#line 592
    host = gethostbyname((char const   *)(buf));
    }
    }
#line 592
    if (host) {
      {
      {
#line 592
      hostname = findfqdn(host);
      }
      }
#line 592
      if (hostname) {
#line 594
        return (hostname);
      }
    }
#line 597
    if (host) {
#line 597
      if ((unsigned long )*(host->h_addr_list + 0) != (unsigned long )((void *)0)) {
        {
        {
#line 598
        tmp = inet_ntoa(*((struct in_addr *)*(host->h_addr_list + 0)));
        }
        {
#line 598
        tmp___0 = strdup((char const   *)tmp);
        }
        }
#line 598
        return (tmp___0);
      }
    }
  }
  {
  {
#line 601
  logmsg((char *)"Failed to get hostname, please set serveraddress in configfile\n");
  }
  }
#line 602
  return ((char *)((void *)0));
}
}
#line 617 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
short writemetadata(FILE *to , mp3entry *entry , short *metaflag ) 
{ 
  int msglen ;
  int padding ;
  int towrite ;
  int written ;
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp13 ;

  {
#line 626
  if (*metaflag) {
    {
#line 627
    *metaflag = (short)0;
    {
#line 629
    tmp = strlen((char const   *)entry->title);
    }
#line 629
    msglen = (int )(tmp + 28U);
#line 630
    padding = 16 - msglen % 16;
#line 631
    towrite = (msglen + padding) + 1;
    {
#line 633
    tmp___0 = malloc((size_t )towrite);
    }
#line 633
    buf = (char *)tmp___0;
    {
#line 634
    memset((void *)buf, 0, (size_t )towrite);
    }
    {
#line 635
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%cStreamTitle=\'%s\';StreamUrl=\'\';",
            (msglen + padding) / 16, entry->title);
    }
    }
  } else {
    {
#line 638
    towrite = 1;
    {
#line 639
    tmp___1 = malloc((size_t )towrite);
    }
#line 639
    buf = (char *)tmp___1;
    {
#line 640
    memset((void *)buf, 0, (size_t )towrite);
    }
    }
  }
  {
  {
#line 643
  tmp___2 = fwrite((void const   */* __restrict  */)buf, (size_t )sizeof(char ), (size_t )towrite,
                   (FILE */* __restrict  */)to);
  }
#line 643
  written = (int )tmp___2;
  {
#line 644
  free((void *)buf);
  }
  }
#line 645
  if (written == towrite) {
#line 646
    return ((short)1);
  } else {
#line 648
    return ((short)0);
  }
}
}
#line 659 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static void stripspaces(char *buffer ) 
{ 
  int i ;

  {
#line 662
  i = 0;
  {
  {
#line 664
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 664
    if (! ((int )*(buffer + i) != 0)) {
#line 664
      goto while_break;
    }
#line 665
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 667
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 667
    if (! (i >= 0)) {
#line 667
      goto while_break___0;
    }
#line 668
    if ((int )*(buffer + i) == 32) {
#line 669
      *(buffer + i) = (char )'\000';
    } else
#line 670
    if (! ((int )*(buffer + i) == 0)) {
#line 673
      goto while_break___0;
    }
#line 667
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 686 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static short setid3v1title(FILE *file , mp3entry *entry ) 
{ 
  char buffer[31] ;
  int offsets[3] ;
  int i ;
  char *result___1 ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 690
  offsets[0] = -95;
#line 690
  offsets[1] = -65;
#line 690
  offsets[2] = -125;
  {
#line 694
  tmp = malloc((size_t )97);
  }
#line 694
  result___1 = (char *)tmp;
#line 695
  *result___1 = (char )'\000';
#line 697
  i = 0;
  }
  {
  {
#line 697
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 697
    if (! (i < 3)) {
#line 697
      goto while_break;
    }
    {
    {
#line 698
    tmp___0 = fseek(file, (long )offsets[i], 2);
    }
    }
#line 698
    if (tmp___0 != 0) {
      {
      {
#line 699
      free((void *)result___1);
      }
      }
#line 700
      return ((short)0);
    }
    {
    {
#line 704
    fgets((char */* __restrict  */)(buffer), 31, (FILE */* __restrict  */)file);
    }
    {
#line 705
    stripspaces(buffer);
    }
    }
#line 706
    if ((int )buffer[0] != 0) {
#line 706
      if ((int )*result___1 != 0) {
        {
        {
#line 707
        strcat((char */* __restrict  */)result___1, (char const   */* __restrict  */)" - ");
        }
        }
      }
    }
    {
    {
#line 708
    strcat((char */* __restrict  */)result___1, (char const   */* __restrict  */)(buffer));
    }
#line 697
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 711
  if ((int )*result___1 == 0) {
    {
    {
#line 712
    free((void *)result___1);
    }
    }
#line 713
    return ((short)0);
  } else {
    {
    {
#line 715
    tmp___1 = strlen((char const   *)result___1);
    }
    {
#line 715
    tmp___2 = realloc((void *)result___1, tmp___1 + 1U);
    }
#line 715
    entry->title = (char *)tmp___2;
    }
#line 716
    return ((short)1);
  }
}
}
#line 729 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static short setid3v2title(FILE *file , mp3entry *entry ) 
{ 
  char *buffer ;
  int minframesize ;
  int size ;
  int readsize ;
  int headerlen ;
  char *title ;
  char *artist ;
  char header[10] ;
  unsigned short version ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 734
  readsize = 0;
#line 735
  title = (char *)((void *)0);
#line 736
  artist = (char *)((void *)0);
#line 741
  if (entry->id3v2len < 10) {
#line 742
    return ((short)0);
  }
  {
  {
#line 745
  fseek(file, 0L, 0);
  }
  {
#line 746
  fread((void */* __restrict  */)(header), (size_t )sizeof(char ), (size_t )10, (FILE */* __restrict  */)file);
  }
#line 747
  version = (unsigned short )header[3];
#line 750
  size = entry->id3v2len - 10;
  {
#line 751
  tmp = malloc((size_t )(size + 1));
  }
#line 751
  buffer = (char *)tmp;
  {
#line 752
  tmp___0 = fread((void */* __restrict  */)buffer, (size_t )sizeof(char ), (size_t )size,
                  (FILE */* __restrict  */)file);
  }
  }
#line 752
  if (size != (int )tmp___0) {
    {
    {
#line 753
    free((void *)buffer);
    }
    }
#line 754
    return ((short)0);
  }
#line 756
  *(buffer + size) = (char )'\000';
#line 759
  if ((int )version > 2) {
#line 760
    minframesize = 12;
  } else {
#line 762
    minframesize = 8;
  }
  {
  {
#line 768
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 768
    if (! (size - readsize > minframesize)) {
#line 768
      goto while_break;
    }
#line 771
    if ((int )version > 2) {
      {
      {
#line 772
      memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)(buffer + readsize),
             (size_t )10);
      }
#line 773
      readsize += 10;
#line 774
      headerlen = (((((int )header[4] & 127) << 21) + (((int )header[5] & 127) << 14)) + (((int )header[6] & 127) << 7)) + ((int )header[7] & 127);
      }
    } else {
      {
      {
#line 777
      memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)(buffer + readsize),
             (size_t )6);
      }
#line 778
      readsize += 6;
#line 779
      headerlen = (((int )header[3] << 16) + ((int )header[4] << 8)) + (int )header[5];
      }
    }
#line 783
    if (headerlen < 1) {
#line 784
      goto while_continue;
    }
    {
    {
#line 787
    tmp___7 = strlen("TPE1");
    }
    {
#line 787
    tmp___8 = strncmp((char const   *)(header), "TPE1", tmp___7);
    }
    }
#line 787
    if (tmp___8) {
      {
      {
#line 787
      tmp___9 = strlen("TP1");
      }
      {
#line 787
      tmp___10 = strncmp((char const   *)(header), "TP1", tmp___9);
      }
      }
#line 787
      if (tmp___10) {
        {
        {
#line 797
        tmp___3 = strlen("TIT2");
        }
        {
#line 797
        tmp___4 = strncmp((char const   *)(header), "TIT2", tmp___3);
        }
        }
#line 797
        if (tmp___4) {
          {
          {
#line 797
          tmp___5 = strlen("TT2");
          }
          {
#line 797
          tmp___6 = strncmp((char const   *)(header), "TT2", tmp___5);
          }
          }
#line 797
          if (! tmp___6) {
            _L: /* CIL Label */ 
#line 799
            readsize ++;
#line 800
            headerlen --;
#line 801
            if (headerlen > size - readsize) {
#line 802
              headerlen = size - readsize;
            }
            {
            {
#line 803
            tmp___2 = malloc((size_t )(headerlen + 1));
            }
#line 803
            title = (char *)tmp___2;
            {
#line 804
            snprintf((char */* __restrict  */)title, (size_t )(headerlen + 1), (char const   */* __restrict  */)"%s",
                     buffer + readsize);
            }
#line 806
            readsize += headerlen;
            }
          }
        } else {
#line 797
          goto _L;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 789
        readsize ++;
#line 790
        headerlen --;
#line 791
        if (headerlen > size - readsize) {
#line 792
          headerlen = size - readsize;
        }
        {
        {
#line 793
        tmp___1 = malloc((size_t )(headerlen + 1));
        }
#line 793
        artist = (char *)tmp___1;
        {
#line 794
        snprintf((char */* __restrict  */)artist, (size_t )(headerlen + 1), (char const   */* __restrict  */)"%s",
                 buffer + readsize);
        }
#line 796
        readsize += headerlen;
        }
      }
    } else {
#line 787
      goto _L___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 811
  if (artist) {
#line 811
    if (title) {
      {
      {
#line 812
      tmp___11 = strlen((char const   *)artist);
      }
      {
#line 812
      tmp___12 = strlen((char const   *)title);
      }
      {
#line 812
      tmp___13 = malloc((tmp___11 + tmp___12) + 4U);
      }
#line 812
      entry->title = (char *)tmp___13;
      {
#line 813
      tmp___14 = strlen((char const   *)artist);
      }
      {
#line 813
      tmp___15 = strlen((char const   *)title);
      }
      {
#line 813
      snprintf((char */* __restrict  */)entry->title, (tmp___14 + tmp___15) + 4U,
               (char const   */* __restrict  */)"%s - %s", artist, title);
      }
      {
#line 815
      free((void *)artist);
      }
      {
#line 816
      free((void *)title);
      }
      }
    } else {
#line 811
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 817
  if (artist) {
#line 818
    entry->title = artist;
  } else
#line 819
  if (title) {
#line 820
    entry->title = title;
  }
  {
  {
#line 823
  free((void *)buffer);
  }
  }
#line 824
  return ((short )((unsigned long )entry->title != (unsigned long )((void *)0)));
}
}
#line 835 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static int getid3v2len(FILE *file ) 
{ 
  char buf[6] ;
  int offset ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 842
  tmp___0 = fseek(file, 0L, 0);
  }
  }
#line 842
  if (tmp___0 != 0) {
#line 845
    offset = 0;
  } else {
    {
    {
#line 842
    tmp___1 = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )6,
                    (FILE */* __restrict  */)file);
    }
    }
#line 842
    if (tmp___1 != 6U) {
#line 845
      offset = 0;
    } else {
      {
      {
#line 842
      tmp___2 = strlen("ID3");
      }
      {
#line 842
      tmp___3 = strncmp((char const   *)(buf), "ID3", tmp___2);
      }
      }
#line 842
      if (tmp___3 != 0) {
#line 845
        offset = 0;
      } else {
        {
        {
#line 847
        tmp = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )4,
                    (FILE */* __restrict  */)file);
        }
        }
#line 847
        if (tmp != 4U) {
#line 848
          offset = 0;
        } else {
#line 850
          offset = ((((((int )buf[0] & 127) << 21) + (((int )buf[1] & 127) << 14)) + (((int )buf[2] & 127) << 7)) + ((int )buf[3] & 127)) + 10;
        }
      }
    }
  }
#line 852
  return (offset);
}
}
#line 863 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static int getid3v1len(FILE *file ) 
{ 
  char buf[3] ;
  int offset ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 870
  tmp = fseek(file, -128L, 2);
  }
  }
#line 870
  if (tmp != 0) {
#line 873
    offset = 0;
  } else {
    {
    {
#line 870
    tmp___0 = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )3,
                    (FILE */* __restrict  */)file);
    }
    }
#line 870
    if (tmp___0 != 3U) {
#line 873
      offset = 0;
    } else {
      {
      {
#line 870
      tmp___1 = strncmp((char const   *)(buf), "TAG", (size_t )3);
      }
      }
#line 870
      if (tmp___1 != 0) {
#line 873
        offset = 0;
      } else {
#line 875
        offset = 128;
      }
    }
  }
#line 877
  return (offset);
}
}
#line 893 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static int getsonglength(FILE *file , mp3entry *entry ) 
{ 
  uint32_t header ;
  int version ;
  int layer ;
  int bitindex ;
  int bitrate ;
  int freqindex ;
  int frequency ;
  double bpf ;
  double tpf ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 913
  tmp = fseek(file, (long )entry->id3v2len, 0);
  }
  }
#line 913
  if (tmp) {
#line 914
    return (-1);
  }
#line 917
  version = 0;
  {
  {
#line 917
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 917
    if (! (version < 3)) {
#line 917
      goto while_break;
    }
    {
#line 918
    header <<= 8;
    {
#line 919
    tmp___0 = fread((void */* __restrict  */)(& header), (size_t )1, (size_t )1, (FILE */* __restrict  */)file);
    }
    }
#line 919
    if (! tmp___0) {
#line 920
      return (-1);
    }
#line 917
    version ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  restart: 
  {
  {
#line 925
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
#line 926
    header <<= 8;
    {
#line 927
    tmp___1 = fread((void */* __restrict  */)(& header), (size_t )1, (size_t )1, (FILE */* __restrict  */)file);
    }
    }
#line 927
    if (! tmp___1) {
#line 928
      return (-1);
    }
#line 925
    if (! (! (((header >> 21) & 2047U) == 2047U))) {
#line 925
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 937
  if ((header & 61440U) == 61440U) {
#line 938
    goto restart;
  }
  {
  {
#line 940
  debug(5, (char *)"We found %x-%x-%x-%x and checksync %i and test %x\n", (header >> 24) & 255U,
        (header >> 16) & 255U, (header >> 8) & 255U, header & 255U, ((header >> 21) & 2047U) == 2047U,
        (header & 61440U) == 61440U);
  }
  }
  {
#line 946
  if ((header & 1572864U) >> 19 == 2U) {
#line 946
    goto case_2;
  }
#line 949
  if ((header & 1572864U) >> 19 == 3U) {
#line 949
    goto case_3;
  }
#line 952
  goto switch_default;
  case_2: /* CIL Label */ 
#line 947
  version = 2;
#line 948
  goto switch_break;
  case_3: /* CIL Label */ 
#line 950
  version = 1;
#line 951
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 953
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 958
  if ((header & 393216U) >> 17 == 1U) {
#line 958
    goto case_1;
  }
#line 961
  if ((header & 393216U) >> 17 == 2U) {
#line 961
    goto case_2___0;
  }
#line 964
  if ((header & 393216U) >> 17 == 3U) {
#line 964
    goto case_3___0;
  }
#line 967
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 959
  layer = 3;
#line 960
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 962
  layer = 2;
#line 963
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 965
  layer = 1;
#line 966
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 968
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 972
  bitindex = (int )((header & 61440U) >> 12);
#line 973
  bitrate = (int )bitrate_table[version - 1][layer - 1][bitindex];
#line 974
  if (bitrate == 0) {
#line 975
    return (-1);
  }
#line 978
  freqindex = (int )((header & 3072U) >> 10);
#line 979
  frequency = (int )freqtab[version - 1][freqindex];
#line 980
  if (frequency == 0) {
#line 981
    return (-1);
  }
  {
  {
#line 983
  debug(2, (char *)"Version %i, lay %i, biti %i, bitr %i, freqi %i, freq %i\n", version,
        layer, bitindex, bitrate, freqindex, frequency);
  }
  }
  {
#line 988
  if (layer == 1) {
#line 988
    goto case_1___0;
  }
#line 994
  if (layer == 3) {
#line 994
    goto case_3___1;
  }
#line 994
  if (layer == 2) {
#line 994
    goto case_3___1;
  }
#line 999
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
#line 989
  bpf = (double )bitrate_table[version - 1][layer - 1][bitindex];
#line 990
  bpf *= 12000.0 * 4.0;
#line 991
  bpf /= (double )(freqtab[version - 1][freqindex] << (version - 1));
#line 992
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
#line 995
  bpf = (double )bitrate_table[version - 1][layer - 1][bitindex];
#line 996
  bpf *= (double )144000;
#line 997
  bpf /= (double )(freqtab[version - 1][freqindex] << (version - 1));
#line 998
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1000
  bpf = 1.0;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 1004
  tpf = (double )bs[layer];
#line 1005
  tpf /= (double )(freqtab[version - 1][freqindex] << (version - 1));
  {
#line 1007
  debug(3, (char *)"BitRate is %i, FileLength is %i, TPF is %f and BPF is %f, we have %f frames in one second\n",
        bitrate, entry->filesize, tpf, bpf, (double )1 / tpf);
  }
  }
#line 1013
  return ((int )(((double )((float )entry->filesize) / bpf) * tpf));
}
}
#line 1025 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
void checkmp3info(mp3entry *entry ) 
{ 
  FILE *file ;
  char *copy ;
  char *title ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1032
  file = fopen((char const   */* __restrict  */)entry->path, (char const   */* __restrict  */)"r");
  }
  }
#line 1032
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 1033
    return;
  }
  {
  {
#line 1035
  entry->id3v2len = getid3v2len(file);
  }
  {
#line 1036
  entry->id3v1len = getid3v1len(file);
  }
  {
#line 1037
  entry->length = getsonglength(file, entry);
  }
#line 1038
  entry->title = (char *)((void *)0);
  }
#line 1040
  if (entry->id3v2len > 0) {
    {
    {
#line 1041
    setid3v2title(file, entry);
    }
    }
  }
#line 1043
  if (entry->id3v1len > 0) {
#line 1043
    if (! entry->title) {
      {
      {
#line 1044
      setid3v1title(file, entry);
      }
      }
    }
  }
#line 1046
  if (! entry->title) {
    {
    {
#line 1047
    copy = strdup((char const   *)entry->path);
    }
    {
#line 1048
    title = __xpg_basename(copy);
    }
    {
#line 1049
    tmp = strlen((char const   *)title);
    }
    {
#line 1049
    tmp___0 = malloc(tmp - 3U);
    }
#line 1049
    entry->title = (char *)tmp___0;
    {
#line 1050
    tmp___1 = strlen((char const   *)title);
    }
    {
#line 1050
    snprintf((char */* __restrict  */)entry->title, tmp___1 - 3U, (char const   */* __restrict  */)"%s",
             title);
    }
    {
#line 1051
    free((void *)copy);
    }
    }
  }
  {
  {
#line 1054
  fclose(file);
  }
  }
#line 1055
  return;
}
}
#line 283 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 380 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 382
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 60 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.h"
struct childstat *childarray ;
#line 41 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.h"
mp3entry *root ;
#line 44
mp3entry *findentrybypath(mp3entry *base , char *name ) ;
#line 47
char *findpathbyentry(mp3entry *base , mp3entry *tofind , char *path ) ;
#line 53
mp3entry *findentrybyindex(mp3entry *base , int *index___0 ) ;
#line 56
short getrange(mp3entry *base , short recursive , int *min , int *max ) ;
#line 68
void cleartree(mp3entry **rootentry ) ;
#line 111 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.h"
int handleclient(int conn , int udpsock ) ;
#line 96 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.h"
short readrequest(struct client_config *cconf___0 ) ;
#line 48 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static int bytestometa  =    16000;
#line 59 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static int preparedata(char *buf , long end , FILE *from ) 
{ 
  long current ;
  int diff ;
  int amount ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 66
  if (end > 0L) {
    {
    {
#line 67
    current = ftell(from);
    }
    }
#line 68
    if (current < 0L) {
      {
      {
#line 69
      die((char *)"ftell()\n");
      }
      }
    }
#line 70
    diff = (int )(end - current);
#line 71
    if (current == end) {
#line 72
      return (0);
    }
  } else {
#line 74
    diff = 4000;
  }
  {
  {
#line 77
  tmp = feof(from);
  }
  }
#line 77
  if (tmp) {
#line 78
    return (0);
  }
#line 80
  if (diff < 4000) {
#line 80
    tmp___0 = diff;
  } else {
#line 80
    tmp___0 = 4000;
  }
  {
  {
#line 80
  tmp___1 = fread((void */* __restrict  */)buf, (size_t )sizeof(char ), (size_t )tmp___0,
                  (FILE */* __restrict  */)from);
  }
#line 80
  amount = (int )tmp___1;
  {
#line 82
  tmp___2 = ferror(from);
  }
  }
#line 82
  if (tmp___2) {
    {
    {
#line 83
    die((char *)"read()\n");
    }
    }
  }
#line 85
  return (amount);
}
}
#line 100 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void senddata(struct client_config *cconf___0 , char *buf , int amount , mp3entry *playing ) 
{ 
  int towrite ;
  int written ;
  size_t tmp ;
  size_t tmp___0 ;
  short tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 104
  written = 0;
#line 106
  if (! ((int )cconf___0->mode & 2)) {
    {
    {
#line 107
    tmp = fwrite((void const   */* __restrict  */)buf, (size_t )sizeof(char ), (size_t )amount,
                 (FILE */* __restrict  */)cconf___0->stream);
    }
    }
#line 107
    if (tmp != (size_t )amount) {
      {
      {
#line 108
      die((char *)"Error writing to client\n");
      }
      }
    }
  } else {
    {
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 110
      if (! (written < amount)) {
#line 110
        goto while_break;
      }
#line 111
      if (amount - written < bytestometa) {
#line 111
        towrite = amount - written;
      } else {
#line 111
        towrite = bytestometa;
      }
      {
      {
#line 112
      tmp___0 = fwrite((void const   */* __restrict  */)(buf + written), (size_t )sizeof(char ),
                       (size_t )towrite, (FILE */* __restrict  */)cconf___0->stream);
      }
      }
#line 112
      if (tmp___0 != (size_t )towrite) {
        {
        {
#line 113
        die((char *)"Error writing to client\n");
        }
        }
      }
#line 114
      bytestometa -= towrite;
#line 115
      written += towrite;
#line 116
      if (bytestometa == 0) {
        {
        {
#line 117
        tmp___1 = writemetadata(cconf___0->stream, playing, & cconf___0->metadata);
        }
        }
#line 117
        if (tmp___1) {
#line 118
          bytestometa = 16000;
        } else {
          {
          {
#line 120
          die((char *)"Error writing to client\n");
          }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 124
  return;
}
}
#line 136 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static long setoffsets(struct client_config *cconf___0 , FILE *stream , mp3entry *entry ) 
{ 
  long start ;
  long end ;
  char *__cil_tmp6 ;

  {
#line 142
  if (cconf___0->startpos > 0L) {
#line 142
    if (cconf___0->startpos < entry->filesize) {
#line 143
      start = cconf___0->startpos;
    } else {
#line 142
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 144
  if (! ((int )cconf___0->mode & 4)) {
#line 144
    if (entry->id3v2len) {
#line 145
      start = (long )entry->id3v2len;
    } else {
#line 147
      start = 0L;
    }
  } else {
#line 147
    start = 0L;
  }
  {
  {
#line 148
  fseek(stream, start, 0);
  }
  }
#line 150
  if (cconf___0->endpos > 0L) {
#line 150
    if (cconf___0->endpos < entry->filesize) {
#line 151
      end = cconf___0->endpos;
    } else {
#line 150
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 152
  if (entry->id3v1len > 0) {
#line 152
    if (end > (long )entry->id3v1len) {
#line 153
      end = entry->filesize - (off_t )entry->id3v1len;
    } else {
#line 155
      end = entry->filesize;
    }
  } else {
#line 155
    end = entry->filesize;
  }
  {
  {
#line 157
  debug(4, (char *)"Start offset is %li, end offset is %li\n", start, end);
  }
  }
#line 158
  return (end);
}
}
#line 170 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void playfile(struct client_config *cconf___0 , mp3entry *entry ) 
{ 
  FILE *file ;
  char buf[4000] ;
  int amount ;
  long end ;
  __pid_t tmp ;
  char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 178
  cconf___0->metadata = (short)1;
  {
#line 179
  debug(1, (char *)"Playing file %s\n", entry->path);
  }
  {
#line 180
  tmp = getpid();
  }
  {
#line 180
  sendstatusmsg(cconf___0->statussock, (char *)"%d:Playing file %s", tmp, entry->path);
  }
  }
#line 183
  if ((unsigned long )gconf.filter != (unsigned long )((void *)0)) {
    {
    {
#line 184
    tmp___0 = replacevariables(gconf.filter, cconf___0, (mp3entry *)((void *)0));
    }
    {
#line 184
    file = popen((char const   *)tmp___0, "r");
    }
    }
#line 184
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      {
      {
#line 186
      die((char *)"popen()\n");
      }
      }
    }
#line 187
    end = -1L;
  } else {
    {
    {
#line 189
    file = fopen((char const   */* __restrict  */)entry->path, (char const   */* __restrict  */)"r");
    }
    }
#line 189
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      {
      {
#line 190
      die((char *)"fopen()\n");
      }
      }
    }
    {
    {
#line 191
    end = setoffsets(cconf___0, file, entry);
    }
    }
  }
  {
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 195
    amount = preparedata(buf, end, file);
    }
    }
#line 195
    if (! amount) {
#line 195
      goto while_break;
    }
    {
    {
#line 196
    senddata(cconf___0, buf, amount, entry);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if ((unsigned long )gconf.filter != (unsigned long )((void *)0)) {
    {
    {
#line 199
    pclose(file);
    }
    }
  } else {
    {
    {
#line 201
    fclose(file);
    }
    }
  }
#line 202
  return;
}
}
#line 217 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void playrange(struct client_config *cconf___0 , int min , int max , short order ) 
{ 
  int i ;
  int toplay ;
  mp3entry *current ;
  int offset ;
  int numentries ;
  int numplayed ;
  char *played ;
  int playedsize ;
  time_t tmp ;
  __pid_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 226
  played = (char *)((void *)0);
#line 229
  if (order) {
#line 230
    toplay = max;
  } else {
    {
#line 232
    numplayed = 0;
#line 233
    numentries = (max - min) + 1;
#line 234
    playedsize = numentries / 8 + 1;
    {
#line 236
    tmp = time((time_t *)((void *)0));
    }
    {
#line 236
    tmp___0 = getpid();
    }
    {
#line 236
    srand((unsigned int )tmp + (unsigned int )tmp___0);
    }
    {
#line 238
    tmp___1 = malloc((size_t )playedsize);
    }
#line 238
    played = (char *)tmp___1;
    }
#line 238
    if ((unsigned long )played == (unsigned long )((void *)0)) {
      {
      {
#line 239
      die((char *)"malloc\n");
      }
      }
    }
    {
    {
#line 240
    memset((void *)played, 0, (size_t )playedsize);
    }
    }
  }
  {
  {
#line 243
  debug(1, (char *)"In playrange with range %i - %i and order %i\n", min, max, (int )order);
  }
  }
  {
  {
#line 246
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 247
    if (order) {
#line 248
      if (toplay == max) {
#line 248
        toplay = min;
      } else {
#line 248
        toplay ++;
      }
    } else {
#line 251
      if (numentries - numplayed == 0) {
        {
#line 252
        numplayed = 0;
        {
#line 253
        memset((void *)played, 0, (size_t )playedsize);
        }
        }
      }
      {
      {
#line 257
      tmp___2 = rand();
      }
#line 257
      offset = (int )((double )((float )(numentries - numplayed) * (float )tmp___2) / ((double )2147483647 + 1.0));
#line 261
      i = 0;
      }
      {
      {
#line 261
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 261
        if (! (i < numentries)) {
#line 261
          goto while_break___0;
        }
#line 263
        if ((((int )*(played + i / 8) >> i % 8) & 1) == 0) {
#line 264
          offset --;
        }
#line 266
        if (offset < 0) {
#line 267
          *(played + i / 8) = (char )((int )*(played + i / 8) | (1 << i % 8));
#line 268
          goto while_break___0;
        }
#line 261
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 273
      numplayed ++;
#line 274
      toplay = min + i;
#line 276
      i = 0;
      {
      {
#line 276
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 276
        if (! (i < playedsize)) {
#line 276
          goto while_break___1;
        }
        {
        {
#line 277
        debug(5, (char *)"Offset %i: %x\n", i * 8, (unsigned int )*(played + i));
        }
#line 276
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 281
    i = toplay;
    {
#line 282
    current = findentrybyindex(root, & i);
    }
    }
#line 283
    if (! current) {
      {
      {
#line 284
      die((char *)"Couldn\'t find entry with index %i\n", toplay);
      }
      }
    } else {
      {
      {
#line 286
      debug(1, (char *)"Going to play %s - index %i - order %i\n", current->name,
            toplay, (int )order);
      }
      }
    }
    {
    {
#line 287
    playfile(cconf___0, current);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  if (played) {
    {
    {
#line 291
    free((void *)played);
    }
    }
  }
}
}
#line 305 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void createhtml(struct client_config *cconf___0 , mp3entry *base ) 
{ 
  int i ;
  mp3entry *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 308
  i = 0;
#line 309
  tmp = base;
#line 311
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 312
    debug(3, (char *)"createhtml: base or output stream NULL - exiting");
    }
    }
#line 313
    return;
  } else
#line 311
  if ((unsigned long )cconf___0->stream == (unsigned long )((void *)0)) {
    {
    {
#line 312
    debug(3, (char *)"createhtml: base or output stream NULL - exiting");
    }
    }
#line 313
    return;
  }
  {
  {
#line 316
  tmp___0 = replacevariables(gconf.htmlheader, cconf___0, (mp3entry *)((void *)0));
  }
  {
#line 316
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"%s",
          tmp___0);
  }
  }
  {
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 317
      goto while_break;
    }
    {
    {
#line 318
    tmp___1 = replacevariables(gconf.htmlmiddle, cconf___0, tmp);
    }
    {
#line 318
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"%s",
            tmp___1);
    }
#line 319
    tmp = tmp->sibling;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 321
  tmp___2 = replacevariables(gconf.htmlfooter, cconf___0, (mp3entry *)((void *)0));
  }
  {
#line 321
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"%s",
          tmp___2);
  }
  }
#line 322
  return;
}
}
#line 332 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void createinfohtml(struct client_config *cconf___0 ) 
{ 
  int i ;
  int clientno ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 336
  clientno = 0;
#line 338
  if ((unsigned long )cconf___0->stream == (unsigned long )((void *)0)) {
    {
    {
#line 339
    debug(3, (char *)"createinfohtml: output stream NULL - exiting");
    }
    }
#line 340
    return;
  }
  {
  {
#line 343
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head>\n<title>%s</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n</head><body><center>\n<p><h1>%s</h1></p>\n<p><h2>Information page</h2></p>\n<p>&nbsp;</p>\n<div align=\"center\"><table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#000000\">",
          gconf.servername, gconf.servername);
  }
  {
#line 345
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\"><b>SERVER STATUS</b></td></tr>\n");
  }
  {
#line 346
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Name</td><td>%s</td></tr>\n",
          gconf.servername);
  }
  {
#line 347
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Address</td><td>%s</td></tr>\n",
          gconf.serveraddress);
  }
  {
#line 348
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Port</td><td>%d</td></tr>\n",
          gconf.port);
  }
  {
#line 349
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Max clients</td><td>%i</td></tr>\n",
          gconf.max_clients);
  }
  {
#line 351
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\"><b>CLIENT STATUS</b></td></tr>\n");
  }
  }
#line 353
  if (gconf.inetd) {
    {
    {
#line 354
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\">In inetd mode, no status available</td></tr>\n");
    }
    }
  } else
#line 355
  if (gconf.trace) {
    {
    {
#line 356
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\">In trace mode, no status available</td></tr>\n");
    }
    }
  } else {
#line 358
    i = 0;
    {
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 358
      if (! (i < gconf.max_clients)) {
#line 358
        goto while_break;
      }
#line 359
      if ((childarray + i)->childpid == 0) {
#line 360
        goto __Cont;
      }
      {
#line 361
      clientno ++;
      {
#line 362
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>%i - %s</td><td>%s</td></tr>\n",
              clientno, (childarray + i)->client, (childarray + i)->status);
      }
      }
      __Cont: /* CIL Label */ 
#line 358
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 365
    if (clientno == 0) {
      {
      {
#line 366
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\">None</td></tr>\n");
      }
      }
    }
  }
  {
  {
#line 369
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"</table></div>\n<p align=\"right\"><font size=\"-1\">powered by Ample, for more information, see the\n<a href=\"http://ample.sourceforge.net\">project homepage</a></font></p>\n</center></body></html>");
  }
  }
#line 370
  return;
}
}
#line 383 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void createm3u(struct client_config *cconf___0 , mp3entry *base , short recursive ) 
{ 
  mp3entry *tmp ;
  char *dir ;
  char *tmp___0 ;
  char *vpath ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 386
  tmp = base;
  {
#line 387
  tmp___0 = findpathbyentry(root, base, (char *)"");
  }
#line 387
  dir = tmp___0;
  }
#line 390
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 391
    return;
  } else
#line 390
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 391
    return;
  } else
#line 390
  if ((unsigned long )cconf___0->stream == (unsigned long )((void *)0)) {
#line 391
    return;
  }
  {
  {
#line 392
  dir = dirname(dir);
  }
  }
  {
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 394
      goto while_break;
    }
#line 395
    if (tmp->type == 0) {
#line 396
      if (recursive) {
#line 396
        if (tmp->child) {
          {
          {
#line 397
          createm3u(cconf___0, tmp->child, recursive);
          }
          }
        }
      }
    } else {
      {
      {
#line 398
      vpath = findpathbyentry(root, tmp, (char *)"");
      }
      }
#line 398
      if (vpath) {
        {
        {
#line 399
        fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"#EXTINF:%i,%s\n",
                tmp->length, tmp->title);
        }
        {
#line 401
        fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"http://%s:%d%s\n",
                gconf.serveraddress, gconf.port, vpath);
        }
        {
#line 403
        free((void *)vpath);
        }
        }
      }
    }
#line 405
    tmp = tmp->sibling;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 417 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static short check_authentication(struct client_config *cconf___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 420
  if ((unsigned long )gconf.username == (unsigned long )((void *)0)) {
#line 421
    return ((short)1);
  } else
#line 420
  if ((unsigned long )gconf.password == (unsigned long )((void *)0)) {
#line 421
    return ((short)1);
  }
#line 423
  if ((unsigned long )cconf___0->username == (unsigned long )((void *)0)) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
            gconf.servername);
    }
    {
#line 429
    fflush(cconf___0->stream);
    }
    }
#line 430
    return ((short)0);
  } else
#line 423
  if ((unsigned long )cconf___0->password == (unsigned long )((void *)0)) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
            gconf.servername);
    }
    {
#line 429
    fflush(cconf___0->stream);
    }
    }
#line 430
    return ((short)0);
  } else {
    {
    {
#line 423
    tmp = strcmp((char const   *)cconf___0->username, (char const   *)gconf.username);
    }
    }
#line 423
    if (tmp) {
      {
      {
#line 428
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
              gconf.servername);
      }
      {
#line 429
      fflush(cconf___0->stream);
      }
      }
#line 430
      return ((short)0);
    } else {
      {
      {
#line 423
      tmp___0 = strcmp((char const   *)cconf___0->password, (char const   *)gconf.password);
      }
      }
#line 423
      if (tmp___0) {
        {
        {
#line 428
        fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
                gconf.servername);
        }
        {
#line 429
        fflush(cconf___0->stream);
        }
        }
#line 430
        return ((short)0);
      } else {
#line 432
        return ((short)1);
      }
    }
  }
}
}
#line 446 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
int handleclient(int conn , int udpsock ) 
{ 
  int min ;
  int max ;
  struct client_config *cconf___0 ;
  void *tmp ;
  __pid_t tmp___0 ;
  FILE *tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  __pid_t tmp___4 ;
  __pid_t tmp___5 ;
  __pid_t tmp___6 ;
  __pid_t tmp___7 ;
  long tmp___8 ;
  __pid_t tmp___9 ;
  __pid_t tmp___10 ;
  __pid_t tmp___11 ;
  __pid_t tmp___12 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
#line 452
  cconf___0 = (struct client_config *)((void *)0);
  {
#line 455
  tmp = malloc((size_t )sizeof(struct client_config ));
  }
#line 455
  cconf___0 = (struct client_config *)tmp;
  }
#line 456
  if ((unsigned long )cconf___0 == (unsigned long )((void *)0)) {
    {
    {
#line 457
    die((char *)"Malloc failed\n");
    }
    }
  }
  {
  {
#line 458
  memset((void *)cconf___0, 0, (size_t )sizeof(struct client_config ));
  }
#line 459
  cconf___0->statussock = udpsock;
  {
#line 462
  tmp___0 = getpid();
  }
  {
#line 462
  sendstatusmsg(cconf___0->statussock, (char *)"%d:connecting", tmp___0);
  }
  {
#line 465
  tmp___1 = fdopen(conn, "r+");
  }
#line 465
  cconf___0->stream = tmp___1;
  }
#line 465
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
    {
#line 467
    debug(1, (char *)"Error while reading client request\n");
    }
    {
#line 468
    fclose(cconf___0->stream);
    }
    {
#line 469
    free((void *)cconf___0);
    }
    }
#line 470
    return (1);
  } else {
    {
    {
#line 465
    tmp___2 = readrequest(cconf___0);
    }
    }
#line 465
    if (! tmp___2) {
      {
      {
#line 467
      debug(1, (char *)"Error while reading client request\n");
      }
      {
#line 468
      fclose(cconf___0->stream);
      }
      {
#line 469
      free((void *)cconf___0);
      }
      }
#line 470
      return (1);
    }
  }
  {
  {
#line 472
  debug(1, (char *)"Requested path %s\n", cconf___0->requestpath);
  }
  {
#line 473
  cconf___0->mp3base = findentrybypath(root, cconf___0->requestpath);
  }
  }
#line 475
  if ((unsigned long )cconf___0->mp3base == (unsigned long )((void *)0)) {
    {
    {
#line 476
    die((char *)"Incorrect file/dir requested\n");
    }
    }
  }
  {
  {
#line 478
  tmp___3 = check_authentication(cconf___0);
  }
  }
#line 478
  if (! tmp___3) {
    {
    {
#line 479
    die((char *)"Incorrect or no credentials specified\n");
    }
    }
  }
#line 481
  if ((int )cconf___0->mode & 1) {
    {
    {
#line 482
    debug(1, (char *)"Entering HTML mode\n");
    }
    {
#line 483
    tmp___4 = getpid();
    }
    {
#line 483
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending HTML data", tmp___4);
    }
    {
#line 485
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nServer: Ample/%s\r\nAccept-Range: none\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n",
            "0.5.7");
    }
    {
#line 486
    fflush(cconf___0->stream);
    }
    {
#line 487
    createhtml(cconf___0, cconf___0->mp3base);
    }
    }
  } else
#line 489
  if ((int )cconf___0->mode & 16) {
    {
    {
#line 490
    debug(1, (char *)"Entering recursive M3U mode\n");
    }
    {
#line 491
    tmp___5 = getpid();
    }
    {
#line 491
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending recursive M3U data",
                  tmp___5);
    }
    {
#line 493
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nServer: Ample/%s\r\nAccept-Range: none\r\nContent-Type: audio/x-mpegurl\r\nConnection: close\r\n\r\n",
            "0.5.7");
    }
    {
#line 494
    fflush(cconf___0->stream);
    }
    {
#line 495
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"#EXTM3U\n");
    }
    {
#line 496
    createm3u(cconf___0, cconf___0->mp3base, (short)1);
    }
    }
  } else
#line 498
  if ((int )cconf___0->mode & 8) {
    {
    {
#line 499
    debug(1, (char *)"Entering non-recursive M3U mode\n");
    }
    {
#line 500
    tmp___6 = getpid();
    }
    {
#line 500
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending non-recursive M3U data",
                  tmp___6);
    }
    {
#line 502
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nServer: Ample/%s\r\nAccept-Range: none\r\nContent-Type: audio/x-mpegurl\r\nConnection: close\r\n\r\n",
            "0.5.7");
    }
    {
#line 503
    fflush(cconf___0->stream);
    }
    {
#line 504
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"#EXTM3U\n");
    }
    {
#line 505
    createm3u(cconf___0, cconf___0->mp3base, (short)0);
    }
    }
  } else
#line 507
  if ((int )cconf___0->mode & 32) {
    {
    {
#line 508
    debug(1, (char *)"Entering MP3-Partial mode\n");
    }
    {
#line 509
    tmp___7 = getpid();
    }
    {
#line 509
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending partial MP3", tmp___7);
    }
#line 511
    tmp___8 = (long )(cconf___0->endpos > (cconf___0->mp3base)->filesize);
#line 511
    cconf___0->endpos = tmp___8;
    }
#line 511
    if (tmp___8) {
      {
      {
#line 512
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 206 Partial Content\r\nServer: Ample/%s\r\nAccept-Range: bytes\r\nContent-Type: audio/mpeg\r\nContent-Range: bytes %lu-%lu/%lu\r\nConnection: close\r\n\r\n",
              "0.5.7", cconf___0->startpos, (cconf___0->mp3base)->filesize, (cconf___0->mp3base)->filesize);
      }
      }
    } else {
      {
      {
#line 516
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 206 Partial Content\r\nServer: Ample/%s\r\nAccept-Range: bytes\r\nContent-Type: audio/mpeg\r\nContent-Range: bytes %lu-%lu/%lu\r\nConnection: close\r\n\r\n",
              "0.5.7", cconf___0->startpos, cconf___0->endpos, (cconf___0->mp3base)->filesize);
      }
      }
    }
    {
    {
#line 519
    fflush(cconf___0->stream);
    }
    {
#line 520
    playfile(cconf___0, cconf___0->mp3base);
    }
    }
  } else
#line 522
  if ((int )cconf___0->mode & 4) {
    {
    {
#line 523
    debug(1, (char *)"Entering MP3-Single mode\n");
    }
    {
#line 524
    tmp___9 = getpid();
    }
    {
#line 524
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending single MP3", tmp___9);
    }
    {
#line 526
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nServer: Ample/%s\r\nAccept-Range: bytes\r\nContent-Type: audio/mpeg\r\nContent-Length: %lu\r\nConnection: close\r\n\r\n",
            "0.5.7", (cconf___0->mp3base)->filesize);
    }
    {
#line 528
    fflush(cconf___0->stream);
    }
    {
#line 529
    playfile(cconf___0, cconf___0->mp3base);
    }
    }
  } else
#line 531
  if ((int )cconf___0->mode & 2) {
    {
    {
#line 532
    getrange(cconf___0->mp3base, gconf.recursive, & min, & max);
    }
    {
#line 533
    debug(1, (char *)"Entering MP3-Metadata mode (range %i - %i)\n", min, max);
    }
    {
#line 535
    tmp___10 = getpid();
    }
    {
#line 535
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending MP3\'s and metadata",
                  tmp___10);
    }
    {
#line 537
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"ICY 200 OK\r\nicy-notice1:This stream is served using Ample/%s\r\nicy-notice2:AMPLE - An MP3 LEnder - http://ample.sf.net/\r\nicy-name:%s\r\nicy-genre:Mixed\r\nicy-url:http://ample.sf.net/\r\nicy-pub:1\r\nicy-metaint:%d\r\nicy-br:128\r\n\r\n",
            "0.5.7", gconf.servername, 16000);
    }
    {
#line 539
    fflush(cconf___0->stream);
    }
    {
#line 540
    playrange(cconf___0, min, max, gconf.order);
    }
    }
  } else
#line 542
  if ((int )cconf___0->mode & 128) {
    {
    {
#line 543
    debug(1, (char *)"Entering INFO mode\n");
    }
    {
#line 544
    tmp___11 = getpid();
    }
    {
#line 544
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending INFO data", tmp___11);
    }
    {
#line 546
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nServer: Ample/%s\r\nAccept-Range: none\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n",
            "0.5.7");
    }
    {
#line 547
    fflush(cconf___0->stream);
    }
    {
#line 548
    createinfohtml(cconf___0);
    }
    }
  } else {
    {
    {
#line 551
    getrange(cconf___0->mp3base, gconf.recursive, & min, & max);
    }
    {
#line 552
    debug(1, (char *)"Entering MP3-Basic mode (range %i - %i)\n", min, max);
    }
    {
#line 554
    tmp___12 = getpid();
    }
    {
#line 554
    sendstatusmsg(cconf___0->statussock, (char *)"%d:Sending MP3\'s", tmp___12);
    }
    }
    {
    {
#line 555
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 555
      cconf___0->mode = (unsigned short )((int )cconf___0->mode | 64);
#line 555
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 556
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nServer: Ample/%s\r\nAccept-Range: none\r\nContent-Type: audio/mpeg\r\nConnection: close\r\n\r\n",
            "0.5.7");
    }
    {
#line 557
    fflush(cconf___0->stream);
    }
    {
#line 558
    playrange(cconf___0, min, max, gconf.order);
    }
    }
  }
  {
  {
#line 561
  fclose(cconf___0->stream);
  }
  {
#line 562
  free((void *)cconf___0);
  }
  {
#line 563
  cleartree(& root);
  }
  }
#line 564
  return (0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 184
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 429 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 487
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) index)(char const   *__s ,
                                                                                    int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 266 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 366 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 289 "/usr/include/netdb.h"
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 8 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.h"
short isbase64(char c ) ;
#line 9
char *b64dec(char *msg ) ;
#line 99 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.h"
void checkopt(int argc , char **argv ) ;
#line 60 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
int volatile   timeout  ;
#line 71 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void addtoarray(char ***arrayptr , char *element ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 76
  if ((unsigned long )*arrayptr == (unsigned long )((void *)0)) {
    {
    {
#line 77
    tmp = malloc((size_t )sizeof(char *));
    }
#line 77
    *arrayptr = (char **)tmp;
    }
#line 78
    if (! *arrayptr) {
      {
      {
#line 79
      die((char *)"malloc()\n");
      }
      }
    }
#line 80
    *(*arrayptr + 0) = (char *)((void *)0);
  }
#line 83
  i = 0;
  {
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned long )*(*arrayptr + i) != (unsigned long )((void *)0))) {
#line 83
      goto while_break;
    }
#line 83
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 85
  tmp___0 = realloc((void *)*arrayptr, (size_t )((unsigned long )(i + 2) * sizeof(char *)));
  }
#line 85
  *arrayptr = (char **)tmp___0;
  }
#line 86
  if (! *arrayptr) {
    {
    {
#line 87
    die((char *)"realloc()\n");
    }
    }
  }
#line 89
  *(*arrayptr + i) = element;
#line 90
  *(*arrayptr + (i + 1)) = (char *)((void *)0);
#line 91
  return;
}
}
#line 105 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static char *decodeurl(char *url ) 
{ 
  char *current ;
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *pos ;
  int hexval ;
  char hexbuf[3] ;
  long tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 108
  current = url;
  {
#line 109
  tmp = strlen((char const   *)url);
  }
  {
#line 109
  tmp___0 = malloc(tmp + 1U);
  }
#line 109
  ret = (char *)tmp___0;
#line 110
  pos = ret;
#line 114
  hexbuf[2] = (char )'\000';
  }
#line 115
  if ((int )*current != 47) {
#line 117
    pos ++;
  }
  {
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((int )*current != 0)) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )*current != 37) {
#line 122
      *pos = *current;
#line 123
      pos ++;
#line 124
      current ++;
    } else {
#line 126
      hexbuf[0] = *(current + 1);
#line 126
      if ((int )hexbuf[0] == 0) {
        {
        {
#line 128
        strncpy((char */* __restrict  */)pos, (char const   */* __restrict  */)current,
                (size_t )3);
        }
#line 129
        pos += 2;
        }
#line 130
        goto while_break;
      } else {
#line 126
        hexbuf[1] = *(current + 2);
#line 126
        if ((int )hexbuf[1] == 0) {
          {
          {
#line 128
          strncpy((char */* __restrict  */)pos, (char const   */* __restrict  */)current,
                  (size_t )3);
          }
#line 129
          pos += 2;
          }
#line 130
          goto while_break;
        } else {
          {
          {
#line 131
          tmp___1 = strtol((char const   */* __restrict  */)(hexbuf), (char **/* __restrict  */)((void *)0),
                           16);
          }
#line 131
          hexval = (int )tmp___1;
          }
#line 131
          if (hexval == 0) {
            {
            {
#line 132
            strncpy((char */* __restrict  */)pos, (char const   */* __restrict  */)current,
                    (size_t )3);
            }
#line 133
            pos += 3;
            }
          } else {
#line 135
            *pos = (char )hexval;
#line 136
            pos ++;
          }
        }
      }
#line 138
      current += 3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  *pos = (char )'\000';
  {
#line 143
  debug(2, (char *)"Decodeurl parses %s as %s\n", url, ret);
  }
  }
#line 144
  return (ret);
}
}
#line 155 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void conntimeout(int signal___0 ) 
{ 


  {
#line 158
  timeout = (int volatile   )1;
#line 159
  return;
}
}
#line 170 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
short readrequest(struct client_config *cconf___0 ) 
{ 
  char line[400] ;
  int start ;
  int end ;
  char *tmp ;
  char *tmp2 ;
  struct sigaction sa ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  long tmp___16 ;
  size_t tmp___17 ;
  unsigned short const   **tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  unsigned short const   **tmp___22 ;
  short tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  unsigned short const   **tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  unsigned short const   **tmp___34 ;
  unsigned short const   **tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;

  {
  {
#line 178
  timeout = (int volatile   )0;
  {
#line 179
  memset((void *)(& sa), 0, (size_t )sizeof(sa));
  }
#line 180
  sa.__sigaction_handler.sa_handler = & conntimeout;
  {
#line 181
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 182
  alarm(60U);
  }
  }
  {
  {
#line 184
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 184
    tmp___45 = fgets((char */* __restrict  */)(line), 400, (FILE */* __restrict  */)cconf___0->stream);
    }
    }
#line 184
    if ((unsigned long )tmp___45 != (unsigned long )((void *)0)) {
#line 184
      if (! (timeout != (int volatile   )1)) {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
    {
    {
#line 186
    tmp___44 = strcmp((char const   *)(line), "\r\n");
    }
    }
#line 186
    if (tmp___44) {
      {
      {
#line 190
      tmp___42 = strlen("GET");
      }
      {
#line 190
      tmp___43 = strncasecmp((char const   *)(line), "GET", tmp___42);
      }
      }
#line 190
      if (tmp___43) {
        {
        {
#line 252
        tmp___40 = strlen("Icy-MetaData:");
        }
        {
#line 252
        tmp___41 = strncasecmp((char const   *)(line), "Icy-MetaData:", tmp___40);
        }
        }
#line 252
        if (tmp___41) {
          {
          {
#line 266
          tmp___38 = strlen("Authorization:");
          }
          {
#line 266
          tmp___39 = strncasecmp((char const   *)(line), "Authorization:", tmp___38);
          }
          }
#line 266
          if (tmp___39) {
            {
            {
#line 308
            tmp___36 = strlen("Range:");
            }
            {
#line 308
            tmp___37 = strncasecmp((char const   *)(line), "Range:", tmp___36);
            }
            }
#line 308
            if (tmp___37) {
              {
              {
#line 359
              debug(3, (char *)"Client sent line %s\n", line);
              }
              }
            } else {
#line 310
              if (! ((int )cconf___0->mode & 4)) {
                {
                {
#line 311
                debug(2, (char *)"Range was requested, but ignored since we aren\'t in single mode\n");
                }
                }
#line 312
                goto while_continue;
              }
              {
              {
#line 314
              debug(3, (char *)"Range request was %s\n", line);
              }
              {
#line 315
              tmp___27 = strlen("Range:");
              }
#line 315
              start = (int )tmp___27;
              }
              {
              {
#line 315
              while (1) {
                while_continue___16: /* CIL Label */ ;
                while_continue___0: /* CIL Label */ ;
                {
                {
#line 315
                tmp___28 = __ctype_b_loc();
                }
                }
#line 315
                if (! ((int const   )*(*tmp___28 + (int )line[start]) & 8192)) {
#line 315
                  goto while_break___0;
                }
#line 315
                start ++;
              }
              while_break___16: /* CIL Label */ ;
              }
              while_break___0: /* CIL Label */ ;
              }
              {
              {
#line 318
              tmp___29 = strlen("bytes");
              }
              {
#line 318
              tmp___30 = strncasecmp((char const   *)(& line[start]), "bytes", tmp___29);
              }
              }
#line 318
              if (tmp___30) {
                {
                {
#line 320
                debug(2, (char *)"Range was requested, but request wasn\'t valid (1)\n");
                }
                }
#line 321
                goto while_continue;
              }
              {
              {
#line 323
              tmp___31 = strlen("bytes");
              }
#line 323
              start = (int )((size_t )start + tmp___31);
              }
              {
              {
#line 325
              while (1) {
                while_continue___17: /* CIL Label */ ;
                while_continue___1: /* CIL Label */ ;
                {
                {
#line 325
                tmp___32 = __ctype_b_loc();
                }
                }
#line 325
                if (! ((int const   )*(*tmp___32 + (int )line[start]) & 8192)) {
#line 325
                  goto while_break___1;
                }
#line 325
                start ++;
              }
              while_break___17: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 326
              if ((int )line[start] != 61) {
                {
                {
#line 327
                debug(2, (char *)"Range was requested, but request wasn\'t valid (2)\n");
                }
                }
#line 328
                goto while_continue;
              }
#line 331
              start ++;
              {
              {
#line 332
              while (1) {
                while_continue___18: /* CIL Label */ ;
                while_continue___2: /* CIL Label */ ;
                {
                {
#line 332
                tmp___33 = __ctype_b_loc();
                }
                }
#line 332
                if (! ((int const   )*(*tmp___33 + (int )line[start]) & 8192)) {
#line 332
                  goto while_break___2;
                }
#line 332
                start ++;
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
              {
#line 334
              tmp___34 = __ctype_b_loc();
              }
              }
#line 334
              if ((int const   )*(*tmp___34 + (int )line[start]) & 2048) {
                {
                {
#line 335
                cconf___0->startpos = strtol((char const   */* __restrict  */)(& line[start]),
                                             (char **/* __restrict  */)(& tmp), 10);
                }
                }
              } else
#line 336
              if ((int )line[start] == 45) {
#line 337
                cconf___0->startpos = 0L;
#line 338
                tmp = & line[start];
              } else {
                {
                {
#line 340
                debug(2, (char *)"Range was requested, but request wasn\'t valid (3)\n");
                }
                }
#line 341
                goto while_continue;
              }
#line 344
              if ((int )*tmp != 45) {
                {
                {
#line 345
                debug(2, (char *)"Range was requested, but request wasn\'t valid (4)\n");
                }
                }
#line 346
                goto while_continue;
              } else {
#line 348
                tmp ++;
              }
              {
              {
#line 351
              tmp___35 = __ctype_b_loc();
              }
              }
#line 351
              if ((int const   )*(*tmp___35 + (int )*tmp) & 2048) {
                {
                {
#line 352
                cconf___0->endpos = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                                           10);
                }
                }
              } else {
#line 354
                cconf___0->endpos = 0L;
              }
              {
              {
#line 356
              while (1) {
                while_continue___19: /* CIL Label */ ;
                while_continue___3: /* CIL Label */ ;
#line 356
                cconf___0->mode = (unsigned short )((int )cconf___0->mode | 32);
#line 356
                goto while_break___3;
              }
              while_break___19: /* CIL Label */ ;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          } else {
            {
            {
#line 268
            tmp___17 = strlen("Authorization:");
            }
#line 268
            start = (int )tmp___17;
            }
            {
            {
#line 269
            while (1) {
              while_continue___20: /* CIL Label */ ;
              while_continue___4: /* CIL Label */ ;
              {
              {
#line 269
              tmp___18 = __ctype_b_loc();
              }
              }
#line 269
              if (! ((int const   )*(*tmp___18 + (int )line[start]) & 8192)) {
#line 269
                goto while_break___4;
              }
#line 270
              start ++;
            }
            while_break___20: /* CIL Label */ ;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 272
            if ((int )line[start] == 0) {
              {
              {
#line 273
              debug(2, (char *)"Authorization was requested, but request wasn\'t valid\n");
              }
              }
#line 274
              goto while_continue;
            } else {
              {
              {
#line 272
              tmp___19 = strlen("Basic");
              }
              {
#line 272
              tmp___20 = strncasecmp((char const   *)(& line[start]), "Basic", tmp___19);
              }
              }
#line 272
              if (tmp___20) {
                {
                {
#line 273
                debug(2, (char *)"Authorization was requested, but request wasn\'t valid\n");
                }
                }
#line 274
                goto while_continue;
              }
            }
            {
            {
#line 277
            tmp___21 = strlen("Basic");
            }
#line 277
            start = (int )((size_t )start + tmp___21);
            }
            {
            {
#line 279
            while (1) {
              while_continue___21: /* CIL Label */ ;
              while_continue___5: /* CIL Label */ ;
              {
              {
#line 279
              tmp___22 = __ctype_b_loc();
              }
              }
#line 279
              if (! ((int const   )*(*tmp___22 + (int )line[start]) & 8192)) {
#line 279
                goto while_break___5;
              }
#line 280
              start ++;
            }
            while_break___21: /* CIL Label */ ;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 282
            tmp = & line[start];
            {
            {
#line 283
            while (1) {
              while_continue___22: /* CIL Label */ ;
              while_continue___6: /* CIL Label */ ;
              {
              {
#line 283
              tmp___23 = isbase64(*tmp);
              }
              }
#line 283
              if (! tmp___23) {
#line 283
                goto while_break___6;
              }
#line 284
              tmp ++;
            }
            while_break___22: /* CIL Label */ ;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 286
            *tmp = (char )'\000';
            {
#line 287
            tmp2 = b64dec(& line[start]);
            }
            }
#line 288
            if ((unsigned long )tmp2 == (unsigned long )((void *)0)) {
#line 288
              goto _L___2;
            } else {
              {
              {
#line 288
              tmp___24 = strlen((char const   *)tmp2);
              }
              }
#line 288
              if (tmp___24 < 1U) {
#line 288
                goto _L___2;
              } else {
                {
                {
#line 288
                tmp___25 = index((char const   *)tmp2, ':');
                }
                }
#line 288
                if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
                  _L___2: /* CIL Label */ 
                  {
                  {
#line 289
                  debug(2, (char *)"Authorization was requested, but request wasn\'t valid\n");
                  }
                  }
#line 290
                  if ((unsigned long )tmp2 != (unsigned long )((void *)0)) {
                    {
                    {
#line 291
                    free((void *)tmp2);
                    }
                    }
                  }
#line 292
                  goto while_continue;
                }
              }
            }
            {
            {
#line 295
            tmp = index((char const   *)tmp2, ':');
            }
#line 296
            *tmp = (char )'\000';
#line 297
            tmp ++;
            }
#line 298
            if ((unsigned long )tmp == (unsigned long )((char *)0)) {
              {
              {
#line 299
              debug(2, (char *)"Authorization was requested, but request wasn\'t valid\n");
              }
              {
#line 300
              free((void *)tmp2);
              }
              }
#line 301
              goto while_continue;
            } else {
              {
              {
#line 298
              tmp___26 = strlen((char const   *)tmp);
              }
              }
#line 298
              if (tmp___26 < 1U) {
                {
                {
#line 299
                debug(2, (char *)"Authorization was requested, but request wasn\'t valid\n");
                }
                {
#line 300
                free((void *)tmp2);
                }
                }
#line 301
                goto while_continue;
              }
            }
            {
            {
#line 304
            cconf___0->username = strdup((char const   *)tmp2);
            }
            {
#line 305
            cconf___0->password = strdup((char const   *)tmp);
            }
            {
#line 306
            free((void *)tmp2);
            }
            }
          }
        } else {
          {
          {
#line 255
          tmp___15 = strlen("Icy-MetaData:");
          }
#line 255
          start = (int )tmp___15;
          }
#line 256
          if ((int )line[start] == 0) {
            {
            {
#line 258
            debug(2, (char *)"Metadata was requested, but request wasn\'t valid\n");
            }
            }
          } else {
            {
            {
#line 256
            tmp___16 = strtol((char const   */* __restrict  */)(& line[start]), (char **/* __restrict  */)((void *)0),
                              10);
            }
            }
#line 256
            if (tmp___16 > 0L) {
#line 259
              if ((int )cconf___0->mode & 4) {
                {
                {
#line 260
                debug(2, (char *)"Metadata was requested, but ignored since we are in single mode\n");
                }
                }
              } else {
                {
                {
#line 262
                while (1) {
                  while_continue___23: /* CIL Label */ ;
                  while_continue___7: /* CIL Label */ ;
#line 262
                  cconf___0->mode = (unsigned short )((int )cconf___0->mode | 2);
#line 262
                  goto while_break___7;
                }
                while_break___23: /* CIL Label */ ;
                }
                while_break___7: /* CIL Label */ ;
                }
                {
                {
#line 263
                debug(2, (char *)"Metadata was requested\n");
                }
                }
              }
            } else {
              {
              {
#line 258
              debug(2, (char *)"Metadata was requested, but request wasn\'t valid\n");
              }
              }
            }
          }
        }
      } else {
        {
        {
#line 192
        debug(3, (char *)"GET request was %s\n", line);
        }
        {
#line 193
        tmp___0 = strlen((char const   *)(line));
        }
        }
#line 193
        if (tmp___0 < 14U) {
#line 194
          goto while_continue;
        }
        {
        {
#line 197
        tmp___1 = strchr((char const   *)(line), ' ');
        }
        }
#line 197
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 199
          goto while_continue;
        } else {
          {
          {
#line 197
          tmp___2 = strchr((char const   *)(line), ' ');
          }
          {
#line 197
          tmp___3 = strrchr((char const   *)(line), ' ');
          }
          }
#line 197
          if ((unsigned long )tmp___2 == (unsigned long )tmp___3) {
#line 199
            goto while_continue;
          }
        }
        {
        {
#line 205
        tmp___4 = strlen("GET");
        }
#line 205
        start = (int )tmp___4;
        }
        {
        {
#line 205
        while (1) {
          while_continue___24: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
          {
          {
#line 205
          tmp___5 = __ctype_b_loc();
          }
          }
#line 205
          if (! ((int const   )*(*tmp___5 + (int )line[start]) & 8192)) {
#line 205
            goto while_break___8;
          }
#line 205
          start ++;
        }
        while_break___24: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
        {
#line 207
        tmp___6 = strrchr((char const   *)(line), ' ');
        }
#line 207
        end = (int )(tmp___6 - line);
        }
        {
        {
#line 207
        while (1) {
          while_continue___25: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
          {
          {
#line 207
          tmp___7 = __ctype_b_loc();
          }
          }
#line 207
          if ((int const   )*(*tmp___7 + (int )line[end]) & 8192) {
#line 207
            goto while_break___9;
          }
#line 207
          end --;
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 209
        line[end] = (char )'\000';
        {
#line 212
        cconf___0->requestpath = decodeurl(& line[start]);
        }
        {
#line 215
        tmp = strrchr((char const   *)cconf___0->requestpath, 'i');
        }
        }
#line 215
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
          {
#line 215
          tmp___8 = strcasecmp((char const   *)tmp, "index.html");
          }
          }
#line 215
          if (tmp___8) {
            {
            {
#line 215
            tmp___9 = strcasecmp((char const   *)tmp, "index.htm");
            }
            }
#line 215
            if (! tmp___9) {
              _L: /* CIL Label */ 
              {
              {
#line 218
              while (1) {
                while_continue___26: /* CIL Label */ ;
                while_continue___10: /* CIL Label */ ;
#line 218
                cconf___0->mode = (unsigned short )((int )cconf___0->mode | 1);
#line 218
                goto while_break___10;
              }
              while_break___26: /* CIL Label */ ;
              }
              while_break___10: /* CIL Label */ ;
              }
#line 219
              *tmp = (char )'\000';
            }
          } else {
#line 215
            goto _L;
          }
        }
        {
        {
#line 223
        tmp = strrchr((char const   *)cconf___0->requestpath, 'i');
        }
        }
#line 223
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
          {
#line 223
          tmp___10 = strcasecmp((char const   *)tmp, "info.html");
          }
          }
#line 223
          if (tmp___10) {
            {
            {
#line 223
            tmp___11 = strcasecmp((char const   *)tmp, "info.htm");
            }
            }
#line 223
            if (! tmp___11) {
              _L___0: /* CIL Label */ 
              {
              {
#line 226
              while (1) {
                while_continue___27: /* CIL Label */ ;
                while_continue___11: /* CIL Label */ ;
#line 226
                cconf___0->mode = (unsigned short )((int )cconf___0->mode | 128);
#line 226
                goto while_break___11;
              }
              while_break___27: /* CIL Label */ ;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 227
              *tmp = (char )'\000';
            }
          } else {
#line 223
            goto _L___0;
          }
        }
        {
        {
#line 231
        tmp = strrchr((char const   *)cconf___0->requestpath, 'i');
        }
        }
#line 231
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          {
          {
#line 231
          tmp___13 = strcasecmp((char const   *)tmp, "index.m3u");
          }
          }
#line 231
          if (! tmp___13) {
            {
#line 233
            *tmp = (char )'\000';
#line 234
            tmp --;
            {
#line 235
            tmp___12 = strlen((char const   *)cconf___0->requestpath);
            }
            }
#line 235
            if (tmp___12 > 1U) {
#line 235
              if ((int )*tmp == 114) {
                {
                {
#line 237
                while (1) {
                  while_continue___28: /* CIL Label */ ;
                  while_continue___12: /* CIL Label */ ;
#line 237
                  cconf___0->mode = (unsigned short )((int )cconf___0->mode | 16);
#line 237
                  goto while_break___12;
                }
                while_break___28: /* CIL Label */ ;
                }
                while_break___12: /* CIL Label */ ;
                }
#line 238
                gconf.recursive = (short)1;
#line 239
                *tmp = (char )'\000';
              } else {
#line 235
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
              {
#line 241
              while (1) {
                while_continue___29: /* CIL Label */ ;
                while_continue___13: /* CIL Label */ ;
#line 241
                cconf___0->mode = (unsigned short )((int )cconf___0->mode | 8);
#line 241
                goto while_break___13;
              }
              while_break___29: /* CIL Label */ ;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
        }
        {
        {
#line 246
        tmp = strrchr((char const   *)cconf___0->requestpath, '.');
        }
        }
#line 246
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 247
          goto while_continue;
        }
        {
        {
#line 248
        tmp___14 = strcasecmp((char const   *)tmp, ".mp3");
        }
        }
#line 248
        if (! tmp___14) {
          {
          {
#line 249
          while (1) {
            while_continue___30: /* CIL Label */ ;
            while_continue___14: /* CIL Label */ ;
#line 249
            cconf___0->mode = (unsigned short )((int )cconf___0->mode | 4);
#line 249
            goto while_break___14;
          }
          while_break___30: /* CIL Label */ ;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
      }
    } else {
#line 188
      goto while_break;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  {
#line 364
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  }
#line 366
  if (timeout) {
    {
    {
#line 367
    logmsg((char *)"Connection timed out\n");
    }
    }
#line 368
    return ((short)0);
  } else {
    {
    {
#line 370
    alarm(0U);
    }
    }
  }
  {
  {
#line 374
  tmp___47 = strlen((char const   *)cconf___0->requestpath);
  }
  }
#line 374
  if (tmp___47 > 1U) {
    {
#line 375
    tmp = cconf___0->requestpath;
    {
#line 376
    tmp___46 = strlen((char const   *)cconf___0->requestpath);
    }
#line 376
    tmp += tmp___46;
#line 377
    tmp --;
    }
#line 378
    if ((int )*tmp == 47) {
#line 379
      *tmp = (char )'\000';
    }
  }
#line 382
  return ((short)1);
}
}
#line 396 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void preparehtml(void) 
{ 
  char line[400] ;
  FILE *file ;
  int i ;
  char *tmp ;
  int tmpsize ;
  int tmpwritten ;
  struct confoption delimiters[4] ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 403
  tmpsize = 800;
#line 404
  tmpwritten = 0;
#line 406
  delimiters[0].name = (char *)"@BEGIN@";
#line 406
  delimiters[0].type = (unsigned short)0;
#line 406
  delimiters[0].value = (void *)(& gconf.htmlheader);
#line 406
  delimiters[1].name = (char *)"@END@";
#line 406
  delimiters[1].type = (unsigned short)0;
#line 406
  delimiters[1].value = (void *)(& gconf.htmlmiddle);
#line 406
  delimiters[2].name = (char *)((void *)0);
#line 406
  delimiters[2].type = (unsigned short)0;
#line 406
  delimiters[2].value = (void *)(& gconf.htmlfooter);
#line 406
  delimiters[3].name = (char *)((void *)0);
#line 406
  delimiters[3].type = (unsigned short)0;
#line 406
  delimiters[3].value = (void *)0;
  {
#line 413
  file = fopen((char const   */* __restrict  */)gconf.htmlfile, (char const   */* __restrict  */)"r");
  }
  }
#line 413
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
    {
#line 414
    debug(2, (char *)"Using %s as configfile\n", gconf.htmlfile);
    }
    }
  } else {
    {
    {
#line 416
    debug(2, (char *)"No HTML template found\n");
    }
    {
#line 417
    gconf.htmlheader = strdup("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head>\n<title>@SERVERNAME@</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n</head><body><center>\n<p><h1>@SERVERNAME@</h1></p>\n<p><h2>Tracks currently available in @PATH@</h2></p>\n<p>&nbsp;</p><p><font size=\"-1\">[ <a href=\"index.m3u\">playlist for this dir</a> | <a href=\"rindex.m3u\">recursive playlist</a> ]</font></p>\n<p><font size=\"-1\">[ <a href=\"../index.html\">Up one level</a> ]</font></p>\n<div align=\"center\"><table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#000000\">\n<tr>\n<td><b>TYPE</b></td><td><b>URL</b></td></tr>\n");
    }
    {
#line 418
    gconf.htmlmiddle = strdup("<tr><td>@TYPE@</td><td><a href=\"@URL@\">@NAME@</a></td></tr>\n");
    }
    {
#line 419
    gconf.htmlfooter = strdup("</table></div>\n<p align=\"right\"><font size=\"-1\">powered by Ample, for more information, see the\n<a href=\"http://ample.sourceforge.net\">project homepage</a></font></p>\n</center></body></html>\r\n");
    }
    }
#line 420
    return;
  }
#line 423
  i = 0;
  {
  {
#line 423
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 423
    if (! ((unsigned long )delimiters[i].value != (unsigned long )((void *)0))) {
#line 423
      goto while_break;
    }
    {
    {
#line 425
    tmp___0 = malloc((size_t )tmpsize);
    }
#line 425
    tmp = (char *)tmp___0;
#line 426
    *tmp = (char )'\000';
    }
    {
    {
#line 428
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 428
      tmp___4 = fgets((char */* __restrict  */)(line), 400, (FILE */* __restrict  */)file);
      }
      }
#line 428
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 428
        goto while_break___0;
      }
      {
      {
#line 429
      debug(9, (char *)"Template line is %s\n", line);
      }
      }
#line 430
      if (delimiters[i].name) {
        {
        {
#line 430
        tmp___1 = strlen((char const   *)delimiters[i].name);
        }
        {
#line 430
        tmp___2 = strncmp((char const   *)(line), (char const   *)delimiters[i].name,
                          tmp___1);
        }
        }
#line 430
        if (! tmp___2) {
#line 433
          goto while_break___0;
        }
      }
      {
      {
#line 434
      tmp___3 = strlen((char const   *)(line));
      }
#line 434
      tmpwritten = (int )((size_t )tmpwritten + tmp___3);
      {
#line 435
      strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)(line));
      }
      }
#line 436
      if (tmpsize - tmpwritten < 400) {
        {
#line 437
        tmpsize += 400;
        {
#line 438
        realloc((void *)tmp, (size_t )tmpsize);
        }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 442
    tmp___5 = strlen((char const   *)tmp);
    }
    {
#line 442
    realloc((void *)tmp, tmp___5 + 1U);
    }
#line 443
    *((char **)delimiters[i].value) = tmp;
#line 423
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 456 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void usage(short error ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 459
  if (error) {
    {
    {
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
            gconf.program_name);
    }
    {
#line 462
    exit(1);
    }
    }
  } else {
    {
    {
#line 465
    printf((char const   */* __restrict  */)"Usage: %s [OPTION(S)]... [PATH]\n\nAMPLE - An MP3 LEnder\nrecursively indexes all MP3 files it finds below PATH and then listens\nto a TCP port for incoming connections. Once a connection is made AMPLE will\nstart sending randomly chosen MP3\'s. If called from the command line or a\nscript AMPLE will go into daemon mode (unlike when called from inetd or with\nthe option -t).\n\n",
           gconf.program_name);
    }
    {
#line 466
    printf((char const   */* __restrict  */)"  -p, --port=NUMBER           which port to listen to, default %d\n  -o, --order                 play MP3 files in alphabetical order\n  -c, --clients=NUMBER        how many clients are allowed to be connected\n                              default %d\n  -n, --norecursive           don\'t index MP3 files in subdirs of the given dir\n  -f, --conffile=FILENAME     alternative file to read for config options\n  -m, --htmlfile=FILENAME     file to use as template for HTML output\n  -h, --help                  display this help and exit\n  -d, --debug[=NUMBER]        debug messages will be printed\n                              higher number means more detail\n  -t, --trace                 no forking, no backgrounding\n                              helpful when debugging\n  -v, --version               output version information and exit\n\nReport bugs to <david@2gen.com>\n",
           1234, 5);
    }
    {
#line 467
    exit(0);
    }
    }
  }
}
}
#line 481 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void setdefopt(int argc , char **argv ) 
{ 
  struct servent *servent ;
  struct servent *tmp ;
  uint16_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 484
  if (gconf.port == 0) {
    {
    {
#line 486
    tmp = getservbyname("ample", "tcp");
    }
#line 486
    servent = tmp;
    }
#line 487
    if (servent) {
      {
      {
#line 487
      tmp___0 = ntohs((uint16_t )servent->s_port);
      }
#line 487
      gconf.port = (int )tmp___0;
      }
    } else {
#line 487
      gconf.port = 1234;
    }
  }
#line 493
  if (gconf.port >= 65536) {
    {
    {
#line 494
    die((char *)"port number out of range\n");
    }
    }
  }
#line 495
  if ((int )gconf.order == -1) {
#line 496
    gconf.order = (short)0;
  }
#line 497
  if (gconf.max_clients == 0) {
#line 498
    gconf.max_clients = 5;
  }
#line 499
  if ((int )gconf.recursive == -1) {
#line 500
    gconf.recursive = (short)1;
  }
#line 501
  if ((unsigned long )gconf.pathlist == (unsigned long )((void *)0)) {
    {
    {
#line 502
    tmp___1 = strdup("/usr/local/share/mp3");
    }
    {
#line 502
    addtoarray(& gconf.pathlist, tmp___1);
    }
    }
  }
#line 503
  if ((unsigned long )gconf.logfile == (unsigned long )((void *)0)) {
    {
    {
#line 504
    gconf.logfile = strdup("/usr/local/var/log/ample.conf");
    }
    }
  }
#line 505
  if ((unsigned long )gconf.servername == (unsigned long )((void *)0)) {
    {
    {
#line 506
    gconf.servername = strdup("Ample");
    }
    }
  }
#line 507
  if ((unsigned long )gconf.serveraddress == (unsigned long )((void *)0)) {
    {
    {
#line 507
    gconf.serveraddress = getservername();
    }
    }
#line 507
    if (! gconf.serveraddress) {
      {
      {
#line 509
      gconf.serveraddress = strdup("127.0.0.1");
      }
      }
    }
  }
#line 510
  if ((unsigned long )gconf.htmlfile == (unsigned long )((void *)0)) {
    {
    {
#line 511
    gconf.htmlfile = strdup("/usr/local/etc/ample.html");
    }
    }
  }
#line 512
  return;
}
}
#line 524 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void parseconfopt(char *tmp , void *value , int type ) 
{ 
  int i ;
  float f ;
  char *end ;
  char *retval ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  unsigned short const   **tmp___13 ;
  void *tmp___14 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 532
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 532
    tmp___0 = __ctype_b_loc();
    }
    }
#line 532
    if (! ((int const   )*(*tmp___0 + (int )*tmp) & 8192)) {
#line 532
      goto while_break;
    }
#line 533
    tmp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if ((int )*tmp != 61) {
#line 536
    return;
  } else {
#line 538
    tmp ++;
  }
  {
  {
#line 540
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 540
    tmp___1 = __ctype_b_loc();
    }
    }
#line 540
    if (! ((int const   )*(*tmp___1 + (int )*tmp) & 8192)) {
#line 540
      goto while_break___0;
    }
#line 541
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 544
  if (type == 2) {
#line 544
    goto case_2;
  }
#line 548
  if (type == 5) {
#line 548
    goto case_5;
  }
#line 552
  if (type == 1) {
#line 552
    goto case_1;
  }
#line 560
  if (type == 3) {
#line 560
    goto case_3;
  }
#line 574
  if (type == 4) {
#line 574
    goto case_4;
  }
#line 588
  goto switch_default;
  case_2: /* CIL Label */ 
  {
  {
#line 545
  tmp___2 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                   10);
  }
#line 545
  i = (int )tmp___2;
  }
#line 545
  if (i > 0) {
#line 546
    *((int *)value) = i;
  }
#line 547
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 549
  tmp___3 = strtod((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0));
  }
#line 549
  f = (float )tmp___3;
  }
#line 549
  if (f > (float )0) {
#line 550
    *((float *)value) = f;
  }
#line 551
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 553
  tmp___8 = strlen("yes");
  }
  {
#line 553
  tmp___9 = strncasecmp("yes", (char const   *)tmp, tmp___8);
  }
  }
#line 553
  if (tmp___9) {
    {
    {
#line 553
    tmp___10 = strlen("true");
    }
    {
#line 553
    tmp___11 = strncasecmp("true", (char const   *)tmp, tmp___10);
    }
    }
#line 553
    if (tmp___11) {
      {
      {
#line 556
      tmp___4 = strlen("no");
      }
      {
#line 556
      tmp___5 = strncasecmp("no", (char const   *)tmp, tmp___4);
      }
      }
#line 556
      if (tmp___5) {
        {
        {
#line 556
        tmp___6 = strlen("false");
        }
        {
#line 556
        tmp___7 = strncasecmp("false", (char const   *)tmp, tmp___6);
        }
        }
#line 556
        if (! tmp___7) {
#line 558
          *((short *)value) = (short)0;
        }
      } else {
#line 558
        *((short *)value) = (short)0;
      }
    } else {
#line 555
      *((short *)value) = (short)1;
    }
  } else {
#line 555
    *((short *)value) = (short)1;
  }
#line 559
  goto switch_break;
  case_3: /* CIL Label */ 
#line 561
  end = tmp;
  {
  {
#line 562
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 562
    if ((int )*end != 10) {
#line 562
      if ((int )*end != 0) {
#line 562
        if (! ((int )*end != 35)) {
#line 562
          goto while_break___1;
        }
      } else {
#line 562
        goto while_break___1;
      }
    } else {
#line 562
      goto while_break___1;
    }
#line 564
    end ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 565
  if ((unsigned long )end == (unsigned long )tmp) {
#line 566
    goto switch_break;
  }
  {
  {
#line 567
  tmp___12 = malloc((size_t )((end - tmp) + 1L));
  }
#line 567
  retval = (char *)tmp___12;
  }
#line 568
  if (! retval) {
    {
    {
#line 569
    die((char *)"malloc");
    }
    }
  }
  {
  {
#line 570
  snprintf((char */* __restrict  */)retval, (size_t )((end - tmp) + 1L), (char const   */* __restrict  */)"%.*s",
           end - tmp, tmp);
  }
#line 572
  *((char **)value) = retval;
  }
#line 573
  goto switch_break;
  case_4: /* CIL Label */ 
#line 575
  end = tmp;
  {
  {
#line 576
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 576
    if ((int )*end != 10) {
#line 576
      if ((int )*end != 0) {
#line 576
        if ((int )*end != 35) {
          {
          {
#line 576
          tmp___13 = __ctype_b_loc();
          }
          }
#line 576
          if ((int const   )*(*tmp___13 + (int )*end) & 8192) {
#line 576
            goto while_break___2;
          }
        } else {
#line 576
          goto while_break___2;
        }
      } else {
#line 576
        goto while_break___2;
      }
    } else {
#line 576
      goto while_break___2;
    }
#line 578
    end ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 579
  if ((unsigned long )end == (unsigned long )tmp) {
#line 580
    goto switch_break;
  }
  {
  {
#line 581
  tmp___14 = malloc((size_t )((end - tmp) + 1L));
  }
#line 581
  retval = (char *)tmp___14;
  }
#line 582
  if (! retval) {
    {
    {
#line 583
    die((char *)"malloc");
    }
    }
  }
  {
  {
#line 584
  snprintf((char */* __restrict  */)retval, (size_t )((end - tmp) + 1L), (char const   */* __restrict  */)"%.*s",
           end - tmp, tmp);
  }
  {
#line 586
  addtoarray((char ***)value, retval);
  }
  }
#line 587
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 590
  debug(2, (char *)"Incorrect type passed to parseconfopt()\n");
  }
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 593
  return;
}
}
#line 605 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void setconfopt(int argc , char **argv ) 
{ 
  char line[400] ;
  FILE *file ;
  int i ;
  int j ;
  struct confoption options[13] ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 611
  options[0].name = (char *)"clients";
#line 611
  options[0].type = (unsigned short)2;
#line 611
  options[0].value = (void *)(& gconf.max_clients);
#line 611
  options[1].name = (char *)"filter";
#line 611
  options[1].type = (unsigned short)3;
#line 611
  options[1].value = (void *)(& gconf.filter);
#line 611
  options[2].name = (char *)"htmlfile";
#line 611
  options[2].type = (unsigned short)3;
#line 611
  options[2].value = (void *)(& gconf.htmlfile);
#line 611
  options[3].name = (char *)"logfile";
#line 611
  options[3].type = (unsigned short)3;
#line 611
  options[3].value = (void *)(& gconf.logfile);
#line 611
  options[4].name = (char *)"mp3path";
#line 611
  options[4].type = (unsigned short)4;
#line 611
  options[4].value = (void *)(& gconf.pathlist);
#line 611
  options[5].name = (char *)"order";
#line 611
  options[5].type = (unsigned short)1;
#line 611
  options[5].value = (void *)(& gconf.order);
#line 611
  options[6].name = (char *)"password";
#line 611
  options[6].type = (unsigned short)3;
#line 611
  options[6].value = (void *)(& gconf.password);
#line 611
  options[7].name = (char *)"port";
#line 611
  options[7].type = (unsigned short)2;
#line 611
  options[7].value = (void *)(& gconf.port);
#line 611
  options[8].name = (char *)"recursive";
#line 611
  options[8].type = (unsigned short)1;
#line 611
  options[8].value = (void *)(& gconf.recursive);
#line 611
  options[9].name = (char *)"servername";
#line 611
  options[9].type = (unsigned short)3;
#line 611
  options[9].value = (void *)(& gconf.servername);
#line 611
  options[10].name = (char *)"serveraddress";
#line 611
  options[10].type = (unsigned short)3;
#line 611
  options[10].value = (void *)(& gconf.serveraddress);
#line 611
  options[11].name = (char *)"username";
#line 611
  options[11].type = (unsigned short)3;
#line 611
  options[11].value = (void *)(& gconf.username);
#line 611
  options[12].name = (char *)((void *)0);
#line 611
  options[12].type = (unsigned short)0;
#line 611
  options[12].value = (void *)0;
#line 627
  if ((unsigned long )gconf.conffile == (unsigned long )((void *)0)) {
    {
    {
#line 628
    file = fopen((char const   */* __restrict  */)"/usr/local/etc/ample.conf", (char const   */* __restrict  */)"r");
    }
    }
  } else {
    {
    {
#line 630
    file = fopen((char const   */* __restrict  */)gconf.conffile, (char const   */* __restrict  */)"r");
    }
    }
  }
#line 632
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 633
    return;
  }
  {
  {
#line 635
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 635
    tmp___3 = fgets((char */* __restrict  */)(line), 400, (FILE */* __restrict  */)file);
    }
    }
#line 635
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 635
      goto while_break;
    }
#line 636
    if ((int )line[0] == 35) {
#line 637
      goto while_continue;
    }
#line 639
    i = 0;
    {
    {
#line 639
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 639
      tmp = __ctype_b_loc();
      }
      }
#line 639
      if (! ((int const   )*(*tmp + (int )line[i]) & 8192)) {
#line 639
        goto while_break___0;
      }
#line 639
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 641
    j = 0;
    {
    {
#line 641
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 641
      if (! ((unsigned long )options[j].name != (unsigned long )((void *)0))) {
#line 641
        goto while_break___1;
      }
      {
      {
#line 642
      tmp___1 = strlen((char const   *)options[j].name);
      }
      {
#line 642
      tmp___2 = strncasecmp((char const   *)(& line[i]), (char const   *)options[j].name,
                            tmp___1);
      }
      }
#line 642
      if (! tmp___2) {
        {
        {
#line 643
        tmp___0 = strlen((char const   *)options[j].name);
        }
#line 643
        i = (int )((size_t )i + tmp___0);
        {
#line 644
        parseconfopt(& line[i], options[j].value, (int )options[j].type);
        }
        }
#line 645
        goto while_break___1;
      }
#line 641
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return;
}
}
#line 660 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void setcmdopt(int argc , char **argv ) 
{ 
  int c ;
  int i ;
  struct option longopts[11] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 666
  longopts[0].name = "port";
#line 666
  longopts[0].has_arg = 1;
#line 666
  longopts[0].flag = (int *)((void *)0);
#line 666
  longopts[0].val = 'p';
#line 666
  longopts[1].name = "order";
#line 666
  longopts[1].has_arg = 0;
#line 666
  longopts[1].flag = (int *)((void *)0);
#line 666
  longopts[1].val = 'o';
#line 666
  longopts[2].name = "clients";
#line 666
  longopts[2].has_arg = 1;
#line 666
  longopts[2].flag = (int *)((void *)0);
#line 666
  longopts[2].val = 'c';
#line 666
  longopts[3].name = "norecursive";
#line 666
  longopts[3].has_arg = 0;
#line 666
  longopts[3].flag = (int *)((void *)0);
#line 666
  longopts[3].val = 'n';
#line 666
  longopts[4].name = "conffile";
#line 666
  longopts[4].has_arg = 1;
#line 666
  longopts[4].flag = (int *)((void *)0);
#line 666
  longopts[4].val = 'f';
#line 666
  longopts[5].name = "htmlfile";
#line 666
  longopts[5].has_arg = 1;
#line 666
  longopts[5].flag = (int *)((void *)0);
#line 666
  longopts[5].val = 'm';
#line 666
  longopts[6].name = "help";
#line 666
  longopts[6].has_arg = 0;
#line 666
  longopts[6].flag = (int *)((void *)0);
#line 666
  longopts[6].val = 'h';
#line 666
  longopts[7].name = "debug";
#line 666
  longopts[7].has_arg = 2;
#line 666
  longopts[7].flag = (int *)((void *)0);
#line 666
  longopts[7].val = 'd';
#line 666
  longopts[8].name = "trace";
#line 666
  longopts[8].has_arg = 0;
#line 666
  longopts[8].flag = (int *)((void *)0);
#line 666
  longopts[8].val = 't';
#line 666
  longopts[9].name = "version";
#line 666
  longopts[9].has_arg = 0;
#line 666
  longopts[9].flag = (int *)((void *)0);
#line 666
  longopts[9].val = 'v';
#line 666
  longopts[10].name = (char const   *)((void *)0);
#line 666
  longopts[10].has_arg = 0;
#line 666
  longopts[10].flag = (int *)((void *)0);
#line 666
  longopts[10].val = 0;
  {
  {
#line 680
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 680
    c = getopt_long(argc, (char * const  *)argv, "p:oc:nf:m:hd::tv", (struct option  const  *)(longopts),
                    & i);
    }
    }
#line 680
    if (! (c != -1)) {
#line 680
      goto while_break;
    }
    {
#line 686
    if (c == 112) {
#line 686
      goto case_112;
    }
#line 690
    if (c == 111) {
#line 690
      goto case_111;
    }
#line 693
    if (c == 99) {
#line 693
      goto case_99;
    }
#line 697
    if (c == 110) {
#line 697
      goto case_110;
    }
#line 700
    if (c == 102) {
#line 700
      goto case_102;
    }
#line 703
    if (c == 109) {
#line 703
      goto case_109;
    }
#line 706
    if (c == 104) {
#line 706
      goto case_104;
    }
#line 709
    if (c == 100) {
#line 709
      goto case_100;
    }
#line 715
    if (c == 116) {
#line 715
      goto case_116;
    }
#line 718
    if (c == 118) {
#line 718
      goto case_118;
    }
#line 721
    goto switch_default;
    case_112: /* CIL Label */ 
    {
    {
#line 687
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
    }
    }
#line 687
    if (tmp___0 > 0L) {
      {
      {
#line 688
      tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                   10);
      }
#line 688
      gconf.port = (int )tmp;
      }
    }
#line 689
    goto switch_break;
    case_111: /* CIL Label */ 
#line 691
    gconf.order = (short)1;
#line 692
    goto switch_break;
    case_99: /* CIL Label */ 
    {
    {
#line 694
    tmp___2 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
    }
    }
#line 694
    if (tmp___2 > 0L) {
      {
      {
#line 695
      tmp___1 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       10);
      }
#line 695
      gconf.max_clients = (int )tmp___1;
      }
    }
#line 696
    goto switch_break;
    case_110: /* CIL Label */ 
#line 698
    gconf.recursive = (short)0;
#line 699
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 701
    gconf.conffile = strdup((char const   *)optarg);
    }
    }
#line 702
    goto switch_break;
    case_109: /* CIL Label */ 
    {
    {
#line 704
    gconf.htmlfile = strdup((char const   *)optarg);
    }
    }
#line 705
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 707
    usage((short)0);
    }
    }
#line 708
    goto switch_break;
    case_100: /* CIL Label */ 
#line 710
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 711
      gconf.debuglevel = 1;
    } else {
      {
      {
#line 710
      tmp___4 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       10);
      }
      }
#line 710
      if (tmp___4 < 0L) {
#line 711
        gconf.debuglevel = 1;
      } else {
        {
        {
#line 713
        tmp___3 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                         10);
        }
#line 713
        gconf.debuglevel = (int )tmp___3;
        }
      }
    }
#line 714
    goto switch_break;
    case_116: /* CIL Label */ 
#line 716
    gconf.trace = (short)1;
#line 717
    goto switch_break;
    case_118: /* CIL Label */ 
    {
    {
#line 719
    printf((char const   */* __restrict  */)"Ample version %s\n", "0.5.7");
    }
    {
#line 720
    exit(0);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 722
    usage((short)1);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  i = optind;
  {
  {
#line 727
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 727
    if (! (i < argc)) {
#line 727
      goto while_break___0;
    }
    {
    {
#line 728
    tmp___5 = strdup((char const   *)*(argv + i));
    }
    {
#line 728
    addtoarray(& gconf.pathlist, tmp___5);
    }
#line 729
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 731
  return;
}
}
#line 744 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
void checkopt(int argc , char **argv ) 
{ 


  {
  {
  {
#line 747
  memset((void *)(& gconf), 0, (size_t )sizeof(struct global_config ));
  }
#line 748
  gconf.order = (short)-1;
#line 749
  gconf.recursive = (short)-1;
#line 750
  gconf.program_name = *(argv + 0);
  {
#line 752
  setcmdopt(argc, argv);
  }
  {
#line 753
  setconfopt(argc, argv);
  }
  {
#line 754
  setdefopt(argc, argv);
  }
  {
#line 755
  preparehtml();
  }
  }
#line 756
  return;
}
}
#line 48 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static int bytestometa___0  =    16000;
#line 59 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static int preparedata___0(char *buf , long end , FILE *from ) 
{ 
  long current ;
  int diff ;
  int amount ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 66
  if (end > 0L) {
    {
    {
#line 67
    current = ftell(from);
    }
    }
#line 68
    if (current < 0L) {
      {
      {
#line 69
      die((char *)"ftell()\n");
      }
      }
    }
#line 70
    diff = (int )(end - current);
#line 71
    if (current == end) {
#line 72
      return (0);
    }
  } else {
#line 74
    diff = 4000;
  }
  {
  {
#line 77
  tmp = feof(from);
  }
  }
#line 77
  if (tmp) {
#line 78
    return (0);
  }
#line 80
  if (diff < 4000) {
#line 80
    tmp___0 = diff;
  } else {
#line 80
    tmp___0 = 4000;
  }
  {
  {
#line 80
  tmp___1 = fread((void */* __restrict  */)buf, (size_t )sizeof(char ), (size_t )tmp___0,
                  (FILE */* __restrict  */)from);
  }
#line 80
  amount = (int )tmp___1;
  {
#line 82
  tmp___2 = ferror(from);
  }
  }
#line 82
  if (tmp___2) {
    {
    {
#line 83
    die((char *)"read()\n");
    }
    }
  }
#line 85
  return (amount);
}
}
#line 100 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void senddata___0(struct client_config *cconf___0 , char *buf , int amount ,
                         mp3entry *playing ) 
{ 
  int towrite ;
  int written ;
  size_t tmp ;
  size_t tmp___0 ;
  short tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 104
  written = 0;
#line 106
  if (! ((int )cconf___0->mode & 2)) {
    {
    {
#line 107
    tmp = fwrite((void const   */* __restrict  */)buf, (size_t )sizeof(char ), (size_t )amount,
                 (FILE */* __restrict  */)cconf___0->stream);
    }
    }
#line 107
    if (tmp != (size_t )amount) {
      {
      {
#line 108
      die((char *)"Error writing to client\n");
      }
      }
    }
  } else {
    {
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 110
      if (! (written < amount)) {
#line 110
        goto while_break;
      }
#line 111
      if (amount - written < bytestometa___0) {
#line 111
        towrite = amount - written;
      } else {
#line 111
        towrite = bytestometa___0;
      }
      {
      {
#line 112
      tmp___0 = fwrite((void const   */* __restrict  */)(buf + written), (size_t )sizeof(char ),
                       (size_t )towrite, (FILE */* __restrict  */)cconf___0->stream);
      }
      }
#line 112
      if (tmp___0 != (size_t )towrite) {
        {
        {
#line 113
        die((char *)"Error writing to client\n");
        }
        }
      }
#line 114
      bytestometa___0 -= towrite;
#line 115
      written += towrite;
#line 116
      if (bytestometa___0 == 0) {
        {
        {
#line 117
        tmp___1 = writemetadata(cconf___0->stream, playing, & cconf___0->metadata);
        }
        }
#line 117
        if (tmp___1) {
#line 118
          bytestometa___0 = 16000;
        } else {
          {
          {
#line 120
          die((char *)"Error writing to client\n");
          }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 124
  return;
}
}
#line 136 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static long setoffsets___0(struct client_config *cconf___0 , FILE *stream , mp3entry *entry ) 
{ 
  long start ;
  long end ;
  char *__cil_tmp6 ;

  {
#line 142
  if (cconf___0->startpos > 0L) {
#line 142
    if (cconf___0->startpos < entry->filesize) {
#line 143
      start = cconf___0->startpos;
    } else {
#line 142
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 144
  if (! ((int )cconf___0->mode & 4)) {
#line 144
    if (entry->id3v2len) {
#line 145
      start = (long )entry->id3v2len;
    } else {
#line 147
      start = 0L;
    }
  } else {
#line 147
    start = 0L;
  }
  {
  {
#line 148
  fseek(stream, start, 0);
  }
  }
#line 150
  if (cconf___0->endpos > 0L) {
#line 150
    if (cconf___0->endpos < entry->filesize) {
#line 151
      end = cconf___0->endpos;
    } else {
#line 150
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 152
  if (entry->id3v1len > 0) {
#line 152
    if (end > (long )entry->id3v1len) {
#line 153
      end = entry->filesize - (off_t )entry->id3v1len;
    } else {
#line 155
      end = entry->filesize;
    }
  } else {
#line 155
    end = entry->filesize;
  }
  {
  {
#line 157
  debug(4, (char *)"Start offset is %li, end offset is %li\n", start, end);
  }
  }
#line 158
  return (end);
}
}
#line 170 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void playfile___0(struct client_config *cconf___0 , mp3entry *entry ) 
{ 
  FILE *file ;
  char buf[4000] ;
  int amount ;
  long end ;
  __pid_t tmp ;
  char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 178
  cconf___0->metadata = (short)1;
  {
#line 179
  debug(1, (char *)"Playing file %s\n", entry->path);
  }
  {
#line 180
  tmp = getpid();
  }
  {
#line 180
  sendstatusmsg(cconf___0->statussock, (char *)"%d:Playing file %s", tmp, entry->path);
  }
  }
#line 183
  if ((unsigned long )gconf.filter != (unsigned long )((void *)0)) {
    {
    {
#line 184
    tmp___0 = replacevariables(gconf.filter, cconf___0, (mp3entry *)((void *)0));
    }
    {
#line 184
    file = popen((char const   *)tmp___0, "r");
    }
    }
#line 184
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      {
      {
#line 186
      die((char *)"popen()\n");
      }
      }
    }
#line 187
    end = -1L;
  } else {
    {
    {
#line 189
    file = fopen((char const   */* __restrict  */)entry->path, (char const   */* __restrict  */)"r");
    }
    }
#line 189
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      {
      {
#line 190
      die((char *)"fopen()\n");
      }
      }
    }
    {
    {
#line 191
    end = setoffsets___0(cconf___0, file, entry);
    }
    }
  }
  {
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 195
    amount = preparedata___0(buf, end, file);
    }
    }
#line 195
    if (! amount) {
#line 195
      goto while_break;
    }
    {
    {
#line 196
    senddata___0(cconf___0, buf, amount, entry);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if ((unsigned long )gconf.filter != (unsigned long )((void *)0)) {
    {
    {
#line 199
    pclose(file);
    }
    }
  } else {
    {
    {
#line 201
    fclose(file);
    }
    }
  }
#line 202
  return;
}
}
#line 217 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void playrange___0(struct client_config *cconf___0 , int min , int max , short order ) 
{ 
  int i ;
  int toplay ;
  mp3entry *current ;
  int offset ;
  int numentries ;
  int numplayed ;
  char *played ;
  int playedsize ;
  time_t tmp ;
  __pid_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 226
  played = (char *)((void *)0);
#line 229
  if (order) {
#line 230
    toplay = max;
  } else {
    {
#line 232
    numplayed = 0;
#line 233
    numentries = (max - min) + 1;
#line 234
    playedsize = numentries / 8 + 1;
    {
#line 236
    tmp = time((time_t *)((void *)0));
    }
    {
#line 236
    tmp___0 = getpid();
    }
    {
#line 236
    srand((unsigned int )tmp + (unsigned int )tmp___0);
    }
    {
#line 238
    tmp___1 = malloc((size_t )playedsize);
    }
#line 238
    played = (char *)tmp___1;
    }
#line 238
    if ((unsigned long )played == (unsigned long )((void *)0)) {
      {
      {
#line 239
      die((char *)"malloc\n");
      }
      }
    }
    {
    {
#line 240
    memset((void *)played, 0, (size_t )playedsize);
    }
    }
  }
  {
  {
#line 243
  debug(1, (char *)"In playrange with range %i - %i and order %i\n", min, max, (int )order);
  }
  }
  {
  {
#line 246
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 247
    if (order) {
#line 248
      if (toplay == max) {
#line 248
        toplay = min;
      } else {
#line 248
        toplay ++;
      }
    } else {
#line 251
      if (numentries - numplayed == 0) {
        {
#line 252
        numplayed = 0;
        {
#line 253
        memset((void *)played, 0, (size_t )playedsize);
        }
        }
      }
      {
      {
#line 257
      tmp___2 = rand();
      }
#line 257
      offset = (int )((double )((float )(numentries - numplayed) * (float )tmp___2) / ((double )2147483647 + 1.0));
#line 261
      i = 0;
      }
      {
      {
#line 261
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 261
        if (! (i < numentries)) {
#line 261
          goto while_break___0;
        }
#line 263
        if ((((int )*(played + i / 8) >> i % 8) & 1) == 0) {
#line 264
          offset --;
        }
#line 266
        if (offset < 0) {
#line 267
          *(played + i / 8) = (char )((int )*(played + i / 8) | (1 << i % 8));
#line 268
          goto while_break___0;
        }
#line 261
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 273
      numplayed ++;
#line 274
      toplay = min + i;
#line 276
      i = 0;
      {
      {
#line 276
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 276
        if (! (i < playedsize)) {
#line 276
          goto while_break___1;
        }
        {
        {
#line 277
        debug(5, (char *)"Offset %i: %x\n", i * 8, (unsigned int )*(played + i));
        }
#line 276
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 281
    i = toplay;
    {
#line 282
    current = findentrybyindex(root, & i);
    }
    }
#line 283
    if (! current) {
      {
      {
#line 284
      die((char *)"Couldn\'t find entry with index %i\n", toplay);
      }
      }
    } else {
      {
      {
#line 286
      debug(1, (char *)"Going to play %s - index %i - order %i\n", current->name,
            toplay, (int )order);
      }
      }
    }
    {
    {
#line 287
    playfile___0(cconf___0, current);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  if (played) {
    {
    {
#line 291
    free((void *)played);
    }
    }
  }
}
}
#line 305 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void createhtml___0(struct client_config *cconf___0 , mp3entry *base ) 
{ 
  int i ;
  mp3entry *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 308
  i = 0;
#line 309
  tmp = base;
#line 311
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 312
    debug(3, (char *)"createhtml: base or output stream NULL - exiting");
    }
    }
#line 313
    return;
  } else
#line 311
  if ((unsigned long )cconf___0->stream == (unsigned long )((void *)0)) {
    {
    {
#line 312
    debug(3, (char *)"createhtml: base or output stream NULL - exiting");
    }
    }
#line 313
    return;
  }
  {
  {
#line 316
  tmp___0 = replacevariables(gconf.htmlheader, cconf___0, (mp3entry *)((void *)0));
  }
  {
#line 316
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"%s",
          tmp___0);
  }
  }
  {
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 317
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 317
      goto while_break;
    }
    {
    {
#line 318
    tmp___1 = replacevariables(gconf.htmlmiddle, cconf___0, tmp);
    }
    {
#line 318
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"%s",
            tmp___1);
    }
#line 319
    tmp = tmp->sibling;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 321
  tmp___2 = replacevariables(gconf.htmlfooter, cconf___0, (mp3entry *)((void *)0));
  }
  {
#line 321
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"%s",
          tmp___2);
  }
  }
#line 322
  return;
}
}
#line 332 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void createinfohtml___0(struct client_config *cconf___0 ) 
{ 
  int i ;
  int clientno ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 336
  clientno = 0;
#line 338
  if ((unsigned long )cconf___0->stream == (unsigned long )((void *)0)) {
    {
    {
#line 339
    debug(3, (char *)"createinfohtml: output stream NULL - exiting");
    }
    }
#line 340
    return;
  }
  {
  {
#line 343
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head>\n<title>%s</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n</head><body><center>\n<p><h1>%s</h1></p>\n<p><h2>Information page</h2></p>\n<p>&nbsp;</p>\n<div align=\"center\"><table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#000000\">",
          gconf.servername, gconf.servername);
  }
  {
#line 345
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\"><b>SERVER STATUS</b></td></tr>\n");
  }
  {
#line 346
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Name</td><td>%s</td></tr>\n",
          gconf.servername);
  }
  {
#line 347
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Address</td><td>%s</td></tr>\n",
          gconf.serveraddress);
  }
  {
#line 348
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Port</td><td>%d</td></tr>\n",
          gconf.port);
  }
  {
#line 349
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>Max clients</td><td>%i</td></tr>\n",
          gconf.max_clients);
  }
  {
#line 351
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\"><b>CLIENT STATUS</b></td></tr>\n");
  }
  }
#line 353
  if (gconf.inetd) {
    {
    {
#line 354
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\">In inetd mode, no status available</td></tr>\n");
    }
    }
  } else
#line 355
  if (gconf.trace) {
    {
    {
#line 356
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\">In trace mode, no status available</td></tr>\n");
    }
    }
  } else {
#line 358
    i = 0;
    {
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 358
      if (! (i < gconf.max_clients)) {
#line 358
        goto while_break;
      }
#line 359
      if ((childarray + i)->childpid == 0) {
#line 360
        goto __Cont;
      }
      {
#line 361
      clientno ++;
      {
#line 362
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td>%i - %s</td><td>%s</td></tr>\n",
              clientno, (childarray + i)->client, (childarray + i)->status);
      }
      }
      __Cont: /* CIL Label */ 
#line 358
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 365
    if (clientno == 0) {
      {
      {
#line 366
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"<tr><td colspan=\"2\">None</td></tr>\n");
      }
      }
    }
  }
  {
  {
#line 369
  fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"</table></div>\n<p align=\"right\"><font size=\"-1\">powered by Ample, for more information, see the\n<a href=\"http://ample.sourceforge.net\">project homepage</a></font></p>\n</center></body></html>");
  }
  }
#line 370
  return;
}
}
#line 383 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static void createm3u___0(struct client_config *cconf___0 , mp3entry *base , short recursive ) 
{ 
  mp3entry *tmp ;
  char *dir ;
  char *tmp___0 ;
  char *vpath ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 386
  tmp = base;
  {
#line 387
  tmp___0 = findpathbyentry(root, base, (char *)"");
  }
#line 387
  dir = tmp___0;
  }
#line 390
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 391
    return;
  } else
#line 390
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 391
    return;
  } else
#line 390
  if ((unsigned long )cconf___0->stream == (unsigned long )((void *)0)) {
#line 391
    return;
  }
  {
  {
#line 392
  dir = dirname(dir);
  }
  }
  {
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 394
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 394
      goto while_break;
    }
#line 395
    if (tmp->type == 0) {
#line 396
      if (recursive) {
#line 396
        if (tmp->child) {
          {
          {
#line 397
          createm3u___0(cconf___0, tmp->child, recursive);
          }
          }
        }
      }
    } else {
      {
      {
#line 398
      vpath = findpathbyentry(root, tmp, (char *)"");
      }
      }
#line 398
      if (vpath) {
        {
        {
#line 399
        fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"#EXTINF:%i,%s\n",
                tmp->length, tmp->title);
        }
        {
#line 401
        fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"http://%s:%d%s\n",
                gconf.serveraddress, gconf.port, vpath);
        }
        {
#line 403
        free((void *)vpath);
        }
        }
      }
    }
#line 405
    tmp = tmp->sibling;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 417 "/home/wslee/benchmarks/sound/ample-0.5.7/src/client.c"
static short check_authentication___0(struct client_config *cconf___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 420
  if ((unsigned long )gconf.username == (unsigned long )((void *)0)) {
#line 421
    return ((short)1);
  } else
#line 420
  if ((unsigned long )gconf.password == (unsigned long )((void *)0)) {
#line 421
    return ((short)1);
  }
#line 423
  if ((unsigned long )cconf___0->username == (unsigned long )((void *)0)) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
            gconf.servername);
    }
    {
#line 429
    fflush(cconf___0->stream);
    }
    }
#line 430
    return ((short)0);
  } else
#line 423
  if ((unsigned long )cconf___0->password == (unsigned long )((void *)0)) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
            gconf.servername);
    }
    {
#line 429
    fflush(cconf___0->stream);
    }
    }
#line 430
    return ((short)0);
  } else {
    {
    {
#line 423
    tmp = strcmp((char const   *)cconf___0->username, (char const   *)gconf.username);
    }
    }
#line 423
    if (tmp) {
      {
      {
#line 428
      fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
              gconf.servername);
      }
      {
#line 429
      fflush(cconf___0->stream);
      }
      }
#line 430
      return ((short)0);
    } else {
      {
      {
#line 423
      tmp___0 = strcmp((char const   *)cconf___0->password, (char const   *)gconf.password);
      }
      }
#line 423
      if (tmp___0) {
        {
        {
#line 428
        fprintf((FILE */* __restrict  */)cconf___0->stream, (char const   */* __restrict  */)"HTTP/1.1 401 Unauthorized\r\nWWW-authenticate: Basic realm=\"%s\"\r\n\r\n",
                gconf.servername);
        }
        {
#line 429
        fflush(cconf___0->stream);
        }
        }
#line 430
        return ((short)0);
      } else {
#line 432
        return ((short)1);
      }
    }
  }
}
}
#line 71 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void addtoarray___0(char ***arrayptr , char *element ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 76
  if ((unsigned long )*arrayptr == (unsigned long )((void *)0)) {
    {
    {
#line 77
    tmp = malloc((size_t )sizeof(char *));
    }
#line 77
    *arrayptr = (char **)tmp;
    }
#line 78
    if (! *arrayptr) {
      {
      {
#line 79
      die((char *)"malloc()\n");
      }
      }
    }
#line 80
    *(*arrayptr + 0) = (char *)((void *)0);
  }
#line 83
  i = 0;
  {
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! ((unsigned long )*(*arrayptr + i) != (unsigned long )((void *)0))) {
#line 83
      goto while_break;
    }
#line 83
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 85
  tmp___0 = realloc((void *)*arrayptr, (size_t )((unsigned long )(i + 2) * sizeof(char *)));
  }
#line 85
  *arrayptr = (char **)tmp___0;
  }
#line 86
  if (! *arrayptr) {
    {
    {
#line 87
    die((char *)"realloc()\n");
    }
    }
  }
#line 89
  *(*arrayptr + i) = element;
#line 90
  *(*arrayptr + (i + 1)) = (char *)((void *)0);
#line 91
  return;
}
}
#line 105 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static char *decodeurl___0(char *url ) 
{ 
  char *current ;
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *pos ;
  int hexval ;
  char hexbuf[3] ;
  long tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 108
  current = url;
  {
#line 109
  tmp = strlen((char const   *)url);
  }
  {
#line 109
  tmp___0 = malloc(tmp + 1U);
  }
#line 109
  ret = (char *)tmp___0;
#line 110
  pos = ret;
#line 114
  hexbuf[2] = (char )'\000';
  }
#line 115
  if ((int )*current != 47) {
#line 117
    pos ++;
  }
  {
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 120
    if (! ((int )*current != 0)) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )*current != 37) {
#line 122
      *pos = *current;
#line 123
      pos ++;
#line 124
      current ++;
    } else {
#line 126
      hexbuf[0] = *(current + 1);
#line 126
      if ((int )hexbuf[0] == 0) {
        {
        {
#line 128
        strncpy((char */* __restrict  */)pos, (char const   */* __restrict  */)current,
                (size_t )3);
        }
#line 129
        pos += 2;
        }
#line 130
        goto while_break;
      } else {
#line 126
        hexbuf[1] = *(current + 2);
#line 126
        if ((int )hexbuf[1] == 0) {
          {
          {
#line 128
          strncpy((char */* __restrict  */)pos, (char const   */* __restrict  */)current,
                  (size_t )3);
          }
#line 129
          pos += 2;
          }
#line 130
          goto while_break;
        } else {
          {
          {
#line 131
          tmp___1 = strtol((char const   */* __restrict  */)(hexbuf), (char **/* __restrict  */)((void *)0),
                           16);
          }
#line 131
          hexval = (int )tmp___1;
          }
#line 131
          if (hexval == 0) {
            {
            {
#line 132
            strncpy((char */* __restrict  */)pos, (char const   */* __restrict  */)current,
                    (size_t )3);
            }
#line 133
            pos += 3;
            }
          } else {
#line 135
            *pos = (char )hexval;
#line 136
            pos ++;
          }
        }
      }
#line 138
      current += 3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  *pos = (char )'\000';
  {
#line 143
  debug(2, (char *)"Decodeurl parses %s as %s\n", url, ret);
  }
  }
#line 144
  return (ret);
}
}
#line 155 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void conntimeout___0(int signal___0 ) 
{ 


  {
#line 158
  timeout = (int volatile   )1;
#line 159
  return;
}
}
#line 396 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void preparehtml___0(void) 
{ 
  char line[400] ;
  FILE *file ;
  int i ;
  char *tmp ;
  int tmpsize ;
  int tmpwritten ;
  struct confoption delimiters[4] ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 403
  tmpsize = 800;
#line 404
  tmpwritten = 0;
#line 406
  delimiters[0].name = (char *)"@BEGIN@";
#line 406
  delimiters[0].type = (unsigned short)0;
#line 406
  delimiters[0].value = (void *)(& gconf.htmlheader);
#line 406
  delimiters[1].name = (char *)"@END@";
#line 406
  delimiters[1].type = (unsigned short)0;
#line 406
  delimiters[1].value = (void *)(& gconf.htmlmiddle);
#line 406
  delimiters[2].name = (char *)((void *)0);
#line 406
  delimiters[2].type = (unsigned short)0;
#line 406
  delimiters[2].value = (void *)(& gconf.htmlfooter);
#line 406
  delimiters[3].name = (char *)((void *)0);
#line 406
  delimiters[3].type = (unsigned short)0;
#line 406
  delimiters[3].value = (void *)0;
  {
#line 413
  file = fopen((char const   */* __restrict  */)gconf.htmlfile, (char const   */* __restrict  */)"r");
  }
  }
#line 413
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
    {
#line 414
    debug(2, (char *)"Using %s as configfile\n", gconf.htmlfile);
    }
    }
  } else {
    {
    {
#line 416
    debug(2, (char *)"No HTML template found\n");
    }
    {
#line 417
    gconf.htmlheader = strdup("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html><head>\n<title>@SERVERNAME@</title><meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n</head><body><center>\n<p><h1>@SERVERNAME@</h1></p>\n<p><h2>Tracks currently available in @PATH@</h2></p>\n<p>&nbsp;</p><p><font size=\"-1\">[ <a href=\"index.m3u\">playlist for this dir</a> | <a href=\"rindex.m3u\">recursive playlist</a> ]</font></p>\n<p><font size=\"-1\">[ <a href=\"../index.html\">Up one level</a> ]</font></p>\n<div align=\"center\"><table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#000000\">\n<tr>\n<td><b>TYPE</b></td><td><b>URL</b></td></tr>\n");
    }
    {
#line 418
    gconf.htmlmiddle = strdup("<tr><td>@TYPE@</td><td><a href=\"@URL@\">@NAME@</a></td></tr>\n");
    }
    {
#line 419
    gconf.htmlfooter = strdup("</table></div>\n<p align=\"right\"><font size=\"-1\">powered by Ample, for more information, see the\n<a href=\"http://ample.sourceforge.net\">project homepage</a></font></p>\n</center></body></html>\r\n");
    }
    }
#line 420
    return;
  }
#line 423
  i = 0;
  {
  {
#line 423
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 423
    if (! ((unsigned long )delimiters[i].value != (unsigned long )((void *)0))) {
#line 423
      goto while_break;
    }
    {
    {
#line 425
    tmp___0 = malloc((size_t )tmpsize);
    }
#line 425
    tmp = (char *)tmp___0;
#line 426
    *tmp = (char )'\000';
    }
    {
    {
#line 428
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 428
      tmp___4 = fgets((char */* __restrict  */)(line), 400, (FILE */* __restrict  */)file);
      }
      }
#line 428
      if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 428
        goto while_break___0;
      }
      {
      {
#line 429
      debug(9, (char *)"Template line is %s\n", line);
      }
      }
#line 430
      if (delimiters[i].name) {
        {
        {
#line 430
        tmp___1 = strlen((char const   *)delimiters[i].name);
        }
        {
#line 430
        tmp___2 = strncmp((char const   *)(line), (char const   *)delimiters[i].name,
                          tmp___1);
        }
        }
#line 430
        if (! tmp___2) {
#line 433
          goto while_break___0;
        }
      }
      {
      {
#line 434
      tmp___3 = strlen((char const   *)(line));
      }
#line 434
      tmpwritten = (int )((size_t )tmpwritten + tmp___3);
      {
#line 435
      strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)(line));
      }
      }
#line 436
      if (tmpsize - tmpwritten < 400) {
        {
#line 437
        tmpsize += 400;
        {
#line 438
        realloc((void *)tmp, (size_t )tmpsize);
        }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 442
    tmp___5 = strlen((char const   *)tmp);
    }
    {
#line 442
    realloc((void *)tmp, tmp___5 + 1U);
    }
#line 443
    *((char **)delimiters[i].value) = tmp;
#line 423
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 456 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void usage___0(short error ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 459
  if (error) {
    {
    {
#line 460
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
            gconf.program_name);
    }
    {
#line 462
    exit(1);
    }
    }
  } else {
    {
    {
#line 465
    printf((char const   */* __restrict  */)"Usage: %s [OPTION(S)]... [PATH]\n\nAMPLE - An MP3 LEnder\nrecursively indexes all MP3 files it finds below PATH and then listens\nto a TCP port for incoming connections. Once a connection is made AMPLE will\nstart sending randomly chosen MP3\'s. If called from the command line or a\nscript AMPLE will go into daemon mode (unlike when called from inetd or with\nthe option -t).\n\n",
           gconf.program_name);
    }
    {
#line 466
    printf((char const   */* __restrict  */)"  -p, --port=NUMBER           which port to listen to, default %d\n  -o, --order                 play MP3 files in alphabetical order\n  -c, --clients=NUMBER        how many clients are allowed to be connected\n                              default %d\n  -n, --norecursive           don\'t index MP3 files in subdirs of the given dir\n  -f, --conffile=FILENAME     alternative file to read for config options\n  -m, --htmlfile=FILENAME     file to use as template for HTML output\n  -h, --help                  display this help and exit\n  -d, --debug[=NUMBER]        debug messages will be printed\n                              higher number means more detail\n  -t, --trace                 no forking, no backgrounding\n                              helpful when debugging\n  -v, --version               output version information and exit\n\nReport bugs to <david@2gen.com>\n",
           1234, 5);
    }
    {
#line 467
    exit(0);
    }
    }
  }
}
}
#line 481 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void setdefopt___0(int argc , char **argv ) 
{ 
  struct servent *servent ;
  struct servent *tmp ;
  uint16_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 484
  if (gconf.port == 0) {
    {
    {
#line 486
    tmp = getservbyname("ample", "tcp");
    }
#line 486
    servent = tmp;
    }
#line 487
    if (servent) {
      {
      {
#line 487
      tmp___0 = ntohs((uint16_t )servent->s_port);
      }
#line 487
      gconf.port = (int )tmp___0;
      }
    } else {
#line 487
      gconf.port = 1234;
    }
  }
#line 493
  if (gconf.port >= 65536) {
    {
    {
#line 494
    die((char *)"port number out of range\n");
    }
    }
  }
#line 495
  if ((int )gconf.order == -1) {
#line 496
    gconf.order = (short)0;
  }
#line 497
  if (gconf.max_clients == 0) {
#line 498
    gconf.max_clients = 5;
  }
#line 499
  if ((int )gconf.recursive == -1) {
#line 500
    gconf.recursive = (short)1;
  }
#line 501
  if ((unsigned long )gconf.pathlist == (unsigned long )((void *)0)) {
    {
    {
#line 502
    tmp___1 = strdup("/usr/local/share/mp3");
    }
    {
#line 502
    addtoarray___0(& gconf.pathlist, tmp___1);
    }
    }
  }
#line 503
  if ((unsigned long )gconf.logfile == (unsigned long )((void *)0)) {
    {
    {
#line 504
    gconf.logfile = strdup("/usr/local/var/log/ample.conf");
    }
    }
  }
#line 505
  if ((unsigned long )gconf.servername == (unsigned long )((void *)0)) {
    {
    {
#line 506
    gconf.servername = strdup("Ample");
    }
    }
  }
#line 507
  if ((unsigned long )gconf.serveraddress == (unsigned long )((void *)0)) {
    {
    {
#line 507
    gconf.serveraddress = getservername();
    }
    }
#line 507
    if (! gconf.serveraddress) {
      {
      {
#line 509
      gconf.serveraddress = strdup("127.0.0.1");
      }
      }
    }
  }
#line 510
  if ((unsigned long )gconf.htmlfile == (unsigned long )((void *)0)) {
    {
    {
#line 511
    gconf.htmlfile = strdup("/usr/local/etc/ample.html");
    }
    }
  }
#line 512
  return;
}
}
#line 524 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void parseconfopt___0(char *tmp , void *value , int type ) 
{ 
  int i ;
  float f ;
  char *end ;
  char *retval ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  double tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  unsigned short const   **tmp___13 ;
  void *tmp___14 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 532
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 532
    tmp___0 = __ctype_b_loc();
    }
    }
#line 532
    if (! ((int const   )*(*tmp___0 + (int )*tmp) & 8192)) {
#line 532
      goto while_break;
    }
#line 533
    tmp ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if ((int )*tmp != 61) {
#line 536
    return;
  } else {
#line 538
    tmp ++;
  }
  {
  {
#line 540
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 540
    tmp___1 = __ctype_b_loc();
    }
    }
#line 540
    if (! ((int const   )*(*tmp___1 + (int )*tmp) & 8192)) {
#line 540
      goto while_break___0;
    }
#line 541
    tmp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 544
  if (type == 2) {
#line 544
    goto case_2;
  }
#line 548
  if (type == 5) {
#line 548
    goto case_5;
  }
#line 552
  if (type == 1) {
#line 552
    goto case_1;
  }
#line 560
  if (type == 3) {
#line 560
    goto case_3;
  }
#line 574
  if (type == 4) {
#line 574
    goto case_4;
  }
#line 588
  goto switch_default;
  case_2: /* CIL Label */ 
  {
  {
#line 545
  tmp___2 = strtol((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0),
                   10);
  }
#line 545
  i = (int )tmp___2;
  }
#line 545
  if (i > 0) {
#line 546
    *((int *)value) = i;
  }
#line 547
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 549
  tmp___3 = strtod((char const   */* __restrict  */)tmp, (char **/* __restrict  */)((void *)0));
  }
#line 549
  f = (float )tmp___3;
  }
#line 549
  if (f > (float )0) {
#line 550
    *((float *)value) = f;
  }
#line 551
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 553
  tmp___8 = strlen("yes");
  }
  {
#line 553
  tmp___9 = strncasecmp("yes", (char const   *)tmp, tmp___8);
  }
  }
#line 553
  if (tmp___9) {
    {
    {
#line 553
    tmp___10 = strlen("true");
    }
    {
#line 553
    tmp___11 = strncasecmp("true", (char const   *)tmp, tmp___10);
    }
    }
#line 553
    if (tmp___11) {
      {
      {
#line 556
      tmp___4 = strlen("no");
      }
      {
#line 556
      tmp___5 = strncasecmp("no", (char const   *)tmp, tmp___4);
      }
      }
#line 556
      if (tmp___5) {
        {
        {
#line 556
        tmp___6 = strlen("false");
        }
        {
#line 556
        tmp___7 = strncasecmp("false", (char const   *)tmp, tmp___6);
        }
        }
#line 556
        if (! tmp___7) {
#line 558
          *((short *)value) = (short)0;
        }
      } else {
#line 558
        *((short *)value) = (short)0;
      }
    } else {
#line 555
      *((short *)value) = (short)1;
    }
  } else {
#line 555
    *((short *)value) = (short)1;
  }
#line 559
  goto switch_break;
  case_3: /* CIL Label */ 
#line 561
  end = tmp;
  {
  {
#line 562
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 562
    if ((int )*end != 10) {
#line 562
      if ((int )*end != 0) {
#line 562
        if (! ((int )*end != 35)) {
#line 562
          goto while_break___1;
        }
      } else {
#line 562
        goto while_break___1;
      }
    } else {
#line 562
      goto while_break___1;
    }
#line 564
    end ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 565
  if ((unsigned long )end == (unsigned long )tmp) {
#line 566
    goto switch_break;
  }
  {
  {
#line 567
  tmp___12 = malloc((size_t )((end - tmp) + 1L));
  }
#line 567
  retval = (char *)tmp___12;
  }
#line 568
  if (! retval) {
    {
    {
#line 569
    die((char *)"malloc");
    }
    }
  }
  {
  {
#line 570
  snprintf((char */* __restrict  */)retval, (size_t )((end - tmp) + 1L), (char const   */* __restrict  */)"%.*s",
           end - tmp, tmp);
  }
#line 572
  *((char **)value) = retval;
  }
#line 573
  goto switch_break;
  case_4: /* CIL Label */ 
#line 575
  end = tmp;
  {
  {
#line 576
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 576
    if ((int )*end != 10) {
#line 576
      if ((int )*end != 0) {
#line 576
        if ((int )*end != 35) {
          {
          {
#line 576
          tmp___13 = __ctype_b_loc();
          }
          }
#line 576
          if ((int const   )*(*tmp___13 + (int )*end) & 8192) {
#line 576
            goto while_break___2;
          }
        } else {
#line 576
          goto while_break___2;
        }
      } else {
#line 576
        goto while_break___2;
      }
    } else {
#line 576
      goto while_break___2;
    }
#line 578
    end ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 579
  if ((unsigned long )end == (unsigned long )tmp) {
#line 580
    goto switch_break;
  }
  {
  {
#line 581
  tmp___14 = malloc((size_t )((end - tmp) + 1L));
  }
#line 581
  retval = (char *)tmp___14;
  }
#line 582
  if (! retval) {
    {
    {
#line 583
    die((char *)"malloc");
    }
    }
  }
  {
  {
#line 584
  snprintf((char */* __restrict  */)retval, (size_t )((end - tmp) + 1L), (char const   */* __restrict  */)"%.*s",
           end - tmp, tmp);
  }
  {
#line 586
  addtoarray___0((char ***)value, retval);
  }
  }
#line 587
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 590
  debug(2, (char *)"Incorrect type passed to parseconfopt()\n");
  }
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 593
  return;
}
}
#line 605 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void setconfopt___0(int argc , char **argv ) 
{ 
  char line[400] ;
  FILE *file ;
  int i ;
  int j ;
  struct confoption options[13] ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 611
  options[0].name = (char *)"clients";
#line 611
  options[0].type = (unsigned short)2;
#line 611
  options[0].value = (void *)(& gconf.max_clients);
#line 611
  options[1].name = (char *)"filter";
#line 611
  options[1].type = (unsigned short)3;
#line 611
  options[1].value = (void *)(& gconf.filter);
#line 611
  options[2].name = (char *)"htmlfile";
#line 611
  options[2].type = (unsigned short)3;
#line 611
  options[2].value = (void *)(& gconf.htmlfile);
#line 611
  options[3].name = (char *)"logfile";
#line 611
  options[3].type = (unsigned short)3;
#line 611
  options[3].value = (void *)(& gconf.logfile);
#line 611
  options[4].name = (char *)"mp3path";
#line 611
  options[4].type = (unsigned short)4;
#line 611
  options[4].value = (void *)(& gconf.pathlist);
#line 611
  options[5].name = (char *)"order";
#line 611
  options[5].type = (unsigned short)1;
#line 611
  options[5].value = (void *)(& gconf.order);
#line 611
  options[6].name = (char *)"password";
#line 611
  options[6].type = (unsigned short)3;
#line 611
  options[6].value = (void *)(& gconf.password);
#line 611
  options[7].name = (char *)"port";
#line 611
  options[7].type = (unsigned short)2;
#line 611
  options[7].value = (void *)(& gconf.port);
#line 611
  options[8].name = (char *)"recursive";
#line 611
  options[8].type = (unsigned short)1;
#line 611
  options[8].value = (void *)(& gconf.recursive);
#line 611
  options[9].name = (char *)"servername";
#line 611
  options[9].type = (unsigned short)3;
#line 611
  options[9].value = (void *)(& gconf.servername);
#line 611
  options[10].name = (char *)"serveraddress";
#line 611
  options[10].type = (unsigned short)3;
#line 611
  options[10].value = (void *)(& gconf.serveraddress);
#line 611
  options[11].name = (char *)"username";
#line 611
  options[11].type = (unsigned short)3;
#line 611
  options[11].value = (void *)(& gconf.username);
#line 611
  options[12].name = (char *)((void *)0);
#line 611
  options[12].type = (unsigned short)0;
#line 611
  options[12].value = (void *)0;
#line 627
  if ((unsigned long )gconf.conffile == (unsigned long )((void *)0)) {
    {
    {
#line 628
    file = fopen((char const   */* __restrict  */)"/usr/local/etc/ample.conf", (char const   */* __restrict  */)"r");
    }
    }
  } else {
    {
    {
#line 630
    file = fopen((char const   */* __restrict  */)gconf.conffile, (char const   */* __restrict  */)"r");
    }
    }
  }
#line 632
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 633
    return;
  }
  {
  {
#line 635
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 635
    tmp___3 = fgets((char */* __restrict  */)(line), 400, (FILE */* __restrict  */)file);
    }
    }
#line 635
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 635
      goto while_break;
    }
#line 636
    if ((int )line[0] == 35) {
#line 637
      goto while_continue;
    }
#line 639
    i = 0;
    {
    {
#line 639
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 639
      tmp = __ctype_b_loc();
      }
      }
#line 639
      if (! ((int const   )*(*tmp + (int )line[i]) & 8192)) {
#line 639
        goto while_break___0;
      }
#line 639
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 641
    j = 0;
    {
    {
#line 641
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 641
      if (! ((unsigned long )options[j].name != (unsigned long )((void *)0))) {
#line 641
        goto while_break___1;
      }
      {
      {
#line 642
      tmp___1 = strlen((char const   *)options[j].name);
      }
      {
#line 642
      tmp___2 = strncasecmp((char const   *)(& line[i]), (char const   *)options[j].name,
                            tmp___1);
      }
      }
#line 642
      if (! tmp___2) {
        {
        {
#line 643
        tmp___0 = strlen((char const   *)options[j].name);
        }
#line 643
        i = (int )((size_t )i + tmp___0);
        {
#line 644
        parseconfopt___0(& line[i], options[j].value, (int )options[j].type);
        }
        }
#line 645
        goto while_break___1;
      }
#line 641
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return;
}
}
#line 660 "/home/wslee/benchmarks/sound/ample-0.5.7/src/configuration.c"
static void setcmdopt___0(int argc , char **argv ) 
{ 
  int c ;
  int i ;
  struct option longopts[11] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 666
  longopts[0].name = "port";
#line 666
  longopts[0].has_arg = 1;
#line 666
  longopts[0].flag = (int *)((void *)0);
#line 666
  longopts[0].val = 'p';
#line 666
  longopts[1].name = "order";
#line 666
  longopts[1].has_arg = 0;
#line 666
  longopts[1].flag = (int *)((void *)0);
#line 666
  longopts[1].val = 'o';
#line 666
  longopts[2].name = "clients";
#line 666
  longopts[2].has_arg = 1;
#line 666
  longopts[2].flag = (int *)((void *)0);
#line 666
  longopts[2].val = 'c';
#line 666
  longopts[3].name = "norecursive";
#line 666
  longopts[3].has_arg = 0;
#line 666
  longopts[3].flag = (int *)((void *)0);
#line 666
  longopts[3].val = 'n';
#line 666
  longopts[4].name = "conffile";
#line 666
  longopts[4].has_arg = 1;
#line 666
  longopts[4].flag = (int *)((void *)0);
#line 666
  longopts[4].val = 'f';
#line 666
  longopts[5].name = "htmlfile";
#line 666
  longopts[5].has_arg = 1;
#line 666
  longopts[5].flag = (int *)((void *)0);
#line 666
  longopts[5].val = 'm';
#line 666
  longopts[6].name = "help";
#line 666
  longopts[6].has_arg = 0;
#line 666
  longopts[6].flag = (int *)((void *)0);
#line 666
  longopts[6].val = 'h';
#line 666
  longopts[7].name = "debug";
#line 666
  longopts[7].has_arg = 2;
#line 666
  longopts[7].flag = (int *)((void *)0);
#line 666
  longopts[7].val = 'd';
#line 666
  longopts[8].name = "trace";
#line 666
  longopts[8].has_arg = 0;
#line 666
  longopts[8].flag = (int *)((void *)0);
#line 666
  longopts[8].val = 't';
#line 666
  longopts[9].name = "version";
#line 666
  longopts[9].has_arg = 0;
#line 666
  longopts[9].flag = (int *)((void *)0);
#line 666
  longopts[9].val = 'v';
#line 666
  longopts[10].name = (char const   *)((void *)0);
#line 666
  longopts[10].has_arg = 0;
#line 666
  longopts[10].flag = (int *)((void *)0);
#line 666
  longopts[10].val = 0;
  {
  {
#line 680
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 680
    c = getopt_long(argc, (char * const  *)argv, "p:oc:nf:m:hd::tv", (struct option  const  *)(longopts),
                    & i);
    }
    }
#line 680
    if (! (c != -1)) {
#line 680
      goto while_break;
    }
    {
#line 686
    if (c == 112) {
#line 686
      goto case_112;
    }
#line 690
    if (c == 111) {
#line 690
      goto case_111;
    }
#line 693
    if (c == 99) {
#line 693
      goto case_99;
    }
#line 697
    if (c == 110) {
#line 697
      goto case_110;
    }
#line 700
    if (c == 102) {
#line 700
      goto case_102;
    }
#line 703
    if (c == 109) {
#line 703
      goto case_109;
    }
#line 706
    if (c == 104) {
#line 706
      goto case_104;
    }
#line 709
    if (c == 100) {
#line 709
      goto case_100;
    }
#line 715
    if (c == 116) {
#line 715
      goto case_116;
    }
#line 718
    if (c == 118) {
#line 718
      goto case_118;
    }
#line 721
    goto switch_default;
    case_112: /* CIL Label */ 
    {
    {
#line 687
    tmp___0 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
    }
    }
#line 687
    if (tmp___0 > 0L) {
      {
      {
#line 688
      tmp = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                   10);
      }
#line 688
      gconf.port = (int )tmp;
      }
    }
#line 689
    goto switch_break;
    case_111: /* CIL Label */ 
#line 691
    gconf.order = (short)1;
#line 692
    goto switch_break;
    case_99: /* CIL Label */ 
    {
    {
#line 694
    tmp___2 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     10);
    }
    }
#line 694
    if (tmp___2 > 0L) {
      {
      {
#line 695
      tmp___1 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       10);
      }
#line 695
      gconf.max_clients = (int )tmp___1;
      }
    }
#line 696
    goto switch_break;
    case_110: /* CIL Label */ 
#line 698
    gconf.recursive = (short)0;
#line 699
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 701
    gconf.conffile = strdup((char const   *)optarg);
    }
    }
#line 702
    goto switch_break;
    case_109: /* CIL Label */ 
    {
    {
#line 704
    gconf.htmlfile = strdup((char const   *)optarg);
    }
    }
#line 705
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 707
    usage___0((short)0);
    }
    }
#line 708
    goto switch_break;
    case_100: /* CIL Label */ 
#line 710
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 711
      gconf.debuglevel = 1;
    } else {
      {
      {
#line 710
      tmp___4 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       10);
      }
      }
#line 710
      if (tmp___4 < 0L) {
#line 711
        gconf.debuglevel = 1;
      } else {
        {
        {
#line 713
        tmp___3 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                         10);
        }
#line 713
        gconf.debuglevel = (int )tmp___3;
        }
      }
    }
#line 714
    goto switch_break;
    case_116: /* CIL Label */ 
#line 716
    gconf.trace = (short)1;
#line 717
    goto switch_break;
    case_118: /* CIL Label */ 
    {
    {
#line 719
    printf((char const   */* __restrict  */)"Ample version %s\n", "0.5.7");
    }
    {
#line 720
    exit(0);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 722
    usage___0((short)1);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  i = optind;
  {
  {
#line 727
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 727
    if (! (i < argc)) {
#line 727
      goto while_break___0;
    }
    {
    {
#line 728
    tmp___5 = strdup((char const   *)*(argv + i));
    }
    {
#line 728
    addtoarray___0(& gconf.pathlist, tmp___5);
    }
#line 729
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 731
  return;
}
}
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 346 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 50 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.h"
short findindexbyentry(mp3entry *base , mp3entry *tofind , int *index___0 ) ;
#line 59
void showtree(int indent , mp3entry *entry ) ;
#line 62
void addentry(mp3entry **baseptr , mp3entry *toadd ) ;
#line 65
short removeentry(mp3entry **baseptr , mp3entry *toremove ) ;
#line 71
int writetree(void *basedest , mp3entry *baseentry ) ;
#line 74
int countentries(mp3entry *baseentry ) ;
#line 77
int spaceneeded(mp3entry *baseentry ) ;
#line 80
void dumpentry(mp3entry *entry ) ;
#line 83
void indexpaths(char **patharray ) ;
#line 66 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
mp3entry *root  =    (mp3entry *)((void *)0);
#line 78 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
mp3entry *findentrybypath(mp3entry *base , char *name ) 
{ 
  char *namec ;
  char *tmp ;
  char *token ;
  mp3entry *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 81
  tmp = strdup((char const   *)name);
  }
#line 81
  namec = tmp;
#line 83
  tmp___0 = base;
  {
#line 85
  token = strtok((char */* __restrict  */)namec, (char const   */* __restrict  */)"/");
  }
  }
#line 87
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    {
    {
#line 88
    free((void *)namec);
    }
    }
#line 89
    return (tmp___0);
  }
  {
  {
#line 92
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 92
    if ((unsigned long )token != (unsigned long )((void *)0)) {
#line 92
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 92
        goto while_break;
      }
    } else {
#line 92
      goto while_break;
    }
    {
    {
#line 93
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 93
      if (tmp___0) {
        {
        {
#line 93
        tmp___1 = strcmp((char const   *)tmp___0->name, (char const   *)token);
        }
        }
#line 93
        if (! tmp___1) {
#line 93
          goto while_break___0;
        }
      } else {
#line 93
        goto while_break___0;
      }
#line 94
      tmp___0 = tmp___0->sibling;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 96
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"/");
    }
    }
#line 98
    if (tmp___0) {
#line 98
      if (! token) {
        {
        {
#line 99
        debug(3, (char *)"Find: found the last part with %s\n", tmp___0->name);
        }
        }
#line 101
        goto while_break;
      } else {
#line 98
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 102
    if (tmp___0) {
      {
      {
#line 103
      debug(3, (char *)"Find: found the part with %s\n", tmp___0->name);
      }
#line 105
      tmp___0 = tmp___0->child;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 109
  free((void *)namec);
  }
  }
#line 110
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 110
    if (tmp___0->child) {
#line 111
      return (tmp___0->child);
    } else {
#line 113
      return (tmp___0);
    }
  } else {
#line 113
    return (tmp___0);
  }
}
}
#line 128 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
char *findpathbyentry(mp3entry *base , mp3entry *tofind , char *path ) 
{ 
  mp3entry *tmp ;
  char *subpath ;
  char *pathc ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 131
  tmp = base;
  {
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 135
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 135
      if (! ((unsigned long )tmp != (unsigned long )tofind)) {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
#line 136
    if (tmp->child) {
      {
      {
#line 137
      tmp___0 = strlen((char const   *)path);
      }
      {
#line 137
      tmp___1 = strlen((char const   *)tmp->name);
      }
      {
#line 137
      tmp___2 = malloc((tmp___0 + tmp___1) + 2U);
      }
#line 137
      pathc = (char *)tmp___2;
      {
#line 138
      sprintf((char */* __restrict  */)pathc, (char const   */* __restrict  */)"%s/%s",
              path, tmp->name);
      }
      {
#line 139
      subpath = findpathbyentry(tmp->child, tofind, pathc);
      }
      {
#line 140
      free((void *)pathc);
      }
      }
#line 141
      if (subpath) {
#line 142
        return (subpath);
      }
    }
#line 144
    tmp = tmp->sibling;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  if ((unsigned long )tmp == (unsigned long )tofind) {
    {
    {
#line 148
    tmp___3 = strlen((char const   *)path);
    }
    {
#line 148
    tmp___4 = strlen((char const   *)tmp->name);
    }
    {
#line 148
    tmp___5 = malloc((tmp___3 + tmp___4) + 2U);
    }
#line 148
    subpath = (char *)tmp___5;
    {
#line 149
    sprintf((char */* __restrict  */)subpath, (char const   */* __restrict  */)"%s/%s",
            path, tmp->name);
    }
    }
#line 150
    return (subpath);
  } else {
#line 152
    return ((char *)((void *)0));
  }
}
}
#line 169 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
short findindexbyentry(mp3entry *base , mp3entry *tofind , int *index___0 ) 
{ 
  mp3entry *tmp ;
  int count ;
  short tmp___0 ;

  {
#line 172
  tmp = base;
#line 173
  count = 0;
#line 175
  if (! tofind) {
#line 176
    return ((short)0);
  }
  {
  {
#line 178
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 178
      goto while_break;
    }
#line 179
    if (tmp->type == 1) {
#line 180
      (*index___0) ++;
    }
#line 181
    if ((unsigned long )tmp == (unsigned long )tofind) {
#line 182
      return ((short)1);
    }
#line 183
    tmp = tmp->sibling;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  tmp = base;
  {
  {
#line 188
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 188
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 188
      goto while_break___0;
    }
#line 189
    if (tmp->type == 0) {
      {
      {
#line 189
      tmp___0 = findindexbyentry(tmp->child, tofind, index___0);
      }
      }
#line 189
      if (tmp___0) {
#line 190
        return ((short)1);
      }
    }
#line 191
    tmp = tmp->sibling;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 194
  return ((short)0);
}
}
#line 208 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
mp3entry *findentrybyindex(mp3entry *base , int *index___0 ) 
{ 
  mp3entry *tmp ;
  mp3entry *result___1 ;

  {
#line 211
  tmp = base;
#line 212
  result___1 = (mp3entry *)((void *)0);
#line 214
  if (*index___0 == 0) {
#line 215
    return ((mp3entry *)((void *)0));
  } else
#line 214
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 215
    return ((mp3entry *)((void *)0));
  }
  {
  {
#line 217
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 217
      goto while_break;
    }
#line 218
    if (tmp->type == 1) {
#line 219
      (*index___0) --;
    }
#line 220
    if (*index___0 == 0) {
#line 221
      return (tmp);
    } else {
#line 223
      tmp = tmp->sibling;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  tmp = base;
  {
  {
#line 228
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 228
      goto while_break___0;
    }
#line 229
    if (tmp->type == 0) {
      {
      {
#line 229
      result___1 = findentrybyindex(tmp->child, index___0);
      }
      }
#line 229
      if (result___1) {
#line 231
        return (result___1);
      }
    }
#line 232
    tmp = tmp->sibling;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 235
  return ((mp3entry *)((void *)0));
}
}
#line 251 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void findfirstfile(mp3entry *base , short recursive , mp3entry **result___1 ) 
{ 
  mp3entry *tmp ;

  {
#line 254
  tmp = base;
#line 256
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 257
    return;
  }
  {
  {
#line 259
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 259
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 259
      if (! ((unsigned long )*result___1 == (unsigned long )((void *)0))) {
#line 259
        goto while_break;
      }
    } else {
#line 259
      goto while_break;
    }
#line 260
    if (tmp->type == 1) {
#line 261
      *result___1 = tmp;
#line 262
      return;
    }
#line 264
    tmp = tmp->sibling;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (recursive) {
#line 268
    tmp = base;
    {
    {
#line 269
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 269
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 269
        if (! ((unsigned long )*result___1 == (unsigned long )((void *)0))) {
#line 269
          goto while_break___0;
        }
      } else {
#line 269
        goto while_break___0;
      }
#line 270
      if (tmp->type == 0) {
        {
        {
#line 271
        findfirstfile(tmp->child, recursive, result___1);
        }
        }
      }
#line 272
      tmp = tmp->sibling;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 275
  return;
}
}
#line 290 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void findlastfile(mp3entry *base , short recursive , mp3entry **result___1 ) 
{ 
  mp3entry *tmp ;

  {
#line 293
  tmp = base;
#line 295
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 296
    return;
  }
  {
  {
#line 298
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 298
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 298
      goto while_break;
    }
#line 299
    if (tmp->type == 1) {
#line 300
      *result___1 = tmp;
    }
#line 301
    tmp = tmp->sibling;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (recursive) {
#line 305
    tmp = base;
    {
    {
#line 306
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 306
        goto while_break___0;
      }
#line 307
      if (tmp->type == 0) {
#line 307
        if (recursive) {
          {
          {
#line 308
          findlastfile(tmp->child, recursive, result___1);
          }
          }
        }
      }
#line 309
      tmp = tmp->sibling;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 312
  return;
}
}
#line 330 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
short getrange(mp3entry *base , short recursive , int *min , int *max ) 
{ 
  mp3entry *tmp ;

  {
  {
#line 335
  *min = 0;
#line 336
  *max = 0;
#line 338
  tmp = (mp3entry *)((void *)0);
  {
#line 339
  findfirstfile(base, recursive, & tmp);
  }
  {
#line 340
  findindexbyentry(root, tmp, min);
  }
#line 341
  tmp = (mp3entry *)((void *)0);
  {
#line 342
  findlastfile(base, recursive, & tmp);
  }
  {
#line 343
  findindexbyentry(root, tmp, max);
  }
  }
#line 345
  if ((unsigned long )max == (unsigned long )((int *)0)) {
#line 346
    return ((short)0);
  } else
#line 345
  if ((unsigned long )min == (unsigned long )((int *)0)) {
#line 346
    return ((short)0);
  } else {
#line 348
    return ((short)1);
  }
}
}
#line 363 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
void showtree(int indent , mp3entry *entry ) 
{ 
  char *start ;
  int i ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 369
  if (! entry) {
#line 370
    return;
  }
  {
  {
#line 372
  tmp = malloc((size_t )(4 * indent + 1));
  }
#line 372
  start = (char *)tmp;
#line 373
  *start = (char)0;
#line 374
  i = 0;
  }
  {
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < indent)) {
#line 374
      goto while_break;
    }
    {
    {
#line 375
    sprintf((char */* __restrict  */)(start + 4 * i), (char const   */* __restrict  */)"|   ");
    }
#line 374
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  if (entry->type == 0) {
    {
    {
#line 378
    debug(1, (char *)"%s|---<%s>\n", start, entry->name);
    }
    {
#line 379
    showtree(indent + 1, entry->child);
    }
    }
  } else {
    {
    {
#line 381
    debug(1, (char *)"%s|-%s [%i:%02i-%d-%d-%i]\n", start, entry->name, entry->length / 60,
          entry->length % 60, entry->id3v1len > 0, entry->id3v2len > 0, entry->length);
    }
    }
  }
  {
  {
#line 386
  free((void *)start);
  }
  {
#line 387
  showtree(indent, entry->sibling);
  }
  }
#line 388
  return;
}
}
#line 398 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void freeentry(mp3entry *tofree ) 
{ 


  {
#line 401
  if (! tofree) {
#line 402
    return;
  }
#line 403
  if (tofree->name) {
    {
    {
#line 404
    free((void *)tofree->name);
    }
    }
  }
#line 405
  if (tofree->path) {
    {
    {
#line 406
    free((void *)tofree->path);
    }
    }
  }
#line 407
  if (tofree->title) {
    {
    {
#line 408
    free((void *)tofree->title);
    }
    }
  }
  {
  {
#line 409
  free((void *)tofree);
  }
  }
#line 410
  return;
}
}
#line 423 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
void addentry(mp3entry **baseptr , mp3entry *toadd ) 
{ 
  mp3entry *tmp ;
  mp3entry **prevptr ;
  int status ;

  {
#line 433
  prevptr = baseptr;
#line 434
  tmp = *baseptr;
  {
  {
#line 436
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 436
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 436
      goto while_break;
    }
#line 438
    if (toadd->type > tmp->type) {
#line 439
      status = 1;
    } else {
      {
      {
#line 441
      status = strcmp((char const   *)toadd->name, (char const   *)tmp->name);
      }
      }
    }
#line 443
    if (status < 0) {
#line 447
      goto while_break;
    } else
#line 448
    if (status == 0) {
      {
      {
#line 451
      freeentry(toadd);
      }
      }
#line 452
      return;
    } else {
#line 454
      prevptr = & tmp->sibling;
#line 455
      tmp = tmp->sibling;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  *prevptr = toadd;
#line 460
  toadd->sibling = tmp;
#line 461
  return;
}
}
#line 472 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
short removeentry(mp3entry **baseptr , mp3entry *toremove ) 
{ 
  short result___1 ;
  mp3entry *tmp ;
  mp3entry **prevptr ;
  char *__cil_tmp6 ;

  {
#line 475
  result___1 = (short)0;
#line 479
  prevptr = baseptr;
#line 480
  tmp = *baseptr;
  {
  {
#line 482
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 482
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 482
      if (! ((unsigned long )tmp != (unsigned long )toremove)) {
#line 482
        goto while_break;
      }
    } else {
#line 482
      goto while_break;
    }
    {
    {
#line 483
    result___1 = removeentry(& tmp->child, toremove);
    }
#line 484
    prevptr = & tmp->sibling;
#line 485
    tmp = tmp->sibling;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  if (! tmp) {
#line 489
    return (result___1);
  }
  {
  {
#line 491
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 491
    if (! tmp->child) {
#line 491
      goto while_break___0;
    }
    {
    {
#line 492
    removeentry(& tmp->child, tmp->child);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 494
  debug(3, (char *)"Removing %s\n", tmp->name);
  }
#line 495
  *prevptr = tmp->sibling;
  {
#line 496
  freeentry(tmp);
  }
  }
#line 497
  return ((short)1);
}
}
#line 508 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
void cleartree(mp3entry **rootentry ) 
{ 


  {
  {
  {
#line 511
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 511
    if (! ((unsigned long )*rootentry != (unsigned long )((void *)0))) {
#line 511
      goto while_break;
    }
    {
    {
#line 512
    removeentry(rootentry, *rootentry);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return;
}
}
#line 527 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
int writetree(void *basedest , mp3entry *baseentry ) 
{ 
  void *tmp ;
  mp3entry *from ;
  mp3entry *to ;
  int towrite ;
  int written ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 530
  tmp = basedest;
#line 531
  from = baseentry;
#line 534
  written = 0;
  {
  {
#line 536
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 536
    if (! from) {
#line 536
      goto while_break;
    }
    {
#line 537
    to = (mp3entry *)tmp;
    {
#line 538
    memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, (size_t )sizeof(mp3entry ));
    }
#line 539
    written = (int )((unsigned long )written + sizeof(mp3entry ));
#line 540
    tmp += sizeof(mp3entry );
    }
#line 542
    if (from->name) {
      {
#line 543
      to->name = (char *)tmp;
      {
#line 544
      tmp___0 = strlen((char const   *)from->name);
      }
#line 544
      towrite = (int )(tmp___0 + 1U);
      {
#line 545
      memcpy((void */* __restrict  */)to->name, (void const   */* __restrict  */)from->name,
             (size_t )towrite);
      }
#line 546
      written += towrite;
#line 547
      tmp += towrite;
      }
    }
#line 550
    if (from->path) {
      {
#line 551
      to->path = (char *)tmp;
      {
#line 552
      tmp___1 = strlen((char const   *)from->path);
      }
#line 552
      towrite = (int )(tmp___1 + 1U);
      {
#line 553
      memcpy((void */* __restrict  */)to->path, (void const   */* __restrict  */)from->path,
             (size_t )towrite);
      }
#line 554
      written += towrite;
#line 555
      tmp += towrite;
      }
    }
#line 558
    if (from->title) {
      {
#line 559
      to->title = (char *)tmp;
      {
#line 560
      tmp___2 = strlen((char const   *)from->title);
      }
#line 560
      towrite = (int )(tmp___2 + 1U);
      {
#line 561
      memcpy((void */* __restrict  */)to->title, (void const   */* __restrict  */)from->title,
             (size_t )towrite);
      }
#line 562
      written += towrite;
#line 563
      tmp += towrite;
      }
    }
#line 566
    if (from->child) {
      {
#line 567
      to->child = (struct node *)tmp;
      {
#line 568
      towrite = writetree((void *)to->child, from->child);
      }
#line 569
      written += towrite;
#line 570
      tmp += towrite;
      }
    }
#line 573
    if (from->sibling) {
#line 574
      to->sibling = (struct node *)tmp;
    }
#line 575
    from = from->sibling;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return (written);
}
}
#line 589 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
int countentries(mp3entry *baseentry ) 
{ 
  mp3entry *tmp ;
  int count ;
  int tmp___0 ;

  {
#line 592
  tmp = baseentry;
#line 593
  count = 0;
  {
  {
#line 595
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 595
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 595
      goto while_break;
    }
#line 596
    if (tmp->type == 1) {
#line 597
      count ++;
    }
    {
    {
#line 598
    tmp___0 = countentries(tmp->child);
    }
#line 598
    count += tmp___0;
#line 599
    tmp = tmp->sibling;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  return (count);
}
}
#line 613 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
int spaceneeded(mp3entry *baseentry ) 
{ 
  mp3entry *tmp ;
  int count ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 616
  tmp = baseentry;
#line 617
  count = 0;
  {
  {
#line 619
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 619
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 619
      goto while_break;
    }
#line 620
    count = (int )((unsigned long )count + sizeof(mp3entry ));
#line 621
    if (tmp->name) {
      {
      {
#line 622
      tmp___0 = strlen((char const   *)tmp->name);
      }
#line 622
      count = (int )((size_t )count + (tmp___0 + 1U));
      }
    }
#line 623
    if (tmp->path) {
      {
      {
#line 624
      tmp___1 = strlen((char const   *)tmp->path);
      }
#line 624
      count = (int )((size_t )count + (tmp___1 + 1U));
      }
    }
#line 625
    if (tmp->title) {
      {
      {
#line 626
      tmp___2 = strlen((char const   *)tmp->title);
      }
#line 626
      count = (int )((size_t )count + (tmp___2 + 1U));
      }
    }
    {
    {
#line 627
    tmp___3 = spaceneeded(tmp->child);
    }
#line 627
    count += tmp___3;
#line 628
    tmp = tmp->sibling;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  return (count);
}
}
#line 642 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
void dumpentry(mp3entry *entry ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 645
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
    {
    {
#line 646
    debug(1, (char *)"<dump of node at NULL>\n");
    }
    }
#line 647
    return;
  }
  {
  {
#line 650
  debug(1, (char *)"<dump of node at %p>\n", entry);
  }
  {
#line 651
  debug(1, (char *)"|->type: %i\n", entry->type);
  }
  }
#line 652
  if (entry->path) {
    {
    {
#line 653
    debug(1, (char *)"|->path: %p - %s\n", entry->path, entry->path);
    }
    }
  } else {
    {
    {
#line 655
    debug(1, (char *)"|->path: NULL\n");
    }
    }
  }
#line 656
  if (entry->name) {
    {
    {
#line 657
    debug(1, (char *)"|->name: %p - %s\n", entry->name, entry->name);
    }
    }
  } else {
    {
    {
#line 659
    debug(1, (char *)"|->name: NULL\n");
    }
    }
  }
  {
  {
#line 660
  debug(1, (char *)"|->filesize: %i\n", entry->filesize);
  }
  {
#line 661
  debug(1, (char *)"|->id3v1len: %i\n", entry->id3v1len);
  }
  {
#line 662
  debug(1, (char *)"|->id3v2len: %i\n", entry->id3v2len);
  }
  }
#line 663
  if (entry->title) {
    {
    {
#line 664
    debug(1, (char *)"|->title: %p - %s\n", entry->title, entry->title);
    }
    }
  } else {
    {
    {
#line 666
    debug(1, (char *)"|->title: NULL\n");
    }
    }
  }
#line 667
  if (entry->sibling) {
    {
    {
#line 668
    debug(1, (char *)"|->sibling: %p\n", entry->sibling);
    }
    }
  } else {
    {
    {
#line 670
    debug(1, (char *)"|->sibling: NULL\n");
    }
    }
  }
#line 671
  if (entry->child) {
    {
    {
#line 672
    debug(1, (char *)"|->child: %p\n", entry->child);
    }
    }
  } else {
    {
    {
#line 674
    debug(1, (char *)"|->child: NULL\n");
    }
    }
  }
#line 675
  return;
}
}
#line 689 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static int checkpathtype(char *path , mp3entry **buf ) 
{ 
  struct stat statbuf ;
  char *dirc ;
  char *basec ;
  char *bname ;
  char *dname ;
  char *owd ;
  char *cwd ;
  int retval ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 695
  retval = -1;
  {
#line 697
  tmp___1 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& statbuf));
  }
  }
#line 697
  if (tmp___1) {
    {
    {
#line 702
    tmp = __errno_location();
    }
    {
#line 702
    tmp___0 = strerror(*tmp);
    }
    {
#line 702
    logmsg((char *)"Error, unable to stat path - %s (reason: %s)\n", path, tmp___0);
    }
#line 703
    *buf = (mp3entry *)((void *)0);
    }
#line 704
    return (-1);
  }
  {
  {
#line 707
  dirc = strdup((char const   *)path);
  }
  {
#line 708
  basec = strdup((char const   *)path);
  }
  {
#line 709
  dname = dirname(dirc);
  }
  {
#line 710
  bname = __xpg_basename(basec);
  }
  }
#line 712
  if ((int )*(bname + 0) == 46) {
    {
    {
#line 714
    debug(2, (char *)"Ignoring %s, starts with .\n", path);
    }
    }
  } else
#line 715
  if ((statbuf.st_mode & 61440U) == 16384U) {
    {
    {
#line 717
    debug(2, (char *)"Valid dir %s\n", path);
    }
    {
#line 719
    tmp___2 = malloc((size_t )sizeof(mp3entry ));
    }
#line 719
    *buf = (mp3entry *)tmp___2;
    {
#line 720
    memset((void *)*buf, 0, (size_t )sizeof(mp3entry ));
    }
    {
#line 722
    (*buf)->name = strdup((char const   *)bname);
    }
#line 723
    (*buf)->type = 0;
#line 725
    retval = 0;
    }
  } else
#line 726
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
    {
#line 728
    debug(2, (char *)"Ignoring %s, not a dir and not a regular file\n", path);
    }
    }
  } else {
    {
    {
#line 729
    tmp___16 = strlen((char const   *)bname);
    }
    }
#line 729
    if (tmp___16 < 5U) {
      {
      {
#line 731
      debug(2, (char *)"Ignoring %s, too short filename\n", path);
      }
      }
    } else
#line 732
    if (statbuf.st_size == 0L) {
      {
      {
#line 734
      debug(2, (char *)"Ignoring %s, zero size\n", path);
      }
      }
    } else {
      {
      {
#line 735
      tmp___14 = strlen((char const   *)bname);
      }
      {
#line 735
      tmp___15 = strcasecmp((char const   *)((bname + tmp___14) - 4), ".mp3");
      }
      }
#line 735
      if (tmp___15) {
        {
        {
#line 769
        tmp___12 = strlen((char const   *)bname);
        }
        {
#line 769
        tmp___13 = strcasecmp((char const   *)((bname + tmp___12) - 4), ".m3u");
        }
        }
#line 769
        if (tmp___13) {
          {
          {
#line 782
          debug(2, (char *)"Ignoring %s, weird filename\n", path);
          }
          }
        } else {
          {
          {
#line 771
          debug(2, (char *)"Valid m3u file %s\n", path);
          }
          {
#line 773
          tmp___11 = malloc((size_t )sizeof(mp3entry ));
          }
#line 773
          *buf = (mp3entry *)tmp___11;
          {
#line 774
          memset((void *)*buf, 0, (size_t )sizeof(mp3entry ));
          }
          {
#line 776
          (*buf)->name = strdup((char const   *)bname);
          }
#line 777
          (*buf)->type = 0;
#line 779
          retval = 2;
          }
        }
      } else {
        {
        {
#line 737
        debug(2, (char *)"Valid mp3 file %s\n", path);
        }
        {
#line 739
        tmp___3 = malloc((size_t )sizeof(mp3entry ));
        }
#line 739
        *buf = (mp3entry *)tmp___3;
        {
#line 740
        memset((void *)*buf, 0, (size_t )sizeof(mp3entry ));
        }
        {
#line 742
        tmp___10 = strcmp((char const   *)dname, ".");
        }
        }
#line 742
        if (tmp___10) {
          {
          {
#line 749
          owd = mgetcwd();
          }
          {
#line 750
          chdir((char const   *)dname);
          }
          {
#line 751
          cwd = mgetcwd();
          }
          {
#line 753
          tmp___7 = strlen((char const   *)cwd);
          }
          {
#line 753
          tmp___8 = strlen((char const   *)bname);
          }
          {
#line 753
          tmp___9 = malloc((tmp___7 + tmp___8) + 2U);
          }
#line 753
          (*buf)->path = (char *)tmp___9;
          {
#line 755
          sprintf((char */* __restrict  */)(*buf)->path, (char const   */* __restrict  */)"%s/%s",
                  cwd, bname);
          }
          {
#line 757
          chdir((char const   *)owd);
          }
          {
#line 758
          free((void *)owd);
          }
          {
#line 759
          free((void *)cwd);
          }
          }
        } else {
          {
          {
#line 743
          cwd = mgetcwd();
          }
          {
#line 744
          tmp___4 = strlen((char const   *)cwd);
          }
          {
#line 744
          tmp___5 = strlen((char const   *)bname);
          }
          {
#line 744
          tmp___6 = malloc((tmp___4 + tmp___5) + 2U);
          }
#line 744
          (*buf)->path = (char *)tmp___6;
          {
#line 746
          sprintf((char */* __restrict  */)(*buf)->path, (char const   */* __restrict  */)"%s/%s",
                  cwd, bname);
          }
          {
#line 747
          free((void *)cwd);
          }
          }
        }
        {
        {
#line 762
        (*buf)->name = strdup((char const   *)bname);
        }
#line 763
        (*buf)->type = 1;
#line 764
        (*buf)->filesize = statbuf.st_size;
        {
#line 766
        checkmp3info(*buf);
        }
#line 767
        retval = 1;
        }
      }
    }
  }
#line 785
  if (retval == -1) {
#line 786
    *buf = (mp3entry *)((void *)0);
  }
  {
  {
#line 788
  free((void *)dirc);
  }
  {
#line 789
  free((void *)basec);
  }
  }
#line 790
  return (retval);
}
}
#line 804 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void parsedir(char *path , mp3entry **baseptr ) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  char *cwd ;
  char *owd ;
  mp3entry *filebuf ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 813
  owd = mgetcwd();
  }
  {
#line 814
  tmp = chdir((char const   *)path);
  }
  }
#line 814
  if (tmp) {
    {
    {
#line 815
    logmsg((char *)"Incorrect path for mp3 files - %s\n", path);
    }
    {
#line 816
    free((void *)owd);
    }
    }
#line 817
    return;
  } else {
    {
    {
#line 819
    cwd = mgetcwd();
    }
    }
  }
  {
  {
#line 822
  dir = opendir(".");
  }
  }
#line 822
  if (! dir) {
    {
    {
#line 823
    die((char *)"opendir()\n");
    }
    }
  }
  {
  {
#line 825
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 825
    dirent = readdir(dir);
    }
    }
#line 825
    if (! dirent) {
#line 825
      goto while_break;
    }
    {
    {
#line 827
    tmp___0 = checkpathtype(dirent->d_name, & filebuf);
    }
    }
    {
#line 828
    if (tmp___0 == 1) {
#line 828
      goto case_1;
    }
#line 831
    if (tmp___0 == 0) {
#line 831
      goto case_0;
    }
#line 839
    if (tmp___0 == 2) {
#line 839
      goto case_2;
    }
#line 842
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 829
    addentry(baseptr, filebuf);
    }
    }
#line 830
    goto switch_break;
    case_0: /* CIL Label */ 
#line 832
    if (gconf.recursive) {
      {
      {
#line 833
      addentry(baseptr, filebuf);
      }
      {
#line 834
      parsedir(dirent->d_name, & filebuf->child);
      }
      }
    } else {
      {
      {
#line 836
      freeentry(filebuf);
      }
      }
    }
#line 838
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 840
    freeentry(filebuf);
    }
    }
    switch_default: /* CIL Label */ 
#line 844
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 847
    tmp___1 = __errno_location();
    }
#line 847
    *tmp___1 = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 850
  tmp___2 = __errno_location();
  }
  }
#line 850
  if (*tmp___2) {
    {
    {
#line 851
    die((char *)"readdir()\n");
    }
    }
  }
  {
  {
#line 853
  chdir((char const   *)owd);
  }
  {
#line 854
  free((void *)owd);
  }
  {
#line 855
  free((void *)cwd);
  }
  {
#line 856
  closedir(dir);
  }
  }
#line 857
  return;
}
}
#line 869 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void parsem3u(mp3entry **baseptr , char *path ) 
{ 
  FILE *m3u ;
  mp3entry *mp3buf ;
  char line[1000] ;
  char *start ;
  char *end ;
  char *tmp ;
  char *dirc ;
  char *basec ;
  char *bname ;
  char *dname ;
  char *owd ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 880
  m3u = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
  }
#line 880
  if (! m3u) {
    {
    {
#line 881
    logmsg((char *)"Unable to open .m3u file %s\n", path);
    }
    }
#line 882
    return;
  }
  {
  {
#line 885
  dirc = strdup((char const   *)path);
  }
  {
#line 886
  basec = strdup((char const   *)path);
  }
  {
#line 887
  dname = dirname(dirc);
  }
  {
#line 888
  bname = __xpg_basename(basec);
  }
  {
#line 889
  owd = mgetcwd();
  }
  {
#line 890
  chdir((char const   *)dname);
  }
  }
  {
  {
#line 892
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 892
    tmp___8 = fgets((char */* __restrict  */)(line), 1000, (FILE */* __restrict  */)m3u);
    }
    }
#line 892
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 892
      goto while_break;
    }
#line 893
    start = line;
    {
    {
#line 893
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 893
      if ((unsigned long )start != (unsigned long )((void *)0)) {
        {
        {
#line 893
        tmp___0 = __ctype_b_loc();
        }
        }
#line 893
        if (! ((int const   )*(*tmp___0 + (int )*start) & 8192)) {
#line 893
          goto while_break___0;
        }
      } else {
#line 893
        goto while_break___0;
      }
#line 893
      start ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 895
    if (! start) {
#line 897
      goto while_continue;
    } else
#line 895
    if ((int )*start == 35) {
#line 897
      goto while_continue;
    } else
#line 895
    if ((int )*start == 0) {
#line 897
      goto while_continue;
    } else {
      {
      {
#line 895
      tmp___1 = strlen((char const   *)start);
      }
      }
#line 895
      if (tmp___1 < 1U) {
#line 897
        goto while_continue;
      }
    }
    {
    {
#line 899
    tmp___2 = strlen((char const   *)start);
    }
#line 899
    end = start + tmp___2;
    }
    {
    {
#line 899
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 899
      if (! ((int )*end == 0)) {
        {
        {
#line 899
        tmp___3 = __ctype_b_loc();
        }
        }
#line 899
        if (! ((int const   )*(*tmp___3 + (int )*end) & 8192)) {
#line 899
          if (! ((int )*end == 10)) {
#line 899
            goto while_break___1;
          }
        }
      }
#line 899
      end --;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 901
    end ++;
#line 902
    *end = (char )'\000';
    {
#line 904
    tmp___4 = strlen((char const   *)start);
    }
    {
#line 904
    tmp___5 = malloc(tmp___4 + 1U);
    }
#line 904
    tmp = (char *)tmp___5;
    {
#line 905
    tmp___6 = strlen((char const   *)start);
    }
    {
#line 905
    snprintf((char */* __restrict  */)tmp, tmp___6 + 1U, (char const   */* __restrict  */)"%s",
             start);
    }
    {
#line 907
    tmp___7 = checkpathtype(tmp, & mp3buf);
    }
    }
    {
#line 908
    if (tmp___7 == 1) {
#line 908
      goto case_1;
    }
#line 911
    if (tmp___7 == -1) {
#line 911
      goto case_neg_1;
    }
#line 913
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 909
    addentry(baseptr, mp3buf);
    }
    }
#line 910
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 912
    goto while_continue;
    switch_default: /* CIL Label */ 
    {
    {
#line 915
    freeentry(mp3buf);
    }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 919
    free((void *)tmp);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 922
  chdir((char const   *)owd);
  }
  {
#line 923
  free((void *)owd);
  }
  {
#line 924
  free((void *)dirc);
  }
  {
#line 925
  free((void *)basec);
  }
  {
#line 926
  fclose(m3u);
  }
  }
#line 927
  return;
}
}
#line 938 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
void indexpaths(char **patharray ) 
{ 
  int i ;
  mp3entry *mp3buf ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 945
  if (! patharray) {
#line 946
    return;
  }
#line 948
  i = 0;
  {
  {
#line 948
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 948
    if (! ((unsigned long )*(patharray + i) != (unsigned long )((void *)0))) {
#line 948
      goto while_break;
    }
    {
    {
#line 949
    debug(1, (char *)"Checking path for mp3 files - %s\n", *(patharray + i));
    }
    {
#line 951
    tmp = checkpathtype(*(patharray + i), & mp3buf);
    }
    }
    {
#line 952
    if (tmp == -1) {
#line 952
      goto case_neg_1;
    }
#line 954
    if (tmp == 1) {
#line 954
      goto case_1;
    }
#line 957
    if (tmp == 2) {
#line 957
      goto case_2;
    }
#line 961
    if (tmp == 0) {
#line 961
      goto case_0;
    }
#line 965
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 953
    goto __Cont;
    case_1: /* CIL Label */ 
    {
    {
#line 955
    addentry(& root, mp3buf);
    }
    }
#line 956
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 958
    freeentry(mp3buf);
    }
    {
#line 959
    parsem3u(& root, *(patharray + i));
    }
    }
#line 960
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 962
    freeentry(mp3buf);
    }
    {
#line 963
    parsedir(*(patharray + i), & root);
    }
    }
#line 964
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 966
    logmsg((char *)"Indexpaths: we should never end up here\n");
    }
    }
#line 967
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 948
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  return;
}
}
#line 30 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.c"
static int valof(char c ) 
{ 
  char *alphabet ;
  char *tmp ;
  int i ;
  char *__cil_tmp5 ;

  {
#line 33
  alphabet = (char *)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
#line 35
  tmp = alphabet;
#line 36
  i = 0;
#line 38
  if ((int )c == 0) {
#line 39
    return (-1);
  }
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 42
    if ((int )*tmp == 0) {
#line 43
      return (-1);
    }
#line 44
    if ((int )*tmp == (int )c) {
#line 45
      return (i);
    }
#line 46
    i ++;
#line 47
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 51 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.c"
short isbase64(char c ) 
{ 
  int tmp ;

  {
  {
  {
#line 54
  tmp = valof(c);
  }
  }
#line 54
  if (tmp >= 0) {
#line 55
    return ((short)1);
  } else {
#line 57
    return ((short)0);
  }
}
}
#line 60 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.c"
static void nextchunk(char **c , char *chunk ) 
{ 
  int i ;
  int b64val[4] ;
  void *__cil_tmp5 ;

  {
#line 66
  i = 0;
  {
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < 4)) {
#line 66
      goto while_break;
    }
#line 67
    if ((int )*(*c) != 0) {
      {
      {
#line 68
      b64val[i] = valof(*(*c));
      }
#line 69
      (*c) ++;
      }
    } else {
#line 71
      b64val[i] = '\000';
    }
#line 66
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  *(chunk + 0) = (char )((b64val[0] << 2) | ((b64val[1] & 48) >> 4));
#line 76
  *(chunk + 1) = (char )(((b64val[1] & 15) << 4) | ((b64val[2] & 60) >> 2));
#line 77
  *(chunk + 2) = (char )(((b64val[2] & 3) << 6) | b64val[3]);
#line 79
  return;
}
}
#line 81 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.c"
char *b64dec(char *msg ) 
{ 
  char *tmp ;
  char *buffer ;
  char chunk[4] ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp7 ;

  {
#line 84
  tmp = msg;
#line 88
  if ((int )*tmp == 0) {
#line 89
    return ((char *)((void *)0));
  }
  {
  {
#line 91
  memset((void *)(chunk), 0, (size_t )sizeof(chunk));
  }
  {
#line 92
  tmp___0 = strlen((char const   *)msg);
  }
  {
#line 92
  tmp___1 = malloc(tmp___0 + 1U);
  }
#line 92
  buffer = (char *)tmp___1;
#line 93
  *buffer = (char )'\000';
  }
  {
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((int )*tmp != 0)) {
#line 95
      goto while_break;
    }
    {
    {
#line 96
    nextchunk(& tmp, chunk);
    }
    {
#line 97
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)(chunk));
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (buffer);
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 684
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 119
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 133
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 148
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 190
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 368 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 370
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 228
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 255
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 181 "/usr/include/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 59 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.h"
struct global_config gconf  ;
#line 60 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.h"
struct childstat *childarray  ;
#line 67 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int volatile   num_clients  =    (int volatile   )0;
#line 83 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int opentcpconn(void) 
{ 
  struct sockaddr_in address ;
  int opt ;
  int sock ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 87
  opt = 1;
  {
#line 90
  sock = socket(2, 1, 0);
  }
  }
#line 90
  if (sock < 0) {
    {
    {
#line 91
    die((char *)"failed to open tcp socket\n");
    }
    }
  }
  {
  {
#line 93
  setsockopt(sock, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
  }
#line 94
  address.sin_family = (sa_family_t )2;
  {
#line 95
  address.sin_port = htons((uint16_t )gconf.port);
  }
  {
#line 96
  memset((void *)(& address.sin_addr), 0, (size_t )sizeof(address.sin_addr));
  }
  {
#line 98
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& address)), (socklen_t )sizeof(struct sockaddr_in ));
  }
  }
#line 98
  if (tmp) {
    {
    {
#line 99
    die((char *)"failed to bind tcp socket\n");
    }
    }
  }
  {
  {
#line 101
  tmp___0 = listen(sock, 5);
  }
  }
#line 101
  if (tmp___0) {
    {
    {
#line 102
    die((char *)"failed to listen to tcp socket\n");
    }
    }
  }
  {
  {
#line 104
  debug(1, (char *)"Opened TCP socket, port %d\n", gconf.port);
  }
  }
#line 105
  return (sock);
}
}
#line 117 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int openudpconn(void) 
{ 
  struct sockaddr_in address ;
  int sock ;
  int socklen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 122
  socklen = (int )sizeof(struct sockaddr_in );
  {
#line 124
  sock = socket(2, 2, 0);
  }
  }
#line 124
  if (sock < 0) {
    {
    {
#line 125
    die((char *)"failed to open udp socket\n");
    }
    }
  }
  {
  {
#line 127
  memset((void *)(& address.sin_addr), 0, (size_t )sizeof(address.sin_addr));
  }
#line 128
  address.sin_family = (sa_family_t )2;
#line 129
  address.sin_port = (in_port_t )0;
  {
#line 130
  address.sin_addr.s_addr = htonl((in_addr_t )2130706433);
  }
  {
#line 132
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& address)), (socklen_t )socklen);
  }
  }
#line 132
  if (tmp) {
    {
    {
#line 133
    logmsg((char *)"failed to bind udp socket\n");
    }
    }
  }
  {
  {
#line 135
  tmp___0 = getsockname(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& address)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
  }
#line 135
  if (tmp___0 < 0) {
    {
    {
#line 136
    logmsg((char *)"failed to get name of udp socket\n");
    }
    }
  }
  {
  {
#line 138
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& address)),
                    (socklen_t )socklen);
  }
  }
#line 138
  if (tmp___1) {
    {
    {
#line 139
    logmsg((char *)"failed to connect udp socket\n");
    }
    }
  }
  {
  {
#line 141
  tmp___2 = ntohs(address.sin_port);
  }
  {
#line 141
  debug(1, (char *)"Opened UDP socket, port %d\n", (int )tmp___2);
  }
  }
#line 142
  return (sock);
}
}
#line 153 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void getudpmessage(int udpsock ) 
{ 
  char buffer[1024] ;
  char *tmp ;
  int childpid ;
  int i ;
  ssize_t tmp___0 ;
  long tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 162
  memset((void *)(buffer), '\000', (size_t )sizeof(buffer));
  }
  {
#line 163
  tmp___0 = recv(udpsock, (void *)(buffer), (size_t )(sizeof(buffer) - 1UL), 0);
  }
  }
#line 163
  if (tmp___0 < 0) {
    {
    {
#line 164
    debug(1, (char *)"recv failed\n");
    }
    }
#line 165
    return;
  }
#line 168
  tmp = buffer;
  {
  {
#line 169
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 169
    if ((int )*tmp != 0) {
#line 169
      if (! ((int )*tmp != 58)) {
#line 169
        goto while_break;
      }
    } else {
#line 169
      goto while_break;
    }
#line 170
    tmp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if ((int )*tmp == 0) {
    {
    {
#line 172
    debug(1, (char *)"Erroneous status message from client!\n");
    }
    }
#line 173
    return;
  }
  {
#line 176
  *tmp = (char )'\000';
#line 177
  tmp ++;
  {
#line 178
  tmp___1 = strtol((char const   */* __restrict  */)(buffer), (char **/* __restrict  */)((void *)0),
                   10);
  }
#line 178
  childpid = (int )tmp___1;
  }
#line 179
  if (childpid < 1) {
    {
    {
#line 180
    debug(1, (char *)"Erroneous status message from client!\n");
    }
    }
#line 181
    return;
  }
#line 184
  i = 0;
  {
  {
#line 184
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! (i < gconf.max_clients)) {
#line 184
      goto while_break___0;
    }
#line 185
    if ((childarray + i)->childpid == childpid) {
#line 186
      if ((childarray + i)->status) {
        {
        {
#line 187
        free((void *)(childarray + i)->status);
        }
        }
      }
      {
      {
#line 188
      (childarray + i)->status = strdup((char const   *)tmp);
      }
      {
#line 189
      debug(1, (char *)"Status message from %i: %s\n", childpid, tmp);
      }
      }
#line 190
      goto while_break___0;
    }
#line 184
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 204 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void sigchild_handler(int signal___0 ) 
{ 
  int i ;
  pid_t pid ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 210
  num_clients -= (int volatile   )1;
  {
#line 211
  pid = wait((union wait *)(& i));
  }
#line 212
  i = 0;
  }
  {
  {
#line 212
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((childarray + i)->childpid != pid)) {
#line 212
      goto while_break;
    }
#line 212
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  (childarray + i)->childpid = 0;
#line 214
  if ((childarray + i)->status) {
    {
    {
#line 215
    free((void *)(childarray + i)->status);
    }
    }
  }
#line 216
  if ((childarray + i)->client) {
    {
    {
#line 217
    free((void *)(childarray + i)->client);
    }
    }
  }
  {
  {
#line 219
  debug(1, (char *)"child with pid %u exited, currently %d/%d client(s)\n", pid, num_clients,
        gconf.max_clients);
  }
#line 220
  i = 0;
  }
  {
  {
#line 220
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (i < gconf.max_clients)) {
#line 220
      goto while_break___0;
    }
#line 221
    if ((childarray + i)->childpid != 0) {
      {
      {
#line 222
      debug(1, (char *)"I have child %u alive with status %s\n", (childarray + i)->childpid,
            (childarray + i)->status);
      }
      }
    }
#line 220
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 252 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static short issocket(int fd ) 
{ 
  int v ;
  socklen_t l ;
  int tmp ;

  {
  {
#line 258
  l = (socklen_t )sizeof(int );
  {
#line 259
  tmp = getsockopt(fd, 1, 3, (void */* __restrict  */)((void *)(& v)), (socklen_t */* __restrict  */)(& l));
  }
  }
#line 259
  return ((short )(tmp == 0));
}
}
#line 271 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void daemonize(void) 
{ 
  pid_t pid ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 277
  umask((__mode_t )18);
  }
  }
#line 279
  if (gconf.trace) {
#line 280
    return;
  } else
#line 279
  if (gconf.inetd) {
#line 280
    return;
  }
  {
  {
#line 282
  pid = fork();
  }
  }
#line 282
  if (pid > 0) {
    {
    {
#line 283
    exit(0);
    }
    }
  } else
#line 284
  if (pid < 0) {
    {
    {
#line 285
    die((char *)"fork");
    }
    }
  }
  {
  {
#line 287
  setsid();
  }
  {
#line 289
  pid = fork();
  }
  }
#line 289
  if (pid > 0) {
    {
    {
#line 290
    exit(0);
    }
    }
  } else
#line 291
  if (pid < 0) {
    {
    {
#line 292
    die((char *)"fork");
    }
    }
  }
#line 293
  return;
}
}
#line 301 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void preparelog(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 305
  signal(1, (void (*)(int  ))1);
  }
  }
#line 306
  if (! gconf.trace) {
    {
    {
#line 307
    openlog("ample", 3, 3 << 3);
    }
    {
#line 308
    fclose(stdout);
    }
    {
#line 309
    fclose(stderr);
    }
    }
  }
#line 328
  if (! gconf.inetd) {
    {
    {
#line 329
    fclose(stdin);
    }
    }
  }
#line 331
  return;
}
}
#line 344 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static short check_access(int conn , struct sockaddr_in *address ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 367
  if (! gconf.inetd) {
#line 367
    if (num_clients >= (int volatile   )gconf.max_clients) {
      {
      {
#line 368
      tmp = inet_ntoa(address->sin_addr);
      }
      {
#line 368
      logmsg((char *)"Connection from %s:%d denied, max clients exceeded\n", tmp,
             (int )address->sin_port);
      }
      {
#line 370
      close(conn);
      }
      }
#line 371
      return ((short)0);
    }
  }
#line 375
  if (gconf.inetd) {
    {
    {
#line 376
    tmp___0 = inet_ntoa(address->sin_addr);
    }
    {
#line 376
    logmsg((char *)"Connection from %s:%d accepted\n", tmp___0, (int )address->sin_port);
    }
    }
  } else {
    {
    {
#line 379
    tmp___1 = inet_ntoa(address->sin_addr);
    }
    {
#line 379
    logmsg((char *)"Connection from %s:%d accepted, currently %d/%d clients\n", tmp___1,
           (int )address->sin_port, num_clients + (int volatile   )1, gconf.max_clients);
    }
    }
  }
#line 383
  return ((short)1);
}
}
#line 396 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int accept_connection(struct sockaddr_in *address , int tcpsock , int udpsock ) 
{ 
  fd_set readfds ;
  int conn ;
  int addrlen ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 401
  addrlen = (int )sizeof(struct sockaddr_in );
#line 403
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 404
    return (0);
  } else
#line 403
  if (tcpsock < 0) {
#line 404
    return (0);
  }
  {
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 407
    if (! gconf.inetd) {
      {
      {
#line 408
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 408
        __asm__  volatile   ("cld; rep; "
                             "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds.__fds_bits[0]): "memory");
#line 408
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 409
      readfds.__fds_bits[tcpsock / (8 * (int )sizeof(__fd_mask ))] |= 1L << tcpsock % (8 * (int )sizeof(__fd_mask ));
#line 410
      readfds.__fds_bits[udpsock / (8 * (int )sizeof(__fd_mask ))] |= 1L << udpsock % (8 * (int )sizeof(__fd_mask ));
#line 411
      if (tcpsock > udpsock) {
#line 411
        tmp = tcpsock;
      } else {
#line 411
        tmp = udpsock;
      }
      {
      {
#line 411
      conn = select(tmp + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
      }
#line 413
      if (conn < 0) {
        {
        {
#line 413
        tmp___0 = __errno_location();
        }
        }
#line 413
        if (*tmp___0 == 4) {
#line 414
          goto while_continue;
        } else {
#line 413
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 415
      if (conn < 0) {
        {
        {
#line 416
        die((char *)"select()\n");
        }
        }
      }
#line 418
      if ((readfds.__fds_bits[udpsock / (8 * (int )sizeof(__fd_mask ))] & (1L << udpsock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
        {
#line 419
        getudpmessage(udpsock);
        }
        }
      }
#line 421
      if (! ((readfds.__fds_bits[tcpsock / (8 * (int )sizeof(__fd_mask ))] & (1L << tcpsock % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 422
        goto while_continue;
      }
      {
      {
#line 424
      conn = accept(tcpsock, (struct sockaddr */* __restrict  */)((struct sockaddr *)address),
                    (socklen_t */* __restrict  */)(& addrlen));
      }
      }
#line 424
      if (conn < 0) {
        {
        {
#line 426
        tmp___1 = __errno_location();
        }
        }
#line 426
        if (*tmp___1 == 4) {
#line 427
          goto while_continue;
        } else {
          {
          {
#line 429
          die((char *)"accept");
          }
          }
        }
      }
#line 432
      goto while_break;
    } else {
      {
#line 435
      conn = 0;
      {
#line 436
      getpeername(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)address),
                  (socklen_t */* __restrict  */)(& addrlen));
      }
      }
#line 437
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return (conn);
}
}
#line 450 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
int main(int argc , char **argv ) 
{ 
  struct sockaddr_in address ;
  int i ;
  int conn ;
  int tcpsock ;
  int udpsock ;
  pid_t pid ;
  struct sigaction sa ;
  sigset_t chld ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  short tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 460
  checkopt(argc, argv);
  }
  {
#line 461
  gconf.inetd = issocket(0);
  }
  {
#line 462
  daemonize();
  }
  {
#line 463
  preparelog();
  }
  }
#line 464
  if (! gconf.inetd) {
    {
    {
#line 465
    logmsg((char *)"Ample/%s started\n", "0.5.7");
    }
    }
  }
  {
  {
#line 468
  tmp = malloc((size_t )((unsigned long )gconf.max_clients * sizeof(struct childstat )));
  }
#line 468
  childarray = (struct childstat *)tmp;
#line 470
  i = 0;
  }
  {
  {
#line 470
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 470
    if (! (i < gconf.max_clients)) {
#line 470
      goto while_break;
    }
#line 471
    (childarray + i)->childpid = 0;
#line 472
    (childarray + i)->status = (char *)((void *)0);
#line 473
    (childarray + i)->client = (char *)((void *)0);
#line 470
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 477
  indexpaths(gconf.pathlist);
  }
  {
#line 478
  tmp___0 = countentries(root);
  }
  }
#line 478
  if (! tmp___0) {
    {
    {
#line 479
    die((char *)"No files found\n");
    }
    }
  }
  {
  {
#line 480
  tmp___1 = chdir("/");
  }
  }
#line 480
  if (tmp___1 < 0) {
    {
    {
#line 481
    die((char *)"chdir()\n");
    }
    }
  }
  {
  {
#line 484
  tmp___2 = countentries(root);
  }
  {
#line 484
  debug(1, (char *)"Indexed %i file(s)\n", tmp___2);
  }
  {
#line 485
  showtree(0, root);
  }
  {
#line 488
  memset((void *)(& sa), 0, (size_t )sizeof(sa));
  }
#line 489
  sa.__sigaction_handler.sa_handler = & sigchild_handler;
  {
#line 490
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 491
  sigemptyset(& chld);
  }
  {
#line 492
  sigaddset(& chld, 17);
  }
  }
#line 499
  if (! gconf.inetd) {
    {
    {
#line 500
    udpsock = openudpconn();
    }
    {
#line 501
    tcpsock = opentcpconn();
    }
    }
  } else {
#line 503
    udpsock = -1;
#line 504
    tcpsock = 0;
  }
  restart: 
  {
  {
#line 509
  conn = accept_connection(& address, tcpsock, udpsock);
  }
  {
#line 512
  tmp___3 = check_access(conn, & address);
  }
  }
#line 512
  if (! tmp___3) {
#line 513
    goto restart;
  }
  {
  {
#line 516
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& chld), (sigset_t */* __restrict  */)((void *)0));
  }
#line 517
  num_clients += (int volatile   )1;
  }
#line 520
  if (gconf.trace) {
#line 520
    goto _L;
  } else
#line 520
  if (gconf.inetd) {
    _L: /* CIL Label */ 
    {
    {
#line 521
    tmp___4 = inet_ntoa(address.sin_addr);
    }
    {
#line 521
    debug(1, (char *)"No-fork/inetd mode: connection from %s:%d\n", tmp___4, (int )address.sin_port);
    }
    {
#line 523
    handleclient(conn, udpsock);
    }
#line 524
    num_clients -= (int volatile   )1;
    {
#line 525
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& chld), (sigset_t */* __restrict  */)((void *)0));
    }
    }
#line 526
    return (0);
  }
  {
  {
#line 530
  pid = fork();
  }
  }
#line 530
  if (pid < 0) {
    {
    {
#line 531
    die((char *)"fork()\n");
    }
    }
  }
#line 533
  if (pid > 0) {
    {
    {
#line 535
    tmp___5 = inet_ntoa(address.sin_addr);
    }
    {
#line 535
    debug(1, (char *)"Connection from %s:%d handled by child with pid %u\n", tmp___5,
          (int )address.sin_port, pid);
    }
#line 537
    i = 0;
    }
    {
    {
#line 537
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 537
      if (! ((childarray + i)->childpid != 0)) {
#line 537
        goto while_break___0;
      }
#line 537
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 540
    tmp___7 = malloc((size_t )22);
    }
#line 540
    tmp___6 = (char *)tmp___7;
#line 540
    (childarray + i)->client = tmp___6;
    }
#line 540
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
      {
      {
#line 541
      die((char *)"malloc");
      }
      }
    }
    {
    {
#line 542
    tmp___8 = inet_ntoa(address.sin_addr);
    }
    {
#line 542
    snprintf((char */* __restrict  */)(childarray + i)->client, (size_t )22, (char const   */* __restrict  */)"%s:%d",
             tmp___8, (int )address.sin_port);
    }
    {
#line 544
    (childarray + i)->status = strdup("Starting");
    }
#line 545
    (childarray + i)->childpid = pid;
    {
#line 547
    sigprocmask(1, (sigset_t const   */* __restrict  */)(& chld), (sigset_t */* __restrict  */)((void *)0));
    }
    {
#line 548
    close(conn);
    }
    }
#line 549
    goto restart;
  } else {
    {
    {
#line 552
    close(tcpsock);
    }
    {
#line 553
    tmp___9 = handleclient(conn, udpsock);
    }
    }
#line 553
    return (tmp___9);
  }
#line 557
  if (! tcpsock) {
    {
    {
#line 558
    close(tcpsock);
    }
    }
  }
#line 559
  return (0);
}
}
#line 124 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static void printlogmsg___0(int type , char *fmt , va_list argp ) 
{ 
  char buffer[1000] ;
  int length ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  __pid_t tmp___6 ;
  __pid_t tmp___7 ;
  int *tmp___8 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 130
  length = vsnprintf((char */* __restrict  */)(buffer), (size_t )1000, (char const   */* __restrict  */)fmt,
                     argp);
  }
  {
#line 131
  sprintf((char */* __restrict  */)(& buffer[992]), (char const   */* __restrict  */)"<TRUNC>");
  }
  }
#line 134
  if (! gconf.trace) {
#line 135
    if (type == 0) {
      {
      {
#line 136
      syslog(6, "%s", buffer);
      }
      }
    } else
#line 137
    if (type == 1) {
      {
      {
#line 138
      syslog(7, "%s", buffer);
      }
      }
    } else
#line 139
    if (type == 2) {
      {
      {
#line 140
      tmp___1 = __errno_location();
      }
      }
#line 140
      if (*tmp___1 != 0) {
        {
        {
#line 141
        tmp = __errno_location();
        }
        {
#line 141
        tmp___0 = strerror(*tmp);
        }
        {
#line 141
        syslog(3, "died - %s, errno: %s", buffer, tmp___0);
        }
        }
      } else {
        {
        {
#line 144
        syslog(3, "died - %s", buffer);
        }
        }
      }
      {
      {
#line 145
      exit(1);
      }
      }
    }
#line 147
    return;
  }
#line 151
  if (type == 0) {
    {
    {
#line 152
    tmp___2 = getpid();
    }
    {
#line 152
    printf((char const   */* __restrict  */)"LOG[%d]: %s", tmp___2, buffer);
    }
    }
  } else
#line 153
  if (type == 1) {
    {
    {
#line 154
    tmp___3 = getpid();
    }
    {
#line 154
    printf((char const   */* __restrict  */)"DBG[%d]: %s", tmp___3, buffer);
    }
    }
  } else
#line 155
  if (type == 2) {
    {
    {
#line 156
    tmp___8 = __errno_location();
    }
    }
#line 156
    if (*tmp___8 != 0) {
      {
      {
#line 157
      tmp___4 = __errno_location();
      }
      {
#line 157
      tmp___5 = strerror(*tmp___4);
      }
      {
#line 157
      tmp___6 = getpid();
      }
      {
#line 157
      printf((char const   */* __restrict  */)"DIE[%d]: (errno: %s) %s", tmp___6,
             tmp___5, buffer);
      }
      }
    } else {
      {
      {
#line 160
      tmp___7 = getpid();
      }
      {
#line 160
      printf((char const   */* __restrict  */)"DIE[%d]: %s", tmp___7, buffer);
      }
      }
    }
    {
    {
#line 161
    exit(1);
    }
    }
  }
  {
  {
#line 163
  fflush(stdout);
  }
  }
#line 164
  return;
}
}
#line 233 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static void expandmalloc___0(void **old , size_t *size , int line ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 235
  *size *= 2U;
  {
#line 236
  debug(4, (char *)"called from %i, gonna realloc with size %i and old %p\n", line,
        *size, *old);
  }
  {
#line 238
  *old = realloc(*old, *size);
  }
  }
#line 239
  if ((unsigned long )*old == (unsigned long )((void *)0)) {
    {
    {
#line 240
    die((char *)"realloc failed\n");
    }
    }
  }
#line 241
  return;
}
}
#line 307 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static char *commonencode___0(char *toencode , short url ) 
{ 
  char *validchars ;
  char *urlprefix ;
  char *htmlprefix ;
  char *urlsuffix ;
  char *htmlsuffix ;
  char *prefix ;
  char *suffix ;
  char *tmp ;
  char *tmp2 ;
  char *retval ;
  char buffer[3] ;
  size_t size ;
  size_t used ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 309
  validchars = (char *)"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";
#line 310
  urlprefix = (char *)"%";
#line 311
  htmlprefix = (char *)"&#x";
#line 312
  urlsuffix = (char *)"";
#line 313
  htmlsuffix = (char *)";";
#line 320
  size = (size_t )100;
#line 321
  used = (size_t )1;
#line 323
  if (url) {
#line 324
    prefix = urlprefix;
#line 325
    suffix = urlsuffix;
  } else {
#line 327
    prefix = htmlprefix;
#line 328
    suffix = htmlsuffix;
  }
  {
  {
#line 331
  tmp___0 = malloc(size);
  }
#line 331
  retval = (char *)tmp___0;
  }
#line 332
  if ((unsigned long )retval == (unsigned long )((void *)0)) {
    {
    {
#line 333
    die((char *)"malloc failed\n");
    }
    }
  }
#line 334
  *retval = (char )'\000';
#line 336
  tmp = toencode;
  {
  {
#line 336
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 336
    if (! ((int )*tmp != 0)) {
#line 336
      goto while_break;
    }
    {
    {
#line 337
    tmp___1 = strlen((char const   *)prefix);
    }
    {
#line 337
    tmp___2 = strlen((char const   *)suffix);
    }
    }
#line 337
    if (size - used < (tmp___1 + 2U) + tmp___2) {
      {
      {
#line 338
      expandmalloc___0((void **)(& retval), & size, 338);
      }
      }
    }
#line 339
    tmp2 = validchars;
    {
    {
#line 339
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 339
      if (! ((int )*tmp2 != 0)) {
#line 339
        goto while_break___0;
      }
#line 340
      if ((int )*tmp == (int )*tmp2) {
#line 341
        goto while_break___0;
      }
#line 339
      tmp2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 344
    if ((int )*tmp2 != 0) {
      {
#line 345
      buffer[0] = *tmp2;
#line 346
      buffer[1] = (char )'\000';
      {
#line 347
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)(buffer));
      }
#line 348
      used ++;
      }
    } else {
      {
      {
#line 350
      snprintf((char */* __restrict  */)(buffer), (size_t )3, (char const   */* __restrict  */)"%.2x",
               (int )((unsigned char )*tmp));
      }
      {
#line 351
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)prefix);
      }
      {
#line 352
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)(buffer));
      }
      {
#line 353
      strcat((char */* __restrict  */)retval, (char const   */* __restrict  */)suffix);
      }
      {
#line 354
      tmp___3 = strlen((char const   *)prefix);
      }
      {
#line 354
      tmp___4 = strlen((char const   *)suffix);
      }
#line 354
      used += (tmp___3 + 2U) + tmp___4;
      }
    }
#line 336
    tmp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (retval);
}
}
#line 404 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static char *result___0  =    (char *)((void *)0);
#line 551 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static char *findfqdn___0(struct hostent *host ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
  {
#line 556
  tmp___0 = strchr((char const   *)host->h_name, '.');
  }
  }
#line 556
  if (tmp___0) {
    {
    {
#line 557
    tmp = strdup((char const   *)host->h_name);
    }
    }
#line 557
    return (tmp);
  }
#line 559
  i = 0;
  {
  {
#line 559
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 559
    if (! ((unsigned long )*(host->h_aliases + i) != (unsigned long )((void *)0))) {
#line 559
      goto while_break;
    }
    {
    {
#line 560
    tmp___4 = strchr((char const   *)*(host->h_aliases + i), '.');
    }
    }
#line 560
    if (tmp___4) {
      {
      {
#line 562
      tmp___2 = strlen((char const   *)host->h_name);
      }
      {
#line 562
      tmp___3 = strncasecmp((char const   *)*(host->h_aliases + i), (char const   *)host->h_name,
                            tmp___2);
      }
      }
#line 562
      if (! tmp___3) {
        {
        {
#line 563
        tmp___1 = strdup((char const   *)*(host->h_aliases + i));
        }
        }
#line 563
        return (tmp___1);
      }
    }
#line 559
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return ((char *)((void *)0));
}
}
#line 659 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static void stripspaces___0(char *buffer ) 
{ 
  int i ;

  {
#line 662
  i = 0;
  {
  {
#line 664
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 664
    if (! ((int )*(buffer + i) != 0)) {
#line 664
      goto while_break;
    }
#line 665
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 667
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 667
    if (! (i >= 0)) {
#line 667
      goto while_break___0;
    }
#line 668
    if ((int )*(buffer + i) == 32) {
#line 669
      *(buffer + i) = (char )'\000';
    } else
#line 670
    if (! ((int )*(buffer + i) == 0)) {
#line 673
      goto while_break___0;
    }
#line 667
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 675
  return;
}
}
#line 686 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static short setid3v1title___0(FILE *file , mp3entry *entry ) 
{ 
  char buffer[31] ;
  int offsets[3] ;
  int i ;
  char *result___1 ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 690
  offsets[0] = -95;
#line 690
  offsets[1] = -65;
#line 690
  offsets[2] = -125;
  {
#line 694
  tmp = malloc((size_t )97);
  }
#line 694
  result___1 = (char *)tmp;
#line 695
  *result___1 = (char )'\000';
#line 697
  i = 0;
  }
  {
  {
#line 697
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 697
    if (! (i < 3)) {
#line 697
      goto while_break;
    }
    {
    {
#line 698
    tmp___0 = fseek(file, (long )offsets[i], 2);
    }
    }
#line 698
    if (tmp___0 != 0) {
      {
      {
#line 699
      free((void *)result___1);
      }
      }
#line 700
      return ((short)0);
    }
    {
    {
#line 704
    fgets((char */* __restrict  */)(buffer), 31, (FILE */* __restrict  */)file);
    }
    {
#line 705
    stripspaces___0(buffer);
    }
    }
#line 706
    if ((int )buffer[0] != 0) {
#line 706
      if ((int )*result___1 != 0) {
        {
        {
#line 707
        strcat((char */* __restrict  */)result___1, (char const   */* __restrict  */)" - ");
        }
        }
      }
    }
    {
    {
#line 708
    strcat((char */* __restrict  */)result___1, (char const   */* __restrict  */)(buffer));
    }
#line 697
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 711
  if ((int )*result___1 == 0) {
    {
    {
#line 712
    free((void *)result___1);
    }
    }
#line 713
    return ((short)0);
  } else {
    {
    {
#line 715
    tmp___1 = strlen((char const   *)result___1);
    }
    {
#line 715
    tmp___2 = realloc((void *)result___1, tmp___1 + 1U);
    }
#line 715
    entry->title = (char *)tmp___2;
    }
#line 716
    return ((short)1);
  }
}
}
#line 729 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static short setid3v2title___0(FILE *file , mp3entry *entry ) 
{ 
  char *buffer ;
  int minframesize ;
  int size ;
  int readsize ;
  int headerlen ;
  char *title ;
  char *artist ;
  char header[10] ;
  unsigned short version ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 734
  readsize = 0;
#line 735
  title = (char *)((void *)0);
#line 736
  artist = (char *)((void *)0);
#line 741
  if (entry->id3v2len < 10) {
#line 742
    return ((short)0);
  }
  {
  {
#line 745
  fseek(file, 0L, 0);
  }
  {
#line 746
  fread((void */* __restrict  */)(header), (size_t )sizeof(char ), (size_t )10, (FILE */* __restrict  */)file);
  }
#line 747
  version = (unsigned short )header[3];
#line 750
  size = entry->id3v2len - 10;
  {
#line 751
  tmp = malloc((size_t )(size + 1));
  }
#line 751
  buffer = (char *)tmp;
  {
#line 752
  tmp___0 = fread((void */* __restrict  */)buffer, (size_t )sizeof(char ), (size_t )size,
                  (FILE */* __restrict  */)file);
  }
  }
#line 752
  if (size != (int )tmp___0) {
    {
    {
#line 753
    free((void *)buffer);
    }
    }
#line 754
    return ((short)0);
  }
#line 756
  *(buffer + size) = (char )'\000';
#line 759
  if ((int )version > 2) {
#line 760
    minframesize = 12;
  } else {
#line 762
    minframesize = 8;
  }
  {
  {
#line 768
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 768
    if (! (size - readsize > minframesize)) {
#line 768
      goto while_break;
    }
#line 771
    if ((int )version > 2) {
      {
      {
#line 772
      memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)(buffer + readsize),
             (size_t )10);
      }
#line 773
      readsize += 10;
#line 774
      headerlen = (((((int )header[4] & 127) << 21) + (((int )header[5] & 127) << 14)) + (((int )header[6] & 127) << 7)) + ((int )header[7] & 127);
      }
    } else {
      {
      {
#line 777
      memcpy((void */* __restrict  */)(header), (void const   */* __restrict  */)(buffer + readsize),
             (size_t )6);
      }
#line 778
      readsize += 6;
#line 779
      headerlen = (((int )header[3] << 16) + ((int )header[4] << 8)) + (int )header[5];
      }
    }
#line 783
    if (headerlen < 1) {
#line 784
      goto while_continue;
    }
    {
    {
#line 787
    tmp___7 = strlen("TPE1");
    }
    {
#line 787
    tmp___8 = strncmp((char const   *)(header), "TPE1", tmp___7);
    }
    }
#line 787
    if (tmp___8) {
      {
      {
#line 787
      tmp___9 = strlen("TP1");
      }
      {
#line 787
      tmp___10 = strncmp((char const   *)(header), "TP1", tmp___9);
      }
      }
#line 787
      if (tmp___10) {
        {
        {
#line 797
        tmp___3 = strlen("TIT2");
        }
        {
#line 797
        tmp___4 = strncmp((char const   *)(header), "TIT2", tmp___3);
        }
        }
#line 797
        if (tmp___4) {
          {
          {
#line 797
          tmp___5 = strlen("TT2");
          }
          {
#line 797
          tmp___6 = strncmp((char const   *)(header), "TT2", tmp___5);
          }
          }
#line 797
          if (! tmp___6) {
            _L: /* CIL Label */ 
#line 799
            readsize ++;
#line 800
            headerlen --;
#line 801
            if (headerlen > size - readsize) {
#line 802
              headerlen = size - readsize;
            }
            {
            {
#line 803
            tmp___2 = malloc((size_t )(headerlen + 1));
            }
#line 803
            title = (char *)tmp___2;
            {
#line 804
            snprintf((char */* __restrict  */)title, (size_t )(headerlen + 1), (char const   */* __restrict  */)"%s",
                     buffer + readsize);
            }
#line 806
            readsize += headerlen;
            }
          }
        } else {
#line 797
          goto _L;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 789
        readsize ++;
#line 790
        headerlen --;
#line 791
        if (headerlen > size - readsize) {
#line 792
          headerlen = size - readsize;
        }
        {
        {
#line 793
        tmp___1 = malloc((size_t )(headerlen + 1));
        }
#line 793
        artist = (char *)tmp___1;
        {
#line 794
        snprintf((char */* __restrict  */)artist, (size_t )(headerlen + 1), (char const   */* __restrict  */)"%s",
                 buffer + readsize);
        }
#line 796
        readsize += headerlen;
        }
      }
    } else {
#line 787
      goto _L___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 811
  if (artist) {
#line 811
    if (title) {
      {
      {
#line 812
      tmp___11 = strlen((char const   *)artist);
      }
      {
#line 812
      tmp___12 = strlen((char const   *)title);
      }
      {
#line 812
      tmp___13 = malloc((tmp___11 + tmp___12) + 4U);
      }
#line 812
      entry->title = (char *)tmp___13;
      {
#line 813
      tmp___14 = strlen((char const   *)artist);
      }
      {
#line 813
      tmp___15 = strlen((char const   *)title);
      }
      {
#line 813
      snprintf((char */* __restrict  */)entry->title, (tmp___14 + tmp___15) + 4U,
               (char const   */* __restrict  */)"%s - %s", artist, title);
      }
      {
#line 815
      free((void *)artist);
      }
      {
#line 816
      free((void *)title);
      }
      }
    } else {
#line 811
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 817
  if (artist) {
#line 818
    entry->title = artist;
  } else
#line 819
  if (title) {
#line 820
    entry->title = title;
  }
  {
  {
#line 823
  free((void *)buffer);
  }
  }
#line 824
  return ((short )((unsigned long )entry->title != (unsigned long )((void *)0)));
}
}
#line 835 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static int getid3v2len___0(FILE *file ) 
{ 
  char buf[6] ;
  int offset ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 842
  tmp___0 = fseek(file, 0L, 0);
  }
  }
#line 842
  if (tmp___0 != 0) {
#line 845
    offset = 0;
  } else {
    {
    {
#line 842
    tmp___1 = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )6,
                    (FILE */* __restrict  */)file);
    }
    }
#line 842
    if (tmp___1 != 6U) {
#line 845
      offset = 0;
    } else {
      {
      {
#line 842
      tmp___2 = strlen("ID3");
      }
      {
#line 842
      tmp___3 = strncmp((char const   *)(buf), "ID3", tmp___2);
      }
      }
#line 842
      if (tmp___3 != 0) {
#line 845
        offset = 0;
      } else {
        {
        {
#line 847
        tmp = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )4,
                    (FILE */* __restrict  */)file);
        }
        }
#line 847
        if (tmp != 4U) {
#line 848
          offset = 0;
        } else {
#line 850
          offset = ((((((int )buf[0] & 127) << 21) + (((int )buf[1] & 127) << 14)) + (((int )buf[2] & 127) << 7)) + ((int )buf[3] & 127)) + 10;
        }
      }
    }
  }
#line 852
  return (offset);
}
}
#line 863 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static int getid3v1len___0(FILE *file ) 
{ 
  char buf[3] ;
  int offset ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 870
  tmp = fseek(file, -128L, 2);
  }
  }
#line 870
  if (tmp != 0) {
#line 873
    offset = 0;
  } else {
    {
    {
#line 870
    tmp___0 = fread((void */* __restrict  */)(buf), (size_t )sizeof(char ), (size_t )3,
                    (FILE */* __restrict  */)file);
    }
    }
#line 870
    if (tmp___0 != 3U) {
#line 873
      offset = 0;
    } else {
      {
      {
#line 870
      tmp___1 = strncmp((char const   *)(buf), "TAG", (size_t )3);
      }
      }
#line 870
      if (tmp___1 != 0) {
#line 873
        offset = 0;
      } else {
#line 875
        offset = 128;
      }
    }
  }
#line 877
  return (offset);
}
}
#line 893 "/home/wslee/benchmarks/sound/ample-0.5.7/src/helper.c"
static int getsonglength___0(FILE *file , mp3entry *entry ) 
{ 
  uint32_t header ;
  int version ;
  int layer ;
  int bitindex ;
  int bitrate ;
  int freqindex ;
  int frequency ;
  double bpf ;
  double tpf ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 913
  tmp = fseek(file, (long )entry->id3v2len, 0);
  }
  }
#line 913
  if (tmp) {
#line 914
    return (-1);
  }
#line 917
  version = 0;
  {
  {
#line 917
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 917
    if (! (version < 3)) {
#line 917
      goto while_break;
    }
    {
#line 918
    header <<= 8;
    {
#line 919
    tmp___0 = fread((void */* __restrict  */)(& header), (size_t )1, (size_t )1, (FILE */* __restrict  */)file);
    }
    }
#line 919
    if (! tmp___0) {
#line 920
      return (-1);
    }
#line 917
    version ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  restart: 
  {
  {
#line 925
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
#line 926
    header <<= 8;
    {
#line 927
    tmp___1 = fread((void */* __restrict  */)(& header), (size_t )1, (size_t )1, (FILE */* __restrict  */)file);
    }
    }
#line 927
    if (! tmp___1) {
#line 928
      return (-1);
    }
#line 925
    if (! (! (((header >> 21) & 2047U) == 2047U))) {
#line 925
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 937
  if ((header & 61440U) == 61440U) {
#line 938
    goto restart;
  }
  {
  {
#line 940
  debug(5, (char *)"We found %x-%x-%x-%x and checksync %i and test %x\n", (header >> 24) & 255U,
        (header >> 16) & 255U, (header >> 8) & 255U, header & 255U, ((header >> 21) & 2047U) == 2047U,
        (header & 61440U) == 61440U);
  }
  }
  {
#line 946
  if ((header & 1572864U) >> 19 == 2U) {
#line 946
    goto case_2;
  }
#line 949
  if ((header & 1572864U) >> 19 == 3U) {
#line 949
    goto case_3;
  }
#line 952
  goto switch_default;
  case_2: /* CIL Label */ 
#line 947
  version = 2;
#line 948
  goto switch_break;
  case_3: /* CIL Label */ 
#line 950
  version = 1;
#line 951
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 953
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 958
  if ((header & 393216U) >> 17 == 1U) {
#line 958
    goto case_1;
  }
#line 961
  if ((header & 393216U) >> 17 == 2U) {
#line 961
    goto case_2___0;
  }
#line 964
  if ((header & 393216U) >> 17 == 3U) {
#line 964
    goto case_3___0;
  }
#line 967
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 959
  layer = 3;
#line 960
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 962
  layer = 2;
#line 963
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 965
  layer = 1;
#line 966
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 968
  return (-1);
  switch_break___0: /* CIL Label */ ;
  }
#line 972
  bitindex = (int )((header & 61440U) >> 12);
#line 973
  bitrate = (int )bitrate_table[version - 1][layer - 1][bitindex];
#line 974
  if (bitrate == 0) {
#line 975
    return (-1);
  }
#line 978
  freqindex = (int )((header & 3072U) >> 10);
#line 979
  frequency = (int )freqtab[version - 1][freqindex];
#line 980
  if (frequency == 0) {
#line 981
    return (-1);
  }
  {
  {
#line 983
  debug(2, (char *)"Version %i, lay %i, biti %i, bitr %i, freqi %i, freq %i\n", version,
        layer, bitindex, bitrate, freqindex, frequency);
  }
  }
  {
#line 988
  if (layer == 1) {
#line 988
    goto case_1___0;
  }
#line 994
  if (layer == 3) {
#line 994
    goto case_3___1;
  }
#line 994
  if (layer == 2) {
#line 994
    goto case_3___1;
  }
#line 999
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
#line 989
  bpf = (double )bitrate_table[version - 1][layer - 1][bitindex];
#line 990
  bpf *= 12000.0 * 4.0;
#line 991
  bpf /= (double )(freqtab[version - 1][freqindex] << (version - 1));
#line 992
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
#line 995
  bpf = (double )bitrate_table[version - 1][layer - 1][bitindex];
#line 996
  bpf *= (double )144000;
#line 997
  bpf /= (double )(freqtab[version - 1][freqindex] << (version - 1));
#line 998
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 1000
  bpf = 1.0;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 1004
  tpf = (double )bs[layer];
#line 1005
  tpf /= (double )(freqtab[version - 1][freqindex] << (version - 1));
  {
#line 1007
  debug(3, (char *)"BitRate is %i, FileLength is %i, TPF is %f and BPF is %f, we have %f frames in one second\n",
        bitrate, entry->filesize, tpf, bpf, (double )1 / tpf);
  }
  }
#line 1013
  return ((int )(((double )((float )entry->filesize) / bpf) * tpf));
}
}
#line 67 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int volatile   num_clients___0  =    (int volatile   )0;
#line 83 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int opentcpconn___0(void) 
{ 
  struct sockaddr_in address ;
  int opt ;
  int sock ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 87
  opt = 1;
  {
#line 90
  sock = socket(2, 1, 0);
  }
  }
#line 90
  if (sock < 0) {
    {
    {
#line 91
    die((char *)"failed to open tcp socket\n");
    }
    }
  }
  {
  {
#line 93
  setsockopt(sock, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
  }
#line 94
  address.sin_family = (sa_family_t )2;
  {
#line 95
  address.sin_port = htons((uint16_t )gconf.port);
  }
  {
#line 96
  memset((void *)(& address.sin_addr), 0, (size_t )sizeof(address.sin_addr));
  }
  {
#line 98
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& address)), (socklen_t )sizeof(struct sockaddr_in ));
  }
  }
#line 98
  if (tmp) {
    {
    {
#line 99
    die((char *)"failed to bind tcp socket\n");
    }
    }
  }
  {
  {
#line 101
  tmp___0 = listen(sock, 5);
  }
  }
#line 101
  if (tmp___0) {
    {
    {
#line 102
    die((char *)"failed to listen to tcp socket\n");
    }
    }
  }
  {
  {
#line 104
  debug(1, (char *)"Opened TCP socket, port %d\n", gconf.port);
  }
  }
#line 105
  return (sock);
}
}
#line 117 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int openudpconn___0(void) 
{ 
  struct sockaddr_in address ;
  int sock ;
  int socklen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 122
  socklen = (int )sizeof(struct sockaddr_in );
  {
#line 124
  sock = socket(2, 2, 0);
  }
  }
#line 124
  if (sock < 0) {
    {
    {
#line 125
    die((char *)"failed to open udp socket\n");
    }
    }
  }
  {
  {
#line 127
  memset((void *)(& address.sin_addr), 0, (size_t )sizeof(address.sin_addr));
  }
#line 128
  address.sin_family = (sa_family_t )2;
#line 129
  address.sin_port = (in_port_t )0;
  {
#line 130
  address.sin_addr.s_addr = htonl((in_addr_t )2130706433);
  }
  {
#line 132
  tmp = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& address)), (socklen_t )socklen);
  }
  }
#line 132
  if (tmp) {
    {
    {
#line 133
    logmsg((char *)"failed to bind udp socket\n");
    }
    }
  }
  {
  {
#line 135
  tmp___0 = getsockname(sock, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& address)),
                        (socklen_t */* __restrict  */)(& socklen));
  }
  }
#line 135
  if (tmp___0 < 0) {
    {
    {
#line 136
    logmsg((char *)"failed to get name of udp socket\n");
    }
    }
  }
  {
  {
#line 138
  tmp___1 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& address)),
                    (socklen_t )socklen);
  }
  }
#line 138
  if (tmp___1) {
    {
    {
#line 139
    logmsg((char *)"failed to connect udp socket\n");
    }
    }
  }
  {
  {
#line 141
  tmp___2 = ntohs(address.sin_port);
  }
  {
#line 141
  debug(1, (char *)"Opened UDP socket, port %d\n", (int )tmp___2);
  }
  }
#line 142
  return (sock);
}
}
#line 153 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void getudpmessage___0(int udpsock ) 
{ 
  char buffer[1024] ;
  char *tmp ;
  int childpid ;
  int i ;
  ssize_t tmp___0 ;
  long tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 162
  memset((void *)(buffer), '\000', (size_t )sizeof(buffer));
  }
  {
#line 163
  tmp___0 = recv(udpsock, (void *)(buffer), (size_t )(sizeof(buffer) - 1UL), 0);
  }
  }
#line 163
  if (tmp___0 < 0) {
    {
    {
#line 164
    debug(1, (char *)"recv failed\n");
    }
    }
#line 165
    return;
  }
#line 168
  tmp = buffer;
  {
  {
#line 169
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 169
    if ((int )*tmp != 0) {
#line 169
      if (! ((int )*tmp != 58)) {
#line 169
        goto while_break;
      }
    } else {
#line 169
      goto while_break;
    }
#line 170
    tmp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if ((int )*tmp == 0) {
    {
    {
#line 172
    debug(1, (char *)"Erroneous status message from client!\n");
    }
    }
#line 173
    return;
  }
  {
#line 176
  *tmp = (char )'\000';
#line 177
  tmp ++;
  {
#line 178
  tmp___1 = strtol((char const   */* __restrict  */)(buffer), (char **/* __restrict  */)((void *)0),
                   10);
  }
#line 178
  childpid = (int )tmp___1;
  }
#line 179
  if (childpid < 1) {
    {
    {
#line 180
    debug(1, (char *)"Erroneous status message from client!\n");
    }
    }
#line 181
    return;
  }
#line 184
  i = 0;
  {
  {
#line 184
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 184
    if (! (i < gconf.max_clients)) {
#line 184
      goto while_break___0;
    }
#line 185
    if ((childarray + i)->childpid == childpid) {
#line 186
      if ((childarray + i)->status) {
        {
        {
#line 187
        free((void *)(childarray + i)->status);
        }
        }
      }
      {
      {
#line 188
      (childarray + i)->status = strdup((char const   *)tmp);
      }
      {
#line 189
      debug(1, (char *)"Status message from %i: %s\n", childpid, tmp);
      }
      }
#line 190
      goto while_break___0;
    }
#line 184
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  return;
}
}
#line 204 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void sigchild_handler___0(int signal___0 ) 
{ 
  int i ;
  pid_t pid ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 210
  num_clients___0 -= (int volatile   )1;
  {
#line 211
  pid = wait((union wait *)(& i));
  }
#line 212
  i = 0;
  }
  {
  {
#line 212
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((childarray + i)->childpid != pid)) {
#line 212
      goto while_break;
    }
#line 212
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  (childarray + i)->childpid = 0;
#line 214
  if ((childarray + i)->status) {
    {
    {
#line 215
    free((void *)(childarray + i)->status);
    }
    }
  }
#line 216
  if ((childarray + i)->client) {
    {
    {
#line 217
    free((void *)(childarray + i)->client);
    }
    }
  }
  {
  {
#line 219
  debug(1, (char *)"child with pid %u exited, currently %d/%d client(s)\n", pid, num_clients___0,
        gconf.max_clients);
  }
#line 220
  i = 0;
  }
  {
  {
#line 220
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (i < gconf.max_clients)) {
#line 220
      goto while_break___0;
    }
#line 221
    if ((childarray + i)->childpid != 0) {
      {
      {
#line 222
      debug(1, (char *)"I have child %u alive with status %s\n", (childarray + i)->childpid,
            (childarray + i)->status);
      }
      }
    }
#line 220
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 223
  return;
}
}
#line 252 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static short issocket___0(int fd ) 
{ 
  int v ;
  socklen_t l ;
  int tmp ;

  {
  {
#line 258
  l = (socklen_t )sizeof(int );
  {
#line 259
  tmp = getsockopt(fd, 1, 3, (void */* __restrict  */)((void *)(& v)), (socklen_t */* __restrict  */)(& l));
  }
  }
#line 259
  return ((short )(tmp == 0));
}
}
#line 271 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void daemonize___0(void) 
{ 
  pid_t pid ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 277
  umask((__mode_t )18);
  }
  }
#line 279
  if (gconf.trace) {
#line 280
    return;
  } else
#line 279
  if (gconf.inetd) {
#line 280
    return;
  }
  {
  {
#line 282
  pid = fork();
  }
  }
#line 282
  if (pid > 0) {
    {
    {
#line 283
    exit(0);
    }
    }
  } else
#line 284
  if (pid < 0) {
    {
    {
#line 285
    die((char *)"fork");
    }
    }
  }
  {
  {
#line 287
  setsid();
  }
  {
#line 289
  pid = fork();
  }
  }
#line 289
  if (pid > 0) {
    {
    {
#line 290
    exit(0);
    }
    }
  } else
#line 291
  if (pid < 0) {
    {
    {
#line 292
    die((char *)"fork");
    }
    }
  }
#line 293
  return;
}
}
#line 301 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static void preparelog___0(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 305
  signal(1, (void (*)(int  ))1);
  }
  }
#line 306
  if (! gconf.trace) {
    {
    {
#line 307
    openlog("ample", 3, 3 << 3);
    }
    {
#line 308
    fclose(stdout);
    }
    {
#line 309
    fclose(stderr);
    }
    }
  }
#line 328
  if (! gconf.inetd) {
    {
    {
#line 329
    fclose(stdin);
    }
    }
  }
#line 331
  return;
}
}
#line 344 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static short check_access___0(int conn , struct sockaddr_in *address ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 367
  if (! gconf.inetd) {
#line 367
    if (num_clients___0 >= (int volatile   )gconf.max_clients) {
      {
      {
#line 368
      tmp = inet_ntoa(address->sin_addr);
      }
      {
#line 368
      logmsg((char *)"Connection from %s:%d denied, max clients exceeded\n", tmp,
             (int )address->sin_port);
      }
      {
#line 370
      close(conn);
      }
      }
#line 371
      return ((short)0);
    }
  }
#line 375
  if (gconf.inetd) {
    {
    {
#line 376
    tmp___0 = inet_ntoa(address->sin_addr);
    }
    {
#line 376
    logmsg((char *)"Connection from %s:%d accepted\n", tmp___0, (int )address->sin_port);
    }
    }
  } else {
    {
    {
#line 379
    tmp___1 = inet_ntoa(address->sin_addr);
    }
    {
#line 379
    logmsg((char *)"Connection from %s:%d accepted, currently %d/%d clients\n", tmp___1,
           (int )address->sin_port, num_clients___0 + (int volatile   )1, gconf.max_clients);
    }
    }
  }
#line 383
  return ((short)1);
}
}
#line 396 "/home/wslee/benchmarks/sound/ample-0.5.7/src/ample.c"
static int accept_connection___0(struct sockaddr_in *address , int tcpsock , int udpsock ) 
{ 
  fd_set readfds ;
  int conn ;
  int addrlen ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 401
  addrlen = (int )sizeof(struct sockaddr_in );
#line 403
  if ((unsigned long )address == (unsigned long )((void *)0)) {
#line 404
    return (0);
  } else
#line 403
  if (tcpsock < 0) {
#line 404
    return (0);
  }
  {
  {
#line 406
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 407
    if (! gconf.inetd) {
      {
      {
#line 408
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 408
        __asm__  volatile   ("cld; rep; "
                             "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds.__fds_bits[0]): "memory");
#line 408
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 409
      readfds.__fds_bits[tcpsock / (8 * (int )sizeof(__fd_mask ))] |= 1L << tcpsock % (8 * (int )sizeof(__fd_mask ));
#line 410
      readfds.__fds_bits[udpsock / (8 * (int )sizeof(__fd_mask ))] |= 1L << udpsock % (8 * (int )sizeof(__fd_mask ));
#line 411
      if (tcpsock > udpsock) {
#line 411
        tmp = tcpsock;
      } else {
#line 411
        tmp = udpsock;
      }
      {
      {
#line 411
      conn = select(tmp + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
      }
#line 413
      if (conn < 0) {
        {
        {
#line 413
        tmp___0 = __errno_location();
        }
        }
#line 413
        if (*tmp___0 == 4) {
#line 414
          goto while_continue;
        } else {
#line 413
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 415
      if (conn < 0) {
        {
        {
#line 416
        die((char *)"select()\n");
        }
        }
      }
#line 418
      if ((readfds.__fds_bits[udpsock / (8 * (int )sizeof(__fd_mask ))] & (1L << udpsock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
        {
#line 419
        getudpmessage___0(udpsock);
        }
        }
      }
#line 421
      if (! ((readfds.__fds_bits[tcpsock / (8 * (int )sizeof(__fd_mask ))] & (1L << tcpsock % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 422
        goto while_continue;
      }
      {
      {
#line 424
      conn = accept(tcpsock, (struct sockaddr */* __restrict  */)((struct sockaddr *)address),
                    (socklen_t */* __restrict  */)(& addrlen));
      }
      }
#line 424
      if (conn < 0) {
        {
        {
#line 426
        tmp___1 = __errno_location();
        }
        }
#line 426
        if (*tmp___1 == 4) {
#line 427
          goto while_continue;
        } else {
          {
          {
#line 429
          die((char *)"accept");
          }
          }
        }
      }
#line 432
      goto while_break;
    } else {
      {
#line 435
      conn = 0;
      {
#line 436
      getpeername(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)address),
                  (socklen_t */* __restrict  */)(& addrlen));
      }
      }
#line 437
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return (conn);
}
}
#line 30 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.c"
static int valof___0(char c ) 
{ 
  char *alphabet ;
  char *tmp ;
  int i ;
  char *__cil_tmp5 ;

  {
#line 33
  alphabet = (char *)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
#line 35
  tmp = alphabet;
#line 36
  i = 0;
#line 38
  if ((int )c == 0) {
#line 39
    return (-1);
  }
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 42
    if ((int )*tmp == 0) {
#line 43
      return (-1);
    }
#line 44
    if ((int )*tmp == (int )c) {
#line 45
      return (i);
    }
#line 46
    i ++;
#line 47
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 60 "/home/wslee/benchmarks/sound/ample-0.5.7/src/base64.c"
static void nextchunk___0(char **c , char *chunk ) 
{ 
  int i ;
  int b64val[4] ;
  void *__cil_tmp5 ;

  {
#line 66
  i = 0;
  {
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < 4)) {
#line 66
      goto while_break;
    }
#line 67
    if ((int )*(*c) != 0) {
      {
      {
#line 68
      b64val[i] = valof___0(*(*c));
      }
#line 69
      (*c) ++;
      }
    } else {
#line 71
      b64val[i] = '\000';
    }
#line 66
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  *(chunk + 0) = (char )((b64val[0] << 2) | ((b64val[1] & 48) >> 4));
#line 76
  *(chunk + 1) = (char )(((b64val[1] & 15) << 4) | ((b64val[2] & 60) >> 2));
#line 77
  *(chunk + 2) = (char )(((b64val[2] & 3) << 6) | b64val[3]);
#line 79
  return;
}
}
#line 251 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void findfirstfile___0(mp3entry *base , short recursive , mp3entry **result___1 ) 
{ 
  mp3entry *tmp ;

  {
#line 254
  tmp = base;
#line 256
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 257
    return;
  }
  {
  {
#line 259
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 259
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 259
      if (! ((unsigned long )*result___1 == (unsigned long )((void *)0))) {
#line 259
        goto while_break;
      }
    } else {
#line 259
      goto while_break;
    }
#line 260
    if (tmp->type == 1) {
#line 261
      *result___1 = tmp;
#line 262
      return;
    }
#line 264
    tmp = tmp->sibling;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (recursive) {
#line 268
    tmp = base;
    {
    {
#line 269
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 269
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 269
        if (! ((unsigned long )*result___1 == (unsigned long )((void *)0))) {
#line 269
          goto while_break___0;
        }
      } else {
#line 269
        goto while_break___0;
      }
#line 270
      if (tmp->type == 0) {
        {
        {
#line 271
        findfirstfile___0(tmp->child, recursive, result___1);
        }
        }
      }
#line 272
      tmp = tmp->sibling;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 275
  return;
}
}
#line 290 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void findlastfile___0(mp3entry *base , short recursive , mp3entry **result___1 ) 
{ 
  mp3entry *tmp ;

  {
#line 293
  tmp = base;
#line 295
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 296
    return;
  }
  {
  {
#line 298
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 298
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 298
      goto while_break;
    }
#line 299
    if (tmp->type == 1) {
#line 300
      *result___1 = tmp;
    }
#line 301
    tmp = tmp->sibling;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (recursive) {
#line 305
    tmp = base;
    {
    {
#line 306
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 306
        goto while_break___0;
      }
#line 307
      if (tmp->type == 0) {
#line 307
        if (recursive) {
          {
          {
#line 308
          findlastfile___0(tmp->child, recursive, result___1);
          }
          }
        }
      }
#line 309
      tmp = tmp->sibling;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 312
  return;
}
}
#line 398 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void freeentry___0(mp3entry *tofree ) 
{ 


  {
#line 401
  if (! tofree) {
#line 402
    return;
  }
#line 403
  if (tofree->name) {
    {
    {
#line 404
    free((void *)tofree->name);
    }
    }
  }
#line 405
  if (tofree->path) {
    {
    {
#line 406
    free((void *)tofree->path);
    }
    }
  }
#line 407
  if (tofree->title) {
    {
    {
#line 408
    free((void *)tofree->title);
    }
    }
  }
  {
  {
#line 409
  free((void *)tofree);
  }
  }
#line 410
  return;
}
}
#line 689 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static int checkpathtype___0(char *path , mp3entry **buf ) 
{ 
  struct stat statbuf ;
  char *dirc ;
  char *basec ;
  char *bname ;
  char *dname ;
  char *owd ;
  char *cwd ;
  int retval ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 695
  retval = -1;
  {
#line 697
  tmp___1 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& statbuf));
  }
  }
#line 697
  if (tmp___1) {
    {
    {
#line 702
    tmp = __errno_location();
    }
    {
#line 702
    tmp___0 = strerror(*tmp);
    }
    {
#line 702
    logmsg((char *)"Error, unable to stat path - %s (reason: %s)\n", path, tmp___0);
    }
#line 703
    *buf = (mp3entry *)((void *)0);
    }
#line 704
    return (-1);
  }
  {
  {
#line 707
  dirc = strdup((char const   *)path);
  }
  {
#line 708
  basec = strdup((char const   *)path);
  }
  {
#line 709
  dname = dirname(dirc);
  }
  {
#line 710
  bname = __xpg_basename(basec);
  }
  }
#line 712
  if ((int )*(bname + 0) == 46) {
    {
    {
#line 714
    debug(2, (char *)"Ignoring %s, starts with .\n", path);
    }
    }
  } else
#line 715
  if ((statbuf.st_mode & 61440U) == 16384U) {
    {
    {
#line 717
    debug(2, (char *)"Valid dir %s\n", path);
    }
    {
#line 719
    tmp___2 = malloc((size_t )sizeof(mp3entry ));
    }
#line 719
    *buf = (mp3entry *)tmp___2;
    {
#line 720
    memset((void *)*buf, 0, (size_t )sizeof(mp3entry ));
    }
    {
#line 722
    (*buf)->name = strdup((char const   *)bname);
    }
#line 723
    (*buf)->type = 0;
#line 725
    retval = 0;
    }
  } else
#line 726
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
    {
#line 728
    debug(2, (char *)"Ignoring %s, not a dir and not a regular file\n", path);
    }
    }
  } else {
    {
    {
#line 729
    tmp___16 = strlen((char const   *)bname);
    }
    }
#line 729
    if (tmp___16 < 5U) {
      {
      {
#line 731
      debug(2, (char *)"Ignoring %s, too short filename\n", path);
      }
      }
    } else
#line 732
    if (statbuf.st_size == 0L) {
      {
      {
#line 734
      debug(2, (char *)"Ignoring %s, zero size\n", path);
      }
      }
    } else {
      {
      {
#line 735
      tmp___14 = strlen((char const   *)bname);
      }
      {
#line 735
      tmp___15 = strcasecmp((char const   *)((bname + tmp___14) - 4), ".mp3");
      }
      }
#line 735
      if (tmp___15) {
        {
        {
#line 769
        tmp___12 = strlen((char const   *)bname);
        }
        {
#line 769
        tmp___13 = strcasecmp((char const   *)((bname + tmp___12) - 4), ".m3u");
        }
        }
#line 769
        if (tmp___13) {
          {
          {
#line 782
          debug(2, (char *)"Ignoring %s, weird filename\n", path);
          }
          }
        } else {
          {
          {
#line 771
          debug(2, (char *)"Valid m3u file %s\n", path);
          }
          {
#line 773
          tmp___11 = malloc((size_t )sizeof(mp3entry ));
          }
#line 773
          *buf = (mp3entry *)tmp___11;
          {
#line 774
          memset((void *)*buf, 0, (size_t )sizeof(mp3entry ));
          }
          {
#line 776
          (*buf)->name = strdup((char const   *)bname);
          }
#line 777
          (*buf)->type = 0;
#line 779
          retval = 2;
          }
        }
      } else {
        {
        {
#line 737
        debug(2, (char *)"Valid mp3 file %s\n", path);
        }
        {
#line 739
        tmp___3 = malloc((size_t )sizeof(mp3entry ));
        }
#line 739
        *buf = (mp3entry *)tmp___3;
        {
#line 740
        memset((void *)*buf, 0, (size_t )sizeof(mp3entry ));
        }
        {
#line 742
        tmp___10 = strcmp((char const   *)dname, ".");
        }
        }
#line 742
        if (tmp___10) {
          {
          {
#line 749
          owd = mgetcwd();
          }
          {
#line 750
          chdir((char const   *)dname);
          }
          {
#line 751
          cwd = mgetcwd();
          }
          {
#line 753
          tmp___7 = strlen((char const   *)cwd);
          }
          {
#line 753
          tmp___8 = strlen((char const   *)bname);
          }
          {
#line 753
          tmp___9 = malloc((tmp___7 + tmp___8) + 2U);
          }
#line 753
          (*buf)->path = (char *)tmp___9;
          {
#line 755
          sprintf((char */* __restrict  */)(*buf)->path, (char const   */* __restrict  */)"%s/%s",
                  cwd, bname);
          }
          {
#line 757
          chdir((char const   *)owd);
          }
          {
#line 758
          free((void *)owd);
          }
          {
#line 759
          free((void *)cwd);
          }
          }
        } else {
          {
          {
#line 743
          cwd = mgetcwd();
          }
          {
#line 744
          tmp___4 = strlen((char const   *)cwd);
          }
          {
#line 744
          tmp___5 = strlen((char const   *)bname);
          }
          {
#line 744
          tmp___6 = malloc((tmp___4 + tmp___5) + 2U);
          }
#line 744
          (*buf)->path = (char *)tmp___6;
          {
#line 746
          sprintf((char */* __restrict  */)(*buf)->path, (char const   */* __restrict  */)"%s/%s",
                  cwd, bname);
          }
          {
#line 747
          free((void *)cwd);
          }
          }
        }
        {
        {
#line 762
        (*buf)->name = strdup((char const   *)bname);
        }
#line 763
        (*buf)->type = 1;
#line 764
        (*buf)->filesize = statbuf.st_size;
        {
#line 766
        checkmp3info(*buf);
        }
#line 767
        retval = 1;
        }
      }
    }
  }
#line 785
  if (retval == -1) {
#line 786
    *buf = (mp3entry *)((void *)0);
  }
  {
  {
#line 788
  free((void *)dirc);
  }
  {
#line 789
  free((void *)basec);
  }
  }
#line 790
  return (retval);
}
}
#line 804 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void parsedir___0(char *path , mp3entry **baseptr ) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  char *cwd ;
  char *owd ;
  mp3entry *filebuf ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 813
  owd = mgetcwd();
  }
  {
#line 814
  tmp = chdir((char const   *)path);
  }
  }
#line 814
  if (tmp) {
    {
    {
#line 815
    logmsg((char *)"Incorrect path for mp3 files - %s\n", path);
    }
    {
#line 816
    free((void *)owd);
    }
    }
#line 817
    return;
  } else {
    {
    {
#line 819
    cwd = mgetcwd();
    }
    }
  }
  {
  {
#line 822
  dir = opendir(".");
  }
  }
#line 822
  if (! dir) {
    {
    {
#line 823
    die((char *)"opendir()\n");
    }
    }
  }
  {
  {
#line 825
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 825
    dirent = readdir(dir);
    }
    }
#line 825
    if (! dirent) {
#line 825
      goto while_break;
    }
    {
    {
#line 827
    tmp___0 = checkpathtype___0(dirent->d_name, & filebuf);
    }
    }
    {
#line 828
    if (tmp___0 == 1) {
#line 828
      goto case_1;
    }
#line 831
    if (tmp___0 == 0) {
#line 831
      goto case_0;
    }
#line 839
    if (tmp___0 == 2) {
#line 839
      goto case_2;
    }
#line 842
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 829
    addentry(baseptr, filebuf);
    }
    }
#line 830
    goto switch_break;
    case_0: /* CIL Label */ 
#line 832
    if (gconf.recursive) {
      {
      {
#line 833
      addentry(baseptr, filebuf);
      }
      {
#line 834
      parsedir___0(dirent->d_name, & filebuf->child);
      }
      }
    } else {
      {
      {
#line 836
      freeentry___0(filebuf);
      }
      }
    }
#line 838
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 840
    freeentry___0(filebuf);
    }
    }
    switch_default: /* CIL Label */ 
#line 844
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 847
    tmp___1 = __errno_location();
    }
#line 847
    *tmp___1 = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 850
  tmp___2 = __errno_location();
  }
  }
#line 850
  if (*tmp___2) {
    {
    {
#line 851
    die((char *)"readdir()\n");
    }
    }
  }
  {
  {
#line 853
  chdir((char const   *)owd);
  }
  {
#line 854
  free((void *)owd);
  }
  {
#line 855
  free((void *)cwd);
  }
  {
#line 856
  closedir(dir);
  }
  }
#line 857
  return;
}
}
#line 869 "/home/wslee/benchmarks/sound/ample-0.5.7/src/entries.c"
static void parsem3u___0(mp3entry **baseptr , char *path ) 
{ 
  FILE *m3u ;
  mp3entry *mp3buf ;
  char line[1000] ;
  char *start ;
  char *end ;
  char *tmp ;
  char *dirc ;
  char *basec ;
  char *bname ;
  char *dname ;
  char *owd ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 880
  m3u = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
  }
#line 880
  if (! m3u) {
    {
    {
#line 881
    logmsg((char *)"Unable to open .m3u file %s\n", path);
    }
    }
#line 882
    return;
  }
  {
  {
#line 885
  dirc = strdup((char const   *)path);
  }
  {
#line 886
  basec = strdup((char const   *)path);
  }
  {
#line 887
  dname = dirname(dirc);
  }
  {
#line 888
  bname = __xpg_basename(basec);
  }
  {
#line 889
  owd = mgetcwd();
  }
  {
#line 890
  chdir((char const   *)dname);
  }
  }
  {
  {
#line 892
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 892
    tmp___8 = fgets((char */* __restrict  */)(line), 1000, (FILE */* __restrict  */)m3u);
    }
    }
#line 892
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 892
      goto while_break;
    }
#line 893
    start = line;
    {
    {
#line 893
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 893
      if ((unsigned long )start != (unsigned long )((void *)0)) {
        {
        {
#line 893
        tmp___0 = __ctype_b_loc();
        }
        }
#line 893
        if (! ((int const   )*(*tmp___0 + (int )*start) & 8192)) {
#line 893
          goto while_break___0;
        }
      } else {
#line 893
        goto while_break___0;
      }
#line 893
      start ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 895
    if (! start) {
#line 897
      goto while_continue;
    } else
#line 895
    if ((int )*start == 35) {
#line 897
      goto while_continue;
    } else
#line 895
    if ((int )*start == 0) {
#line 897
      goto while_continue;
    } else {
      {
      {
#line 895
      tmp___1 = strlen((char const   *)start);
      }
      }
#line 895
      if (tmp___1 < 1U) {
#line 897
        goto while_continue;
      }
    }
    {
    {
#line 899
    tmp___2 = strlen((char const   *)start);
    }
#line 899
    end = start + tmp___2;
    }
    {
    {
#line 899
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 899
      if (! ((int )*end == 0)) {
        {
        {
#line 899
        tmp___3 = __ctype_b_loc();
        }
        }
#line 899
        if (! ((int const   )*(*tmp___3 + (int )*end) & 8192)) {
#line 899
          if (! ((int )*end == 10)) {
#line 899
            goto while_break___1;
          }
        }
      }
#line 899
      end --;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 901
    end ++;
#line 902
    *end = (char )'\000';
    {
#line 904
    tmp___4 = strlen((char const   *)start);
    }
    {
#line 904
    tmp___5 = malloc(tmp___4 + 1U);
    }
#line 904
    tmp = (char *)tmp___5;
    {
#line 905
    tmp___6 = strlen((char const   *)start);
    }
    {
#line 905
    snprintf((char */* __restrict  */)tmp, tmp___6 + 1U, (char const   */* __restrict  */)"%s",
             start);
    }
    {
#line 907
    tmp___7 = checkpathtype___0(tmp, & mp3buf);
    }
    }
    {
#line 908
    if (tmp___7 == 1) {
#line 908
      goto case_1;
    }
#line 911
    if (tmp___7 == -1) {
#line 911
      goto case_neg_1;
    }
#line 913
    goto switch_default;
    case_1: /* CIL Label */ 
    {
    {
#line 909
    addentry(baseptr, mp3buf);
    }
    }
#line 910
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 912
    goto while_continue;
    switch_default: /* CIL Label */ 
    {
    {
#line 915
    freeentry___0(mp3buf);
    }
    }
#line 916
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 919
    free((void *)tmp);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 922
  chdir((char const   *)owd);
  }
  {
#line 923
  free((void *)owd);
  }
  {
#line 924
  free((void *)dirc);
  }
  {
#line 925
  free((void *)basec);
  }
  {
#line 926
  fclose(m3u);
  }
  }
#line 927
  return;
}
}
