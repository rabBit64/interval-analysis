/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 30 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.h"
enum __anonenum_error_code_31 {
    ERROR_NONE = 0,
    ERROR_USER = 1,
    ERROR_CONFIG = 2,
    ERROR_SYSTEM = 3,
    ERROR_INTERNAL = 4
} ;
#line 30 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.h"
typedef enum __anonenum_error_code_31 error_code;
#line 30 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.h"
struct filebuf {
   void *buf ;
   size_t len ;
   char const   *name ;
   uint32_t start ;
   uint32_t count ;
   uint32_t cursor ;
};
#line 30 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.h"
typedef struct filebuf filebuf_t;
#line 39 "/home/wslee/benchmarks/textformat/unsort-1.1.2/iovec.c"
struct iovec_const {
   void const   *iov_base ;
   size_t iov_len ;
};
#line 59 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 39 "/usr/include/stdint.h"
typedef int int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 170 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 336
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 76 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 29 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.h"
void mt_seed(uint32_t s ) ;
#line 30
void mt_seed_array(uint32_t *init_key , unsigned int key_length ) ;
#line 29 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar_init.h"
void mt_init(void) ;
#line 30
_Bool mt_init_urandom(void) ;
#line 36 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar_init.c"
_Bool mt_init_urandom(void) 
{ 
  int fd ;
  size_t len ;
  ssize_t r ;
  uint32_t buf[4] ;
  int *tmp___1 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 38
  len = (size_t )0;
  {
#line 42
  fd = open("/dev/urandom", 0);
  }
  }
#line 43
  if (fd == -1) {
#line 44
    return ((_Bool)0);
  }
  {
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 46
    if (! ((unsigned long )len < sizeof(buf))) {
#line 46
      goto while_break;
    }
    {
    {
#line 47
    tmp___1 = __errno_location();
    }
#line 47
    *tmp___1 = 11;
    {
#line 48
    r = read(fd, (void *)(buf + len), (size_t )(sizeof(buf) - (unsigned long )len));
    }
    }
#line 49
    if (! r) {
#line 50
      goto while_break;
    } else
#line 49
    if (r == -1) {
#line 50
      goto while_break;
    }
#line 51
    len += (size_t )r;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 53
  close(fd);
  }
  }
#line 55
  if ((unsigned long )len < sizeof(buf)) {
#line 56
    return ((_Bool)0);
  }
  {
  {
#line 58
  mt_seed_array(buf, (unsigned int )(sizeof(buf) / sizeof(buf[0])));
  }
  }
#line 60
  return ((_Bool)1);
}
}
#line 63 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar_init.c"
void mt_init(void) 
{ 
  uint32_t buf[4] ;
  _Bool success ;
  struct timespec ts ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  time_t tmp___4 ;
  void *__cil_tmp8 ;

  {
  {
#line 65
  success = (_Bool)0;
  {
#line 68
  tmp___1 = mt_init_urandom();
  }
  }
#line 68
  if (tmp___1) {
#line 69
    return;
  }
  {
  {
#line 71
  tmp___2 = clock_gettime(0, & ts);
  }
  }
#line 71
  if (! tmp___2) {
#line 72
    success = (_Bool)1;
#line 73
    buf[0] = (uint32_t )ts.tv_sec;
#line 74
    buf[1] = (uint32_t )ts.tv_nsec;
  }
  {
  {
#line 77
  tmp___3 = clock_gettime(1, & ts);
  }
  }
#line 77
  if (! tmp___3) {
#line 78
    success = (_Bool)1;
#line 79
    buf[2] = (uint32_t )ts.tv_sec;
#line 80
    buf[3] = (uint32_t )ts.tv_nsec;
  }
#line 83
  if (success) {
    {
    {
#line 84
    mt_seed_array(buf, (unsigned int )(sizeof(buf) / sizeof(buf[0])));
    }
    }
#line 85
    return;
  }
  {
  {
#line 88
  tmp___4 = time((time_t *)((void *)0));
  }
  {
#line 88
  mt_seed((uint32_t )tmp___4);
  }
  }
#line 89
  return;
}
}
#line 94 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 51 "/usr/include/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 38 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.h"
void exit_error(error_code e , char const   *msg  , ...) ;
#line 40
void exit_perror(error_code e , char const   *msg  , ...) ;
#line 32 "/home/wslee/benchmarks/textformat/unsort-1.1.2/iovec.h"
_Bool iovec_parse(filebuf_t *fb , int sep , struct iovec *iov , uint32_t const   *tlb ) ;
#line 33
void writev_all(int fd , struct iovec *iov , uint32_t count ) ;
#line 44 "/home/wslee/benchmarks/textformat/unsort-1.1.2/iovec.c"
static uint32_t writev_max  =    (uint32_t )1024;
#line 46 "/home/wslee/benchmarks/textformat/unsort-1.1.2/iovec.c"
void writev_all(int fd , struct iovec *iov , uint32_t count ) 
{ 
  ssize_t r ;
  ssize_t len ;
  uint32_t tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 49
  if (! count) {
#line 50
    return;
  }
  {
  {
#line 52
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 52
    if (! count) {
#line 52
      goto while_break;
    }
#line 53
    if (count > writev_max) {
#line 53
      tmp___1 = writev_max;
    } else {
#line 53
      tmp___1 = count;
    }
    {
    {
#line 53
    r = writev(fd, (struct iovec  const  *)iov, (int )tmp___1);
    }
    }
#line 54
    if (r == -1) {
      {
      {
#line 55
      exit_perror((error_code )3, "Can\'t write to fd %d", fd);
      }
      }
    }
#line 56
    if (! r) {
      {
      {
#line 57
      exit_error((error_code )3, "Can\'t write to fd %d", fd);
      }
      }
    }
    {
    {
#line 58
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 58
      if (! r) {
#line 58
        goto while_break___0;
      }
#line 59
      len = (ssize_t )iov->iov_len;
#line 60
      if (r < len) {
#line 61
        iov->iov_base = (void *)((char *)iov->iov_base + r);
#line 62
        iov->iov_len -= (size_t )r;
      } else {
#line 64
        r -= len;
#line 65
        iov ++;
#line 66
        count --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/wslee/benchmarks/textformat/unsort-1.1.2/iovec.c"
_Bool iovec_parse(filebuf_t *fb , int sep , struct iovec *iov , uint32_t const   *tlb ) 
{ 
  char const   *buf ;
  char const   *end ;
  char const   *line ;
  uint32_t count ;
  struct iovec_const *ioc ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 77
  buf = (char const   *)fb->buf;
#line 78
  end = buf + fb->len;
#line 79
  count = fb->start;
  {
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )buf < (unsigned long )end)) {
#line 81
      goto while_break;
    }
    {
    {
#line 82
    tmp___1 = memchr((void const   *)buf, sep, (size_t )(end - buf));
    }
#line 82
    line = (char const   *)tmp___1;
    }
#line 83
    if (! line) {
#line 84
      goto while_break;
    }
#line 85
    line ++;
#line 87
    if (iov) {
#line 88
      if (tlb) {
#line 88
        tmp___2 = *(tlb + count);
      } else {
#line 88
        tmp___2 = (uint32_t const   )count;
      }
#line 88
      ioc = (struct iovec_const *)iov + tmp___2;
#line 89
      ioc->iov_base = (void const   *)buf;
#line 90
      ioc->iov_len = (size_t )(line - buf);
    }
#line 92
    count ++;
#line 93
    buf = line;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  fb->count = count;
#line 98
  return ((_Bool )((unsigned long )buf < (unsigned long )end));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 39 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.h"
void warn_error(char const   *msg  , ...) ;
#line 41
void warn_perror(char const   *msg  , ...) ;
#line 42
void *xalloc(size_t len ) ;
#line 34 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.c"
void exit_error(error_code e , char const   *msg  , ...) 
{ 
  va_list ap ;

  {
#line 37
  if (msg) {
    {
    {
#line 38
    __builtin_va_start(ap, msg);
    }
    {
#line 39
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             ap);
    }
    {
#line 40
    __builtin_va_end(ap);
    }
    {
#line 41
    _IO_putc('\n', stderr);
    }
    }
  }
  {
  {
#line 44
  exit((int )e);
  }
  }
}
}
#line 47 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.c"
void warn_error(char const   *msg  , ...) 
{ 
  va_list ap ;

  {
#line 50
  if (msg) {
    {
    {
#line 51
    __builtin_va_start(ap, msg);
    }
    {
#line 52
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             ap);
    }
    {
#line 53
    __builtin_va_end(ap);
    }
    {
#line 54
    _IO_putc('\n', stderr);
    }
    }
  }
#line 56
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.c"
void exit_perror(error_code e , char const   *msg  , ...) 
{ 
  va_list ap ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;

  {
#line 61
  if (msg) {
    {
    {
#line 62
    __builtin_va_start(ap, msg);
    }
    {
#line 63
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             ap);
    }
    {
#line 64
    __builtin_va_end(ap);
    }
    {
#line 65
    tmp___1 = __errno_location();
    }
    {
#line 65
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
            tmp___2);
    }
    }
  }
  {
  {
#line 68
  exit((int )e);
  }
  }
}
}
#line 71 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.c"
void warn_perror(char const   *msg  , ...) 
{ 
  va_list ap ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp5 ;

  {
#line 74
  if (msg) {
    {
    {
#line 75
    __builtin_va_start(ap, msg);
    }
    {
#line 76
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             ap);
    }
    {
#line 77
    __builtin_va_end(ap);
    }
    {
#line 78
    tmp___1 = __errno_location();
    }
    {
#line 78
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
            tmp___2);
    }
    }
  }
#line 80
  return;
}
}
#line 82 "/home/wslee/benchmarks/textformat/unsort-1.1.2/error.c"
void *xalloc(size_t len ) 
{ 
  void *buf ;
  void *tmp___1 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 83
  tmp___1 = malloc(len);
  }
#line 83
  buf = tmp___1;
  }
#line 84
  if (! buf) {
    {
    {
#line 85
    exit_perror((error_code )3, "Can\'t malloc(%llu)", (uint64_t )len);
    }
    }
  }
#line 86
  return (buf);
}
}
#line 29 "/home/wslee/benchmarks/textformat/unsort-1.1.2/msort.h"
void msort32(uint32_t *dd , uint32_t count ) ;
#line 33 "/home/wslee/benchmarks/textformat/unsort-1.1.2/msort.c"
static void msort32_update(uint32_t *dd , uint32_t count , uint32_t o ) 
{ 
  uint32_t d ;
  uint32_t d1 ;
  uint32_t d2 ;
  uint32_t o1 ;
  uint32_t o2 ;

  {
#line 37
  if (! count) {
#line 38
    return;
  }
#line 40
  d = *(dd + o);
  {
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 43
    o1 = o * 2U + 1U;
#line 44
    if (o1 >= count) {
#line 45
      goto while_break;
    }
#line 46
    d1 = *(dd + o1);
#line 48
    o2 = o * 2U + 2U;
#line 49
    if (o2 < count) {
#line 50
      d2 = *(dd + o2);
#line 51
      if (d2 > d1) {
#line 52
        o1 = o2;
#line 53
        d1 = d2;
      }
    }
#line 57
    if (d > d1) {
#line 58
      goto while_break;
    }
#line 60
    *(dd + o1) = d;
#line 61
    *(dd + o) = d1;
#line 62
    o = o1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 66 "/home/wslee/benchmarks/textformat/unsort-1.1.2/msort.c"
void msort32(uint32_t *dd , uint32_t count ) 
{ 
  uint32_t u ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 67
  u = count / 2U;
#line 69
  if (! dd) {
#line 70
    return;
  } else
#line 69
  if (! u) {
#line 70
    return;
  }
  {
  {
#line 72
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 72
    msort32_update(dd, count, u);
    }
#line 72
    tmp___1 = u;
#line 72
    u --;
    }
#line 72
    if (! tmp___1) {
#line 72
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 75
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 75
    tmp___2 = count;
#line 75
    count --;
#line 75
    if (! (tmp___2 > 1U)) {
#line 75
      goto while_break___0;
    }
    {
#line 76
    u = *(dd + 0);
#line 77
    *(dd + 0) = *(dd + count);
#line 78
    *(dd + count) = u;
    {
#line 79
    msort32_update(dd, count, (uint32_t )0);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 31 "/home/wslee/benchmarks/textformat/unsort-1.1.2/merge.h"
void merge(filebuf_t **dd , uint32_t count , uint32_t *src , uint32_t *dst ) ;
#line 34 "/home/wslee/benchmarks/textformat/unsort-1.1.2/merge.c"
static int cmp(filebuf_t *a , filebuf_t *b ) 
{ 
  uint64_t av ;
  uint64_t bv ;
  uint64_t an ;
  uint64_t bn ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 36
  an = (uint64_t )a->count;
#line 37
  if (! an) {
#line 38
    return (1);
  }
#line 39
  bn = (uint64_t )b->count;
#line 40
  if (! bn) {
#line 41
    return (-1);
  }
#line 42
  av = (1ULL + 2ULL * (uint64_t )a->cursor) * bn;
#line 43
  bv = (1ULL + 2ULL * (uint64_t )b->cursor) * an;
#line 44
  if (av < bv) {
#line 45
    return (-1);
  }
#line 46
  if (av > bv) {
#line 47
    return (1);
  }
#line 48
  if ((unsigned long )a < (unsigned long )b) {
#line 48
    tmp___2 = -1;
  } else {
#line 48
    if ((unsigned long )a > (unsigned long )b) {
#line 48
      tmp___1 = 1;
    } else {
#line 48
      tmp___1 = 0;
    }
#line 48
    tmp___2 = tmp___1;
  }
#line 48
  return (tmp___2);
}
}
#line 51 "/home/wslee/benchmarks/textformat/unsort-1.1.2/merge.c"
static void merge_update(filebuf_t **dd , uint32_t count , uint32_t o ) 
{ 
  filebuf_t *d ;
  filebuf_t *d1 ;
  filebuf_t *d2 ;
  uint32_t o1 ;
  uint32_t o2 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 55
  if (! count) {
#line 56
    return;
  }
#line 58
  d = *(dd + o);
  {
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 61
    o1 = o * 2U + 1U;
#line 62
    if (o1 >= count) {
#line 63
      goto while_break;
    }
#line 64
    d1 = *(dd + o1);
#line 66
    o2 = o * 2U + 2U;
#line 67
    if (o2 < count) {
      {
#line 68
      d2 = *(dd + o2);
      {
#line 69
      tmp___1 = cmp(d2, d1);
      }
      }
#line 69
      if (tmp___1 < 0) {
#line 70
        o1 = o2;
#line 71
        d1 = d2;
      }
    }
    {
    {
#line 75
    tmp___2 = cmp(d, d1);
    }
    }
#line 75
    if (tmp___2 < 0) {
#line 76
      goto while_break;
    }
#line 78
    *(dd + o1) = d;
#line 79
    *(dd + o) = d1;
#line 80
    o = o1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 84 "/home/wslee/benchmarks/textformat/unsort-1.1.2/merge.c"
void merge(filebuf_t **dd , uint32_t count , uint32_t *src , uint32_t *dst ) 
{ 
  uint32_t u ;
  uint32_t cur ;
  filebuf_t *d ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 88
  if (! dd) {
#line 89
    return;
  } else
#line 88
  if (! count) {
#line 89
    return;
  }
#line 91
  u = count / 2U;
  {
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 91
    if (! u) {
#line 91
      goto while_break;
    }
    {
    {
#line 92
    merge_update(dd, count, u);
    }
#line 91
    u --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 93
  merge_update(dd, count, u);
  }
  }
  {
  {
#line 95
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 96
    d = *dd;
#line 97
    cur = d->cursor;
#line 98
    if (cur == d->count) {
#line 99
      goto while_break___0;
    }
#line 100
    if (src) {
#line 100
      tmp___1 = src;
#line 100
      src ++;
#line 100
      *(dst + (d->start + cur)) = *tmp___1;
    } else {
#line 100
      tmp___2 = u;
#line 100
      u ++;
#line 100
      *(dst + (d->start + cur)) = tmp___2;
    }
    {
#line 101
    d->cursor = cur + 1U;
    {
#line 102
    merge_update(dd, count, (uint32_t )0);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 34 "/home/wslee/benchmarks/textformat/unsort-1.1.2/merge.c"
static int cmp___0(filebuf_t *a , filebuf_t *b ) 
{ 
  uint64_t av ;
  uint64_t bv ;
  uint64_t an ;
  uint64_t bn ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 36
  an = (uint64_t )a->count;
#line 37
  if (! an) {
#line 38
    return (1);
  }
#line 39
  bn = (uint64_t )b->count;
#line 40
  if (! bn) {
#line 41
    return (-1);
  }
#line 42
  av = (1ULL + 2ULL * (uint64_t )a->cursor) * bn;
#line 43
  bv = (1ULL + 2ULL * (uint64_t )b->cursor) * an;
#line 44
  if (av < bv) {
#line 45
    return (-1);
  }
#line 46
  if (av > bv) {
#line 47
    return (1);
  }
#line 48
  if ((unsigned long )a < (unsigned long )b) {
#line 48
    tmp___2 = -1;
  } else {
#line 48
    if ((unsigned long )a > (unsigned long )b) {
#line 48
      tmp___1 = 1;
    } else {
#line 48
      tmp___1 = 0;
    }
#line 48
    tmp___2 = tmp___1;
  }
#line 48
  return (tmp___2);
}
}
#line 51 "/home/wslee/benchmarks/textformat/unsort-1.1.2/merge.c"
static void merge_update___0(filebuf_t **dd , uint32_t count , uint32_t o ) 
{ 
  filebuf_t *d ;
  filebuf_t *d1 ;
  filebuf_t *d2 ;
  uint32_t o1 ;
  uint32_t o2 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 55
  if (! count) {
#line 56
    return;
  }
#line 58
  d = *(dd + o);
  {
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 61
    o1 = o * 2U + 1U;
#line 62
    if (o1 >= count) {
#line 63
      goto while_break;
    }
#line 64
    d1 = *(dd + o1);
#line 66
    o2 = o * 2U + 2U;
#line 67
    if (o2 < count) {
      {
#line 68
      d2 = *(dd + o2);
      {
#line 69
      tmp___1 = cmp___0(d2, d1);
      }
      }
#line 69
      if (tmp___1 < 0) {
#line 70
        o1 = o2;
#line 71
        d1 = d2;
      }
    }
    {
    {
#line 75
    tmp___2 = cmp___0(d, d1);
    }
    }
#line 75
    if (tmp___2 < 0) {
#line 76
      goto while_break;
    }
#line 78
    *(dd + o1) = d;
#line 79
    *(dd + o) = d1;
#line 80
    o = o1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 44 "/home/wslee/benchmarks/textformat/unsort-1.1.2/iovec.c"
static uint32_t writev_max___0  =    (uint32_t )1024;
#line 33 "/home/wslee/benchmarks/textformat/unsort-1.1.2/msort.c"
static void msort32_update___0(uint32_t *dd , uint32_t count , uint32_t o ) 
{ 
  uint32_t d ;
  uint32_t d1 ;
  uint32_t d2 ;
  uint32_t o1 ;
  uint32_t o2 ;

  {
#line 37
  if (! count) {
#line 38
    return;
  }
#line 40
  d = *(dd + o);
  {
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 43
    o1 = o * 2U + 1U;
#line 44
    if (o1 >= count) {
#line 45
      goto while_break;
    }
#line 46
    d1 = *(dd + o1);
#line 48
    o2 = o * 2U + 2U;
#line 49
    if (o2 < count) {
#line 50
      d2 = *(dd + o2);
#line 51
      if (d2 > d1) {
#line 52
        o1 = o2;
#line 53
        d1 = d2;
      }
    }
#line 57
    if (d > d1) {
#line 58
      goto while_break;
    }
#line 60
    *(dd + o1) = d;
#line 61
    *(dd + o) = d1;
#line 62
    o = o1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 668
extern int puts(char const   *__s ) ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 78
extern int opterr ;
#line 82
extern int optopt ;
#line 175
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 39 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.h"
struct filebuf  const  filebuf_0 ;
#line 41
void filebuf_init(filebuf_t *fb , int fd ) ;
#line 29 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.h"
void (* const  shuffle_heuristic)(uint32_t * , uint32_t * , uint32_t  ) ;
#line 31
void shuffle_seed(uint32_t s ) ;
#line 32
void shuffle_tmp(uint32_t *t ) ;
#line 34
void shuffle_none(uint32_t *src , uint32_t *dst , uint32_t count ) ;
#line 35
void shuffle_random(uint32_t *src , uint32_t *dst , uint32_t count ) ;
#line 32 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.h"
uint32_t mt_genrand32(void) ;
#line 53 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
static struct option  const  long_options[13]  = 
#line 53 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
  {      {"help\000             Print this message to stdout", 0, (int *)0, 'h'}, 
        {"version\000          Print the program version", 0, (int *)0, 'v'}, 
        {"random\000           Use a random permutation", 0, (int *)0, 'r'}, 
        {"heuristic\000        Use a heuristic permutation (default)", 0, (int *)0, 'p'}, 
        {"identity\000         Do not change the order of lines",
      0, (int *)0, 'n'}, 
        {"concatenate\000      Concatenate input before shuffling", 0, (int *)0, 'c'}, 
        {"merge\000            Merge input after shuffling in given order",
      0, (int *)0, 'm'}, 
        {"merge-random\000     Merge input after shuffling (default)", 0, (int *)0, 'M'}, 
        {"seed\000 <integer>   Seed the permutation",
      1, (int *)0, 's'}, 
        {"zero-terminated\000  Use \\0 line endings", 0, (int *)0, 'z'}, 
        {"null\000             Use \\0 line endings", 0, (int *)0, '0'}, 
        {"linefeed\000         Use \\n line endings (default)", 0, (int *)0, 'l'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 69 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
static void usage(FILE *fh , char const   *progname ) 
{ 
  int i ;
  size_t tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 71
  fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"Usage: %s [-",
          progname);
  }
#line 72
  i = 0;
  }
  {
  {
#line 72
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 72
    if (! long_options[i].name) {
#line 72
      goto while_break;
    }
#line 73
    if (long_options[i].val) {
#line 73
      if (! long_options[i].has_arg) {
        {
        {
#line 74
        fputc((int )long_options[i].val, fh);
        }
        }
      }
    }
#line 72
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 75
  fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"] [-s <integer>] [file...]\n");
  }
#line 76
  i = 0;
  }
  {
  {
#line 76
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! long_options[i].name) {
#line 76
      goto while_break___0;
    }
    {
    {
#line 77
    tmp___1 = strlen((char const   *)long_options[i].name);
    }
    {
#line 77
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\t-%c, --%s%s\n",
            long_options[i].val, long_options[i].name, (long_options[i].name + tmp___1) + 1);
    }
#line 76
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int fd ;
  int option_index ;
  struct iovec *iov ;
  uint32_t u ;
  uint32_t numfiles ;
  uint32_t count ;
  uint32_t chunk_count ;
  uint32_t chunk_start ;
  uint32_t *tlb ;
  uint32_t *chunk_tlb ;
  filebuf_t *fb ;
  filebuf_t *ds ;
  filebuf_t **dd ;
  uint32_t seed___1 ;
  _Bool manual_seed ;
  _Bool multi ;
  void (*shuffle_algo)(uint32_t * , uint32_t * , uint32_t  ) ;
  void (*shuffle_files)(uint32_t * , uint32_t * , uint32_t  ) ;
  char *end ;
  int sep ;
  int *tmp___1 ;
  unsigned long tmp___2 ;
  int *tmp___3 ;
  _Bool tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
#line 90
  seed___1 = (uint32_t )0;
#line 91
  manual_seed = (_Bool)0;
#line 92
  multi = (_Bool)1;
#line 93
  shuffle_algo = (void (*)(uint32_t * , uint32_t * , uint32_t  ))shuffle_heuristic;
#line 94
  shuffle_files = & shuffle_random;
#line 96
  sep = '\n';
#line 98
  opterr = 0;
  {
  {
#line 99
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 99
    i = getopt_long(argc, (char * const  *)argv, ":hvrpncmMs:z0l", long_options, & option_index);
    }
    }
#line 99
    if (! (i != -1)) {
#line 99
      goto while_break;
    }
    {
#line 101
    if (i == 104) {
#line 101
      goto case_104;
    }
#line 105
    if (i == 118) {
#line 105
      goto case_118;
    }
#line 108
    if (i == 114) {
#line 108
      goto case_114;
    }
#line 111
    if (i == 112) {
#line 111
      goto case_112;
    }
#line 114
    if (i == 110) {
#line 114
      goto case_110;
    }
#line 117
    if (i == 99) {
#line 117
      goto case_99;
    }
#line 120
    if (i == 109) {
#line 120
      goto case_109;
    }
#line 124
    if (i == 77) {
#line 124
      goto case_77;
    }
#line 128
    if (i == 115) {
#line 128
      goto case_115;
    }
#line 143
    if (i == 122) {
#line 143
      goto case_122;
    }
#line 143
    if (i == 48) {
#line 143
      goto case_122;
    }
#line 146
    if (i == 108) {
#line 146
      goto case_108;
    }
#line 149
    if (i == 63) {
#line 149
      goto case_63;
    }
#line 152
    if (i == 58) {
#line 152
      goto case_58;
    }
#line 155
    goto switch_default;
    case_104: /* CIL Label */ 
    {
    {
#line 102
    puts("unsort - reorder files semi-randomly");
    }
    {
#line 103
    usage(stdout, (char const   *)*argv);
    }
    {
#line 104
    exit(0);
    }
    }
    case_118: /* CIL Label */ 
    {
    {
#line 106
    printf((char const   */* __restrict  */)"unsort %s\ncopyright 2007, 2008 Wessel Dankers <wsl@fruit.je>\n",
           "1.1.2");
    }
    {
#line 107
    exit(0);
    }
    }
    case_114: /* CIL Label */ 
#line 109
    shuffle_algo = & shuffle_random;
#line 110
    goto switch_break;
    case_112: /* CIL Label */ 
#line 112
    shuffle_algo = (void (*)(uint32_t * , uint32_t * , uint32_t  ))shuffle_heuristic;
#line 113
    goto switch_break;
    case_110: /* CIL Label */ 
#line 115
    shuffle_algo = & shuffle_none;
#line 116
    goto switch_break;
    case_99: /* CIL Label */ 
#line 118
    multi = (_Bool)0;
#line 119
    goto switch_break;
    case_109: /* CIL Label */ 
#line 121
    multi = (_Bool)1;
#line 122
    shuffle_files = & shuffle_none;
#line 123
    goto switch_break;
    case_77: /* CIL Label */ 
#line 125
    multi = (_Bool)1;
#line 126
    shuffle_files = & shuffle_random;
#line 127
    goto switch_break;
    case_115: /* CIL Label */ 
#line 129
    if (optarg) {
#line 129
      if (*optarg) {
        {
        {
#line 130
        tmp___1 = __errno_location();
        }
#line 130
        *tmp___1 = 0;
        {
#line 131
        tmp___2 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& end),
                          0);
        }
#line 131
        seed___1 = (uint32_t )tmp___2;
        {
#line 132
        tmp___3 = __errno_location();
        }
        }
#line 132
        if (*tmp___3) {
          {
          {
#line 133
          exit_perror((error_code )1, "Can\'t parse seed \'%s\' as an unsigned integer",
                      optarg);
          }
          }
        }
#line 134
        if (end) {
#line 134
          if (*end) {
            {
            {
#line 135
            exit_error((error_code )1, "Can\'t parse seed \'%s\' as an unsigned integer",
                       optarg);
            }
            }
          }
        }
#line 136
        manual_seed = (_Bool)1;
      } else {
#line 138
        seed___1 = 0U;
#line 139
        manual_seed = (_Bool)0;
      }
    } else {
#line 138
      seed___1 = 0U;
#line 139
      manual_seed = (_Bool)0;
    }
#line 141
    goto switch_break;
    case_122: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 144
    sep = '\000';
#line 145
    goto switch_break;
    case_108: /* CIL Label */ 
#line 147
    sep = '\n';
#line 148
    goto switch_break;
    case_63: /* CIL Label */ 
    {
    {
#line 150
    usage(stderr, (char const   *)*argv);
    }
    {
#line 151
    exit_error((error_code )1, "Unknown option: -%c", optopt);
    }
    }
    case_58: /* CIL Label */ 
    {
    {
#line 153
    usage(stderr, (char const   *)*argv);
    }
    {
#line 154
    exit_error((error_code )1, "Option -%c requires an argument", optopt);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 156
    usage(stderr, (char const   *)*argv);
    }
    {
#line 157
    exit_error((error_code )4, "Unknown option: -%c", i);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (argc > optind) {
#line 162
    numfiles = (uint32_t )(argc - optind);
  } else {
#line 164
    numfiles = (uint32_t )1;
  }
#line 166
  if (manual_seed) {
    {
    {
#line 167
    mt_seed(seed___1);
    }
    }
  } else {
    {
    {
#line 169
    tmp___4 = mt_init_urandom();
    }
    }
#line 169
    if (! tmp___4) {
      {
      {
#line 170
      exit_perror((error_code )3, "Can\'t read from /dev/urandom");
      }
      }
    }
    {
    {
#line 171
    seed___1 = mt_genrand32();
    }
    }
  }
  {
  {
#line 173
  shuffle_seed(seed___1);
  }
  {
#line 175
  tmp___5 = xalloc((size_t )((unsigned long )numfiles * sizeof(*dd)));
  }
#line 175
  dd = (filebuf_t **)tmp___5;
  {
#line 176
  tmp___6 = xalloc((size_t )((unsigned long )numfiles * sizeof(*ds)));
  }
#line 176
  ds = (filebuf_t *)tmp___6;
#line 177
  tlb = (uint32_t *)ds;
  {
#line 179
  (*shuffle_files)((uint32_t *)((void *)0), tlb, numfiles);
  }
#line 180
  u = (uint32_t )0;
  }
  {
  {
#line 180
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! (u < numfiles)) {
#line 180
      goto while_break___0;
    }
#line 181
    *(dd + u) = ds + *(tlb + u);
#line 180
    u ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  u = (uint32_t )0;
#line 184
  if (argc > optind) {
#line 185
    i = optind;
    {
    {
#line 185
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 185
      if (! (i < argc)) {
#line 185
        goto while_break___1;
      }
      {
#line 186
      tmp___7 = u;
#line 186
      u ++;
#line 186
      fb = *(dd + tmp___7);
#line 187
      *fb = (filebuf_t )filebuf_0;
      {
#line 188
      tmp___8 = strcmp((char const   *)*(argv + i), "-");
      }
      }
#line 188
      if (tmp___8) {
        {
        {
#line 189
        fd = open((char const   *)*(argv + i), 32768);
        }
        }
#line 190
        if (fd == -1) {
          {
          {
#line 191
          warn_perror("Can\'t open %s", *(argv + i));
          }
          }
#line 192
          goto __Cont;
        }
        {
        {
#line 194
        filebuf_init(fb, fd);
        }
        {
#line 195
        close(fd);
        }
#line 196
        fb->name = (char const   *)*(argv + i);
        }
      } else {
        {
        {
#line 198
        filebuf_init(fb, 0);
        }
        }
      }
      __Cont: /* CIL Label */ 
#line 185
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 202
    filebuf_init(*dd, 0);
    }
    }
  }
#line 205
  count = (uint32_t )0;
#line 206
  u = (uint32_t )0;
  {
  {
#line 206
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 206
    if (! (u < numfiles)) {
#line 206
      goto while_break___2;
    }
    {
#line 207
    fb = *(dd + u);
    {
#line 208
    tmp___9 = iovec_parse(fb, sep, (struct iovec *)((void *)0), (uint32_t const   *)((void *)0));
    }
    }
#line 208
    if (tmp___9) {
#line 209
      if (fb->name) {
        {
        {
#line 210
        warn_error("%s: missing linebreak at end of file \342\200\223 line skipped",
                   fb->name);
        }
        }
      } else {
        {
        {
#line 212
        warn_error("missing linebreak at end of input \342\200\223 line skipped");
        }
        }
      }
    }
#line 214
    fb->start = count;
#line 215
    count += fb->count;
#line 206
    u ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 218
  if (! count) {
#line 219
    return (0);
  }
  {
  {
#line 221
  tmp___10 = xalloc((size_t )((unsigned long )count * sizeof(*tlb)));
  }
#line 221
  tlb = (uint32_t *)tmp___10;
  {
#line 222
  tmp___11 = xalloc((size_t )((unsigned long )count * sizeof(*iov)));
  }
#line 222
  iov = (struct iovec *)tmp___11;
#line 224
  chunk_tlb = (uint32_t *)iov;
  {
#line 225
  shuffle_tmp(chunk_tlb + count);
  }
  }
#line 227
  if (multi) {
    {
    {
#line 228
    merge(dd, numfiles, (uint32_t *)((void *)0), chunk_tlb);
    }
#line 230
    u = (uint32_t )0;
    }
    {
    {
#line 230
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 230
      if (! (u < numfiles)) {
#line 230
        goto while_break___3;
      }
      {
#line 231
      fb = *(dd + u);
#line 232
      chunk_start = fb->start;
#line 233
      chunk_count = fb->count;
      {
#line 234
      (*shuffle_algo)(chunk_tlb + chunk_start, tlb + chunk_start, chunk_count);
      }
#line 230
      u ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 237
    (*shuffle_algo)((uint32_t *)((void *)0), tlb, count);
    }
    }
  }
#line 240
  u = (uint32_t )0;
  {
  {
#line 240
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 240
    if (! (u < numfiles)) {
#line 240
      goto while_break___4;
    }
    {
    {
#line 241
    iovec_parse(*(dd + u), sep, iov, (uint32_t const   *)tlb);
    }
#line 240
    u ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
  {
#line 243
  writev_all(1, iov, count);
  }
  }
#line 245
  return (0);
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 37 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.h"
uint32_t mt_genrand32_bounded(uint32_t min , uint32_t max ) ;
#line 33 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.h"
void shuffle_init(uint32_t *a , uint32_t count ) ;
#line 36
void shuffle_bitreverse(uint32_t *src , uint32_t *dst , uint32_t count ) ;
#line 37
void shuffle_sqrtbase(uint32_t *src , uint32_t *dst , uint32_t count ) ;
#line 34 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t u32reverse(uint32_t i ) 
{ 


  {
#line 35
  i = ((i & 2863311530U) >> 1) | ((i & 1431655765U) << 1);
#line 36
  i = ((i & 3435973836U) >> 2) | ((i & 858993459U) << 2);
#line 37
  i = ((i & 4042322160U) >> 4) | ((i & 252645135U) << 4);
#line 38
  i = ((i & 4278255360U) >> 8) | ((i & 16711935U) << 8);
#line 39
  return ((i << 16) | (i >> 16));
}
}
#line 42 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static void u32swap(uint32_t *a , uint32_t *b ) 
{ 
  uint32_t u ;

  {
#line 44
  u = *a;
#line 45
  *a = *b;
#line 46
  *b = u;
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t sqrt32(uint32_t u ) 
{ 
  uint32_t r ;
  uint32_t p ;

  {
#line 52
  if (u < 2U) {
#line 53
    return (u);
  }
#line 55
  p = u / 2U;
#line 55
  r = p;
  {
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    p = r;
#line 59
    r = (p + u / p) / 2U;
#line 57
    if (! (r < p)) {
#line 57
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (p);
}
}
#line 65 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t seed  =    (uint32_t )0;
#line 66 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t *tmp  =    (uint32_t *)((void *)0);
#line 68 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_seed(uint32_t s ) 
{ 


  {
#line 69
  seed = s;
#line 70
  return;
}
}
#line 72 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_tmp(uint32_t *t ) 
{ 


  {
#line 73
  tmp = t;
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_init(uint32_t *a , uint32_t count ) 
{ 
  uint32_t u ;

  {
#line 78
  u = (uint32_t )0;
  {
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 78
    if (! (u < count)) {
#line 78
      goto while_break;
    }
#line 79
    *(a + u) = u;
#line 78
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 82 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_none(uint32_t *src , uint32_t *dst , uint32_t count ) 
{ 


  {
#line 83
  if (! count) {
#line 84
    return;
  }
#line 86
  if (src) {
#line 87
    if ((unsigned long )src != (unsigned long )dst) {
      {
      {
#line 88
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )((unsigned long )count * sizeof(*src)));
      }
      }
    }
  } else {
    {
    {
#line 90
    shuffle_init(dst, count);
    }
    }
  }
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_random(uint32_t *src , uint32_t *dst , uint32_t count ) 
{ 
  uint32_t u ;
  uint32_t tmp___1 ;

  {
#line 97
  if (! count) {
#line 98
    return;
  }
#line 100
  if ((unsigned long )src != (unsigned long )dst) {
#line 101
    if (src) {
      {
      {
#line 102
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )((unsigned long )count * sizeof(*src)));
      }
      }
    } else {
      {
      {
#line 104
      shuffle_init(dst, count);
      }
      }
    }
  }
#line 106
  u = count - 1U;
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! (u > 0U)) {
#line 106
      goto while_break;
    }
    {
    {
#line 107
    tmp___1 = mt_genrand32_bounded((uint32_t )0, u + 1U);
    }
    {
#line 107
    u32swap(dst + tmp___1, dst + u);
    }
#line 106
    u --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_bitreverse(uint32_t *src , uint32_t *dst , uint32_t count ) 
{ 
  uint32_t u ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
#line 113
  if (! count) {
#line 114
    return;
  }
#line 116
  if ((unsigned long )src == (unsigned long )dst) {
#line 117
    u = (uint32_t )0;
    {
    {
#line 117
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 117
      if (! (u < count)) {
#line 117
        goto while_break;
      }
      {
      {
#line 118
      *(dst + u) = u32reverse(*(dst + u) ^ seed);
      }
#line 117
      u ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 119
    src = (uint32_t *)((void *)0);
  } else {
#line 121
    u = (uint32_t )0;
    {
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! (u < count)) {
#line 121
        goto while_break___0;
      }
      {
      {
#line 122
      *(dst + u) = u32reverse(u ^ seed);
      }
#line 121
      u ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  {
#line 124
  msort32(dst, count);
  }
  }
#line 125
  if (src) {
#line 126
    u = (uint32_t )0;
    {
    {
#line 126
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 126
      if (! (u < count)) {
#line 126
        goto while_break___1;
      }
      {
      {
#line 127
      tmp___1 = u32reverse(*(dst + u));
      }
#line 127
      *(dst + u) = *(src + (tmp___1 ^ seed));
#line 126
      u ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 129
    u = (uint32_t )0;
    {
    {
#line 129
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 129
      if (! (u < count)) {
#line 129
        goto while_break___2;
      }
      {
      {
#line 130
      tmp___2 = u32reverse(*(dst + u));
      }
#line 130
      *(dst + u) = tmp___2 ^ seed;
#line 129
      u ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t rev(uint32_t r , uint32_t *a , uint32_t u ) 
{ 


  {
#line 134
  return ((u % r) * r + *(a + u / r));
}
}
#line 137 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t fwd(uint32_t r , uint32_t *a , uint32_t u ) 
{ 


  {
#line 138
  return (*(a + u % r) * r + u / r);
}
}
#line 141 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static void shuffle_invert(uint32_t *src , uint32_t *dst , uint32_t count ) 
{ 
  uint32_t u ;

  {
#line 143
  u = (uint32_t )0;
  {
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 143
    if (! (u < count)) {
#line 143
      goto while_break;
    }
#line 144
    *(dst + *(src + u)) = u;
#line 143
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 147 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void shuffle_sqrtbase(uint32_t *src , uint32_t *dst , uint32_t count ) 
{ 
  uint32_t u ;
  uint32_t r ;
  uint32_t *a ;
  uint32_t *b ;
  uint32_t tmp___1 ;

  {
#line 151
  if (! count) {
#line 152
    return;
  }
#line 154
  if ((unsigned long )src == (unsigned long )dst) {
    {
    {
#line 155
    shuffle_bitreverse(src, dst, count);
    }
    }
#line 156
    return;
  } else
#line 154
  if (! tmp) {
    {
    {
#line 155
    shuffle_bitreverse(src, dst, count);
    }
    }
#line 156
    return;
  }
  {
  {
#line 159
  r = sqrt32(count);
  }
  }
#line 160
  if (r * r < count) {
#line 161
    r ++;
  }
  {
#line 163
  a = tmp;
#line 164
  b = a + r;
  {
#line 166
  shuffle_random((uint32_t *)((void *)0), a, r);
  }
#line 168
  u = (uint32_t )0;
  }
  {
  {
#line 168
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 168
    if (! (u < count)) {
#line 168
      goto while_break;
    }
    {
    {
#line 169
    *(dst + u) = fwd(r, a, u);
    }
#line 168
    u ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 171
  msort32(dst, count);
  }
  {
#line 172
  shuffle_invert(a, b, r);
  }
  }
#line 173
  if (src) {
#line 174
    u = (uint32_t )0;
    {
    {
#line 174
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 174
      if (! (u < count)) {
#line 174
        goto while_break___0;
      }
      {
      {
#line 175
      tmp___1 = rev(r, b, *(dst + u));
      }
#line 175
      *(dst + u) = *(src + tmp___1);
#line 174
      u ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 177
    u = (uint32_t )0;
    {
    {
#line 177
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 177
      if (! (u < count)) {
#line 177
        goto while_break___1;
      }
      {
      {
#line 178
      *(dst + u) = rev(r, b, *(dst + u));
      }
#line 177
      u ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 179
  return;
}
}
#line 181 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
void (* const  shuffle_heuristic)(uint32_t * , uint32_t * , uint32_t  )  =    (void (*/* const  */)(uint32_t * , uint32_t * , uint32_t  ))(& shuffle_sqrtbase);
#line 31 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.h"
int32_t mt_genrand31(void) ;
#line 33
double mt_genrand_real1(void) ;
#line 34
double mt_genrand_real2(void) ;
#line 35
double mt_genrand_real3(void) ;
#line 36
double mt_genrand_res53(void) ;
#line 56 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
static uint32_t mt[624]  ;
#line 57 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
static uint32_t mti  =    (uint32_t )625;
#line 60 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
void mt_seed(uint32_t s ) 
{ 


  {
#line 64
  mti = (uint32_t )1;
  {
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 64
    if (! (mti < 624U)) {
#line 64
      goto while_break;
    }
#line 65
    mt[mti] = 1812433253U * (mt[mti - 1U] ^ (mt[mti - 1U] >> 30)) + mti;
#line 64
    mti ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
void mt_seed_array(uint32_t *init_key , unsigned int key_length ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;

  {
  {
#line 72
  i = 1U;
#line 72
  j = 0U;
  {
#line 73
  mt_seed(19650218U);
  }
  }
#line 74
  if (key_length < 624U) {
#line 74
    k = key_length;
  } else {
#line 74
    k = 624U;
  }
  {
  {
#line 74
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 74
    if (! k) {
#line 74
      goto while_break;
    }
#line 75
    mt[i] = ((mt[i] ^ (mt[i - 1U] ^ (mt[i - 1U] >> 30)) * 1664525U) + *(init_key + j)) + j;
#line 77
    i ++;
#line 77
    if (i >= 624U) {
#line 78
      mt[0] = mt[623];
#line 79
      i = 1U;
    }
#line 81
    j ++;
#line 81
    if (j >= key_length) {
#line 82
      j = 0U;
    }
#line 74
    k --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  k = 623U;
  {
  {
#line 84
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! k) {
#line 84
      goto while_break___0;
    }
#line 85
    mt[i] = (mt[i] ^ (mt[i - 1U] ^ (mt[i - 1U] >> 30)) * 1566083941U) - i;
#line 87
    i ++;
#line 87
    if (i >= 624U) {
#line 88
      mt[0] = mt[623];
#line 89
      i = 1U;
    }
#line 84
    k --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  mt[0] = 2147483648U;
#line 95
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
static uint32_t mag01[2]  = {      0U,      2567483615U};
#line 98 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
uint32_t mt_genrand32(void) 
{ 
  uint32_t y ;
  int kk ;
  uint32_t tmp___1 ;

  {
#line 103
  if (mti >= 624U) {
#line 106
    if (mti == 625U) {
      {
      {
#line 107
      mt_seed(5489U);
      }
      }
    }
#line 109
    kk = 0;
    {
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 109
      if (! (kk < 227)) {
#line 109
        goto while_break;
      }
#line 110
      y = (mt[kk] & 2147483648U) | (mt[kk + 1] & 2147483647U);
#line 111
      mt[kk] = (mt[kk + 397] ^ (y >> 1)) ^ mag01[y & 1U];
#line 109
      kk ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 113
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! (kk < 623)) {
#line 113
        goto while_break___0;
      }
#line 114
      y = (mt[kk] & 2147483648U) | (mt[kk + 1] & 2147483647U);
#line 115
      mt[kk] = (mt[kk + -227] ^ (y >> 1)) ^ mag01[y & 1U];
#line 113
      kk ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 117
    y = (mt[623] & 2147483648U) | (mt[0] & 2147483647U);
#line 118
    mt[623] = (mt[396] ^ (y >> 1)) ^ mag01[y & 1U];
#line 120
    mti = (uint32_t )0;
  }
#line 123
  tmp___1 = mti;
#line 123
  mti ++;
#line 123
  y = mt[tmp___1];
#line 126
  y ^= y >> 11;
#line 127
  y ^= (y << 7) & 2636928640U;
#line 128
  y ^= (y << 15) & 4022730752U;
#line 129
  y ^= y >> 18;
#line 131
  return (y);
}
}
#line 135 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
int32_t mt_genrand31(void) 
{ 
  uint32_t tmp___1 ;

  {
  {
  {
#line 136
  tmp___1 = mt_genrand32();
  }
  }
#line 136
  return ((int32_t )(tmp___1 >> 1));
}
}
#line 141 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
double mt_genrand_real1(void) 
{ 
  uint32_t x ;
  uint32_t tmp___1 ;

  {
  {
  {
#line 143
  tmp___1 = mt_genrand32();
  }
#line 143
  x = tmp___1;
  }
#line 144
  return ((double )x * (1.0 / 4294967295.0));
}
}
#line 148 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
double mt_genrand_real2(void) 
{ 
  uint32_t x ;
  uint32_t tmp___1 ;

  {
  {
  {
#line 150
  tmp___1 = mt_genrand32();
  }
#line 150
  x = tmp___1;
  }
#line 151
  return ((double )x * (1.0 / 4294967296.0));
}
}
#line 155 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
double mt_genrand_real3(void) 
{ 
  uint32_t x ;
  uint32_t tmp___1 ;

  {
  {
  {
#line 157
  tmp___1 = mt_genrand32();
  }
#line 157
  x = tmp___1;
  }
#line 158
  return (((double )x + 0.5) * (1.0 / 4294967296.0));
}
}
#line 162 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
double mt_genrand_res53(void) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
  {
#line 164
  tmp___1 = mt_genrand32();
  }
#line 164
  a = tmp___1 >> 5;
  {
#line 165
  tmp___2 = mt_genrand32();
  }
#line 165
  b = tmp___2 >> 6;
  }
#line 167
  return (((double )a * 67108864.0 + (double )b) * (1.0 / 9007199254740992.0));
}
}
#line 170 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
uint32_t mt_genrand32_bounded(uint32_t min , uint32_t max ) 
{ 
  uint64_t x ;
  uint32_t tmp___1 ;

  {
  {
#line 171
  x = (uint64_t )(max - min);
  {
#line 172
  tmp___1 = mt_genrand32();
  }
#line 172
  x *= (uint64_t )tmp___1;
  }
#line 173
  return (min + (uint32_t )(x >> 32));
}
}
#line 175 "/usr/include/stdio.h"
extern FILE *tmpfile(void)  __asm__("tmpfile64")  ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 526
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 614
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 1023
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 220 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf )  __asm__("fstat64")  ;
#line 62 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 37 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
struct filebuf  const  filebuf_0  =    {(void *)0, 0U, (char const   *)0, 0U, 0U, 0U};
#line 41 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static int filebuf_tmp(void) 
{ 
  FILE *fh ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 44
  fh = tmpfile();
  }
  }
#line 45
  if (! fh) {
    {
    {
#line 46
    exit_perror((error_code )3, "Can\'t create temporary file");
    }
    }
  }
  {
  {
#line 47
  tmp___1 = fileno(fh);
  }
  {
#line 47
  fd = dup(tmp___1);
  }
  }
#line 48
  if (fd == -1) {
    {
    {
#line 49
    tmp___2 = fileno(fh);
    }
    {
#line 49
    exit_perror((error_code )3, "Can\'t dup(%d)", tmp___2);
    }
    }
  }
  {
  {
#line 50
  fclose(fh);
  }
  }
#line 51
  return (fd);
}
}
#line 54 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static void write_all(int fd , void *buf , size_t len ) 
{ 
  ssize_t r ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 56
    if (! len) {
#line 56
      goto while_break;
    }
    {
    {
#line 57
    r = write(fd, (void const   *)buf, len);
    }
    }
#line 58
    if (! r) {
      {
      {
#line 59
      exit_error((error_code )3, "Can\'t write to fd %d", fd);
      }
      }
    }
#line 60
    if (r == -1) {
      {
      {
#line 61
      exit_perror((error_code )3, "Can\'t write to fd %d", fd);
      }
      }
    }
#line 62
    buf = (void *)((uint8_t *)buf + (size_t )r);
#line 63
    len -= (size_t )r;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static _Bool filebuf_mmap(int fd , filebuf_t *fb , size_t len ) 
{ 
  void *buf ;

  {
  {
  {
#line 69
  buf = mmap((void *)0, len, 1, 1, fd, (__off64_t )0);
  }
  }
#line 70
  if ((unsigned long )buf == (unsigned long )((void *)-1)) {
#line 71
    return ((_Bool)1);
  }
#line 72
  fb->buf = buf;
#line 73
  fb->len = len;
#line 74
  return ((_Bool)0);
}
}
#line 80 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static void *streambuf  =    (void *)0;
#line 81 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static size_t streamleft  =    (size_t )1048576;
#line 88
static void filebuf_stream(int fd , filebuf_t *fb ) ;
#line 88 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static int pg  =    -1;
#line 83 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static void filebuf_stream(int fd , filebuf_t *fb ) 
{ 
  void *buf ;
  size_t len ;
  size_t left ;
  size_t edge ;
  size_t offset ;
  ssize_t r ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 85
  len = (size_t )0;
#line 85
  offset = (size_t )0;
#line 90
  if (! streambuf) {
    {
    {
#line 91
    streambuf = xalloc(streamleft);
    }
    }
  }
#line 93
  buf = streambuf;
#line 94
  left = streamleft;
  {
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 96
    if (! (left >= 4096U)) {
#line 96
      goto while_break;
    }
    {
    {
#line 97
    r = read(fd, (void *)((uint8_t *)buf + len), left);
    }
    }
#line 98
    if (r == -1) {
      {
      {
#line 99
      exit_perror((error_code )3, "Can\'t read from fd %d", fd);
      }
      }
    }
#line 100
    if (! r) {
#line 101
      if (len) {
#line 102
        streambuf = (void *)((uint8_t *)streambuf + len);
#line 103
        streamleft -= len;
      } else {
#line 105
        buf = (void *)0;
      }
#line 107
      fb->buf = buf;
#line 108
      fb->len = len;
#line 109
      return;
    }
#line 111
    len += (size_t )r;
#line 112
    left -= (size_t )r;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 115
  tmp___1 = filebuf_tmp();
  }
  {
#line 116
  write_all(tmp___1, buf, len);
  }
#line 117
  buf = (void *)0;
  }
#line 119
  if (pg == -1) {
    {
    {
#line 120
    tmp___2 = sysconf(30);
    }
#line 120
    pg = (int )tmp___2;
    }
  }
#line 122
  left = (size_t )0;
  {
  {
#line 123
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 124
    if (left < 4096U) {
#line 125
      if (buf) {
        {
        {
#line 125
        tmp___3 = munmap(buf, (size_t )1048576);
        }
        }
#line 125
        if (tmp___3 == -1) {
          {
          {
#line 126
          exit_perror((error_code )3, "Can\'t munmap %d bytes", 1048576);
          }
          }
        }
      }
      {
#line 127
      edge = len % (unsigned int )pg;
#line 128
      offset = len - edge;
#line 129
      left = 1048576U - edge;
      {
#line 130
      tmp___4 = ftruncate(tmp___1, (off_t )(offset + 1048576U));
      }
      }
#line 130
      if (tmp___4 == -1) {
        {
        {
#line 131
        exit_perror((error_code )3, "Can\'t extend fd %d to %ld bytes", tmp___1, (long )(offset + 1048576U));
        }
        }
      }
      {
      {
#line 132
      buf = mmap((void *)0, (size_t )1048576, 2, 1, tmp___1, (off_t )offset);
      }
      }
#line 133
      if ((unsigned long )buf == (unsigned long )((void *)-1)) {
        {
        {
#line 134
        exit_perror((error_code )3, "Can\'t mmap fd %d for writing", fd);
        }
        }
      }
    }
    {
    {
#line 136
    r = read(fd, (void *)(((char *)buf + len) - offset), left);
    }
    }
#line 137
    if (! r) {
#line 138
      goto while_break___0;
    }
#line 139
    if (r == -1) {
      {
      {
#line 140
      exit_perror((error_code )3, "Can\'t read from fd %d", tmp___1);
      }
      }
    }
#line 141
    len += (size_t )r;
#line 142
    left -= (size_t )r;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  if (buf) {
    {
    {
#line 145
    tmp___5 = munmap(buf, (size_t )1048576);
    }
    }
#line 145
    if (tmp___5 == -1) {
      {
      {
#line 146
      exit_perror((error_code )3, "Can\'t munmap %d bytes", 1048576);
      }
      }
    }
  }
  {
  {
#line 147
  tmp___6 = ftruncate(tmp___1, (off_t )len);
  }
  }
#line 147
  if (tmp___6 == -1) {
    {
    {
#line 148
    exit_perror((error_code )3, "Can\'t truncate fd %d to %ld bytes", tmp___1, (long )len);
    }
    }
  }
  {
  {
#line 150
  tmp___7 = filebuf_mmap(tmp___1, fb, len);
  }
  }
#line 150
  if (tmp___7) {
    {
    {
#line 151
    exit_perror((error_code )3, "Can\'t mmap fd %d", tmp___1);
    }
    }
  }
  {
  {
#line 153
  close(tmp___1);
  }
  }
#line 154
  return;
}
}
#line 156 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
void filebuf_init(filebuf_t *fb , int fd ) 
{ 
  struct stat st ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
  {
#line 159
  tmp___1 = fstat(fd, & st);
  }
  }
#line 159
  if (tmp___1) {
    {
    {
#line 160
    filebuf_stream(fd, fb);
    }
    }
  } else
#line 159
  if (! st.st_size) {
    {
    {
#line 160
    filebuf_stream(fd, fb);
    }
    }
  } else {
    {
    {
#line 159
    tmp___2 = filebuf_mmap(fd, fb, (size_t )st.st_size);
    }
    }
#line 159
    if (tmp___2) {
      {
      {
#line 160
      filebuf_stream(fd, fb);
      }
      }
    }
  }
#line 161
  return;
}
}
#line 34 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t u32reverse___0(uint32_t i ) 
{ 


  {
#line 35
  i = ((i & 2863311530U) >> 1) | ((i & 1431655765U) << 1);
#line 36
  i = ((i & 3435973836U) >> 2) | ((i & 858993459U) << 2);
#line 37
  i = ((i & 4042322160U) >> 4) | ((i & 252645135U) << 4);
#line 38
  i = ((i & 4278255360U) >> 8) | ((i & 16711935U) << 8);
#line 39
  return ((i << 16) | (i >> 16));
}
}
#line 42 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static void u32swap___0(uint32_t *a , uint32_t *b ) 
{ 
  uint32_t u ;

  {
#line 44
  u = *a;
#line 45
  *a = *b;
#line 46
  *b = u;
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t sqrt32___0(uint32_t u ) 
{ 
  uint32_t r ;
  uint32_t p ;

  {
#line 52
  if (u < 2U) {
#line 53
    return (u);
  }
#line 55
  p = u / 2U;
#line 55
  r = p;
  {
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    p = r;
#line 59
    r = (p + u / p) / 2U;
#line 57
    if (! (r < p)) {
#line 57
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return (p);
}
}
#line 65 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t seed___0  =    (uint32_t )0;
#line 66 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t *tmp___0  =    (uint32_t *)((void *)0);
#line 133 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t rev___0(uint32_t r , uint32_t *a , uint32_t u ) 
{ 


  {
#line 134
  return ((u % r) * r + *(a + u / r));
}
}
#line 137 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static uint32_t fwd___0(uint32_t r , uint32_t *a , uint32_t u ) 
{ 


  {
#line 138
  return (*(a + u % r) * r + u / r);
}
}
#line 141 "/home/wslee/benchmarks/textformat/unsort-1.1.2/shuffle.c"
static void shuffle_invert___0(uint32_t *src , uint32_t *dst , uint32_t count ) 
{ 
  uint32_t u ;

  {
#line 143
  u = (uint32_t )0;
  {
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 143
    if (! (u < count)) {
#line 143
      goto while_break;
    }
#line 144
    *(dst + *(src + u)) = u;
#line 143
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 56 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
static uint32_t mt___0[624]  ;
#line 57 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
static uint32_t mti___0  =    (uint32_t )625;
#line 100 "/home/wslee/benchmarks/textformat/unsort-1.1.2/mt19937ar.c"
static uint32_t mag01___0[2]  = {      0U,      2567483615U};
#line 53 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
static struct option  const  long_options___0[13]  = 
#line 53 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
  {      {"help\000             Print this message to stdout", 0, (int *)0, 'h'}, 
        {"version\000          Print the program version", 0, (int *)0, 'v'}, 
        {"random\000           Use a random permutation", 0, (int *)0, 'r'}, 
        {"heuristic\000        Use a heuristic permutation (default)", 0, (int *)0, 'p'}, 
        {"identity\000         Do not change the order of lines",
      0, (int *)0, 'n'}, 
        {"concatenate\000      Concatenate input before shuffling", 0, (int *)0, 'c'}, 
        {"merge\000            Merge input after shuffling in given order",
      0, (int *)0, 'm'}, 
        {"merge-random\000     Merge input after shuffling (default)", 0, (int *)0, 'M'}, 
        {"seed\000 <integer>   Seed the permutation",
      1, (int *)0, 's'}, 
        {"zero-terminated\000  Use \\0 line endings", 0, (int *)0, 'z'}, 
        {"null\000             Use \\0 line endings", 0, (int *)0, '0'}, 
        {"linefeed\000         Use \\n line endings (default)", 0, (int *)0, 'l'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 69 "/home/wslee/benchmarks/textformat/unsort-1.1.2/unsort.c"
static void usage___0(FILE *fh , char const   *progname ) 
{ 
  int i ;
  size_t tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 71
  fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"Usage: %s [-",
          progname);
  }
#line 72
  i = 0;
  }
  {
  {
#line 72
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 72
    if (! long_options___0[i].name) {
#line 72
      goto while_break;
    }
#line 73
    if (long_options___0[i].val) {
#line 73
      if (! long_options___0[i].has_arg) {
        {
        {
#line 74
        fputc((int )long_options___0[i].val, fh);
        }
        }
      }
    }
#line 72
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 75
  fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"] [-s <integer>] [file...]\n");
  }
#line 76
  i = 0;
  }
  {
  {
#line 76
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 76
    if (! long_options___0[i].name) {
#line 76
      goto while_break___0;
    }
    {
    {
#line 77
    tmp___1 = strlen((char const   *)long_options___0[i].name);
    }
    {
#line 77
    fprintf((FILE */* __restrict  */)fh, (char const   */* __restrict  */)"\t-%c, --%s%s\n",
            long_options___0[i].val, long_options___0[i].name, (long_options___0[i].name + tmp___1) + 1);
    }
#line 76
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 41 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static int filebuf_tmp___0(void) 
{ 
  FILE *fh ;
  int fd ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 44
  fh = tmpfile();
  }
  }
#line 45
  if (! fh) {
    {
    {
#line 46
    exit_perror((error_code )3, "Can\'t create temporary file");
    }
    }
  }
  {
  {
#line 47
  tmp___1 = fileno(fh);
  }
  {
#line 47
  fd = dup(tmp___1);
  }
  }
#line 48
  if (fd == -1) {
    {
    {
#line 49
    tmp___2 = fileno(fh);
    }
    {
#line 49
    exit_perror((error_code )3, "Can\'t dup(%d)", tmp___2);
    }
    }
  }
  {
  {
#line 50
  fclose(fh);
  }
  }
#line 51
  return (fd);
}
}
#line 54 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static void write_all___0(int fd , void *buf , size_t len ) 
{ 
  ssize_t r ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 56
    if (! len) {
#line 56
      goto while_break;
    }
    {
    {
#line 57
    r = write(fd, (void const   *)buf, len);
    }
    }
#line 58
    if (! r) {
      {
      {
#line 59
      exit_error((error_code )3, "Can\'t write to fd %d", fd);
      }
      }
    }
#line 60
    if (r == -1) {
      {
      {
#line 61
      exit_perror((error_code )3, "Can\'t write to fd %d", fd);
      }
      }
    }
#line 62
    buf = (void *)((uint8_t *)buf + (size_t )r);
#line 63
    len -= (size_t )r;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static _Bool filebuf_mmap___0(int fd , filebuf_t *fb , size_t len ) 
{ 
  void *buf ;

  {
  {
  {
#line 69
  buf = mmap((void *)0, len, 1, 1, fd, (__off64_t )0);
  }
  }
#line 70
  if ((unsigned long )buf == (unsigned long )((void *)-1)) {
#line 71
    return ((_Bool)1);
  }
#line 72
  fb->buf = buf;
#line 73
  fb->len = len;
#line 74
  return ((_Bool)0);
}
}
#line 80 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static void *streambuf___0  =    (void *)0;
#line 81 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static size_t streamleft___0  =    (size_t )1048576;
#line 88
static void filebuf_stream___0(int fd , filebuf_t *fb ) ;
#line 88 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static int pg___0  =    -1;
#line 83 "/home/wslee/benchmarks/textformat/unsort-1.1.2/filebuf.c"
static void filebuf_stream___0(int fd , filebuf_t *fb ) 
{ 
  void *buf ;
  size_t len ;
  size_t left ;
  size_t edge ;
  size_t offset ;
  ssize_t r ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 85
  len = (size_t )0;
#line 85
  offset = (size_t )0;
#line 90
  if (! streambuf___0) {
    {
    {
#line 91
    streambuf___0 = xalloc(streamleft___0);
    }
    }
  }
#line 93
  buf = streambuf___0;
#line 94
  left = streamleft___0;
  {
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 96
    if (! (left >= 4096U)) {
#line 96
      goto while_break;
    }
    {
    {
#line 97
    r = read(fd, (void *)((uint8_t *)buf + len), left);
    }
    }
#line 98
    if (r == -1) {
      {
      {
#line 99
      exit_perror((error_code )3, "Can\'t read from fd %d", fd);
      }
      }
    }
#line 100
    if (! r) {
#line 101
      if (len) {
#line 102
        streambuf___0 = (void *)((uint8_t *)streambuf___0 + len);
#line 103
        streamleft___0 -= len;
      } else {
#line 105
        buf = (void *)0;
      }
#line 107
      fb->buf = buf;
#line 108
      fb->len = len;
#line 109
      return;
    }
#line 111
    len += (size_t )r;
#line 112
    left -= (size_t )r;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 115
  tmp___1 = filebuf_tmp___0();
  }
  {
#line 116
  write_all___0(tmp___1, buf, len);
  }
#line 117
  buf = (void *)0;
  }
#line 119
  if (pg___0 == -1) {
    {
    {
#line 120
    tmp___2 = sysconf(30);
    }
#line 120
    pg___0 = (int )tmp___2;
    }
  }
#line 122
  left = (size_t )0;
  {
  {
#line 123
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 124
    if (left < 4096U) {
#line 125
      if (buf) {
        {
        {
#line 125
        tmp___3 = munmap(buf, (size_t )1048576);
        }
        }
#line 125
        if (tmp___3 == -1) {
          {
          {
#line 126
          exit_perror((error_code )3, "Can\'t munmap %d bytes", 1048576);
          }
          }
        }
      }
      {
#line 127
      edge = len % (unsigned int )pg___0;
#line 128
      offset = len - edge;
#line 129
      left = 1048576U - edge;
      {
#line 130
      tmp___4 = ftruncate(tmp___1, (off_t )(offset + 1048576U));
      }
      }
#line 130
      if (tmp___4 == -1) {
        {
        {
#line 131
        exit_perror((error_code )3, "Can\'t extend fd %d to %ld bytes", tmp___1, (long )(offset + 1048576U));
        }
        }
      }
      {
      {
#line 132
      buf = mmap((void *)0, (size_t )1048576, 2, 1, tmp___1, (off_t )offset);
      }
      }
#line 133
      if ((unsigned long )buf == (unsigned long )((void *)-1)) {
        {
        {
#line 134
        exit_perror((error_code )3, "Can\'t mmap fd %d for writing", fd);
        }
        }
      }
    }
    {
    {
#line 136
    r = read(fd, (void *)(((char *)buf + len) - offset), left);
    }
    }
#line 137
    if (! r) {
#line 138
      goto while_break___0;
    }
#line 139
    if (r == -1) {
      {
      {
#line 140
      exit_perror((error_code )3, "Can\'t read from fd %d", tmp___1);
      }
      }
    }
#line 141
    len += (size_t )r;
#line 142
    left -= (size_t )r;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  if (buf) {
    {
    {
#line 145
    tmp___5 = munmap(buf, (size_t )1048576);
    }
    }
#line 145
    if (tmp___5 == -1) {
      {
      {
#line 146
      exit_perror((error_code )3, "Can\'t munmap %d bytes", 1048576);
      }
      }
    }
  }
  {
  {
#line 147
  tmp___6 = ftruncate(tmp___1, (off_t )len);
  }
  }
#line 147
  if (tmp___6 == -1) {
    {
    {
#line 148
    exit_perror((error_code )3, "Can\'t truncate fd %d to %ld bytes", tmp___1, (long )len);
    }
    }
  }
  {
  {
#line 150
  tmp___7 = filebuf_mmap___0(tmp___1, fb, len);
  }
  }
#line 150
  if (tmp___7) {
    {
    {
#line 151
    exit_perror((error_code )3, "Can\'t mmap fd %d", tmp___1);
    }
    }
  }
  {
  {
#line 153
  close(tmp___1);
  }
  }
#line 154
  return;
}
}
