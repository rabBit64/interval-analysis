/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 34 "/home/wslee/benchmarks/textformat/rotix-0.83/help.c"
void display_help(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 36
  tmp = gettext("Usage:\n");
  }
  {
#line 36
  printf((char const   */* __restrict  */)tmp);
  }
  {
#line 37
  tmp___0 = gettext("       rotix [ -f <file> ] [ -o <file> ] [ -r <value> ]\n");
  }
  {
#line 37
  printf((char const   */* __restrict  */)tmp___0);
  }
  {
#line 38
  tmp___1 = gettext("       rotix -t <text> [ -o <file> ] [ -r <value> ]\n\n");
  }
  {
#line 38
  printf((char const   */* __restrict  */)tmp___1);
  }
  {
#line 40
  tmp___2 = gettext("-f <file>  specify input-file\n");
  }
  {
#line 40
  printf((char const   */* __restrict  */)tmp___2);
  }
  {
#line 41
  tmp___3 = gettext("-o <file>  specify output-file\n");
  }
  {
#line 41
  printf((char const   */* __restrict  */)tmp___3);
  }
  {
#line 42
  tmp___4 = gettext("-r <value> specify the value to rotate with\n");
  }
  {
#line 42
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 43
  tmp___5 = gettext("-a         use all sane values to rotate with\n");
  }
  {
#line 43
  printf((char const   */* __restrict  */)tmp___5);
  }
  {
#line 44
  tmp___6 = gettext("-R         rotate right\n");
  }
  {
#line 44
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 45
  tmp___7 = gettext("-L         rotate left\n");
  }
  {
#line 45
  printf((char const   */* __restrict  */)tmp___7);
  }
  {
#line 46
  tmp___8 = gettext("-t <text>  specify the text to rotate\n\n");
  }
  {
#line 46
  printf((char const   */* __restrict  */)tmp___8);
  }
  {
#line 48
  tmp___9 = gettext("For complete documentation:\n");
  }
  {
#line 48
  printf((char const   */* __restrict  */)tmp___9);
  }
  {
#line 49
  printf((char const   */* __restrict  */)"man rotix\n\n");
  }
  {
#line 51
  tmp___10 = gettext("Report bugs to: sjoerd@huiswerkservice.nl\n");
  }
  {
#line 51
  printf((char const   */* __restrict  */)tmp___10);
  }
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/rotix-0.83/help.c"
void display_version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 56
  tmp = gettext("Rotix version 0.82\n\n");
  }
  {
#line 56
  printf((char const   */* __restrict  */)tmp);
  }
  {
#line 58
  printf((char const   */* __restrict  */)"Copyright (C) 2001 Sjoerd Hemminga <sjoerd@huiswerkservice.nl>\n\n");
  }
  {
#line 60
  tmp___0 = gettext("Rotix is licensed under the GNU General Public License. See the file COPYING\nfor details.\n");
  }
  {
#line 60
  printf((char const   */* __restrict  */)tmp___0);
  }
  }
#line 62
  return;
}
}
#line 37 "/home/wslee/benchmarks/textformat/rotix-0.83/rot.c"
void rotate(int rotor , char *rotar , char flags ) 
{ 
  int i ;

  {
#line 41
  if (! ((int )flags & 1)) {
#line 43
    rotor = - rotor;
  }
#line 47
  rotor %= 26;
#line 50
  if (rotor < 0) {
#line 51
    rotor += 26;
  }
#line 54
  i = 0;
  {
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 54
    if (! *(rotar + i)) {
#line 54
      goto while_break;
    }
#line 55
    if ((int )*(rotar + i) >= 65) {
#line 55
      if ((int )*(rotar + i) <= 90) {
#line 56
        *(rotar + i) = (char )((int )*(rotar + i) - 65);
#line 57
        *(rotar + i) = (char )((int )*(rotar + i) + rotor);
#line 58
        *(rotar + i) = (char )((int )*(rotar + i) % 26);
#line 59
        *(rotar + i) = (char )((int )*(rotar + i) + 65);
      }
    }
#line 62
    if ((int )*(rotar + i) >= 97) {
#line 62
      if ((int )*(rotar + i) <= 122) {
#line 63
        *(rotar + i) = (char )((int )*(rotar + i) - 97);
#line 64
        *(rotar + i) = (char )((int )*(rotar + i) + rotor);
#line 65
        *(rotar + i) = (char )((int )*(rotar + i) % 26);
#line 66
        *(rotar + i) = (char )((int )*(rotar + i) + 97);
      }
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 172
extern FILE *tmpfile(void) ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 732
extern void rewind(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 175
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 60 "/home/wslee/benchmarks/textformat/rotix-0.83/rotix.c"
int main(int argc , char **argv ) ;
#line 60 "/home/wslee/benchmarks/textformat/rotix-0.83/rotix.c"
static struct option rotix_options[10]  = 
#line 60
  {      {"file", 1, (int *)((void *)0), 'f'}, 
        {"rot", 1, (int *)((void *)0), 'r'}, 
        {"auto", 0, (int *)((void *)0), 'a'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"text", 1, (int *)((void *)0), 't'}, 
        {"left", 0, (int *)((void *)0), 'L'}, 
        {"right", 0, (int *)((void *)0), 'R'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 53 "/home/wslee/benchmarks/textformat/rotix-0.83/rotix.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int rotor ;
  int option ;
  char *arg ;
  char option_flags ;
  char rotate_flags ;
  char rotme[2] ;
  FILE *ifp ;
  FILE *ofp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 55
  i = 1;
#line 55
  rotor = 13;
#line 55
  option = 0;
#line 56
  arg = (char *)((void *)0);
#line 56
  option_flags = (char)0;
#line 56
  rotate_flags = (char)0;
#line 78
  ifp = (FILE *)((void *)0);
#line 79
  ofp = (FILE *)((void *)0);
#line 89
  rotme[1] = (char )'\000';
#line 90
  rotate_flags = (char )((int )rotate_flags | 1);
  {
  {
#line 93
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 94
    option = getopt_long(argc, (char * const  *)argv, "f:r:ao:t:LRhv", (struct option  const  *)(rotix_options),
                         (int *)((void *)0));
    }
    }
#line 95
    if (option == -1) {
#line 95
      goto while_break;
    }
    {
#line 98
    if (option == 63) {
#line 98
      goto case_63;
    }
#line 101
    if (option == 58) {
#line 101
      goto case_58;
    }
#line 106
    if (option == 118) {
#line 106
      goto case_118;
    }
#line 109
    if (option == 104) {
#line 109
      goto case_104;
    }
#line 116
    if (option == 82) {
#line 116
      goto case_82;
    }
#line 120
    if (option == 76) {
#line 120
      goto case_76;
    }
#line 127
    if (option == 102) {
#line 127
      goto case_102;
    }
#line 151
    if (option == 114) {
#line 151
      goto case_114;
    }
#line 161
    if (option == 97) {
#line 161
      goto case_97;
    }
#line 166
    if (option == 111) {
#line 166
      goto case_111;
    }
#line 182
    if (option == 116) {
#line 182
      goto case_116;
    }
#line 198
    goto switch_default;
    case_63: /* CIL Label */ 
    {
    {
#line 99
    display_help();
    }
    {
#line 100
    exit(1);
    }
    }
    case_58: /* CIL Label */ 
    {
    {
#line 104
    display_help();
    }
    {
#line 105
    exit(1);
    }
    }
    case_118: /* CIL Label */ 
    {
    {
#line 107
    display_version();
    }
    {
#line 108
    exit(0);
    }
    }
    case_104: /* CIL Label */ 
    {
    {
#line 110
    display_help();
    }
    {
#line 111
    exit(0);
    }
    }
    case_82: /* CIL Label */ 
#line 117
    rotate_flags = (char )((int )rotate_flags | 1);
#line 118
    goto switch_break;
    case_76: /* CIL Label */ 
#line 121
    if ((int )rotate_flags & 1) {
#line 122
      rotate_flags = (char )((int )rotate_flags - 1);
    }
#line 124
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 128
    tmp = strcmp((char const   *)optarg, "-");
    }
    }
#line 128
    if (tmp == 0) {
#line 129
      ifp = stdin;
#line 130
      option_flags = (char )((int )option_flags | 16);
#line 132
      if ((int )option_flags & 4) {
        {
        {
#line 133
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: you cannot specify both an inputfile and a text\n");
        }
        {
#line 134
        exit(1);
        }
        }
      }
    } else {
      {
      {
#line 137
      ifp = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
      }
#line 138
      option_flags = (char )((int )option_flags | 2);
      }
#line 140
      if ((unsigned long )ifp == (unsigned long )((void *)0)) {
        {
        {
#line 141
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: error opening file %s for reading\n",
                optarg);
        }
        {
#line 142
        exit(1);
        }
        }
      } else
#line 143
      if ((int )option_flags & 4) {
        {
        {
#line 144
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: you cannot specify both an inputfile and a text\n");
        }
        {
#line 145
        exit(1);
        }
        }
      }
    }
#line 148
    goto switch_break;
    case_114: /* CIL Label */ 
    {
    {
#line 152
    tmp___1 = strcmp((char const   *)optarg, "auto");
    }
    }
#line 152
    if (tmp___1 == 0) {
#line 153
      option_flags = (char )((int )option_flags | 1);
    } else {
      {
      {
#line 154
      tmp___0 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%9i",
                       & rotor);
      }
      }
#line 154
      if (! tmp___0) {
        {
        {
#line 155
        display_help();
        }
        {
#line 156
        exit(1);
        }
        }
      }
    }
#line 158
    goto switch_break;
    case_97: /* CIL Label */ 
#line 162
    option_flags = (char )((int )option_flags | 1);
#line 163
    goto switch_break;
    case_111: /* CIL Label */ 
    {
    {
#line 167
    tmp___2 = strcmp((char const   *)optarg, "-");
    }
    }
#line 167
    if (tmp___2 == 0) {
#line 168
      ofp = stdout;
    } else {
      {
      {
#line 170
      ofp = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"a");
      }
#line 172
      option_flags = (char )((int )option_flags | 8);
      }
#line 174
      if ((unsigned long )ofp == (unsigned long )((void *)0)) {
        {
        {
#line 175
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: error opening file %s for writing\n",
                optarg);
        }
        {
#line 176
        exit(1);
        }
        }
      }
    }
#line 179
    goto switch_break;
    case_116: /* CIL Label */ 
#line 183
    if ((int )option_flags & 2) {
      {
      {
#line 184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: you cannot specify both an inputfile and a text\n");
      }
      {
#line 185
      exit(1);
      }
      }
    } else
#line 183
    if ((int )option_flags & 16) {
      {
      {
#line 184
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: you cannot specify both an inputfile and a text\n");
      }
      {
#line 185
      exit(1);
      }
      }
    }
    {
    {
#line 188
    tmp___3 = strlen((char const   *)optarg);
    }
    {
#line 188
    tmp___4 = malloc(tmp___3 + 1U);
    }
#line 188
    arg = (char *)tmp___4;
    }
#line 189
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      {
#line 190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: not enough memory\n");
      }
      {
#line 191
      exit(1);
      }
      }
    }
    {
    {
#line 193
    strcpy((char */* __restrict  */)arg, (char const   */* __restrict  */)optarg);
    }
#line 194
    option_flags = (char )((int )option_flags | 4);
    }
#line 195
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: fixme\n");
    }
    {
#line 200
    exit(2);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (! ((int )option_flags & 2)) {
#line 204
    if (! ((int )option_flags & 4)) {
#line 205
      option_flags = (char )((int )option_flags | 16);
#line 206
      ifp = stdin;
    }
  }
#line 209
  if ((unsigned long )ofp == (unsigned long )((void *)0)) {
#line 210
    ofp = stdout;
  }
#line 216
  if ((int )option_flags & 4) {
#line 217
    if ((int )option_flags & 1) {
#line 218
      i = 1;
      {
      {
#line 218
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 218
        if (! (i < 26)) {
#line 218
          goto while_break___0;
        }
        {
        {
#line 219
        rotate(1, arg, rotate_flags);
        }
        {
#line 220
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"ROT-%02i: %s\n",
                i, arg);
        }
#line 218
        i ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 223
      free((void *)arg);
      }
      }
    } else {
      {
      {
#line 225
      rotate(rotor, arg, rotate_flags);
      }
      {
#line 226
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s\n",
              arg);
      }
      }
    }
  } else
#line 228
  if ((int )option_flags & 1) {
#line 231
    if ((unsigned long )ifp == (unsigned long )stdin) {
      {
      {
#line 233
      ifp = tmpfile();
      }
      }
#line 235
      if ((unsigned long )ifp == (unsigned long )((void *)0)) {
        {
        {
#line 236
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: error creating temporary file\n");
        }
        {
#line 237
        exit(1);
        }
        }
      }
      {
      {
#line 240
      tmp___5 = malloc((size_t )265);
      }
#line 240
      arg = (char *)tmp___5;
      }
#line 241
      if ((unsigned long )arg == (unsigned long )((void *)0)) {
        {
        {
#line 242
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: not enough memory\n");
        }
        {
#line 243
        exit(1);
        }
        }
      }
      {
      {
#line 246
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 246
        tmp___8 = feof(stdin);
        }
        }
#line 246
        if (tmp___8) {
#line 246
          goto while_break___1;
        }
        {
        {
#line 247
        strcpy((char */* __restrict  */)arg, (char const   */* __restrict  */)"");
        }
#line 248
        rotme[0] = (char )'\000';
        {
#line 250
        fscanf((FILE */* __restrict  */)stdin, (char const   */* __restrict  */)"%255[^\n]s",
               arg);
        }
        {
#line 251
        fprintf((FILE */* __restrict  */)ifp, (char const   */* __restrict  */)"%s",
                arg);
        }
        {
#line 253
        tmp___6 = feof(stdin);
        }
        }
#line 253
        if (tmp___6) {
#line 253
          goto while_break___1;
        }
        {
        {
#line 255
        tmp___7 = fgetc(stdin);
        }
#line 255
        rotme[0] = (char )tmp___7;
        {
#line 256
        fprintf((FILE */* __restrict  */)ifp, (char const   */* __restrict  */)"%s",
                rotme);
        }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 258
      rewind(ifp);
      }
      }
    }
    {
    {
#line 261
    tmp___9 = malloc((size_t )256);
    }
#line 261
    arg = (char *)tmp___9;
    }
#line 262
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      {
#line 263
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: not enough memory\n");
      }
      {
#line 264
      exit(1);
      }
      }
    }
#line 267
    i = 1;
    {
    {
#line 267
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 267
      if (! (i < 26)) {
#line 267
        goto while_break___2;
      }
      {
      {
#line 268
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\nROT-%02i:\n=======\n\n",
              i);
      }
      }
      {
      {
#line 270
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 270
        tmp___12 = feof(ifp);
        }
        }
#line 270
        if (tmp___12) {
#line 270
          goto while_break___3;
        }
        {
        {
#line 271
        strcpy((char */* __restrict  */)arg, (char const   */* __restrict  */)"");
        }
#line 272
        rotme[0] = (char )'\000';
        {
#line 274
        fscanf((FILE */* __restrict  */)ifp, (char const   */* __restrict  */)"%255[^\n]s",
               arg);
        }
        {
#line 275
        rotate(i, arg, rotate_flags);
        }
        {
#line 276
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s",
                arg);
        }
        {
#line 278
        tmp___10 = feof(ifp);
        }
        }
#line 278
        if (tmp___10) {
#line 278
          goto while_break___3;
        }
        {
        {
#line 280
        tmp___11 = fgetc(ifp);
        }
#line 280
        rotme[0] = (char )tmp___11;
        {
#line 281
        rotate(i, rotme, rotate_flags);
        }
        {
#line 282
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s",
                rotme);
        }
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      {
#line 284
      rewind(ifp);
      }
#line 267
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 286
    free((void *)arg);
    }
    }
  } else {
    {
    {
#line 288
    tmp___13 = malloc((size_t )256);
    }
#line 288
    arg = (char *)tmp___13;
    }
#line 289
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rotix: not enough memory\n");
      }
      {
#line 291
      exit(1);
      }
      }
    }
    {
    {
#line 294
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
      {
      {
#line 294
      tmp___16 = feof(ifp);
      }
      }
#line 294
      if (tmp___16) {
#line 294
        goto while_break___4;
      }
      {
      {
#line 295
      strcpy((char */* __restrict  */)arg, (char const   */* __restrict  */)"");
      }
#line 296
      rotme[0] = (char )'\000';
      {
#line 298
      fscanf((FILE */* __restrict  */)ifp, (char const   */* __restrict  */)"%255[^\n]s",
             arg);
      }
      {
#line 299
      rotate(rotor, arg, rotate_flags);
      }
      {
#line 300
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s",
              arg);
      }
      {
#line 302
      tmp___14 = feof(ifp);
      }
      }
#line 302
      if (tmp___14) {
#line 302
        goto while_break___4;
      }
      {
      {
#line 304
      tmp___15 = fgetc(ifp);
      }
#line 304
      rotme[0] = (char )tmp___15;
      {
#line 305
      rotate(rotor, rotme, rotate_flags);
      }
      {
#line 306
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%s",
              rotme);
      }
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    {
#line 309
    free((void *)arg);
    }
    }
  }
  {
  {
#line 312
  fflush((FILE *)((void *)0));
  }
  }
#line 314
  if ((int )option_flags & 2) {
    {
    {
#line 315
    fclose(ifp);
    }
    }
  }
#line 318
  if ((int )option_flags & 8) {
    {
    {
#line 319
    fclose(ofp);
    }
    }
  }
#line 322
  return (0);
}
}
#line 60 "/home/wslee/benchmarks/textformat/rotix-0.83/rotix.c"
static struct option rotix_options___0[10]  = 
#line 60
  {      {"file", 1, (int *)((void *)0), 'f'}, 
        {"rot", 1, (int *)((void *)0), 'r'}, 
        {"auto", 0, (int *)((void *)0), 'a'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"text", 1, (int *)((void *)0), 't'}, 
        {"left", 0, (int *)((void *)0), 'L'}, 
        {"right", 0, (int *)((void *)0), 'R'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
