/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 81 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 94 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 166 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 166 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 247 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_22 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 247 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_22 Visual;
#line 275
struct _XDisplay;
#line 370 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 370 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 370 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask __fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 465 "global.h"
struct ld {
   int infile ;
   unsigned char rdbfr[2051] ;
   unsigned char *rdptr ;
   unsigned char inbfr[16] ;
   int incnt ;
   int bitcnt ;
   short block[12][64] ;
};
#line 493 "global.h"
struct bcm {
   int present ;
   int BT ;
   int URF ;
   int TR ;
   int ELNUMI ;
   int ELNUM ;
   int BCPM ;
   int BSPI ;
   int BEPB1 ;
   int GN_MBA ;
   int BEPB2 ;
   int RTR ;
   int BSTUF ;
};
#line 56 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 63 "getvlc.h"
struct __anonstruct_VLCtab_10 {
   int val ;
   int len ;
};
#line 63 "getvlc.h"
typedef struct __anonstruct_VLCtab_10 VLCtab;
#line 82 "getblk.c"
struct __anonstruct_RunCoef_20 {
   int val ;
   int run ;
   int sign ;
};
#line 82 "getblk.c"
typedef struct __anonstruct_RunCoef_20 RunCoef;
#line 87 "getblk.c"
struct __anonstruct_CodeCoeff_21 {
   int code ;
   int level ;
   int last ;
   int run ;
   int sign ;
   int extended_level ;
};
#line 87 "getblk.c"
typedef struct __anonstruct_CodeCoeff_21 CodeCoeff;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 157 "/usr/include/bits/types.h"
typedef int __key_t;
#line 123 "/usr/include/sys/types.h"
typedef __key_t key_t;
#line 71 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 79 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 82 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 101 "/usr/include/X11/X.h"
typedef XID Window;
#line 102 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 107 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 108 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 109 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 234 "/usr/include/X11/Xlib.h"
struct _XGC;
#line 234 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 263 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_22 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 263 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_22 Depth;
#line 277 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_23 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 277 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_23 Screen;
#line 300 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_24 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 300 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_24 ScreenFormat;
#line 310 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_25 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 310 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_25 XSetWindowAttributes;
#line 328 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_26 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 328 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_26 XWindowAttributes;
#line 429 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_29 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 429 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_29 XColor;
#line 506 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 509
struct _XPrivate;
#line 510
struct _XrmHashBucketRec;
#line 512 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_38 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 512 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_38 *_XPrivDisplay;
#line 582 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 582 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_39 XKeyEvent;
#line 600 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 600 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_40 XButtonEvent;
#line 618 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 618 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_41 XMotionEvent;
#line 635 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 635 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_42 XCrossingEvent;
#line 659 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 659 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_43 XFocusChangeEvent;
#line 677 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 677 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_44 XKeymapEvent;
#line 686 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 686 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_45 XExposeEvent;
#line 697 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 697 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_46 XGraphicsExposeEvent;
#line 710 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 710 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_47 XNoExposeEvent;
#line 720 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 720 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_48 XVisibilityEvent;
#line 729 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 729 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_49 XCreateWindowEvent;
#line 742 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 742 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_50 XDestroyWindowEvent;
#line 751 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 751 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_51 XUnmapEvent;
#line 761 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 761 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_52 XMapEvent;
#line 771 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 771 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_53 XMapRequestEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_54 XReparentEvent;
#line 792 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 792 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_55 XConfigureEvent;
#line 806 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 806 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_56 XGravityEvent;
#line 816 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 816 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_57 XResizeRequestEvent;
#line 825 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 825 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_58 XConfigureRequestEvent;
#line 840 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 840 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_59 XCirculateEvent;
#line 850 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 850 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_60 XCirculateRequestEvent;
#line 860 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 860 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_61 XPropertyEvent;
#line 871 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 871 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_62 XSelectionClearEvent;
#line 881 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 881 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_63 XSelectionRequestEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_64 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_64 XSelectionEvent;
#line 906 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 906 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_65 XColormapEvent;
#line 921 "/usr/include/X11/Xlib.h"
union __anonunion_data_67 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 921 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_66 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_67 data ;
};
#line 921 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_66 XClientMessageEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_68 XMappingEvent;
#line 948 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_69 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 948 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_69 XErrorEvent;
#line 958 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_70 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 958 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_70 XAnyEvent;
#line 970 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   long pad[24] ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 2029 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 74 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_96 {
   int x ;
   int y ;
};
#line 74 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_95 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_96 min_aspect ;
   struct __anonstruct_min_aspect_96 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 74 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_95 XSizeHints;
#line 43 "/usr/include/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
#line 44 "/usr/include/bits/shm.h"
typedef unsigned long shmatt_t;
#line 47 "/usr/include/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   unsigned long __unused1 ;
   __time_t shm_dtime ;
   unsigned long __unused2 ;
   __time_t shm_ctime ;
   unsigned long __unused3 ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 50 "/usr/include/X11/extensions/XShm.h"
typedef unsigned long ShmSeg;
#line 65 "/usr/include/X11/extensions/XShm.h"
struct __anonstruct_XShmSegmentInfo_105 {
   ShmSeg shmseg ;
   int shmid ;
   char *shmaddr ;
   int readOnly ;
};
#line 65 "/usr/include/X11/extensions/XShm.h"
typedef struct __anonstruct_XShmSegmentInfo_105 XShmSegmentInfo;
#line 177 "global.h"
void init_dither_tab(void) ;
#line 180
void ConvertYUVtoRGB(unsigned char *src0 , unsigned char *src1 , unsigned char *src2 ,
                     unsigned char *dst_ori , int width , int height ) ;
#line 288
unsigned char *clp ;
#line 61 "yuvrgb24.c"
long crv_tab[256]  ;
#line 62 "yuvrgb24.c"
long cbu_tab[256]  ;
#line 63 "yuvrgb24.c"
long cgu_tab[256]  ;
#line 65 "yuvrgb24.c"
long cgv_tab[256]  ;
#line 66 "yuvrgb24.c"
long tab_76309[256]  ;
#line 68 "yuvrgb24.c"
void init_dither_tab(void) 
{ 
  long crv ;
  long cbu ;
  long cgu ;
  long cgv ;
  int i ;

  {
#line 73
  crv = 104597L;
#line 74
  cbu = 132201L;
#line 75
  cgu = 25675L;
#line 76
  cgv = 53279L;
#line 78
  i = 0;
  {
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < 256)) {
#line 78
      goto while_break;
    }
#line 80
    crv_tab[i] = (long )(i - 128) * crv;
#line 81
    cbu_tab[i] = (long )(i - 128) * cbu;
#line 82
    cgu_tab[i] = (long )(i - 128) * cgu;
#line 83
    cgv_tab[i] = (long )(i - 128) * cgv;
#line 84
    tab_76309[i] = (long )(76309 * (i - 16));
#line 78
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 107 "yuvrgb24.c"
void ConvertYUVtoRGB(unsigned char *src0 , unsigned char *src1 , unsigned char *src2 ,
                     unsigned char *dst_ori , int width , int height ) 
{ 
  int y11 ;
  int y21 ;
  int y12 ;
  int y22 ;
  int y13 ;
  int y23 ;
  int y14 ;
  int y24 ;
  int u ;
  int v ;
  int i ;
  int j ;
  int c11 ;
  int c21 ;
  int c31 ;
  int c41 ;
  int c12 ;
  int c22 ;
  int c32 ;
  int c42 ;
  unsigned int DW ;
  unsigned int *id1 ;
  unsigned int *id2 ;
  unsigned char *py1 ;
  unsigned char *py2 ;
  unsigned char *pu ;
  unsigned char *pv ;
  unsigned char *d1 ;
  unsigned char *d2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned int *tmp___11 ;
  unsigned int *tmp___12 ;
  unsigned int *tmp___13 ;
  unsigned int *tmp___14 ;
  unsigned int *tmp___15 ;
  unsigned int *tmp___16 ;

  {
#line 132
  d1 = dst_ori;
#line 133
  d1 += (width * height) * 3 - width * 3;
#line 134
  d2 = d1 - width * 3;
#line 136
  py1 = src0;
#line 137
  pu = src1;
#line 138
  pv = src2;
#line 139
  py2 = py1 + width;
#line 141
  id1 = (unsigned int *)d1;
#line 142
  id2 = (unsigned int *)d2;
#line 144
  j = 0;
  {
  {
#line 144
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 144
    if (! (j < height)) {
#line 144
      goto while_break;
    }
#line 147
    i = 0;
    {
    {
#line 147
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 147
      if (! (i < width)) {
#line 147
        goto while_break___0;
      }
#line 149
      tmp = pu;
#line 149
      pu ++;
#line 149
      u = (int )*tmp;
#line 150
      tmp___0 = pv;
#line 150
      pv ++;
#line 150
      v = (int )*tmp___0;
#line 151
      c11 = (int )crv_tab[v];
#line 152
      c21 = (int )cgu_tab[u];
#line 153
      c31 = (int )cgv_tab[v];
#line 154
      c41 = (int )cbu_tab[u];
#line 155
      tmp___1 = pu;
#line 155
      pu ++;
#line 155
      u = (int )*tmp___1;
#line 156
      tmp___2 = pv;
#line 156
      pv ++;
#line 156
      v = (int )*tmp___2;
#line 157
      c12 = (int )crv_tab[v];
#line 158
      c22 = (int )cgu_tab[u];
#line 159
      c32 = (int )cgv_tab[v];
#line 160
      c42 = (int )cbu_tab[u];
#line 162
      tmp___3 = py1;
#line 162
      py1 ++;
#line 162
      y11 = (int )tab_76309[*tmp___3];
#line 163
      tmp___4 = py1;
#line 163
      py1 ++;
#line 163
      y12 = (int )tab_76309[*tmp___4];
#line 164
      tmp___5 = py1;
#line 164
      py1 ++;
#line 164
      y13 = (int )tab_76309[*tmp___5];
#line 165
      tmp___6 = py1;
#line 165
      py1 ++;
#line 165
      y14 = (int )tab_76309[*tmp___6];
#line 167
      tmp___7 = py2;
#line 167
      py2 ++;
#line 167
      y21 = (int )tab_76309[*tmp___7];
#line 168
      tmp___8 = py2;
#line 168
      py2 ++;
#line 168
      y22 = (int )tab_76309[*tmp___8];
#line 169
      tmp___9 = py2;
#line 169
      py2 ++;
#line 169
      y23 = (int )tab_76309[*tmp___9];
#line 170
      tmp___10 = py2;
#line 170
      py2 ++;
#line 170
      y24 = (int )tab_76309[*tmp___10];
#line 173
      DW = (unsigned int )((((int )*(clp + ((y11 + c41) >> 16)) | ((int )*(clp + (((y11 - c21) - c31) >> 16)) << 8)) | ((int )*(clp + ((y11 + c11) >> 16)) << 16)) | ((int )*(clp + ((y12 + c41) >> 16)) << 24));
#line 177
      tmp___11 = id1;
#line 177
      id1 ++;
#line 177
      *tmp___11 = DW;
#line 180
      DW = (unsigned int )((((int )*(clp + (((y12 - c21) - c31) >> 16)) | ((int )*(clp + ((y12 + c11) >> 16)) << 8)) | ((int )*(clp + ((y13 + c42) >> 16)) << 16)) | ((int )*(clp + (((y13 - c22) - c32) >> 16)) << 24));
#line 184
      tmp___12 = id1;
#line 184
      id1 ++;
#line 184
      *tmp___12 = DW;
#line 187
      DW = (unsigned int )((((int )*(clp + ((y13 + c12) >> 16)) | ((int )*(clp + ((y14 + c42) >> 16)) << 8)) | ((int )*(clp + (((y14 - c22) - c32) >> 16)) << 16)) | ((int )*(clp + ((y14 + c12) >> 16)) << 24));
#line 191
      tmp___13 = id1;
#line 191
      id1 ++;
#line 191
      *tmp___13 = DW;
#line 194
      DW = (unsigned int )((((int )*(clp + ((y21 + c41) >> 16)) | ((int )*(clp + (((y21 - c21) - c31) >> 16)) << 8)) | ((int )*(clp + ((y21 + c11) >> 16)) << 16)) | ((int )*(clp + ((y22 + c41) >> 16)) << 24));
#line 198
      tmp___14 = id2;
#line 198
      id2 ++;
#line 198
      *tmp___14 = DW;
#line 201
      DW = (unsigned int )((((int )*(clp + (((y22 - c21) - c31) >> 16)) | ((int )*(clp + ((y22 + c11) >> 16)) << 8)) | ((int )*(clp + ((y23 + c42) >> 16)) << 16)) | ((int )*(clp + (((y23 - c22) - c32) >> 16)) << 24));
#line 205
      tmp___15 = id2;
#line 205
      id2 ++;
#line 205
      *tmp___15 = DW;
#line 208
      DW = (unsigned int )((((int )*(clp + ((y23 + c12) >> 16)) | ((int )*(clp + ((y24 + c42) >> 16)) << 8)) | ((int )*(clp + (((y24 - c22) - c32) >> 16)) << 16)) | ((int )*(clp + ((y24 + c12) >> 16)) << 24));
#line 212
      tmp___16 = id2;
#line 212
      id2 ++;
#line 212
      *tmp___16 = DW;
#line 147
      i += 4;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    id1 -= 9 * width >> 2;
#line 215
    id2 -= 9 * width >> 2;
#line 216
    py1 += width;
#line 217
    py2 += width;
#line 144
    j += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 174 "global.h"
void Color16DitherImage(unsigned char **src , unsigned char *out ) ;
#line 175
void Color32DitherImage(unsigned char **src , unsigned char *out ) ;
#line 176
void InitColorDither(int thirty2 ) ;
#line 290
int coded_picture_width ;
#line 290
int coded_picture_height ;
#line 305
int expand ;
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 154 "/usr/include/bits/mathcalls.h"
extern double pow(double __x , double __y ) ;
#line 129 "yuv2rgb.c"
int gammaCorrectFlag  =    0;
#line 130 "yuv2rgb.c"
double gammaCorrect  =    1.0;
#line 133 "yuv2rgb.c"
int chromaCorrectFlag  =    0;
#line 134 "yuv2rgb.c"
double chromaCorrect  =    1.0;
#line 138 "yuv2rgb.c"
static int number_of_bits_set(unsigned long a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 142
  if (! a) {
#line 143
    return (0);
  }
#line 144
  if (a & 1UL) {
    {
    {
#line 145
    tmp = number_of_bits_set(a >> 1);
    }
    }
#line 145
    return (1 + tmp);
  }
  {
  {
#line 146
  tmp___0 = number_of_bits_set(a >> 1);
  }
  }
#line 146
  return (tmp___0);
}
}
#line 179 "yuv2rgb.c"
static int free_bits_at_bottom(unsigned long a ) 
{ 
  int tmp ;

  {
#line 184
  if (! a) {
#line 185
    return ((int )(sizeof(unsigned long ) * 8UL));
  }
#line 186
  if ((long )a & 1L) {
#line 187
    return (0);
  }
  {
  {
#line 188
  tmp = free_bits_at_bottom(a >> 1);
  }
  }
#line 188
  return (1 + tmp);
}
}
#line 191 "yuv2rgb.c"
static int *L_tab  ;
#line 191 "yuv2rgb.c"
static int *Cr_r_tab  ;
#line 191 "yuv2rgb.c"
static int *Cr_g_tab  ;
#line 191 "yuv2rgb.c"
static int *Cb_g_tab  ;
#line 191 "yuv2rgb.c"
static int *Cb_b_tab  ;
#line 196 "yuv2rgb.c"
static long *r_2_pix  ;
#line 197 "yuv2rgb.c"
static long *g_2_pix  ;
#line 198 "yuv2rgb.c"
static long *b_2_pix  ;
#line 199 "yuv2rgb.c"
static long *r_2_pix_alloc  ;
#line 200 "yuv2rgb.c"
static long *g_2_pix_alloc  ;
#line 201 "yuv2rgb.c"
static long *b_2_pix_alloc  ;
#line 223
XImage *ximage ;
#line 224
unsigned long wpixel[3] ;
#line 219 "yuv2rgb.c"
void InitColorDither(int thirty2 ) 
{ 
  unsigned long red_mask ;
  unsigned long green_mask ;
  unsigned long blue_mask ;
  int CR ;
  int CB ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 229
  red_mask = wpixel[0];
#line 230
  green_mask = wpixel[1];
#line 231
  blue_mask = wpixel[2];
#line 235
  if (ximage->bits_per_pixel == 24) {
    {
    {
#line 236
    init_dither_tab();
    }
    }
  }
  {
  {
#line 238
  tmp = malloc((size_t )(256UL * sizeof(int )));
  }
#line 238
  L_tab = (int *)tmp;
  {
#line 239
  tmp___0 = malloc((size_t )(256UL * sizeof(int )));
  }
#line 239
  Cr_r_tab = (int *)tmp___0;
  {
#line 240
  tmp___1 = malloc((size_t )(256UL * sizeof(int )));
  }
#line 240
  Cr_g_tab = (int *)tmp___1;
  {
#line 241
  tmp___2 = malloc((size_t )(256UL * sizeof(int )));
  }
#line 241
  Cb_g_tab = (int *)tmp___2;
  {
#line 242
  tmp___3 = malloc((size_t )(256UL * sizeof(int )));
  }
#line 242
  Cb_b_tab = (int *)tmp___3;
  {
#line 244
  tmp___4 = malloc((size_t )(768UL * sizeof(long )));
  }
#line 244
  r_2_pix_alloc = (long *)tmp___4;
  {
#line 245
  tmp___5 = malloc((size_t )(768UL * sizeof(long )));
  }
#line 245
  g_2_pix_alloc = (long *)tmp___5;
  {
#line 246
  tmp___6 = malloc((size_t )(768UL * sizeof(long )));
  }
#line 246
  b_2_pix_alloc = (long *)tmp___6;
  }
#line 248
  if ((unsigned long )L_tab == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )Cr_r_tab == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )Cr_g_tab == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )Cb_g_tab == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )Cb_b_tab == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )r_2_pix_alloc == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )g_2_pix_alloc == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  } else
#line 248
  if ((unsigned long )b_2_pix_alloc == (unsigned long )((void *)0)) {
    {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get enough memory in InitColorDither\n");
    }
    {
#line 258
    exit(1);
    }
    }
  }
#line 260
  i = 0;
  {
  {
#line 260
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 256)) {
#line 260
      goto while_break;
    }
#line 262
    *(L_tab + i) = i;
#line 263
    if (gammaCorrectFlag) {
      {
      {
#line 265
      tmp___7 = pow((double )i / 255.0, 1.0 / gammaCorrect);
      }
#line 265
      *(L_tab + i) = (int )(tmp___7 * 255.0);
      }
    }
#line 267
    CR = i;
#line 267
    CB = CR;
#line 269
    if (chromaCorrectFlag) {
#line 271
      CB -= 128;
#line 272
      if (CB >= 0) {
#line 272
        if (127 < (int )((double )CB * chromaCorrect)) {
#line 272
          tmp___8 = 127;
        } else {
#line 272
          tmp___8 = (int )((double )CB * chromaCorrect);
        }
#line 272
        CB = tmp___8;
      } else {
#line 272
        if (-128 > (int )((double )CB * chromaCorrect)) {
#line 272
          tmp___9 = -128;
        } else {
#line 272
          tmp___9 = (int )((double )CB * chromaCorrect);
        }
#line 272
        CB = tmp___9;
      }
#line 273
      CR -= 128;
#line 274
      if (CR >= 0) {
#line 274
        if (127 < (int )((double )CR * chromaCorrect)) {
#line 274
          tmp___10 = 127;
        } else {
#line 274
          tmp___10 = (int )((double )CR * chromaCorrect);
        }
#line 274
        CR = tmp___10;
      } else {
#line 274
        if (-128 > (int )((double )CR * chromaCorrect)) {
#line 274
          tmp___11 = -128;
        } else {
#line 274
          tmp___11 = (int )((double )CR * chromaCorrect);
        }
#line 274
        CR = tmp___11;
      }
    } else {
#line 277
      CB -= 128;
#line 278
      CR -= 128;
    }
#line 286
    *(Cr_r_tab + i) = (int )((0.419 / 0.299) * (double )CR);
#line 287
    *(Cr_g_tab + i) = (int )(- (0.299 / 0.419) * (double )CR);
#line 288
    *(Cb_g_tab + i) = (int )(- (0.114 / 0.331) * (double )CB);
#line 289
    *(Cb_b_tab + i) = (int )((0.587 / 0.331) * (double )CB);
#line 260
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  i = 0;
  {
  {
#line 302
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 302
    if (! (i < 256)) {
#line 302
      goto while_break___0;
    }
    {
    {
#line 304
    tmp___12 = number_of_bits_set(red_mask);
    }
#line 304
    *(r_2_pix_alloc + (i + 256)) = (long )(i >> (8 - tmp___12));
    {
#line 305
    tmp___13 = free_bits_at_bottom(red_mask);
    }
#line 305
    *(r_2_pix_alloc + (i + 256)) <<= tmp___13;
    {
#line 306
    tmp___14 = number_of_bits_set(green_mask);
    }
#line 306
    *(g_2_pix_alloc + (i + 256)) = (long )(i >> (8 - tmp___14));
    {
#line 307
    tmp___15 = free_bits_at_bottom(green_mask);
    }
#line 307
    *(g_2_pix_alloc + (i + 256)) <<= tmp___15;
    {
#line 308
    tmp___16 = number_of_bits_set(blue_mask);
    }
#line 308
    *(b_2_pix_alloc + (i + 256)) = (long )(i >> (8 - tmp___16));
    {
#line 309
    tmp___17 = free_bits_at_bottom(blue_mask);
    }
#line 309
    *(b_2_pix_alloc + (i + 256)) <<= tmp___17;
    }
#line 316
    if (! thirty2) {
#line 319
      *(r_2_pix_alloc + (i + 256)) |= *(r_2_pix_alloc + (i + 256)) << 16;
#line 320
      *(g_2_pix_alloc + (i + 256)) |= *(g_2_pix_alloc + (i + 256)) << 16;
#line 321
      *(b_2_pix_alloc + (i + 256)) |= *(b_2_pix_alloc + (i + 256)) << 16;
    }
#line 302
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 338
  i = 0;
  {
  {
#line 338
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! (i < 256)) {
#line 338
      goto while_break___1;
    }
#line 340
    *(r_2_pix_alloc + i) = *(r_2_pix_alloc + 256);
#line 341
    *(r_2_pix_alloc + (i + 512)) = *(r_2_pix_alloc + 511);
#line 342
    *(g_2_pix_alloc + i) = *(g_2_pix_alloc + 256);
#line 343
    *(g_2_pix_alloc + (i + 512)) = *(g_2_pix_alloc + 511);
#line 344
    *(b_2_pix_alloc + i) = *(b_2_pix_alloc + 256);
#line 345
    *(b_2_pix_alloc + (i + 512)) = *(b_2_pix_alloc + 511);
#line 338
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 348
  r_2_pix = r_2_pix_alloc + 256;
#line 349
  g_2_pix = g_2_pix_alloc + 256;
#line 350
  b_2_pix = b_2_pix_alloc + 256;
#line 352
  return;
}
}
#line 369 "yuv2rgb.c"
void Color16DitherImage(unsigned char **src , unsigned char *out ) 
{ 
  unsigned char *lum ;
  unsigned char *cb ;
  unsigned char *cr ;
  int cols ;
  int rows ;
  int L ;
  int CR ;
  int CB ;
  unsigned short *row1 ;
  unsigned short *row2 ;
  unsigned char *lum2 ;
  int x ;
  int y ;
  int cr_r ;
  int cr_g ;
  int cb_g ;
  int cb_b ;
  int cols_2 ;
  int R ;
  int G ;
  int B ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned short *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned short *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned short *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned short *tmp___8 ;

  {
#line 374
  lum = *(src + 0);
#line 375
  cb = *(src + 1);
#line 376
  cr = *(src + 2);
#line 390
  cols = coded_picture_width;
#line 391
  rows = coded_picture_height;
#line 392
  if (expand) {
#line 394
    cols *= 2;
#line 395
    rows *= 2;
  }
#line 397
  cols_2 = cols / 2;
#line 399
  row1 = (unsigned short *)out;
#line 400
  row2 = (row1 + cols_2) + cols_2;
#line 401
  lum2 = (lum + cols_2) + cols_2;
#line 403
  y = 0;
  {
  {
#line 403
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 403
    if (! (y < rows)) {
#line 403
      goto while_break;
    }
#line 405
    x = 0;
    {
    {
#line 405
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 405
      if (! (x < cols_2)) {
#line 405
        goto while_break___0;
      }
#line 409
      tmp = cr;
#line 409
      cr ++;
#line 409
      CR = (int )*tmp;
#line 410
      tmp___0 = cb;
#line 410
      cb ++;
#line 410
      CB = (int )*tmp___0;
#line 411
      cr_r = *(Cr_r_tab + CR);
#line 412
      cr_g = *(Cr_g_tab + CR);
#line 413
      cb_g = *(Cb_g_tab + CB);
#line 414
      cb_b = *(Cb_b_tab + CB);
#line 416
      tmp___1 = lum;
#line 416
      lum ++;
#line 416
      L = *(L_tab + (int )*tmp___1);
#line 418
      R = L + cr_r;
#line 419
      G = (L + cr_g) + cb_g;
#line 420
      B = L + cb_b;
#line 422
      tmp___2 = row1;
#line 422
      row1 ++;
#line 422
      *tmp___2 = (unsigned short )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 436
      tmp___3 = lum;
#line 436
      lum ++;
#line 436
      L = *(L_tab + (int )*tmp___3);
#line 438
      R = L + cr_r;
#line 439
      G = (L + cr_g) + cb_g;
#line 440
      B = L + cb_b;
#line 442
      tmp___4 = row1;
#line 442
      row1 ++;
#line 442
      *tmp___4 = (unsigned short )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 457
      tmp___5 = lum2;
#line 457
      lum2 ++;
#line 457
      L = *(L_tab + (int )*tmp___5);
#line 458
      R = L + cr_r;
#line 459
      G = (L + cr_g) + cb_g;
#line 460
      B = L + cb_b;
#line 462
      tmp___6 = row2;
#line 462
      row2 ++;
#line 462
      *tmp___6 = (unsigned short )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 464
      tmp___7 = lum2;
#line 464
      lum2 ++;
#line 464
      L = *(L_tab + (int )*tmp___7);
#line 465
      R = L + cr_r;
#line 466
      G = (L + cr_g) + cb_g;
#line 467
      B = L + cb_b;
#line 469
      tmp___8 = row2;
#line 469
      row2 ++;
#line 469
      *tmp___8 = (unsigned short )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 405
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 473
    lum += cols_2 + cols_2;
#line 474
    lum2 += cols_2 + cols_2;
#line 475
    row1 += cols_2 + cols_2;
#line 476
    row2 += cols_2 + cols_2;
#line 403
    y += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  return;
}
}
#line 499 "yuv2rgb.c"
void Color32DitherImage(unsigned char **src , unsigned char *out ) 
{ 
  unsigned char *lum ;
  unsigned char *cb ;
  unsigned char *cr ;
  int cols ;
  int rows ;
  int L ;
  int CR ;
  int CB ;
  unsigned int *row1 ;
  unsigned int *row2 ;
  unsigned char *lum2 ;
  int x ;
  int y ;
  int cr_r ;
  int cr_g ;
  int cb_g ;
  int cb_b ;
  int cols_2 ;
  int R ;
  int G ;
  int B ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned int *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned int *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned int *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned int *tmp___8 ;

  {
#line 504
  lum = *(src + 0);
#line 505
  cb = *(src + 1);
#line 506
  cr = *(src + 2);
#line 520
  cols = coded_picture_width;
#line 521
  rows = coded_picture_height;
#line 522
  if (expand) {
#line 524
    cols *= 2;
#line 525
    rows *= 2;
  }
#line 527
  cols_2 = cols / 2;
#line 529
  row1 = (unsigned int *)out;
#line 530
  row2 = (row1 + cols_2) + cols_2;
#line 531
  lum2 = (lum + cols_2) + cols_2;
#line 532
  y = 0;
  {
  {
#line 532
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 532
    if (! (y < rows)) {
#line 532
      goto while_break;
    }
#line 534
    x = 0;
    {
    {
#line 534
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 534
      if (! (x < cols_2)) {
#line 534
        goto while_break___0;
      }
#line 538
      tmp = cr;
#line 538
      cr ++;
#line 538
      CR = (int )*tmp;
#line 539
      tmp___0 = cb;
#line 539
      cb ++;
#line 539
      CB = (int )*tmp___0;
#line 540
      cr_r = *(Cr_r_tab + CR);
#line 541
      cr_g = *(Cr_g_tab + CR);
#line 542
      cb_g = *(Cb_g_tab + CB);
#line 543
      cb_b = *(Cb_b_tab + CB);
#line 545
      tmp___1 = lum;
#line 545
      lum ++;
#line 545
      L = *(L_tab + (int )*tmp___1);
#line 547
      R = L + cr_r;
#line 548
      G = (L + cr_g) + cb_g;
#line 549
      B = L + cb_b;
#line 551
      tmp___2 = row1;
#line 551
      row1 ++;
#line 551
      *tmp___2 = (unsigned int )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 565
      tmp___3 = lum;
#line 565
      lum ++;
#line 565
      L = *(L_tab + (int )*tmp___3);
#line 567
      R = L + cr_r;
#line 568
      G = (L + cr_g) + cb_g;
#line 569
      B = L + cb_b;
#line 571
      tmp___4 = row1;
#line 571
      row1 ++;
#line 571
      *tmp___4 = (unsigned int )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 587
      tmp___5 = lum2;
#line 587
      lum2 ++;
#line 587
      L = *(L_tab + (int )*tmp___5);
#line 588
      R = L + cr_r;
#line 589
      G = (L + cr_g) + cb_g;
#line 590
      B = L + cb_b;
#line 592
      tmp___6 = row2;
#line 592
      row2 ++;
#line 592
      *tmp___6 = (unsigned int )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 594
      tmp___7 = lum2;
#line 594
      lum2 ++;
#line 594
      L = *(L_tab + (int )*tmp___7);
#line 595
      R = L + cr_r;
#line 596
      G = (L + cr_g) + cb_g;
#line 597
      B = L + cb_b;
#line 599
      tmp___8 = row2;
#line 599
      row2 ++;
#line 599
      *tmp___8 = (unsigned int )((*(r_2_pix + R) | *(g_2_pix + G)) | *(b_2_pix + B));
#line 534
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 601
    lum += cols_2 + cols_2;
#line 602
    lum2 += cols_2 + cols_2;
#line 603
    row1 += cols_2 + cols_2;
#line 604
    row2 += cols_2 + cols_2;
#line 532
    y += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  return;
}
}
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 329
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 401
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 119
extern int toupper(int __c ) ;
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 81 "global.h"
void initbits(void) ;
#line 93
int getheader(void) ;
#line 95
void initoptions(void) ;
#line 98
void getpicture(int *framenum , int gob ) ;
#line 114
void interpolate_image(unsigned char *in , unsigned char *out , int width , int height ) ;
#line 129
void init_idct(void) ;
#line 132
void init_idctref(void) ;
#line 136
void error(char *text ) ;
#line 137
void printbits(int code , int bits , int len ) ;
#line 139
void doframerate(int pb ) ;
#line 148
void storeframe(unsigned char **src , int frame ) ;
#line 150
void save_frame(unsigned char **src , int framenum , FILE *file ) ;
#line 164
void init_display(char *name ) ;
#line 165
void exit_display(void) ;
#line 192 "global.h"
char version[100]  = 
#line 192
  {      (char )'t',      (char )'m',      (char )'n',      (char )'d', 
        (char )'e',      (char )'c',      (char )'o',      (char )'d', 
        (char )'e',      (char )' ',      (char )'v',      (char )'3', 
        (char )'.',      (char )'0',      (char )'\n',      (char )'(', 
        (char )'C',      (char )')',      (char )' ',      (char )'1', 
        (char )'9',      (char )'9',      (char )'7',      (char )',', 
        (char )' ',      (char )'U',      (char )'n',      (char )'i', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'B', 
        (char )'r',      (char )'i',      (char )'t',      (char )'i', 
        (char )'s',      (char )'h',      (char )' ',      (char )'C', 
        (char )'o',      (char )'l',      (char )'u',      (char )'m', 
        (char )'b',      (char )'i',      (char )'a',      (char )',', 
        (char )' ',      (char )'C',      (char )'a',      (char )'n', 
        (char )'a',      (char )'d',      (char )'a',      (char )'\n', 
        (char )'(',      (char )'C',      (char )')',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'5', 
        (char )',',      (char )' ',      (char )'1',      (char )'9', 
        (char )'9',      (char )'6',      (char )' ',      (char )'T', 
        (char )'e',      (char )'l',      (char )'e',      (char )'n', 
        (char )'o',      (char )'r',      (char )' ',      (char )'R', 
        (char )'&',      (char )'D',      (char )',',      (char )' ', 
        (char )'N',      (char )'o',      (char )'r',      (char )'w', 
        (char )'a',      (char )'y',      (char )'\n',      (char )'\000'};
#line 199 "global.h"
unsigned char zig_zag_scan[64]  = 
#line 199
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)8,      (unsigned char)16, 
        (unsigned char)9,      (unsigned char)2,      (unsigned char)3,      (unsigned char)10, 
        (unsigned char)17,      (unsigned char)24,      (unsigned char)32,      (unsigned char)25, 
        (unsigned char)18,      (unsigned char)11,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)12,      (unsigned char)19,      (unsigned char)26,      (unsigned char)33, 
        (unsigned char)40,      (unsigned char)48,      (unsigned char)41,      (unsigned char)34, 
        (unsigned char)27,      (unsigned char)20,      (unsigned char)13,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)14,      (unsigned char)21,      (unsigned char)28, 
        (unsigned char)35,      (unsigned char)42,      (unsigned char)49,      (unsigned char)56, 
        (unsigned char)57,      (unsigned char)50,      (unsigned char)43,      (unsigned char)36, 
        (unsigned char)29,      (unsigned char)22,      (unsigned char)15,      (unsigned char)23, 
        (unsigned char)30,      (unsigned char)37,      (unsigned char)44,      (unsigned char)51, 
        (unsigned char)58,      (unsigned char)59,      (unsigned char)52,      (unsigned char)45, 
        (unsigned char)38,      (unsigned char)31,      (unsigned char)39,      (unsigned char)46, 
        (unsigned char)53,      (unsigned char)60,      (unsigned char)61,      (unsigned char)54, 
        (unsigned char)47,      (unsigned char)55,      (unsigned char)62,      (unsigned char)63};
#line 211 "global.h"
int lines[7]  = {      -1,      128,      176,      352, 
        704,      1408,      -1};
#line 217 "global.h"
int pels[7]  = {      -1,      96,      144,      288, 
        576,      1152,      -1};
#line 224 "global.h"
unsigned char alternate_horizontal_scan[64]  = 
#line 224
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)16,      (unsigned char)17, 
        (unsigned char)10,      (unsigned char)11,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)6,      (unsigned char)7,      (unsigned char)15,      (unsigned char)14, 
        (unsigned char)13,      (unsigned char)12,      (unsigned char)19,      (unsigned char)18, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)32,      (unsigned char)33, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)20,      (unsigned char)21, 
        (unsigned char)22,      (unsigned char)23,      (unsigned char)28,      (unsigned char)29, 
        (unsigned char)30,      (unsigned char)31,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)48,      (unsigned char)49, 
        (unsigned char)42,      (unsigned char)43,      (unsigned char)36,      (unsigned char)37, 
        (unsigned char)38,      (unsigned char)39,      (unsigned char)44,      (unsigned char)45, 
        (unsigned char)46,      (unsigned char)47,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63};
#line 235 "global.h"
unsigned char alternate_vertical_scan[64]  = 
#line 235
  {      (unsigned char)0,      (unsigned char)8,      (unsigned char)16,      (unsigned char)24, 
        (unsigned char)1,      (unsigned char)9,      (unsigned char)2,      (unsigned char)10, 
        (unsigned char)17,      (unsigned char)25,      (unsigned char)32,      (unsigned char)40, 
        (unsigned char)48,      (unsigned char)56,      (unsigned char)57,      (unsigned char)49, 
        (unsigned char)41,      (unsigned char)33,      (unsigned char)26,      (unsigned char)18, 
        (unsigned char)3,      (unsigned char)11,      (unsigned char)4,      (unsigned char)12, 
        (unsigned char)19,      (unsigned char)27,      (unsigned char)34,      (unsigned char)42, 
        (unsigned char)50,      (unsigned char)58,      (unsigned char)35,      (unsigned char)43, 
        (unsigned char)51,      (unsigned char)59,      (unsigned char)20,      (unsigned char)28, 
        (unsigned char)5,      (unsigned char)13,      (unsigned char)6,      (unsigned char)14, 
        (unsigned char)21,      (unsigned char)29,      (unsigned char)36,      (unsigned char)44, 
        (unsigned char)52,      (unsigned char)60,      (unsigned char)37,      (unsigned char)45, 
        (unsigned char)53,      (unsigned char)61,      (unsigned char)22,      (unsigned char)30, 
        (unsigned char)7,      (unsigned char)15,      (unsigned char)23,      (unsigned char)31, 
        (unsigned char)38,      (unsigned char)46,      (unsigned char)54,      (unsigned char)62, 
        (unsigned char)39,      (unsigned char)47,      (unsigned char)55,      (unsigned char)63};
#line 257 "global.h"
int convmat[8][4]  = 
#line 257
  { {        117504,        138453,        13954,        34903}, 
   {        117504,        138453,        13954,        34903}, 
   {        104597,        132201,        25675,        53279}, 
   {        104597,        132201,        25675,        53279}, 
   {        104448,        132798,        24759,        53109}, 
   {        104597,        132201,        25675,        53279}, 
   {        104597,        132201,        25675,        53279}, 
   {        117579,        136230,        16907,        35559}};
#line 273 "global.h"
int quiet  ;
#line 274 "global.h"
int trace  ;
#line 275 "global.h"
int save_frames  ;
#line 276 "global.h"
char errortext[256]  ;
#line 277 "global.h"
unsigned char *prev_frame[3]  ;
#line 277 "global.h"
unsigned char *current_frame[3]  ;
#line 277 "global.h"
unsigned char *bframe[3]  ;
#line 278 "global.h"
unsigned char *tmp_f[3]  ;
#line 278 "global.h"
unsigned char *tmp_b[3]  ;
#line 279 "global.h"
unsigned char *edgeframe[3]  ;
#line 279 "global.h"
unsigned char *edgeframeorig[3]  ;
#line 279 "global.h"
unsigned char *exnewframe[3]  ;
#line 280 "global.h"
unsigned char *nextedgeframe[3]  ;
#line 280 "global.h"
unsigned char *nextedgeframeorig[3]  ;
#line 281 "global.h"
unsigned char *enhancementedgeframe[3]  ;
#line 281 "global.h"
unsigned char *enhacnementedgeframeorig[3]  ;
#line 282 "global.h"
unsigned char *next_I_P_frame[3]  ;
#line 282 "global.h"
unsigned char *prev_I_P_frame[3]  ;
#line 282 "global.h"
unsigned char *buffered_frame[3]  ;
#line 283 "global.h"
int MV[2][6][73][90]  ;
#line 284 "global.h"
int true_B_direct_mode_MV[2][5][73][90]  ;
#line 285 "global.h"
int modemap[73][90]  ;
#line 286 "global.h"
int anchorframemodemap[73][90]  ;
#line 287 "global.h"
int predictionmap[73][90]  ;
#line 288 "global.h"
unsigned char *clp  ;
#line 289 "global.h"
int horizontal_size  ;
#line 289 "global.h"
int vertical_size  ;
#line 289 "global.h"
int mb_width  ;
#line 289 "global.h"
int mb_height  ;
#line 290 "global.h"
int coded_picture_width  ;
#line 290 "global.h"
int coded_picture_height  ;
#line 291 "global.h"
int ref_coded_picture_width  ;
#line 291 "global.h"
int ref_coded_picture_height  ;
#line 292 "global.h"
int chrom_width  ;
#line 292 "global.h"
int chrom_height  ;
#line 292 "global.h"
int blk_cnt  ;
#line 293 "global.h"
int ref_chrom_width  ;
#line 293 "global.h"
int ref_chrom_height  ;
#line 294 "global.h"
int pict_type  ;
#line 294 "global.h"
int newgob  ;
#line 294 "global.h"
int gfid  ;
#line 294 "global.h"
int pgfid  ;
#line 295 "global.h"
int mv_outside_frame  ;
#line 296 "global.h"
int syntax_arith_coding  ;
#line 297 "global.h"
int adv_pred_mode  ;
#line 298 "global.h"
int overlapping_MC  ;
#line 299 "global.h"
int use_4mv  ;
#line 300 "global.h"
int pb_frame  ;
#line 301 "global.h"
int true_B_frame  ;
#line 302 "global.h"
int scalability_mode  ;
#line 303 "global.h"
int buffered_framenum  ;
#line 304 "global.h"
int long_vectors  ;
#line 305 "global.h"
int fault  ;
#line 305 "global.h"
int expand  ;
#line 306 "global.h"
int verbose  ;
#line 307 "global.h"
int refidct  ;
#line 308 "global.h"
int matrix_coefficients  ;
#line 309 "global.h"
int temp_ref  ;
#line 309 "global.h"
int prev_non_disposable_temp_ref  ;
#line 309 "global.h"
int next_non_disposable_temp_ref  ;
#line 310 "global.h"
int pic_quant  ;
#line 310 "global.h"
int quant  ;
#line 310 "global.h"
int source_format  ;
#line 310 "global.h"
int base_source_format  ;
#line 311 "global.h"
int UFEP  ;
#line 312 "global.h"
int prev_mv_outside_frame  ;
#line 312 "global.h"
int prev_sac  ;
#line 312 "global.h"
int prev_adv_pred  ;
#line 312 "global.h"
int prev_aic  ;
#line 312 "global.h"
int prev_df  ;
#line 313 "global.h"
int prev_slice_struct  ;
#line 313 "global.h"
int prev_rps  ;
#line 313 "global.h"
int prev_isd  ;
#line 313 "global.h"
int prev_aivlc  ;
#line 313 "global.h"
int prev_mq  ;
#line 314 "global.h"
int prev_4mv  ;
#line 314 "global.h"
int prev_long_vectors  ;
#line 314 "global.h"
int prev_obmc  ;
#line 317 "global.h"
int plus_type  ;
#line 319 "global.h"
int optional_custom_PCF  ;
#line 320 "global.h"
int advanced_intra_coding  ;
#line 321 "global.h"
int deblocking_filter_mode  ;
#line 322 "global.h"
int slice_structured_mode  ;
#line 323 "global.h"
int reference_picture_selection_mode  ;
#line 324 "global.h"
int independently_segmented_decoding_mode  ;
#line 325 "global.h"
int alternative_inter_VLC_mode  ;
#line 326 "global.h"
int modified_quantization_mode  ;
#line 327 "global.h"
int reduced_resolution_update_mode  ;
#line 328 "global.h"
int reference_picture_resampling_mode  ;
#line 329 "global.h"
int rtype  ;
#line 330 "global.h"
int post_filter  ;
#line 331 "global.h"
int unlimited_unrestricted_motion_vectors  ;
#line 332 "global.h"
int concealment  ;
#line 335 "global.h"
unsigned char *prev_enhancement_frame[2][3]  ;
#line 335 "global.h"
unsigned char *current_enhancement_frame[2][3]  ;
#line 336 "global.h"
unsigned char *curr_reference_frame[3]  ;
#line 336 "global.h"
unsigned char *upsampled_reference_frame[3]  ;
#line 337 "global.h"
unsigned char *enhance_edgeframeorig[2][3]  ;
#line 337 "global.h"
unsigned char *enhance_edgeframe[2][3]  ;
#line 338 "global.h"
unsigned char *tmp_enhance_fwd[2][3]  ;
#line 338 "global.h"
unsigned char *tmp_enhance_up[2][3]  ;
#line 339 "global.h"
int enhancement_layer_init[2]  ;
#line 340 "global.h"
int enhance_pict  ;
#line 343 "global.h"
int CP_PAR_code  ;
#line 344 "global.h"
int CP_picture_width_indication  ;
#line 345 "global.h"
int CP_picture_width  ;
#line 346 "global.h"
int CP_picture_height_indication  ;
#line 347 "global.h"
int CP_picture_height  ;
#line 348 "global.h"
int PAR_width  ;
#line 349 "global.h"
int PAR_height  ;
#line 351 "global.h"
int CP_clock_frequency  ;
#line 352 "global.h"
int SSS_rectangular_slices  ;
#line 353 "global.h"
int SSS_arbitary_slice_ordering  ;
#line 354 "global.h"
int enhancement_layer_num  ;
#line 355 "global.h"
int reference_layer_number  ;
#line 356 "global.h"
int MF_of_reference_picture_selection  ;
#line 357 "global.h"
int TRI  ;
#line 357 "global.h"
int TRPI  ;
#line 358 "global.h"
int temporal_reference_for_prediction  ;
#line 361 "global.h"
int framerate  ;
#line 363 "global.h"
struct timeval tftarget  ;
#line 370 "global.h"
int trd  ;
#line 370 "global.h"
int trb  ;
#line 370 "global.h"
int bscan  ;
#line 370 "global.h"
int bquant  ;
#line 370 "global.h"
int true_b_trb  ;
#line 371 "global.h"
int bscan_tab[4]  = {      2,      4,      6,      8};
#line 376 "global.h"
int bquant_tab[4]  = {      5,      6,      7,      8};
#line 382 "global.h"
int OM[5][8][8]  = { { {          4,          5,          5,          5, 
                5,          5,          5,          4}, 
     {          5,          5,          5,          5, 
                5,          5,          5,          5}, 
     {          5,          5,          6,          6, 
                6,          6,          5,          5}, 
     {          5,          5,          6,          6, 
                6,          6,          5,          5}, 
     {          5,          5,          6,          6, 
                6,          6,          5,          5}, 
     {          5,          5,          6,          6, 
                6,          6,          5,          5}, 
     {          5,          5,          5,          5, 
                5,          5,          5,          5}, 
     {          4,          5,          5,          5, 
                5,          5,          5,          4}}, 
   { {          2,          2,          2,          2, 
                2,          2,          2,          2}, 
     {          1,          1,          2,          2, 
                2,          2,          1,          1}, 
     {          1,          1,          1,          1, 
                1,          1,          1,          1}, 
     {          1,          1,          1,          1, 
                1,          1,          1,          1}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}}, 
   { {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          0,          0,          0,          0, 
                0,          0,          0,          0}, 
     {          1,          1,          1,          1, 
                1,          1,          1,          1}, 
     {          1,          1,          1,          1, 
                1,          1,          1,          1}, 
     {          1,          1,          2,          2, 
                2,          2,          1,          1}, 
     {          2,          2,          2,          2, 
                2,          2,          2,          2}}, 
   { {          0,          0,          0,          0, 
                1,          1,          1,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          2,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          2,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          2,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          2,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          2,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          2,          2}, 
     {          0,          0,          0,          0, 
                1,          1,          1,          2}}, 
   { {          2,          1,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          2,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          2,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          2,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          2,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          2,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          2,          1,          1, 
                0,          0,          0,          0}, 
     {          2,          1,          1,          1, 
                0,          0,          0,          0}}};
#line 434 "global.h"
int roundtab[16]  = 
#line 434
  {      0,      0,      0,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      2,      2};
#line 440 "global.h"
int MQ_chroma_QP_table[32]  = 
#line 440
  {      0,      1,      2,      3, 
        4,      5,      6,      6, 
        7,      8,      9,      9, 
        10,      10,      11,      11, 
        12,      12,      12,      13, 
        13,      13,      14,      14, 
        14,      14,      14,      15, 
        15,      15,      15,      15};
#line 448 "global.h"
char *outputname  ;
#line 449 "global.h"
char trace_file_name[100]  ;
#line 450 "global.h"
FILE *trace_file  ;
#line 451 "global.h"
char recon_file_name[100]  ;
#line 452 "global.h"
FILE *recon_file_ptr  ;
#line 453 "global.h"
char enhance_recon_file_name[2][100]  ;
#line 454 "global.h"
FILE *enhance_recon_file_ptr[2]  ;
#line 456 "global.h"
int outtype  ;
#line 465 "global.h"
struct ld base  ;
#line 465 "global.h"
struct ld *ld  ;
#line 483 "global.h"
int ring_pointer  ;
#line 484 "global.h"
void *ring_lum[8]  ;
#line 485 "global.h"
void *ring_Cr[8]  ;
#line 486 "global.h"
void *ring_Cb[8]  ;
#line 487 "global.h"
int ring_temporal_reference[8]  ;
#line 488 "global.h"
int ring_quality[8]  ;
#line 489 "global.h"
int stop_decoder  ;
#line 493 "global.h"
struct bcm BCM  ;
#line 72 "/usr/include/sys/time.h"
extern int gettimeofday(struct timeval * __restrict  __tv , __timezone_ptr_t __tz ) ;
#line 92 "tmndec.c"
static void initdecoder(void) ;
#line 93
static void options(int *argcp , char ***argvp ) ;
#line 94
static int getval(char **argv ) ;
#line 95
static void flushdisplaybuffer(int framenum ) ;
#line 97 "tmndec.c"
static int loopflag  ;
#line 156
extern int ( /* missing proto */  lseek)() ;
#line 191
extern int ( /* missing proto */  close)() ;
#line 99 "tmndec.c"
int main(int argc , char **argv ) 
{ 
  int first ;
  int framenum ;
  int gob ;
  int runtime ;
  struct timeval tstart ;
  struct timeval tstop ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 114
  framerate = 99;
  {
#line 117
  options(& argc, & argv);
  }
  }
#line 119
  if (trace) {
    {
    {
#line 121
    trace_file = fopen((char const   */* __restrict  */)(trace_file_name), (char const   */* __restrict  */)"wt");
    }
    }
#line 121
    if ((unsigned long )trace_file == (unsigned long )((void *)0)) {
      {
      {
#line 123
      printf((char const   */* __restrict  */)"Unable to open trace file");
      }
      {
#line 124
      exit(-1);
      }
      }
    }
  }
#line 127
  if (save_frames) {
    {
    {
#line 129
    recon_file_ptr = fopen((char const   */* __restrict  */)(recon_file_name), (char const   */* __restrict  */)"wb");
    }
    }
#line 129
    if ((unsigned long )recon_file_ptr == (unsigned long )((void *)0)) {
      {
      {
#line 131
      printf((char const   */* __restrict  */)"Unable to open reconstruction file");
      }
      {
#line 132
      exit(-1);
      }
      }
    }
  }
#line 137
  if (outtype == 4) {
#line 138
    outputname = (char *)"";
  } else
#line 137
  if (outtype == 6) {
#line 138
    outputname = (char *)"";
  } else {
#line 141
    outputname = *(argv + (argc - 1));
  }
  {
#line 143
  ld = & base;
  {
#line 146
  base.infile = open((char const   *)*(argv + 1), 0);
  }
  }
#line 146
  if (base.infile < 0) {
    {
    {
#line 148
    sprintf((char */* __restrict  */)(errortext), (char const   */* __restrict  */)"Input file %s not found\n",
            *(argv + 1));
    }
    {
#line 149
    error(errortext);
    }
    }
  }
#line 151
  first = 1;
  {
  {
#line 153
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 155
    if (base.infile != 0) {
      {
      {
#line 156
      lseek(base.infile, 0L, 0);
      }
      }
    }
    {
    {
#line 157
    initbits();
    }
    {
#line 158
    initoptions();
    }
#line 159
    framenum = 0;
#line 160
    temp_ref = 0;
#line 161
    next_non_disposable_temp_ref = 0;
#line 161
    prev_non_disposable_temp_ref = next_non_disposable_temp_ref;
    }
    {
    {
#line 163
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 163
      gob = getheader();
      }
      }
#line 163
      if (! gob) {
#line 163
        goto while_break___0;
      }
#line 165
      if (first) {
        {
#line 167
        base_source_format = source_format;
        {
#line 168
        initdecoder();
        }
        {
#line 171
        gettimeofday((struct timeval */* __restrict  */)(& tstart), (__timezone_ptr_t )((struct timezone *)((void *)0)));
        }
        }
#line 172
        if (framerate > 0) {
          {
          {
#line 173
          gettimeofday((struct timeval */* __restrict  */)(& tftarget), (__timezone_ptr_t )((struct timezone *)((void *)0)));
          }
          }
        }
#line 180
        first = 0;
      }
      {
      {
#line 182
      getpicture(& framenum, gob);
      }
#line 184
      framenum ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 187
    flushdisplaybuffer(framenum);
    }
    }
#line 153
    if (! loopflag) {
#line 153
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 191
  close(base.infile);
  }
  {
#line 195
  gettimeofday((struct timeval */* __restrict  */)(& tstop), (__timezone_ptr_t )((struct timezone *)((void *)0)));
  }
#line 196
  runtime = (int )(100L * (tstop.tv_sec - tstart.tv_sec) + (tstop.tv_usec - tstart.tv_usec) / 10000L);
  }
#line 202
  if (! quiet) {
#line 202
    if (runtime != 0) {
      {
      {
#line 203
      printf((char const   */* __restrict  */)"%d.%02d seconds, %d frames, %d.%02d fps\n",
             runtime / 100, runtime % 100, framenum, ((10000 * framenum + runtime / 2) / runtime) / 100,
             ((10000 * framenum + runtime / 2) / runtime) % 100);
      }
      }
    }
  }
#line 210
  if (outtype == 4) {
    {
    {
#line 211
    exit_display();
    }
    }
  }
#line 218
  return (0);
}
}
#line 221 "tmndec.c"
static void initdecoder(void) 
{ 
  int i ;
  int cc ;
  int size ;
  FILE *cleared ;
  void *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  void *tmp___4 ;
  unsigned char *tmp___5 ;
  void *tmp___6 ;
  unsigned char *tmp___7 ;
  void *tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  unsigned char *tmp___11 ;
  void *tmp___12 ;
  unsigned char *tmp___13 ;
  void *tmp___14 ;
  unsigned char *tmp___15 ;
  void *tmp___16 ;
  unsigned char *tmp___17 ;
  void *tmp___18 ;
  unsigned char *tmp___19 ;
  void *tmp___20 ;
  unsigned char *tmp___21 ;
  void *tmp___22 ;
  unsigned char *tmp___23 ;
  void *tmp___24 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
  {
  {
#line 227
  tmp = malloc((size_t )1024);
  }
#line 227
  clp = (unsigned char *)tmp;
  }
#line 227
  if (! clp) {
    {
    {
#line 228
    error((char *)"malloc failed\n");
    }
    }
  }
#line 230
  clp += 384;
#line 232
  i = -384;
  {
  {
#line 232
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 232
    if (! (i < 640)) {
#line 232
      goto while_break;
    }
#line 233
    if (i < 0) {
#line 233
      *(clp + i) = (unsigned char)0;
    } else {
#line 233
      if (i > 255) {
#line 233
        tmp___0 = 255;
      } else {
#line 233
        tmp___0 = i;
      }
#line 233
      *(clp + i) = (unsigned char )tmp___0;
    }
#line 232
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  matrix_coefficients = 5;
#line 238
  blk_cnt = 6;
#line 240
  i = 0;
  {
  {
#line 240
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 240
    if (! (i < 2)) {
#line 240
      goto while_break___0;
    }
#line 241
    enhancement_layer_init[i] = 0;
#line 240
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 243
  cc = 0;
  {
  {
#line 243
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 243
    if (! (cc < 3)) {
#line 243
      goto while_break___1;
    }
#line 245
    if (cc == 0) {
#line 246
      size = coded_picture_width * coded_picture_height;
    } else {
#line 248
      size = chrom_width * chrom_height;
    }
    {
    {
#line 252
    tmp___2 = malloc((size_t )size);
    }
#line 252
    tmp___1 = (unsigned char *)tmp___2;
#line 252
    next_I_P_frame[cc] = tmp___1;
    }
#line 252
    if (! tmp___1) {
      {
      {
#line 253
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 255
    tmp___4 = malloc((size_t )size);
    }
#line 255
    tmp___3 = (unsigned char *)tmp___4;
#line 255
    prev_I_P_frame[cc] = tmp___3;
    }
#line 255
    if (! tmp___3) {
      {
      {
#line 256
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 258
    tmp___6 = malloc((size_t )size);
    }
#line 258
    tmp___5 = (unsigned char *)tmp___6;
#line 258
    current_frame[cc] = tmp___5;
    }
#line 258
    if (! tmp___5) {
      {
      {
#line 259
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 261
    tmp___8 = malloc((size_t )size);
    }
#line 261
    tmp___7 = (unsigned char *)tmp___8;
#line 261
    bframe[cc] = tmp___7;
    }
#line 261
    if (! tmp___7) {
      {
      {
#line 262
      error((char *)"malloc failed\n");
      }
      }
    }
    {
#line 264
    prev_frame[cc] = current_frame[cc];
    {
#line 266
    tmp___10 = malloc((size_t )size);
    }
#line 266
    tmp___9 = (unsigned char *)tmp___10;
#line 266
    tmp_f[cc] = tmp___9;
    }
#line 266
    if (! tmp___9) {
      {
      {
#line 267
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 269
    tmp___12 = malloc((size_t )size);
    }
#line 269
    tmp___11 = (unsigned char *)tmp___12;
#line 269
    tmp_b[cc] = tmp___11;
    }
#line 269
    if (! tmp___11) {
      {
      {
#line 270
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 273
    tmp___14 = malloc((size_t )size);
    }
#line 273
    tmp___13 = (unsigned char *)tmp___14;
#line 273
    buffered_frame[cc] = tmp___13;
    }
#line 273
    if (! tmp___13) {
      {
      {
#line 274
      error((char *)"malloc failed\n");
      }
      }
    }
#line 243
    cc ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 277
  cc = 0;
  {
  {
#line 277
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 277
    if (! (cc < 3)) {
#line 277
      goto while_break___2;
    }
#line 279
    if (cc == 0) {
      {
#line 281
      size = (coded_picture_width + 64) * (coded_picture_height + 64);
      {
#line 284
      tmp___16 = malloc((size_t )size);
      }
#line 284
      tmp___15 = (unsigned char *)tmp___16;
#line 284
      edgeframeorig[cc] = tmp___15;
      }
#line 284
      if (! tmp___15) {
        {
        {
#line 285
        error((char *)"malloc failed\n");
        }
        }
      }
      {
#line 286
      edgeframe[cc] = (edgeframeorig[cc] + (coded_picture_width + 64) * 32) + 32;
      {
#line 290
      tmp___18 = malloc((size_t )size);
      }
#line 290
      tmp___17 = (unsigned char *)tmp___18;
#line 290
      nextedgeframeorig[cc] = tmp___17;
      }
#line 290
      if (! tmp___17) {
        {
        {
#line 291
        error((char *)"malloc failed\n");
        }
        }
      }
#line 292
      nextedgeframe[cc] = (nextedgeframeorig[cc] + (coded_picture_width + 64) * 32) + 32;
    } else {
      {
#line 296
      size = (chrom_width + 32) * (chrom_height + 32);
      {
#line 299
      tmp___20 = malloc((size_t )size);
      }
#line 299
      tmp___19 = (unsigned char *)tmp___20;
#line 299
      edgeframeorig[cc] = tmp___19;
      }
#line 299
      if (! tmp___19) {
        {
        {
#line 300
        error((char *)"malloc failed\n");
        }
        }
      }
      {
#line 301
      edgeframe[cc] = (edgeframeorig[cc] + (chrom_width + 32) * 16) + 16;
      {
#line 305
      tmp___22 = malloc((size_t )size);
      }
#line 305
      tmp___21 = (unsigned char *)tmp___22;
#line 305
      nextedgeframeorig[cc] = tmp___21;
      }
#line 305
      if (! tmp___21) {
        {
        {
#line 306
        error((char *)"malloc failed\n");
        }
        }
      }
#line 307
      nextedgeframe[cc] = (nextedgeframeorig[cc] + (chrom_width + 32) * 16) + 16;
    }
#line 277
    cc ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 311
  if (expand) {
#line 313
    cc = 0;
    {
    {
#line 313
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 313
      if (! (cc < 3)) {
#line 313
        goto while_break___3;
      }
#line 315
      if (cc == 0) {
#line 316
        size = (coded_picture_width * coded_picture_height) * 4;
      } else {
#line 318
        size = (chrom_width * chrom_height) * 4;
      }
      {
      {
#line 320
      tmp___24 = malloc((size_t )size);
      }
#line 320
      tmp___23 = (unsigned char *)tmp___24;
#line 320
      exnewframe[cc] = tmp___23;
      }
#line 320
      if (! tmp___23) {
        {
        {
#line 321
        error((char *)"malloc failed\n");
        }
        }
      }
#line 313
      cc ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 325
  if (outtype == 5) {
    {
    {
#line 327
    cleared = fopen((char const   */* __restrict  */)outputname, (char const   */* __restrict  */)"wb");
    }
    }
#line 327
    if ((unsigned long )cleared == (unsigned long )((void *)0)) {
      {
      {
#line 328
      error((char *)"couldn\'t clear outputfile\n");
      }
      }
    } else {
      {
      {
#line 330
      fclose(cleared);
      }
      }
    }
  }
#line 333
  if (refidct) {
    {
    {
#line 334
    init_idctref();
    }
    }
  } else {
    {
    {
#line 336
    init_idct();
    }
    }
  }
#line 339
  if (outtype == 4) {
    {
    {
#line 341
    init_display((char *)"");
    }
    }
  }
#line 351
  prev_df = 0;
#line 351
  prev_aic = prev_df;
#line 351
  prev_adv_pred = prev_aic;
#line 351
  prev_sac = prev_adv_pred;
#line 351
  prev_mv_outside_frame = prev_sac;
#line 352
  prev_mq = 0;
#line 352
  prev_aivlc = prev_mq;
#line 352
  prev_isd = prev_aivlc;
#line 352
  prev_rps = prev_isd;
#line 352
  prev_slice_struct = prev_rps;
#line 353
  prev_obmc = 0;
#line 353
  prev_long_vectors = prev_obmc;
#line 353
  prev_4mv = prev_long_vectors;
#line 354
  return;
}
}
#line 356 "tmndec.c"
void error(char *text ) 
{ 


  {
  {
  {
#line 358
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)text);
  }
  {
#line 359
  exit(1);
  }
  }
}
}
#line 363 "tmndec.c"
void printbits(int code , int bits , int len ) 
{ 
  int i ;
  char *__cil_tmp5 ;

  {
#line 366
  i = 0;
  {
  {
#line 366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 366
    if (! (i < len)) {
#line 366
      goto while_break;
    }
    {
    {
#line 367
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"%d",
            (code >> ((bits - 1) - i)) & 1);
    }
#line 366
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 371 "tmndec.c"
static void options(int *argcp , char ***argvp ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 373
  trace = 0;
#line 374
  save_frames = 0;
  {
  {
#line 376
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 376
    if (*argcp > 1) {
#line 376
      if (! ((int )*(*(*argvp + 1) + 0) == 45)) {
#line 376
        goto while_break;
      }
    } else {
#line 376
      goto while_break;
    }
    {
    {
#line 378
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 378
      if (! *(*(*argvp + 1) + 1)) {
#line 378
        goto while_break___0;
      }
      {
      {
#line 380
      tmp = toupper((int )*(*(*argvp + 1) + 1));
      }
      }
      {
#line 383
      if (tmp == 70) {
#line 383
        goto case_70;
      }
#line 387
      if (tmp == 86) {
#line 387
        goto case_86;
      }
#line 390
      if (tmp == 79) {
#line 390
        goto case_79;
      }
#line 393
      if (tmp == 82) {
#line 393
        goto case_82;
      }
#line 396
      if (tmp == 76) {
#line 396
        goto case_76;
      }
#line 399
      if (tmp == 88) {
#line 399
        goto case_88;
      }
#line 402
      if (tmp == 84) {
#line 402
        goto case_84;
      }
#line 406
      if (tmp == 83) {
#line 406
        goto case_83;
      }
#line 419
      if (tmp == 81) {
#line 419
        goto case_81;
      }
#line 422
      if (tmp == 80) {
#line 422
        goto case_80;
      }
#line 425
      if (tmp == 67) {
#line 425
        goto case_67;
      }
#line 430
      goto switch_default;
      case_70: /* CIL Label */ 
      {
      {
#line 384
      framerate = getval(*argvp);
      }
      }
#line 385
      goto switch_break;
      case_86: /* CIL Label */ 
      {
      {
#line 388
      verbose = getval(*argvp);
      }
      }
#line 389
      goto switch_break;
      case_79: /* CIL Label */ 
      {
      {
#line 391
      outtype = getval(*argvp);
      }
      }
#line 392
      goto switch_break;
      case_82: /* CIL Label */ 
#line 394
      refidct = 1;
#line 395
      goto switch_break;
      case_76: /* CIL Label */ 
#line 397
      loopflag = 1;
#line 398
      goto switch_break;
      case_88: /* CIL Label */ 
#line 400
      expand = 1;
#line 401
      goto switch_break;
      case_84: /* CIL Label */ 
      {
#line 403
      trace = 1;
      {
#line 404
      strcpy((char */* __restrict  */)(trace_file_name), (char const   */* __restrict  */)"trace.dec");
      }
      }
#line 405
      goto switch_break;
      case_83: /* CIL Label */ 
      {
#line 407
      save_frames = 1;
#line 408
      (*argvp) ++;
#line 409
      (*argcp) --;
      {
#line 410
      strcpy((char */* __restrict  */)(recon_file_name), (char const   */* __restrict  */)*(*argvp + 1));
      }
      {
#line 411
      tmp___0 = strlen((char const   *)(recon_file_name));
      }
#line 411
      *(*argvp + 1) += tmp___0;
      }
#line 412
      if ((int )recon_file_name[0] == 45) {
        {
        {
#line 414
        printf((char const   */* __restrict  */)"Reconstruction file name is expected after -S option");
        }
        {
#line 415
        exit(-1);
        }
        }
      }
#line 417
      goto switch_break;
      case_81: /* CIL Label */ 
#line 420
      quiet = 1;
#line 421
      goto switch_break;
      case_80: /* CIL Label */ 
#line 423
      post_filter = 1;
#line 424
      goto switch_break;
      case_67: /* CIL Label */ 
#line 426
      concealment = 1;
#line 427
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"undefined option -%c ignored\n",
              (int )*(*(*argvp + 1) + 1));
      }
      }
      switch_break: /* CIL Label */ ;
      }
#line 434
      (*(*argvp + 1)) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    (*argvp) ++;
#line 438
    (*argcp) --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  if (outtype != 4) {
#line 442
    if (outtype != 6) {
#line 444
      loopflag = 0;
#line 446
      framerate = 0;
    }
  }
#line 450
  if (outtype == 4) {
#line 452
    (*argcp) ++;
  }
#line 462
  if (*argcp != 3) {
#line 462
    if (*argcp != 4) {
      {
      {
#line 464
      printf((char const   */* __restrict  */)"\n%s\n", version);
      }
      {
#line 465
      printf((char const   */* __restrict  */)"Usage:   tmndecode {options} bitstream {outputfilename%%d}\nOptions: -vn  verbose output (n: level)\n         -on  output format \n              n=0 : YUV\n              n=1 : SIF\n              n=2 : TGA\n              n=3 : PPM\n");
      }
      {
#line 473
      printf((char const   */* __restrict  */)"              n=4 : X11 Display\n");
      }
      {
#line 476
      printf((char const   */* __restrict  */)"              n=5 : YUV concatenated\n");
      }
      {
#line 482
      printf((char const   */* __restrict  */)"              You have to choose one output format!\n         -q   disable warnings to stderr\n         -r   use double precision reference IDCT\n         -t   enable low level tracing\n         -s <filename>  output reconstructed frame to filename (YUV concatenated)\n         -p   enable tmn-8 post filter\n         -c   enable error concealment\n");
      }
      {
#line 491
      printf((char const   */* __restrict  */)"         -x   interpolate pictures to double size before display\n");
      }
      {
#line 495
      printf((char const   */* __restrict  */)"         -fn  frame rate\n              n=0  : as fast as possible\n              n=99 : read frame rate from bitstream (default)\n");
      }
      {
#line 501
      printf((char const   */* __restrict  */)"         -l   loop sequence\n");
      }
      {
#line 504
      exit(0);
      }
      }
    }
  }
#line 506
  return;
}
}
#line 508 "tmndec.c"
static int getval(char **argv ) 
{ 
  int val ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 512
  tmp = sscanf((char const   */* __restrict  */)(*(argv + 1) + 2), (char const   */* __restrict  */)"%d",
               & val);
  }
  }
#line 512
  if (tmp != 1) {
#line 513
    return (0);
  }
  {
  {
#line 515
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 515
    tmp___0 = __ctype_b_loc();
    }
    }
#line 515
    if (! ((int const   )*(*tmp___0 + (int )*(*(argv + 1) + 2)) & 2048)) {
#line 515
      goto while_break;
    }
#line 516
    (*(argv + 1)) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  return (val);
}
}
#line 527 "tmndec.c"
void doframerate(int pb ) 
{ 
  struct timeval tfdiff ;
  float REF_FRAME_RATE ;

  {
#line 530
  REF_FRAME_RATE = (float )29.97;
#line 533
  if (framerate <= 0) {
#line 534
    return;
  }
#line 536
  if (framerate != 99) {
#line 538
    tftarget.tv_usec += (__suseconds_t )(1000000 / framerate);
  } else
#line 541
  if (pb) {
#line 543
    tftarget.tv_usec = (__suseconds_t )((float )tftarget.tv_usec + (float )1000000 / (REF_FRAME_RATE / (float )trb));
  } else {
#line 546
    tftarget.tv_usec = (__suseconds_t )((float )tftarget.tv_usec + (float )1000000 / (REF_FRAME_RATE / (float )(trd - trb)));
  }
#line 551
  if (tftarget.tv_usec >= 1000000L) {
#line 553
    tftarget.tv_usec -= 1000000L;
#line 554
    (tftarget.tv_sec) ++;
  }
  {
  {
#line 557
  gettimeofday((struct timeval */* __restrict  */)(& tfdiff), (__timezone_ptr_t )((struct timezone *)((void *)0)));
  }
#line 559
  tfdiff.tv_usec = tftarget.tv_usec - tfdiff.tv_usec;
#line 560
  tfdiff.tv_sec = tftarget.tv_sec - tfdiff.tv_sec;
  }
#line 561
  if (tfdiff.tv_usec < 0L) {
#line 563
    tfdiff.tv_usec += 1000000L;
#line 564
    (tfdiff.tv_sec) --;
  }
#line 567
  if (tfdiff.tv_sec < 0L) {
#line 568
    return;
  } else
#line 567
  if (tfdiff.tv_sec == 0L) {
#line 567
    if (tfdiff.tv_usec <= 0L) {
#line 568
      return;
    }
  }
  {
  {
#line 571
  select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
         (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tfdiff));
  }
  }
#line 572
  return;
}
}
#line 633 "tmndec.c"
static void flushdisplaybuffer(int framenum ) 
{ 


  {
#line 638
  horizontal_size = lines[base_source_format];
#line 638
  coded_picture_width = horizontal_size;
#line 639
  vertical_size = pels[base_source_format];
#line 639
  coded_picture_height = vertical_size;
#line 641
  mb_width = horizontal_size / 16;
#line 642
  mb_height = vertical_size / 16;
#line 643
  chrom_width = coded_picture_width >> 1;
#line 644
  chrom_height = coded_picture_height >> 1;
#line 646
  if (expand) {
#line 646
    if (outtype == 4) {
      {
      {
#line 649
      interpolate_image(buffered_frame[0], exnewframe[0], coded_picture_width, coded_picture_height);
      }
      {
#line 651
      interpolate_image(buffered_frame[1], exnewframe[1], chrom_width, chrom_height);
      }
      {
#line 652
      interpolate_image(buffered_frame[2], exnewframe[2], chrom_width, chrom_height);
      }
      {
#line 654
      storeframe(exnewframe, framenum);
      }
      }
#line 655
      if (save_frames) {
        {
        {
#line 657
        save_frame(exnewframe, framenum, recon_file_ptr);
        }
        }
      }
    } else {
#line 646
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 661
    storeframe(buffered_frame, framenum);
    }
    }
#line 662
    if (save_frames) {
      {
      {
#line 664
      save_frame(buffered_frame, framenum, recon_file_ptr);
      }
      }
    }
  }
#line 667
  return;
}
}
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 89 "/usr/include/string.h"
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 151 "global.h"
void store_one(char *outname , unsigned char **src , int offset , int incr , int height ) ;
#line 166
void dither(unsigned char **src ) ;
#line 77 "store.c"
static void store_yuv(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) ;
#line 79
static void store_yuv_append(char *outname , unsigned char **src , int offset , int incr ,
                             int height ) ;
#line 81
static void store_sif(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) ;
#line 83
static void store_ppm_tga(char *outname , unsigned char **src , int offset , int incr ,
                          int height , int tgaflag ) ;
#line 85
static void store_yuv1(char *name , unsigned char *src , int offset , int incr , int width ,
                       int height , int append ) ;
#line 87
static void putbyte(int c___0 ) ;
#line 88
static void putword(int w ) ;
#line 89
static void conv422to444(unsigned char *src , unsigned char *dst ) ;
#line 90
static void conv420to422(unsigned char *src , unsigned char *dst ) ;
#line 93 "store.c"
static unsigned char obfr[4096]  ;
#line 94 "store.c"
static unsigned char *optr  ;
#line 95 "store.c"
static int outfile  ;
#line 98 "store.c"
void storeframe(unsigned char **src , int frame ) 
{ 
  char outname[32] ;
  void *__cil_tmp4 ;

  {
  {
  {
#line 103
  sprintf((char */* __restrict  */)(outname), (char const   */* __restrict  */)outputname,
          frame, 'f');
  }
  {
#line 104
  store_one(outname, src, 0, coded_picture_width, vertical_size);
  }
  }
#line 105
  return;
}
}
#line 108 "store.c"
void store_one(char *outname , unsigned char **src , int offset , int incr , int height ) 
{ 


  {
  {
#line 112
  if (outtype == 0) {
#line 112
    goto case_0;
  }
#line 115
  if (outtype == 5) {
#line 115
    goto case_5;
  }
#line 118
  if (outtype == 1) {
#line 118
    goto case_1;
  }
#line 121
  if (outtype == 2) {
#line 121
    goto case_2;
  }
#line 124
  if (outtype == 3) {
#line 124
    goto case_3;
  }
#line 128
  if (outtype == 4) {
#line 128
    goto case_4;
  }
#line 139
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 113
  store_yuv(outname, src, offset, incr, height);
  }
  }
#line 114
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 116
  store_yuv_append(outname, src, offset, incr, height);
  }
  }
#line 117
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 119
  store_sif(outname, src, offset, incr, height);
  }
  }
#line 120
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 122
  store_ppm_tga(outname, src, offset, incr, height, 1);
  }
  }
#line 123
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 125
  store_ppm_tga(outname, src, offset, incr, height, 0);
  }
  }
#line 126
  goto switch_break;
  case_4: /* CIL Label */ 
#line 129
  if (enhancement_layer_num == 1) {
    {
    {
#line 130
    dither(src);
    }
    }
  }
#line 131
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 140
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 145 "store.c"
static void store_yuv(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) 
{ 
  int hsize ;
  char tmpname[32] ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 150
  hsize = horizontal_size;
  {
#line 152
  sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.Y",
          outname);
  }
  {
#line 153
  store_yuv1(tmpname, *(src + 0), offset, incr, hsize, height, 0);
  }
#line 155
  offset >>= 1;
#line 156
  incr >>= 1;
#line 157
  hsize >>= 1;
#line 158
  height >>= 1;
  {
#line 160
  sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.U",
          outname);
  }
  {
#line 161
  store_yuv1(tmpname, *(src + 1), offset, incr, hsize, height, 0);
  }
  {
#line 163
  sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.V",
          outname);
  }
  {
#line 164
  store_yuv1(tmpname, *(src + 2), offset, incr, hsize, height, 0);
  }
  }
#line 165
  return;
}
}
#line 168 "store.c"
static void store_yuv_append(char *outname , unsigned char **src , int offset , int incr ,
                             int height ) 
{ 
  int hsize ;

  {
  {
#line 174
  hsize = horizontal_size;
  {
#line 176
  store_yuv1(outname, *(src + 0), offset, incr, hsize, height, 1);
  }
#line 178
  offset >>= 1;
#line 179
  incr >>= 1;
#line 180
  hsize >>= 1;
#line 181
  height >>= 1;
  {
#line 183
  store_yuv1(outname, *(src + 1), offset, incr, hsize, height, 1);
  }
  {
#line 184
  store_yuv1(outname, *(src + 2), offset, incr, hsize, height, 1);
  }
  }
#line 185
  return;
}
}
#line 222
extern int ( /* missing proto */  write)() ;
#line 188 "store.c"
static void store_yuv1(char *name , unsigned char *src , int offset , int incr , int width ,
                       int height , int append ) 
{ 
  int i ;
  int j ;
  unsigned char *p ;
  unsigned char *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 194
  if (append) {
    {
    {
#line 196
    outfile = open((char const   *)name, 1025, 438);
    }
    }
#line 196
    if (outfile == -1) {
      {
      {
#line 198
      sprintf((char */* __restrict  */)(errortext), (char const   */* __restrict  */)"Couldn\'t append to %s\n",
              name);
      }
      {
#line 199
      error(errortext);
      }
      }
    }
  } else {
    {
    {
#line 203
    outfile = open((char const   *)name, 577, 438);
    }
    }
#line 203
    if (outfile == -1) {
      {
      {
#line 205
      sprintf((char */* __restrict  */)(errortext), (char const   */* __restrict  */)"Couldn\'t create %s\n",
              name);
      }
      {
#line 206
      error(errortext);
      }
      }
    }
  }
#line 209
  if (! quiet) {
    {
    {
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"saving %s\n",
            name);
    }
    }
  }
#line 212
  optr = obfr;
#line 214
  i = 0;
  {
  {
#line 214
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i < height)) {
#line 214
      goto while_break;
    }
#line 216
    p = (src + offset) + incr * i;
#line 217
    j = 0;
    {
    {
#line 217
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (j < width)) {
#line 217
        goto while_break___0;
      }
      {
#line 218
      tmp = p;
#line 218
      p ++;
      {
#line 218
      putbyte((int )*tmp);
      }
#line 217
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  if ((unsigned long )optr != (unsigned long )(obfr)) {
    {
    {
#line 222
    write(outfile, obfr, optr - obfr);
    }
    }
  }
  {
  {
#line 224
  close(outfile);
  }
  }
#line 225
  return;
}
}
#line 232 "store.c"
static unsigned char *u422  ;
#line 232 "store.c"
static unsigned char *v422  ;
#line 228 "store.c"
static void store_sif(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) 
{ 
  int i ;
  int j ;
  unsigned char *py ;
  unsigned char *pu ;
  unsigned char *pv ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 234
  if (! u422) {
    {
    {
#line 236
    tmp = malloc((size_t )((coded_picture_width >> 1) * coded_picture_height));
    }
#line 236
    u422 = (unsigned char *)tmp;
    }
#line 236
    if (! u422) {
      {
      {
#line 238
      error((char *)"malloc failed");
      }
      }
    }
    {
    {
#line 239
    tmp___0 = malloc((size_t )((coded_picture_width >> 1) * coded_picture_height));
    }
#line 239
    v422 = (unsigned char *)tmp___0;
    }
#line 239
    if (! v422) {
      {
      {
#line 241
      error((char *)"malloc failed");
      }
      }
    }
  }
  {
  {
#line 243
  conv420to422(*(src + 1), u422);
  }
  {
#line 244
  conv420to422(*(src + 2), v422);
  }
  {
#line 246
  strcat((char */* __restrict  */)outname, (char const   */* __restrict  */)".SIF");
  }
  }
#line 248
  if (! quiet) {
    {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"saving %s\n",
            outname);
    }
    }
  }
  {
  {
#line 251
  outfile = open((char const   *)outname, 577, 438);
  }
  }
#line 251
  if (outfile == -1) {
    {
    {
#line 253
    sprintf((char */* __restrict  */)(errortext), (char const   */* __restrict  */)"Couldn\'t create %s\n",
            outname);
    }
    {
#line 254
    error(errortext);
    }
    }
  }
#line 256
  optr = obfr;
#line 258
  i = 0;
  {
  {
#line 258
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < height)) {
#line 258
      goto while_break;
    }
#line 260
    py = (*(src + 0) + offset) + incr * i;
#line 261
    pu = (u422 + (offset >> 1)) + (incr >> 1) * i;
#line 262
    pv = (v422 + (offset >> 1)) + (incr >> 1) * i;
#line 264
    j = 0;
    {
    {
#line 264
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 264
      if (! (j < horizontal_size)) {
#line 264
        goto while_break___0;
      }
      {
#line 266
      tmp___1 = pu;
#line 266
      pu ++;
      {
#line 266
      putbyte((int )*tmp___1);
      }
#line 267
      tmp___2 = py;
#line 267
      py ++;
      {
#line 267
      putbyte((int )*tmp___2);
      }
#line 268
      tmp___3 = pv;
#line 268
      pv ++;
      {
#line 268
      putbyte((int )*tmp___3);
      }
#line 269
      tmp___4 = py;
#line 269
      py ++;
      {
#line 269
      putbyte((int )*tmp___4);
      }
#line 264
      j += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  if ((unsigned long )optr != (unsigned long )(obfr)) {
    {
    {
#line 274
    write(outfile, obfr, optr - obfr);
    }
    }
  }
  {
  {
#line 276
  close(outfile);
  }
  }
#line 277
  return;
}
}
#line 287 "store.c"
static unsigned char tga24[14]  = 
#line 287
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)24,      (unsigned char)32};
#line 289 "store.c"
static unsigned char *u422___0  ;
#line 289 "store.c"
static unsigned char *v422___0  ;
#line 289 "store.c"
static unsigned char *u444  ;
#line 289 "store.c"
static unsigned char *v444  ;
#line 280 "store.c"
static void store_ppm_tga(char *outname , unsigned char **src , int offset , int incr ,
                          int height , int tgaflag ) 
{ 
  int i ;
  int j ;
  int y ;
  int u ;
  int v ;
  int r ;
  int g ;
  int b ;
  int crv ;
  int cbu ;
  int cgu ;
  int cgv ;
  unsigned char *py ;
  unsigned char *pu ;
  unsigned char *pv ;
  char header[32] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 291
  if (! u444) {
    {
    {
#line 293
    tmp = malloc((size_t )((coded_picture_width >> 1) * coded_picture_height));
    }
#line 293
    u422___0 = (unsigned char *)tmp;
    }
#line 293
    if (! u422___0) {
      {
      {
#line 295
      error((char *)"malloc failed");
      }
      }
    }
    {
    {
#line 296
    tmp___0 = malloc((size_t )((coded_picture_width >> 1) * coded_picture_height));
    }
#line 296
    v422___0 = (unsigned char *)tmp___0;
    }
#line 296
    if (! v422___0) {
      {
      {
#line 298
      error((char *)"malloc failed");
      }
      }
    }
    {
    {
#line 300
    tmp___1 = malloc((size_t )(coded_picture_width * coded_picture_height));
    }
#line 300
    u444 = (unsigned char *)tmp___1;
    }
#line 300
    if (! u444) {
      {
      {
#line 302
      error((char *)"malloc failed");
      }
      }
    }
    {
    {
#line 304
    tmp___2 = malloc((size_t )(coded_picture_width * coded_picture_height));
    }
#line 304
    v444 = (unsigned char *)tmp___2;
    }
#line 304
    if (! v444) {
      {
      {
#line 306
      error((char *)"malloc failed");
      }
      }
    }
  }
  {
  {
#line 308
  conv420to422(*(src + 1), u422___0);
  }
  {
#line 309
  conv420to422(*(src + 2), v422___0);
  }
  {
#line 310
  conv422to444(u422___0, u444);
  }
  {
#line 311
  conv422to444(v422___0, v444);
  }
  }
#line 313
  if (tgaflag) {
#line 313
    tmp___3 = ".tga";
  } else {
#line 313
    tmp___3 = ".ppm";
  }
  {
  {
#line 313
  strcat((char */* __restrict  */)outname, (char const   */* __restrict  */)tmp___3);
  }
  }
#line 315
  if (! quiet) {
    {
    {
#line 316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"saving %s\n",
            outname);
    }
    }
  }
  {
  {
#line 318
  outfile = open((char const   *)outname, 577, 438);
  }
  }
#line 318
  if (outfile == -1) {
    {
    {
#line 320
    sprintf((char */* __restrict  */)(errortext), (char const   */* __restrict  */)"Couldn\'t create %s\n",
            outname);
    }
    {
#line 321
    error(errortext);
    }
    }
  }
#line 323
  optr = obfr;
#line 325
  if (tgaflag) {
#line 328
    i = 0;
    {
    {
#line 328
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 328
      if (! (i < 12)) {
#line 328
        goto while_break;
      }
      {
      {
#line 329
      putbyte((int )tga24[i]);
      }
#line 328
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 331
    putword(horizontal_size);
    }
    {
#line 332
    putword(height);
    }
    {
#line 333
    putbyte((int )tga24[12]);
    }
    {
#line 334
    putbyte((int )tga24[13]);
    }
    }
  } else {
    {
    {
#line 338
    sprintf((char */* __restrict  */)(header), (char const   */* __restrict  */)"P6\n%d %d\n255\n",
            horizontal_size, height);
    }
#line 340
    i = 0;
    }
    {
    {
#line 340
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 340
      if (! ((int )header[i] != 0)) {
#line 340
        goto while_break___0;
      }
      {
      {
#line 341
      putbyte((int )header[i]);
      }
#line 340
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 345
  crv = convmat[matrix_coefficients][0];
#line 346
  cbu = convmat[matrix_coefficients][1];
#line 347
  cgu = convmat[matrix_coefficients][2];
#line 348
  cgv = convmat[matrix_coefficients][3];
#line 350
  i = 0;
  {
  {
#line 350
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 350
    if (! (i < height)) {
#line 350
      goto while_break___1;
    }
#line 352
    py = (*(src + 0) + offset) + incr * i;
#line 353
    pu = (u444 + offset) + incr * i;
#line 354
    pv = (v444 + offset) + incr * i;
#line 356
    j = 0;
    {
    {
#line 356
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 356
      if (! (j < horizontal_size)) {
#line 356
        goto while_break___2;
      }
#line 358
      tmp___4 = pu;
#line 358
      pu ++;
#line 358
      u = (int )*tmp___4 - 128;
#line 359
      tmp___5 = pv;
#line 359
      pv ++;
#line 359
      v = (int )*tmp___5 - 128;
#line 360
      tmp___6 = py;
#line 360
      py ++;
#line 360
      y = 76309 * ((int )*tmp___6 - 16);
#line 361
      r = (int )*(clp + (((y + crv * v) + 32768) >> 16));
#line 362
      g = (int )*(clp + ((((y - cgu * u) - cgv * v) + 32768) >> 16));
#line 363
      b = (int )*(clp + (((y + cbu * u) + 32786) >> 16));
#line 365
      if (tgaflag) {
        {
        {
#line 367
        putbyte(b);
        }
        {
#line 368
        putbyte(g);
        }
        {
#line 369
        putbyte(r);
        }
        }
      } else {
        {
        {
#line 372
        putbyte(r);
        }
        {
#line 373
        putbyte(g);
        }
        {
#line 374
        putbyte(b);
        }
        }
      }
#line 356
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 350
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 379
  if ((unsigned long )optr != (unsigned long )(obfr)) {
    {
    {
#line 380
    write(outfile, obfr, optr - obfr);
    }
    }
  }
  {
  {
#line 382
  close(outfile);
  }
  }
#line 383
  return;
}
}
#line 385 "store.c"
static void putbyte(int c___0 ) 
{ 
  unsigned char *tmp ;

  {
#line 387
  tmp = optr;
#line 387
  optr ++;
#line 387
  *tmp = (unsigned char )c___0;
#line 389
  if ((unsigned long )optr == (unsigned long )(obfr + 4096)) {
    {
    {
#line 391
    write(outfile, obfr, 4096);
    }
#line 392
    optr = obfr;
    }
  }
#line 394
  return;
}
}
#line 396 "store.c"
static void putword(int w ) 
{ 


  {
  {
  {
#line 398
  putbyte(w);
  }
  {
#line 399
  putbyte(w >> 8);
  }
  }
#line 400
  return;
}
}
#line 403 "store.c"
static void conv422to444(unsigned char *src , unsigned char *dst ) 
{ 
  int i ;
  int i2 ;
  int w ;
  int j ;
  int im3 ;
  int im2 ;
  int im1 ;
  int ip1 ;
  int ip2 ;
  int ip3 ;

  {
#line 407
  w = coded_picture_width >> 1;
#line 409
  j = 0;
  {
  {
#line 409
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 409
    if (! (j < coded_picture_height)) {
#line 409
      goto while_break;
    }
#line 411
    i = 0;
    {
    {
#line 411
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 411
      if (! (i < w)) {
#line 411
        goto while_break___0;
      }
#line 414
      i2 = i << 1;
#line 415
      if (i < 3) {
#line 415
        im3 = 0;
      } else {
#line 415
        im3 = i - 3;
      }
#line 416
      if (i < 2) {
#line 416
        im2 = 0;
      } else {
#line 416
        im2 = i - 2;
      }
#line 417
      if (i < 1) {
#line 417
        im1 = 0;
      } else {
#line 417
        im1 = i - 1;
      }
#line 418
      if (i < w - 1) {
#line 418
        ip1 = i + 1;
      } else {
#line 418
        ip1 = w - 1;
      }
#line 419
      if (i < w - 2) {
#line 419
        ip2 = i + 2;
      } else {
#line 419
        ip2 = w - 1;
      }
#line 420
      if (i < w - 3) {
#line 420
        ip3 = i + 3;
      } else {
#line 420
        ip3 = w - 1;
      }
#line 423
      *(dst + i2) = *(clp + (((((((5 * (int )*(src + im3) - 21 * (int )*(src + im2)) + 70 * (int )*(src + im1)) + 228 * (int )*(src + i)) - 37 * (int )*(src + ip1)) + 11 * (int )*(src + ip2)) + 128) >> 8));
#line 430
      *(dst + (i2 + 1)) = *(clp + (((((((5 * (int )*(src + ip3) - 21 * (int )*(src + ip2)) + 70 * (int )*(src + ip1)) + 228 * (int )*(src + i)) - 37 * (int )*(src + im1)) + 11 * (int )*(src + im2)) + 128) >> 8));
#line 411
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    src += w;
#line 438
    dst += coded_picture_width;
#line 409
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  return;
}
}
#line 443 "store.c"
static void conv420to422(unsigned char *src , unsigned char *dst ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int j2 ;
  int jm3 ;
  int jm2 ;
  int jm1 ;
  int jp1 ;
  int jp2 ;
  int jp3 ;

  {
#line 448
  w = coded_picture_width >> 1;
#line 449
  h = coded_picture_height >> 1;
#line 452
  i = 0;
  {
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < w)) {
#line 452
      goto while_break;
    }
#line 454
    j = 0;
    {
    {
#line 454
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 454
      if (! (j < h)) {
#line 454
        goto while_break___0;
      }
#line 456
      j2 = j << 1;
#line 457
      if (j < 3) {
#line 457
        jm3 = 0;
      } else {
#line 457
        jm3 = j - 3;
      }
#line 458
      if (j < 2) {
#line 458
        jm2 = 0;
      } else {
#line 458
        jm2 = j - 2;
      }
#line 459
      if (j < 1) {
#line 459
        jm1 = 0;
      } else {
#line 459
        jm1 = j - 1;
      }
#line 460
      if (j < h - 1) {
#line 460
        jp1 = j + 1;
      } else {
#line 460
        jp1 = h - 1;
      }
#line 461
      if (j < h - 2) {
#line 461
        jp2 = j + 2;
      } else {
#line 461
        jp2 = h - 1;
      }
#line 462
      if (j < h - 3) {
#line 462
        jp3 = j + 3;
      } else {
#line 462
        jp3 = h - 1;
      }
#line 466
      *(dst + w * j2) = *(clp + (((((((3 * (int )*(src + w * jm3) - 16 * (int )*(src + w * jm2)) + 67 * (int )*(src + w * jm1)) + 227 * (int )*(src + w * j)) - 32 * (int )*(src + w * jp1)) + 7 * (int )*(src + w * jp2)) + 128) >> 8));
#line 473
      *(dst + w * (j2 + 1)) = *(clp + (((((((3 * (int )*(src + w * jp3) - 16 * (int )*(src + w * jp2)) + 67 * (int )*(src + w * jp1)) + 227 * (int )*(src + w * j)) - 32 * (int )*(src + w * jm1)) + 7 * (int )*(src + w * jm2)) + 128) >> 8));
#line 454
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 480
    src ++;
#line 481
    dst ++;
#line 452
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  return;
}
}
#line 487 "store.c"
void save_frame(unsigned char **src , int framenum , FILE *file ) 
{ 
  unsigned char *lum ;
  unsigned char *Cr ;
  unsigned char *Cb ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 493
  lum = *(src + 0);
#line 494
  Cb = *(src + 1);
#line 495
  Cr = *(src + 2);
  {
#line 497
  tmp = fwrite((void const   */* __restrict  */)lum, (size_t )sizeof(unsigned char ),
               (size_t )(coded_picture_height * coded_picture_width), (FILE */* __restrict  */)file);
  }
  }
#line 497
  if ((int )tmp != coded_picture_height * coded_picture_width) {
    {
    {
#line 500
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Error occured when writing reconstructed data\n");
    }
    {
#line 501
    exit(-1);
    }
    }
  }
  {
  {
#line 503
  tmp___0 = fwrite((void const   */* __restrict  */)Cb, (size_t )sizeof(unsigned char ),
                   (size_t )((coded_picture_height * coded_picture_width) / 4), (FILE */* __restrict  */)file);
  }
  }
#line 503
  if ((int )tmp___0 != (coded_picture_height * coded_picture_width) / 4) {
    {
    {
#line 506
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Error occured when writing reconstructed data\n");
    }
    {
#line 507
    exit(-1);
    }
    }
  }
  {
  {
#line 509
  tmp___1 = fwrite((void const   */* __restrict  */)Cr, (size_t )sizeof(unsigned char ),
                   (size_t )((coded_picture_height * coded_picture_width) / 4), (FILE */* __restrict  */)file);
  }
  }
#line 509
  if ((int )tmp___1 != (coded_picture_height * coded_picture_width) / 4) {
    {
    {
#line 512
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Error occured when writing reconstructed data\n");
    }
    {
#line 513
    exit(-1);
    }
    }
  }
#line 515
  return;
}
}
#line 83 "global.h"
unsigned int showbits(int n ) ;
#line 86
unsigned int getbits(int n ) ;
#line 155
int decode_a_symbol(int *cumul_freq ) ;
#line 156
void decoder_reset(void) ;
#line 76 "sac.c"
void bit_out_psc_layer(void) ;
#line 97 "sac.c"
static long low  ;
#line 97 "sac.c"
static long high  ;
#line 97 "sac.c"
static long code_value  ;
#line 97 "sac.c"
static long bit  ;
#line 97 "sac.c"
static long length  ;
#line 97 "sac.c"
static long sacindex  ;
#line 97 "sac.c"
static long cum  ;
#line 97 "sac.c"
static long zerorun  =    0L;
#line 99 "sac.c"
int decode_a_symbol(int *cumul_freq ) 
{ 


  {
#line 102
  length = (high - low) + 1L;
#line 103
  cum = (-1L + ((code_value - low) + 1L) * (long )*(cumul_freq + 0)) / length;
#line 104
  sacindex = 1L;
  {
  {
#line 104
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 104
    if (! ((long )*(cumul_freq + sacindex) > cum)) {
#line 104
      goto while_break;
    }
#line 104
    sacindex ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  high = (low - 1L) + (length * (long )*(cumul_freq + (sacindex - 1L))) / (long )*(cumul_freq + 0);
#line 106
  low += (length * (long )*(cumul_freq + sacindex)) / (long )*(cumul_freq + 0);
  {
  {
#line 108
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! (high < 32768L)) {
#line 111
      if (low >= 32768L) {
#line 113
        code_value -= 32768L;
#line 114
        low -= 32768L;
#line 115
        high -= 32768L;
      } else
#line 116
      if (low >= 16384L) {
#line 116
        if (high < 49152L) {
#line 118
          code_value -= 16384L;
#line 119
          low -= 16384L;
#line 120
          high -= 16384L;
        } else {
#line 123
          goto while_break___0;
        }
      } else {
#line 123
        goto while_break___0;
      }
    }
    {
#line 126
    low *= 2L;
#line 127
    high = 2L * high + 1L;
    {
#line 128
    bit_out_psc_layer();
    }
#line 129
    code_value = 2L * code_value + bit;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 132
  return ((int )(sacindex - 1L));
}
}
#line 152 "sac.c"
void decoder_reset(void) 
{ 
  int i ;
  char *__cil_tmp2 ;

  {
#line 155
  zerorun = 0L;
#line 156
  code_value = 0L;
#line 157
  low = 0L;
#line 158
  high = 65535L;
#line 159
  i = 1;
  {
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i <= 16)) {
#line 159
      goto while_break;
    }
    {
    {
#line 161
    bit_out_psc_layer();
    }
#line 162
    code_value = 2L * code_value + bit;
#line 159
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (trace) {
    {
    {
#line 165
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nArithmetic Decoder Reset \n");
    }
    }
  }
#line 166
  return;
}
}
#line 188 "sac.c"
void bit_out_psc_layer(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 190
  tmp___1 = showbits(17);
  }
  }
#line 190
  if (tmp___1 != 1U) {
    {
    {
#line 194
    tmp = getbits(1);
    }
#line 194
    bit = (long )tmp;
    }
#line 196
    if (zerorun > 13L) {
#line 198
      if (! bit) {
#line 200
        if (trace) {
          {
          {
#line 201
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"PSC/GBSC, Header Data, or Encoded Stream Error \n");
          }
          }
        }
#line 202
        zerorun = 1L;
      } else {
#line 205
        if (trace) {
          {
          {
#line 206
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"Removing Startcode Emulation Prevention bit \n");
          }
          }
        }
        {
        {
#line 207
        tmp___0 = getbits(1);
        }
#line 207
        bit = (long )tmp___0;
#line 208
        zerorun = (long )(! bit);
        }
      }
    } else
#line 213
    if (! bit) {
#line 214
      zerorun ++;
    } else {
#line 216
      zerorun = 0L;
    }
  } else {
#line 223
    bit = 0L;
#line 224
    if (trace) {
      {
      {
#line 225
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"Startcode Found:Finishing Arithmetic Decoding using \'Garbage bits\'\n");
      }
      }
    }
  }
#line 232
  return;
}
}
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 159 "global.h"
int get_reference_picture(void) ;
#line 160
void store_picture(int quality ) ;
#line 55 "ring_buf.c"
int get_reference_gob(void) ;
#line 56
void store_gob(int quality ) ;
#line 80 "ring_buf.c"
int get_reference_picture(void) 
{ 
  int i ;
  int diff_tr ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 84
  if (! TRPI) {
#line 86
    if (! quiet) {
      {
      {
#line 87
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getrefpic: TR=%d - I-frame\n",
              temp_ref);
      }
      }
    }
#line 88
    return (0);
  }
#line 90
  i = ring_pointer;
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i != (ring_pointer + 1) % 8)) {
#line 90
      goto while_break;
    }
#line 93
    diff_tr = temporal_reference_for_prediction - ring_temporal_reference[i];
#line 94
    if (diff_tr > 128) {
#line 94
      diff_tr -= 256;
    }
#line 95
    if (diff_tr < -128) {
#line 95
      diff_tr += 256;
    }
#line 96
    if (diff_tr >= 0) {
#line 96
      goto while_break;
    }
#line 90
    i = ((i + 8) - 1) % 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (ring_temporal_reference[ring_pointer] == temp_ref) {
#line 98
    if (ring_quality[i] + diff_tr >= ring_quality[ring_pointer]) {
#line 101
      return (-1);
    }
  }
#line 103
  if (ring_lum[i]) {
    {
    {
#line 105
    memcpy((void */* __restrict  */)prev_I_P_frame[0], (void const   */* __restrict  */)ring_lum[i],
           (size_t )(coded_picture_height * coded_picture_width));
    }
    {
#line 106
    memcpy((void */* __restrict  */)prev_I_P_frame[1], (void const   */* __restrict  */)ring_Cr[i],
           (size_t )((coded_picture_height * coded_picture_width) / 4));
    }
    {
#line 107
    memcpy((void */* __restrict  */)prev_I_P_frame[2], (void const   */* __restrict  */)ring_Cb[i],
           (size_t )((coded_picture_height * coded_picture_width) / 4));
    }
    }
  }
#line 109
  if (diff_tr) {
#line 109
    if (! quiet) {
      {
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getrefpic: TR=%d, TRP=%d, available %d, q=%d+%d\n",
              temp_ref, temporal_reference_for_prediction, ring_temporal_reference[i],
              ring_quality[i], diff_tr);
      }
      }
    }
  }
#line 113
  return (ring_quality[i] + diff_tr);
}
}
#line 130 "ring_buf.c"
void store_picture(int quality ) 
{ 


  {
#line 132
  ring_pointer = (ring_pointer + 1) % 8;
#line 133
  if (! ring_lum[ring_pointer]) {
    {
    {
#line 134
    ring_lum[ring_pointer] = malloc((size_t )(coded_picture_height * coded_picture_width));
    }
    {
#line 135
    ring_Cr[ring_pointer] = malloc((size_t )((coded_picture_height * coded_picture_width) / 4));
    }
    {
#line 136
    ring_Cb[ring_pointer] = malloc((size_t )((coded_picture_height * coded_picture_width) / 4));
    }
    }
  }
  {
  {
#line 138
  memcpy((void */* __restrict  */)ring_lum[ring_pointer], (void const   */* __restrict  */)current_frame[0],
         (size_t )(coded_picture_height * coded_picture_width));
  }
  {
#line 139
  memcpy((void */* __restrict  */)ring_Cr[ring_pointer], (void const   */* __restrict  */)current_frame[1],
         (size_t )((coded_picture_height * coded_picture_width) / 4));
  }
  {
#line 140
  memcpy((void */* __restrict  */)ring_Cb[ring_pointer], (void const   */* __restrict  */)current_frame[2],
         (size_t )((coded_picture_height * coded_picture_width) / 4));
  }
#line 141
  ring_temporal_reference[ring_pointer] = temp_ref;
#line 142
  ring_quality[ring_pointer] = quality;
  }
#line 143
  return;
}
}
#line 162 "ring_buf.c"
int get_reference_gob(void) 
{ 


  {
#line 164
  return (0);
}
}
#line 180 "ring_buf.c"
void store_gob(int quality ) 
{ 


  {
#line 182
  return;
}
}
#line 748 "/usr/include/stdlib.h"
extern int abs(int __x )  __attribute__((__const__)) ;
#line 143 "global.h"
void reconstruct(int bx , int by , int P , int bdx , int bdy , int MODB , int newgob___0 ) ;
#line 144
void reconstruct_true_B(int bx , int by , int true_B_prediction_type ) ;
#line 145
void reconstruct_ei_ep(int bx , int by , int ei_ep_prediction_type ) ;
#line 69 "recon.c"
static void recon_comp(unsigned char *src , unsigned char *dst , int lx , int lx2 ,
                       int w , int h , int x , int y , int dx , int dy , int chroma ) ;
#line 71
static void recon_comp_obmc(unsigned char *src , unsigned char *dst , int lx , int lx2 ,
                            int comp , int w , int h , int x , int y , int newgob___0 ) ;
#line 72
static void rec(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 73
static void recon_bidir_average(int bx , int by ) ;
#line 74
static void recc(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 75
static void reco(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                 int xa , int xb , int ya , int yb ) ;
#line 76
static void rech(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 77
static void rechc(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 78
static void recho(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                  int xa , int xb , int ya , int yb ) ;
#line 79
static void recv(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 80
static void recvc(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 81
static void recvo(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                  int xa , int xb , int ya , int yb ) ;
#line 82
static void rec4(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 83
static void rec4c(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) ;
#line 84
static void rec4o(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                  int xa , int xb , int ya , int yb ) ;
#line 86 "recon.c"
void reconstruct(int bx , int by , int P , int bdx , int bdy , int MODB , int newgob___0 ) 
{ 
  int w ;
  int h ;
  int lx ;
  int lx2 ;
  int dx ;
  int dy ;
  int xp ;
  int yp ;
  int comp ;
  int sum ;
  int x ;
  int y ;
  int mode ;
  int xvec ;
  int yvec ;
  unsigned char *src[3] ;
  int store_rtype ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp43 ;

  {
#line 93
  x = bx / 16 + 1;
#line 94
  y = by / 16 + 1;
#line 95
  lx = coded_picture_width;
#line 97
  if (mv_outside_frame) {
#line 99
    lx2 = coded_picture_width + 64;
#line 100
    src[0] = edgeframe[0];
#line 101
    src[1] = edgeframe[1];
#line 102
    src[2] = edgeframe[2];
  } else {
#line 105
    lx2 = coded_picture_width;
#line 106
    src[0] = prev_I_P_frame[0];
#line 107
    src[1] = prev_I_P_frame[1];
#line 108
    src[2] = prev_I_P_frame[2];
  }
#line 111
  mode = modemap[y][x];
#line 113
  if (P) {
#line 116
    if (use_4mv) {
#line 118
      w = 8;
#line 119
      h = 8;
#line 122
      if (overlapping_MC) {
#line 124
        comp = 0;
        {
        {
#line 124
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 124
          if (! (comp < 4)) {
#line 124
            goto while_break;
          }
          {
#line 126
          xp = bx + ((comp & 1) << 3);
#line 127
          yp = by + ((comp & 2) << 2);
          {
#line 128
          recon_comp_obmc(src[0], current_frame[0], lx, lx2, comp, w, h, xp, yp, newgob___0);
          }
#line 124
          comp ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      } else
#line 132
      if (mode == 2) {
#line 132
        goto _L;
      } else
#line 132
      if (mode == 5) {
        _L: /* CIL Label */ 
#line 134
        comp = 0;
        {
        {
#line 134
        while (1) {
          while_continue___3: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 134
          if (! (comp < 4)) {
#line 134
            goto while_break___0;
          }
          {
#line 136
          dx = MV[0][comp + 1][y][x];
#line 137
          dy = MV[1][comp + 1][y][x];
#line 139
          xp = bx + ((comp & 1) << 3);
#line 140
          yp = by + ((comp & 2) << 2);
          {
#line 141
          recon_comp(src[0], current_frame[0], lx, lx2, w, h, xp, yp, dx, dy, 0);
          }
#line 134
          comp ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 145
        dx = MV[0][0][y][x];
#line 146
        dy = MV[1][0][y][x];
        {
#line 147
        recon_comp(src[0], current_frame[0], lx, lx2, w << 1, h << 1, bx, by, dx,
                   dy, 0);
        }
        }
      }
#line 151
      if (mode == 2) {
#line 151
        goto _L___0;
      } else
#line 151
      if (mode == 5) {
        _L___0: /* CIL Label */ 
#line 153
        sum = ((MV[0][1][y][x] + MV[0][2][y][x]) + MV[0][3][y][x]) + MV[0][4][y][x];
#line 154
        if (sum < 0) {
#line 154
          tmp = -1;
        } else {
#line 154
          tmp = 1;
        }
        {
        {
#line 154
        tmp___0 = abs(sum);
        }
        {
#line 154
        tmp___1 = abs(sum);
        }
#line 154
        dx = tmp * (roundtab[tmp___0 % 16] + (tmp___1 / 16) * 2);
#line 156
        sum = ((MV[1][1][y][x] + MV[1][2][y][x]) + MV[1][3][y][x]) + MV[1][4][y][x];
        }
#line 157
        if (sum < 0) {
#line 157
          tmp___2 = -1;
        } else {
#line 157
          tmp___2 = 1;
        }
        {
        {
#line 157
        tmp___3 = abs(sum);
        }
        {
#line 157
        tmp___4 = abs(sum);
        }
#line 157
        dy = tmp___2 * (roundtab[tmp___3 % 16] + (tmp___4 / 16) * 2);
        }
      } else {
#line 161
        dx = MV[0][0][y][x];
#line 162
        dy = MV[1][0][y][x];
#line 164
        if (dx % 4 == 0) {
#line 164
          dx >>= 1;
        } else {
#line 164
          dx = (dx >> 1) | 1;
        }
#line 165
        if (dy % 4 == 0) {
#line 165
          dy >>= 1;
        } else {
#line 165
          dy = (dy >> 1) | 1;
        }
      }
      {
#line 167
      lx >>= 1;
#line 168
      bx >>= 1;
#line 169
      lx2 >>= 1;
#line 170
      by >>= 1;
      {
#line 172
      recon_comp(src[1], current_frame[1], lx, lx2, w, h, bx, by, dx, dy, 1);
      }
      {
#line 173
      recon_comp(src[2], current_frame[2], lx, lx2, w, h, bx, by, dx, dy, 2);
      }
      }
    } else {
      {
#line 177
      w = 16;
#line 178
      h = 16;
#line 179
      dx = MV[0][0][y][x];
#line 180
      dy = MV[1][0][y][x];
      {
#line 183
      recon_comp(src[0], current_frame[0], lx, lx2, w, h, bx, by, dx, dy, 0);
      }
#line 185
      lx >>= 1;
#line 186
      w >>= 1;
#line 187
      bx >>= 1;
#line 188
      lx2 >>= 1;
#line 189
      h >>= 1;
#line 190
      by >>= 1;
      }
#line 192
      if (dx % 4 == 0) {
#line 192
        dx >>= 1;
      } else {
#line 192
        dx = (dx >> 1) | 1;
      }
#line 193
      if (dy % 4 == 0) {
#line 193
        dy >>= 1;
      } else {
#line 193
        dy = (dy >> 1) | 1;
      }
      {
      {
#line 196
      recon_comp(src[1], current_frame[1], lx, lx2, w, h, bx, by, dx, dy, 1);
      }
      {
#line 197
      recon_comp(src[2], current_frame[2], lx, lx2, w, h, bx, by, dx, dy, 2);
      }
      }
    }
  } else {
#line 201
    store_rtype = rtype;
#line 202
    rtype = 0;
#line 204
    if (pb_frame == 2) {
#line 204
      if (MODB == 14) {
#line 204
        goto _L___6;
      } else
#line 204
      if (MODB == 6) {
        _L___6: /* CIL Label */ 
        {
#line 206
        w = 16;
#line 207
        h = 16;
#line 208
        dx = bdx;
#line 209
        dy = bdy;
        {
#line 212
        recon_comp(src[0], bframe[0], lx, lx2, w, h, bx, by, dx, dy, 0);
        }
#line 214
        lx >>= 1;
#line 215
        w >>= 1;
#line 216
        bx >>= 1;
#line 217
        lx2 >>= 1;
#line 218
        h >>= 1;
#line 219
        by >>= 1;
        }
#line 221
        if (dx % 4 == 0) {
#line 221
          dx >>= 1;
        } else {
#line 221
          dx = (dx >> 1) | 1;
        }
#line 222
        if (dy % 4 == 0) {
#line 222
          dy >>= 1;
        } else {
#line 222
          dy = (dy >> 1) | 1;
        }
        {
        {
#line 225
        recon_comp(src[1], bframe[1], lx, lx2, w, h, bx, by, dx, dy, 1);
        }
        {
#line 226
        recon_comp(src[2], bframe[2], lx, lx2, w, h, bx, by, dx, dy, 2);
        }
        }
      } else {
#line 204
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 227
    if (pb_frame == 2) {
#line 227
      if (MODB == 31) {
#line 227
        goto _L___4;
      } else
#line 227
      if (MODB == 30) {
        _L___4: /* CIL Label */ 
        {
#line 229
        lx2 = coded_picture_width;
#line 230
        src[0] = prev_I_P_frame[0];
#line 231
        src[1] = prev_I_P_frame[1];
#line 232
        src[2] = prev_I_P_frame[2];
#line 234
        w = 16;
#line 235
        h = 16;
        {
#line 238
        recon_comp(current_frame[0], bframe[0], lx, lx2, w, h, bx, by, 0, 0, 0);
        }
#line 240
        lx >>= 1;
#line 241
        w >>= 1;
#line 242
        bx >>= 1;
#line 243
        lx2 >>= 1;
#line 244
        h >>= 1;
#line 245
        by >>= 1;
        {
#line 248
        recon_comp(current_frame[1], bframe[1], lx, lx2, w, h, bx, by, 0, 0, 1);
        }
        {
#line 249
        recon_comp(current_frame[2], bframe[2], lx, lx2, w, h, bx, by, 0, 0, 2);
        }
        }
      } else {
#line 227
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 253
      if (pb_frame == 2) {
#line 255
        bdx = 0;
#line 256
        bdy = 0;
      }
#line 258
      if (use_4mv) {
#line 258
        if (mode == 2) {
#line 258
          goto _L___2;
        } else
#line 258
        if (mode == 5) {
          _L___2: /* CIL Label */ 
#line 260
          w = 8;
#line 261
          h = 8;
#line 263
          yvec = 0;
#line 263
          xvec = yvec;
#line 264
          comp = 0;
          {
          {
#line 264
          while (1) {
            while_continue___4: /* CIL Label */ ;
            while_continue___1: /* CIL Label */ ;
#line 264
            if (! (comp < 4)) {
#line 264
              goto while_break___1;
            }
            {
#line 266
            dx = (trb * MV[0][comp + 1][y][x]) / trd + bdx;
#line 266
            xvec += dx;
#line 267
            dy = (trb * MV[1][comp + 1][y][x]) / trd + bdy;
#line 267
            yvec += dy;
#line 268
            xp = bx + ((comp & 1) << 3);
#line 269
            yp = by + ((comp & 2) << 2);
            {
#line 270
            recon_comp(src[0], bframe[0], lx, lx2, w, h, xp, yp, dx, dy, 0);
            }
#line 264
            comp ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 274
          if (xvec < 0) {
#line 274
            tmp___5 = -1;
          } else {
#line 274
            tmp___5 = 1;
          }
          {
          {
#line 274
          tmp___6 = abs(xvec);
          }
          {
#line 274
          tmp___7 = abs(xvec);
          }
#line 274
          dx = tmp___5 * (roundtab[tmp___6 % 16] + (tmp___7 / 16) * 2);
          }
#line 275
          if (yvec < 0) {
#line 275
            tmp___8 = -1;
          } else {
#line 275
            tmp___8 = 1;
          }
          {
          {
#line 275
          tmp___9 = abs(yvec);
          }
          {
#line 275
          tmp___10 = abs(yvec);
          }
#line 275
          dy = tmp___8 * (roundtab[tmp___9 % 16] + (tmp___10 / 16) * 2);
#line 277
          lx >>= 1;
#line 278
          bx >>= 1;
#line 279
          lx2 >>= 1;
#line 280
          by >>= 1;
          {
#line 282
          recon_comp(src[1], bframe[1], lx, lx2, w, h, bx, by, dx, dy, 1);
          }
          {
#line 283
          recon_comp(src[2], bframe[2], lx, lx2, w, h, bx, by, dx, dy, 2);
          }
          }
        } else {
#line 258
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 287
        w = 16;
#line 288
        h = 16;
#line 290
        dx = (trb * MV[0][0][y][x]) / trd + bdx;
#line 291
        dy = (trb * MV[1][0][y][x]) / trd + bdy;
        {
#line 293
        recon_comp(src[0], bframe[0], lx, lx2, w, h, bx, by, dx, dy, 0);
        }
#line 295
        lx >>= 1;
#line 296
        w >>= 1;
#line 297
        bx >>= 1;
#line 298
        lx2 >>= 1;
#line 299
        h >>= 1;
#line 300
        by >>= 1;
#line 302
        xvec = 4 * dx;
#line 303
        yvec = 4 * dy;
        }
#line 306
        if (xvec < 0) {
#line 306
          tmp___11 = -1;
        } else {
#line 306
          tmp___11 = 1;
        }
        {
        {
#line 306
        tmp___12 = abs(xvec);
        }
        {
#line 306
        tmp___13 = abs(xvec);
        }
#line 306
        dx = tmp___11 * (roundtab[tmp___12 % 16] + (tmp___13 / 16) * 2);
        }
#line 307
        if (yvec < 0) {
#line 307
          tmp___14 = -1;
        } else {
#line 307
          tmp___14 = 1;
        }
        {
        {
#line 307
        tmp___15 = abs(yvec);
        }
        {
#line 307
        tmp___16 = abs(yvec);
        }
#line 307
        dy = tmp___14 * (roundtab[tmp___15 % 16] + (tmp___16 / 16) * 2);
        {
#line 310
        recon_comp(src[1], bframe[1], lx, lx2, w, h, bx, by, dx, dy, 1);
        }
        {
#line 311
        recon_comp(src[2], bframe[2], lx, lx2, w, h, bx, by, dx, dy, 2);
        }
        }
      }
    }
#line 314
    rtype = store_rtype;
  }
#line 316
  return;
}
}
#line 331 "recon.c"
void reconstruct_true_B(int bx , int by , int true_B_prediction_type ) 
{ 
  int w ;
  int h ;
  int lx ;
  int lx2 ;
  int dxf ;
  int dyf ;
  int dxb ;
  int dyb ;
  int x ;
  int y ;
  int mode ;
  int anchorframemode ;
  int bx_chroma ;
  int by_chroma ;
  unsigned char *src_f[3] ;
  unsigned char *src_b[3] ;
  int sumx ;
  int sumy ;
  int comp ;
  int dx ;
  int dy ;
  int xp ;
  int yp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 337
  sumx = 0;
#line 337
  sumy = 0;
#line 339
  x = bx / 16 + 1;
#line 340
  y = by / 16 + 1;
#line 341
  lx = coded_picture_width;
#line 342
  w = 16;
#line 343
  h = 16;
#line 345
  lx2 = coded_picture_width + 64;
#line 346
  src_f[0] = edgeframe[0];
#line 347
  src_f[1] = edgeframe[1];
#line 348
  src_f[2] = edgeframe[2];
#line 349
  src_b[0] = nextedgeframe[0];
#line 350
  src_b[1] = nextedgeframe[1];
#line 351
  src_b[2] = nextedgeframe[2];
#line 353
  mode = modemap[y][x];
#line 354
  anchorframemode = anchorframemodemap[y][x];
  {
#line 359
  if (true_B_prediction_type == 0) {
#line 359
    goto case_0;
  }
#line 455
  if (true_B_prediction_type == 1) {
#line 455
    goto case_1;
  }
#line 482
  if (true_B_prediction_type == 2) {
#line 482
    goto case_2;
  }
#line 508
  if (true_B_prediction_type == 3) {
#line 508
    goto case_3;
  }
#line 547
  goto switch_default;
  case_0: /* CIL Label */ 
#line 361
  if (2 == anchorframemode) {
#line 361
    goto _L;
  } else
#line 361
  if (5 == anchorframemode) {
    _L: /* CIL Label */ 
#line 363
    w = 8;
#line 364
    h = 8;
#line 366
    comp = 0;
    {
    {
#line 366
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 366
      if (! (comp < 4)) {
#line 366
        goto while_break;
      }
      {
#line 368
      dx = true_B_direct_mode_MV[0][comp + 1][y][x];
#line 369
      dy = true_B_direct_mode_MV[1][comp + 1][y][x];
#line 371
      dxf = (true_b_trb * dx) / trd;
#line 372
      dyf = (true_b_trb * dy) / trd;
#line 373
      dxb = ((true_b_trb - trd) * dx) / trd;
#line 374
      dyb = ((true_b_trb - trd) * dy) / trd;
#line 376
      xp = bx + ((comp & 1) << 3);
#line 377
      yp = by + ((comp & 2) << 2);
      {
#line 380
      recon_comp(src_f[0], tmp_f[0], lx, lx2, w, h, xp, yp, dxf, dyf, 0);
      }
      {
#line 381
      recon_comp(src_b[0], tmp_b[0], lx, lx2, w, h, xp, yp, dxb, dyb, 0);
      }
#line 366
      comp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 384
    dyb = 0;
#line 384
    dxb = dyb;
#line 384
    dyf = dxb;
#line 384
    dxf = dyf;
#line 386
    comp = 0;
    {
    {
#line 386
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 386
      if (! (comp < 4)) {
#line 386
        goto while_break___0;
      }
#line 388
      dx = true_B_direct_mode_MV[0][comp + 1][y][x];
#line 389
      dy = true_B_direct_mode_MV[1][comp + 1][y][x];
#line 391
      dxf += (true_b_trb * dx) / trd;
#line 392
      dyf += (true_b_trb * dy) / trd;
#line 393
      dxb += ((true_b_trb - trd) * dx) / trd;
#line 394
      dyb += ((true_b_trb - trd) * dy) / trd;
#line 386
      comp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 397
    if (dxf < 0) {
#line 397
      tmp = -1;
    } else {
#line 397
      tmp = 1;
    }
    {
    {
#line 397
    tmp___0 = abs(dxf);
    }
    {
#line 397
    tmp___1 = abs(dxf);
    }
#line 397
    dxf = tmp * (roundtab[tmp___0 % 16] + (tmp___1 / 16) * 2);
    }
#line 398
    if (dyf < 0) {
#line 398
      tmp___2 = -1;
    } else {
#line 398
      tmp___2 = 1;
    }
    {
    {
#line 398
    tmp___3 = abs(dyf);
    }
    {
#line 398
    tmp___4 = abs(dyf);
    }
#line 398
    dyf = tmp___2 * (roundtab[tmp___3 % 16] + (tmp___4 / 16) * 2);
    }
#line 399
    if (dxb < 0) {
#line 399
      tmp___5 = -1;
    } else {
#line 399
      tmp___5 = 1;
    }
    {
    {
#line 399
    tmp___6 = abs(dxb);
    }
    {
#line 399
    tmp___7 = abs(dxb);
    }
#line 399
    dxb = tmp___5 * (roundtab[tmp___6 % 16] + (tmp___7 / 16) * 2);
    }
#line 400
    if (dyb < 0) {
#line 400
      tmp___8 = -1;
    } else {
#line 400
      tmp___8 = 1;
    }
    {
    {
#line 400
    tmp___9 = abs(dyb);
    }
    {
#line 400
    tmp___10 = abs(dyb);
    }
#line 400
    dyb = tmp___8 * (roundtab[tmp___9 % 16] + (tmp___10 / 16) * 2);
#line 402
    lx >>= 1;
#line 403
    bx >>= 1;
#line 404
    lx2 >>= 1;
#line 405
    by >>= 1;
    {
#line 408
    recon_comp(src_f[1], tmp_f[1], lx, lx2, w, h, bx, by, dxf, dyf, 1);
    }
    {
#line 409
    recon_comp(src_f[2], tmp_f[2], lx, lx2, w, h, bx, by, dxf, dyf, 2);
    }
    {
#line 410
    recon_comp(src_b[1], tmp_b[1], lx, lx2, w, h, bx, by, dxb, dyb, 1);
    }
    {
#line 411
    recon_comp(src_b[2], tmp_b[2], lx, lx2, w, h, bx, by, dxb, dyb, 2);
    }
#line 413
    bx <<= 1;
#line 414
    by <<= 1;
    }
  } else {
    {
#line 418
    dxf = (true_b_trb * true_B_direct_mode_MV[0][0][y][x]) / trd;
#line 419
    dyf = (true_b_trb * true_B_direct_mode_MV[1][0][y][x]) / trd;
#line 420
    dxb = ((true_b_trb - trd) * true_B_direct_mode_MV[0][0][y][x]) / trd;
#line 421
    dyb = ((true_b_trb - trd) * true_B_direct_mode_MV[1][0][y][x]) / trd;
    {
#line 424
    recon_comp(src_f[0], tmp_f[0], lx, lx2, w, h, bx, by, dxf, dyf, 0);
    }
    {
#line 425
    recon_comp(src_b[0], tmp_b[0], lx, lx2, w, h, bx, by, dxb, dyb, 0);
    }
#line 427
    lx >>= 1;
#line 428
    w >>= 1;
#line 429
    bx >>= 1;
#line 430
    lx2 >>= 1;
#line 431
    h >>= 1;
#line 432
    by >>= 1;
    }
#line 435
    if (dxf % 4 == 0) {
#line 435
      dxf >>= 1;
    } else {
#line 435
      dxf = (dxf >> 1) | 1;
    }
#line 436
    if (dyf % 4 == 0) {
#line 436
      dyf >>= 1;
    } else {
#line 436
      dyf = (dyf >> 1) | 1;
    }
#line 437
    if (dxb % 4 == 0) {
#line 437
      dxb >>= 1;
    } else {
#line 437
      dxb = (dxb >> 1) | 1;
    }
#line 438
    if (dyb % 4 == 0) {
#line 438
      dyb >>= 1;
    } else {
#line 438
      dyb = (dyb >> 1) | 1;
    }
    {
    {
#line 441
    recon_comp(src_f[1], tmp_f[1], lx, lx2, w, h, bx, by, dxf, dyf, 1);
    }
    {
#line 442
    recon_comp(src_f[2], tmp_f[2], lx, lx2, w, h, bx, by, dxf, dyf, 2);
    }
    {
#line 443
    recon_comp(src_b[1], tmp_b[1], lx, lx2, w, h, bx, by, dxb, dyb, 1);
    }
    {
#line 444
    recon_comp(src_b[2], tmp_b[2], lx, lx2, w, h, bx, by, dxb, dyb, 2);
    }
#line 446
    bx <<= 1;
#line 447
    by <<= 1;
    }
  }
  {
  {
#line 451
  recon_bidir_average(bx, by);
  }
  }
#line 453
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 457
  w = 16;
#line 458
  h = 16;
#line 459
  dxf = MV[0][0][y][x];
#line 460
  dyf = MV[1][0][y][x];
  {
#line 463
  recon_comp(src_f[0], bframe[0], lx, lx2, w, h, bx, by, dxf, dyf, 0);
  }
#line 465
  lx >>= 1;
#line 466
  w >>= 1;
#line 467
  bx >>= 1;
#line 468
  lx2 >>= 1;
#line 469
  h >>= 1;
#line 470
  by >>= 1;
  }
#line 473
  if (dxf % 4 == 0) {
#line 473
    dxf >>= 1;
  } else {
#line 473
    dxf = (dxf >> 1) | 1;
  }
#line 474
  if (dyf % 4 == 0) {
#line 474
    dyf >>= 1;
  } else {
#line 474
    dyf = (dyf >> 1) | 1;
  }
  {
  {
#line 477
  recon_comp(src_f[1], bframe[1], lx, lx2, w, h, bx, by, dxf, dyf, 1);
  }
  {
#line 478
  recon_comp(src_f[2], bframe[2], lx, lx2, w, h, bx, by, dxf, dyf, 2);
  }
  }
#line 480
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 484
  w = 16;
#line 485
  h = 16;
#line 486
  dxb = MV[0][5][y][x];
#line 487
  dyb = MV[1][5][y][x];
  {
#line 490
  recon_comp(src_b[0], bframe[0], lx, lx2, w, h, bx, by, dxb, dyb, 0);
  }
#line 492
  lx >>= 1;
#line 493
  w >>= 1;
#line 494
  bx >>= 1;
#line 495
  lx2 >>= 1;
#line 496
  h >>= 1;
#line 497
  by >>= 1;
  }
#line 499
  if (dxb % 4 == 0) {
#line 499
    dxb >>= 1;
  } else {
#line 499
    dxb = (dxb >> 1) | 1;
  }
#line 500
  if (dyb % 4 == 0) {
#line 500
    dyb >>= 1;
  } else {
#line 500
    dyb = (dyb >> 1) | 1;
  }
  {
  {
#line 503
  recon_comp(src_b[1], bframe[1], lx, lx2, w, h, bx, by, dxb, dyb, 1);
  }
  {
#line 504
  recon_comp(src_b[2], bframe[2], lx, lx2, w, h, bx, by, dxb, dyb, 2);
  }
  }
#line 506
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 510
  w = 16;
#line 511
  h = 16;
#line 513
  dxf = MV[0][0][y][x];
#line 514
  dyf = MV[1][0][y][x];
#line 515
  dxb = MV[0][5][y][x];
#line 516
  dyb = MV[1][5][y][x];
  {
#line 519
  recon_comp(src_f[0], tmp_f[0], lx, lx2, w, h, bx, by, dxf, dyf, 0);
  }
  {
#line 520
  recon_comp(src_b[0], tmp_b[0], lx, lx2, w, h, bx, by, dxb, dyb, 0);
  }
#line 522
  lx >>= 1;
#line 523
  w >>= 1;
#line 524
  lx2 >>= 1;
#line 525
  h >>= 1;
#line 527
  bx_chroma = bx >> 1;
#line 528
  by_chroma = by >> 1;
  }
#line 531
  if (dxf % 4 == 0) {
#line 531
    dxf >>= 1;
  } else {
#line 531
    dxf = (dxf >> 1) | 1;
  }
#line 532
  if (dyf % 4 == 0) {
#line 532
    dyf >>= 1;
  } else {
#line 532
    dyf = (dyf >> 1) | 1;
  }
#line 533
  if (dxb % 4 == 0) {
#line 533
    dxb >>= 1;
  } else {
#line 533
    dxb = (dxb >> 1) | 1;
  }
#line 534
  if (dyb % 4 == 0) {
#line 534
    dyb >>= 1;
  } else {
#line 534
    dyb = (dyb >> 1) | 1;
  }
  {
  {
#line 537
  recon_comp(src_f[1], tmp_f[1], lx, lx2, w, h, bx_chroma, by_chroma, dxf, dyf, 1);
  }
  {
#line 538
  recon_comp(src_f[2], tmp_f[2], lx, lx2, w, h, bx_chroma, by_chroma, dxf, dyf, 2);
  }
  {
#line 539
  recon_comp(src_b[1], tmp_b[1], lx, lx2, w, h, bx_chroma, by_chroma, dxb, dyb, 1);
  }
  {
#line 540
  recon_comp(src_b[2], tmp_b[2], lx, lx2, w, h, bx_chroma, by_chroma, dxb, dyb, 2);
  }
  {
#line 543
  recon_bidir_average(bx, by);
  }
  }
#line 545
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 549
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal scalable prediction type in reconstruct_true_B (recon.c)\n");
  }
  {
#line 550
  exit(-1);
  }
  }
#line 551
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 554
  return;
}
}
#line 568 "recon.c"
void reconstruct_ei_ep(int bx , int by , int ei_ep_prediction_type ) 
{ 
  int w ;
  int h ;
  int lx ;
  int lx2 ;
  int dxf ;
  int dyf ;
  int x ;
  int y ;
  int mode ;
  int bx_chroma ;
  int by_chroma ;
  unsigned char *src_fwd[3] ;
  unsigned char *src_up[3] ;
  unsigned char *tmp_fwd[3] ;
  unsigned char *tmp_up[3] ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 577
  x = bx / 16 + 1;
#line 578
  y = by / 16 + 1;
#line 579
  lx = coded_picture_width;
#line 580
  w = 16;
#line 581
  h = 16;
#line 583
  lx2 = coded_picture_width + 64;
#line 584
  src_fwd[0] = enhance_edgeframe[enhancement_layer_num - 2][0];
#line 585
  src_fwd[1] = enhance_edgeframe[enhancement_layer_num - 2][1];
#line 586
  src_fwd[2] = enhance_edgeframe[enhancement_layer_num - 2][2];
#line 587
  src_up[0] = curr_reference_frame[0];
#line 588
  src_up[1] = curr_reference_frame[1];
#line 589
  src_up[2] = curr_reference_frame[2];
#line 591
  tmp_fwd[0] = tmp_enhance_fwd[enhancement_layer_num - 2][0];
#line 592
  tmp_fwd[1] = tmp_enhance_fwd[enhancement_layer_num - 2][1];
#line 593
  tmp_fwd[2] = tmp_enhance_fwd[enhancement_layer_num - 2][2];
#line 594
  tmp_up[0] = tmp_enhance_up[enhancement_layer_num - 2][0];
#line 595
  tmp_up[1] = tmp_enhance_up[enhancement_layer_num - 2][1];
#line 596
  tmp_up[2] = tmp_enhance_up[enhancement_layer_num - 2][2];
#line 598
  mode = modemap[y][x];
  {
#line 603
  if (ei_ep_prediction_type == 0) {
#line 603
    goto case_0;
  }
#line 630
  if (ei_ep_prediction_type == 1) {
#line 630
    goto case_1;
  }
#line 652
  if (ei_ep_prediction_type == 2) {
#line 652
    goto case_2;
  }
#line 687
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 605
  w = 16;
#line 606
  h = 16;
#line 607
  dxf = MV[0][0][y][x];
#line 608
  dyf = MV[1][0][y][x];
  {
#line 611
  recon_comp(src_fwd[0], current_enhancement_frame[enhancement_layer_num - 2][0],
             lx, lx2, w, h, bx, by, dxf, dyf, 0);
  }
#line 613
  lx >>= 1;
#line 614
  w >>= 1;
#line 615
  bx >>= 1;
#line 616
  lx2 >>= 1;
#line 617
  h >>= 1;
#line 618
  by >>= 1;
  }
#line 621
  if (dxf % 4 == 0) {
#line 621
    dxf >>= 1;
  } else {
#line 621
    dxf = (dxf >> 1) | 1;
  }
#line 622
  if (dyf % 4 == 0) {
#line 622
    dyf >>= 1;
  } else {
#line 622
    dyf = (dyf >> 1) | 1;
  }
  {
  {
#line 625
  recon_comp(src_fwd[1], current_enhancement_frame[enhancement_layer_num - 2][1],
             lx, lx2, w, h, bx, by, dxf, dyf, 1);
  }
  {
#line 626
  recon_comp(src_fwd[2], current_enhancement_frame[enhancement_layer_num - 2][2],
             lx, lx2, w, h, bx, by, dxf, dyf, 2);
  }
  }
#line 628
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 633
  w = 16;
#line 634
  h = 16;
  {
#line 637
  recon_comp(src_up[0], current_enhancement_frame[enhancement_layer_num - 2][0], lx,
             lx, w, h, bx, by, 0, 0, 0);
  }
#line 639
  lx >>= 1;
#line 640
  w >>= 1;
#line 641
  bx >>= 1;
#line 642
  lx2 >>= 1;
#line 643
  h >>= 1;
#line 644
  by >>= 1;
  {
#line 647
  recon_comp(src_up[1], current_enhancement_frame[enhancement_layer_num - 2][1], lx,
             lx, w, h, bx, by, 0, 0, 1);
  }
  {
#line 648
  recon_comp(src_up[2], current_enhancement_frame[enhancement_layer_num - 2][2], lx,
             lx, w, h, bx, by, 0, 0, 2);
  }
  }
#line 650
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 654
  w = 16;
#line 655
  h = 16;
#line 657
  dxf = MV[0][0][y][x];
#line 658
  dyf = MV[1][0][y][x];
  {
#line 661
  recon_comp(src_fwd[0], tmp_fwd[0], lx, lx2, w, h, bx, by, dxf, dyf, 0);
  }
  {
#line 662
  recon_comp(src_up[0], tmp_up[0], lx, lx, w, h, bx, by, 0, 0, 0);
  }
#line 664
  lx >>= 1;
#line 665
  w >>= 1;
#line 666
  lx2 >>= 1;
#line 667
  h >>= 1;
#line 669
  bx_chroma = bx >> 1;
#line 670
  by_chroma = by >> 1;
  }
#line 673
  if (dxf % 4 == 0) {
#line 673
    dxf >>= 1;
  } else {
#line 673
    dxf = (dxf >> 1) | 1;
  }
#line 674
  if (dyf % 4 == 0) {
#line 674
    dyf >>= 1;
  } else {
#line 674
    dyf = (dyf >> 1) | 1;
  }
  {
  {
#line 677
  recon_comp(src_fwd[1], tmp_fwd[1], lx, lx2, w, h, bx_chroma, by_chroma, dxf, dyf,
             1);
  }
  {
#line 678
  recon_comp(src_fwd[2], tmp_fwd[2], lx, lx2, w, h, bx_chroma, by_chroma, dxf, dyf,
             2);
  }
  {
#line 679
  recon_comp(src_up[1], tmp_up[1], lx, lx, w, h, bx_chroma, by_chroma, 0, 0, 1);
  }
  {
#line 680
  recon_comp(src_up[2], tmp_up[2], lx, lx, w, h, bx_chroma, by_chroma, 0, 0, 2);
  }
  {
#line 683
  recon_bidir_average(bx, by);
  }
  }
#line 685
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 689
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal scalable prediction type in reconstruct_ei_ep (recon.c)\n");
  }
  {
#line 690
  exit(-1);
  }
  }
#line 692
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 695
  return;
}
}
#line 697 "recon.c"
static void recon_comp(unsigned char *src , unsigned char *dst , int lx , int lx2 ,
                       int w , int h , int x , int y , int dx , int dy , int chroma ) 
{ 
  int xint ;
  int xh ;
  int yint ;
  int yh ;
  unsigned char *s ;
  unsigned char *d ;
  int store_rtype ;

  {
#line 705
  store_rtype = rtype;
#line 707
  xint = dx >> 1;
#line 708
  xh = dx & 1;
#line 709
  yint = dy >> 1;
#line 710
  yh = dy & 1;
#line 713
  s = ((src + lx2 * (y + yint)) + x) + xint;
#line 714
  d = (dst + lx * y) + x;
#line 716
  if (! xh) {
#line 716
    if (! yh) {
#line 717
      if (w != 8) {
        {
        {
#line 718
        rec(s, d, lx, lx2, h);
        }
        }
      } else {
        {
        {
#line 720
        recc(s, d, lx, lx2, h);
        }
        }
      }
    } else {
#line 716
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 721
  if (! xh) {
#line 721
    if (yh) {
#line 722
      if (w != 8) {
        {
        {
#line 723
        recv(s, d, lx, lx2, h);
        }
        }
      } else {
        {
        {
#line 725
        recvc(s, d, lx, lx2, h);
        }
        }
      }
    } else {
#line 721
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 726
  if (xh) {
#line 726
    if (! yh) {
#line 727
      if (w != 8) {
        {
        {
#line 728
        rech(s, d, lx, lx2, h);
        }
        }
      } else {
        {
        {
#line 730
        rechc(s, d, lx, lx2, h);
        }
        }
      }
    } else {
#line 726
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 732
  if (w != 8) {
    {
    {
#line 733
    rec4(s, d, lx, lx2, h);
    }
    }
  } else {
    {
    {
#line 735
    rec4c(s, d, lx, lx2, h);
    }
    }
  }
#line 737
  rtype = store_rtype;
#line 738
  return;
}
}
#line 740 "recon.c"
static void rec(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  int j ;

  {
#line 745
  j = 0;
  {
  {
#line 745
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 745
    if (! (j < h)) {
#line 745
      goto while_break;
    }
#line 747
    *(d + 0) = *(s + 0);
#line 748
    *(d + 1) = *(s + 1);
#line 749
    *(d + 2) = *(s + 2);
#line 750
    *(d + 3) = *(s + 3);
#line 751
    *(d + 4) = *(s + 4);
#line 752
    *(d + 5) = *(s + 5);
#line 753
    *(d + 6) = *(s + 6);
#line 754
    *(d + 7) = *(s + 7);
#line 755
    *(d + 8) = *(s + 8);
#line 756
    *(d + 9) = *(s + 9);
#line 757
    *(d + 10) = *(s + 10);
#line 758
    *(d + 11) = *(s + 11);
#line 759
    *(d + 12) = *(s + 12);
#line 760
    *(d + 13) = *(s + 13);
#line 761
    *(d + 14) = *(s + 14);
#line 762
    *(d + 15) = *(s + 15);
#line 763
    s += lx2;
#line 764
    d += lx;
#line 745
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  return;
}
}
#line 781 "recon.c"
static void recon_bidir_average(int bx , int by ) 
{ 
  int i ;
  int iincr ;
  int cc ;
  int comp ;
  unsigned char *avg ;
  unsigned char *forw ;
  unsigned char *backw ;
  unsigned char *prev_frame___0[3] ;
  unsigned char *next_frame[3] ;
  unsigned char *curr[3] ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 788
  if (3 == pict_type) {
#line 790
    prev_frame___0[0] = tmp_f[0];
#line 791
    prev_frame___0[1] = tmp_f[1];
#line 792
    prev_frame___0[2] = tmp_f[2];
#line 793
    next_frame[0] = tmp_b[0];
#line 794
    next_frame[1] = tmp_b[1];
#line 795
    next_frame[2] = tmp_b[2];
#line 796
    curr[0] = current_frame[0];
#line 797
    curr[1] = current_frame[1];
#line 798
    curr[2] = current_frame[2];
  } else {
#line 803
    prev_frame___0[0] = tmp_enhance_fwd[enhancement_layer_num - 2][0];
#line 804
    prev_frame___0[1] = tmp_enhance_fwd[enhancement_layer_num - 2][1];
#line 805
    prev_frame___0[2] = tmp_enhance_fwd[enhancement_layer_num - 2][2];
#line 806
    next_frame[0] = tmp_enhance_up[enhancement_layer_num - 2][0];
#line 807
    next_frame[1] = tmp_enhance_up[enhancement_layer_num - 2][1];
#line 808
    next_frame[2] = tmp_enhance_up[enhancement_layer_num - 2][2];
#line 809
    curr[0] = current_enhancement_frame[enhancement_layer_num - 2][0];
#line 810
    curr[1] = current_enhancement_frame[enhancement_layer_num - 2][1];
#line 811
    curr[2] = current_enhancement_frame[enhancement_layer_num - 2][2];
  }
#line 814
  comp = 0;
  {
  {
#line 814
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 814
    if (! (comp < 6)) {
#line 814
      goto while_break;
    }
#line 816
    if (comp < 4) {
#line 816
      cc = 0;
    } else {
#line 816
      cc = (comp & 1) + 1;
    }
#line 819
    if (cc == 0) {
#line 821
      avg = ((curr[cc] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 822
      forw = ((prev_frame___0[cc] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 823
      backw = ((next_frame[cc] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 824
      iincr = coded_picture_width;
    } else {
#line 830
      if (4 == comp) {
#line 832
        bx >>= 1;
#line 833
        by >>= 1;
      }
#line 835
      avg = (curr[cc] + chrom_width * by) + bx;
#line 836
      forw = (prev_frame___0[cc] + chrom_width * by) + bx;
#line 837
      backw = (next_frame[cc] + chrom_width * by) + bx;
#line 838
      iincr = chrom_width;
    }
#line 841
    i = 0;
    {
    {
#line 841
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 841
      if (! (i < 8)) {
#line 841
        goto while_break___0;
      }
#line 843
      *(avg + 0) = (unsigned char )(((int )*(forw + 0) + (int )*(backw + 0)) / 2);
#line 844
      *(avg + 1) = (unsigned char )(((int )*(forw + 1) + (int )*(backw + 1)) / 2);
#line 845
      *(avg + 2) = (unsigned char )(((int )*(forw + 2) + (int )*(backw + 2)) / 2);
#line 846
      *(avg + 3) = (unsigned char )(((int )*(forw + 3) + (int )*(backw + 3)) / 2);
#line 847
      *(avg + 4) = (unsigned char )(((int )*(forw + 4) + (int )*(backw + 4)) / 2);
#line 848
      *(avg + 5) = (unsigned char )(((int )*(forw + 5) + (int )*(backw + 5)) / 2);
#line 849
      *(avg + 6) = (unsigned char )(((int )*(forw + 6) + (int )*(backw + 6)) / 2);
#line 850
      *(avg + 7) = (unsigned char )(((int )*(forw + 7) + (int )*(backw + 7)) / 2);
#line 851
      avg += iincr;
#line 852
      forw += iincr;
#line 853
      backw += iincr;
#line 841
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 814
    comp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 856
  return;
}
}
#line 859 "recon.c"
static void recc(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  int j ;

  {
#line 864
  j = 0;
  {
  {
#line 864
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 864
    if (! (j < h)) {
#line 864
      goto while_break;
    }
#line 866
    *(d + 0) = *(s + 0);
#line 867
    *(d + 1) = *(s + 1);
#line 868
    *(d + 2) = *(s + 2);
#line 869
    *(d + 3) = *(s + 3);
#line 870
    *(d + 4) = *(s + 4);
#line 871
    *(d + 5) = *(s + 5);
#line 872
    *(d + 6) = *(s + 6);
#line 873
    *(d + 7) = *(s + 7);
#line 874
    s += lx2;
#line 875
    d += lx;
#line 864
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 877
  return;
}
}
#line 879 "recon.c"
static void reco(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                 int xa , int xb , int ya , int yb ) 
{ 
  int i ;
  int j ;
  int *om ;

  {
#line 886
  om = & OM[c___0][ya][0];
#line 888
  if (! addflag) {
#line 890
    j = ya;
    {
    {
#line 890
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 890
      if (! (j < yb)) {
#line 890
        goto while_break;
      }
#line 892
      i = xa;
      {
      {
#line 892
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 892
        if (! (i < xb)) {
#line 892
          goto while_break___0;
        }
#line 894
        *(d + i) = (int )*(s + i) * *(om + i);
#line 892
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 896
      s += lx2;
#line 897
      d += lx;
#line 898
      om += 8;
#line 890
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 902
    j = ya;
    {
    {
#line 902
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 902
      if (! (j < yb)) {
#line 902
        goto while_break___1;
      }
#line 904
      i = xa;
      {
      {
#line 904
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 904
        if (! (i < xb)) {
#line 904
          goto while_break___2;
        }
#line 906
        *(d + i) += (int )*(s + i) * *(om + i);
#line 904
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 908
      s += lx2;
#line 909
      d += lx;
#line 910
      om += 8;
#line 902
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 913
  return;
}
}
#line 915 "recon.c"
static void rech(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  unsigned char *dp ;
  unsigned char *sp ;
  int j ;
  unsigned int s1 ;
  unsigned int s2 ;

  {
#line 922
  sp = s;
#line 923
  dp = d;
#line 924
  j = 0;
  {
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 924
    if (! (j < h)) {
#line 924
      goto while_break;
    }
#line 926
    s1 = (unsigned int )*(sp + 0);
#line 927
    s2 = (unsigned int )*(sp + 1);
#line 927
    *(dp + 0) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 928
    s1 = (unsigned int )*(sp + 2);
#line 928
    *(dp + 1) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 929
    s2 = (unsigned int )*(sp + 3);
#line 929
    *(dp + 2) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 930
    s1 = (unsigned int )*(sp + 4);
#line 930
    *(dp + 3) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 931
    s2 = (unsigned int )*(sp + 5);
#line 931
    *(dp + 4) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 932
    s1 = (unsigned int )*(sp + 6);
#line 932
    *(dp + 5) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 933
    s2 = (unsigned int )*(sp + 7);
#line 933
    *(dp + 6) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 934
    s1 = (unsigned int )*(sp + 8);
#line 934
    *(dp + 7) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 935
    s2 = (unsigned int )*(sp + 9);
#line 935
    *(dp + 8) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 936
    s1 = (unsigned int )*(sp + 10);
#line 936
    *(dp + 9) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 937
    s2 = (unsigned int )*(sp + 11);
#line 937
    *(dp + 10) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 938
    s1 = (unsigned int )*(sp + 12);
#line 938
    *(dp + 11) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 939
    s2 = (unsigned int )*(sp + 13);
#line 939
    *(dp + 12) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 940
    s1 = (unsigned int )*(sp + 14);
#line 940
    *(dp + 13) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 941
    s2 = (unsigned int )*(sp + 15);
#line 941
    *(dp + 14) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 942
    *(dp + 15) = (unsigned char )((((s2 + (unsigned int )*(sp + 16)) + 1U) - (unsigned int )rtype) >> 1);
#line 943
    sp += lx2;
#line 944
    dp += lx;
#line 924
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  return;
}
}
#line 948 "recon.c"
static void rechc(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  unsigned char *dp ;
  unsigned char *sp ;
  int j ;
  unsigned int s1 ;
  unsigned int s2 ;

  {
#line 955
  sp = s;
#line 956
  dp = d;
#line 957
  j = 0;
  {
  {
#line 957
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 957
    if (! (j < h)) {
#line 957
      goto while_break;
    }
#line 959
    s1 = (unsigned int )*(sp + 0);
#line 960
    s2 = (unsigned int )*(sp + 1);
#line 960
    *(dp + 0) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 961
    s1 = (unsigned int )*(sp + 2);
#line 961
    *(dp + 1) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 962
    s2 = (unsigned int )*(sp + 3);
#line 962
    *(dp + 2) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 963
    s1 = (unsigned int )*(sp + 4);
#line 963
    *(dp + 3) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 964
    s2 = (unsigned int )*(sp + 5);
#line 964
    *(dp + 4) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 965
    s1 = (unsigned int )*(sp + 6);
#line 965
    *(dp + 5) = (unsigned char )((((s2 + s1) + 1U) - (unsigned int )rtype) >> 1);
#line 966
    s2 = (unsigned int )*(sp + 7);
#line 966
    *(dp + 6) = (unsigned char )((((s1 + s2) + 1U) - (unsigned int )rtype) >> 1);
#line 967
    *(dp + 7) = (unsigned char )((((s2 + (unsigned int )*(sp + 8)) + 1U) - (unsigned int )rtype) >> 1);
#line 968
    sp += lx2;
#line 969
    dp += lx;
#line 957
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return;
}
}
#line 973 "recon.c"
static void recho(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                  int xa , int xb , int ya , int yb ) 
{ 
  int *dp ;
  int *om ;
  unsigned char *sp ;
  int i ;
  int j ;

  {
#line 980
  sp = s;
#line 981
  dp = d;
#line 982
  om = & OM[c___0][ya][0];
#line 984
  if (! addflag) {
#line 986
    j = ya;
    {
    {
#line 986
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 986
      if (! (j < yb)) {
#line 986
        goto while_break;
      }
#line 988
      i = xa;
      {
      {
#line 988
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 988
        if (! (i < xb)) {
#line 988
          goto while_break___0;
        }
#line 990
        *(dp + i) = (int )(((unsigned int )((((int )*(sp + i) + (int )*(sp + (i + 1))) + 1) - rtype) >> 1) * (unsigned int )*(om + i));
#line 988
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 992
      sp += lx2;
#line 993
      dp += lx;
#line 994
      om += 8;
#line 986
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 998
    j = ya;
    {
    {
#line 998
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 998
      if (! (j < yb)) {
#line 998
        goto while_break___1;
      }
#line 1000
      i = xa;
      {
      {
#line 1000
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1000
        if (! (i < xb)) {
#line 1000
          goto while_break___2;
        }
#line 1002
        *(dp + i) = (int )((unsigned int )*(dp + i) + ((unsigned int )((((int )*(sp + i) + (int )*(sp + (i + 1))) + 1) - rtype) >> 1) * (unsigned int )OM[c___0][j][i]);
#line 1000
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1004
      sp += lx2;
#line 1005
      dp += lx;
#line 1006
      om += 8;
#line 998
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1009
  return;
}
}
#line 1011 "recon.c"
static void recv(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  unsigned char *dp ;
  unsigned char *sp ;
  unsigned char *sp2 ;
  int j ;

  {
#line 1017
  sp = s;
#line 1018
  sp2 = s + lx2;
#line 1019
  dp = d;
#line 1020
  j = 0;
  {
  {
#line 1020
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1020
    if (! (j < h)) {
#line 1020
      goto while_break;
    }
#line 1022
    *(dp + 0) = (unsigned char )((unsigned int )((((int )*(sp + 0) + (int )*(sp2 + 0)) + 1) - rtype) >> 1);
#line 1023
    *(dp + 1) = (unsigned char )((unsigned int )((((int )*(sp + 1) + (int )*(sp2 + 1)) + 1) - rtype) >> 1);
#line 1024
    *(dp + 2) = (unsigned char )((unsigned int )((((int )*(sp + 2) + (int )*(sp2 + 2)) + 1) - rtype) >> 1);
#line 1025
    *(dp + 3) = (unsigned char )((unsigned int )((((int )*(sp + 3) + (int )*(sp2 + 3)) + 1) - rtype) >> 1);
#line 1026
    *(dp + 4) = (unsigned char )((unsigned int )((((int )*(sp + 4) + (int )*(sp2 + 4)) + 1) - rtype) >> 1);
#line 1027
    *(dp + 5) = (unsigned char )((unsigned int )((((int )*(sp + 5) + (int )*(sp2 + 5)) + 1) - rtype) >> 1);
#line 1028
    *(dp + 6) = (unsigned char )((unsigned int )((((int )*(sp + 6) + (int )*(sp2 + 6)) + 1) - rtype) >> 1);
#line 1029
    *(dp + 7) = (unsigned char )((unsigned int )((((int )*(sp + 7) + (int )*(sp2 + 7)) + 1) - rtype) >> 1);
#line 1030
    *(dp + 8) = (unsigned char )((unsigned int )((((int )*(sp + 8) + (int )*(sp2 + 8)) + 1) - rtype) >> 1);
#line 1031
    *(dp + 9) = (unsigned char )((unsigned int )((((int )*(sp + 9) + (int )*(sp2 + 9)) + 1) - rtype) >> 1);
#line 1032
    *(dp + 10) = (unsigned char )((unsigned int )((((int )*(sp + 10) + (int )*(sp2 + 10)) + 1) - rtype) >> 1);
#line 1033
    *(dp + 11) = (unsigned char )((unsigned int )((((int )*(sp + 11) + (int )*(sp2 + 11)) + 1) - rtype) >> 1);
#line 1034
    *(dp + 12) = (unsigned char )((unsigned int )((((int )*(sp + 12) + (int )*(sp2 + 12)) + 1) - rtype) >> 1);
#line 1035
    *(dp + 13) = (unsigned char )((unsigned int )((((int )*(sp + 13) + (int )*(sp2 + 13)) + 1) - rtype) >> 1);
#line 1036
    *(dp + 14) = (unsigned char )((unsigned int )((((int )*(sp + 14) + (int )*(sp2 + 14)) + 1) - rtype) >> 1);
#line 1037
    *(dp + 15) = (unsigned char )((unsigned int )((((int )*(sp + 15) + (int )*(sp2 + 15)) + 1) - rtype) >> 1);
#line 1038
    sp += lx2;
#line 1039
    sp2 += lx2;
#line 1040
    dp += lx;
#line 1020
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1042
  return;
}
}
#line 1044 "recon.c"
static void recvc(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  unsigned char *dp ;
  unsigned char *sp ;
  unsigned char *sp2 ;
  int j ;

  {
#line 1050
  sp = s;
#line 1051
  sp2 = s + lx2;
#line 1052
  dp = d;
#line 1054
  j = 0;
  {
  {
#line 1054
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1054
    if (! (j < h)) {
#line 1054
      goto while_break;
    }
#line 1056
    *(dp + 0) = (unsigned char )((unsigned int )((((int )*(sp + 0) + (int )*(sp2 + 0)) + 1) - rtype) >> 1);
#line 1057
    *(dp + 1) = (unsigned char )((unsigned int )((((int )*(sp + 1) + (int )*(sp2 + 1)) + 1) - rtype) >> 1);
#line 1058
    *(dp + 2) = (unsigned char )((unsigned int )((((int )*(sp + 2) + (int )*(sp2 + 2)) + 1) - rtype) >> 1);
#line 1059
    *(dp + 3) = (unsigned char )((unsigned int )((((int )*(sp + 3) + (int )*(sp2 + 3)) + 1) - rtype) >> 1);
#line 1060
    *(dp + 4) = (unsigned char )((unsigned int )((((int )*(sp + 4) + (int )*(sp2 + 4)) + 1) - rtype) >> 1);
#line 1061
    *(dp + 5) = (unsigned char )((unsigned int )((((int )*(sp + 5) + (int )*(sp2 + 5)) + 1) - rtype) >> 1);
#line 1062
    *(dp + 6) = (unsigned char )((unsigned int )((((int )*(sp + 6) + (int )*(sp2 + 6)) + 1) - rtype) >> 1);
#line 1063
    *(dp + 7) = (unsigned char )((unsigned int )((((int )*(sp + 7) + (int )*(sp2 + 7)) + 1) - rtype) >> 1);
#line 1064
    sp += lx2;
#line 1065
    sp2 += lx2;
#line 1066
    dp += lx;
#line 1054
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1068
  return;
}
}
#line 1070 "recon.c"
static void recvo(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                  int xa , int xb , int ya , int yb ) 
{ 
  int *dp ;
  int *om ;
  unsigned char *sp ;
  unsigned char *sp2 ;
  int i ;
  int j ;

  {
#line 1078
  sp = s;
#line 1079
  sp2 = s + lx2;
#line 1080
  dp = d;
#line 1081
  om = & OM[c___0][ya][0];
#line 1083
  if (! addflag) {
#line 1085
    j = ya;
    {
    {
#line 1085
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1085
      if (! (j < yb)) {
#line 1085
        goto while_break;
      }
#line 1087
      i = xa;
      {
      {
#line 1087
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1087
        if (! (i < xb)) {
#line 1087
          goto while_break___0;
        }
#line 1089
        *(dp + i) = (int )(((unsigned int )((((int )*(sp + i) + (int )*(sp2 + i)) + 1) - rtype) >> 1) * (unsigned int )*(om + i));
#line 1087
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1091
      sp += lx2;
#line 1092
      sp2 += lx2;
#line 1093
      dp += lx;
#line 1094
      om += 8;
#line 1085
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1098
    j = ya;
    {
    {
#line 1098
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1098
      if (! (j < yb)) {
#line 1098
        goto while_break___1;
      }
#line 1100
      i = xa;
      {
      {
#line 1100
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1100
        if (! (i < xb)) {
#line 1100
          goto while_break___2;
        }
#line 1102
        *(dp + i) = (int )((unsigned int )*(dp + i) + ((unsigned int )((((int )*(sp + i) + (int )*(sp2 + i)) + 1) - rtype) >> 1) * (unsigned int )*(om + i));
#line 1100
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1104
      sp += lx2;
#line 1105
      sp2 += lx2;
#line 1106
      dp += lx;
#line 1107
      om += 8;
#line 1098
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1110
  return;
}
}
#line 1112 "recon.c"
static void rec4(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  unsigned char *dp ;
  unsigned char *sp ;
  unsigned char *sp2 ;
  int j ;
  unsigned int s1 ;
  unsigned int s2 ;
  unsigned int s3 ;
  unsigned int s4 ;

  {
#line 1119
  sp = s;
#line 1120
  sp2 = s + lx2;
#line 1121
  dp = d;
#line 1122
  j = 0;
  {
  {
#line 1122
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1122
    if (! (j < h)) {
#line 1122
      goto while_break;
    }
#line 1124
    s1 = (unsigned int )*(sp + 0);
#line 1125
    s3 = (unsigned int )*(sp2 + 0);
#line 1126
    s2 = (unsigned int )*(sp + 1);
#line 1126
    s4 = (unsigned int )*(sp2 + 1);
#line 1126
    *(dp + 0) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1127
    s1 = (unsigned int )*(sp + 2);
#line 1127
    s3 = (unsigned int )*(sp2 + 2);
#line 1127
    *(dp + 1) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1128
    s2 = (unsigned int )*(sp + 3);
#line 1128
    s4 = (unsigned int )*(sp2 + 3);
#line 1128
    *(dp + 2) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1129
    s1 = (unsigned int )*(sp + 4);
#line 1129
    s3 = (unsigned int )*(sp2 + 4);
#line 1129
    *(dp + 3) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1130
    s2 = (unsigned int )*(sp + 5);
#line 1130
    s4 = (unsigned int )*(sp2 + 5);
#line 1130
    *(dp + 4) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1131
    s1 = (unsigned int )*(sp + 6);
#line 1131
    s3 = (unsigned int )*(sp2 + 6);
#line 1131
    *(dp + 5) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1132
    s2 = (unsigned int )*(sp + 7);
#line 1132
    s4 = (unsigned int )*(sp2 + 7);
#line 1132
    *(dp + 6) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1133
    s1 = (unsigned int )*(sp + 8);
#line 1133
    s3 = (unsigned int )*(sp2 + 8);
#line 1133
    *(dp + 7) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1134
    s2 = (unsigned int )*(sp + 9);
#line 1134
    s4 = (unsigned int )*(sp2 + 9);
#line 1134
    *(dp + 8) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1135
    s1 = (unsigned int )*(sp + 10);
#line 1135
    s3 = (unsigned int )*(sp2 + 10);
#line 1135
    *(dp + 9) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1136
    s2 = (unsigned int )*(sp + 11);
#line 1136
    s4 = (unsigned int )*(sp2 + 11);
#line 1136
    *(dp + 10) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1137
    s1 = (unsigned int )*(sp + 12);
#line 1137
    s3 = (unsigned int )*(sp2 + 12);
#line 1137
    *(dp + 11) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1138
    s2 = (unsigned int )*(sp + 13);
#line 1138
    s4 = (unsigned int )*(sp2 + 13);
#line 1138
    *(dp + 12) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1139
    s1 = (unsigned int )*(sp + 14);
#line 1139
    s3 = (unsigned int )*(sp2 + 14);
#line 1139
    *(dp + 13) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1140
    s2 = (unsigned int )*(sp + 15);
#line 1140
    s4 = (unsigned int )*(sp2 + 15);
#line 1140
    *(dp + 14) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1141
    *(dp + 15) = (unsigned char )((((((s2 + (unsigned int )*(sp + 16)) + s4) + (unsigned int )*(sp2 + 16)) + 2U) - (unsigned int )rtype) >> 2);
#line 1142
    sp += lx2;
#line 1143
    sp2 += lx2;
#line 1144
    dp += lx;
#line 1122
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1146
  return;
}
}
#line 1148 "recon.c"
static void rec4c(unsigned char *s , unsigned char *d , int lx , int lx2 , int h ) 
{ 
  unsigned char *dp ;
  unsigned char *sp ;
  unsigned char *sp2 ;
  int j ;
  unsigned int s1 ;
  unsigned int s2 ;
  unsigned int s3 ;
  unsigned int s4 ;

  {
#line 1155
  sp = s;
#line 1156
  sp2 = s + lx2;
#line 1157
  dp = d;
#line 1158
  j = 0;
  {
  {
#line 1158
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1158
    if (! (j < h)) {
#line 1158
      goto while_break;
    }
#line 1160
    s1 = (unsigned int )*(sp + 0);
#line 1161
    s3 = (unsigned int )*(sp2 + 0);
#line 1162
    s2 = (unsigned int )*(sp + 1);
#line 1162
    s4 = (unsigned int )*(sp2 + 1);
#line 1162
    *(dp + 0) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1163
    s1 = (unsigned int )*(sp + 2);
#line 1163
    s3 = (unsigned int )*(sp2 + 2);
#line 1163
    *(dp + 1) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1164
    s2 = (unsigned int )*(sp + 3);
#line 1164
    s4 = (unsigned int )*(sp2 + 3);
#line 1164
    *(dp + 2) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1165
    s1 = (unsigned int )*(sp + 4);
#line 1165
    s3 = (unsigned int )*(sp2 + 4);
#line 1165
    *(dp + 3) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1166
    s2 = (unsigned int )*(sp + 5);
#line 1166
    s4 = (unsigned int )*(sp2 + 5);
#line 1166
    *(dp + 4) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1167
    s1 = (unsigned int )*(sp + 6);
#line 1167
    s3 = (unsigned int )*(sp2 + 6);
#line 1167
    *(dp + 5) = (unsigned char )((((((s2 + s1) + s4) + s3) + 2U) - (unsigned int )rtype) >> 2);
#line 1168
    s2 = (unsigned int )*(sp + 7);
#line 1168
    s4 = (unsigned int )*(sp2 + 7);
#line 1168
    *(dp + 6) = (unsigned char )((((((s1 + s2) + s3) + s4) + 2U) - (unsigned int )rtype) >> 2);
#line 1169
    *(dp + 7) = (unsigned char )((((((s2 + (unsigned int )*(sp + 8)) + s4) + (unsigned int )*(sp2 + 8)) + 2U) - (unsigned int )rtype) >> 2);
#line 1170
    sp += lx2;
#line 1171
    sp2 += lx2;
#line 1172
    dp += lx;
#line 1158
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  return;
}
}
#line 1176 "recon.c"
static void rec4o(unsigned char *s , int *d , int lx , int lx2 , int addflag , int c___0 ,
                  int xa , int xb , int ya , int yb ) 
{ 
  int *dp ;
  int *om ;
  unsigned char *sp ;
  unsigned char *sp2 ;
  int i ;
  int j ;

  {
#line 1184
  sp = s;
#line 1185
  sp2 = s + lx2;
#line 1186
  dp = d;
#line 1187
  om = & OM[c___0][ya][0];
#line 1189
  if (! addflag) {
#line 1191
    j = ya;
    {
    {
#line 1191
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1191
      if (! (j < yb)) {
#line 1191
        goto while_break;
      }
#line 1193
      i = xa;
      {
      {
#line 1193
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1193
        if (! (i < xb)) {
#line 1193
          goto while_break___0;
        }
#line 1195
        *(dp + i) = (int )(((unsigned int )((((((int )*(sp + i) + (int )*(sp2 + i)) + (int )*(sp + (i + 1))) + (int )*(sp2 + (i + 1))) + 2) - rtype) >> 2) * (unsigned int )*(om + i));
#line 1193
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1197
      sp += lx2;
#line 1198
      sp2 += lx2;
#line 1199
      dp += lx;
#line 1200
      om += 8;
#line 1191
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1204
    j = ya;
    {
    {
#line 1204
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1204
      if (! (j < yb)) {
#line 1204
        goto while_break___1;
      }
#line 1206
      i = xa;
      {
      {
#line 1206
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1206
        if (! (i < xb)) {
#line 1206
          goto while_break___2;
        }
#line 1208
        *(dp + i) = (int )((unsigned int )*(dp + i) + ((unsigned int )((((((int )*(sp + i) + (int )*(sp2 + i)) + (int )*(sp + (i + 1))) + (int )*(sp2 + (i + 1))) + 2) - rtype) >> 2) * (unsigned int )*(om + i));
#line 1206
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1210
      sp += lx2;
#line 1211
      sp2 += lx2;
#line 1212
      dp += lx;
#line 1213
      om += 8;
#line 1204
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1216
  return;
}
}
#line 1218 "recon.c"
static void recon_comp_obmc(unsigned char *src , unsigned char *dst , int lx , int lx2 ,
                            int comp , int w , int h , int x , int y , int newgob___0 ) 
{ 
  int j ;
  int k ;
  int xmb ;
  int ymb ;
  int c8 ;
  int t8 ;
  int l8 ;
  int r8 ;
  int ti8 ;
  int li8 ;
  int ri8 ;
  int xit ;
  int xib ;
  int xir ;
  int xil ;
  int yit ;
  int yib ;
  int yir ;
  int yil ;
  int vect ;
  int vecb ;
  int vecr ;
  int vecl ;
  int nx[5] ;
  int ny[5] ;
  int xint[5] ;
  int yint[5] ;
  int xh[5] ;
  int yh[5] ;
  int p[64] ;
  int *pd ;
  unsigned char *d ;
  unsigned char *s[5] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 1233
  xmb = (x >> 4) + 1;
#line 1234
  ymb = (y >> 4) + 1;
#line 1236
  if (modemap[ymb][xmb] == 2) {
#line 1236
    c8 = 1;
  } else {
#line 1236
    c8 = 0;
  }
#line 1237
  if (modemap[ymb][xmb] == 5) {
#line 1237
    c8 = 1;
  } else {
#line 1237
    c8 = c8;
  }
#line 1239
  if (modemap[ymb - 1][xmb] == 2) {
#line 1239
    t8 = 1;
  } else {
#line 1239
    t8 = 0;
  }
#line 1240
  if (modemap[ymb - 1][xmb] == 5) {
#line 1240
    t8 = 1;
  } else {
#line 1240
    t8 = t8;
  }
#line 1241
  if (modemap[ymb - 1][xmb] == 3) {
#line 1241
    ti8 = 1;
  } else {
#line 1241
    ti8 = 0;
  }
#line 1242
  if (modemap[ymb - 1][xmb] == 4) {
#line 1242
    ti8 = 1;
  } else {
#line 1242
    ti8 = ti8;
  }
#line 1244
  if (modemap[ymb][xmb - 1] == 2) {
#line 1244
    l8 = 1;
  } else {
#line 1244
    l8 = 0;
  }
#line 1245
  if (modemap[ymb][xmb - 1] == 5) {
#line 1245
    l8 = 1;
  } else {
#line 1245
    l8 = l8;
  }
#line 1246
  if (modemap[ymb][xmb - 1] == 3) {
#line 1246
    li8 = 1;
  } else {
#line 1246
    li8 = 0;
  }
#line 1247
  if (modemap[ymb][xmb - 1] == 4) {
#line 1247
    li8 = 1;
  } else {
#line 1247
    li8 = li8;
  }
#line 1249
  if (modemap[ymb][xmb + 1] == 2) {
#line 1249
    r8 = 1;
  } else {
#line 1249
    r8 = 0;
  }
#line 1250
  if (modemap[ymb][xmb + 1] == 5) {
#line 1250
    r8 = 1;
  } else {
#line 1250
    r8 = r8;
  }
#line 1251
  if (modemap[ymb][xmb + 1] == 3) {
#line 1251
    ri8 = 1;
  } else {
#line 1251
    ri8 = 0;
  }
#line 1252
  if (modemap[ymb][xmb + 1] == 4) {
#line 1252
    ri8 = 1;
  } else {
#line 1252
    ri8 = ri8;
  }
#line 1254
  if (pb_frame) {
#line 1256
    ri8 = 0;
#line 1256
    li8 = ri8;
#line 1256
    ti8 = li8;
  }
  {
#line 1261
  if (comp + 1 == 1) {
#line 1261
    goto case_1;
  }
#line 1291
  if (comp + 1 == 2) {
#line 1291
    goto case_2;
  }
#line 1320
  if (comp + 1 == 3) {
#line 1320
    goto case_3;
  }
#line 1344
  if (comp + 1 == 4) {
#line 1344
    goto case_4;
  }
#line 1367
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1262
  if (ti8) {
#line 1262
    if (c8) {
#line 1262
      tmp = 1;
    } else {
#line 1262
      tmp = 0;
    }
#line 1262
    vect = tmp;
  } else {
#line 1262
    if (t8) {
#line 1262
      tmp___0 = 3;
    } else {
#line 1262
      tmp___0 = 0;
    }
#line 1262
    vect = tmp___0;
  }
#line 1263
  if (ti8) {
#line 1263
    yit = ymb;
  } else {
#line 1263
    yit = ymb - 1;
  }
#line 1264
  xit = xmb;
#line 1266
  if (c8) {
#line 1266
    vecb = 3;
  } else {
#line 1266
    vecb = 0;
  }
#line 1267
  yib = ymb;
#line 1268
  xib = xmb;
#line 1270
  if (li8) {
#line 1270
    if (c8) {
#line 1270
      tmp___1 = 1;
    } else {
#line 1270
      tmp___1 = 0;
    }
#line 1270
    vecl = tmp___1;
  } else {
#line 1270
    if (l8) {
#line 1270
      tmp___2 = 2;
    } else {
#line 1270
      tmp___2 = 0;
    }
#line 1270
    vecl = tmp___2;
  }
#line 1271
  yil = ymb;
#line 1272
  if (li8) {
#line 1272
    xil = xmb;
  } else {
#line 1272
    xil = xmb - 1;
  }
#line 1274
  if (c8) {
#line 1274
    vecr = 2;
  } else {
#line 1274
    vecr = 0;
  }
#line 1275
  yir = ymb;
#line 1276
  xir = xmb;
#line 1279
  if (ymb == 1) {
#line 1279
    goto _L;
  } else
#line 1279
  if (newgob___0) {
    _L: /* CIL Label */ 
#line 1281
    yit = ymb;
#line 1282
    if (c8) {
#line 1282
      vect = 1;
    } else {
#line 1282
      vect = 0;
    }
  }
#line 1284
  if (xmb == 1) {
#line 1286
    xil = xmb;
#line 1287
    if (c8) {
#line 1287
      vecl = 1;
    } else {
#line 1287
      vecl = 0;
    }
  }
#line 1289
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1292
  if (ti8) {
#line 1292
    if (c8) {
#line 1292
      tmp___3 = 2;
    } else {
#line 1292
      tmp___3 = 0;
    }
#line 1292
    vect = tmp___3;
  } else {
#line 1292
    if (t8) {
#line 1292
      tmp___4 = 4;
    } else {
#line 1292
      tmp___4 = 0;
    }
#line 1292
    vect = tmp___4;
  }
#line 1293
  if (ti8) {
#line 1293
    yit = ymb;
  } else {
#line 1293
    yit = ymb - 1;
  }
#line 1294
  xit = xmb;
#line 1296
  if (c8) {
#line 1296
    vecb = 4;
  } else {
#line 1296
    vecb = 0;
  }
#line 1297
  yib = ymb;
#line 1298
  xib = xmb;
#line 1299
  if (c8) {
#line 1299
    vecl = 1;
  } else {
#line 1299
    vecl = 0;
  }
#line 1300
  yil = ymb;
#line 1301
  xil = xmb;
#line 1303
  if (ri8) {
#line 1303
    if (c8) {
#line 1303
      tmp___5 = 2;
    } else {
#line 1303
      tmp___5 = 0;
    }
#line 1303
    vecr = tmp___5;
  } else {
#line 1303
    if (r8) {
#line 1303
      tmp___6 = 1;
    } else {
#line 1303
      tmp___6 = 0;
    }
#line 1303
    vecr = tmp___6;
  }
#line 1304
  yir = ymb;
#line 1305
  if (ri8) {
#line 1305
    xir = xmb;
  } else {
#line 1305
    xir = xmb + 1;
  }
#line 1308
  if (ymb == 1) {
#line 1308
    goto _L___0;
  } else
#line 1308
  if (newgob___0) {
    _L___0: /* CIL Label */ 
#line 1310
    yit = ymb;
#line 1311
    if (c8) {
#line 1311
      vect = 2;
    } else {
#line 1311
      vect = 0;
    }
  }
#line 1313
  if (xmb == mb_width) {
#line 1315
    xir = xmb;
#line 1316
    if (c8) {
#line 1316
      vecr = 2;
    } else {
#line 1316
      vecr = 0;
    }
  }
#line 1318
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1321
  if (c8) {
#line 1321
    vect = 1;
  } else {
#line 1321
    vect = 0;
  }
#line 1322
  yit = ymb;
#line 1323
  xit = xmb;
#line 1324
  if (c8) {
#line 1324
    vecb = 3;
  } else {
#line 1324
    vecb = 0;
  }
#line 1325
  yib = ymb;
#line 1326
  xib = xmb;
#line 1328
  if (li8) {
#line 1328
    if (c8) {
#line 1328
      tmp___7 = 3;
    } else {
#line 1328
      tmp___7 = 0;
    }
#line 1328
    vecl = tmp___7;
  } else {
#line 1328
    if (l8) {
#line 1328
      tmp___8 = 4;
    } else {
#line 1328
      tmp___8 = 0;
    }
#line 1328
    vecl = tmp___8;
  }
#line 1329
  yil = ymb;
#line 1330
  if (li8) {
#line 1330
    xil = xmb;
  } else {
#line 1330
    xil = xmb - 1;
  }
#line 1332
  if (c8) {
#line 1332
    vecr = 4;
  } else {
#line 1332
    vecr = 0;
  }
#line 1333
  yir = ymb;
#line 1334
  xir = xmb;
#line 1337
  if (xmb == 1) {
#line 1339
    xil = xmb;
#line 1340
    if (c8) {
#line 1340
      vecl = 3;
    } else {
#line 1340
      vecl = 0;
    }
  }
#line 1342
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1345
  if (c8) {
#line 1345
    vect = 2;
  } else {
#line 1345
    vect = 0;
  }
#line 1346
  yit = ymb;
#line 1347
  xit = xmb;
#line 1348
  if (c8) {
#line 1348
    vecb = 4;
  } else {
#line 1348
    vecb = 0;
  }
#line 1349
  yib = ymb;
#line 1350
  xib = xmb;
#line 1351
  if (c8) {
#line 1351
    vecl = 3;
  } else {
#line 1351
    vecl = 0;
  }
#line 1352
  yil = ymb;
#line 1353
  xil = xmb;
#line 1355
  if (ri8) {
#line 1355
    if (c8) {
#line 1355
      tmp___9 = 4;
    } else {
#line 1355
      tmp___9 = 0;
    }
#line 1355
    vecr = tmp___9;
  } else {
#line 1355
    if (r8) {
#line 1355
      tmp___10 = 3;
    } else {
#line 1355
      tmp___10 = 0;
    }
#line 1355
    vecr = tmp___10;
  }
#line 1356
  yir = ymb;
#line 1357
  if (ri8) {
#line 1357
    xir = xmb;
  } else {
#line 1357
    xir = xmb + 1;
  }
#line 1360
  if (xmb == mb_width) {
#line 1362
    xir = xmb;
#line 1363
    if (c8) {
#line 1363
      vecr = 4;
    } else {
#line 1363
      vecr = 0;
    }
  }
#line 1365
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 1368
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal block number in recon_comp_obmc (recon.c)\n");
  }
  {
#line 1369
  exit(1);
  }
  }
#line 1370
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1373
  if (c8) {
#line 1373
    tmp___11 = comp + 1;
  } else {
#line 1373
    tmp___11 = 0;
  }
#line 1373
  nx[0] = MV[0][tmp___11][ymb][xmb];
#line 1374
  if (c8) {
#line 1374
    tmp___12 = comp + 1;
  } else {
#line 1374
    tmp___12 = 0;
  }
#line 1374
  ny[0] = MV[1][tmp___12][ymb][xmb];
#line 1376
  nx[1] = MV[0][vect][yit][xit];
#line 1377
  ny[1] = MV[1][vect][yit][xit];
#line 1378
  nx[2] = MV[0][vecb][yib][xib];
#line 1379
  ny[2] = MV[1][vecb][yib][xib];
#line 1380
  nx[3] = MV[0][vecr][yir][xir];
#line 1381
  ny[3] = MV[1][vecr][yir][xir];
#line 1382
  nx[4] = MV[0][vecl][yil][xil];
#line 1383
  ny[4] = MV[1][vecl][yil][xil];
#line 1385
  k = 0;
  {
  {
#line 1385
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1385
    if (! (k < 5)) {
#line 1385
      goto while_break;
    }
#line 1387
    xint[k] = nx[k] >> 1;
#line 1388
    xh[k] = nx[k] & 1;
#line 1389
    yint[k] = ny[k] >> 1;
#line 1390
    yh[k] = ny[k] & 1;
#line 1391
    s[k] = ((src + lx2 * (y + yint[k])) + x) + xint[k];
#line 1385
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1394
  d = (dst + lx * y) + x;
#line 1396
  if (! xh[0]) {
#line 1396
    if (! yh[0]) {
      {
      {
#line 1397
      reco(s[0], & p[0], 8, lx2, 0, 0, 0, 8, 0, 8);
      }
      }
    } else {
#line 1396
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1398
  if (! xh[0]) {
#line 1398
    if (yh[0]) {
      {
      {
#line 1399
      recvo(s[0], & p[0], 8, lx2, 0, 0, 0, 8, 0, 8);
      }
      }
    } else {
#line 1398
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1400
  if (xh[0]) {
#line 1400
    if (! yh[0]) {
      {
      {
#line 1401
      recho(s[0], & p[0], 8, lx2, 0, 0, 0, 8, 0, 8);
      }
      }
    } else {
      {
      {
#line 1403
      rec4o(s[0], & p[0], 8, lx2, 0, 0, 0, 8, 0, 8);
      }
      }
    }
  } else {
    {
    {
#line 1403
    rec4o(s[0], & p[0], 8, lx2, 0, 0, 0, 8, 0, 8);
    }
    }
  }
#line 1405
  if (! xh[1]) {
#line 1405
    if (! yh[1]) {
      {
      {
#line 1406
      reco(s[1], & p[0], 8, lx2, 1, 1, 0, 8, 0, 4);
      }
      }
    } else {
#line 1405
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1407
  if (! xh[1]) {
#line 1407
    if (yh[1]) {
      {
      {
#line 1408
      recvo(s[1], & p[0], 8, lx2, 1, 1, 0, 8, 0, 4);
      }
      }
    } else {
#line 1407
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1409
  if (xh[1]) {
#line 1409
    if (! yh[1]) {
      {
      {
#line 1410
      recho(s[1], & p[0], 8, lx2, 1, 1, 0, 8, 0, 4);
      }
      }
    } else {
      {
      {
#line 1412
      rec4o(s[1], & p[0], 8, lx2, 1, 1, 0, 8, 0, 4);
      }
      }
    }
  } else {
    {
    {
#line 1412
    rec4o(s[1], & p[0], 8, lx2, 1, 1, 0, 8, 0, 4);
    }
    }
  }
#line 1414
  if (! xh[2]) {
#line 1414
    if (! yh[2]) {
      {
      {
#line 1415
      reco(s[2] + (lx2 << 2), & p[32], 8, lx2, 1, 2, 0, 8, 4, 8);
      }
      }
    } else {
#line 1414
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 1416
  if (! xh[2]) {
#line 1416
    if (yh[2]) {
      {
      {
#line 1417
      recvo(s[2] + (lx2 << 2), & p[32], 8, lx2, 1, 2, 0, 8, 4, 8);
      }
      }
    } else {
#line 1416
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 1418
  if (xh[2]) {
#line 1418
    if (! yh[2]) {
      {
      {
#line 1419
      recho(s[2] + (lx2 << 2), & p[32], 8, lx2, 1, 2, 0, 8, 4, 8);
      }
      }
    } else {
      {
      {
#line 1421
      rec4o(s[2] + (lx2 << 2), & p[32], 8, lx2, 1, 2, 0, 8, 4, 8);
      }
      }
    }
  } else {
    {
    {
#line 1421
    rec4o(s[2] + (lx2 << 2), & p[32], 8, lx2, 1, 2, 0, 8, 4, 8);
    }
    }
  }
#line 1423
  if (! xh[3]) {
#line 1423
    if (! yh[3]) {
      {
      {
#line 1424
      reco(s[3], & p[0], 8, lx2, 1, 3, 4, 8, 0, 8);
      }
      }
    } else {
#line 1423
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 1425
  if (! xh[3]) {
#line 1425
    if (yh[3]) {
      {
      {
#line 1426
      recvo(s[3], & p[0], 8, lx2, 1, 3, 4, 8, 0, 8);
      }
      }
    } else {
#line 1425
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 1427
  if (xh[3]) {
#line 1427
    if (! yh[3]) {
      {
      {
#line 1428
      recho(s[3], & p[0], 8, lx2, 1, 3, 4, 8, 0, 8);
      }
      }
    } else {
      {
      {
#line 1430
      rec4o(s[3], & p[0], 8, lx2, 1, 3, 4, 8, 0, 8);
      }
      }
    }
  } else {
    {
    {
#line 1430
    rec4o(s[3], & p[0], 8, lx2, 1, 3, 4, 8, 0, 8);
    }
    }
  }
#line 1432
  if (! xh[4]) {
#line 1432
    if (! yh[4]) {
      {
      {
#line 1433
      reco(s[4], & p[0], 8, lx2, 1, 4, 0, 4, 0, 8);
      }
      }
    } else {
#line 1432
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 1434
  if (! xh[4]) {
#line 1434
    if (yh[4]) {
      {
      {
#line 1435
      recvo(s[4], & p[0], 8, lx2, 1, 4, 0, 4, 0, 8);
      }
      }
    } else {
#line 1434
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 1436
  if (xh[4]) {
#line 1436
    if (! yh[4]) {
      {
      {
#line 1437
      recho(s[4], & p[0], 8, lx2, 1, 4, 0, 4, 0, 8);
      }
      }
    } else {
      {
      {
#line 1439
      rec4o(s[4], & p[0], 8, lx2, 1, 4, 0, 4, 0, 8);
      }
      }
    }
  } else {
    {
    {
#line 1439
    rec4o(s[4], & p[0], 8, lx2, 1, 4, 0, 4, 0, 8);
    }
    }
  }
#line 1441
  pd = & p[0];
#line 1442
  j = 0;
  {
  {
#line 1442
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1442
    if (! (j < 8)) {
#line 1442
      goto while_break___0;
    }
#line 1444
    *(d + 0) = (unsigned char )((*(pd + 0) + 4) >> 3);
#line 1445
    *(d + 1) = (unsigned char )((*(pd + 1) + 4) >> 3);
#line 1446
    *(d + 2) = (unsigned char )((*(pd + 2) + 4) >> 3);
#line 1447
    *(d + 3) = (unsigned char )((*(pd + 3) + 4) >> 3);
#line 1448
    *(d + 4) = (unsigned char )((*(pd + 4) + 4) >> 3);
#line 1449
    *(d + 5) = (unsigned char )((*(pd + 5) + 4) >> 3);
#line 1450
    *(d + 6) = (unsigned char )((*(pd + 6) + 4) >> 3);
#line 1451
    *(d + 7) = (unsigned char )((*(pd + 7) + 4) >> 3);
#line 1452
    d += lx;
#line 1453
    pd += 8;
#line 1442
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1456
  return;
}
}
#line 64 "/usr/include/bits/mathcalls.h"
extern double cos(double __x ) ;
#line 157
extern double sqrt(double __x ) ;
#line 185
extern double floor(double __x )  __attribute__((__const__)) ;
#line 82 "idctref.c"
void idctref(short *block ) ;
#line 87 "idctref.c"
static double c[8][8]  ;
#line 91 "idctref.c"
void init_idctref(void) 
{ 
  int freq ;
  int time ;
  double scale ;
  double tmp ;
  double tmp___0 ;

  {
#line 96
  freq = 0;
  {
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 96
    if (! (freq < 8)) {
#line 96
      goto while_break;
    }
#line 98
    if (freq == 0) {
      {
      {
#line 98
      tmp = sqrt(0.125);
      }
#line 98
      scale = tmp;
      }
    } else {
#line 98
      scale = 0.5;
    }
#line 99
    time = 0;
    {
    {
#line 99
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 99
      if (! (time < 8)) {
#line 99
        goto while_break___0;
      }
      {
      {
#line 100
      tmp___0 = cos(((3.14159265358979323846 / 8.0) * (double )freq) * ((double )time + 0.5));
      }
#line 100
      c[freq][time] = scale * tmp___0;
#line 99
      time ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 96
    freq ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 106 "idctref.c"
void idctref(short *block ) 
{ 
  int i ;
  int j ;
  int k ;
  int v ;
  double partial_product ;
  double tmp[64] ;
  double tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;

  {
#line 112
  i = 0;
  {
  {
#line 112
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < 8)) {
#line 112
      goto while_break;
    }
#line 113
    j = 0;
    {
    {
#line 113
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! (j < 8)) {
#line 113
        goto while_break___0;
      }
#line 115
      partial_product = 0.0;
#line 117
      k = 0;
      {
      {
#line 117
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 117
        if (! (k < 8)) {
#line 117
          goto while_break___1;
        }
#line 118
        partial_product += c[k][j] * (double )*(block + (8 * i + k));
#line 117
        k ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 120
      tmp[8 * i + j] = partial_product;
#line 113
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  j = 0;
  {
  {
#line 126
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 126
    if (! (j < 8)) {
#line 126
      goto while_break___2;
    }
#line 127
    i = 0;
    {
    {
#line 127
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 127
      if (! (i < 8)) {
#line 127
        goto while_break___3;
      }
#line 129
      partial_product = 0.0;
#line 131
      k = 0;
      {
      {
#line 131
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 131
        if (! (k < 8)) {
#line 131
          goto while_break___4;
        }
#line 132
        partial_product += c[k][i] * tmp[8 * k + j];
#line 131
        k ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      {
#line 134
      tmp___0 = floor(partial_product + 0.5);
      }
#line 134
      v = (int )tmp___0;
      }
#line 135
      if (v < -256) {
#line 135
        *(block + (8 * i + j)) = (short)-256;
      } else {
#line 135
        if (v > 255) {
#line 135
          tmp___1 = 255;
        } else {
#line 135
          tmp___1 = v;
        }
#line 135
        *(block + (8 * i + j)) = (short )tmp___1;
      }
#line 127
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 126
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 86 "idct.c"
void idct(short *block ) ;
#line 89 "idct.c"
static short iclip[1024]  ;
#line 90 "idct.c"
static short *iclp  ;
#line 93
static void idctrow(short *blk ) ;
#line 94
static void idctcol(short *blk ) ;
#line 103 "idct.c"
static void idctrow(short *blk ) 
{ 
  int x0 ;
  int x1 ;
  int x2 ;
  int x3 ;
  int x4 ;
  int x5 ;
  int x6 ;
  int x7 ;
  int x8 ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;

  {
#line 108
  x1 = (int )*(blk + 4) << 11;
#line 108
  x2 = (int )*(blk + 6);
#line 108
  x3 = (int )*(blk + 2);
#line 108
  x4 = (int )*(blk + 1);
#line 108
  x5 = (int )*(blk + 7);
#line 108
  x6 = (int )*(blk + 5);
#line 108
  x7 = (int )*(blk + 3);
#line 108
  if (! ((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) {
#line 111
    tmp___5 = (short )((int )*(blk + 0) << 3);
#line 111
    *(blk + 7) = tmp___5;
#line 111
    tmp___4 = tmp___5;
#line 111
    *(blk + 6) = tmp___4;
#line 111
    tmp___3 = tmp___4;
#line 111
    *(blk + 5) = tmp___3;
#line 111
    tmp___2 = tmp___3;
#line 111
    *(blk + 4) = tmp___2;
#line 111
    tmp___1 = tmp___2;
#line 111
    *(blk + 3) = tmp___1;
#line 111
    tmp___0 = tmp___1;
#line 111
    *(blk + 2) = tmp___0;
#line 111
    tmp = tmp___0;
#line 111
    *(blk + 1) = tmp;
#line 111
    *(blk + 0) = tmp;
#line 112
    return;
  }
#line 114
  x0 = ((int )*(blk + 0) << 11) + 128;
#line 117
  x8 = 565 * (x4 + x5);
#line 118
  x4 = x8 + 2276 * x4;
#line 119
  x5 = x8 - 3406 * x5;
#line 120
  x8 = 2408 * (x6 + x7);
#line 121
  x6 = x8 - 799 * x6;
#line 122
  x7 = x8 - 4017 * x7;
#line 125
  x8 = x0 + x1;
#line 126
  x0 -= x1;
#line 127
  x1 = 1108 * (x3 + x2);
#line 128
  x2 = x1 - 3784 * x2;
#line 129
  x3 = x1 + 1568 * x3;
#line 130
  x1 = x4 + x6;
#line 131
  x4 -= x6;
#line 132
  x6 = x5 + x7;
#line 133
  x5 -= x7;
#line 136
  x7 = x8 + x3;
#line 137
  x8 -= x3;
#line 138
  x3 = x0 + x2;
#line 139
  x0 -= x2;
#line 140
  x2 = (181 * (x4 + x5) + 128) >> 8;
#line 141
  x4 = (181 * (x4 - x5) + 128) >> 8;
#line 144
  *(blk + 0) = (short )((x7 + x1) >> 8);
#line 145
  *(blk + 1) = (short )((x3 + x2) >> 8);
#line 146
  *(blk + 2) = (short )((x0 + x4) >> 8);
#line 147
  *(blk + 3) = (short )((x8 + x6) >> 8);
#line 148
  *(blk + 4) = (short )((x8 - x6) >> 8);
#line 149
  *(blk + 5) = (short )((x0 - x4) >> 8);
#line 150
  *(blk + 6) = (short )((x3 - x2) >> 8);
#line 151
  *(blk + 7) = (short )((x7 - x1) >> 8);
#line 152
  return;
}
}
#line 160 "idct.c"
static void idctcol(short *blk ) 
{ 
  int x0 ;
  int x1 ;
  int x2 ;
  int x3 ;
  int x4 ;
  int x5 ;
  int x6 ;
  int x7 ;
  int x8 ;
  short tmp ;
  short tmp___0 ;
  short tmp___1 ;
  short tmp___2 ;
  short tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;

  {
#line 165
  x1 = (int )*(blk + 32) << 8;
#line 165
  x2 = (int )*(blk + 48);
#line 165
  x3 = (int )*(blk + 16);
#line 165
  x4 = (int )*(blk + 8);
#line 165
  x5 = (int )*(blk + 56);
#line 165
  x6 = (int )*(blk + 40);
#line 165
  x7 = (int )*(blk + 24);
#line 165
  if (! ((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) {
#line 168
    tmp___5 = *(iclp + (((int )*(blk + 0) + 32) >> 6));
#line 168
    *(blk + 56) = tmp___5;
#line 168
    tmp___4 = tmp___5;
#line 168
    *(blk + 48) = tmp___4;
#line 168
    tmp___3 = tmp___4;
#line 168
    *(blk + 40) = tmp___3;
#line 168
    tmp___2 = tmp___3;
#line 168
    *(blk + 32) = tmp___2;
#line 168
    tmp___1 = tmp___2;
#line 168
    *(blk + 24) = tmp___1;
#line 168
    tmp___0 = tmp___1;
#line 168
    *(blk + 16) = tmp___0;
#line 168
    tmp = tmp___0;
#line 168
    *(blk + 8) = tmp;
#line 168
    *(blk + 0) = tmp;
#line 170
    return;
  }
#line 172
  x0 = ((int )*(blk + 0) << 8) + 8192;
#line 175
  x8 = 565 * (x4 + x5) + 4;
#line 176
  x4 = (x8 + 2276 * x4) >> 3;
#line 177
  x5 = (x8 - 3406 * x5) >> 3;
#line 178
  x8 = 2408 * (x6 + x7) + 4;
#line 179
  x6 = (x8 - 799 * x6) >> 3;
#line 180
  x7 = (x8 - 4017 * x7) >> 3;
#line 183
  x8 = x0 + x1;
#line 184
  x0 -= x1;
#line 185
  x1 = 1108 * (x3 + x2) + 4;
#line 186
  x2 = (x1 - 3784 * x2) >> 3;
#line 187
  x3 = (x1 + 1568 * x3) >> 3;
#line 188
  x1 = x4 + x6;
#line 189
  x4 -= x6;
#line 190
  x6 = x5 + x7;
#line 191
  x5 -= x7;
#line 194
  x7 = x8 + x3;
#line 195
  x8 -= x3;
#line 196
  x3 = x0 + x2;
#line 197
  x0 -= x2;
#line 198
  x2 = (181 * (x4 + x5) + 128) >> 8;
#line 199
  x4 = (181 * (x4 - x5) + 128) >> 8;
#line 202
  *(blk + 0) = *(iclp + ((x7 + x1) >> 14));
#line 203
  *(blk + 8) = *(iclp + ((x3 + x2) >> 14));
#line 204
  *(blk + 16) = *(iclp + ((x0 + x4) >> 14));
#line 205
  *(blk + 24) = *(iclp + ((x8 + x6) >> 14));
#line 206
  *(blk + 32) = *(iclp + ((x8 - x6) >> 14));
#line 207
  *(blk + 40) = *(iclp + ((x0 - x4) >> 14));
#line 208
  *(blk + 48) = *(iclp + ((x3 - x2) >> 14));
#line 209
  *(blk + 56) = *(iclp + ((x7 - x1) >> 14));
#line 210
  return;
}
}
#line 213 "idct.c"
void idct(short *block ) 
{ 
  int i ;

  {
#line 217
  i = 0;
  {
  {
#line 217
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < 8)) {
#line 217
      goto while_break;
    }
    {
    {
#line 218
    idctrow(block + 8 * i);
    }
#line 217
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  i = 0;
  {
  {
#line 220
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (i < 8)) {
#line 220
      goto while_break___0;
    }
    {
    {
#line 221
    idctcol(block + i);
    }
#line 220
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "idct.c"
void init_idct(void) 
{ 
  int i ;
  int tmp ;

  {
#line 228
  iclp = iclip + 512;
#line 229
  i = -512;
  {
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < 512)) {
#line 229
      goto while_break;
    }
#line 230
    if (i < -256) {
#line 230
      *(iclp + i) = (short)-256;
    } else {
#line 230
      if (i > 255) {
#line 230
        tmp = 255;
      } else {
#line 230
        tmp = i;
      }
#line 230
      *(iclp + i) = (short )tmp;
    }
#line 229
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 84 "global.h"
unsigned int getbits1(void) ;
#line 85
void flushbits(int n ) ;
#line 118
int getTMNMV(void) ;
#line 119
int getRVLC(void) ;
#line 120
int getMCBPC(void) ;
#line 121
int getMODB(void) ;
#line 122
int getMCBPCintra(void) ;
#line 123
int getCBPY(void) ;
#line 124
int getMBTYPE(int *cbp_present , int *quant_present ) ;
#line 125
int getscalabilityCBPC(void) ;
#line 72 "getvlc.h"
static VLCtab TMNMVtab0[14]  = 
#line 72 "getvlc.h"
  {      {3, 4}, 
        {61, 4}, 
        {2, 3}, 
        {2, 3}, 
        {62, 3}, 
        {62, 3}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {63, 2}, 
        {63, 2}, 
        {63, 2}, 
        {63, 2}};
#line 77 "getvlc.h"
static VLCtab TMNMVtab1[96]  = 
#line 77
  {      {12, 10}, 
        {52, 10}, 
        {11, 10}, 
        {53, 10}, 
        {10, 9}, 
        {10, 9}, 
        {54, 9}, 
        {54, 9}, 
        {9, 9}, 
        {9, 9}, 
        {55, 9}, 
        {55, 9}, 
        {8, 9}, 
        {8, 9}, 
        {56, 9}, 
        {56, 9}, 
        {7, 7}, 
        {7, 7}, 
        {7, 7}, 
        {7, 7}, 
        {7, 7}, 
        {7, 7}, 
        {7, 7}, 
        {7, 7}, 
        {57, 7}, 
        {57, 7}, 
        {57, 7}, 
        {57, 7}, 
        {57, 7}, 
        {57, 7}, 
        {57, 7}, 
        {57, 7}, 
        {6, 7}, 
        {6, 7}, 
        {6, 7}, 
        {6, 7}, 
        {6, 7}, 
        {6, 7}, 
        {6, 7}, 
        {6, 7}, 
        {58, 7}, 
        {58, 7}, 
        {58, 7}, 
        {58, 7}, 
        {58, 7}, 
        {58, 7}, 
        {58, 7}, 
        {58, 7}, 
        {5, 7}, 
        {5, 7}, 
        {5, 7}, 
        {5, 7}, 
        {5, 7}, 
        {5, 7}, 
        {5, 7}, 
        {5, 7}, 
        {59, 7}, 
        {59, 7}, 
        {59, 7}, 
        {59, 7}, 
        {59, 7}, 
        {59, 7}, 
        {59, 7}, 
        {59, 7}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}, 
        {60, 6}};
#line 96 "getvlc.h"
static VLCtab TMNMVtab2[123]  = 
#line 96
  {      {32, 12}, 
        {31, 12}, 
        {33, 12}, 
        {30, 11}, 
        {30, 11}, 
        {34, 11}, 
        {34, 11}, 
        {29, 11}, 
        {29, 11}, 
        {35, 11}, 
        {35, 11}, 
        {28, 11}, 
        {28, 11}, 
        {36, 11}, 
        {36, 11}, 
        {27, 11}, 
        {27, 11}, 
        {37, 11}, 
        {37, 11}, 
        {26, 11}, 
        {26, 11}, 
        {38, 11}, 
        {38, 11}, 
        {25, 11}, 
        {25, 11}, 
        {39, 11}, 
        {39, 11}, 
        {24, 10}, 
        {24, 10}, 
        {24, 10}, 
        {24, 10}, 
        {40, 10}, 
        {40, 10}, 
        {40, 10}, 
        {40, 10}, 
        {23, 10}, 
        {23, 10}, 
        {23, 10}, 
        {23, 10}, 
        {41, 10}, 
        {41, 10}, 
        {41, 10}, 
        {41, 10}, 
        {22, 10}, 
        {22, 10}, 
        {22, 10}, 
        {22, 10}, 
        {42, 10}, 
        {42, 10}, 
        {42, 10}, 
        {42, 10}, 
        {21, 10}, 
        {21, 10}, 
        {21, 10}, 
        {21, 10}, 
        {43, 10}, 
        {43, 10}, 
        {43, 10}, 
        {43, 10}, 
        {20, 10}, 
        {20, 10}, 
        {20, 10}, 
        {20, 10}, 
        {44, 10}, 
        {44, 10}, 
        {44, 10}, 
        {44, 10}, 
        {19, 10}, 
        {19, 10}, 
        {19, 10}, 
        {19, 10}, 
        {45, 10}, 
        {45, 10}, 
        {45, 10}, 
        {45, 10}, 
        {18, 10}, 
        {18, 10}, 
        {18, 10}, 
        {18, 10}, 
        {46, 10}, 
        {46, 10}, 
        {46, 10}, 
        {46, 10}, 
        {17, 10}, 
        {17, 10}, 
        {17, 10}, 
        {17, 10}, 
        {47, 10}, 
        {47, 10}, 
        {47, 10}, 
        {47, 10}, 
        {16, 10}, 
        {16, 10}, 
        {16, 10}, 
        {16, 10}, 
        {48, 10}, 
        {48, 10}, 
        {48, 10}, 
        {48, 10}, 
        {15, 10}, 
        {15, 10}, 
        {15, 10}, 
        {15, 10}, 
        {49, 10}, 
        {49, 10}, 
        {49, 10}, 
        {49, 10}, 
        {14, 10}, 
        {14, 10}, 
        {14, 10}, 
        {14, 10}, 
        {50, 10}, 
        {50, 10}, 
        {50, 10}, 
        {50, 10}, 
        {13, 10}, 
        {13, 10}, 
        {13, 10}, 
        {13, 10}, 
        {51, 10}, 
        {51, 10}, 
        {51, 10}, 
        {51, 10}};
#line 121 "getvlc.h"
static VLCtab MCBPCtab0[256]  = 
#line 121
  {      {-1, 0}, 
        {255, 9}, 
        {52, 9}, 
        {36, 9}, 
        {20, 9}, 
        {49, 9}, 
        {35, 8}, 
        {35, 8}, 
        {19, 8}, 
        {19, 8}, 
        {50, 8}, 
        {50, 8}, 
        {51, 7}, 
        {51, 7}, 
        {51, 7}, 
        {51, 7}, 
        {34, 7}, 
        {34, 7}, 
        {34, 7}, 
        {34, 7}, 
        {18, 7}, 
        {18, 7}, 
        {18, 7}, 
        {18, 7}, 
        {33, 7}, 
        {33, 7}, 
        {33, 7}, 
        {33, 7}, 
        {17, 7}, 
        {17, 7}, 
        {17, 7}, 
        {17, 7}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {4, 6}, 
        {48, 6}, 
        {48, 6}, 
        {48, 6}, 
        {48, 6}, 
        {48, 6}, 
        {48, 6}, 
        {48, 6}, 
        {48, 6}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {3, 5}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {32, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}};
#line 154 "getvlc.h"
static VLCtab MCBPCtab1[8]  = 
#line 154
  {      {5, 11}, 
        {5, 11}, 
        {5, 11}, 
        {5, 11}, 
        {21, 13}, 
        {21, 13}, 
        {37, 13}, 
        {53, 13}};
#line 159 "getvlc.h"
static VLCtab MBTYPEtabB[96]  = 
#line 159
  {      {-1, 0}, 
        {12, 7}, 
        {11, 6}, 
        {11, 6}, 
        {10, 5}, 
        {10, 5}, 
        {10, 5}, 
        {10, 5}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {8, 5}, 
        {8, 5}, 
        {8, 5}, 
        {8, 5}, 
        {9, 5}, 
        {9, 5}, 
        {9, 5}, 
        {9, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {7, 5}, 
        {7, 5}, 
        {7, 5}, 
        {7, 5}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {5, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {6, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}};
#line 174 "getvlc.h"
static int CBP_present_B[13]  = 
#line 174
  {      1,      1,      0,      1, 
        1,      0,      1,      1, 
        0,      1,      1,      1, 
        1};
#line 175 "getvlc.h"
static int QUANT_present_B[13]  = 
#line 175
  {      0,      1,      0,      0, 
        1,      0,      0,      1, 
        0,      0,      1,      0, 
        1};
#line 176 "getvlc.h"
static int PRED_type_B[13]  = 
#line 176
  {      0,      0,      1,      1, 
        1,      2,      2,      2, 
        3,      3,      3,      4, 
        4};
#line 178 "getvlc.h"
static VLCtab MBTYPEtabEP[128]  = 
#line 178
  {      {-1, 0}, 
        {9, 8}, 
        {8, 7}, 
        {8, 7}, 
        {7, 6}, 
        {7, 6}, 
        {7, 6}, 
        {7, 6}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {6, 5}, 
        {6, 5}, 
        {6, 5}, 
        {6, 5}, 
        {6, 5}, 
        {6, 5}, 
        {6, 5}, 
        {6, 5}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}};
#line 197 "getvlc.h"
static int CBP_present_EP[10]  = 
#line 197
  {      1,      1,      0,      1, 
        1,      0,      1,      1, 
        1,      1};
#line 198 "getvlc.h"
static int QUANT_present_EP[10]  = 
#line 198
  {      0,      1,      0,      0, 
        1,      0,      0,      1, 
        0,      1};
#line 199 "getvlc.h"
static int PRED_type_EP[10]  = 
#line 199
  {      0,      0,      1,      1, 
        1,      2,      2,      2, 
        3,      3};
#line 201 "getvlc.h"
static VLCtab MBTYPEtabEI[128]  = 
#line 201
  {      {-1, 0}, 
        {8, 8}, 
        {5, 7}, 
        {5, 7}, 
        {6, 7}, 
        {6, 7}, 
        {7, 7}, 
        {7, 7}, 
        {-1, 0}, 
        {9, 8}, 
        {10, 8}, 
        {11, 8}, 
        {12, 8}, 
        {13, 8}, 
        {14, 8}, 
        {15, 8}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {1, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}, 
        {3, 3}};
#line 220 "getvlc.h"
static int CBPC_pattern_EI[16]  = 
#line 220
  {      0,      1,      2,      3, 
        0,      1,      2,      3, 
        0,      1,      2,      3, 
        0,      1,      2,      3};
#line 221 "getvlc.h"
static int QUANT_present_EI[16]  = 
#line 221
  {      0,      0,      0,      0, 
        1,      1,      1,      1, 
        0,      0,      0,      0, 
        1,      1,      1,      1};
#line 222 "getvlc.h"
static int PRED_type_EI[16]  = 
#line 222
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        3,      3,      3,      3, 
        3,      3,      3,      3};
#line 224 "getvlc.h"
static VLCtab MCBPCtabintra[32]  = 
#line 224
  {      {-1, 0}, 
        {20, 6}, 
        {36, 6}, 
        {52, 6}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {19, 3}, 
        {19, 3}, 
        {19, 3}, 
        {19, 3}, 
        {19, 3}, 
        {19, 3}, 
        {19, 3}, 
        {19, 3}, 
        {35, 3}, 
        {35, 3}, 
        {35, 3}, 
        {35, 3}, 
        {35, 3}, 
        {35, 3}, 
        {35, 3}, 
        {35, 3}, 
        {51, 3}, 
        {51, 3}, 
        {51, 3}, 
        {51, 3}, 
        {51, 3}, 
        {51, 3}, 
        {51, 3}, 
        {51, 3}};
#line 236 "getvlc.h"
static VLCtab CBPYtab[48]  = 
#line 236
  {      {-1, 0}, 
        {-1, 0}, 
        {9, 6}, 
        {6, 6}, 
        {7, 5}, 
        {7, 5}, 
        {11, 5}, 
        {11, 5}, 
        {13, 5}, 
        {13, 5}, 
        {14, 5}, 
        {14, 5}, 
        {15, 4}, 
        {15, 4}, 
        {15, 4}, 
        {15, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {5, 4}, 
        {5, 4}, 
        {5, 4}, 
        {5, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {1, 4}, 
        {10, 4}, 
        {10, 4}, 
        {10, 4}, 
        {10, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {12, 4}, 
        {12, 4}, 
        {12, 4}, 
        {12, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {4, 4}, 
        {8, 4}, 
        {8, 4}, 
        {8, 4}, 
        {8, 4}};
#line 246 "getvlc.h"
VLCtab DCT3Dtab0[112]  = 
#line 246
  {      {4225, 7}, 
        {4209, 7}, 
        {4193, 7}, 
        {4177, 7}, 
        {193, 7}, 
        {177, 7}, 
        {161, 7}, 
        {4, 7}, 
        {4161, 6}, 
        {4161, 6}, 
        {4145, 6}, 
        {4145, 6}, 
        {4129, 6}, 
        {4129, 6}, 
        {4113, 6}, 
        {4113, 6}, 
        {145, 6}, 
        {145, 6}, 
        {129, 6}, 
        {129, 6}, 
        {113, 6}, 
        {113, 6}, 
        {97, 6}, 
        {97, 6}, 
        {18, 6}, 
        {18, 6}, 
        {3, 6}, 
        {3, 6}, 
        {81, 5}, 
        {81, 5}, 
        {81, 5}, 
        {81, 5}, 
        {65, 5}, 
        {65, 5}, 
        {65, 5}, 
        {65, 5}, 
        {49, 5}, 
        {49, 5}, 
        {49, 5}, 
        {49, 5}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {17, 3}, 
        {33, 4}, 
        {33, 4}, 
        {33, 4}, 
        {33, 4}, 
        {33, 4}, 
        {33, 4}, 
        {33, 4}, 
        {33, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}, 
        {2, 4}};
#line 269 "getvlc.h"
VLCtab DCT3Dtab1[96]  = 
#line 269
  {      {9, 10}, 
        {8, 10}, 
        {4481, 9}, 
        {4481, 9}, 
        {4465, 9}, 
        {4465, 9}, 
        {4449, 9}, 
        {4449, 9}, 
        {4433, 9}, 
        {4433, 9}, 
        {4417, 9}, 
        {4417, 9}, 
        {4401, 9}, 
        {4401, 9}, 
        {4385, 9}, 
        {4385, 9}, 
        {4369, 9}, 
        {4369, 9}, 
        {4098, 9}, 
        {4098, 9}, 
        {353, 9}, 
        {353, 9}, 
        {337, 9}, 
        {337, 9}, 
        {321, 9}, 
        {321, 9}, 
        {305, 9}, 
        {305, 9}, 
        {289, 9}, 
        {289, 9}, 
        {273, 9}, 
        {273, 9}, 
        {257, 9}, 
        {257, 9}, 
        {241, 9}, 
        {241, 9}, 
        {66, 9}, 
        {66, 9}, 
        {50, 9}, 
        {50, 9}, 
        {7, 9}, 
        {7, 9}, 
        {6, 9}, 
        {6, 9}, 
        {4353, 8}, 
        {4353, 8}, 
        {4353, 8}, 
        {4353, 8}, 
        {4337, 8}, 
        {4337, 8}, 
        {4337, 8}, 
        {4337, 8}, 
        {4321, 8}, 
        {4321, 8}, 
        {4321, 8}, 
        {4321, 8}, 
        {4305, 8}, 
        {4305, 8}, 
        {4305, 8}, 
        {4305, 8}, 
        {4289, 8}, 
        {4289, 8}, 
        {4289, 8}, 
        {4289, 8}, 
        {4273, 8}, 
        {4273, 8}, 
        {4273, 8}, 
        {4273, 8}, 
        {4257, 8}, 
        {4257, 8}, 
        {4257, 8}, 
        {4257, 8}, 
        {4241, 8}, 
        {4241, 8}, 
        {4241, 8}, 
        {4241, 8}, 
        {225, 8}, 
        {225, 8}, 
        {225, 8}, 
        {225, 8}, 
        {209, 8}, 
        {209, 8}, 
        {209, 8}, 
        {209, 8}, 
        {34, 8}, 
        {34, 8}, 
        {34, 8}, 
        {34, 8}, 
        {19, 8}, 
        {19, 8}, 
        {19, 8}, 
        {19, 8}, 
        {5, 8}, 
        {5, 8}, 
        {5, 8}, 
        {5, 8}};
#line 289 "getvlc.h"
VLCtab DCT3Dtab2[120]  = 
#line 289
  {      {4114, 11}, 
        {4114, 11}, 
        {4099, 11}, 
        {4099, 11}, 
        {11, 11}, 
        {11, 11}, 
        {10, 11}, 
        {10, 11}, 
        {4545, 10}, 
        {4545, 10}, 
        {4545, 10}, 
        {4545, 10}, 
        {4529, 10}, 
        {4529, 10}, 
        {4529, 10}, 
        {4529, 10}, 
        {4513, 10}, 
        {4513, 10}, 
        {4513, 10}, 
        {4513, 10}, 
        {4497, 10}, 
        {4497, 10}, 
        {4497, 10}, 
        {4497, 10}, 
        {146, 10}, 
        {146, 10}, 
        {146, 10}, 
        {146, 10}, 
        {130, 10}, 
        {130, 10}, 
        {130, 10}, 
        {130, 10}, 
        {114, 10}, 
        {114, 10}, 
        {114, 10}, 
        {114, 10}, 
        {98, 10}, 
        {98, 10}, 
        {98, 10}, 
        {98, 10}, 
        {82, 10}, 
        {82, 10}, 
        {82, 10}, 
        {82, 10}, 
        {51, 10}, 
        {51, 10}, 
        {51, 10}, 
        {51, 10}, 
        {35, 10}, 
        {35, 10}, 
        {35, 10}, 
        {35, 10}, 
        {20, 10}, 
        {20, 10}, 
        {20, 10}, 
        {20, 10}, 
        {12, 11}, 
        {12, 11}, 
        {21, 11}, 
        {21, 11}, 
        {369, 11}, 
        {369, 11}, 
        {385, 11}, 
        {385, 11}, 
        {4561, 11}, 
        {4561, 11}, 
        {4577, 11}, 
        {4577, 11}, 
        {4593, 11}, 
        {4593, 11}, 
        {4609, 11}, 
        {4609, 11}, 
        {22, 12}, 
        {36, 12}, 
        {67, 12}, 
        {83, 12}, 
        {99, 12}, 
        {162, 12}, 
        {401, 12}, 
        {417, 12}, 
        {4625, 12}, 
        {4641, 12}, 
        {4657, 12}, 
        {4673, 12}, 
        {4689, 12}, 
        {4705, 12}, 
        {4721, 12}, 
        {4737, 12}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}};
#line 315 "getvlc.h"
VLCtab INTRA_DCT3Dtab0[112]  = 
#line 315
  {      {4099, 7}, 
        {4353, 7}, 
        {4481, 7}, 
        {4417, 7}, 
        {67, 7}, 
        {130, 7}, 
        {9, 7}, 
        {321, 7}, 
        {4098, 6}, 
        {4098, 6}, 
        {4289, 6}, 
        {4289, 6}, 
        {4225, 6}, 
        {4225, 6}, 
        {4161, 6}, 
        {4161, 6}, 
        {6, 6}, 
        {6, 6}, 
        {7, 6}, 
        {7, 6}, 
        {8, 6}, 
        {8, 6}, 
        {257, 6}, 
        {257, 6}, 
        {66, 6}, 
        {66, 6}, 
        {193, 6}, 
        {193, 6}, 
        {129, 5}, 
        {129, 5}, 
        {129, 5}, 
        {129, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {4, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {5, 5}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {4097, 4}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {1, 2}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {2, 3}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {3, 4}, 
        {65, 4}, 
        {65, 4}, 
        {65, 4}, 
        {65, 4}, 
        {65, 4}, 
        {65, 4}, 
        {65, 4}, 
        {65, 4}};
#line 337 "getvlc.h"
VLCtab INTRA_DCT3Dtab1[96]  = 
#line 337
  {      {705, 10}, 
        {641, 10}, 
        {4101, 9}, 
        {4101, 9}, 
        {4102, 9}, 
        {4102, 9}, 
        {4162, 9}, 
        {4162, 9}, 
        {4226, 9}, 
        {4226, 9}, 
        {5057, 9}, 
        {5057, 9}, 
        {5121, 9}, 
        {5121, 9}, 
        {5249, 9}, 
        {5249, 9}, 
        {5185, 9}, 
        {5185, 9}, 
        {4993, 9}, 
        {4993, 9}, 
        {13, 9}, 
        {13, 9}, 
        {14, 9}, 
        {14, 9}, 
        {15, 9}, 
        {15, 9}, 
        {16, 9}, 
        {16, 9}, 
        {17, 9}, 
        {17, 9}, 
        {18, 9}, 
        {18, 9}, 
        {11, 9}, 
        {11, 9}, 
        {12, 9}, 
        {12, 9}, 
        {322, 9}, 
        {322, 9}, 
        {258, 9}, 
        {258, 9}, 
        {577, 9}, 
        {577, 9}, 
        {513, 9}, 
        {513, 9}, 
        {4100, 8}, 
        {4100, 8}, 
        {4100, 8}, 
        {4100, 8}, 
        {4545, 8}, 
        {4545, 8}, 
        {4545, 8}, 
        {4545, 8}, 
        {4609, 8}, 
        {4609, 8}, 
        {4609, 8}, 
        {4609, 8}, 
        {4929, 8}, 
        {4929, 8}, 
        {4929, 8}, 
        {4929, 8}, 
        {4865, 8}, 
        {4865, 8}, 
        {4865, 8}, 
        {4865, 8}, 
        {4801, 8}, 
        {4801, 8}, 
        {4801, 8}, 
        {4801, 8}, 
        {4737, 8}, 
        {4737, 8}, 
        {4737, 8}, 
        {4737, 8}, 
        {4673, 8}, 
        {4673, 8}, 
        {4673, 8}, 
        {4673, 8}, 
        {10, 8}, 
        {10, 8}, 
        {10, 8}, 
        {10, 8}, 
        {385, 8}, 
        {385, 8}, 
        {385, 8}, 
        {385, 8}, 
        {194, 8}, 
        {194, 8}, 
        {194, 8}, 
        {194, 8}, 
        {68, 8}, 
        {68, 8}, 
        {68, 8}, 
        {68, 8}, 
        {449, 8}, 
        {449, 8}, 
        {449, 8}, 
        {449, 8}};
#line 356 "getvlc.h"
VLCtab INTRA_DCT3Dtab2[120]  = 
#line 356
  {      {5313, 11}, 
        {5313, 11}, 
        {5377, 11}, 
        {5377, 11}, 
        {578, 11}, 
        {578, 11}, 
        {259, 11}, 
        {259, 11}, 
        {4103, 10}, 
        {4103, 10}, 
        {4103, 10}, 
        {4103, 10}, 
        {4163, 10}, 
        {4163, 10}, 
        {4163, 10}, 
        {4163, 10}, 
        {4290, 10}, 
        {4290, 10}, 
        {4290, 10}, 
        {4290, 10}, 
        {4354, 10}, 
        {4354, 10}, 
        {4354, 10}, 
        {4354, 10}, 
        {769, 10}, 
        {769, 10}, 
        {769, 10}, 
        {769, 10}, 
        {132, 10}, 
        {132, 10}, 
        {132, 10}, 
        {132, 10}, 
        {514, 10}, 
        {514, 10}, 
        {514, 10}, 
        {514, 10}, 
        {450, 10}, 
        {450, 10}, 
        {450, 10}, 
        {450, 10}, 
        {386, 10}, 
        {386, 10}, 
        {386, 10}, 
        {386, 10}, 
        {195, 10}, 
        {195, 10}, 
        {195, 10}, 
        {195, 10}, 
        {131, 10}, 
        {131, 10}, 
        {131, 10}, 
        {131, 10}, 
        {69, 10}, 
        {69, 10}, 
        {69, 10}, 
        {69, 10}, 
        {833, 11}, 
        {833, 11}, 
        {70, 11}, 
        {70, 11}, 
        {20, 11}, 
        {20, 11}, 
        {19, 11}, 
        {19, 11}, 
        {4227, 11}, 
        {4227, 11}, 
        {4164, 11}, 
        {4164, 11}, 
        {4105, 11}, 
        {4105, 11}, 
        {4104, 11}, 
        {4104, 11}, 
        {71, 12}, 
        {196, 12}, 
        {323, 12}, 
        {25, 12}, 
        {24, 12}, 
        {23, 12}, 
        {22, 12}, 
        {21, 12}, 
        {5441, 12}, 
        {5505, 12}, 
        {5569, 12}, 
        {4546, 12}, 
        {4482, 12}, 
        {4418, 12}, 
        {4291, 12}, 
        {4106, 12}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}, 
        {7167, 7}};
#line 68 "getvlc.c"
int getTMNMV(void) 
{ 
  int code ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 72
  if (trace) {
    {
    {
#line 73
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"motion_code (");
    }
    }
  }
  {
  {
#line 75
  tmp = getbits1();
  }
  }
#line 75
  if (tmp) {
#line 77
    if (trace) {
      {
      {
#line 78
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1): 0\n");
      }
      }
    }
#line 79
    return (0);
  }
  {
  {
#line 81
  tmp___0 = showbits(12);
  }
#line 81
  code = (int )tmp___0;
  }
#line 81
  if (code >= 512) {
    {
#line 83
    code = (code >> 8) - 2;
    {
#line 84
    flushbits(TMNMVtab0[code].len);
    }
    }
#line 86
    if (trace) {
      {
      {
#line 88
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"0");
      }
      {
#line 89
      printbits(code + 2, 4, TMNMVtab0[code].len);
      }
      {
#line 90
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              TMNMVtab0[code].val);
      }
      }
    }
#line 92
    return (TMNMVtab0[code].val);
  }
#line 94
  if (code >= 128) {
    {
#line 96
    code = (code >> 2) - 32;
    {
#line 97
    flushbits(TMNMVtab1[code].len);
    }
    }
#line 99
    if (trace) {
      {
      {
#line 101
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"0");
      }
      {
#line 102
      printbits(code + 32, 10, TMNMVtab1[code].len);
      }
      {
#line 103
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              TMNMVtab1[code].val);
      }
      }
    }
#line 105
    return (TMNMVtab1[code].val);
  }
#line 107
  code -= 5;
#line 107
  if (code < 0) {
#line 109
    if (! quiet) {
      {
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid motion_vector code\n");
      }
      }
    }
#line 111
    fault = 1;
#line 112
    return (0);
  }
  {
  {
#line 114
  flushbits(TMNMVtab2[code].len);
  }
  }
#line 116
  if (trace) {
    {
    {
#line 118
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"0");
    }
    {
#line 119
    printbits(code + 5, 12, TMNMVtab2[code].len);
    }
    {
#line 120
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
            TMNMVtab2[code].val);
    }
    }
  }
#line 122
  return (TMNMVtab2[code].val);
}
}
#line 139 "getvlc.c"
int getRVLC(void) 
{ 
  int code ;
  int sign ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 142
  code = 0;
#line 144
  if (trace) {
    {
    {
#line 145
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"motion_code (");
    }
    }
  }
  {
  {
#line 147
  tmp = getbits1();
  }
  }
#line 147
  if (tmp) {
#line 149
    if (trace) {
      {
      {
#line 150
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1): 0\n");
      }
      }
    }
#line 151
    return (0);
  }
  {
  {
#line 153
  tmp___0 = getbits(1);
  }
#line 153
  code = (int )(2U + tmp___0);
  }
  {
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 154
    tmp___2 = getbits(1);
    }
    }
#line 154
    if (! tmp___2) {
#line 154
      goto while_break;
    }
    {
#line 156
    code <<= 1;
    {
#line 157
    tmp___1 = getbits(1);
    }
#line 157
    code = (int )((unsigned int )code + tmp___1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  sign = code & 1;
#line 160
  code >>= 1;
#line 161
  if (trace) {
    {
    {
#line 163
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"RVLC");
    }
    }
#line 164
    if (sign) {
#line 164
      tmp___3 = - code;
    } else {
#line 164
      tmp___3 = code;
    }
    {
    {
#line 164
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
            tmp___3);
    }
    }
  }
#line 166
  if (sign) {
#line 166
    tmp___4 = - code;
  } else {
#line 166
    tmp___4 = code;
  }
#line 166
  return (tmp___4);
}
}
#line 169 "getvlc.c"
int getMCBPC(void) 
{ 
  int code ;
  unsigned int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 173
  if (trace) {
    {
    {
#line 174
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MCBPC (");
    }
    }
  }
  {
  {
#line 176
  tmp = showbits(13);
  }
#line 176
  code = (int )tmp;
  }
#line 178
  if (code >> 4 == 1) {
#line 181
    if (trace) {
      {
      {
#line 182
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"000000001): stuffing\n");
      }
      }
    }
    {
    {
#line 183
    flushbits(9);
    }
    }
#line 184
    return (255);
  }
#line 186
  if (code == 0) {
#line 188
    if (! quiet) {
      {
      {
#line 189
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid MCBPC code\n");
      }
      }
    }
#line 190
    fault = 1;
#line 191
    return (0);
  }
#line 193
  if (code >= 4096) {
    {
    {
#line 195
    flushbits(1);
    }
    }
#line 196
    if (trace) {
      {
      {
#line 197
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1): %d\n",
              0);
      }
      }
    }
#line 198
    return (0);
  }
#line 200
  if (code >= 16) {
    {
    {
#line 202
    flushbits(MCBPCtab0[code >> 4].len);
    }
    }
#line 203
    if (trace) {
      {
      {
#line 205
      printbits(code >> 4, 9, MCBPCtab0[code >> 4].len);
      }
      {
#line 206
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              MCBPCtab0[code >> 4].val);
      }
      }
    }
#line 208
    return (MCBPCtab0[code >> 4].val);
  } else {
    {
    {
#line 211
    flushbits(MCBPCtab1[code - 8].len);
    }
    }
#line 212
    if (trace) {
      {
      {
#line 214
      printbits(code, 13, MCBPCtab1[code - 8].len);
      }
      {
#line 215
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              MCBPCtab1[code - 8].val);
      }
      }
    }
#line 217
    return (MCBPCtab1[code - 8].val);
  }
}
}
#line 237 "getvlc.c"
int getMBTYPE(int *cbp_present , int *quant_present ) 
{ 
  int code ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 241
  if (trace) {
    {
    {
#line 242
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MBTYPE (");
    }
    }
  }
  {
  {
#line 244
  tmp = showbits(9);
  }
#line 244
  code = (int )tmp;
  }
#line 246
  if (code == 1) {
#line 249
    if (trace) {
      {
      {
#line 250
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"000000001): stuffing\n");
      }
      }
    }
    {
    {
#line 251
    flushbits(9);
    }
#line 252
    tmp___0 = 0;
#line 252
    *quant_present = tmp___0;
#line 252
    *cbp_present = tmp___0;
    }
#line 253
    return (5);
  }
  {
#line 259
  if (pict_type == 3) {
#line 259
    goto case_3;
  }
#line 296
  if (pict_type == 5) {
#line 296
    goto case_5;
  }
#line 333
  if (pict_type == 4) {
#line 333
    goto case_4;
  }
#line 381
  goto switch_default;
  case_3: /* CIL Label */ 
#line 261
  if (code < 4) {
#line 263
    if (! quiet) {
      {
      {
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid MBTYPE code\n");
      }
      }
    }
#line 265
    fault = 1;
#line 266
    tmp___1 = -1;
#line 266
    *quant_present = tmp___1;
#line 266
    *cbp_present = tmp___1;
#line 267
    return (255);
  }
#line 270
  code >>= 2;
#line 272
  if (code >= 96) {
    {
    {
#line 274
    flushbits(2);
    }
    }
#line 275
    if (trace) {
      {
      {
#line 276
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"11): %d\n",
              0);
      }
      }
    }
#line 277
    *cbp_present = 1;
#line 278
    *quant_present = 0;
#line 279
    return (0);
  } else {
    {
    {
#line 283
    flushbits(MBTYPEtabB[code].len);
    }
    }
#line 284
    if (trace) {
      {
      {
#line 286
      printbits(code, 7, MBTYPEtabB[code].len);
      }
      {
#line 287
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              MBTYPEtabB[code].val);
      }
      }
    }
#line 289
    *cbp_present = CBP_present_B[MBTYPEtabB[code].val];
#line 290
    *quant_present = QUANT_present_B[MBTYPEtabB[code].val];
#line 291
    return (PRED_type_B[MBTYPEtabB[code].val]);
  }
#line 294
  goto switch_break;
  case_5: /* CIL Label */ 
#line 298
  if (code < 2) {
#line 300
    if (! quiet) {
      {
      {
#line 301
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid MBTYPE code\n");
      }
      }
    }
#line 302
    fault = 1;
#line 303
    tmp___2 = -1;
#line 303
    *quant_present = tmp___2;
#line 303
    *cbp_present = tmp___2;
#line 304
    return (255);
  }
#line 307
  code >>= 1;
#line 309
  if (code >= 128) {
    {
    {
#line 311
    flushbits(1);
    }
    }
#line 312
    if (trace) {
      {
      {
#line 313
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1): %d\n",
              0);
      }
      }
    }
#line 314
    *cbp_present = 1;
#line 315
    *quant_present = 0;
#line 316
    return (0);
  } else {
    {
    {
#line 320
    flushbits(MBTYPEtabEP[code].len);
    }
    }
#line 321
    if (trace) {
      {
      {
#line 323
      printbits(code, 8, MBTYPEtabEP[code].len);
      }
      {
#line 324
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              MBTYPEtabEP[code].val);
      }
      }
    }
#line 326
    *cbp_present = CBP_present_EP[MBTYPEtabEP[code].val];
#line 327
    *quant_present = QUANT_present_EP[MBTYPEtabEP[code].val];
#line 328
    return (PRED_type_EP[MBTYPEtabEP[code].val]);
  }
#line 331
  goto switch_break;
  case_4: /* CIL Label */ 
#line 337
  if (code < 2) {
#line 339
    if (! quiet) {
      {
      {
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid MBTYPE code\n");
      }
      }
    }
#line 341
    fault = 1;
#line 342
    tmp___3 = -1;
#line 342
    *quant_present = tmp___3;
#line 342
    *cbp_present = tmp___3;
#line 343
    return (255);
  }
#line 346
  code >>= 1;
#line 348
  if (8 == code) {
#line 350
    if (! quiet) {
      {
      {
#line 351
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid MBTYPE code\n");
      }
      }
    }
#line 352
    fault = 1;
#line 353
    tmp___4 = -1;
#line 353
    *quant_present = tmp___4;
#line 353
    *cbp_present = tmp___4;
#line 354
    return (255);
  }
#line 357
  if (code >= 128) {
    {
    {
#line 359
    flushbits(1);
    }
    }
#line 360
    if (trace) {
      {
      {
#line 361
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1): %d\n",
              0);
      }
      }
    }
#line 362
    *cbp_present = 0;
#line 363
    *quant_present = 0;
#line 364
    return (1);
  } else {
    {
    {
#line 368
    flushbits(MBTYPEtabEI[code].len);
    }
    }
#line 369
    if (trace) {
      {
      {
#line 371
      printbits(code, 8, MBTYPEtabEI[code].len);
      }
      {
#line 372
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
              MBTYPEtabEI[code].val);
      }
      }
    }
#line 374
    *cbp_present = CBPC_pattern_EI[MBTYPEtabEI[code].val];
#line 375
    *quant_present = QUANT_present_EI[MBTYPEtabEI[code].val];
#line 376
    return (PRED_type_EI[MBTYPEtabEI[code].val]);
  }
#line 379
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 383
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 386
  return (0);
}
}
#line 388 "getvlc.c"
int getMODB(void) 
{ 
  int code ;
  int MODB ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 393
  if (trace) {
    {
    {
#line 394
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MODB (");
    }
    }
  }
#line 396
  if (pict_type == 2) {
    {
    {
#line 398
    tmp = getbits(1);
    }
#line 398
    code = (int )tmp;
    }
#line 399
    if (code == 0) {
#line 401
      MODB = 0;
#line 402
      if (trace) {
        {
        {
#line 403
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"0): 0\n");
        }
        }
      }
    } else {
      {
      {
#line 407
      tmp___0 = getbits(1);
      }
#line 407
      code = (int )tmp___0;
      }
#line 408
      if (code == 0) {
#line 410
        MODB = 2;
#line 411
        if (trace) {
          {
          {
#line 412
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"10): 2\n");
          }
          }
        }
      } else {
        {
        {
#line 416
        tmp___1 = getbits(1);
        }
#line 416
        code = (int )tmp___1;
        }
#line 417
        if (code == 0) {
#line 419
          MODB = 6;
#line 420
          if (trace) {
            {
            {
#line 421
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"110): 6\n");
            }
            }
          }
        } else {
          {
          {
#line 425
          tmp___2 = getbits(1);
          }
#line 425
          code = (int )tmp___2;
          }
#line 426
          if (code == 0) {
#line 428
            MODB = 14;
#line 429
            if (trace) {
              {
              {
#line 430
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1110): 14\n");
              }
              }
            }
          } else {
            {
            {
#line 434
            tmp___3 = getbits(1);
            }
#line 434
            code = (int )tmp___3;
            }
#line 435
            if (code == 0) {
#line 437
              MODB = 30;
#line 438
              if (trace) {
                {
                {
#line 439
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"11110): 30\n");
                }
                }
              }
            } else {
#line 443
              MODB = 31;
#line 444
              if (trace) {
                {
                {
#line 445
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"11111): 31\n");
                }
                }
              }
            }
          }
        }
      }
    }
  } else {
    {
    {
#line 453
    tmp___4 = showbits(2);
    }
#line 453
    code = (int )tmp___4;
    }
#line 455
    if (code < 2) {
#line 457
      if (trace) {
        {
        {
#line 458
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"0): 0\n");
        }
        }
      }
      {
#line 459
      MODB = 0;
      {
#line 460
      flushbits(1);
      }
      }
    } else
#line 461
    if (code == 2) {
#line 463
      if (trace) {
        {
        {
#line 464
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"10): 1\n");
        }
        }
      }
      {
#line 465
      MODB = 1;
      {
#line 466
      flushbits(2);
      }
      }
    } else {
#line 470
      if (trace) {
        {
        {
#line 471
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"11): 2\n");
        }
        }
      }
      {
#line 472
      MODB = 2;
      {
#line 473
      flushbits(2);
      }
      }
    }
  }
#line 477
  return (MODB);
}
}
#line 482 "getvlc.c"
int getMCBPCintra(void) 
{ 
  int code ;
  unsigned int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 486
  if (trace) {
    {
    {
#line 487
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MCBPCintra (");
    }
    }
  }
  {
  {
#line 489
  tmp = showbits(9);
  }
#line 489
  code = (int )tmp;
  }
#line 491
  if (code == 1) {
#line 494
    if (trace) {
      {
      {
#line 495
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"000000001): stuffing\n");
      }
      }
    }
    {
    {
#line 496
    flushbits(9);
    }
    }
#line 497
    return (255);
  }
#line 500
  if (code < 8) {
#line 502
    if (! quiet) {
      {
      {
#line 503
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid MCBPCintra code\n");
      }
      }
    }
#line 504
    fault = 1;
#line 505
    return (0);
  }
#line 507
  code >>= 3;
#line 509
  if (code >= 32) {
    {
    {
#line 511
    flushbits(1);
    }
    }
#line 512
    if (trace) {
      {
      {
#line 513
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"1): %d\n",
              3);
      }
      }
    }
#line 514
    return (3);
  }
  {
  {
#line 516
  flushbits(MCBPCtabintra[code].len);
  }
  }
#line 518
  if (trace) {
    {
    {
#line 520
    printbits(code, 6, MCBPCtabintra[code].len);
    }
    {
#line 521
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
            MCBPCtabintra[code].val);
    }
    }
  }
#line 523
  return (MCBPCtabintra[code].val);
}
}
#line 527 "getvlc.c"
int getscalabilityCBPC(void) 
{ 
  int code ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 531
  if (trace) {
    {
    {
#line 532
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"CBPC: ");
    }
    }
  }
  {
  {
#line 534
  tmp = showbits(1);
  }
#line 534
  code = (int )tmp;
  }
#line 536
  if (0 == code) {
#line 538
    if (trace) {
      {
      {
#line 539
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"0 - Blocks 56: 00\n");
      }
      }
    }
    {
    {
#line 540
    flushbits(1);
    }
    }
#line 541
    return (0);
  } else {
    {
    {
#line 544
    tmp___0 = showbits(2);
    }
#line 544
    code = (int )tmp___0;
    }
#line 546
    if (2 == code) {
#line 548
      if (trace) {
        {
        {
#line 549
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"10 - Blocks 56: 01\n");
        }
        }
      }
      {
      {
#line 550
      flushbits(2);
      }
      }
#line 551
      return (1);
    } else {
      {
      {
#line 554
      tmp___1 = showbits(3);
      }
#line 554
      code = (int )tmp___1;
      }
#line 556
      if (6 == code) {
#line 558
        if (trace) {
          {
          {
#line 559
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"110 - Blocks 56: 11\n");
          }
          }
        }
        {
        {
#line 560
        flushbits(3);
        }
        }
#line 561
        return (3);
      } else
#line 562
      if (7 == code) {
#line 564
        if (trace) {
          {
          {
#line 565
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"111 - Blocks 56: 10\n");
          }
          }
        }
        {
        {
#line 566
        flushbits(3);
        }
        }
#line 567
        return (2);
      } else {
#line 570
        if (! quiet) {
          {
          {
#line 571
          printf((char const   */* __restrict  */)"Invalid chromiance CBP in getscalabilityCBPC (getvlc.c).\n");
          }
          }
        }
#line 572
        fault = 1;
#line 573
        return (0);
      }
    }
  }
}
}
#line 579 "getvlc.c"
int getCBPY(void) 
{ 
  int code ;
  unsigned int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 583
  if (trace) {
    {
    {
#line 584
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"CBPY (");
    }
    }
  }
  {
  {
#line 586
  tmp = showbits(6);
  }
#line 586
  code = (int )tmp;
  }
#line 587
  if (code < 2) {
#line 589
    if (! quiet) {
      {
      {
#line 590
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid CBPY code\n");
      }
      }
    }
#line 591
    fault = 1;
#line 592
    return (-1);
  }
#line 594
  if (code >= 48) {
    {
    {
#line 596
    flushbits(2);
    }
    }
#line 597
    if (trace) {
      {
      {
#line 598
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"11): %d\n",
              0);
      }
      }
    }
#line 599
    return (0);
  }
  {
  {
#line 601
  flushbits(CBPYtab[code].len);
  }
  }
#line 603
  if (trace) {
    {
    {
#line 605
    printbits(code, 6, CBPYtab[code].len);
    }
    {
#line 606
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
            CBPYtab[code].val);
    }
    }
  }
#line 608
  return (CBPYtab[code].val);
}
}
#line 211 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 558 "/usr/include/stdlib.h"
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 89 "global.h"
void getblock(int comp , int mode , int INTRA_AC_DC , int Mode ) ;
#line 90
void get_sac_block(int comp , int ptype , int INTRA_AC_DC , int Mode ) ;
#line 94
void startcode(void) ;
#line 96
void getgobheader(void) ;
#line 100
void PictureDisplay(int *framenum ) ;
#line 103
void UpsampleReferenceLayerPicture(void) ;
#line 104
void UpsampleComponent(unsigned char *enhanced , unsigned char *base___0 , int horiz ,
                       int vert ) ;
#line 107
void Intra_AC_DC_Decode(short *store_qcoeff , int INTRA_AC_DC , int MBA , int xpos ,
                        int ypos , int comp , int newgob___0 ) ;
#line 108
void fill_null(int *pred ) ;
#line 109
void fill_A(int *pred , short *store_qcoeff , int xpos , int ypos , int block ) ;
#line 110
void fill_B(int *pred , short *store_qcoeff , int xpos , int ypos , int block ) ;
#line 111
int oddifyclipDC(int x ) ;
#line 112
int clipAC(int x ) ;
#line 113
int clipDC(int x ) ;
#line 98 "indices.h"
int codtab[2] ;
#line 99
int mcbpctab[21] ;
#line 100
int mcbpctab_4mvq[25] ;
#line 101
int mcbpc_intratab[9] ;
#line 102
int modb_tab_G[3] ;
#line 103
int modb_tab_M[6] ;
#line 104
int ycbpb_tab[2] ;
#line 105
int uvcbpb_tab[2] ;
#line 106
int cbpytab[16] ;
#line 107
int cbpy_intratab[16] ;
#line 108
int dquanttab[4] ;
#line 109
int mvdtab[64] ;
#line 110
int intradctab[254] ;
#line 117
int intra_ac_dctab[3] ;
#line 128 "sactbls.h"
int cumf_COD[3] ;
#line 129
int cumf_MCBPC_no4MVQ[22] ;
#line 130
int cumf_MCBPC_4MVQ[26] ;
#line 131
int cumf_MCBPC_intra[10] ;
#line 132
int cumf_MODB_G[4] ;
#line 133
int cumf_MODB_M[7] ;
#line 134
int cumf_YCBPB[3] ;
#line 135
int cumf_UVCBPB[3] ;
#line 136
int cumf_CBPY[17] ;
#line 137
int cumf_CBPY_intra[17] ;
#line 138
int cumf_DQUANT[5] ;
#line 139
int cumf_MVD[65] ;
#line 140
int cumf_INTRADC[255] ;
#line 156
int cumf_INTRA_AC_DC[4] ;
#line 74 "getpic.c"
static int coded_map[73][89]  ;
#line 75 "getpic.c"
static int quant_map[73][89]  ;
#line 76 "getpic.c"
static int STRENGTH[31]  = 
#line 76
  {      1,      1,      2,      2, 
        3,      3,      4,      4, 
        4,      5,      5,      6, 
        6,      7,      7,      7, 
        8,      8,      8,      9, 
        9,      9,      10,      10, 
        10,      11,      11,      11, 
        12,      12,      12};
#line 77 "getpic.c"
static int STRENGTH1[31]  = 
#line 77
  {      1,      1,      1,      1, 
        1,      2,      2,      2, 
        2,      2,      2,      3, 
        3,      3,      3,      3, 
        3,      3,      3,      3, 
        3,      3,      3,      4, 
        4,      4,      4,      4, 
        4,      4,      4};
#line 78 "getpic.c"
static int STRENGTH2[31]  = 
#line 78
  {      1,      1,      1,      1, 
        1,      1,      1,      2, 
        2,      2,      2,      2, 
        2,      2,      3,      3, 
        3,      3,      3,      3, 
        3,      3,      3,      3, 
        3,      3,      3,      3, 
        3,      3,      3};
#line 82
static void get_I_P_MBs(int framenum , int gob ) ;
#line 83
static void get_B_MBs(int framenum ) ;
#line 84
static void get_EI_EP_MBs(int framenum ) ;
#line 85
static void clearblock(int comp ) ;
#line 86
static int motion_decode(int vec , int pmv ) ;
#line 87
static int find_pmv(int x , int y , int block , int comp ) ;
#line 88
static void addblock(int comp , int bx , int by , int addflag ) ;
#line 89
static void reconblock_b(int comp , int bx , int by , int mode , int bdx , int bdy ) ;
#line 90
static void find_bidir_limits(int vec , int *start , int *stop , int nhv ) ;
#line 91
static void find_bidir_chroma_limits(int vec , int *start , int *stop ) ;
#line 92
static void make_edge_image(unsigned char *src , unsigned char *dst , int width ,
                            int height , int edge ) ;
#line 93
static void init_enhancement_layer(int layer ) ;
#line 94
void edge_filter(unsigned char *lum , unsigned char *Cb , unsigned char *Cr , int width ,
                 int height ) ;
#line 95
void horiz_edge_filter(unsigned char *rec___0 , int width , int height , int chr ) ;
#line 96
void vert_edge_filter(unsigned char *rec___0 , int width , int height , int chr ) ;
#line 97
void vert_post_filter(unsigned char *rec___0 , int width , int height , int chr ) ;
#line 98
void horiz_post_filter(unsigned char *rec___0 , int width , int height , int chr ) ;
#line 99
void PostFilter(unsigned char *lum , unsigned char *Cb , unsigned char *Cr , int width ,
                int height ) ;
#line 106
void conceal_missing_gobs(int start_mb_row_missing , int number_of_mb_rows_missing ) ;
#line 119 "getpic.c"
void getpicture(int *framenum , int gob ) 
{ 
  unsigned char *tmp ;
  int i ;
  int store_pb ;
  int quality ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 122
  quality = 0;
  {
#line 132
  if (pict_type == 2) {
#line 132
    goto case_2;
  }
#line 132
  if (pict_type == 6) {
#line 132
    goto case_2;
  }
#line 132
  if (pict_type == 1) {
#line 132
    goto case_2;
  }
#line 132
  if (pict_type == 0) {
#line 132
    goto case_2;
  }
#line 240
  if (pict_type == 3) {
#line 240
    goto case_3;
  }
#line 271
  if (pict_type == 5) {
#line 271
    goto case_5;
  }
#line 271
  if (pict_type == 4) {
#line 271
    goto case_5;
  }
#line 327
  goto switch_default;
  case_2: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 134
  enhance_pict = 0;
#line 136
  if (0 == UFEP) {
#line 136
    if (plus_type) {
#line 138
      mv_outside_frame = prev_mv_outside_frame;
#line 140
      deblocking_filter_mode = prev_df;
#line 142
      adv_pred_mode = prev_adv_pred;
#line 144
      overlapping_MC = prev_obmc;
#line 145
      use_4mv = prev_4mv;
#line 146
      long_vectors = prev_long_vectors;
#line 148
      syntax_arith_coding = prev_sac;
#line 150
      advanced_intra_coding = prev_aic;
#line 152
      slice_structured_mode = prev_slice_struct;
#line 154
      reference_picture_selection_mode = prev_rps;
#line 156
      independently_segmented_decoding_mode = prev_isd;
#line 158
      alternative_inter_VLC_mode = prev_aivlc;
#line 160
      modified_quantization_mode = prev_mq;
    }
  }
#line 163
  i = 0;
  {
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < 3)) {
#line 163
      goto while_break;
    }
#line 165
    tmp = prev_frame[i];
#line 166
    tmp___0 = next_I_P_frame[i];
#line 166
    prev_frame[i] = tmp___0;
#line 166
    prev_I_P_frame[i] = tmp___0;
#line 167
    tmp___1 = tmp;
#line 167
    current_frame[i] = tmp___1;
#line 167
    next_I_P_frame[i] = tmp___1;
#line 163
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  if (reference_picture_selection_mode) {
    {
    {
#line 175
    quality = get_reference_picture();
    }
    }
#line 175
    if (-1 == quality) {
#line 176
      goto switch_break;
    }
#line 177
    if (quality > 256) {
      {
      {
#line 179
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"completely out of sync -- waiting for I-frame\n");
      }
#line 180
      stop_decoder = 1;
      }
#line 181
      goto switch_break;
    }
  }
#line 191
  if (mv_outside_frame) {
#line 191
    if (*framenum > 0) {
      {
      {
#line 193
      make_edge_image(prev_I_P_frame[0], edgeframe[0], coded_picture_width, coded_picture_height,
                      32);
      }
      {
#line 195
      make_edge_image(prev_I_P_frame[1], edgeframe[1], chrom_width, chrom_height,
                      16);
      }
      {
#line 196
      make_edge_image(prev_I_P_frame[2], edgeframe[2], chrom_width, chrom_height,
                      16);
      }
      }
    }
  }
  {
  {
#line 199
  get_I_P_MBs(*framenum, gob);
  }
#line 201
  store_pb = pb_frame;
#line 202
  pb_frame = 0;
  }
#line 204
  if (deblocking_filter_mode) {
    {
    {
#line 205
    edge_filter(current_frame[0], current_frame[1], current_frame[2], coded_picture_width,
                coded_picture_height);
    }
    }
  }
#line 208
  pb_frame = store_pb;
#line 210
  if (pb_frame) {
#line 212
    if (deblocking_filter_mode) {
      {
      {
#line 213
      edge_filter(bframe[0], bframe[1], bframe[2], coded_picture_width, coded_picture_height);
      }
      }
    }
  }
  {
  {
#line 217
  PictureDisplay(framenum);
  }
  }
#line 218
  if (reference_picture_selection_mode) {
#line 219
    if (pict_type == 0) {
#line 219
      tmp___2 = 0;
    } else {
#line 219
      tmp___2 = quality;
    }
    {
    {
#line 219
    store_picture(tmp___2);
    }
    }
  }
#line 221
  if (1 == UFEP) {
#line 223
    prev_mv_outside_frame = mv_outside_frame;
#line 224
    prev_sac = syntax_arith_coding;
#line 225
    prev_adv_pred = adv_pred_mode;
#line 226
    prev_aic = advanced_intra_coding;
#line 227
    prev_df = deblocking_filter_mode;
#line 228
    prev_slice_struct = slice_structured_mode;
#line 229
    prev_rps = reference_picture_selection_mode;
#line 230
    prev_isd = independently_segmented_decoding_mode;
#line 231
    prev_aivlc = alternative_inter_VLC_mode;
#line 232
    prev_mq = modified_quantization_mode;
#line 233
    prev_long_vectors = long_vectors;
#line 234
    prev_obmc = overlapping_MC;
#line 235
    prev_4mv = use_4mv;
  }
#line 238
  goto switch_break;
  case_3: /* CIL Label */ 
#line 242
  if (enhancement_layer_num > 1) {
#line 243
    enhance_pict = 1;
  } else {
#line 245
    enhance_pict = 0;
  }
#line 247
  i = 0;
  {
  {
#line 247
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 247
    if (! (i < 3)) {
#line 247
      goto while_break___0;
    }
#line 249
    current_frame[i] = bframe[i];
#line 247
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 253
  make_edge_image(prev_I_P_frame[0], edgeframe[0], coded_picture_width, coded_picture_height,
                  32);
  }
  {
#line 255
  make_edge_image(prev_I_P_frame[1], edgeframe[1], chrom_width, chrom_height, 16);
  }
  {
#line 256
  make_edge_image(prev_I_P_frame[2], edgeframe[2], chrom_width, chrom_height, 16);
  }
  {
#line 259
  make_edge_image(next_I_P_frame[0], nextedgeframe[0], coded_picture_width, coded_picture_height,
                  32);
  }
  {
#line 261
  make_edge_image(next_I_P_frame[1], nextedgeframe[1], chrom_width, chrom_height,
                  16);
  }
  {
#line 262
  make_edge_image(next_I_P_frame[2], nextedgeframe[2], chrom_width, chrom_height,
                  16);
  }
  {
#line 264
  get_B_MBs(*framenum);
  }
  {
#line 266
  PictureDisplay(framenum);
  }
  }
#line 268
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 273
  enhance_pict = 1;
#line 275
  if (! enhancement_layer_init[enhancement_layer_num - 2]) {
    {
    {
#line 277
    init_enhancement_layer(enhancement_layer_num - 2);
    }
#line 278
    enhancement_layer_init[enhancement_layer_num - 2] = 1;
    }
  }
#line 281
  i = 0;
  {
  {
#line 281
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 281
    if (! (i < 3)) {
#line 281
      goto while_break___1;
    }
#line 283
    tmp = prev_enhancement_frame[enhancement_layer_num - 2][i];
#line 284
    prev_enhancement_frame[enhancement_layer_num - 2][i] = current_enhancement_frame[enhancement_layer_num - 2][i];
#line 286
    current_enhancement_frame[enhancement_layer_num - 2][i] = tmp;
#line 281
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 289
  if (scalability_mode >= 3) {
    {
    {
#line 291
    UpsampleReferenceLayerPicture();
    }
#line 292
    curr_reference_frame[0] = upsampled_reference_frame[0];
#line 293
    curr_reference_frame[1] = upsampled_reference_frame[1];
#line 294
    curr_reference_frame[2] = upsampled_reference_frame[2];
    }
  } else {
#line 298
    curr_reference_frame[0] = current_frame[0];
#line 299
    curr_reference_frame[1] = current_frame[1];
#line 300
    curr_reference_frame[2] = current_frame[2];
  }
  {
  {
#line 303
  make_edge_image(prev_enhancement_frame[enhancement_layer_num - 2][0], enhance_edgeframe[enhancement_layer_num - 2][0],
                  coded_picture_width, coded_picture_height, 32);
  }
  {
#line 306
  make_edge_image(prev_enhancement_frame[enhancement_layer_num - 2][1], enhance_edgeframe[enhancement_layer_num - 2][1],
                  chrom_width, chrom_height, 16);
  }
  {
#line 309
  make_edge_image(prev_enhancement_frame[enhancement_layer_num - 2][2], enhance_edgeframe[enhancement_layer_num - 2][2],
                  chrom_width, chrom_height, 16);
  }
  {
#line 313
  get_EI_EP_MBs(*framenum);
  }
  }
#line 315
  if (deblocking_filter_mode) {
    {
    {
#line 316
    edge_filter(current_enhancement_frame[enhancement_layer_num - 2][0], current_enhancement_frame[enhancement_layer_num - 2][1],
                current_enhancement_frame[enhancement_layer_num - 2][2], coded_picture_width,
                coded_picture_height);
    }
    }
  }
  {
  {
#line 321
  store_one(enhance_recon_file_name[enhancement_layer_num - 2], current_enhancement_frame[enhancement_layer_num - 2],
            0, coded_picture_width, vertical_size);
  }
  }
#line 325
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 329
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 332
  return;
}
}
#line 335 "getpic.c"
static int change_of_quant_tab_10[32]  = 
#line 335
  {      0,      2,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -2, 
        -2,      -2,      -2,      -2, 
        -2,      -2,      -2,      -2, 
        -2,      -3,      -3,      -3, 
        -3,      -3,      -3,      -3, 
        -3,      -3,      -3,      -3};
#line 336 "getpic.c"
static int change_of_quant_tab_11[32]  = 
#line 336
  {      0,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      2, 
        2,      2,      2,      2, 
        2,      2,      2,      2, 
        2,      3,      3,      3, 
        3,      3,      3,      3, 
        3,      2,      1,      -5};
#line 338 "getpic.c"
static void get_I_P_MBs(int framenum , int gob ) 
{ 
  int comp ;
  int MBA ;
  int MBAmax ;
  int bx ;
  int by ;
  int COD ;
  int MCBPC ;
  int CBPY ;
  int CBP ;
  int CBPB ;
  int MODB ;
  int Mode ;
  int DQUANT ;
  int COD_index ;
  int CBPY_index ;
  int MODB_index ;
  int DQUANT_index ;
  int MCBPC_index ;
  int INTRADC_index ;
  int YCBPB_index ;
  int UVCBPB_index ;
  int mvdbx_index ;
  int mvdby_index ;
  int mvx ;
  int mvy ;
  int mvy_index ;
  int mvx_index ;
  int pmv0 ;
  int pmv1 ;
  int xpos ;
  int ypos ;
  int i ;
  int k ;
  int mvdbx ;
  int mvdby ;
  int pmvdbx ;
  int pmvdby ;
  int YCBPB ;
  int UVCBPB ;
  int gobheader_read ;
  int startmv ;
  int stopmv ;
  int offset ;
  int bsize ;
  int last_done ;
  int pCBP ;
  int pCBPB ;
  int pCOD ;
  int pMODB ;
  int DQ_tab[4] ;
  short *bp ;
  int long_vectors_bak ;
  int tmp ;
  int pnewgob ;
  int pypos ;
  int start_mb_row_missing ;
  int number_of_mb_rows_missing ;
  int INTRA_AC_DC ;
  int INTRA_AC_DC_index ;
  short *store_qcoeff ;
  int quality ;
  int decode_last_mb ;
  int dont_reconstruct_next_mb ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int tmp___21 ;
  void *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;

  {
#line 344
  COD = 0;
#line 344
  CBP = 0;
#line 344
  CBPB = 0;
#line 344
  MODB = 0;
#line 344
  Mode = 0;
#line 347
  mvx = 0;
#line 347
  mvy = 0;
#line 348
  mvdbx = 0;
#line 348
  mvdby = 0;
#line 349
  last_done = 0;
#line 349
  pCBP = 0;
#line 349
  pCBPB = 0;
#line 349
  pCOD = 0;
#line 349
  pMODB = 0;
#line 350
  DQ_tab[0] = -1;
#line 350
  DQ_tab[1] = -2;
#line 350
  DQ_tab[2] = 1;
#line 350
  DQ_tab[3] = 2;
#line 353
  tmp = 0;
#line 354
  pnewgob = 0;
#line 357
  pypos = 0;
#line 362
  INTRA_AC_DC = 0;
#line 364
  quality = 0;
#line 365
  decode_last_mb = 0;
#line 369
  MBAmax = mb_width * mb_height;
#line 370
  gob --;
#line 372
  MBA = 0;
#line 373
  newgob = 0;
#line 374
  ypos = 0;
#line 374
  xpos = ypos;
#line 377
  i = 1;
  {
  {
#line 377
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < mb_width + 1)) {
#line 377
      goto while_break;
    }
#line 379
    k = 0;
    {
    {
#line 379
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! (k < 5)) {
#line 379
        goto while_break___0;
      }
#line 381
      MV[0][k][0][i] = 999;
#line 382
      MV[1][k][0][i] = 999;
#line 379
      k ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 384
    modemap[0][i] = 3;
#line 377
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  i = 0;
  {
  {
#line 387
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 387
    if (! (i < mb_height + 1)) {
#line 387
      goto while_break___1;
    }
#line 389
    k = 0;
    {
    {
#line 389
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 389
      if (! (k < 5)) {
#line 389
        goto while_break___2;
      }
#line 391
      MV[0][k][i][0] = 0;
#line 392
      MV[1][k][i][0] = 0;
#line 393
      MV[0][k][i][mb_width + 1] = 0;
#line 394
      MV[1][k][i][mb_width + 1] = 0;
#line 389
      k ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 396
    modemap[i][0] = 3;
#line 397
    modemap[i][mb_width + 1] = 3;
#line 387
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 400
  if (advanced_intra_coding) {
    {
    {
#line 403
    tmp___0 = calloc((size_t )((64 * MBAmax) * blk_cnt), (size_t )sizeof(short ));
    }
#line 403
    store_qcoeff = (short *)tmp___0;
    }
#line 403
    if ((unsigned long )store_qcoeff == (unsigned long )((short *)0)) {
      {
      {
#line 405
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getMB(): Couldn\'t allocate store_qcoeff.\n");
      }
      {
#line 406
      exit(-1);
      }
      }
    }
  }
#line 409
  fault = 0;
#line 410
  gobheader_read = 0;
#line 413
  if (gob) {
#line 413
    goto getgobhrd;
  }
  {
  {
#line 415
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 418
    if (MBA >= MBAmax) {
      {
      {
#line 421
      memcpy((void */* __restrict  */)(anchorframemodemap), (void const   */* __restrict  */)(modemap),
             (size_t )((sizeof(int ) * 73UL) * 90UL));
      }
      }
#line 422
      return;
    }
#line 425
    if (trace) {
      {
      {
#line 426
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"frame %d, MB %d\n",
              framenum, MBA);
      }
      }
    }
    resync: 
#line 434
    if (fault) {
      {
      {
#line 436
      printf((char const   */* __restrict  */)"Warning: A Fault Condition Has Occurred - Resyncing \n");
      }
      {
#line 437
      startcode();
      }
#line 438
      fault = 0;
      }
    }
    {
    {
#line 440
    tmp___5 = showbits(22);
    }
    }
#line 440
    if (! (tmp___5 >> 6)) {
      {
      {
#line 443
      startcode();
      }
      {
#line 447
      tmp___4 = showbits(22);
      }
      }
#line 447
      if (tmp___4 == 63U) {
#line 450
        if (syntax_arith_coding) {
#line 450
          if (! (MBA < MBAmax)) {
#line 452
            return;
          }
        } else {
#line 452
          return;
        }
      } else {
        {
        {
#line 455
        tmp___3 = showbits(22);
        }
        }
#line 455
        if (tmp___3 == (unsigned int )(1 << 5)) {
#line 459
          if (concealment) {
#line 459
            if (MBA < MBAmax) {
#line 462
              number_of_mb_rows_missing = (MBAmax - MBA) / mb_width;
#line 463
              start_mb_row_missing = MBA / mb_width;
#line 464
              decode_last_mb = 1;
#line 465
              pypos = ypos;
            } else {
#line 459
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 467
          if (syntax_arith_coding) {
#line 467
            if (! (MBA < MBAmax)) {
#line 469
              return;
            }
          } else {
#line 469
            return;
          }
        } else
#line 474
        if (syntax_arith_coding) {
#line 474
          if (! (MBA % mb_width)) {
#line 474
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 476
          if (syntax_arith_coding) {
            {
            {
#line 480
            tmp___1 = showbits(22);
            }
#line 480
            gob = (int )(tmp___1 & 31U);
            }
#line 481
            if (gob * mb_width != MBA) {
#line 482
              goto finish_gob;
            }
          }
          {
          {
#line 484
          tmp___2 = getheader();
          }
#line 484
          gob = tmp___2 - 1;
          }
#line 485
          if (gob > mb_height) {
#line 487
            if (! quiet) {
              {
              {
#line 488
              printf((char const   */* __restrict  */)"GN out of range\n");
              }
              }
            }
#line 489
            return;
          }
          getgobhrd: 
          {
          {
#line 497
          getgobheader();
          }
          }
#line 503
          if (reference_picture_selection_mode) {
            {
            {
#line 505
            quality = get_reference_picture();
            }
            }
#line 505
            if (-1 == quality) {
#line 506
              goto while_break___3;
            }
#line 507
            if (quality > 256) {
              {
              {
#line 509
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"completely out of sync -- waiting for I-frame\n");
              }
#line 510
              stop_decoder = 1;
              }
#line 511
              goto while_break___3;
            }
#line 513
            if (mv_outside_frame) {
#line 513
              if (framenum > 0) {
                {
                {
#line 515
                make_edge_image(prev_I_P_frame[0], edgeframe[0], coded_picture_width,
                                coded_picture_height, 32);
                }
                {
#line 517
                make_edge_image(prev_I_P_frame[1], edgeframe[1], chrom_width, chrom_height,
                                16);
                }
                {
#line 518
                make_edge_image(prev_I_P_frame[2], edgeframe[2], chrom_width, chrom_height,
                                16);
                }
                }
              }
            }
          }
#line 524
          if (concealment) {
#line 524
            if (gob * mb_width != MBA) {
#line 531
              if (gob - MBA / mb_width < 0) {
#line 533
                framenum ++;
#line 534
                number_of_mb_rows_missing = (MBAmax - MBA) / mb_width;
              } else {
#line 536
                number_of_mb_rows_missing = gob - MBA / mb_width;
              }
#line 537
              start_mb_row_missing = MBA / mb_width;
#line 538
              decode_last_mb = 1;
#line 539
              pypos = ypos;
            }
          }
#line 542
          xpos = 0;
#line 543
          ypos = gob;
#line 544
          MBA = ypos * mb_width;
#line 546
          newgob = 1;
#line 547
          gobheader_read = 1;
#line 548
          if (syntax_arith_coding) {
            {
            {
#line 549
            decoder_reset();
            }
            }
          }
        }
      }
    }
#line 555
    if (decode_last_mb) {
#line 557
      if (! start_mb_row_missing) {
#line 560
        goto conceal_gob;
      } else {
#line 564
        xpos = 0;
#line 565
        pypos ++;
#line 565
        ypos = pypos;
#line 566
        COD = 1;
#line 567
        goto reconstruct_mb;
      }
    }
#line 570
    dont_reconstruct_next_mb = 0;
    finish_gob: 
#line 575
    if (! gobheader_read) {
#line 577
      xpos = MBA % mb_width;
#line 578
      ypos = MBA / mb_width;
#line 579
      if (xpos == 0) {
#line 579
        if (ypos > 0) {
#line 580
          newgob = 0;
        }
      }
    } else {
#line 584
      gobheader_read = 0;
    }
    read_cod: 
#line 589
    if (syntax_arith_coding) {
#line 591
      if (pict_type == 1) {
#line 591
        goto _L___1;
      } else
#line 591
      if (pict_type == 2) {
        _L___1: /* CIL Label */ 
        {
        {
#line 593
        COD_index = decode_a_symbol(cumf_COD);
        }
#line 594
        COD = codtab[COD_index];
        }
#line 595
        if (trace) {
          {
          {
#line 597
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"Arithmetic Decoding Debug \n");
          }
          {
#line 598
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"COD Index: %d COD: %d \n",
                  COD_index, COD);
          }
          }
        }
      } else {
#line 603
        COD = 0;
#line 604
        coded_map[ypos + 1][xpos + 1] = 1;
      }
    } else
#line 609
    if (1 == pict_type) {
#line 609
      goto _L___2;
    } else
#line 609
    if (2 == pict_type) {
      _L___2: /* CIL Label */ 
      {
      {
#line 611
      tmp___6 = showbits(1);
      }
#line 611
      COD = (int )tmp___6;
      }
#line 612
      if (trace) {
        {
        {
#line 614
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"COD : %d \n",
                COD);
        }
        }
      }
    } else {
#line 619
      COD = 0;
#line 620
      coded_map[ypos + 1][xpos + 1] = 1;
    }
#line 624
    if (! COD) {
#line 627
      if (syntax_arith_coding) {
#line 629
        if (pict_type == 1) {
#line 629
          goto _L___3;
        } else
#line 629
        if (pict_type == 2) {
          _L___3: /* CIL Label */ 
#line 631
          if (plus_type) {
            {
            {
#line 633
            MCBPC_index = decode_a_symbol(cumf_MCBPC_4MVQ);
            }
#line 634
            MCBPC = mcbpctab_4mvq[MCBPC_index];
            }
          } else {
            {
            {
#line 638
            MCBPC_index = decode_a_symbol(cumf_MCBPC_no4MVQ);
            }
#line 639
            MCBPC = mcbpctab[MCBPC_index];
            }
          }
        } else {
          {
          {
#line 644
          MCBPC_index = decode_a_symbol(cumf_MCBPC_intra);
          }
#line 645
          MCBPC = mcbpc_intratab[MCBPC_index];
          }
        }
#line 647
        if (trace) {
          {
          {
#line 648
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MCBPC Index: %d MCBPC: %d \n",
                  MCBPC_index, MCBPC);
          }
          }
        }
      } else {
#line 652
        if (1 == pict_type) {
          {
          {
#line 655
          flushbits(1);
          }
          }
        } else
#line 652
        if (2 == pict_type) {
          {
          {
#line 655
          flushbits(1);
          }
          }
        }
#line 657
        if (0 == pict_type) {
          {
          {
#line 659
          MCBPC = getMCBPCintra();
          }
          }
        } else {
          {
          {
#line 663
          MCBPC = getMCBPC();
          }
          }
        }
      }
#line 667
      if (fault) {
#line 668
        goto resync;
      }
#line 670
      if (MCBPC == 255) {
#line 673
        goto read_cod;
      } else {
#line 678
        Mode = MCBPC & 7;
#line 679
        if (advanced_intra_coding) {
#line 679
          if (Mode == 3) {
#line 679
            goto _L___4;
          } else
#line 679
          if (Mode == 4) {
            _L___4: /* CIL Label */ 
#line 682
            if (syntax_arith_coding) {
              {
              {
#line 684
              INTRA_AC_DC_index = decode_a_symbol(cumf_INTRA_AC_DC);
              }
#line 685
              INTRA_AC_DC = intra_ac_dctab[INTRA_AC_DC_index];
              }
            } else {
              {
              {
#line 690
              tmp___9 = showbits(1);
              }
              }
#line 690
              if (tmp___9) {
                {
                {
#line 693
                tmp___8 = getbits(2);
                }
#line 693
                INTRA_AC_DC = (int )tmp___8;
                }
              } else {
                {
                {
#line 691
                tmp___7 = getbits(1);
                }
#line 691
                INTRA_AC_DC = (int )tmp___7;
                }
              }
            }
#line 695
            if (trace) {
              {
              {
#line 696
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"INTRA_AC_DC: %d\n",
                      INTRA_AC_DC);
              }
              }
            }
          }
        }
#line 700
        if (pb_frame) {
#line 702
          CBPB = 0;
#line 703
          if (syntax_arith_coding) {
#line 705
            if (pb_frame == 1) {
              {
              {
#line 707
              MODB_index = decode_a_symbol(cumf_MODB_G);
              }
#line 708
              MODB = modb_tab_G[MODB_index];
              }
            } else {
              {
              {
#line 712
              MODB_index = decode_a_symbol(cumf_MODB_M);
              }
#line 713
              MODB = modb_tab_M[MODB_index];
              }
            }
          } else {
            {
            {
#line 717
            MODB = getMODB();
            }
            }
          }
#line 719
          if (MODB == 2) {
#line 719
            if (pb_frame == 1) {
#line 719
              goto _L___6;
            } else {
#line 719
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 719
          if (pb_frame == 2) {
#line 719
            if (MODB == 14) {
#line 719
              goto _L___6;
            } else
#line 719
            if (MODB == 2) {
#line 719
              goto _L___6;
            } else
#line 719
            if (MODB == 31) {
              _L___6: /* CIL Label */ 
#line 724
              if (syntax_arith_coding) {
#line 726
                i = 0;
                {
                {
#line 726
                while (1) {
                  while_continue___19: /* CIL Label */ ;
                  while_continue___4: /* CIL Label */ ;
#line 726
                  if (! (i < 4)) {
#line 726
                    goto while_break___4;
                  }
                  {
                  {
#line 728
                  YCBPB_index = decode_a_symbol(cumf_YCBPB);
                  }
#line 729
                  YCBPB = ycbpb_tab[YCBPB_index];
#line 730
                  CBPB |= YCBPB << (5 - i);
#line 726
                  i ++;
                  }
                }
                while_break___19: /* CIL Label */ ;
                }
                while_break___4: /* CIL Label */ ;
                }
#line 732
                i = 4;
                {
                {
#line 732
                while (1) {
                  while_continue___20: /* CIL Label */ ;
                  while_continue___5: /* CIL Label */ ;
#line 732
                  if (! (i < 6)) {
#line 732
                    goto while_break___5;
                  }
                  {
                  {
#line 734
                  UVCBPB_index = decode_a_symbol(cumf_UVCBPB);
                  }
#line 735
                  UVCBPB = uvcbpb_tab[UVCBPB_index];
#line 736
                  CBPB |= UVCBPB << (5 - i);
#line 732
                  i ++;
                  }
                }
                while_break___20: /* CIL Label */ ;
                }
                while_break___5: /* CIL Label */ ;
                }
              } else {
                {
                {
#line 740
                tmp___10 = getbits(6);
                }
#line 740
                CBPB = (int )tmp___10;
                }
              }
#line 742
              if (trace) {
                {
                {
#line 743
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"CBPB = %d\n",
                        CBPB);
                }
                }
              }
            }
          }
        }
#line 747
        if (syntax_arith_coding) {
#line 749
          if (Mode == 3) {
            {
            {
#line 752
            CBPY_index = decode_a_symbol(cumf_CBPY_intra);
            }
#line 753
            CBPY = cbpy_intratab[CBPY_index];
            }
          } else
#line 749
          if (Mode == 4) {
            {
            {
#line 752
            CBPY_index = decode_a_symbol(cumf_CBPY_intra);
            }
#line 753
            CBPY = cbpy_intratab[CBPY_index];
            }
          } else {
            {
            {
#line 757
            CBPY_index = decode_a_symbol(cumf_CBPY);
            }
#line 758
            CBPY = cbpytab[CBPY_index];
            }
          }
#line 761
          if (trace) {
            {
            {
#line 762
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"CBPY Index: %d CBPY %d \n",
                    CBPY_index, CBPY);
            }
            }
          }
        } else {
          {
          {
#line 766
          CBPY = getCBPY();
          }
          }
        }
      }
#line 771
      if (Mode == 3) {
#line 771
        goto _L___8;
      } else
#line 771
      if (Mode == 4) {
        _L___8: /* CIL Label */ 
#line 774
        coded_map[ypos + 1][xpos + 1] = 1;
#line 776
        if (! syntax_arith_coding) {
#line 777
          CBPY ^= 15;
        }
      } else
#line 779
      if (! syntax_arith_coding) {
#line 779
        if (alternative_inter_VLC_mode) {
#line 779
          if (MCBPC >> 4 == 3) {
#line 780
            CBPY ^= 15;
          }
        }
      }
#line 782
      CBP = (CBPY << 2) | (MCBPC >> 4);
#line 784
      if (Mode == 2) {
#line 784
        goto _L___9;
      } else
#line 784
      if (Mode == 5) {
        _L___9: /* CIL Label */ 
#line 784
        if (! use_4mv) {
#line 786
          fault = 1;
#line 787
          if (! quiet) {
            {
            {
#line 790
            printf((char const   */* __restrict  */)"8x8 vectors not allowed in normal prediction mode\n");
            }
            }
          }
#line 792
          if (trace) {
            {
            {
#line 793
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"8x8 vectors not allowed in normal prediction mode\n");
            }
            }
          }
        }
      }
#line 796
      if (Mode == 1) {
#line 796
        goto _L___11;
      } else
#line 796
      if (Mode == 4) {
#line 796
        goto _L___11;
      } else
#line 796
      if (Mode == 5) {
        _L___11: /* CIL Label */ 
#line 799
        if (syntax_arith_coding) {
          {
          {
#line 801
          DQUANT_index = decode_a_symbol(cumf_DQUANT);
          }
#line 802
          DQUANT = dquanttab[DQUANT_index] - 2;
#line 803
          quant += DQUANT;
          }
#line 804
          if (trace) {
            {
            {
#line 805
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT Index: %d DQUANT %d \n",
                    DQUANT_index, DQUANT);
            }
            }
          }
        } else
#line 809
        if (! modified_quantization_mode) {
          {
          {
#line 811
          tmp___11 = getbits(2);
          }
#line 811
          DQUANT = (int )tmp___11;
#line 812
          quant += DQ_tab[DQUANT];
          }
#line 813
          if (trace) {
            {
            {
#line 815
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (");
            }
            {
#line 816
            printbits(DQUANT, 2, 2);
            }
            {
#line 817
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d = %d\n",
                    DQUANT, DQ_tab[DQUANT]);
            }
            }
          }
        } else {
          {
          {
#line 822
          tmp___12 = getbits(1);
          }
#line 822
          tmp = (int )tmp___12;
          }
#line 823
          if (tmp) {
            {
            {
#line 826
            tmp___13 = getbits(1);
            }
#line 826
            tmp = (int )tmp___13;
            }
#line 827
            if (tmp) {
#line 830
              DQUANT = change_of_quant_tab_11[quant];
            } else {
#line 835
              DQUANT = change_of_quant_tab_10[quant];
            }
#line 837
            quant += DQUANT;
#line 838
            if (trace) {
              {
              {
#line 840
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (1");
              }
              {
#line 841
              printbits(tmp, 1, 1);
              }
              {
#line 842
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d \n",
                      DQUANT);
              }
              }
            }
          } else {
            {
            {
#line 849
            tmp___14 = getbits(5);
            }
#line 849
            DQUANT = (int )tmp___14;
#line 850
            quant = DQUANT;
            }
#line 851
            if (trace) {
              {
              {
#line 853
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (");
              }
              {
#line 854
              printbits(DQUANT, 5, 5);
              }
              {
#line 855
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d \n",
                      DQUANT);
              }
              }
            }
          }
        }
#line 861
        if (quant > 31) {
#line 861
          goto _L___10;
        } else
#line 861
        if (quant < 1) {
          _L___10: /* CIL Label */ 
#line 863
          if (! quiet) {
            {
            {
#line 864
            printf((char const   */* __restrict  */)"Quantizer out of range: clipping\n");
            }
            }
          }
#line 865
          if (31 < quant) {
#line 865
            tmp___17 = 31;
          } else {
#line 865
            tmp___17 = quant;
          }
#line 865
          if (1 > tmp___17) {
#line 865
            quant = 1;
          } else {
#line 865
            if (31 < quant) {
#line 865
              tmp___16 = 31;
            } else {
#line 865
              tmp___16 = quant;
            }
#line 865
            quant = tmp___16;
          }
#line 867
          fault = 1;
        }
      }
#line 872
      if (Mode == 0) {
#line 872
        goto _L___19;
      } else
#line 872
      if (Mode == 1) {
#line 872
        goto _L___19;
      } else
#line 872
      if (Mode == 2) {
#line 872
        goto _L___19;
      } else
#line 872
      if (Mode == 5) {
#line 872
        goto _L___19;
      } else
#line 872
      if (pb_frame) {
        _L___19: /* CIL Label */ 
#line 875
        if (Mode == 2) {
#line 877
          startmv = 1;
#line 878
          stopmv = 4;
        } else
#line 875
        if (Mode == 5) {
#line 877
          startmv = 1;
#line 878
          stopmv = 4;
        } else {
#line 882
          startmv = 0;
#line 883
          stopmv = 0;
        }
#line 886
        k = startmv;
        {
        {
#line 886
        while (1) {
          while_continue___21: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 886
          if (! (k <= stopmv)) {
#line 886
            goto while_break___6;
          }
#line 888
          if (syntax_arith_coding) {
            {
            {
#line 890
            mvx_index = decode_a_symbol(cumf_MVD);
            }
#line 891
            mvx = mvdtab[mvx_index];
            {
#line 892
            mvy_index = decode_a_symbol(cumf_MVD);
            }
#line 893
            mvy = mvdtab[mvy_index];
            }
#line 894
            if (trace) {
              {
              {
#line 895
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvx_index: %d mvy_index: %d \n",
                      mvy_index, mvx_index);
              }
              }
            }
          } else
#line 899
          if (plus_type) {
#line 899
            if (long_vectors) {
              {
              {
#line 901
              mvx = getRVLC();
              }
              {
#line 902
              mvy = getRVLC();
              }
              }
#line 905
              if (mvx == 1) {
#line 905
                if (mvy == 1) {
                  {
                  {
#line 906
                  flushbits(1);
                  }
                  }
                }
              }
            } else {
              {
              {
#line 910
              mvx = getTMNMV();
              }
              {
#line 911
              mvy = getTMNMV();
              }
              }
            }
          } else {
            {
            {
#line 910
            mvx = getTMNMV();
            }
            {
#line 911
            mvy = getTMNMV();
            }
            }
          }
          {
          {
#line 915
          pmv0 = find_pmv(xpos, ypos, k, 0);
          }
          {
#line 916
          pmv1 = find_pmv(xpos, ypos, k, 1);
          }
          }
#line 918
          if (plus_type) {
#line 918
            if (long_vectors) {
#line 918
              if (! syntax_arith_coding) {
#line 920
                mvx += pmv0;
#line 921
                mvy += pmv1;
              } else {
                {
                {
#line 925
                mvx = motion_decode(mvx, pmv0);
                }
                {
#line 926
                mvy = motion_decode(mvy, pmv1);
                }
                }
              }
            } else {
              {
              {
#line 925
              mvx = motion_decode(mvx, pmv0);
              }
              {
#line 926
              mvy = motion_decode(mvy, pmv1);
              }
              }
            }
          } else {
            {
            {
#line 925
            mvx = motion_decode(mvx, pmv0);
            }
            {
#line 926
            mvy = motion_decode(mvy, pmv1);
            }
            }
          }
#line 929
          if (trace) {
            {
            {
#line 931
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvx: %d\n",
                    mvx);
            }
            {
#line 932
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvy: %d\n",
                    mvy);
            }
            }
          }
#line 935
          coded_map[ypos + 1][xpos + 1] = 1;
#line 938
          if (! mv_outside_frame) {
#line 940
            if (k) {
#line 940
              bsize = 8;
            } else {
#line 940
              bsize = 16;
            }
#line 941
            if (k) {
#line 941
              offset = ((k - 1) & 1) << 3;
            } else {
#line 941
              offset = 0;
            }
#line 943
            if (((xpos << 4) + mvx / 2) + offset < 0) {
#line 943
              goto _L___12;
            } else
#line 943
            if (((xpos << 4) + mvx / 2) + offset > (mb_width << 4) - bsize) {
              _L___12: /* CIL Label */ 
#line 946
              if (! quiet) {
                {
                {
#line 947
                printf((char const   */* __restrict  */)"mvx out of range: searching for sync\n");
                }
                }
              }
#line 948
              fault = 1;
            }
#line 950
            if (k) {
#line 950
              offset = ((k - 1) & 2) << 2;
            } else {
#line 950
              offset = 0;
            }
#line 951
            if (((ypos << 4) + mvy / 2) + offset < 0) {
#line 951
              goto _L___13;
            } else
#line 951
            if (((ypos << 4) + mvy / 2) + offset > (mb_height << 4) - bsize) {
              _L___13: /* CIL Label */ 
#line 954
              if (! quiet) {
                {
                {
#line 955
                printf((char const   */* __restrict  */)"mvy out of range: searching for sync\n");
                }
                }
              }
#line 956
              fault = 1;
            }
          }
#line 959
          tmp___18 = mvx;
#line 959
          MV[0][k][ypos + 1][xpos + 1] = tmp___18;
#line 959
          true_B_direct_mode_MV[0][k][ypos + 1][xpos + 1] = tmp___18;
#line 960
          tmp___19 = mvy;
#line 960
          MV[1][k][ypos + 1][xpos + 1] = tmp___19;
#line 960
          true_B_direct_mode_MV[1][k][ypos + 1][xpos + 1] = tmp___19;
#line 886
          k ++;
        }
        while_break___21: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 964
        if (pb_frame) {
#line 966
          if (MODB == 1) {
#line 966
            goto _L___18;
          } else
#line 966
          if (MODB == 2) {
            _L___18: /* CIL Label */ 
#line 966
            if (pb_frame == 1) {
#line 966
              goto _L___16;
            } else {
#line 966
              goto _L___17;
            }
          } else
          _L___17: /* CIL Label */ 
#line 966
          if (pb_frame == 2) {
#line 966
            if (MODB == 14) {
#line 966
              goto _L___16;
            } else
#line 966
            if (MODB == 6) {
              _L___16: /* CIL Label */ 
#line 969
              if (syntax_arith_coding) {
                {
                {
#line 971
                mvdbx_index = decode_a_symbol(cumf_MVD);
                }
#line 972
                mvdbx = mvdtab[mvdbx_index];
                {
#line 973
                mvdby_index = decode_a_symbol(cumf_MVD);
                }
#line 974
                mvdby = mvdtab[mvdby_index];
                }
              } else
#line 978
              if (plus_type) {
#line 978
                if (long_vectors) {
                  {
                  {
#line 980
                  mvdbx = getRVLC();
                  }
                  {
#line 981
                  mvdby = getRVLC();
                  }
                  }
#line 984
                  if (mvdbx == 1) {
#line 984
                    if (mvdby == 1) {
                      {
                      {
#line 985
                      flushbits(1);
                      }
                      }
                    }
                  }
                } else {
                  {
                  {
#line 989
                  mvdbx = getTMNMV();
                  }
                  {
#line 990
                  mvdby = getTMNMV();
                  }
                  }
                }
              } else {
                {
                {
#line 989
                mvdbx = getTMNMV();
                }
                {
#line 990
                mvdby = getTMNMV();
                }
                }
              }
#line 994
              long_vectors_bak = long_vectors;
#line 998
              pmv0 = 0;
#line 999
              pmv1 = 0;
#line 1000
              if (pb_frame == 2) {
#line 1000
                if (MODB == 14) {
#line 1000
                  goto _L___14;
                } else
#line 1000
                if (MODB == 6) {
                  _L___14: /* CIL Label */ 
#line 1003
                  long_vectors = 0;
#line 1004
                  if (MBA % mb_width) {
#line 1004
                    if (pMODB == 14) {
#line 1008
                      pmv0 = pmvdbx;
#line 1009
                      pmv1 = pmvdby;
                    } else
#line 1004
                    if (pMODB == 6) {
#line 1008
                      pmv0 = pmvdbx;
#line 1009
                      pmv1 = pmvdby;
                    }
                  }
                }
              }
#line 1012
              if (plus_type) {
#line 1012
                if (long_vectors) {
#line 1012
                  if (! syntax_arith_coding) {
#line 1014
                    mvdbx += pmv0;
#line 1015
                    mvdby += pmv1;
                  } else {
                    {
                    {
#line 1019
                    mvdbx = motion_decode(mvdbx, pmv0);
                    }
                    {
#line 1020
                    mvdby = motion_decode(mvdby, pmv1);
                    }
                    }
                  }
                } else {
                  {
                  {
#line 1019
                  mvdbx = motion_decode(mvdbx, pmv0);
                  }
                  {
#line 1020
                  mvdby = motion_decode(mvdby, pmv1);
                  }
                  }
                }
              } else {
                {
                {
#line 1019
                mvdbx = motion_decode(mvdbx, pmv0);
                }
                {
#line 1020
                mvdby = motion_decode(mvdby, pmv1);
                }
                }
              }
#line 1023
              long_vectors = long_vectors_bak;
#line 1033
              if (trace) {
                {
                {
#line 1035
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MVDB x: %d\n",
                        mvdbx);
                }
                {
#line 1036
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"MVDB y: %d\n",
                        mvdby);
                }
                }
              }
            } else {
#line 1041
              mvdbx = 0;
#line 1042
              mvdby = 0;
            }
          } else {
#line 1041
            mvdbx = 0;
#line 1042
            mvdby = 0;
          }
        }
      } else
#line 1051
      if (1 == pict_type) {
#line 1053
        k = 0;
        {
        {
#line 1053
        while (1) {
          while_continue___22: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 1053
          if (! (k < 5)) {
#line 1053
            goto while_break___7;
          }
#line 1055
          true_B_direct_mode_MV[0][k][ypos + 1][xpos + 1] = 0;
#line 1056
          true_B_direct_mode_MV[1][k][ypos + 1][xpos + 1] = 0;
#line 1053
          k ++;
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1060
      if (fault) {
#line 1061
        goto resync;
      }
    } else {
#line 1066
      if (MBA >= MBAmax) {
        {
        {
#line 1069
        memcpy((void */* __restrict  */)(anchorframemodemap), (void const   */* __restrict  */)(modemap),
               (size_t )((sizeof(int ) * 73UL) * 90UL));
        }
        }
#line 1070
        return;
      }
#line 1072
      if (! syntax_arith_coding) {
#line 1073
        if (1 == pict_type) {
          {
          {
#line 1074
          flushbits(1);
          }
          }
        } else
#line 1073
        if (2 == pict_type) {
          {
          {
#line 1074
          flushbits(1);
          }
          }
        }
      }
#line 1076
      Mode = 0;
#line 1078
      CBPB = 0;
#line 1078
      CBP = CBPB;
#line 1079
      coded_map[ypos + 1][xpos + 1] = 0;
#line 1082
      MV[0][0][ypos + 1][xpos + 1] = 0;
#line 1083
      MV[1][0][ypos + 1][xpos + 1] = 0;
#line 1085
      if (1 == pict_type) {
#line 1087
        k = 0;
        {
        {
#line 1087
        while (1) {
          while_continue___23: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
#line 1087
          if (! (k < 5)) {
#line 1087
            goto while_break___8;
          }
#line 1089
          true_B_direct_mode_MV[0][k][ypos + 1][xpos + 1] = 0;
#line 1090
          true_B_direct_mode_MV[1][k][ypos + 1][xpos + 1] = 0;
#line 1087
          k ++;
        }
        while_break___23: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 1093
      mvdbx = 0;
#line 1094
      mvdby = 0;
    }
#line 1098
    modemap[ypos + 1][xpos + 1] = Mode;
#line 1101
    if (advanced_intra_coding) {
#line 1103
      i = 0;
      {
      {
#line 1103
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 1103
        if (! (i < blk_cnt)) {
#line 1103
          goto while_break___9;
        }
#line 1104
        *(store_qcoeff + ((MBA * blk_cnt) * 64 + i * 64)) = (short)1024;
#line 1103
        i ++;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 1106
    if (Mode == 3) {
#line 1106
      goto _L___20;
    } else
#line 1106
    if (Mode == 4) {
      _L___20: /* CIL Label */ 
#line 1108
      if (! pb_frame) {
#line 1110
        tmp___20 = 0;
#line 1110
        MV[1][0][ypos + 1][xpos + 1] = tmp___20;
#line 1110
        MV[0][0][ypos + 1][xpos + 1] = tmp___20;
      }
    }
    reconstruct_mb: 
#line 1118
    if (xpos > 0) {
#line 1120
      bx = 16 * (xpos - 1);
#line 1121
      by = 16 * ypos;
    } else {
#line 1125
      bx = coded_picture_width - 16;
#line 1126
      by = 16 * (ypos - 1);
    }
#line 1129
    if (MBA > 0) {
#line 1129
      if (! dont_reconstruct_next_mb) {
#line 1131
        Mode = modemap[by / 16 + 1][bx / 16 + 1];
#line 1134
        if (pb_frame) {
#line 1136
          if (pCOD) {
            {
#line 1139
            pMODB = 0;
            {
#line 1140
            reconstruct(bx, by, 0, pmvdbx, pmvdby, 0, pnewgob);
            }
            }
          } else
#line 1144
          if (pb_frame == 2) {
#line 1144
            if (! (pMODB == 31)) {
#line 1144
              if (! (pMODB == 30)) {
                {
                {
#line 1145
                reconstruct(bx, by, 0, pmvdbx, pmvdby, pMODB, pnewgob);
                }
                }
              }
            }
          } else {
            {
            {
#line 1145
            reconstruct(bx, by, 0, pmvdbx, pmvdby, pMODB, pnewgob);
            }
            }
          }
        }
#line 1150
        if (Mode == 0) {
          {
          {
#line 1153
          reconstruct(bx, by, 1, 0, 0, pMODB, pnewgob);
          }
          }
        } else
#line 1150
        if (Mode == 1) {
          {
          {
#line 1153
          reconstruct(bx, by, 1, 0, 0, pMODB, pnewgob);
          }
          }
        } else
#line 1150
        if (Mode == 2) {
          {
          {
#line 1153
          reconstruct(bx, by, 1, 0, 0, pMODB, pnewgob);
          }
          }
        } else
#line 1150
        if (Mode == 5) {
          {
          {
#line 1153
          reconstruct(bx, by, 1, 0, 0, pMODB, pnewgob);
          }
          }
        }
#line 1157
        comp = 0;
        {
        {
#line 1157
        while (1) {
          while_continue___25: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
#line 1157
          if (! (comp < blk_cnt)) {
#line 1157
            goto while_break___10;
          }
#line 1160
          if (Mode == 3) {
#line 1160
            goto _L___21;
          } else
#line 1160
          if (Mode == 4) {
            _L___21: /* CIL Label */ 
#line 1162
            if (refidct) {
              {
              {
#line 1163
              idctref(ld->block[comp]);
              }
              }
            } else {
              {
              {
#line 1165
              idct(ld->block[comp]);
              }
              }
            }
            {
            {
#line 1166
            addblock(comp, bx, by, 0);
            }
            }
          } else
#line 1168
          if (pCBP & (1 << ((blk_cnt - 1) - comp))) {
#line 1171
            if (refidct) {
              {
              {
#line 1172
              idctref(ld->block[comp]);
              }
              }
            } else {
              {
              {
#line 1174
              idct(ld->block[comp]);
              }
              }
            }
            {
            {
#line 1175
            addblock(comp, bx, by, 1);
            }
            }
          }
#line 1157
          comp ++;
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1179
        if (pb_frame) {
#line 1182
          if (pMODB == 31) {
            {
            {
#line 1184
            reconstruct(bx, by, 0, 0, 0, pMODB, pnewgob);
            }
            }
          } else
#line 1182
          if (pMODB == 30) {
            {
            {
#line 1184
            reconstruct(bx, by, 0, 0, 0, pMODB, pnewgob);
            }
            }
          }
#line 1187
          comp = 6;
          {
          {
#line 1187
          while (1) {
            while_continue___26: /* CIL Label */ ;
            while_continue___11: /* CIL Label */ ;
#line 1187
            if (! (comp < blk_cnt + 6)) {
#line 1187
              goto while_break___11;
            }
#line 1189
            if (! pCOD) {
#line 1189
              goto _L___22;
            } else
#line 1189
            if (adv_pred_mode) {
              _L___22: /* CIL Label */ 
#line 1191
              if (pb_frame == 2) {
#line 1193
                if (pMODB == 2) {
                  {
                  {
#line 1195
                  reconblock_b(comp - 6, bx, by, Mode, 0, 0);
                  }
                  }
                } else
#line 1193
                if (pMODB == 0) {
                  {
                  {
#line 1195
                  reconblock_b(comp - 6, bx, by, Mode, 0, 0);
                  }
                  }
                } else
#line 1193
                if (pCOD) {
                  {
                  {
#line 1195
                  reconblock_b(comp - 6, bx, by, Mode, 0, 0);
                  }
                  }
                }
              } else {
                {
                {
#line 1200
                reconblock_b(comp - 6, bx, by, Mode, pmvdbx, pmvdby);
                }
                }
              }
            }
#line 1203
            if (pCBPB & (1 << ((blk_cnt - 1) - comp % 6))) {
#line 1205
              if (refidct) {
                {
                {
#line 1206
                idctref(ld->block[comp]);
                }
                }
              } else {
                {
                {
#line 1208
                idct(ld->block[comp]);
                }
                }
              }
              {
              {
#line 1209
              addblock(comp, bx, by, 1);
              }
              }
            }
#line 1187
            comp ++;
          }
          while_break___26: /* CIL Label */ ;
          }
          while_break___11: /* CIL Label */ ;
          }
        }
      }
    }
#line 1215
    if (! COD) {
#line 1217
      Mode = modemap[ypos + 1][xpos + 1];
#line 1220
      comp = 0;
      {
      {
#line 1220
      while (1) {
        while_continue___27: /* CIL Label */ ;
        while_continue___12: /* CIL Label */ ;
#line 1220
        if (! (comp < blk_cnt)) {
#line 1220
          goto while_break___12;
        }
        {
        {
#line 1222
        clearblock(comp);
        }
        }
#line 1223
        if (Mode == 3) {
#line 1223
          goto _L___24;
        } else
#line 1223
        if (Mode == 4) {
          _L___24: /* CIL Label */ 
#line 1223
          if (! advanced_intra_coding) {
#line 1226
            bp = ld->block[comp];
#line 1227
            if (syntax_arith_coding) {
              {
              {
#line 1229
              INTRADC_index = decode_a_symbol(cumf_INTRADC);
              }
#line 1230
              *(bp + 0) = (short )intradctab[INTRADC_index];
              }
#line 1231
              if (trace) {
                {
                {
#line 1232
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"INTRADC Index: %d INTRADC: %d \n",
                        INTRADC_index, (int )*(bp + 0));
                }
                }
              }
            } else {
              {
              {
#line 1236
              tmp___21 = getbits(8);
              }
#line 1236
              *(bp + 0) = (short )tmp___21;
              }
#line 1237
              if (trace) {
                {
                {
#line 1239
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DC[%d]: (",
                        comp);
                }
                {
#line 1240
                printbits((int )*(bp + 0), 8, 8);
                }
                {
#line 1241
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
                        (int )*(bp + 0));
                }
                }
              }
            }
#line 1245
            if ((int )*(bp + 0) == 128) {
#line 1246
              if (! quiet) {
                {
                {
#line 1247
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal DC-coeff: 1000000\n");
                }
                }
              }
            }
#line 1248
            if ((int )*(bp + 0) == 255) {
#line 1249
              *(bp + 0) = (short)128;
            }
#line 1250
            *(bp + 0) = (short )((int )*(bp + 0) * 8);
#line 1251
            if (CBP & (1 << ((blk_cnt - 1) - comp))) {
#line 1253
              if (! syntax_arith_coding) {
                {
                {
#line 1254
                getblock(comp, 0, 0, Mode);
                }
                }
              } else {
                {
                {
#line 1256
                get_sac_block(comp, 0, 0, Mode);
                }
                }
              }
            }
          } else {
#line 1223
            goto _L___23;
          }
        } else
        _L___23: /* CIL Label */ 
#line 1262
        if (CBP & (1 << ((blk_cnt - 1) - comp))) {
#line 1264
          if (! syntax_arith_coding) {
            {
            {
#line 1265
            getblock(comp, 1, INTRA_AC_DC, Mode);
            }
            }
          } else {
            {
            {
#line 1267
            get_sac_block(comp, 1, INTRA_AC_DC, Mode);
            }
            }
          }
        }
#line 1270
        if (advanced_intra_coding) {
#line 1270
          if (Mode == 3) {
            {
            {
#line 1272
            Intra_AC_DC_Decode(store_qcoeff, INTRA_AC_DC, MBA, xpos, ypos, comp, newgob);
            }
            {
#line 1273
            memcpy((void */* __restrict  */)((void *)((store_qcoeff + (MBA * blk_cnt) * 64) + comp * 64)),
                   (void const   */* __restrict  */)((void *)(ld->block[comp])), (size_t )(sizeof(short ) * 64UL));
            }
            }
          } else
#line 1270
          if (Mode == 4) {
            {
            {
#line 1272
            Intra_AC_DC_Decode(store_qcoeff, INTRA_AC_DC, MBA, xpos, ypos, comp, newgob);
            }
            {
#line 1273
            memcpy((void */* __restrict  */)((void *)((store_qcoeff + (MBA * blk_cnt) * 64) + comp * 64)),
                   (void const   */* __restrict  */)((void *)(ld->block[comp])), (size_t )(sizeof(short ) * 64UL));
            }
            }
          }
        }
#line 1276
        if (fault) {
#line 1277
          goto resync;
        }
#line 1220
        comp ++;
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1281
      if (pb_frame) {
#line 1283
        comp = 6;
        {
        {
#line 1283
        while (1) {
          while_continue___28: /* CIL Label */ ;
          while_continue___13: /* CIL Label */ ;
#line 1283
          if (! (comp < blk_cnt + 6)) {
#line 1283
            goto while_break___13;
          }
          {
          {
#line 1285
          clearblock(comp);
          }
          }
#line 1286
          if (CBPB & (1 << ((blk_cnt - 1) - comp % 6))) {
#line 1288
            if (! syntax_arith_coding) {
              {
              {
#line 1289
              getblock(comp, 1, 0, 0);
              }
              }
            } else {
              {
              {
#line 1291
              get_sac_block(comp, 1, 0, 0);
              }
              }
            }
          }
#line 1293
          if (fault) {
#line 1294
            goto resync;
          }
#line 1283
          comp ++;
        }
        while_break___28: /* CIL Label */ ;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
    conceal_gob: 
#line 1301
    if (decode_last_mb) {
      {
      {
#line 1303
      conceal_missing_gobs(start_mb_row_missing, number_of_mb_rows_missing);
      }
      }
#line 1308
      if ((number_of_mb_rows_missing + start_mb_row_missing) * mb_width >= MBAmax) {
#line 1308
        return;
      }
#line 1309
      ypos = gob;
#line 1310
      decode_last_mb = 0;
#line 1311
      dont_reconstruct_next_mb = 1;
#line 1312
      goto finish_gob;
    } else {
      {
#line 1317
      MBA ++;
#line 1318
      pCBP = CBP;
#line 1319
      pCBPB = CBPB;
#line 1320
      pCOD = COD;
#line 1321
      pMODB = MODB;
#line 1322
      quant_map[ypos + 1][xpos + 1] = quant;
#line 1324
      pmvdbx = mvdbx;
#line 1325
      pmvdby = mvdby;
      {
#line 1326
      fflush(stdout);
      }
#line 1327
      pnewgob = newgob;
      }
#line 1329
      if (MBA >= MBAmax) {
#line 1329
        if (! last_done) {
#line 1331
          COD = 1;
#line 1332
          xpos = 0;
#line 1333
          ypos ++;
#line 1334
          last_done = 1;
#line 1335
          goto reconstruct_mb;
        }
      }
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1339
  return;
}
}
#line 1353 "getpic.c"
static void get_B_MBs(int framenum ) 
{ 
  int comp ;
  int MBA ;
  int MBAmax ;
  int bx ;
  int by ;
  int COD ;
  int CBP ;
  int Mode ;
  int DQUANT ;
  int xpos ;
  int ypos ;
  int gob ;
  int i ;
  int mvfx ;
  int mvfy ;
  int mvbx ;
  int mvby ;
  int pmvf0 ;
  int pmvf1 ;
  int pmvb0 ;
  int pmvb1 ;
  int gfid___0 ;
  int gobheader_read ;
  int last_done ;
  int pCBP ;
  int pCOD ;
  int DQ_tab[4] ;
  short *bp ;
  int true_B_cbp ;
  int true_B_quant ;
  int true_B_prediction_type ;
  int CBPC ;
  int CBPY ;
  int tmp ;
  int INTRA_AC_DC ;
  short *store_qcoeff ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  void *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;

  {
#line 1358
  COD = 0;
#line 1358
  CBP = 0;
#line 1358
  Mode = 0;
#line 1360
  mvfx = 0;
#line 1360
  mvfy = 0;
#line 1360
  mvbx = 0;
#line 1360
  mvby = 0;
#line 1362
  last_done = 0;
#line 1362
  pCBP = 0;
#line 1362
  pCOD = 0;
#line 1363
  DQ_tab[0] = -1;
#line 1363
  DQ_tab[1] = -2;
#line 1363
  DQ_tab[2] = 1;
#line 1363
  DQ_tab[3] = 2;
#line 1365
  true_B_cbp = 0;
#line 1365
  true_B_quant = 0;
#line 1366
  CBPC = 0;
#line 1366
  CBPY = 0;
#line 1366
  tmp = 0;
#line 1369
  INTRA_AC_DC = 0;
#line 1373
  MBAmax = mb_width * mb_height;
#line 1375
  MBA = 0;
#line 1376
  newgob = 0;
#line 1379
  i = 1;
  {
  {
#line 1379
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1379
    if (! (i < mb_width + 1)) {
#line 1379
      goto while_break;
    }
#line 1381
    MV[0][0][0][i] = 999;
#line 1382
    MV[1][0][0][i] = 999;
#line 1383
    MV[0][5][0][i] = 999;
#line 1384
    MV[1][5][0][i] = 999;
#line 1385
    modemap[0][i] = 3;
#line 1386
    predictionmap[0][i] = 4;
#line 1379
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1389
  i = 0;
  {
  {
#line 1389
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1389
    if (! (i < mb_height + 1)) {
#line 1389
      goto while_break___0;
    }
#line 1391
    MV[0][0][i][0] = 0;
#line 1392
    MV[1][0][i][0] = 0;
#line 1393
    MV[0][0][i][mb_width + 1] = 0;
#line 1394
    MV[1][0][i][mb_width + 1] = 0;
#line 1396
    MV[0][5][i][0] = 0;
#line 1397
    MV[1][5][i][0] = 0;
#line 1398
    MV[0][5][i][mb_width + 1] = 0;
#line 1399
    MV[1][5][i][mb_width + 1] = 0;
#line 1401
    modemap[i][0] = 3;
#line 1402
    modemap[i][mb_width + 1] = 3;
#line 1403
    predictionmap[i][0] = 4;
#line 1404
    predictionmap[i][mb_width + 1] = 4;
#line 1389
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1407
  if (advanced_intra_coding) {
    {
    {
#line 1410
    tmp___0 = calloc((size_t )((64 * MBAmax) * blk_cnt), (size_t )sizeof(short ));
    }
#line 1410
    store_qcoeff = (short *)tmp___0;
    }
#line 1410
    if ((unsigned long )store_qcoeff == (unsigned long )((short *)0)) {
      {
      {
#line 1412
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getMB(): Couldn\'t allocate store_qcoeff.\n");
      }
      {
#line 1413
      exit(-1);
      }
      }
    }
  }
#line 1416
  fault = 0;
#line 1417
  gobheader_read = 0;
  {
  {
#line 1419
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1422
    if (trace) {
      {
      {
#line 1423
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"frame %d, MB %d\n",
              framenum, MBA);
      }
      }
    }
    resync: 
#line 1431
    if (fault) {
      {
      {
#line 1433
      printf((char const   */* __restrict  */)"Warning: A Fault Condition Has Occurred - Resyncing \n");
      }
      {
#line 1434
      startcode();
      }
#line 1435
      fault = 0;
      }
    }
    {
    {
#line 1437
    tmp___6 = showbits(22);
    }
    }
#line 1437
    if (! (tmp___6 >> 6)) {
      {
      {
#line 1440
      startcode();
      }
      {
#line 1444
      tmp___5 = showbits(22);
      }
      }
#line 1444
      if (tmp___5 == 63U) {
#line 1447
        if (! (MBA < MBAmax)) {
#line 1449
          return;
        }
      } else {
        {
        {
#line 1452
        tmp___4 = showbits(22);
        }
        }
#line 1452
        if (tmp___4 == (unsigned int )(1 << 5)) {
#line 1455
          if (! (MBA < MBAmax)) {
#line 1457
            return;
          }
        } else
#line 1462
        if (! (MBA % mb_width)) {
          {
          {
#line 1464
          tmp___1 = getheader();
          }
#line 1464
          gob = tmp___1 - 1;
          }
#line 1465
          if (gob > mb_height) {
#line 1467
            if (! quiet) {
              {
              {
#line 1468
              printf((char const   */* __restrict  */)"GN out of range\n");
              }
              }
            }
#line 1469
            return;
          }
          {
          {
#line 1473
          tmp___2 = getbits(2);
          }
#line 1473
          gfid___0 = (int )tmp___2;
          }
#line 1474
          if (trace) {
            {
            {
#line 1476
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"gfid: ");
            }
            {
#line 1477
            printbits(gfid___0, 2, 2);
            }
            }
          }
          {
          {
#line 1483
          tmp___3 = getbits(5);
          }
#line 1483
          quant = (int )tmp___3;
          }
#line 1484
          if (trace) {
            {
            {
#line 1486
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"quant: ");
            }
            {
#line 1487
            printbits(quant, 5, 5);
            }
            }
          }
#line 1489
          xpos = 0;
#line 1490
          ypos = gob;
#line 1491
          MBA = ypos * mb_width;
#line 1493
          newgob = 1;
#line 1494
          gobheader_read = 1;
        }
      }
    }
#line 1500
    if (! gobheader_read) {
#line 1502
      xpos = MBA % mb_width;
#line 1503
      ypos = MBA / mb_width;
#line 1504
      if (xpos == 0) {
#line 1504
        if (ypos > 0) {
#line 1505
          newgob = 0;
        }
      }
    } else {
#line 1508
      gobheader_read = 0;
    }
#line 1510
    if (MBA >= MBAmax) {
#line 1513
      return;
    }
    read_cod: 
    {
    {
#line 1517
    tmp___7 = showbits(1);
    }
#line 1517
    COD = (int )tmp___7;
    }
#line 1518
    if (trace) {
      {
      {
#line 1520
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"COD : %d \n",
              COD);
      }
      }
    }
#line 1523
    if (! COD) {
      {
#line 1526
      coded_map[ypos + 1][xpos + 1] = 1;
      {
#line 1529
      flushbits(1);
      }
      {
#line 1531
      true_B_prediction_type = getMBTYPE(& true_B_cbp, & true_B_quant);
      }
      }
#line 1533
      if (fault) {
#line 1534
        goto resync;
      }
#line 1536
      if (5 == true_B_prediction_type) {
#line 1539
        goto read_cod;
      }
#line 1542
      if (4 != true_B_prediction_type) {
#line 1544
        if (1 == true_B_quant) {
#line 1546
          Mode = 1;
        } else {
#line 1550
          Mode = 0;
        }
      } else
#line 1555
      if (1 == true_B_quant) {
#line 1557
        Mode = 4;
      } else {
#line 1561
        Mode = 3;
      }
#line 1565
      if (advanced_intra_coding) {
#line 1565
        if (4 == true_B_prediction_type) {
          {
          {
#line 1568
          tmp___10 = showbits(1);
          }
          }
#line 1568
          if (tmp___10) {
            {
            {
#line 1571
            tmp___9 = getbits(2);
            }
#line 1571
            INTRA_AC_DC = (int )tmp___9;
            }
          } else {
            {
            {
#line 1569
            tmp___8 = getbits(1);
            }
#line 1569
            INTRA_AC_DC = (int )tmp___8;
            }
          }
#line 1573
          if (trace) {
            {
            {
#line 1575
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"INTRA_AC_DC: %d\n",
                    INTRA_AC_DC);
            }
            }
          }
        }
      }
#line 1578
      if (1 == true_B_cbp) {
        {
        {
#line 1580
        CBPC = getscalabilityCBPC();
        }
        {
#line 1581
        CBPY = getCBPY();
        }
        }
#line 1584
        if (Mode == 3) {
#line 1589
          CBPY ^= 15;
        } else
#line 1584
        if (Mode == 4) {
#line 1589
          CBPY ^= 15;
        } else
#line 1592
        if (alternative_inter_VLC_mode) {
#line 1592
          if (CBPC == 3) {
#line 1593
            CBPY ^= 15;
          }
        }
#line 1595
        CBP = (CBPY << 2) | CBPC;
      } else {
#line 1599
        CBP = 0;
      }
#line 1602
      if (fault) {
#line 1603
        goto resync;
      }
#line 1605
      if (Mode == 1) {
#line 1605
        goto _L___0;
      } else
#line 1605
      if (Mode == 4) {
        _L___0: /* CIL Label */ 
#line 1608
        if (true_B_frame) {
#line 1608
          if (true_B_quant) {
#line 1610
            if (! modified_quantization_mode) {
              {
              {
#line 1612
              tmp___11 = getbits(2);
              }
#line 1612
              DQUANT = (int )tmp___11;
#line 1613
              quant += DQ_tab[DQUANT];
              }
#line 1614
              if (trace) {
                {
                {
#line 1616
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (");
                }
                {
#line 1617
                printbits(DQUANT, 2, 2);
                }
                {
#line 1618
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d = %d\n",
                        DQUANT, DQ_tab[DQUANT]);
                }
                }
              }
            } else {
              {
              {
#line 1623
              tmp___12 = getbits(1);
              }
#line 1623
              tmp = (int )tmp___12;
              }
#line 1624
              if (tmp) {
                {
                {
#line 1626
                tmp___13 = getbits(1);
                }
#line 1626
                tmp = (int )tmp___13;
                }
#line 1627
                if (tmp) {
#line 1629
                  DQUANT = change_of_quant_tab_11[quant];
                } else {
#line 1632
                  DQUANT = change_of_quant_tab_10[quant];
                }
#line 1634
                quant += DQUANT;
#line 1635
                if (trace) {
                  {
                  {
#line 1637
                  fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (1");
                  }
                  {
#line 1638
                  printbits(tmp, 1, 1);
                  }
                  {
#line 1639
                  fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d \n",
                          DQUANT);
                  }
                  }
                }
              } else {
                {
                {
#line 1645
                tmp___14 = getbits(5);
                }
#line 1645
                DQUANT = (int )tmp___14;
#line 1646
                quant = DQUANT;
                }
#line 1647
                if (trace) {
                  {
                  {
#line 1649
                  fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (");
                  }
                  {
#line 1650
                  printbits(DQUANT, 5, 5);
                  }
                  {
#line 1651
                  fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d \n",
                          DQUANT);
                  }
                  }
                }
              }
            }
          }
        }
#line 1656
        if (quant > 31) {
#line 1656
          goto _L;
        } else
#line 1656
        if (quant < 1) {
          _L: /* CIL Label */ 
#line 1658
          if (! quiet) {
            {
            {
#line 1659
            printf((char const   */* __restrict  */)"Quantizer out of range: clipping\n");
            }
            }
          }
#line 1660
          if (31 < quant) {
#line 1660
            tmp___17 = 31;
          } else {
#line 1660
            tmp___17 = quant;
          }
#line 1660
          if (1 > tmp___17) {
#line 1660
            quant = 1;
          } else {
#line 1660
            if (31 < quant) {
#line 1660
              tmp___16 = 31;
            } else {
#line 1660
              tmp___16 = quant;
            }
#line 1660
            quant = tmp___16;
          }
        }
      }
#line 1666
      if (Mode == 0) {
#line 1666
        goto _L___1;
      } else
#line 1666
      if (Mode == 1) {
        _L___1: /* CIL Label */ 
        {
#line 1670
        if (true_B_prediction_type == 1) {
#line 1670
          goto case_1;
        }
#line 1715
        if (true_B_prediction_type == 2) {
#line 1715
          goto case_2;
        }
#line 1760
        if (true_B_prediction_type == 3) {
#line 1760
          goto case_3;
        }
#line 1840
        goto switch_default;
        case_1: /* CIL Label */ 
#line 1672
        if (plus_type) {
#line 1672
          if (long_vectors) {
            {
            {
#line 1674
            mvfx = getRVLC();
            }
            {
#line 1675
            mvfy = getRVLC();
            }
            }
#line 1678
            if (mvfx == 1) {
#line 1678
              if (mvfy == 1) {
                {
                {
#line 1679
                flushbits(1);
                }
                }
              }
            }
          } else {
            {
            {
#line 1683
            mvfx = getTMNMV();
            }
            {
#line 1684
            mvfy = getTMNMV();
            }
            }
          }
        } else {
          {
          {
#line 1683
          mvfx = getTMNMV();
          }
          {
#line 1684
          mvfy = getTMNMV();
          }
          }
        }
        {
        {
#line 1687
        pmvf0 = find_pmv(xpos, ypos, 0, 0);
        }
        {
#line 1688
        pmvf1 = find_pmv(xpos, ypos, 0, 1);
        }
        }
#line 1690
        if (plus_type) {
#line 1690
          if (long_vectors) {
#line 1692
            mvfx += pmvf0;
#line 1693
            mvfy += pmvf1;
          } else {
            {
            {
#line 1697
            mvfx = motion_decode(mvfx, pmvf0);
            }
            {
#line 1698
            mvfy = motion_decode(mvfy, pmvf1);
            }
            }
          }
        } else {
          {
          {
#line 1697
          mvfx = motion_decode(mvfx, pmvf0);
          }
          {
#line 1698
          mvfy = motion_decode(mvfy, pmvf1);
          }
          }
        }
#line 1701
        if (trace) {
          {
          {
#line 1703
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfx: %d\n",
                  mvfx);
          }
          {
#line 1704
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfy: %d\n",
                  mvfy);
          }
          }
        }
#line 1707
        MV[0][0][ypos + 1][xpos + 1] = mvfx;
#line 1708
        MV[1][0][ypos + 1][xpos + 1] = mvfy;
#line 1710
        MV[0][5][ypos + 1][xpos + 1] = 0;
#line 1711
        MV[1][5][ypos + 1][xpos + 1] = 0;
#line 1713
        goto switch_break;
        case_2: /* CIL Label */ 
#line 1717
        if (plus_type) {
#line 1717
          if (long_vectors) {
            {
            {
#line 1719
            mvbx = getRVLC();
            }
            {
#line 1720
            mvby = getRVLC();
            }
            }
#line 1723
            if (mvbx == 1) {
#line 1723
              if (mvby == 1) {
                {
                {
#line 1724
                flushbits(1);
                }
                }
              }
            }
          } else {
            {
            {
#line 1728
            mvbx = getTMNMV();
            }
            {
#line 1729
            mvby = getTMNMV();
            }
            }
          }
        } else {
          {
          {
#line 1728
          mvbx = getTMNMV();
          }
          {
#line 1729
          mvby = getTMNMV();
          }
          }
        }
        {
        {
#line 1732
        pmvb0 = find_pmv(xpos, ypos, 5, 0);
        }
        {
#line 1733
        pmvb1 = find_pmv(xpos, ypos, 5, 1);
        }
        }
#line 1735
        if (plus_type) {
#line 1735
          if (long_vectors) {
#line 1737
            mvbx += pmvb0;
#line 1738
            mvby += pmvb1;
          } else {
            {
            {
#line 1742
            mvbx = motion_decode(mvbx, pmvb0);
            }
            {
#line 1743
            mvby = motion_decode(mvby, pmvb1);
            }
            }
          }
        } else {
          {
          {
#line 1742
          mvbx = motion_decode(mvbx, pmvb0);
          }
          {
#line 1743
          mvby = motion_decode(mvby, pmvb1);
          }
          }
        }
#line 1746
        if (trace) {
          {
          {
#line 1748
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvbx: %d\n",
                  mvbx);
          }
          {
#line 1749
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvby: %d\n",
                  mvby);
          }
          }
        }
#line 1752
        MV[0][5][ypos + 1][xpos + 1] = mvbx;
#line 1753
        MV[1][5][ypos + 1][xpos + 1] = mvby;
#line 1755
        MV[0][0][ypos + 1][xpos + 1] = 0;
#line 1756
        MV[1][0][ypos + 1][xpos + 1] = 0;
#line 1758
        goto switch_break;
        case_3: /* CIL Label */ 
#line 1762
        if (plus_type) {
#line 1762
          if (long_vectors) {
            {
            {
#line 1764
            mvfx = getRVLC();
            }
            {
#line 1765
            mvfy = getRVLC();
            }
            }
#line 1768
            if (mvfx == 1) {
#line 1768
              if (mvfy == 1) {
                {
                {
#line 1769
                flushbits(1);
                }
                }
              }
            }
          } else {
            {
            {
#line 1773
            mvfx = getTMNMV();
            }
            {
#line 1774
            mvfy = getTMNMV();
            }
            }
          }
        } else {
          {
          {
#line 1773
          mvfx = getTMNMV();
          }
          {
#line 1774
          mvfy = getTMNMV();
          }
          }
        }
        {
        {
#line 1777
        pmvf0 = find_pmv(xpos, ypos, 0, 0);
        }
        {
#line 1778
        pmvf1 = find_pmv(xpos, ypos, 0, 1);
        }
        }
#line 1780
        if (plus_type) {
#line 1780
          if (long_vectors) {
#line 1782
            mvfx += pmvf0;
#line 1783
            mvfy += pmvf1;
          } else {
            {
            {
#line 1787
            mvfx = motion_decode(mvfx, pmvf0);
            }
            {
#line 1788
            mvfy = motion_decode(mvfy, pmvf1);
            }
            }
          }
        } else {
          {
          {
#line 1787
          mvfx = motion_decode(mvfx, pmvf0);
          }
          {
#line 1788
          mvfy = motion_decode(mvfy, pmvf1);
          }
          }
        }
#line 1791
        if (trace) {
          {
          {
#line 1793
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfx: %d\n",
                  mvfx);
          }
          {
#line 1794
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfy: %d\n",
                  mvfy);
          }
          }
        }
#line 1797
        if (plus_type) {
#line 1797
          if (long_vectors) {
            {
            {
#line 1799
            mvbx = getRVLC();
            }
            {
#line 1800
            mvby = getRVLC();
            }
            }
#line 1803
            if (mvbx == 1) {
#line 1803
              if (mvby == 1) {
                {
                {
#line 1804
                flushbits(1);
                }
                }
              }
            }
          } else {
            {
            {
#line 1808
            mvbx = getTMNMV();
            }
            {
#line 1809
            mvby = getTMNMV();
            }
            }
          }
        } else {
          {
          {
#line 1808
          mvbx = getTMNMV();
          }
          {
#line 1809
          mvby = getTMNMV();
          }
          }
        }
        {
        {
#line 1812
        pmvb0 = find_pmv(xpos, ypos, 5, 0);
        }
        {
#line 1813
        pmvb1 = find_pmv(xpos, ypos, 5, 1);
        }
        }
#line 1815
        if (plus_type) {
#line 1815
          if (long_vectors) {
#line 1817
            mvbx += pmvb0;
#line 1818
            mvby += pmvb1;
          } else {
            {
            {
#line 1822
            mvbx = motion_decode(mvbx, pmvb0);
            }
            {
#line 1823
            mvby = motion_decode(mvby, pmvb1);
            }
            }
          }
        } else {
          {
          {
#line 1822
          mvbx = motion_decode(mvbx, pmvb0);
          }
          {
#line 1823
          mvby = motion_decode(mvby, pmvb1);
          }
          }
        }
#line 1826
        if (trace) {
          {
          {
#line 1828
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvbx: %d\n",
                  mvbx);
          }
          {
#line 1829
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvby: %d\n",
                  mvby);
          }
          }
        }
#line 1832
        MV[0][0][ypos + 1][xpos + 1] = mvfx;
#line 1833
        MV[1][0][ypos + 1][xpos + 1] = mvfy;
#line 1835
        MV[0][5][ypos + 1][xpos + 1] = mvbx;
#line 1836
        MV[1][5][ypos + 1][xpos + 1] = mvby;
#line 1838
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1843
        MV[0][0][ypos + 1][xpos + 1] = 0;
#line 1844
        MV[1][0][ypos + 1][xpos + 1] = 0;
#line 1846
        MV[0][5][ypos + 1][xpos + 1] = 0;
#line 1847
        MV[1][5][ypos + 1][xpos + 1] = 0;
#line 1849
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1853
      if (fault) {
#line 1854
        goto resync;
      }
    } else {
#line 1859
      if (MBA >= MBAmax) {
#line 1862
        return;
      }
      {
      {
#line 1864
      flushbits(1);
      }
#line 1866
      Mode = 0;
#line 1869
      CBP = 0;
#line 1871
      coded_map[ypos + 1][xpos + 1] = 0;
#line 1873
      true_B_prediction_type = 0;
#line 1876
      MV[0][0][ypos + 1][xpos + 1] = 0;
#line 1877
      MV[1][0][ypos + 1][xpos + 1] = 0;
#line 1878
      MV[0][5][ypos + 1][xpos + 1] = 0;
#line 1879
      MV[1][5][ypos + 1][xpos + 1] = 0;
      }
    }
#line 1883
    modemap[ypos + 1][xpos + 1] = Mode;
#line 1884
    predictionmap[ypos + 1][xpos + 1] = true_B_prediction_type;
#line 1887
    if (advanced_intra_coding) {
#line 1889
      i = 0;
      {
      {
#line 1889
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1889
        if (! (i < blk_cnt)) {
#line 1889
          goto while_break___2;
        }
#line 1890
        *(store_qcoeff + ((MBA * blk_cnt) * 64 + i * 64)) = (short)1024;
#line 1889
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1892
    if (Mode == 3) {
#line 1892
      goto _L___2;
    } else
#line 1892
    if (Mode == 4) {
      _L___2: /* CIL Label */ 
#line 1894
      tmp___18 = 0;
#line 1894
      MV[1][0][ypos + 1][xpos + 1] = tmp___18;
#line 1894
      MV[0][0][ypos + 1][xpos + 1] = tmp___18;
#line 1895
      tmp___19 = 0;
#line 1895
      MV[1][5][ypos + 1][xpos + 1] = tmp___19;
#line 1895
      MV[0][5][ypos + 1][xpos + 1] = tmp___19;
    }
    reconstruct_mb: 
#line 1902
    if (xpos > 0) {
#line 1904
      bx = 16 * (xpos - 1);
#line 1905
      by = 16 * ypos;
    } else {
#line 1909
      bx = coded_picture_width - 16;
#line 1910
      by = 16 * (ypos - 1);
    }
#line 1913
    if (MBA > 0) {
#line 1915
      Mode = modemap[by / 16 + 1][bx / 16 + 1];
#line 1916
      true_B_prediction_type = predictionmap[by / 16 + 1][bx / 16 + 1];
#line 1919
      if (Mode == 0) {
        {
        {
#line 1920
        reconstruct_true_B(bx, by, true_B_prediction_type);
        }
        }
      } else
#line 1919
      if (Mode == 1) {
        {
        {
#line 1920
        reconstruct_true_B(bx, by, true_B_prediction_type);
        }
        }
      }
#line 1923
      comp = 0;
      {
      {
#line 1923
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 1923
        if (! (comp < blk_cnt)) {
#line 1923
          goto while_break___3;
        }
#line 1926
        if (Mode == 3) {
#line 1926
          goto _L___3;
        } else
#line 1926
        if (Mode == 4) {
          _L___3: /* CIL Label */ 
#line 1928
          if (refidct) {
            {
            {
#line 1929
            idctref(ld->block[comp]);
            }
            }
          } else {
            {
            {
#line 1931
            idct(ld->block[comp]);
            }
            }
          }
          {
          {
#line 1932
          addblock(comp, bx, by, 0);
          }
          }
        } else
#line 1934
        if (pCBP & (1 << ((blk_cnt - 1) - comp))) {
#line 1937
          if (refidct) {
            {
            {
#line 1938
            idctref(ld->block[comp]);
            }
            }
          } else {
            {
            {
#line 1940
            idct(ld->block[comp]);
            }
            }
          }
          {
          {
#line 1941
          addblock(comp, bx, by, 1);
          }
          }
        }
#line 1923
        comp ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1946
    if (! COD) {
#line 1948
      Mode = modemap[ypos + 1][xpos + 1];
#line 1949
      true_B_prediction_type = predictionmap[ypos + 1][xpos + 1];
#line 1951
      comp = 0;
      {
      {
#line 1951
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 1951
        if (! (comp < blk_cnt)) {
#line 1951
          goto while_break___4;
        }
        {
        {
#line 1953
        clearblock(comp);
        }
        }
#line 1954
        if (Mode == 3) {
#line 1954
          goto _L___5;
        } else
#line 1954
        if (Mode == 4) {
          _L___5: /* CIL Label */ 
#line 1954
          if (! advanced_intra_coding) {
            {
#line 1957
            bp = ld->block[comp];
            {
#line 1958
            tmp___20 = getbits(8);
            }
#line 1958
            *(bp + 0) = (short )tmp___20;
            }
#line 1959
            if (trace) {
              {
              {
#line 1961
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DC[%d]: (",
                      comp);
              }
              {
#line 1962
              printbits((int )*(bp + 0), 8, 8);
              }
              {
#line 1963
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
                      (int )*(bp + 0));
              }
              }
            }
#line 1965
            if ((int )*(bp + 0) == 128) {
#line 1966
              if (! quiet) {
                {
                {
#line 1967
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal DC-coeff: 1000000\n");
                }
                }
              }
            }
#line 1968
            if ((int )*(bp + 0) == 255) {
#line 1969
              *(bp + 0) = (short)128;
            }
#line 1970
            *(bp + 0) = (short )((int )*(bp + 0) * 8);
#line 1972
            if (CBP & (1 << ((blk_cnt - 1) - comp))) {
              {
              {
#line 1974
              getblock(comp, 0, 0, Mode);
              }
              }
            }
          } else {
#line 1954
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 1980
        if (CBP & (1 << ((blk_cnt - 1) - comp))) {
          {
          {
#line 1982
          getblock(comp, 1, INTRA_AC_DC, Mode);
          }
          }
        }
#line 1985
        if (advanced_intra_coding) {
#line 1985
          if (Mode == 3) {
            {
            {
#line 1987
            Intra_AC_DC_Decode(store_qcoeff, INTRA_AC_DC, MBA, xpos, ypos, comp, newgob);
            }
            {
#line 1988
            memcpy((void */* __restrict  */)((void *)((store_qcoeff + (MBA * blk_cnt) * 64) + comp * 64)),
                   (void const   */* __restrict  */)((void *)(ld->block[comp])), (size_t )(sizeof(short ) * 64UL));
            }
            }
          } else
#line 1985
          if (Mode == 4) {
            {
            {
#line 1987
            Intra_AC_DC_Decode(store_qcoeff, INTRA_AC_DC, MBA, xpos, ypos, comp, newgob);
            }
            {
#line 1988
            memcpy((void */* __restrict  */)((void *)((store_qcoeff + (MBA * blk_cnt) * 64) + comp * 64)),
                   (void const   */* __restrict  */)((void *)(ld->block[comp])), (size_t )(sizeof(short ) * 64UL));
            }
            }
          }
        }
#line 1992
        if (fault) {
#line 1993
          goto resync;
        }
#line 1951
        comp ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 1998
    MBA ++;
#line 1999
    pCBP = CBP;
#line 2000
    pCOD = COD;
#line 2001
    quant_map[ypos + 1][xpos + 1] = quant;
    {
#line 2003
    fflush(stdout);
    }
    }
#line 2005
    if (MBA >= MBAmax) {
#line 2005
      if (! last_done) {
#line 2007
        COD = 1;
#line 2008
        xpos = 0;
#line 2009
        ypos ++;
#line 2010
        last_done = 1;
#line 2011
        goto reconstruct_mb;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 2028 "getpic.c"
static void get_EI_EP_MBs(int framenum ) 
{ 
  int comp ;
  int MBA ;
  int MBAmax ;
  int bx ;
  int by ;
  int COD ;
  int CBP ;
  int Mode ;
  int DQUANT ;
  int xpos ;
  int ypos ;
  int gob ;
  int i ;
  int mvfx ;
  int mvfy ;
  int pmvf0 ;
  int pmvf1 ;
  int gfid___0 ;
  int gobheader_read ;
  int last_done ;
  int pCBP ;
  int pCOD ;
  int DQ_tab[4] ;
  short *bp ;
  int ei_ep_cbp ;
  int ei_ep_quant ;
  int ei_ep_prediction_type ;
  int CBPC ;
  int CBPY ;
  int tmp ;
  int INTRA_AC_DC ;
  short *store_qcoeff ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;

  {
#line 2033
  COD = 0;
#line 2033
  CBP = 0;
#line 2033
  Mode = 0;
#line 2035
  mvfx = 0;
#line 2035
  mvfy = 0;
#line 2037
  last_done = 0;
#line 2037
  pCBP = 0;
#line 2037
  pCOD = 0;
#line 2038
  DQ_tab[0] = -1;
#line 2038
  DQ_tab[1] = -2;
#line 2038
  DQ_tab[2] = 1;
#line 2038
  DQ_tab[3] = 2;
#line 2040
  ei_ep_cbp = 0;
#line 2040
  ei_ep_quant = 0;
#line 2041
  CBPC = 0;
#line 2041
  CBPY = 0;
#line 2041
  tmp = 0;
#line 2044
  INTRA_AC_DC = 0;
#line 2047
  MBAmax = mb_width * mb_height;
#line 2049
  MBA = 0;
#line 2050
  newgob = 0;
#line 2053
  i = 1;
  {
  {
#line 2053
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2053
    if (! (i < mb_width + 1)) {
#line 2053
      goto while_break;
    }
#line 2055
    MV[0][0][0][i] = 999;
#line 2056
    MV[1][0][0][i] = 999;
#line 2057
    modemap[0][i] = 3;
#line 2058
    predictionmap[0][i] = 3;
#line 2053
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2061
  i = 0;
  {
  {
#line 2061
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2061
    if (! (i < mb_height + 1)) {
#line 2061
      goto while_break___0;
    }
#line 2063
    MV[0][0][i][0] = 0;
#line 2064
    MV[1][0][i][0] = 0;
#line 2065
    MV[0][0][i][mb_width + 1] = 0;
#line 2066
    MV[1][0][i][mb_width + 1] = 0;
#line 2067
    modemap[i][0] = 3;
#line 2068
    modemap[i][mb_width + 1] = 3;
#line 2069
    predictionmap[i][0] = 3;
#line 2070
    predictionmap[i][mb_width + 1] = 3;
#line 2061
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2073
  if (advanced_intra_coding) {
    {
    {
#line 2076
    tmp___0 = calloc((size_t )((64 * MBAmax) * blk_cnt), (size_t )sizeof(short ));
    }
#line 2076
    store_qcoeff = (short *)tmp___0;
    }
#line 2076
    if ((unsigned long )store_qcoeff == (unsigned long )((short *)0)) {
      {
      {
#line 2078
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getMB(): Couldn\'t allocate store_qcoeff.\n");
      }
      {
#line 2079
      exit(-1);
      }
      }
    }
  }
#line 2082
  fault = 0;
#line 2083
  gobheader_read = 0;
  {
  {
#line 2085
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 2088
    if (trace) {
      {
      {
#line 2089
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"frame %d, MB %d\n",
              framenum, MBA);
      }
      }
    }
    resync: 
#line 2097
    if (fault) {
      {
      {
#line 2099
      printf((char const   */* __restrict  */)"Warning: A Fault Condition Has Occurred - Resyncing \n");
      }
      {
#line 2100
      startcode();
      }
#line 2101
      fault = 0;
      }
    }
    {
    {
#line 2103
    tmp___6 = showbits(22);
    }
    }
#line 2103
    if (! (tmp___6 >> 6)) {
      {
      {
#line 2106
      startcode();
      }
      {
#line 2110
      tmp___5 = showbits(22);
      }
      }
#line 2110
      if (tmp___5 == 63U) {
#line 2113
        if (! (MBA < MBAmax)) {
#line 2115
          return;
        }
      } else {
        {
        {
#line 2118
        tmp___4 = showbits(22);
        }
        }
#line 2118
        if (tmp___4 == (unsigned int )(1 << 5)) {
#line 2121
          if (! (MBA < MBAmax)) {
#line 2123
            return;
          }
        } else
#line 2128
        if (! (MBA % mb_width)) {
          {
          {
#line 2130
          tmp___1 = getheader();
          }
#line 2130
          gob = tmp___1 - 1;
          }
#line 2131
          if (gob > mb_height) {
#line 2133
            if (! quiet) {
              {
              {
#line 2134
              printf((char const   */* __restrict  */)"GN out of range\n");
              }
              }
            }
#line 2135
            return;
          }
          {
          {
#line 2139
          tmp___2 = getbits(2);
          }
#line 2139
          gfid___0 = (int )tmp___2;
          }
#line 2140
          if (trace) {
            {
            {
#line 2142
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"gfid: ");
            }
            {
#line 2143
            printbits(gfid___0, 2, 2);
            }
            }
          }
          {
          {
#line 2149
          tmp___3 = getbits(5);
          }
#line 2149
          quant = (int )tmp___3;
          }
#line 2150
          if (trace) {
            {
            {
#line 2152
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"quant: ");
            }
            {
#line 2153
            printbits(quant, 5, 5);
            }
            }
          }
#line 2155
          xpos = 0;
#line 2156
          ypos = gob;
#line 2157
          MBA = ypos * mb_width;
#line 2159
          newgob = 1;
#line 2160
          gobheader_read = 1;
        }
      }
    }
#line 2166
    if (! gobheader_read) {
#line 2168
      xpos = MBA % mb_width;
#line 2169
      ypos = MBA / mb_width;
#line 2170
      if (xpos == 0) {
#line 2170
        if (ypos > 0) {
#line 2171
          newgob = 0;
        }
      }
    } else {
#line 2174
      gobheader_read = 0;
    }
#line 2176
    if (MBA >= MBAmax) {
#line 2179
      return;
    }
    read_cod: 
    {
    {
#line 2183
    tmp___7 = showbits(1);
    }
#line 2183
    COD = (int )tmp___7;
    }
#line 2184
    if (trace) {
      {
      {
#line 2186
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"COD : %d \n",
              COD);
      }
      }
    }
#line 2189
    if (! COD) {
      {
#line 2192
      coded_map[ypos + 1][xpos + 1] = 1;
      {
#line 2195
      flushbits(1);
      }
      {
#line 2197
      ei_ep_prediction_type = getMBTYPE(& ei_ep_cbp, & ei_ep_quant);
      }
      }
#line 2199
      if (fault) {
#line 2200
        goto resync;
      }
#line 2202
      if (5 == ei_ep_prediction_type) {
#line 2205
        goto read_cod;
      }
#line 2208
      if (3 != ei_ep_prediction_type) {
#line 2210
        if (1 == ei_ep_quant) {
#line 2212
          Mode = 1;
        } else {
#line 2216
          Mode = 0;
        }
      } else
#line 2221
      if (1 == ei_ep_quant) {
#line 2223
        Mode = 4;
      } else {
#line 2227
        Mode = 3;
      }
#line 2231
      if (advanced_intra_coding) {
#line 2231
        if (3 == ei_ep_prediction_type) {
          {
          {
#line 2234
          tmp___10 = showbits(1);
          }
          }
#line 2234
          if (tmp___10) {
            {
            {
#line 2237
            tmp___9 = getbits(2);
            }
#line 2237
            INTRA_AC_DC = (int )tmp___9;
            }
          } else {
            {
            {
#line 2235
            tmp___8 = getbits(1);
            }
#line 2235
            INTRA_AC_DC = (int )tmp___8;
            }
          }
#line 2239
          if (trace) {
            {
            {
#line 2241
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"INTRA_AC_DC: %d\n",
                    INTRA_AC_DC);
            }
            }
          }
        }
      }
#line 2244
      if (1 == ei_ep_cbp) {
#line 2244
        goto _L___0;
      } else
#line 2244
      if (4 == pict_type) {
        _L___0: /* CIL Label */ 
#line 2246
        if (5 == pict_type) {
          {
          {
#line 2247
          CBPC = getscalabilityCBPC();
          }
          }
        } else {
#line 2249
          CBPC = ei_ep_cbp;
        }
        {
        {
#line 2251
        CBPY = getCBPY();
        }
        }
#line 2254
        if (3 == Mode) {
#line 2260
          CBPY ^= 15;
        } else
#line 2254
        if (4 == Mode) {
#line 2260
          CBPY ^= 15;
        } else
#line 2254
        if (1 == ei_ep_prediction_type) {
#line 2260
          CBPY ^= 15;
        } else
#line 2254
        if (5 == pict_type) {
#line 2254
          if (2 == ei_ep_prediction_type) {
#line 2260
            CBPY ^= 15;
          } else {
#line 2254
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2263
        if (alternative_inter_VLC_mode) {
#line 2263
          if (CBPC == 3) {
#line 2264
            CBPY ^= 15;
          }
        }
#line 2266
        CBP = (CBPY << 2) | CBPC;
      } else {
#line 2270
        CBP = 0;
      }
#line 2273
      if (fault) {
#line 2274
        goto resync;
      }
#line 2276
      if (Mode == 1) {
#line 2276
        goto _L___2;
      } else
#line 2276
      if (Mode == 4) {
        _L___2: /* CIL Label */ 
#line 2279
        if (ei_ep_quant) {
#line 2281
          if (! modified_quantization_mode) {
            {
            {
#line 2283
            tmp___11 = getbits(2);
            }
#line 2283
            DQUANT = (int )tmp___11;
#line 2284
            quant += DQ_tab[DQUANT];
            }
#line 2285
            if (trace) {
              {
              {
#line 2287
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (");
              }
              {
#line 2288
              printbits(DQUANT, 2, 2);
              }
              {
#line 2289
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d = %d\n",
                      DQUANT, DQ_tab[DQUANT]);
              }
              }
            }
          } else {
            {
            {
#line 2294
            tmp___12 = getbits(1);
            }
#line 2294
            tmp = (int )tmp___12;
            }
#line 2295
            if (tmp) {
              {
              {
#line 2297
              tmp___13 = getbits(1);
              }
#line 2297
              tmp = (int )tmp___13;
              }
#line 2298
              if (tmp) {
#line 2300
                DQUANT = change_of_quant_tab_11[quant];
              } else {
#line 2303
                DQUANT = change_of_quant_tab_10[quant];
              }
#line 2305
              quant += DQUANT;
#line 2306
              if (trace) {
                {
                {
#line 2308
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (1");
                }
                {
#line 2309
                printbits(tmp, 1, 1);
                }
                {
#line 2310
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d \n",
                        DQUANT);
                }
                }
              }
            } else {
              {
              {
#line 2316
              tmp___14 = getbits(5);
              }
#line 2316
              DQUANT = (int )tmp___14;
#line 2317
              quant = DQUANT;
              }
#line 2318
              if (trace) {
                {
                {
#line 2320
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DQUANT (");
                }
                {
#line 2321
                printbits(DQUANT, 5, 5);
                }
                {
#line 2322
                fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d \n",
                        DQUANT);
                }
                }
              }
            }
          }
        }
#line 2327
        if (quant > 31) {
#line 2327
          goto _L___1;
        } else
#line 2327
        if (quant < 1) {
          _L___1: /* CIL Label */ 
#line 2329
          if (! quiet) {
            {
            {
#line 2330
            printf((char const   */* __restrict  */)"Quantizer out of range: clipping\n");
            }
            }
          }
#line 2331
          if (31 < quant) {
#line 2331
            tmp___17 = 31;
          } else {
#line 2331
            tmp___17 = quant;
          }
#line 2331
          if (1 > tmp___17) {
#line 2331
            quant = 1;
          } else {
#line 2331
            if (31 < quant) {
#line 2331
              tmp___16 = 31;
            } else {
#line 2331
              tmp___16 = quant;
            }
#line 2331
            quant = tmp___16;
          }
        }
      }
#line 2337
      if (Mode == 0) {
#line 2337
        goto _L___3;
      } else
#line 2337
      if (Mode == 1) {
        _L___3: /* CIL Label */ 
        {
#line 2341
        if (ei_ep_prediction_type == 0) {
#line 2341
          goto case_0;
        }
#line 2383
        if (ei_ep_prediction_type == 2) {
#line 2383
          goto case_2;
        }
#line 2434
        goto switch_default;
        case_0: /* CIL Label */ 
#line 2343
        if (plus_type) {
#line 2343
          if (long_vectors) {
            {
            {
#line 2345
            mvfx = getRVLC();
            }
            {
#line 2346
            mvfy = getRVLC();
            }
            }
#line 2349
            if (mvfx == 1) {
#line 2349
              if (mvfy == 1) {
                {
                {
#line 2350
                flushbits(1);
                }
                }
              }
            }
          } else {
            {
            {
#line 2354
            mvfx = getTMNMV();
            }
            {
#line 2355
            mvfy = getTMNMV();
            }
            }
          }
        } else {
          {
          {
#line 2354
          mvfx = getTMNMV();
          }
          {
#line 2355
          mvfy = getTMNMV();
          }
          }
        }
        {
        {
#line 2358
        pmvf0 = find_pmv(xpos, ypos, 0, 0);
        }
        {
#line 2359
        pmvf1 = find_pmv(xpos, ypos, 0, 1);
        }
        }
#line 2361
        if (plus_type) {
#line 2361
          if (long_vectors) {
#line 2363
            mvfx += pmvf0;
#line 2364
            mvfy += pmvf1;
          } else {
            {
            {
#line 2368
            mvfx = motion_decode(mvfx, pmvf0);
            }
            {
#line 2369
            mvfy = motion_decode(mvfy, pmvf1);
            }
            }
          }
        } else {
          {
          {
#line 2368
          mvfx = motion_decode(mvfx, pmvf0);
          }
          {
#line 2369
          mvfy = motion_decode(mvfy, pmvf1);
          }
          }
        }
#line 2372
        if (trace) {
          {
          {
#line 2374
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfx: %d\n",
                  mvfx);
          }
          {
#line 2375
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfy: %d\n",
                  mvfy);
          }
          }
        }
#line 2378
        MV[0][0][ypos + 1][xpos + 1] = mvfx;
#line 2379
        MV[1][0][ypos + 1][xpos + 1] = mvfy;
#line 2381
        goto switch_break;
        case_2: /* CIL Label */ 
#line 2386
        if (0 == ei_ep_cbp) {
#line 2386
          if (0 == ei_ep_quant) {
#line 2388
            MV[0][0][ypos + 1][xpos + 1] = 0;
#line 2389
            MV[1][0][ypos + 1][xpos + 1] = 0;
#line 2390
            goto switch_break;
          }
        }
#line 2393
        if (plus_type) {
#line 2393
          if (long_vectors) {
            {
            {
#line 2395
            mvfx = getRVLC();
            }
            {
#line 2396
            mvfy = getRVLC();
            }
            }
#line 2399
            if (mvfx == 1) {
#line 2399
              if (mvfy == 1) {
                {
                {
#line 2400
                flushbits(1);
                }
                }
              }
            }
          } else {
            {
            {
#line 2404
            mvfx = getTMNMV();
            }
            {
#line 2405
            mvfy = getTMNMV();
            }
            }
          }
        } else {
          {
          {
#line 2404
          mvfx = getTMNMV();
          }
          {
#line 2405
          mvfy = getTMNMV();
          }
          }
        }
        {
        {
#line 2408
        pmvf0 = find_pmv(xpos, ypos, 0, 0);
        }
        {
#line 2409
        pmvf1 = find_pmv(xpos, ypos, 0, 1);
        }
        }
#line 2411
        if (plus_type) {
#line 2411
          if (long_vectors) {
#line 2413
            mvfx += pmvf0;
#line 2414
            mvfy += pmvf1;
          } else {
            {
            {
#line 2418
            mvfx = motion_decode(mvfx, pmvf0);
            }
            {
#line 2419
            mvfy = motion_decode(mvfy, pmvf1);
            }
            }
          }
        } else {
          {
          {
#line 2418
          mvfx = motion_decode(mvfx, pmvf0);
          }
          {
#line 2419
          mvfy = motion_decode(mvfy, pmvf1);
          }
          }
        }
#line 2422
        if (trace) {
          {
          {
#line 2424
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfx: %d\n",
                  mvfx);
          }
          {
#line 2425
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"mvfy: %d\n",
                  mvfy);
          }
          }
        }
#line 2428
        MV[0][0][ypos + 1][xpos + 1] = mvfx;
#line 2429
        MV[1][0][ypos + 1][xpos + 1] = mvfy;
#line 2431
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2437
        MV[0][0][ypos + 1][xpos + 1] = 0;
#line 2438
        MV[1][0][ypos + 1][xpos + 1] = 0;
#line 2440
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 2444
      if (fault) {
#line 2445
        goto resync;
      }
    } else {
#line 2450
      if (MBA >= MBAmax) {
#line 2453
        return;
      }
      {
      {
#line 2455
      flushbits(1);
      }
#line 2457
      Mode = 0;
#line 2460
      CBP = 0;
#line 2462
      coded_map[ypos + 1][xpos + 1] = 0;
      }
#line 2464
      if (4 == pict_type) {
#line 2466
        ei_ep_prediction_type = 1;
      } else {
#line 2470
        ei_ep_prediction_type = 0;
      }
#line 2474
      MV[0][0][ypos + 1][xpos + 1] = 0;
#line 2475
      MV[1][0][ypos + 1][xpos + 1] = 0;
    }
#line 2479
    modemap[ypos + 1][xpos + 1] = Mode;
#line 2480
    predictionmap[ypos + 1][xpos + 1] = ei_ep_prediction_type;
#line 2483
    if (advanced_intra_coding) {
#line 2485
      i = 0;
      {
      {
#line 2485
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 2485
        if (! (i < blk_cnt)) {
#line 2485
          goto while_break___2;
        }
#line 2486
        *(store_qcoeff + ((MBA * blk_cnt) * 64 + i * 64)) = (short)1024;
#line 2485
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2488
    if (Mode == 3) {
#line 2490
      tmp___18 = 0;
#line 2490
      MV[1][0][ypos + 1][xpos + 1] = tmp___18;
#line 2490
      MV[0][0][ypos + 1][xpos + 1] = tmp___18;
    } else
#line 2488
    if (Mode == 4) {
#line 2490
      tmp___18 = 0;
#line 2490
      MV[1][0][ypos + 1][xpos + 1] = tmp___18;
#line 2490
      MV[0][0][ypos + 1][xpos + 1] = tmp___18;
    }
    reconstruct_mb: 
#line 2497
    if (xpos > 0) {
#line 2499
      bx = 16 * (xpos - 1);
#line 2500
      by = 16 * ypos;
    } else {
#line 2503
      bx = coded_picture_width - 16;
#line 2504
      by = 16 * (ypos - 1);
    }
#line 2507
    if (MBA > 0) {
#line 2509
      Mode = modemap[by / 16 + 1][bx / 16 + 1];
#line 2510
      ei_ep_prediction_type = predictionmap[by / 16 + 1][bx / 16 + 1];
#line 2513
      if (Mode == 0) {
        {
        {
#line 2514
        reconstruct_ei_ep(bx, by, ei_ep_prediction_type);
        }
        }
      } else
#line 2513
      if (Mode == 1) {
        {
        {
#line 2514
        reconstruct_ei_ep(bx, by, ei_ep_prediction_type);
        }
        }
      }
#line 2517
      comp = 0;
      {
      {
#line 2517
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 2517
        if (! (comp < blk_cnt)) {
#line 2517
          goto while_break___3;
        }
#line 2520
        if (Mode == 3) {
#line 2520
          goto _L___4;
        } else
#line 2520
        if (Mode == 4) {
          _L___4: /* CIL Label */ 
#line 2522
          if (refidct) {
            {
            {
#line 2523
            idctref(ld->block[comp]);
            }
            }
          } else {
            {
            {
#line 2525
            idct(ld->block[comp]);
            }
            }
          }
          {
          {
#line 2526
          addblock(comp, bx, by, 0);
          }
          }
        } else
#line 2528
        if (pCBP & (1 << ((blk_cnt - 1) - comp))) {
#line 2531
          if (refidct) {
            {
            {
#line 2532
            idctref(ld->block[comp]);
            }
            }
          } else {
            {
            {
#line 2534
            idct(ld->block[comp]);
            }
            }
          }
          {
          {
#line 2535
          addblock(comp, bx, by, 1);
          }
          }
        }
#line 2517
        comp ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 2540
    if (! COD) {
#line 2542
      Mode = modemap[ypos + 1][xpos + 1];
#line 2543
      ei_ep_prediction_type = predictionmap[ypos + 1][xpos + 1];
#line 2545
      comp = 0;
      {
      {
#line 2545
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 2545
        if (! (comp < blk_cnt)) {
#line 2545
          goto while_break___4;
        }
        {
        {
#line 2547
        clearblock(comp);
        }
        }
#line 2548
        if (Mode == 3) {
#line 2548
          goto _L___6;
        } else
#line 2548
        if (Mode == 4) {
          _L___6: /* CIL Label */ 
#line 2548
          if (! advanced_intra_coding) {
            {
#line 2551
            bp = ld->block[comp];
            {
#line 2552
            tmp___19 = getbits(8);
            }
#line 2552
            *(bp + 0) = (short )tmp___19;
            }
#line 2553
            if (trace) {
              {
              {
#line 2555
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"DC[%d]: (",
                      comp);
              }
              {
#line 2556
              printbits((int )*(bp + 0), 8, 8);
              }
              {
#line 2557
              fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d\n",
                      (int )*(bp + 0));
              }
              }
            }
#line 2559
            if ((int )*(bp + 0) == 128) {
#line 2560
              if (! quiet) {
                {
                {
#line 2561
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal DC-coeff: 1000000\n");
                }
                }
              }
            }
#line 2562
            if ((int )*(bp + 0) == 255) {
#line 2563
              *(bp + 0) = (short)128;
            }
#line 2564
            *(bp + 0) = (short )((int )*(bp + 0) * 8);
#line 2566
            if (CBP & (1 << ((blk_cnt - 1) - comp))) {
              {
              {
#line 2568
              getblock(comp, 0, 0, Mode);
              }
              }
            }
          } else {
#line 2548
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 2574
        if (CBP & (1 << ((blk_cnt - 1) - comp))) {
          {
          {
#line 2576
          getblock(comp, 1, INTRA_AC_DC, Mode);
          }
          }
        }
#line 2579
        if (advanced_intra_coding) {
#line 2579
          if (Mode == 3) {
            {
            {
#line 2581
            Intra_AC_DC_Decode(store_qcoeff, INTRA_AC_DC, MBA, xpos, ypos, comp, newgob);
            }
            {
#line 2582
            memcpy((void */* __restrict  */)((void *)((store_qcoeff + (MBA * blk_cnt) * 64) + comp * 64)),
                   (void const   */* __restrict  */)((void *)(ld->block[comp])), (size_t )(sizeof(short ) * 64UL));
            }
            }
          } else
#line 2579
          if (Mode == 4) {
            {
            {
#line 2581
            Intra_AC_DC_Decode(store_qcoeff, INTRA_AC_DC, MBA, xpos, ypos, comp, newgob);
            }
            {
#line 2582
            memcpy((void */* __restrict  */)((void *)((store_qcoeff + (MBA * blk_cnt) * 64) + comp * 64)),
                   (void const   */* __restrict  */)((void *)(ld->block[comp])), (size_t )(sizeof(short ) * 64UL));
            }
            }
          }
        }
#line 2586
        if (fault) {
#line 2587
          goto resync;
        }
#line 2545
        comp ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 2592
    MBA ++;
#line 2593
    pCBP = CBP;
#line 2594
    pCOD = COD;
#line 2595
    quant_map[ypos + 1][xpos + 1] = quant;
    {
#line 2597
    fflush(stdout);
    }
    }
#line 2599
    if (MBA >= MBAmax) {
#line 2599
      if (! last_done) {
#line 2601
        COD = 1;
#line 2602
        xpos = 0;
#line 2603
        ypos ++;
#line 2604
        last_done = 1;
#line 2605
        goto reconstruct_mb;
      }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 2611 "getpic.c"
static void clearblock(int comp ) 
{ 
  int *bp ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2616
  bp = (int *)(ld->block[comp]);
#line 2618
  i = 0;
  {
  {
#line 2618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2618
    if (! (i < 8)) {
#line 2618
      goto while_break;
    }
#line 2620
    tmp___1 = 0;
#line 2620
    *(bp + 3) = tmp___1;
#line 2620
    tmp___0 = tmp___1;
#line 2620
    *(bp + 2) = tmp___0;
#line 2620
    tmp = tmp___0;
#line 2620
    *(bp + 1) = tmp;
#line 2620
    *(bp + 0) = tmp;
#line 2621
    bp += 4;
#line 2618
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2623
  return;
}
}
#line 2628 "getpic.c"
static void addblock(int comp , int bx , int by , int addflag ) 
{ 
  int cc ;
  int i ;
  int iincr ;
  int P ;
  unsigned char *rfp ;
  short *bp ;
  unsigned char *curr[3] ;
  void *__cil_tmp12 ;

  {
#line 2630
  P = 1;
#line 2635
  if (enhancement_layer_num > 1) {
#line 2637
    curr[0] = current_enhancement_frame[enhancement_layer_num - 2][0];
#line 2638
    curr[1] = current_enhancement_frame[enhancement_layer_num - 2][1];
#line 2639
    curr[2] = current_enhancement_frame[enhancement_layer_num - 2][2];
  } else {
#line 2643
    curr[0] = current_frame[0];
#line 2644
    curr[1] = current_frame[1];
#line 2645
    curr[2] = current_frame[2];
  }
#line 2649
  bp = ld->block[comp];
#line 2651
  if (comp >= 6) {
#line 2654
    P = 0;
#line 2655
    addflag = 1;
#line 2656
    comp -= 6;
  }
#line 2658
  if (comp < 4) {
#line 2658
    cc = 0;
  } else {
#line 2658
    cc = (comp & 1) + 1;
  }
#line 2660
  if (cc == 0) {
#line 2665
    if (P) {
#line 2666
      rfp = ((curr[0] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
    } else {
#line 2669
      rfp = ((bframe[0] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
    }
#line 2671
    iincr = coded_picture_width;
  } else {
#line 2678
    bx >>= 1;
#line 2679
    by >>= 1;
#line 2681
    if (P) {
#line 2682
      rfp = (curr[cc] + chrom_width * by) + bx;
    } else {
#line 2684
      rfp = (bframe[cc] + chrom_width * by) + bx;
    }
#line 2685
    iincr = chrom_width;
  }
#line 2689
  if (addflag) {
#line 2691
    i = 0;
    {
    {
#line 2691
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2691
      if (! (i < 8)) {
#line 2691
        goto while_break;
      }
#line 2693
      *(rfp + 0) = *(clp + ((int )*(bp + 0) + (int )*(rfp + 0)));
#line 2694
      *(rfp + 1) = *(clp + ((int )*(bp + 1) + (int )*(rfp + 1)));
#line 2695
      *(rfp + 2) = *(clp + ((int )*(bp + 2) + (int )*(rfp + 2)));
#line 2696
      *(rfp + 3) = *(clp + ((int )*(bp + 3) + (int )*(rfp + 3)));
#line 2697
      *(rfp + 4) = *(clp + ((int )*(bp + 4) + (int )*(rfp + 4)));
#line 2698
      *(rfp + 5) = *(clp + ((int )*(bp + 5) + (int )*(rfp + 5)));
#line 2699
      *(rfp + 6) = *(clp + ((int )*(bp + 6) + (int )*(rfp + 6)));
#line 2700
      *(rfp + 7) = *(clp + ((int )*(bp + 7) + (int )*(rfp + 7)));
#line 2701
      bp += 8;
#line 2702
      rfp += iincr;
#line 2691
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2706
    i = 0;
    {
    {
#line 2706
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 2706
      if (! (i < 8)) {
#line 2706
        goto while_break___0;
      }
#line 2708
      *(rfp + 0) = *(clp + *(bp + 0));
#line 2709
      *(rfp + 1) = *(clp + *(bp + 1));
#line 2710
      *(rfp + 2) = *(clp + *(bp + 2));
#line 2711
      *(rfp + 3) = *(clp + *(bp + 3));
#line 2712
      *(rfp + 4) = *(clp + *(bp + 4));
#line 2713
      *(rfp + 5) = *(clp + *(bp + 5));
#line 2714
      *(rfp + 6) = *(clp + *(bp + 6));
#line 2715
      *(rfp + 7) = *(clp + *(bp + 7));
#line 2716
      bp += 8;
#line 2717
      rfp += iincr;
#line 2706
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2725
  return;
}
}
#line 2729 "getpic.c"
static void reconblock_b(int comp , int bx , int by , int mode , int bdx , int bdy ) 
{ 
  int cc ;
  int i ;
  int j ;
  int k ;
  int ii ;
  unsigned char *bfr ;
  unsigned char *ffr ;
  int BMVx ;
  int BMVy ;
  int xa ;
  int xb ;
  int ya ;
  int yb ;
  int x ;
  int y ;
  int xvec ;
  int yvec ;
  int mvx ;
  int mvy ;
  int xint ;
  int xhalf ;
  int yint ;
  int yhalf ;
  int pel ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 2737
  x = bx / 16 + 1;
#line 2738
  y = by / 16 + 1;
#line 2740
  if (mode == 2) {
#line 2740
    goto _L;
  } else
#line 2740
  if (mode == 5) {
    _L: /* CIL Label */ 
#line 2742
    if (comp < 4) {
#line 2745
      mvx = MV[0][comp + 1][y][x];
#line 2746
      mvy = MV[1][comp + 1][y][x];
#line 2747
      if (bdx == 0) {
#line 2747
        BMVx = ((trb - trd) * mvx) / trd;
      } else {
#line 2747
        BMVx = ((trb * mvx) / trd + bdx) - mvx;
      }
#line 2748
      if (bdy == 0) {
#line 2748
        BMVy = ((trb - trd) * mvy) / trd;
      } else {
#line 2748
        BMVy = ((trb * mvy) / trd + bdy) - mvy;
      }
    } else {
#line 2752
      yvec = 0;
#line 2752
      xvec = yvec;
#line 2753
      k = 1;
      {
      {
#line 2753
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 2753
        if (! (k <= 4)) {
#line 2753
          goto while_break;
        }
#line 2755
        mvx = MV[0][k][y][x];
#line 2756
        mvy = MV[1][k][y][x];
#line 2757
        if (bdx == 0) {
#line 2757
          tmp = ((trb - trd) * mvx) / trd;
        } else {
#line 2757
          tmp = ((trb * mvx) / trd + bdx) - mvx;
        }
#line 2757
        xvec += tmp;
#line 2758
        if (bdy == 0) {
#line 2758
          tmp___0 = ((trb - trd) * mvy) / trd;
        } else {
#line 2758
          tmp___0 = ((trb * mvy) / trd + bdy) - mvy;
        }
#line 2758
        yvec += tmp___0;
#line 2753
        k ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 2762
      if (xvec < 0) {
#line 2762
        tmp___1 = -1;
      } else {
#line 2762
        tmp___1 = 1;
      }
      {
      {
#line 2762
      tmp___2 = abs(xvec);
      }
      {
#line 2762
      tmp___3 = abs(xvec);
      }
#line 2762
      BMVx = tmp___1 * (roundtab[tmp___2 % 16] + (tmp___3 / 16) * 2);
      }
#line 2763
      if (yvec < 0) {
#line 2763
        tmp___4 = -1;
      } else {
#line 2763
        tmp___4 = 1;
      }
      {
      {
#line 2763
      tmp___5 = abs(yvec);
      }
      {
#line 2763
      tmp___6 = abs(yvec);
      }
#line 2763
      BMVy = tmp___4 * (roundtab[tmp___5 % 16] + (tmp___6 / 16) * 2);
      }
    }
  } else
#line 2767
  if (comp < 4) {
#line 2770
    mvx = MV[0][0][y][x];
#line 2771
    mvy = MV[1][0][y][x];
#line 2772
    if (bdx == 0) {
#line 2772
      BMVx = ((trb - trd) * mvx) / trd;
    } else {
#line 2772
      BMVx = ((trb * mvx) / trd + bdx) - mvx;
    }
#line 2773
    if (bdy == 0) {
#line 2773
      BMVy = ((trb - trd) * mvy) / trd;
    } else {
#line 2773
      BMVy = ((trb * mvy) / trd + bdy) - mvy;
    }
  } else {
#line 2777
    mvx = MV[0][0][y][x];
#line 2778
    mvy = MV[1][0][y][x];
#line 2779
    if (bdx == 0) {
#line 2779
      xvec = ((trb - trd) * mvx) / trd;
    } else {
#line 2779
      xvec = ((trb * mvx) / trd + bdx) - mvx;
    }
#line 2780
    if (bdy == 0) {
#line 2780
      yvec = ((trb - trd) * mvy) / trd;
    } else {
#line 2780
      yvec = ((trb * mvy) / trd + bdy) - mvy;
    }
#line 2781
    xvec *= 4;
#line 2782
    yvec *= 4;
#line 2785
    if (xvec < 0) {
#line 2785
      tmp___7 = -1;
    } else {
#line 2785
      tmp___7 = 1;
    }
    {
    {
#line 2785
    tmp___8 = abs(xvec);
    }
    {
#line 2785
    tmp___9 = abs(xvec);
    }
#line 2785
    BMVx = tmp___7 * (roundtab[tmp___8 % 16] + (tmp___9 / 16) * 2);
    }
#line 2786
    if (yvec < 0) {
#line 2786
      tmp___10 = -1;
    } else {
#line 2786
      tmp___10 = 1;
    }
    {
    {
#line 2786
    tmp___11 = abs(yvec);
    }
    {
#line 2786
    tmp___12 = abs(yvec);
    }
#line 2786
    BMVy = tmp___10 * (roundtab[tmp___11 % 16] + (tmp___12 / 16) * 2);
    }
  }
#line 2790
  if (comp < 4) {
#line 2790
    cc = 0;
  } else {
#line 2790
    cc = (comp & 1) + 1;
  }
#line 2792
  if (cc == 0) {
    {
    {
#line 2795
    find_bidir_limits(BMVx, & xa, & xb, comp & 1);
    }
    {
#line 2796
    find_bidir_limits(BMVy, & ya, & yb, (comp & 2) >> 1);
    }
#line 2797
    bfr = ((bframe[0] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 2799
    ffr = ((current_frame[0] + coded_picture_width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 2801
    ii = coded_picture_width;
    }
  } else {
    {
#line 2806
    bx >>= 1;
#line 2807
    by >>= 1;
    {
#line 2809
    find_bidir_chroma_limits(BMVx, & xa, & xb);
    }
    {
#line 2810
    find_bidir_chroma_limits(BMVy, & ya, & yb);
    }
#line 2812
    bfr = ((bframe[cc] + chrom_width * (by + ((comp & 2) << 2))) + bx) + (comp & 8);
#line 2813
    ffr = ((current_frame[cc] + chrom_width * (by + ((comp & 2) << 2))) + bx) + (comp & 8);
#line 2814
    ii = chrom_width;
    }
  }
#line 2817
  xint = BMVx >> 1;
#line 2818
  xhalf = BMVx - 2 * xint;
#line 2819
  yint = BMVy >> 1;
#line 2820
  yhalf = BMVy - 2 * yint;
#line 2822
  ffr += xint + (yint + ya) * ii;
#line 2823
  bfr += ya * ii;
#line 2825
  if (! xhalf) {
#line 2825
    if (! yhalf) {
#line 2827
      j = ya;
      {
      {
#line 2827
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 2827
        if (! (j < yb)) {
#line 2827
          goto while_break___0;
        }
#line 2829
        i = xa;
        {
        {
#line 2829
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 2829
          if (! (i < xb)) {
#line 2829
            goto while_break___1;
          }
#line 2831
          pel = (int )*(ffr + i);
#line 2832
          *(bfr + i) = (unsigned char )((unsigned int )(pel + (int )*(bfr + i)) >> 1);
#line 2829
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2834
        bfr += ii;
#line 2835
        ffr += ii;
#line 2827
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 2825
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2837
  if (xhalf) {
#line 2837
    if (! yhalf) {
#line 2839
      j = ya;
      {
      {
#line 2839
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 2839
        if (! (j < yb)) {
#line 2839
          goto while_break___2;
        }
#line 2841
        i = xa;
        {
        {
#line 2841
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 2841
          if (! (i < xb)) {
#line 2841
            goto while_break___3;
          }
#line 2843
          pel = (int )((unsigned int )(((int )*(ffr + i) + (int )*(ffr + (i + 1))) + 1) >> 1);
#line 2844
          *(bfr + i) = (unsigned char )((unsigned int )(pel + (int )*(bfr + i)) >> 1);
#line 2841
          i ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2846
        bfr += ii;
#line 2847
        ffr += ii;
#line 2839
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 2837
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2849
  if (! xhalf) {
#line 2849
    if (yhalf) {
#line 2851
      j = ya;
      {
      {
#line 2851
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 2851
        if (! (j < yb)) {
#line 2851
          goto while_break___4;
        }
#line 2853
        i = xa;
        {
        {
#line 2853
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 2853
          if (! (i < xb)) {
#line 2853
            goto while_break___5;
          }
#line 2855
          pel = (int )((unsigned int )(((int )*(ffr + i) + (int )*(ffr + (ii + i))) + 1) >> 1);
#line 2856
          *(bfr + i) = (unsigned char )((unsigned int )(pel + (int )*(bfr + i)) >> 1);
#line 2853
          i ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2858
        bfr += ii;
#line 2859
        ffr += ii;
#line 2851
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 2849
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 2863
    j = ya;
    {
    {
#line 2863
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 2863
      if (! (j < yb)) {
#line 2863
        goto while_break___6;
      }
#line 2865
      i = xa;
      {
      {
#line 2865
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 2865
        if (! (i < xb)) {
#line 2865
          goto while_break___7;
        }
#line 2867
        pel = (int )((unsigned int )(((((int )*(ffr + i) + (int )*(ffr + (i + 1))) + (int )*(ffr + (ii + i))) + (int )*(ffr + ((ii + i) + 1))) + 2) >> 2);
#line 2868
        *(bfr + i) = (unsigned char )((unsigned int )(pel + (int )*(bfr + i)) >> 1);
#line 2865
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2870
      bfr += ii;
#line 2871
      ffr += ii;
#line 2863
      j ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 2874
  return;
}
}
#line 2877 "getpic.c"
static int motion_decode(int vec , int pmv ) 
{ 


  {
#line 2879
  if (vec > 31) {
#line 2880
    vec -= 64;
  }
#line 2881
  vec += pmv;
#line 2882
  if (! long_vectors) {
#line 2884
    if (vec > 31) {
#line 2885
      vec -= 64;
    }
#line 2886
    if (vec < -32) {
#line 2887
      vec += 64;
    }
  } else {
#line 2890
    if (pmv < -31) {
#line 2890
      if (vec < -63) {
#line 2891
        vec += 64;
      }
    }
#line 2892
    if (pmv > 32) {
#line 2892
      if (vec > 63) {
#line 2893
        vec -= 64;
      }
    }
  }
#line 2895
  return (vec);
}
}
#line 2899 "getpic.c"
static int find_pmv(int x , int y , int block , int comp ) 
{ 
  int p1 ;
  int p2 ;
  int p3 ;
  int xin1 ;
  int xin2 ;
  int xin3 ;
  int yin1 ;
  int yin2 ;
  int yin3 ;
  int vec1 ;
  int vec2 ;
  int vec3 ;
  int l8 ;
  int o8 ;
  int or8 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp28 ;

  {
#line 2907
  x ++;
#line 2908
  y ++;
#line 2910
  if (modemap[y][x - 1] == 2) {
#line 2910
    l8 = 1;
  } else {
#line 2910
    l8 = 0;
  }
#line 2911
  if (modemap[y][x - 1] == 5) {
#line 2911
    l8 = 1;
  } else {
#line 2911
    l8 = l8;
  }
#line 2913
  if (modemap[y - 1][x] == 2) {
#line 2913
    o8 = 1;
  } else {
#line 2913
    o8 = 0;
  }
#line 2914
  if (modemap[y - 1][x] == 5) {
#line 2914
    o8 = 1;
  } else {
#line 2914
    o8 = o8;
  }
#line 2916
  if (modemap[y - 1][x + 1] == 2) {
#line 2916
    or8 = 1;
  } else {
#line 2916
    or8 = 0;
  }
#line 2917
  if (modemap[y - 1][x + 1] == 5) {
#line 2917
    or8 = 1;
  } else {
#line 2917
    or8 = or8;
  }
  {
#line 2922
  if (block == 0) {
#line 2922
    goto case_0;
  }
#line 2933
  if (block == 1) {
#line 2933
    goto case_1;
  }
#line 2944
  if (block == 2) {
#line 2944
    goto case_2;
  }
#line 2955
  if (block == 3) {
#line 2955
    goto case_3;
  }
#line 2966
  if (block == 4) {
#line 2966
    goto case_4;
  }
#line 2977
  if (block == 5) {
#line 2977
    goto case_5;
  }
#line 2988
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2923
  if (l8) {
#line 2923
    vec1 = 2;
  } else {
#line 2923
    vec1 = 0;
  }
#line 2924
  yin1 = y;
#line 2925
  xin1 = x - 1;
#line 2926
  if (o8) {
#line 2926
    vec2 = 3;
  } else {
#line 2926
    vec2 = 0;
  }
#line 2927
  yin2 = y - 1;
#line 2928
  xin2 = x;
#line 2929
  if (or8) {
#line 2929
    vec3 = 3;
  } else {
#line 2929
    vec3 = 0;
  }
#line 2930
  yin3 = y - 1;
#line 2931
  xin3 = x + 1;
#line 2932
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2934
  if (l8) {
#line 2934
    vec1 = 2;
  } else {
#line 2934
    vec1 = 0;
  }
#line 2935
  yin1 = y;
#line 2936
  xin1 = x - 1;
#line 2937
  if (o8) {
#line 2937
    vec2 = 3;
  } else {
#line 2937
    vec2 = 0;
  }
#line 2938
  yin2 = y - 1;
#line 2939
  xin2 = x;
#line 2940
  if (or8) {
#line 2940
    vec3 = 3;
  } else {
#line 2940
    vec3 = 0;
  }
#line 2941
  yin3 = y - 1;
#line 2942
  xin3 = x + 1;
#line 2943
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2945
  vec1 = 1;
#line 2946
  yin1 = y;
#line 2947
  xin1 = x;
#line 2948
  if (o8) {
#line 2948
    vec2 = 4;
  } else {
#line 2948
    vec2 = 0;
  }
#line 2949
  yin2 = y - 1;
#line 2950
  xin2 = x;
#line 2951
  if (or8) {
#line 2951
    vec3 = 3;
  } else {
#line 2951
    vec3 = 0;
  }
#line 2952
  yin3 = y - 1;
#line 2953
  xin3 = x + 1;
#line 2954
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2956
  if (l8) {
#line 2956
    vec1 = 4;
  } else {
#line 2956
    vec1 = 0;
  }
#line 2957
  yin1 = y;
#line 2958
  xin1 = x - 1;
#line 2959
  vec2 = 1;
#line 2960
  yin2 = y;
#line 2961
  xin2 = x;
#line 2962
  vec3 = 2;
#line 2963
  yin3 = y;
#line 2964
  xin3 = x;
#line 2965
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2967
  vec1 = 3;
#line 2968
  yin1 = y;
#line 2969
  xin1 = x;
#line 2970
  vec2 = 1;
#line 2971
  yin2 = y;
#line 2972
  xin2 = x;
#line 2973
  vec3 = 2;
#line 2974
  yin3 = y;
#line 2975
  xin3 = x;
#line 2976
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2978
  vec1 = 5;
#line 2979
  yin1 = y;
#line 2980
  xin1 = x - 1;
#line 2981
  vec2 = 5;
#line 2982
  yin2 = y - 1;
#line 2983
  xin2 = x;
#line 2984
  vec3 = 5;
#line 2985
  yin3 = y - 1;
#line 2986
  xin3 = x + 1;
#line 2987
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 2989
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal block number in find_pmv (getpic.c)\n");
  }
  {
#line 2990
  exit(1);
  }
  }
#line 2991
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2993
  p1 = MV[comp][vec1][yin1][xin1];
#line 2994
  p2 = MV[comp][vec2][yin2][xin2];
#line 2995
  p3 = MV[comp][vec3][yin3][xin3];
#line 2997
  if (newgob) {
#line 2997
    if (block == 0) {
#line 2998
      p2 = 999;
    } else
#line 2997
    if (block == 1) {
#line 2998
      p2 = 999;
    } else
#line 2997
    if (block == 2) {
#line 2998
      p2 = 999;
    }
  }
#line 3000
  if (p2 == 999) {
#line 3002
    p3 = p1;
#line 3002
    p2 = p3;
  }
#line 3004
  if (p2 > p3) {
#line 3004
    tmp___2 = p2;
  } else {
#line 3004
    tmp___2 = p3;
  }
#line 3004
  if (p1 > tmp___2) {
#line 3004
    tmp___1 = p1;
  } else {
#line 3004
    if (p2 > p3) {
#line 3004
      tmp___0 = p2;
    } else {
#line 3004
      tmp___0 = p3;
    }
#line 3004
    tmp___1 = tmp___0;
  }
#line 3004
  if (p2 < p3) {
#line 3004
    tmp___6 = p2;
  } else {
#line 3004
    tmp___6 = p3;
  }
#line 3004
  if (p1 < tmp___6) {
#line 3004
    tmp___5 = p1;
  } else {
#line 3004
    if (p2 < p3) {
#line 3004
      tmp___4 = p2;
    } else {
#line 3004
      tmp___4 = p3;
    }
#line 3004
    tmp___5 = tmp___4;
  }
#line 3004
  return ((((p1 + p2) + p3) - tmp___1) - tmp___5);
}
}
#line 3009 "getpic.c"
static void find_bidir_limits(int vec , int *start , int *stop , int nhv ) 
{ 


  {
#line 3012
  if (0 > (- vec + 1) / 2 - nhv * 8) {
#line 3012
    *start = 0;
  } else {
#line 3012
    *start = (- vec + 1) / 2 - nhv * 8;
  }
#line 3013
  if (7 < (15 - (vec + 1) / 2) - nhv * 8) {
#line 3013
    *stop = 7;
  } else {
#line 3013
    *stop = (15 - (vec + 1) / 2) - nhv * 8;
  }
#line 3015
  (*stop) ++;
#line 3016
  return;
}
}
#line 3018 "getpic.c"
static void find_bidir_chroma_limits(int vec , int *start , int *stop ) 
{ 


  {
#line 3022
  if (0 > (- vec + 1) / 2) {
#line 3022
    *start = 0;
  } else {
#line 3022
    *start = (- vec + 1) / 2;
  }
#line 3023
  if (7 < 7 - (vec + 1) / 2) {
#line 3023
    *stop = 7;
  } else {
#line 3023
    *stop = 7 - (vec + 1) / 2;
  }
#line 3025
  (*stop) ++;
#line 3026
  return;
}
}
#line 3029 "getpic.c"
static void make_edge_image(unsigned char *src , unsigned char *dst , int width ,
                            int height , int edge ) 
{ 
  int i ;
  int j ;
  unsigned char *p1 ;
  unsigned char *p2 ;
  unsigned char *p3 ;
  unsigned char *p4 ;
  unsigned char *o1 ;
  unsigned char *o2 ;
  unsigned char *o3 ;
  unsigned char *o4 ;

  {
#line 3037
  p1 = dst;
#line 3038
  o1 = src;
#line 3039
  j = 0;
  {
  {
#line 3039
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3039
    if (! (j < height)) {
#line 3039
      goto while_break;
    }
#line 3041
    i = 0;
    {
    {
#line 3041
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3041
      if (! (i < width)) {
#line 3041
        goto while_break___0;
      }
#line 3043
      *(p1 + i) = *(o1 + i);
#line 3041
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3045
    p1 += width + (edge << 1);
#line 3046
    o1 += width;
#line 3039
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3050
  p1 = dst - 1;
#line 3051
  o1 = src;
#line 3052
  j = 0;
  {
  {
#line 3052
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 3052
    if (! (j < height)) {
#line 3052
      goto while_break___1;
    }
#line 3054
    i = 0;
    {
    {
#line 3054
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 3054
      if (! (i < edge)) {
#line 3054
        goto while_break___2;
      }
#line 3056
      *(p1 - i) = *o1;
#line 3057
      *(((p1 + width) + i) + 1) = *((o1 + width) - 1);
#line 3054
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3059
    p1 += width + (edge << 1);
#line 3060
    o1 += width;
#line 3052
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3064
  p1 = dst;
#line 3065
  p2 = dst + (width + (edge << 1)) * (height - 1);
#line 3066
  o1 = src;
#line 3067
  o2 = src + width * (height - 1);
#line 3068
  j = 0;
  {
  {
#line 3068
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 3068
    if (! (j < edge)) {
#line 3068
      goto while_break___3;
    }
#line 3070
    p1 -= width + (edge << 1);
#line 3071
    p2 += width + (edge << 1);
#line 3072
    i = 0;
    {
    {
#line 3072
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 3072
      if (! (i < width)) {
#line 3072
        goto while_break___4;
      }
#line 3074
      *(p1 + i) = *(o1 + i);
#line 3075
      *(p2 + i) = *(o2 + i);
#line 3072
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3068
    j ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3080
  p1 = (dst - (width + (edge << 1))) - 1;
#line 3081
  p2 = (p1 + width) + 1;
#line 3082
  p3 = (dst + (width + (edge << 1)) * height) - 1;
#line 3083
  p4 = (p3 + width) + 1;
#line 3085
  o1 = src;
#line 3086
  o2 = (o1 + width) - 1;
#line 3087
  o3 = src + width * (height - 1);
#line 3088
  o4 = (o3 + width) - 1;
#line 3089
  j = 0;
  {
  {
#line 3089
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 3089
    if (! (j < edge)) {
#line 3089
      goto while_break___5;
    }
#line 3091
    i = 0;
    {
    {
#line 3091
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 3091
      if (! (i < edge)) {
#line 3091
        goto while_break___6;
      }
#line 3093
      *(p1 - i) = *o1;
#line 3094
      *(p2 + i) = *o2;
#line 3095
      *(p3 - i) = *o3;
#line 3096
      *(p4 + i) = *o4;
#line 3091
      i ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3098
    p1 -= width + (edge << 1);
#line 3099
    p2 -= width + (edge << 1);
#line 3100
    p3 = (p3 + width) + (edge << 1);
#line 3101
    p4 = (p4 + width) + (edge << 1);
#line 3089
    j ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3104
  return;
}
}
#line 3107 "getpic.c"
void interpolate_image(unsigned char *in , unsigned char *out , int width , int height ) 
{ 
  int x ;
  int xx ;
  int y ;
  int w2 ;
  unsigned char *pp ;
  unsigned char *ii ;

  {
#line 3115
  w2 = 2 * width;
#line 3118
  pp = out;
#line 3119
  ii = in;
#line 3120
  y = 0;
  {
  {
#line 3120
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3120
    if (! (y < height - 1)) {
#line 3120
      goto while_break;
    }
#line 3122
    x = 0;
#line 3122
    xx = 0;
    {
    {
#line 3122
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3122
      if (! (x < width - 1)) {
#line 3122
        goto while_break___0;
      }
#line 3124
      *(pp + xx) = *(ii + x);
#line 3125
      *((pp + xx) + 1) = (unsigned char )((unsigned int )((int )*(ii + x) + (int )*((ii + x) + 1)) >> 1);
#line 3126
      *((pp + w2) + xx) = (unsigned char )((unsigned int )((int )*(ii + x) + (int )*((ii + x) + width)) >> 1);
#line 3127
      *(((pp + w2) + xx) + 1) = (unsigned char )((unsigned int )((((int )*(ii + x) + (int )*((ii + x) + 1)) + (int )*((ii + x) + width)) + (int )*(((ii + x) + width) + 1)) >> 2);
#line 3122
      x ++;
#line 3122
      xx += 2;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3131
    *((pp + w2) - 2) = *((ii + width) - 1);
#line 3132
    *((pp + w2) - 1) = *((ii + width) - 1);
#line 3133
    *(((pp + w2) + w2) - 2) = *(((ii + width) + width) - 1);
#line 3134
    *(((pp + w2) + w2) - 1) = *(((ii + width) + width) - 1);
#line 3135
    pp += w2 << 1;
#line 3136
    ii += width;
#line 3120
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3140
  x = 0;
#line 3140
  xx = 0;
  {
  {
#line 3140
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 3140
    if (! (x < width - 1)) {
#line 3140
      goto while_break___1;
    }
#line 3142
    *(pp + xx) = *(ii + x);
#line 3143
    *((pp + xx) + 1) = (unsigned char )((unsigned int )(((int )*(ii + x) + (int )*((ii + x) + 1)) + 1) >> 1);
#line 3144
    *((pp + w2) + xx) = *(ii + x);
#line 3145
    *(((pp + w2) + xx) + 1) = (unsigned char )((unsigned int )(((int )*(ii + x) + (int )*((ii + x) + 1)) + 1) >> 1);
#line 3140
    x ++;
#line 3140
    xx += 2;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3149
  *((pp + (width << 1)) - 2) = *((ii + width) - 1);
#line 3150
  *((pp + (width << 1)) - 1) = *((ii + width) - 1);
#line 3151
  *((pp + (width << 2)) - 2) = *((ii + width) - 1);
#line 3152
  *((pp + (width << 2)) - 1) = *((ii + width) - 1);
#line 3154
  return;
}
}
#line 3176 "getpic.c"
void Intra_AC_DC_Decode(short *store_qcoeff , int INTRA_AC_DC , int MBA , int xpos ,
                        int ypos , int comp , int newgob___0 ) 
{ 
  int A[8] ;
  int B[8] ;
  int i ;
  int j ;
  int tempDC ;
  short *Rec_C ;
  short *rcoeff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 3185
  Rec_C = ld->block[comp];
#line 3187
  if (xpos == 0) {
#line 3187
    if (ypos == 0) {
#line 3189
      if (comp == 2) {
        {
        {
#line 3189
        fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
        }
        }
      } else
#line 3189
      if (comp == 3) {
        {
        {
#line 3189
        fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
        }
        }
      } else {
        {
        {
#line 3189
        fill_null(A);
        }
        }
      }
#line 3190
      if (comp == 1) {
        {
        {
#line 3190
        fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
        }
        }
      } else
#line 3190
      if (comp == 3) {
        {
        {
#line 3190
        fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
        }
        }
      } else {
        {
        {
#line 3190
        fill_null(B);
        }
        }
      }
    } else {
#line 3187
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 3193
  if (xpos == 0) {
#line 3195
    if (comp == 2) {
      {
      {
#line 3195
      fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
      }
      }
    } else
#line 3195
    if (comp == 3) {
      {
      {
#line 3195
      fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
      }
      }
    } else
#line 3195
    if (comp == 0) {
#line 3195
      goto _L___1;
    } else
#line 3195
    if (comp == 1) {
      _L___1: /* CIL Label */ 
#line 3195
      if (! newgob___0) {
        {
        {
#line 3195
        fill_A(A, store_qcoeff, xpos, ypos - 1, comp + 2);
        }
        }
      } else {
#line 3195
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 3195
    if (comp == 4) {
#line 3195
      goto _L;
    } else
#line 3195
    if (comp == 5) {
      _L: /* CIL Label */ 
#line 3195
      if (! newgob___0) {
        {
        {
#line 3195
        fill_A(A, store_qcoeff, xpos, ypos - 1, comp);
        }
        }
      } else {
        {
        {
#line 3195
        fill_null(A);
        }
        }
      }
    } else {
      {
      {
#line 3195
      fill_null(A);
      }
      }
    }
#line 3198
    if (comp == 1) {
      {
      {
#line 3198
      fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
      }
      }
    } else
#line 3198
    if (comp == 3) {
      {
      {
#line 3198
      fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
      }
      }
    } else {
      {
      {
#line 3198
      fill_null(B);
      }
      }
    }
  } else
#line 3201
  if (ypos == 0) {
#line 3203
    if (comp == 2) {
      {
      {
#line 3203
      fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
      }
      }
    } else
#line 3203
    if (comp == 3) {
      {
      {
#line 3203
      fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
      }
      }
    } else {
      {
      {
#line 3203
      fill_null(A);
      }
      }
    }
#line 3204
    if (comp == 4) {
      {
      {
#line 3204
      fill_B(B, store_qcoeff, xpos - 1, ypos, comp);
      }
      }
    } else
#line 3204
    if (comp == 5) {
      {
      {
#line 3204
      fill_B(B, store_qcoeff, xpos - 1, ypos, comp);
      }
      }
    } else
#line 3204
    if (comp == 1) {
      {
      {
#line 3204
      fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
      }
      }
    } else
#line 3204
    if (comp == 3) {
      {
      {
#line 3204
      fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
      }
      }
    } else {
      {
      {
#line 3204
      fill_B(B, store_qcoeff, xpos - 1, ypos, comp + 1);
      }
      }
    }
  } else {
#line 3210
    if (comp == 2) {
      {
      {
#line 3210
      fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
      }
      }
    } else
#line 3210
    if (comp == 3) {
      {
      {
#line 3210
      fill_A(A, store_qcoeff, xpos, ypos, comp - 2);
      }
      }
    } else
#line 3210
    if (comp == 0) {
#line 3210
      goto _L___4;
    } else
#line 3210
    if (comp == 1) {
      _L___4: /* CIL Label */ 
#line 3210
      if (! newgob___0) {
        {
        {
#line 3210
        fill_A(A, store_qcoeff, xpos, ypos - 1, comp + 2);
        }
        }
      } else {
#line 3210
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 3210
    if (comp == 4) {
#line 3210
      goto _L___2;
    } else
#line 3210
    if (comp == 5) {
      _L___2: /* CIL Label */ 
#line 3210
      if (! newgob___0) {
        {
        {
#line 3210
        fill_A(A, store_qcoeff, xpos, ypos - 1, comp);
        }
        }
      } else {
        {
        {
#line 3210
        fill_null(A);
        }
        }
      }
    } else {
      {
      {
#line 3210
      fill_null(A);
      }
      }
    }
#line 3214
    if (comp == 4) {
      {
      {
#line 3214
      fill_B(B, store_qcoeff, xpos - 1, ypos, comp);
      }
      }
    } else
#line 3214
    if (comp == 5) {
      {
      {
#line 3214
      fill_B(B, store_qcoeff, xpos - 1, ypos, comp);
      }
      }
    } else
#line 3214
    if (comp == 1) {
      {
      {
#line 3214
      fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
      }
      }
    } else
#line 3214
    if (comp == 3) {
      {
      {
#line 3214
      fill_B(B, store_qcoeff, xpos, ypos, comp - 1);
      }
      }
    } else {
      {
      {
#line 3214
      fill_B(B, store_qcoeff, xpos - 1, ypos, comp + 1);
      }
      }
    }
  }
  {
#line 3225
  if (INTRA_AC_DC == 0) {
#line 3225
    goto case_0;
  }
#line 3235
  if (INTRA_AC_DC == 2) {
#line 3235
    goto case_2;
  }
#line 3247
  if (INTRA_AC_DC == 3) {
#line 3247
    goto case_3;
  }
#line 3256
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3227
  if (A[0] == 1024) {
#line 3227
    if (B[0] == 1024) {
#line 3227
      tmp___1 = 1024;
    } else {
#line 3227
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
#line 3227
    if (A[0] == 1024) {
#line 3227
      tmp___0 = B[0];
    } else {
#line 3227
      if (B[0] == 1024) {
#line 3227
        tmp = A[0];
      } else {
#line 3227
        tmp = (A[0] + B[0]) / 2;
      }
#line 3227
      tmp___0 = tmp;
    }
#line 3227
    tmp___1 = tmp___0;
  }
#line 3227
  tempDC = (int )*(Rec_C + 0) + tmp___1;
#line 3230
  i = 0;
  {
  {
#line 3230
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3230
    if (! (i < 8)) {
#line 3230
      goto while_break;
    }
#line 3231
    j = 0;
    {
    {
#line 3231
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3231
      if (! (j < 8)) {
#line 3231
        goto while_break___0;
      }
      {
      {
#line 3232
      tmp___2 = clipAC((int )*(Rec_C + (i * 8 + j)));
      }
#line 3232
      *(Rec_C + (i * 8 + j)) = (short )tmp___2;
#line 3231
      j ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3230
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 3233
  tmp___3 = oddifyclipDC(tempDC);
  }
#line 3233
  *(Rec_C + 0) = (short )tmp___3;
  }
#line 3234
  goto switch_break;
  case_2: /* CIL Label */ 
#line 3236
  tempDC = (int )*(Rec_C + 0) + A[0];
#line 3237
  i = 1;
  {
  {
#line 3237
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 3237
    if (! (i < 8)) {
#line 3237
      goto while_break___1;
    }
    {
#line 3239
    rcoeff = Rec_C + i;
    {
#line 3240
    tmp___4 = clipAC((int )*(Rec_C + i) + A[i]);
    }
#line 3240
    *rcoeff = (short )tmp___4;
#line 3237
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3242
  i = 1;
  {
  {
#line 3242
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 3242
    if (! (i < 8)) {
#line 3242
      goto while_break___2;
    }
#line 3243
    j = 0;
    {
    {
#line 3243
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 3243
      if (! (j < 8)) {
#line 3243
        goto while_break___3;
      }
      {
      {
#line 3244
      tmp___5 = clipAC((int )*(Rec_C + (i * 8 + j)));
      }
#line 3244
      *(Rec_C + (i * 8 + j)) = (short )tmp___5;
#line 3243
      j ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3242
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 3245
  tmp___6 = oddifyclipDC(tempDC);
  }
#line 3245
  *(Rec_C + 0) = (short )tmp___6;
  }
#line 3246
  goto switch_break;
  case_3: /* CIL Label */ 
#line 3248
  tempDC = (int )*(Rec_C + 0) + B[0];
#line 3249
  i = 1;
  {
  {
#line 3249
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 3249
    if (! (i < 8)) {
#line 3249
      goto while_break___4;
    }
    {
    {
#line 3250
    tmp___7 = clipAC((int )*(Rec_C + i * 8) + B[i]);
    }
#line 3250
    *(Rec_C + i * 8) = (short )tmp___7;
#line 3249
    i ++;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3251
  i = 0;
  {
  {
#line 3251
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 3251
    if (! (i < 8)) {
#line 3251
      goto while_break___5;
    }
#line 3252
    j = 1;
    {
    {
#line 3252
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 3252
      if (! (j < 8)) {
#line 3252
        goto while_break___6;
      }
      {
      {
#line 3253
      tmp___8 = clipAC((int )*(Rec_C + (i * 8 + j)));
      }
#line 3253
      *(Rec_C + (i * 8 + j)) = (short )tmp___8;
#line 3252
      j ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3251
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
  {
#line 3254
  tmp___9 = oddifyclipDC(tempDC);
  }
#line 3254
  *(Rec_C + 0) = (short )tmp___9;
  }
#line 3255
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 3257
  printf((char const   */* __restrict  */)"Error in Prediction in Advanced Intra Coding\n");
  }
  {
#line 3258
  exit(-1);
  }
  }
#line 3259
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3263
  return;
}
}
#line 3283 "getpic.c"
void fill_null(int *pred ) 
{ 
  int j ;

  {
#line 3287
  *(pred + 0) = 1024;
#line 3288
  j = 1;
  {
  {
#line 3288
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3288
    if (! (j < 8)) {
#line 3288
      goto while_break;
    }
#line 3290
    *(pred + j) = 0;
#line 3288
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3292
  return;
}
}
#line 3294 "getpic.c"
void fill_A(int *pred , short *store_qcoeff , int xpos , int ypos , int block ) 
{ 
  int j ;

  {
#line 3298
  j = 0;
  {
  {
#line 3298
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3298
    if (! (j < 8)) {
#line 3298
      goto while_break;
    }
#line 3300
    *(pred + j) = (int )*(((store_qcoeff + (ypos * mb_width + xpos) * 384) + block * 64) + j);
#line 3298
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3302
  return;
}
}
#line 3304 "getpic.c"
void fill_B(int *pred , short *store_qcoeff , int xpos , int ypos , int block ) 
{ 
  int j ;

  {
#line 3308
  j = 0;
  {
  {
#line 3308
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3308
    if (! (j < 8)) {
#line 3308
      goto while_break;
    }
#line 3310
    *(pred + j) = (int )*(((store_qcoeff + (ypos * mb_width + xpos) * 384) + block * 64) + j * 8);
#line 3308
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3312
  return;
}
}
#line 3314 "getpic.c"
int oddifyclipDC(int x ) 
{ 
  int result ;

  {
#line 3320
  if (x % 2) {
    {
    {
#line 3320
    result = clipDC(x);
    }
    }
  } else {
    {
    {
#line 3320
    result = clipDC(x + 1);
    }
    }
  }
#line 3321
  return (result);
}
}
#line 3323 "getpic.c"
int clipAC(int x ) 
{ 
  int clipped ;

  {
#line 3327
  if (x > 2047) {
#line 3328
    clipped = 2047;
  } else
#line 3329
  if (x < -2048) {
#line 3330
    clipped = -2048;
  } else {
#line 3332
    clipped = x;
  }
#line 3333
  return (clipped);
}
}
#line 3336 "getpic.c"
int clipDC(int x ) 
{ 
  int clipped ;

  {
#line 3339
  if (x > 2047) {
#line 3340
    clipped = 2047;
  } else
#line 3341
  if (x < 0) {
#line 3342
    clipped = 0;
  } else {
#line 3344
    clipped = x;
  }
#line 3345
  return (clipped);
}
}
#line 3371 "getpic.c"
void edge_filter(unsigned char *lum , unsigned char *Cb , unsigned char *Cr , int width ,
                 int height ) 
{ 


  {
  {
  {
#line 3376
  horiz_edge_filter(lum, width, height, 0);
  }
  {
#line 3377
  vert_edge_filter(lum, width, height, 0);
  }
  {
#line 3380
  horiz_edge_filter(Cb, width / 2, height / 2, 1);
  }
  {
#line 3381
  vert_edge_filter(Cb, width / 2, height / 2, 1);
  }
  {
#line 3382
  horiz_edge_filter(Cr, width / 2, height / 2, 1);
  }
  {
#line 3383
  vert_edge_filter(Cr, width / 2, height / 2, 1);
  }
  }
#line 3386
  return;
}
}
#line 3393 "getpic.c"
void horiz_edge_filter(unsigned char *rec___0 , int width , int height , int chr ) 
{ 
  int i ;
  int j ;
  int delta ;
  int d1 ;
  int d2 ;
  int mbc ;
  int mbr ;
  int do_filter ;
  int QP ;
  int mbr_above ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___30 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___44 ;
  int tmp___45 ;

  {
#line 3403
  j = 8;
  {
  {
#line 3403
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3403
    if (! (j < height)) {
#line 3403
      goto while_break;
    }
#line 3405
    i = 0;
    {
    {
#line 3405
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3405
      if (! (i < width)) {
#line 3405
        goto while_break___0;
      }
#line 3407
      if (! chr) {
#line 3409
        mbr = j >> 4;
#line 3410
        mbc = i >> 4;
#line 3411
        mbr_above = (j - 8) >> 4;
      } else {
#line 3414
        mbr = j >> 3;
#line 3415
        mbc = i >> 3;
#line 3416
        mbr_above = mbr - 1;
      }
#line 3419
      if (coded_map[mbr + 1][mbc + 1]) {
#line 3419
        tmp = 1;
      } else
#line 3419
      if (coded_map[mbr_above + 1][mbc + 1]) {
#line 3419
        tmp = 1;
      } else {
#line 3419
        tmp = 0;
      }
#line 3419
      do_filter = tmp;
#line 3420
      if (do_filter) {
#line 3422
        if (pb_frame) {
#line 3424
          if (coded_map[mbr + 1][mbc + 1]) {
#line 3424
            if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3424
              tmp___3 = 31;
            } else {
#line 3424
              tmp___3 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
            }
#line 3424
            if (1 > tmp___3) {
#line 3424
              tmp___2 = 1;
            } else {
#line 3424
              if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3424
                tmp___1 = 31;
              } else {
#line 3424
                tmp___1 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
              }
#line 3424
              tmp___2 = tmp___1;
            }
#line 3424
            QP = tmp___2;
          } else {
#line 3424
            if (31 < (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4) {
#line 3424
              tmp___7 = 31;
            } else {
#line 3424
              tmp___7 = (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4;
            }
#line 3424
            if (1 > tmp___7) {
#line 3424
              tmp___6 = 1;
            } else {
#line 3424
              if (31 < (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4) {
#line 3424
                tmp___5 = 31;
              } else {
#line 3424
                tmp___5 = (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4;
              }
#line 3424
              tmp___6 = tmp___5;
            }
#line 3424
            QP = tmp___6;
          }
        } else
#line 3428
        if (coded_map[mbr + 1][mbc + 1]) {
#line 3428
          QP = quant_map[mbr + 1][mbc + 1];
        } else {
#line 3428
          QP = quant_map[mbr_above + 1][mbc + 1];
        }
#line 3429
        if (chr) {
#line 3429
          if (modified_quantization_mode) {
#line 3431
            QP = MQ_chroma_QP_table[QP];
          }
        }
#line 3434
        delta = (int )((double )((((int )*((rec___0 + i) + (j - 2) * width) + (int )*((rec___0 + i) + (j - 1) * width) * -4) + (int )*((rec___0 + i) + j * width) * 4) + (int )*((rec___0 + i) + (j + 1) * width) * -1) / 8.0);
#line 3439
        if (delta < 0) {
#line 3439
          tmp___8 = -1;
        } else {
#line 3439
          tmp___8 = 1;
        }
        {
        {
#line 3439
        tmp___20 = abs(delta);
        }
        {
#line 3439
        tmp___24 = abs(delta);
        }
        }
#line 3439
        if (0 > 2 * (tmp___24 - STRENGTH[QP - 1])) {
#line 3439
          tmp___23 = 0;
        } else {
          {
          {
#line 3439
          tmp___22 = abs(delta);
          }
#line 3439
          tmp___23 = 2 * (tmp___22 - STRENGTH[QP - 1]);
          }
        }
#line 3439
        if (0 > tmp___20 - tmp___23) {
#line 3439
          tmp___19 = 0;
        } else {
          {
          {
#line 3439
          tmp___14 = abs(delta);
          }
          {
#line 3439
          tmp___18 = abs(delta);
          }
          }
#line 3439
          if (0 > 2 * (tmp___18 - STRENGTH[QP - 1])) {
#line 3439
            tmp___17 = 0;
          } else {
            {
            {
#line 3439
            tmp___16 = abs(delta);
            }
#line 3439
            tmp___17 = 2 * (tmp___16 - STRENGTH[QP - 1]);
            }
          }
#line 3439
          tmp___19 = tmp___14 - tmp___17;
        }
        {
#line 3439
        d1 = tmp___8 * tmp___19;
        {
#line 3441
        tmp___35 = abs(d1 / 2);
        }
        {
#line 3441
        tmp___39 = abs(d1 / 2);
        }
        }
#line 3441
        if (- tmp___39 > ((int )*((rec___0 + i) + (j - 2) * width) - (int )*((rec___0 + i) + (j + 1) * width)) / 4) {
          {
          {
#line 3441
          tmp___37 = abs(d1 / 2);
          }
#line 3441
          tmp___38 = - tmp___37;
          }
        } else {
#line 3441
          tmp___38 = ((int )*((rec___0 + i) + (j - 2) * width) - (int )*((rec___0 + i) + (j + 1) * width)) / 4;
        }
#line 3441
        if (tmp___35 < tmp___38) {
          {
          {
#line 3441
          tmp___30 = abs(d1 / 2);
          }
#line 3441
          d2 = tmp___30;
          }
        } else {
          {
          {
#line 3441
          tmp___34 = abs(d1 / 2);
          }
          }
#line 3441
          if (- tmp___34 > ((int )*((rec___0 + i) + (j - 2) * width) - (int )*((rec___0 + i) + (j + 1) * width)) / 4) {
            {
            {
#line 3441
            tmp___32 = abs(d1 / 2);
            }
#line 3441
            tmp___33 = - tmp___32;
            }
          } else {
#line 3441
            tmp___33 = ((int )*((rec___0 + i) + (j - 2) * width) - (int )*((rec___0 + i) + (j + 1) * width)) / 4;
          }
#line 3441
          d2 = tmp___33;
        }
#line 3444
        *((rec___0 + i) + (j + 1) * width) = (unsigned char )((int )*((rec___0 + i) + (j + 1) * width) + d2);
#line 3445
        if (0 > (int )*((rec___0 + i) + j * width) - d1) {
#line 3445
          tmp___42 = 0;
        } else {
#line 3445
          tmp___42 = (int )*((rec___0 + i) + j * width) - d1;
        }
#line 3445
        if (255 < tmp___42) {
#line 3445
          *((rec___0 + i) + j * width) = (unsigned char)255;
        } else {
#line 3445
          if (0 > (int )*((rec___0 + i) + j * width) - d1) {
#line 3445
            tmp___41 = 0;
          } else {
#line 3445
            tmp___41 = (int )*((rec___0 + i) + j * width) - d1;
          }
#line 3445
          *((rec___0 + i) + j * width) = (unsigned char )tmp___41;
        }
#line 3446
        if (0 > (int )*((rec___0 + i) + (j - 1) * width) + d1) {
#line 3446
          tmp___45 = 0;
        } else {
#line 3446
          tmp___45 = (int )*((rec___0 + i) + (j - 1) * width) + d1;
        }
#line 3446
        if (255 < tmp___45) {
#line 3446
          *((rec___0 + i) + (j - 1) * width) = (unsigned char)255;
        } else {
#line 3446
          if (0 > (int )*((rec___0 + i) + (j - 1) * width) + d1) {
#line 3446
            tmp___44 = 0;
          } else {
#line 3446
            tmp___44 = (int )*((rec___0 + i) + (j - 1) * width) + d1;
          }
#line 3446
          *((rec___0 + i) + (j - 1) * width) = (unsigned char )tmp___44;
        }
#line 3447
        *((rec___0 + i) + (j - 2) * width) = (unsigned char )((int )*((rec___0 + i) + (j - 2) * width) - d2);
      }
#line 3405
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3403
    j += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3451
  return;
}
}
#line 3454 "getpic.c"
void vert_edge_filter(unsigned char *rec___0 , int width , int height , int chr ) 
{ 
  int i ;
  int j ;
  int delta ;
  int d1 ;
  int d2 ;
  int mbc ;
  int mbr ;
  int do_filter ;
  int QP ;
  int mbc_left ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___30 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___44 ;
  int tmp___45 ;

  {
#line 3465
  i = 8;
  {
  {
#line 3465
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3465
    if (! (i < width)) {
#line 3465
      goto while_break;
    }
#line 3467
    j = 0;
    {
    {
#line 3467
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3467
      if (! (j < height)) {
#line 3467
        goto while_break___0;
      }
#line 3469
      if (! chr) {
#line 3471
        mbr = j >> 4;
#line 3472
        mbc = i >> 4;
#line 3473
        mbc_left = (i - 8) >> 4;
      } else {
#line 3477
        mbr = j >> 3;
#line 3478
        mbc = i >> 3;
#line 3479
        mbc_left = mbc - 1;
      }
#line 3481
      if (coded_map[mbr + 1][mbc + 1]) {
#line 3481
        tmp = 1;
      } else
#line 3481
      if (coded_map[mbr + 1][mbc_left + 1]) {
#line 3481
        tmp = 1;
      } else {
#line 3481
        tmp = 0;
      }
#line 3481
      do_filter = tmp;
#line 3483
      if (do_filter) {
#line 3485
        if (pb_frame) {
#line 3487
          if (coded_map[mbr + 1][mbc + 1]) {
#line 3487
            if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3487
              tmp___3 = 31;
            } else {
#line 3487
              tmp___3 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
            }
#line 3487
            if (1 > tmp___3) {
#line 3487
              tmp___2 = 1;
            } else {
#line 3487
              if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3487
                tmp___1 = 31;
              } else {
#line 3487
                tmp___1 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
              }
#line 3487
              tmp___2 = tmp___1;
            }
#line 3487
            QP = tmp___2;
          } else {
#line 3487
            if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4) {
#line 3487
              tmp___7 = 31;
            } else {
#line 3487
              tmp___7 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4;
            }
#line 3487
            if (1 > tmp___7) {
#line 3487
              tmp___6 = 1;
            } else {
#line 3487
              if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4) {
#line 3487
                tmp___5 = 31;
              } else {
#line 3487
                tmp___5 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4;
              }
#line 3487
              tmp___6 = tmp___5;
            }
#line 3487
            QP = tmp___6;
          }
        } else
#line 3492
        if (coded_map[mbr + 1][mbc + 1]) {
#line 3492
          QP = quant_map[mbr + 1][mbc + 1];
        } else {
#line 3492
          QP = quant_map[mbr + 1][mbc_left + 1];
        }
#line 3494
        if (chr) {
#line 3494
          if (modified_quantization_mode) {
#line 3496
            QP = MQ_chroma_QP_table[QP];
          }
        }
#line 3499
        delta = (int )((double )((((int )*(((rec___0 + i) - 2) + j * width) + (int )*(((rec___0 + i) - 1) + j * width) * -4) + (int )*((rec___0 + i) + j * width) * 4) + (int )*(((rec___0 + i) + 1) + j * width) * -1) / 8.0);
#line 3504
        if (delta < 0) {
#line 3504
          tmp___8 = -1;
        } else {
#line 3504
          tmp___8 = 1;
        }
        {
        {
#line 3504
        tmp___20 = abs(delta);
        }
        {
#line 3504
        tmp___24 = abs(delta);
        }
        }
#line 3504
        if (0 > 2 * (tmp___24 - STRENGTH[QP - 1])) {
#line 3504
          tmp___23 = 0;
        } else {
          {
          {
#line 3504
          tmp___22 = abs(delta);
          }
#line 3504
          tmp___23 = 2 * (tmp___22 - STRENGTH[QP - 1]);
          }
        }
#line 3504
        if (0 > tmp___20 - tmp___23) {
#line 3504
          tmp___19 = 0;
        } else {
          {
          {
#line 3504
          tmp___14 = abs(delta);
          }
          {
#line 3504
          tmp___18 = abs(delta);
          }
          }
#line 3504
          if (0 > 2 * (tmp___18 - STRENGTH[QP - 1])) {
#line 3504
            tmp___17 = 0;
          } else {
            {
            {
#line 3504
            tmp___16 = abs(delta);
            }
#line 3504
            tmp___17 = 2 * (tmp___16 - STRENGTH[QP - 1]);
            }
          }
#line 3504
          tmp___19 = tmp___14 - tmp___17;
        }
        {
#line 3504
        d1 = tmp___8 * tmp___19;
        {
#line 3507
        tmp___35 = abs(d1 / 2);
        }
        {
#line 3507
        tmp___39 = abs(d1 / 2);
        }
        }
#line 3507
        if (- tmp___39 > ((int )*(((rec___0 + i) - 2) + j * width) - (int )*(((rec___0 + i) + 1) + j * width)) / 4) {
          {
          {
#line 3507
          tmp___37 = abs(d1 / 2);
          }
#line 3507
          tmp___38 = - tmp___37;
          }
        } else {
#line 3507
          tmp___38 = ((int )*(((rec___0 + i) - 2) + j * width) - (int )*(((rec___0 + i) + 1) + j * width)) / 4;
        }
#line 3507
        if (tmp___35 < tmp___38) {
          {
          {
#line 3507
          tmp___30 = abs(d1 / 2);
          }
#line 3507
          d2 = tmp___30;
          }
        } else {
          {
          {
#line 3507
          tmp___34 = abs(d1 / 2);
          }
          }
#line 3507
          if (- tmp___34 > ((int )*(((rec___0 + i) - 2) + j * width) - (int )*(((rec___0 + i) + 1) + j * width)) / 4) {
            {
            {
#line 3507
            tmp___32 = abs(d1 / 2);
            }
#line 3507
            tmp___33 = - tmp___32;
            }
          } else {
#line 3507
            tmp___33 = ((int )*(((rec___0 + i) - 2) + j * width) - (int )*(((rec___0 + i) + 1) + j * width)) / 4;
          }
#line 3507
          d2 = tmp___33;
        }
#line 3511
        *(((rec___0 + i) + 1) + j * width) = (unsigned char )((int )*(((rec___0 + i) + 1) + j * width) + d2);
#line 3512
        if (0 > (int )*((rec___0 + i) + j * width) - d1) {
#line 3512
          tmp___42 = 0;
        } else {
#line 3512
          tmp___42 = (int )*((rec___0 + i) + j * width) - d1;
        }
#line 3512
        if (255 < tmp___42) {
#line 3512
          *((rec___0 + i) + j * width) = (unsigned char)255;
        } else {
#line 3512
          if (0 > (int )*((rec___0 + i) + j * width) - d1) {
#line 3512
            tmp___41 = 0;
          } else {
#line 3512
            tmp___41 = (int )*((rec___0 + i) + j * width) - d1;
          }
#line 3512
          *((rec___0 + i) + j * width) = (unsigned char )tmp___41;
        }
#line 3513
        if (0 > (int )*(((rec___0 + i) - 1) + j * width) + d1) {
#line 3513
          tmp___45 = 0;
        } else {
#line 3513
          tmp___45 = (int )*(((rec___0 + i) - 1) + j * width) + d1;
        }
#line 3513
        if (255 < tmp___45) {
#line 3513
          *(((rec___0 + i) - 1) + j * width) = (unsigned char)255;
        } else {
#line 3513
          if (0 > (int )*(((rec___0 + i) - 1) + j * width) + d1) {
#line 3513
            tmp___44 = 0;
          } else {
#line 3513
            tmp___44 = (int )*(((rec___0 + i) - 1) + j * width) + d1;
          }
#line 3513
          *(((rec___0 + i) - 1) + j * width) = (unsigned char )tmp___44;
        }
#line 3514
        *(((rec___0 + i) - 2) + j * width) = (unsigned char )((int )*(((rec___0 + i) - 2) + j * width) - d2);
      }
#line 3467
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3465
    i += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3518
  return;
}
}
#line 3541 "getpic.c"
void PostFilter(unsigned char *lum , unsigned char *Cb , unsigned char *Cr , int width ,
                int height ) 
{ 


  {
  {
  {
#line 3546
  horiz_post_filter(lum, width, height, 0);
  }
  {
#line 3547
  vert_post_filter(lum, width, height, 0);
  }
  {
#line 3550
  horiz_post_filter(Cb, width / 2, height / 2, 1);
  }
  {
#line 3551
  vert_post_filter(Cb, width / 2, height / 2, 1);
  }
  {
#line 3552
  horiz_post_filter(Cr, width / 2, height / 2, 1);
  }
  {
#line 3553
  vert_post_filter(Cr, width / 2, height / 2, 1);
  }
  }
#line 3556
  return;
}
}
#line 3563 "getpic.c"
void horiz_post_filter(unsigned char *rec___0 , int width , int height , int chr ) 
{ 
  int i ;
  int j ;
  int delta ;
  int d1 ;
  int mbc ;
  int mbr ;
  int QP ;
  int mbr_above ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___13 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 3573
  j = 8;
  {
  {
#line 3573
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3573
    if (! (j < height)) {
#line 3573
      goto while_break;
    }
#line 3575
    i = 0;
    {
    {
#line 3575
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3575
      if (! (i < width)) {
#line 3575
        goto while_break___0;
      }
#line 3577
      if (! chr) {
#line 3579
        mbr = j >> 4;
#line 3580
        mbc = i >> 4;
#line 3581
        mbr_above = (j - 8) >> 4;
      } else {
#line 3584
        mbr = j >> 3;
#line 3585
        mbc = i >> 3;
#line 3586
        mbr_above = mbr - 1;
      }
#line 3590
      if (pb_frame) {
#line 3592
        if (coded_map[mbr + 1][mbc + 1]) {
#line 3592
          if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3592
            tmp___2 = 31;
          } else {
#line 3592
            tmp___2 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
          }
#line 3592
          if (1 > tmp___2) {
#line 3592
            tmp___1 = 1;
          } else {
#line 3592
            if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3592
              tmp___0 = 31;
            } else {
#line 3592
              tmp___0 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
            }
#line 3592
            tmp___1 = tmp___0;
          }
#line 3592
          QP = tmp___1;
        } else {
#line 3592
          if (31 < (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4) {
#line 3592
            tmp___6 = 31;
          } else {
#line 3592
            tmp___6 = (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4;
          }
#line 3592
          if (1 > tmp___6) {
#line 3592
            tmp___5 = 1;
          } else {
#line 3592
            if (31 < (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4) {
#line 3592
              tmp___4 = 31;
            } else {
#line 3592
              tmp___4 = (bquant_tab[bquant] * quant_map[mbr_above + 1][mbc + 1]) / 4;
            }
#line 3592
            tmp___5 = tmp___4;
          }
#line 3592
          QP = tmp___5;
        }
      } else
#line 3596
      if (coded_map[mbr + 1][mbc + 1]) {
#line 3596
        QP = quant_map[mbr + 1][mbc + 1];
      } else {
#line 3596
        QP = quant_map[mbr_above + 1][mbc + 1];
      }
#line 3599
      delta = (int )((double )(((((((int )*((rec___0 + i) + (j - 3) * width) + (int )*((rec___0 + i) + (j - 2) * width)) + (int )*((rec___0 + i) + (j - 1) * width)) + (int )*((rec___0 + i) + j * width) * -6) + (int )*((rec___0 + i) + (j + 1) * width)) + (int )*((rec___0 + i) + (j + 2) * width)) + (int )*((rec___0 + i) + (j + 3) * width)) / 8.0);
#line 3607
      if (delta < 0) {
#line 3607
        tmp___7 = -1;
      } else {
#line 3607
        tmp___7 = 1;
      }
      {
      {
#line 3607
      tmp___19 = abs(delta);
      }
      {
#line 3607
      tmp___23 = abs(delta);
      }
      }
#line 3607
      if (0 > 2 * (tmp___23 - STRENGTH1[QP - 1])) {
#line 3607
        tmp___22 = 0;
      } else {
        {
        {
#line 3607
        tmp___21 = abs(delta);
        }
#line 3607
        tmp___22 = 2 * (tmp___21 - STRENGTH1[QP - 1]);
        }
      }
#line 3607
      if (0 > tmp___19 - tmp___22) {
#line 3607
        tmp___18 = 0;
      } else {
        {
        {
#line 3607
        tmp___13 = abs(delta);
        }
        {
#line 3607
        tmp___17 = abs(delta);
        }
        }
#line 3607
        if (0 > 2 * (tmp___17 - STRENGTH1[QP - 1])) {
#line 3607
          tmp___16 = 0;
        } else {
          {
          {
#line 3607
          tmp___15 = abs(delta);
          }
#line 3607
          tmp___16 = 2 * (tmp___15 - STRENGTH1[QP - 1]);
          }
        }
#line 3607
        tmp___18 = tmp___13 - tmp___16;
      }
#line 3607
      d1 = tmp___7 * tmp___18;
#line 3610
      *((rec___0 + i) + j * width) = (unsigned char )((int )*((rec___0 + i) + j * width) + d1);
#line 3575
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3573
    j += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3613
  return;
}
}
#line 3616 "getpic.c"
void vert_post_filter(unsigned char *rec___0 , int width , int height , int chr ) 
{ 
  int i ;
  int j ;
  int delta ;
  int d1 ;
  int mbc ;
  int mbr ;
  int QP ;
  int mbc_left ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___13 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 3626
  i = 8;
  {
  {
#line 3626
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3626
    if (! (i < width)) {
#line 3626
      goto while_break;
    }
#line 3628
    j = 0;
    {
    {
#line 3628
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3628
      if (! (j < height)) {
#line 3628
        goto while_break___0;
      }
#line 3630
      if (! chr) {
#line 3632
        mbr = j >> 4;
#line 3633
        mbc = i >> 4;
#line 3634
        mbc_left = (i - 8) >> 4;
      } else {
#line 3637
        mbr = j >> 3;
#line 3638
        mbc = i >> 3;
#line 3639
        mbc_left = mbc - 1;
      }
#line 3642
      if (pb_frame) {
#line 3644
        if (coded_map[mbr + 1][mbc + 1]) {
#line 3644
          if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3644
            tmp___2 = 31;
          } else {
#line 3644
            tmp___2 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
          }
#line 3644
          if (1 > tmp___2) {
#line 3644
            tmp___1 = 1;
          } else {
#line 3644
            if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4) {
#line 3644
              tmp___0 = 31;
            } else {
#line 3644
              tmp___0 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc + 1]) / 4;
            }
#line 3644
            tmp___1 = tmp___0;
          }
#line 3644
          QP = tmp___1;
        } else {
#line 3644
          if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4) {
#line 3644
            tmp___6 = 31;
          } else {
#line 3644
            tmp___6 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4;
          }
#line 3644
          if (1 > tmp___6) {
#line 3644
            tmp___5 = 1;
          } else {
#line 3644
            if (31 < (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4) {
#line 3644
              tmp___4 = 31;
            } else {
#line 3644
              tmp___4 = (bquant_tab[bquant] * quant_map[mbr + 1][mbc_left + 1]) / 4;
            }
#line 3644
            tmp___5 = tmp___4;
          }
#line 3644
          QP = tmp___5;
        }
      } else
#line 3648
      if (coded_map[mbr + 1][mbc + 1]) {
#line 3648
        QP = quant_map[mbr + 1][mbc + 1];
      } else {
#line 3648
        QP = quant_map[mbr + 1][mbc_left + 1];
      }
#line 3651
      delta = (int )((double )(((((((int )*(((rec___0 + i) - 3) + j * width) + (int )*(((rec___0 + i) - 2) + j * width)) + (int )*(((rec___0 + i) - 1) + j * width)) + (int )*((rec___0 + i) + j * width) * -6) + (int )*(((rec___0 + i) + 1) + j * width)) + (int )*(((rec___0 + i) + 2) + j * width)) + (int )*(((rec___0 + i) + 3) + j * width)) / 8.0);
#line 3659
      if (delta < 0) {
#line 3659
        tmp___7 = -1;
      } else {
#line 3659
        tmp___7 = 1;
      }
      {
      {
#line 3659
      tmp___19 = abs(delta);
      }
      {
#line 3659
      tmp___23 = abs(delta);
      }
      }
#line 3659
      if (0 > 2 * (tmp___23 - STRENGTH2[QP - 1])) {
#line 3659
        tmp___22 = 0;
      } else {
        {
        {
#line 3659
        tmp___21 = abs(delta);
        }
#line 3659
        tmp___22 = 2 * (tmp___21 - STRENGTH2[QP - 1]);
        }
      }
#line 3659
      if (0 > tmp___19 - tmp___22) {
#line 3659
        tmp___18 = 0;
      } else {
        {
        {
#line 3659
        tmp___13 = abs(delta);
        }
        {
#line 3659
        tmp___17 = abs(delta);
        }
        }
#line 3659
        if (0 > 2 * (tmp___17 - STRENGTH2[QP - 1])) {
#line 3659
          tmp___16 = 0;
        } else {
          {
          {
#line 3659
          tmp___15 = abs(delta);
          }
#line 3659
          tmp___16 = 2 * (tmp___15 - STRENGTH2[QP - 1]);
          }
        }
#line 3659
        tmp___18 = tmp___13 - tmp___16;
      }
#line 3659
      d1 = tmp___7 * tmp___18;
#line 3662
      *((rec___0 + i) + j * width) = (unsigned char )((int )*((rec___0 + i) + j * width) + d1);
#line 3628
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3626
    i += 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3665
  return;
}
}
#line 3684 "getpic.c"
static void init_enhancement_layer(int layer ) 
{ 
  int cc ;
  int size ;
  unsigned char *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  void *tmp___4 ;
  unsigned char *tmp___5 ;
  void *tmp___6 ;
  unsigned char *tmp___7 ;
  void *tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  FILE *tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 3688
  blk_cnt = 6;
#line 3690
  cc = 0;
  {
  {
#line 3690
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3690
    if (! (cc < 3)) {
#line 3690
      goto while_break;
    }
#line 3692
    if (cc == 0) {
#line 3693
      size = coded_picture_width * coded_picture_height;
    } else {
#line 3695
      size = chrom_width * chrom_height;
    }
    {
    {
#line 3699
    tmp___0 = malloc((size_t )size);
    }
#line 3699
    tmp = (unsigned char *)tmp___0;
#line 3699
    prev_enhancement_frame[layer][cc] = tmp;
    }
#line 3699
    if (! tmp) {
      {
      {
#line 3700
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 3702
    tmp___2 = malloc((size_t )size);
    }
#line 3702
    tmp___1 = (unsigned char *)tmp___2;
#line 3702
    current_enhancement_frame[layer][cc] = tmp___1;
    }
#line 3702
    if (! tmp___1) {
      {
      {
#line 3703
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 3705
    tmp___4 = malloc((size_t )size);
    }
#line 3705
    tmp___3 = (unsigned char *)tmp___4;
#line 3705
    tmp_enhance_fwd[layer][cc] = tmp___3;
    }
#line 3705
    if (! tmp___3) {
      {
      {
#line 3706
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 3708
    tmp___6 = malloc((size_t )size);
    }
#line 3708
    tmp___5 = (unsigned char *)tmp___6;
#line 3708
    tmp_enhance_up[layer][cc] = tmp___5;
    }
#line 3708
    if (! tmp___5) {
      {
      {
#line 3709
      error((char *)"malloc failed\n");
      }
      }
    }
#line 3690
    cc ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3713
  cc = 0;
  {
  {
#line 3713
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 3713
    if (! (cc < 3)) {
#line 3713
      goto while_break___0;
    }
#line 3715
    if (cc == 0) {
      {
#line 3717
      size = (coded_picture_width + 64) * (coded_picture_height + 64);
      {
#line 3720
      tmp___8 = malloc((size_t )size);
      }
#line 3720
      tmp___7 = (unsigned char *)tmp___8;
#line 3720
      enhance_edgeframeorig[layer][cc] = tmp___7;
      }
#line 3720
      if (! tmp___7) {
        {
        {
#line 3721
        error((char *)"malloc failed\n");
        }
        }
      }
#line 3722
      enhance_edgeframe[layer][cc] = (enhance_edgeframeorig[layer][cc] + (coded_picture_width + 64) * 32) + 32;
    } else {
      {
#line 3726
      size = (chrom_width + 32) * (chrom_height + 32);
      {
#line 3729
      tmp___10 = malloc((size_t )size);
      }
#line 3729
      tmp___9 = (unsigned char *)tmp___10;
#line 3729
      enhance_edgeframeorig[layer][cc] = tmp___9;
      }
#line 3729
      if (! tmp___9) {
        {
        {
#line 3730
        error((char *)"malloc failed\n");
        }
        }
      }
#line 3731
      enhance_edgeframe[layer][cc] = (enhance_edgeframeorig[layer][cc] + (chrom_width + 32) * 16) + 16;
    }
#line 3713
    cc ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 3735
  sprintf((char */* __restrict  */)(enhance_recon_file_name[enhancement_layer_num - 2]),
          (char const   */* __restrict  */)"enhanced_%d.raw", enhancement_layer_num - 1);
  }
  {
#line 3737
  tmp___11 = fopen((char const   */* __restrict  */)(enhance_recon_file_name[enhancement_layer_num - 2]),
                   (char const   */* __restrict  */)"wb");
  }
#line 3737
  enhance_recon_file_ptr[enhancement_layer_num - 2] = tmp___11;
  }
#line 3737
  if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
    {
    {
#line 3740
    printf((char const   */* __restrict  */)"Unable to open enhancement layer reconstruction file");
    }
    {
#line 3741
    exit(-1);
    }
    }
  }
#line 3743
  return;
}
}
#line 3758 "getpic.c"
void UpsampleReferenceLayerPicture(void) 
{ 
  int cc ;
  int size ;
  int x ;
  int y ;
  unsigned char *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 3763
  cc = 0;
  {
  {
#line 3763
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3763
    if (! (cc < 3)) {
#line 3763
      goto while_break;
    }
#line 3765
    if (cc == 0) {
#line 3767
      size = coded_picture_width * coded_picture_height;
#line 3768
      x = ref_coded_picture_width;
#line 3769
      y = ref_coded_picture_height;
    } else {
#line 3773
      size = chrom_width * chrom_height;
#line 3774
      x = ref_chrom_width;
#line 3775
      y = ref_chrom_height;
    }
    {
    {
#line 3778
    tmp___0 = malloc((size_t )size);
    }
#line 3778
    tmp = (unsigned char *)tmp___0;
#line 3778
    upsampled_reference_frame[cc] = tmp;
    }
#line 3778
    if (! tmp) {
      {
      {
#line 3779
      error((char *)"malloc failed\n");
      }
      }
    }
    {
    {
#line 3781
    UpsampleComponent(upsampled_reference_frame[cc], current_frame[cc], x, y);
    }
#line 3763
    cc ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3783
  return;
}
}
#line 3800 "getpic.c"
void UpsampleComponent(unsigned char *enhanced , unsigned char *base___0 , int horiz ,
                       int vert ) 
{ 
  int i ;
  int j ;
  unsigned char *base_next ;
  unsigned char *enhanced_next ;
  unsigned char *enhanced_origin ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;

  {
#line 3806
  enhanced_origin = enhanced;
  {
#line 3810
  if (scalability_mode == 3) {
#line 3810
    goto case_3;
  }
#line 3829
  if (scalability_mode == 5) {
#line 3829
    goto case_5;
  }
#line 3864
  if (scalability_mode == 7) {
#line 3864
    goto case_7;
  }
#line 3925
  goto switch_default;
  case_3: /* CIL Label */ 
#line 3813
  j = 0;
  {
  {
#line 3813
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3813
    if (! (j < vert)) {
#line 3813
      goto while_break;
    }
#line 3816
    tmp = enhanced;
#line 3816
    enhanced ++;
#line 3816
    *tmp = *base___0;
#line 3817
    i = 1;
    {
    {
#line 3817
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3817
      if (! (i < horiz)) {
#line 3817
        goto while_break___0;
      }
#line 3819
      tmp___0 = enhanced;
#line 3819
      enhanced ++;
#line 3819
      *tmp___0 = (unsigned char )(((3 * (int )*base___0 + (int )*(base___0 + 1)) + 2) >> 2);
#line 3820
      tmp___1 = enhanced;
#line 3820
      enhanced ++;
#line 3820
      *tmp___1 = (unsigned char )((((int )*base___0 + 3 * (int )*(base___0 + 1)) + 2) >> 2);
#line 3821
      base___0 ++;
#line 3817
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3824
    tmp___2 = enhanced;
#line 3824
    enhanced ++;
#line 3824
    tmp___3 = base___0;
#line 3824
    base___0 ++;
#line 3824
    *tmp___2 = *tmp___3;
#line 3813
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3827
  goto switch_break;
  case_5: /* CIL Label */ 
#line 3832
  i = 0;
  {
  {
#line 3832
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 3832
    if (! (i < horiz)) {
#line 3832
      goto while_break___1;
    }
#line 3834
    tmp___4 = enhanced;
#line 3834
    enhanced ++;
#line 3834
    tmp___5 = base___0;
#line 3834
    base___0 ++;
#line 3834
    *tmp___4 = *tmp___5;
#line 3832
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3837
  enhanced_next = enhanced + horiz;
#line 3838
  base___0 -= horiz;
#line 3839
  base_next = base___0 + horiz;
#line 3842
  j = 0;
  {
  {
#line 3842
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 3842
    if (! (j < vert - 1)) {
#line 3842
      goto while_break___2;
    }
#line 3845
    i = 0;
    {
    {
#line 3845
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 3845
      if (! (i < horiz)) {
#line 3845
        goto while_break___3;
      }
#line 3847
      tmp___6 = enhanced;
#line 3847
      enhanced ++;
#line 3847
      *tmp___6 = (unsigned char )(((3 * (int )*base___0 + (int )*base_next) + 2) >> 2);
#line 3848
      tmp___7 = enhanced_next;
#line 3848
      enhanced_next ++;
#line 3848
      *tmp___7 = (unsigned char )((((int )*base___0 + 3 * (int )*base_next) + 2) >> 2);
#line 3849
      base___0 ++;
#line 3850
      base_next ++;
#line 3845
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3852
    enhanced += horiz;
#line 3853
    enhanced_next = enhanced + horiz;
#line 3842
    j ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3857
  i = 0;
  {
  {
#line 3857
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 3857
    if (! (i < horiz)) {
#line 3857
      goto while_break___4;
    }
#line 3859
    tmp___8 = enhanced;
#line 3859
    enhanced ++;
#line 3859
    tmp___9 = base___0;
#line 3859
    base___0 ++;
#line 3859
    *tmp___8 = *tmp___9;
#line 3857
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3862
  goto switch_break;
  case_7: /* CIL Label */ 
#line 3867
  tmp___10 = enhanced;
#line 3867
  enhanced ++;
#line 3867
  *tmp___10 = *base___0;
#line 3869
  i = 1;
  {
  {
#line 3869
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 3869
    if (! (i < horiz)) {
#line 3869
      goto while_break___5;
    }
#line 3871
    tmp___11 = enhanced;
#line 3871
    enhanced ++;
#line 3871
    *tmp___11 = (unsigned char )(((3 * (int )*base___0 + (int )*(base___0 + 1)) + 2) >> 2);
#line 3872
    tmp___12 = enhanced;
#line 3872
    enhanced ++;
#line 3872
    *tmp___12 = (unsigned char )((((int )*base___0 + 3 * (int )*(base___0 + 1)) + 2) >> 2);
#line 3873
    base___0 ++;
#line 3869
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3876
  tmp___13 = enhanced;
#line 3876
  enhanced ++;
#line 3876
  tmp___14 = base___0;
#line 3876
  base___0 ++;
#line 3876
  *tmp___13 = *tmp___14;
#line 3878
  enhanced_next = enhanced + (horiz << 1);
#line 3879
  base___0 -= horiz;
#line 3880
  base_next = base___0 + horiz;
#line 3883
  j = 0;
  {
  {
#line 3883
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 3883
    if (! (j < vert - 1)) {
#line 3883
      goto while_break___6;
    }
#line 3886
    tmp___15 = enhanced;
#line 3886
    enhanced ++;
#line 3886
    *tmp___15 = (unsigned char )(((3 * (int )*base___0 + (int )*base_next) + 2) >> 2);
#line 3887
    tmp___16 = enhanced_next;
#line 3887
    enhanced_next ++;
#line 3887
    *tmp___16 = (unsigned char )((((int )*base___0 + 3 * (int )*base_next) + 2) >> 2);
#line 3888
    i = 1;
    {
    {
#line 3888
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 3888
      if (! (i < horiz)) {
#line 3888
        goto while_break___7;
      }
#line 3890
      tmp___17 = enhanced;
#line 3890
      enhanced ++;
#line 3890
      *tmp___17 = (unsigned char )(((((9 * (int )*base___0 + 3 * (int )*(base___0 + 1)) + 3 * (int )*base_next) + (int )*(base_next + 1)) + 8) >> 4);
#line 3892
      tmp___18 = enhanced;
#line 3892
      enhanced ++;
#line 3892
      *tmp___18 = (unsigned char )(((((3 * (int )*base___0 + 9 * (int )*(base___0 + 1)) + (int )*base_next) + 3 * (int )*(base_next + 1)) + 8) >> 4);
#line 3894
      tmp___19 = enhanced_next;
#line 3894
      enhanced_next ++;
#line 3894
      *tmp___19 = (unsigned char )(((((3 * (int )*base___0 + (int )*(base___0 + 1)) + 9 * (int )*base_next) + 3 * (int )*(base_next + 1)) + 8) >> 4);
#line 3896
      tmp___20 = enhanced_next;
#line 3896
      enhanced_next ++;
#line 3896
      *tmp___20 = (unsigned char )((((((int )*base___0 + 3 * (int )*(base___0 + 1)) + 3 * (int )*base_next) + 9 * (int )*(base_next + 1)) + 8) >> 4);
#line 3898
      base___0 ++;
#line 3899
      base_next ++;
#line 3888
      i ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 3902
    tmp___21 = enhanced;
#line 3902
    enhanced ++;
#line 3902
    *tmp___21 = (unsigned char )(((3 * (int )*base___0 + (int )*base_next) + 2) >> 2);
#line 3903
    tmp___22 = enhanced_next;
#line 3903
    enhanced_next ++;
#line 3903
    *tmp___22 = (unsigned char )((((int )*base___0 + 3 * (int )*base_next) + 2) >> 2);
#line 3905
    enhanced += horiz << 1;
#line 3906
    enhanced_next = enhanced + (horiz << 1);
#line 3907
    base___0 ++;
#line 3908
    base_next ++;
#line 3883
    j ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 3912
  tmp___23 = enhanced;
#line 3912
  enhanced ++;
#line 3912
  *tmp___23 = *base___0;
#line 3914
  i = 1;
  {
  {
#line 3914
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 3914
    if (! (i < horiz)) {
#line 3914
      goto while_break___8;
    }
#line 3916
    tmp___24 = enhanced;
#line 3916
    enhanced ++;
#line 3916
    *tmp___24 = (unsigned char )(((3 * (int )*base___0 + (int )*(base___0 + 1)) + 2) >> 2);
#line 3917
    tmp___25 = enhanced;
#line 3917
    enhanced ++;
#line 3917
    *tmp___25 = (unsigned char )((((int )*base___0 + 3 * (int )*(base___0 + 1)) + 2) >> 2);
#line 3918
    base___0 ++;
#line 3914
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 3921
  *enhanced = *base___0;
#line 3923
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3927
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3929
  return;
}
}
#line 3947 "getpic.c"
static int display_buffer_empty  =    1;
#line 3948 "getpic.c"
static int buffered_frame_temp_ref  =    0;
#line 3948 "getpic.c"
static int display_framenum  =    0;
#line 3944 "getpic.c"
void PictureDisplay(int *framenum ) 
{ 
  unsigned char *frame_to_display[3] ;
  int cc ;
  int size ;
  int update_buffered_frame ;
  int tmp ;
  void *__cil_tmp7 ;

  {
#line 3951
  if (display_buffer_empty) {
#line 3954
    update_buffered_frame = 1;
  } else
#line 3958
  if (temp_ref < buffered_frame_temp_ref) {
#line 3958
    if (3 == pict_type) {
#line 3961
      update_buffered_frame = 0;
#line 3964
      display_framenum = *framenum;
#line 3966
      frame_to_display[0] = current_frame[0];
#line 3967
      frame_to_display[1] = current_frame[1];
#line 3968
      frame_to_display[2] = current_frame[2];
    } else {
#line 3958
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3970
  if (0 == pict_type) {
#line 3970
    if (temp_ref < buffered_frame_temp_ref) {
#line 3974
      display_framenum = buffered_framenum;
#line 3976
      frame_to_display[0] = buffered_frame[0];
#line 3977
      frame_to_display[1] = buffered_frame[1];
#line 3978
      frame_to_display[2] = buffered_frame[2];
#line 3981
      update_buffered_frame = 1;
    } else {
#line 3986
      display_framenum = buffered_framenum;
#line 3988
      frame_to_display[0] = buffered_frame[0];
#line 3989
      frame_to_display[1] = buffered_frame[1];
#line 3990
      frame_to_display[2] = buffered_frame[2];
#line 3993
      update_buffered_frame = 1;
    }
  } else {
#line 3986
    display_framenum = buffered_framenum;
#line 3988
    frame_to_display[0] = buffered_frame[0];
#line 3989
    frame_to_display[1] = buffered_frame[1];
#line 3990
    frame_to_display[2] = buffered_frame[2];
#line 3993
    update_buffered_frame = 1;
  }
#line 3997
  if (! display_buffer_empty) {
#line 4000
    if (post_filter) {
      {
      {
#line 4001
      PostFilter(frame_to_display[0], frame_to_display[1], frame_to_display[2], coded_picture_width,
                 coded_picture_height);
      }
      }
    }
#line 4004
    if (expand) {
#line 4004
      if (outtype == 4) {
        {
        {
#line 4007
        interpolate_image(frame_to_display[0], exnewframe[0], coded_picture_width,
                          coded_picture_height);
        }
        {
#line 4009
        interpolate_image(frame_to_display[1], exnewframe[1], chrom_width, chrom_height);
        }
        {
#line 4010
        interpolate_image(frame_to_display[2], exnewframe[2], chrom_width, chrom_height);
        }
        {
#line 4012
        storeframe(exnewframe, *framenum);
        }
        }
#line 4013
        if (save_frames) {
          {
          {
#line 4015
          save_frame(exnewframe, *framenum, recon_file_ptr);
          }
          }
        }
#line 4017
        if (pb_frame) {
#line 4020
          if (framerate > 0) {
            {
            {
#line 4021
            doframerate(1);
            }
            }
          }
          {
#line 4024
          (*framenum) ++;
          {
#line 4025
          interpolate_image(bframe[0], exnewframe[0], coded_picture_width, coded_picture_height);
          }
          {
#line 4026
          interpolate_image(bframe[1], exnewframe[1], chrom_width, chrom_height);
          }
          {
#line 4027
          interpolate_image(bframe[2], exnewframe[2], chrom_width, chrom_height);
          }
          {
#line 4028
          storeframe(exnewframe, *framenum);
          }
          }
#line 4029
          if (save_frames) {
            {
            {
#line 4031
            save_frame(exnewframe, *framenum, recon_file_ptr);
            }
            }
          }
        }
      } else {
#line 4004
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
      {
#line 4037
      storeframe(frame_to_display, *framenum);
      }
      }
#line 4038
      if (save_frames) {
        {
        {
#line 4040
        save_frame(frame_to_display, *framenum, recon_file_ptr);
        }
        }
      }
#line 4042
      if (pb_frame) {
#line 4045
        if (framerate > 0) {
          {
          {
#line 4046
          doframerate(1);
          }
          }
        }
        {
#line 4049
        (*framenum) ++;
        {
#line 4050
        storeframe(bframe, *framenum);
        }
        }
#line 4052
        if (save_frames) {
          {
          {
#line 4054
          save_frame(bframe, *framenum, recon_file_ptr);
          }
          }
        }
      }
    }
  }
#line 4062
  if (display_buffer_empty) {
#line 4064
    display_buffer_empty = 0;
  }
#line 4066
  if (update_buffered_frame) {
#line 4068
    if (temp_ref - buffered_frame_temp_ref < 0) {
#line 4068
      tmp = (temp_ref - buffered_frame_temp_ref) + 256;
    } else {
#line 4068
      tmp = temp_ref - buffered_frame_temp_ref;
    }
#line 4068
    buffered_frame_temp_ref += tmp;
#line 4071
    buffered_framenum = *framenum;
#line 4073
    cc = 0;
    {
    {
#line 4073
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 4073
      if (! (cc < 3)) {
#line 4073
        goto while_break;
      }
#line 4075
      if (cc == 0) {
#line 4076
        size = coded_picture_width * coded_picture_height;
      } else {
#line 4078
        size = chrom_width * chrom_height;
      }
      {
      {
#line 4080
      memcpy((void */* __restrict  */)buffered_frame[cc], (void const   */* __restrict  */)current_frame[cc],
             (size_t )size);
      }
#line 4073
      cc ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4083
  return;
}
}
#line 4085 "getpic.c"
void conceal_missing_gobs(int start_mb_row_missing , int number_of_mb_rows_missing ) 
{ 
  int xpos ;
  int ypos ;
  int bx ;
  int by ;
  int end ;

  {
#line 4091
  end = start_mb_row_missing + number_of_mb_rows_missing;
#line 4093
  ypos = start_mb_row_missing;
  {
  {
#line 4093
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 4093
    if (! (ypos < end)) {
#line 4093
      goto while_break;
    }
#line 4095
    xpos = 0;
    {
    {
#line 4095
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 4095
      if (! (xpos < mb_width)) {
#line 4095
        goto while_break___0;
      }
#line 4098
      bx = 16 * xpos;
#line 4099
      by = 16 * ypos;
#line 4102
      modemap[ypos + 1][xpos + 1] = 0;
#line 4106
      if (! start_mb_row_missing) {
#line 4108
        MV[0][0][ypos + 1][xpos + 1] = 0;
#line 4109
        MV[1][0][ypos + 1][xpos + 1] = 0;
      } else {
#line 4113
        MV[0][0][ypos + 1][xpos + 1] = MV[0][0][start_mb_row_missing][xpos + 1];
#line 4114
        MV[1][0][ypos + 1][xpos + 1] = MV[1][0][start_mb_row_missing][xpos + 1];
      }
      {
      {
#line 4119
      reconstruct(bx, by, 1, 0, 0, 0, 1);
      }
#line 4095
      xpos ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4093
    ypos ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 4122
  return;
}
}
#line 70 "gethdr.c"
static void getpicturehdr(void) ;
#line 75 "gethdr.c"
int getheader(void) 
{ 
  unsigned int code ;
  unsigned int gob ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 80
  startcode();
  }
  {
#line 81
  code = getbits(17);
  }
  {
#line 82
  gob = getbits(5);
  }
  }
#line 83
  if (gob == 31U) {
#line 84
    return (0);
  }
#line 85
  if (gob == 0U) {
#line 87
    if (trace) {
      {
      {
#line 90
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nPSC: ");
      }
      {
#line 91
      printbits((int )(code << (5U + gob)), 22, 22);
      }
      }
    }
    {
    {
#line 93
    getpicturehdr();
    }
    }
#line 94
    if (syntax_arith_coding) {
      {
      {
#line 95
      decoder_reset();
      }
      }
    }
  } else
#line 99
  if (trace) {
    {
    {
#line 102
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nGBSC: ");
    }
    {
#line 103
    printbits((int )((code << 5) + gob), 22, 22);
    }
    }
  }
#line 106
  return ((int )(gob + 1U));
}
}
#line 112 "gethdr.c"
void startcode(void) 
{ 
  unsigned int tmp ;

  {
  {
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 115
    tmp = showbits(17);
    }
    }
#line 115
    if (! ((long )tmp != 1L)) {
#line 115
      goto while_break;
    }
    {
    {
#line 116
    flushbits(1);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 121 "gethdr.c"
static void getpicturehdr(void) 
{ 
  int pos ;
  int pei ;
  int tmp ;
  int TRPI___0 ;
  int BCI ;
  int clock_conversion_code ;
  int clock_divisor ;
  int extended_temporal_reference ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  unsigned int tmp___25 ;
  unsigned int tmp___26 ;
  unsigned int tmp___27 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  unsigned int tmp___33 ;
  unsigned int tmp___34 ;
  unsigned int tmp___35 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  unsigned int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  unsigned int tmp___58 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;

  {
  {
#line 124
  TRPI___0 = 0;
#line 125
  BCI = 0;
#line 126
  clock_conversion_code = 0;
#line 127
  clock_divisor = 0;
#line 128
  extended_temporal_reference = 0;
#line 130
  UFEP = 0;
#line 132
  pos = ld->bitcnt;
  {
#line 134
  tmp___0 = getbits(8);
  }
#line 134
  temp_ref = (int )tmp___0;
  }
#line 135
  if (trace) {
    {
    {
#line 137
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nTR: ");
    }
    {
#line 138
    printbits(temp_ref, 8, 8);
    }
    }
  }
#line 140
  if (trd < 0) {
#line 141
    trd += 256;
  }
  {
  {
#line 143
  tmp___1 = getbits(1);
  }
#line 143
  tmp = (int )tmp___1;
  }
#line 144
  if (trace) {
    {
    {
#line 145
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nSpare: %d",
            tmp);
    }
    }
  }
#line 146
  if (! tmp) {
#line 147
    if (! quiet) {
      {
      {
#line 148
      printf((char const   */* __restrict  */)"warning: spare in picture header should be \"1\"\n");
      }
      }
    }
  }
  {
  {
#line 149
  tmp___2 = getbits(1);
  }
#line 149
  tmp = (int )tmp___2;
  }
#line 150
  if (trace) {
    {
    {
#line 151
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nH.261 distinction bit: %d",
            tmp);
    }
    }
  }
#line 152
  if (tmp) {
#line 153
    if (! quiet) {
      {
      {
#line 154
      printf((char const   */* __restrict  */)"warning: H.261 distinction bit should be \"0\"\n");
      }
      }
    }
  }
  {
  {
#line 155
  tmp___3 = getbits(1);
  }
#line 155
  tmp = (int )tmp___3;
  }
#line 156
  if (trace) {
    {
    {
#line 157
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nsplit_screen_indicator: %d",
            tmp);
    }
    }
  }
#line 158
  if (tmp) {
#line 160
    if (! quiet) {
      {
      {
#line 161
      printf((char const   */* __restrict  */)"error: split-screen not supported in this version\n");
      }
      }
    }
    {
    {
#line 162
    exit(-1);
    }
    }
  }
  {
  {
#line 164
  tmp___4 = getbits(1);
  }
#line 164
  tmp = (int )tmp___4;
  }
#line 165
  if (trace) {
    {
    {
#line 166
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ndocument_camera_indicator: %d",
            tmp);
    }
    }
  }
#line 167
  if (tmp) {
#line 168
    if (! quiet) {
      {
      {
#line 169
      printf((char const   */* __restrict  */)"warning: document camera indicator not supported in this version\n");
      }
      }
    }
  }
  {
  {
#line 171
  tmp___5 = getbits(1);
  }
#line 171
  tmp = (int )tmp___5;
  }
#line 172
  if (trace) {
    {
    {
#line 173
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nfreeze_picture_release: %d",
            tmp);
    }
    }
  }
#line 174
  if (tmp) {
#line 175
    if (! quiet) {
      {
      {
#line 176
      printf((char const   */* __restrict  */)"warning: frozen picture not supported in this version\n");
      }
      }
    }
  }
  {
  {
#line 177
  tmp___6 = getbits(3);
  }
#line 177
  tmp = (int )tmp___6;
  }
#line 178
  if (trace) {
    {
    {
#line 180
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nsource_format: ");
    }
    {
#line 181
    printbits(tmp, 3, 3);
    }
    }
  }
#line 183
  if (tmp == 0) {
#line 185
    if (! quiet) {
      {
      {
#line 186
      printf((char const   */* __restrict  */)"error: source format 000 is reserved and not used in this version\n");
      }
      }
    }
    {
    {
#line 187
    exit(-1);
    }
    }
  }
#line 189
  if (tmp == 7) {
#line 191
    if (trace) {
      {
      {
#line 192
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\n----------EXTENDED_PTYPE----------");
      }
      }
    }
    {
#line 193
    plus_type = 1;
    {
#line 194
    tmp___7 = getbits(3);
    }
#line 194
    UFEP = (int )tmp___7;
    }
#line 195
    if (trace) {
      {
      {
#line 197
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nUFEP: ");
      }
      {
#line 198
      printbits(UFEP, 3, 3);
      }
      }
    }
#line 200
    if (UFEP == 1) {
#line 202
      if (trace) {
        {
        {
#line 203
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\n----------OPTIONAL PLUS PTYPE----------");
        }
        }
      }
      {
      {
#line 204
      tmp___8 = getbits(3);
      }
#line 204
      source_format = (int )tmp___8;
      }
#line 205
      if (trace) {
        {
        {
#line 207
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nsource_format: ");
        }
        {
#line 208
        printbits(source_format, 3, 3);
        }
        }
      }
      {
      {
#line 212
      tmp___9 = getbits(1);
      }
#line 212
      optional_custom_PCF = (int )tmp___9;
      }
#line 213
      if (trace) {
        {
        {
#line 215
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\noptional_custom_PCF: ");
        }
        {
#line 216
        printbits(optional_custom_PCF, 1, 1);
        }
        }
      }
#line 218
      if (optional_custom_PCF) {
#line 220
        if (! quiet) {
          {
          {
#line 221
          printf((char const   */* __restrict  */)"error: Optional custom picture clock frequency is not supported in this version\n");
          }
          }
        }
        {
        {
#line 222
        exit(-1);
        }
        }
      }
      {
      {
#line 224
      tmp___10 = getbits(1);
      }
#line 224
      mv_outside_frame = (int )tmp___10;
      }
#line 225
      if (trace) {
        {
        {
#line 227
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nmv_outside_frame: ");
        }
        {
#line 228
        printbits(mv_outside_frame, 1, 1);
        }
        }
      }
#line 230
      if (mv_outside_frame) {
#line 230
        long_vectors = 1;
      } else {
#line 230
        long_vectors = 0;
      }
      {
      {
#line 231
      tmp___11 = getbits(1);
      }
#line 231
      syntax_arith_coding = (int )tmp___11;
      }
#line 232
      if (trace) {
        {
        {
#line 234
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nsyntax_arith_coding: ");
        }
        {
#line 235
        printbits(syntax_arith_coding, 1, 1);
        }
        }
      }
      {
      {
#line 237
      tmp___12 = getbits(1);
      }
#line 237
      adv_pred_mode = (int )tmp___12;
      }
#line 238
      if (trace) {
        {
        {
#line 240
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nadv_pred_mode: ");
        }
        {
#line 241
        printbits(adv_pred_mode, 1, 1);
        }
        }
      }
#line 243
      if (adv_pred_mode) {
#line 243
        mv_outside_frame = 1;
      } else {
#line 243
        mv_outside_frame = mv_outside_frame;
      }
#line 244
      if (adv_pred_mode) {
#line 244
        overlapping_MC = 1;
      } else {
#line 244
        overlapping_MC = 0;
      }
#line 245
      if (adv_pred_mode) {
#line 245
        use_4mv = 1;
      } else {
#line 245
        use_4mv = 0;
      }
      {
#line 246
      pb_frame = 0;
      {
#line 247
      tmp___13 = getbits(1);
      }
#line 247
      advanced_intra_coding = (int )tmp___13;
      }
#line 248
      if (trace) {
        {
        {
#line 250
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nadvanced_intra_coding: ");
        }
        {
#line 251
        printbits(advanced_intra_coding, 1, 1);
        }
        }
      }
      {
      {
#line 253
      tmp___14 = getbits(1);
      }
#line 253
      deblocking_filter_mode = (int )tmp___14;
      }
#line 254
      if (trace) {
        {
        {
#line 256
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ndeblocking_filter_mode: ");
        }
        {
#line 257
        printbits(deblocking_filter_mode, 1, 1);
        }
        }
      }
#line 259
      if (deblocking_filter_mode) {
#line 259
        mv_outside_frame = 1;
      } else {
#line 259
        mv_outside_frame = mv_outside_frame;
      }
#line 260
      if (deblocking_filter_mode) {
#line 260
        use_4mv = 1;
      } else {
#line 260
        use_4mv = use_4mv;
      }
      {
      {
#line 262
      tmp___15 = getbits(1);
      }
#line 262
      slice_structured_mode = (int )tmp___15;
      }
#line 263
      if (trace) {
        {
        {
#line 265
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nslice_structured_mode: ");
        }
        {
#line 266
        printbits(slice_structured_mode, 1, 1);
        }
        }
      }
#line 268
      if (slice_structured_mode) {
#line 270
        if (! quiet) {
          {
          {
#line 271
          printf((char const   */* __restrict  */)"error: Slice structured mode is not supported in this version\n");
          }
          }
        }
        {
        {
#line 272
        exit(-1);
        }
        }
      }
      {
      {
#line 274
      tmp___16 = getbits(1);
      }
#line 274
      reference_picture_selection_mode = (int )tmp___16;
      }
#line 275
      if (trace) {
        {
        {
#line 277
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nreference_picture_selection_mode: ");
        }
        {
#line 278
        printbits(reference_picture_selection_mode, 1, 1);
        }
        }
      }
      {
      {
#line 280
      tmp___17 = getbits(1);
      }
#line 280
      independently_segmented_decoding_mode = (int )tmp___17;
      }
#line 281
      if (trace) {
        {
        {
#line 283
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nindependently_segmented_decoding_mode: ");
        }
        {
#line 284
        printbits(independently_segmented_decoding_mode, 1, 1);
        }
        }
      }
#line 286
      if (independently_segmented_decoding_mode) {
#line 288
        if (! quiet) {
          {
          {
#line 289
          printf((char const   */* __restrict  */)"error: Independently segmented decoding mode is not supported in this version\n");
          }
          }
        }
        {
        {
#line 290
        exit(-1);
        }
        }
      }
      {
      {
#line 292
      tmp___18 = getbits(1);
      }
#line 292
      alternative_inter_VLC_mode = (int )tmp___18;
      }
#line 293
      if (trace) {
        {
        {
#line 295
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nalternative_inter_VLC_mode: ");
        }
        {
#line 296
        printbits(alternative_inter_VLC_mode, 1, 1);
        }
        }
      }
      {
      {
#line 298
      tmp___19 = getbits(1);
      }
#line 298
      modified_quantization_mode = (int )tmp___19;
      }
#line 299
      if (trace) {
        {
        {
#line 301
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nmodified_quantization_mode: ");
        }
        {
#line 302
        printbits(modified_quantization_mode, 1, 1);
        }
        }
      }
      {
      {
#line 304
      tmp___20 = getbits(4);
      }
#line 304
      tmp = (int )tmp___20;
      }
#line 305
      if (trace) {
        {
        {
#line 307
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nspare, reserve, reserve, reserve: ");
        }
        {
#line 308
        printbits(tmp, 4, 4);
        }
        }
      }
#line 310
      if (tmp != 8) {
#line 312
        if (! quiet) {
          {
          {
#line 313
          printf((char const   */* __restrict  */)"error: The last 4 bits of OPPTYPE is expected to be 1000\n");
          }
          }
        }
        {
        {
#line 314
        exit(-1);
        }
        }
      }
    }
#line 317
    if (UFEP == 1) {
#line 317
      goto _L;
    } else
#line 317
    if (UFEP == 0) {
      _L: /* CIL Label */ 
#line 319
      if (UFEP == 0) {
#line 321
        if (scalability_mode >= 3) {
#line 323
          horizontal_size = lines[base_source_format];
#line 324
          vertical_size = pels[base_source_format];
#line 326
          mb_width = horizontal_size / 16;
#line 327
          mb_height = vertical_size / 16;
#line 333
          coded_picture_width = horizontal_size;
#line 333
          ref_coded_picture_width = coded_picture_width;
#line 334
          coded_picture_height = vertical_size;
#line 334
          ref_coded_picture_height = coded_picture_height;
#line 335
          chrom_width = coded_picture_width >> 1;
#line 335
          ref_chrom_width = chrom_width;
#line 336
          chrom_height = coded_picture_height >> 1;
#line 336
          ref_chrom_height = chrom_height;
#line 338
          source_format = base_source_format;
        }
      }
#line 343
      if (trace) {
        {
        {
#line 344
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\n----------MANDATORY PLUS PTYPE----------");
        }
        }
      }
      {
      {
#line 345
      tmp___21 = getbits(3);
      }
#line 345
      pict_type = (int )tmp___21;
      }
#line 346
      if (trace) {
        {
        {
#line 348
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\npict_type: ");
        }
        {
#line 349
        printbits(pict_type, 3, 3);
        }
        }
      }
#line 351
      if (pict_type == 2) {
#line 352
        pb_frame = 2;
      } else {
#line 354
        pb_frame = 0;
      }
#line 356
      if (3 == pict_type) {
#line 358
        true_B_frame = 1;
#line 361
        mv_outside_frame = 1;
#line 362
        true_b_trb = temp_ref - prev_non_disposable_temp_ref;
#line 363
        if (true_b_trb < 0) {
#line 364
          true_b_trb += 256;
        }
      } else {
#line 367
        true_B_frame = 0;
#line 368
        prev_non_disposable_temp_ref = next_non_disposable_temp_ref;
#line 369
        next_non_disposable_temp_ref = temp_ref;
#line 370
        trd = temp_ref - prev_non_disposable_temp_ref;
#line 371
        if (trd < 0) {
#line 372
          trd += 256;
        }
      }
      {
      {
#line 375
      tmp___22 = getbits(1);
      }
#line 375
      reference_picture_resampling_mode = (int )tmp___22;
      }
#line 376
      if (trace) {
        {
        {
#line 378
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nreference_picture_resampling_mode: ");
        }
        {
#line 379
        printbits(reference_picture_resampling_mode, 1, 1);
        }
        }
      }
#line 381
      if (reference_picture_resampling_mode) {
#line 383
        if (! quiet) {
          {
          {
#line 384
          printf((char const   */* __restrict  */)"error: Reference picture resampling mode is not supported in this version\n");
          }
          }
        }
        {
        {
#line 385
        exit(-1);
        }
        }
      }
      {
      {
#line 387
      tmp___23 = getbits(1);
      }
#line 387
      reduced_resolution_update_mode = (int )tmp___23;
      }
#line 388
      if (trace) {
        {
        {
#line 390
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nreduced_resolution_update_mode: ");
        }
        {
#line 391
        printbits(reduced_resolution_update_mode, 1, 1);
        }
        }
      }
#line 393
      if (reduced_resolution_update_mode) {
#line 395
        if (! quiet) {
          {
          {
#line 396
          printf((char const   */* __restrict  */)"error: Reduced resolution update mode is not supported in this version\n");
          }
          }
        }
        {
        {
#line 397
        exit(-1);
        }
        }
      }
      {
      {
#line 399
      tmp___24 = getbits(1);
      }
#line 399
      rtype = (int )tmp___24;
      }
#line 400
      if (trace) {
        {
        {
#line 402
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nrounding_type: ");
        }
        {
#line 403
        printbits(rtype, 1, 1);
        }
        }
      }
#line 405
      if (trace) {
        {
        {
#line 407
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nrtype: ");
        }
        {
#line 408
        printbits(rtype, 1, 1);
        }
        }
      }
      {
      {
#line 410
      tmp___25 = getbits(3);
      }
#line 410
      tmp = (int )tmp___25;
      }
#line 411
      if (trace) {
        {
        {
#line 413
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nreserve, reserve, spare: ");
        }
        {
#line 414
        printbits(tmp, 3, 3);
        }
        }
      }
#line 416
      if (tmp != 1) {
#line 418
        if (! quiet) {
          {
          {
#line 419
          exit(-1);
          }
          }
        }
      }
    } else {
#line 424
      if (! quiet) {
        {
        {
#line 425
        printf((char const   */* __restrict  */)"error: UFEP should be either 001 or 000.\n");
        }
        }
      }
      {
      {
#line 426
      exit(-1);
      }
      }
    }
    {
    {
#line 429
    tmp___26 = getbits(1);
    }
#line 429
    tmp = (int )tmp___26;
    }
#line 430
    if (trace) {
      {
      {
#line 432
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nCPM: ");
      }
      {
#line 433
      printbits(tmp, 1, 1);
      }
      }
    }
#line 435
    if (tmp) {
#line 437
      if (! quiet) {
        {
        {
#line 438
        printf((char const   */* __restrict  */)"error: CPM not supported in this version\n");
        }
        }
      }
      {
      {
#line 439
      exit(-1);
      }
      }
    }
#line 442
    if (UFEP) {
#line 442
      if (source_format == 6) {
#line 445
        if (trace) {
          {
          {
#line 446
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ncustom picture format \n");
          }
          }
        }
        {
        {
#line 447
        tmp___27 = getbits(4);
        }
#line 447
        CP_PAR_code = (int )tmp___27;
        }
#line 448
        if (trace) {
          {
          {
#line 450
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nCP_PAR_code: ");
          }
          {
#line 451
          printbits(CP_PAR_code, 4, 4);
          }
          }
        }
#line 453
        if (CP_PAR_code != 2) {
#line 455
          if (! quiet) {
            {
            {
#line 457
            printf((char const   */* __restrict  */)"error: only 12:11 pixel aspect ratio supported ");
            }
            }
          }
          {
          {
#line 459
          exit(-1);
          }
          }
        }
        {
        {
#line 461
        tmp___28 = getbits(9);
        }
#line 461
        tmp = (int )tmp___28;
#line 462
        horizontal_size = (tmp + 1) * 4;
        }
#line 463
        if (trace) {
          {
          {
#line 465
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nCP_picture_width_indication: ");
          }
          {
#line 466
          printbits(tmp, 9, 9);
          }
          }
        }
        {
        {
#line 468
        tmp___29 = getbits(1);
        }
#line 468
        tmp = (int )tmp___29;
        }
#line 469
        if (trace) {
          {
          {
#line 471
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nspare: ");
          }
          {
#line 472
          printbits(tmp, 1, 1);
          }
          }
        }
#line 474
        if (! tmp) {
#line 476
          if (! quiet) {
            {
            {
#line 477
            printf((char const   */* __restrict  */)"error: The 14th bit of Custom Picture Format(CPFMT) should be 1\n");
            }
            }
          }
          {
          {
#line 478
          exit(-1);
          }
          }
        }
        {
        {
#line 480
        tmp___30 = getbits(9);
        }
#line 480
        tmp = (int )tmp___30;
#line 481
        vertical_size = tmp * 4;
        }
#line 482
        if (trace) {
          {
          {
#line 484
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nCP_picture_height_indication: ");
          }
          {
#line 485
          printbits(tmp, 9, 9);
          }
          }
        }
#line 487
        if (horizontal_size % 16) {
#line 487
          goto _L___0;
        } else
#line 487
        if (vertical_size % 16) {
          _L___0: /* CIL Label */ 
#line 489
          if (! quiet) {
            {
            {
#line 491
            printf((char const   */* __restrict  */)"error: only factor of 16 custom source format supported\n");
            }
            }
          }
          {
          {
#line 493
          exit(-1);
          }
          }
        }
#line 496
        if (CP_PAR_code == 15) {
          {
          {
#line 498
          tmp___31 = getbits(8);
          }
#line 498
          PAR_width = (int )tmp___31;
          {
#line 499
          tmp___32 = getbits(8);
          }
#line 499
          PAR_height = (int )tmp___32;
          }
        }
      }
    }
#line 503
    if (source_format != 6) {
#line 505
      horizontal_size = lines[source_format];
#line 506
      vertical_size = pels[source_format];
    }
#line 509
    mb_width = horizontal_size / 16;
#line 510
    mb_height = vertical_size / 16;
#line 516
    ref_coded_picture_width = coded_picture_width;
#line 517
    coded_picture_width = horizontal_size;
#line 519
    ref_coded_picture_height = coded_picture_height;
#line 520
    coded_picture_height = vertical_size;
#line 522
    ref_chrom_width = chrom_width;
#line 523
    chrom_width = coded_picture_width >> 1;
#line 525
    ref_chrom_height = chrom_height;
#line 526
    chrom_height = coded_picture_height >> 1;
#line 528
    if (optional_custom_PCF) {
#line 530
      if (trace) {
        {
        {
#line 531
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\noptional_custom_PCF \n");
        }
        }
      }
#line 532
      if (UFEP) {
        {
        {
#line 534
        tmp___33 = getbits(1);
        }
#line 534
        clock_conversion_code = (int )tmp___33;
        }
#line 535
        if (trace) {
          {
          {
#line 537
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nclock_conversion_code: ");
          }
          {
#line 538
          printbits(clock_conversion_code, 1, 1);
          }
          }
        }
        {
        {
#line 540
        tmp___34 = getbits(7);
        }
#line 540
        clock_divisor = (int )tmp___34;
        }
#line 541
        if (trace) {
          {
          {
#line 543
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nclock_divisor: ");
          }
          {
#line 544
          printbits(clock_divisor, 7, 7);
          }
          }
        }
#line 546
        CP_clock_frequency = (int )(((float )1800 / ((float )clock_divisor * (float )(8 + clock_conversion_code))) * (float )1000);
      }
      {
      {
#line 549
      tmp___35 = getbits(2);
      }
#line 549
      extended_temporal_reference = (int )tmp___35;
      }
#line 550
      if (trace) {
        {
        {
#line 552
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nextended_temporal_reference: ");
        }
        {
#line 553
        printbits(extended_temporal_reference, 2, 2);
        }
        }
      }
#line 555
      temp_ref = extended_temporal_reference << (8 + temp_ref);
#line 557
      if (3 == pict_type) {
#line 559
        true_b_trb = temp_ref - prev_non_disposable_temp_ref;
      } else {
#line 562
        trd = temp_ref - prev_non_disposable_temp_ref;
      }
#line 565
      if (trd < 0) {
#line 566
        trd += 1024;
      }
    }
#line 568
    if (UFEP) {
#line 568
      if (long_vectors) {
        {
        {
#line 570
        tmp___36 = getbits(1);
        }
        }
#line 570
        if (tmp___36) {
#line 572
          unlimited_unrestricted_motion_vectors = 0;
#line 573
          if (trace) {
            {
            {
#line 575
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nunlimited_unrestricted_motion_vectors indicator: ");
            }
            {
#line 576
            printbits(1, 1, 1);
            }
            }
          }
        } else {
          {
          {
#line 581
          flushbits(1);
          }
#line 582
          unlimited_unrestricted_motion_vectors = 1;
          }
#line 583
          if (trace) {
            {
            {
#line 585
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nunlimited_unrestricted_motion_vectors indicator: ");
            }
            {
#line 586
            printbits(1, 2, 2);
            }
            }
          }
        }
      }
    }
#line 590
    if (UFEP) {
#line 590
      if (slice_structured_mode) {
        {
        {
#line 592
        tmp___37 = getbits(1);
        }
#line 592
        SSS_rectangular_slices = (int )tmp___37;
        }
#line 593
        if (trace) {
          {
          {
#line 595
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nSSS_rectangular_slices: ");
          }
          {
#line 596
          printbits(SSS_rectangular_slices, 1, 1);
          }
          }
        }
        {
        {
#line 598
        tmp___38 = getbits(1);
        }
#line 598
        SSS_arbitary_slice_ordering = (int )tmp___38;
        }
#line 599
        if (trace) {
          {
          {
#line 601
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nSSS_arbitary_slice_ordering: ");
          }
          {
#line 602
          printbits(SSS_arbitary_slice_ordering, 1, 1);
          }
          }
        }
      }
    }
#line 606
    if (pict_type == 3) {
#line 606
      goto _L___1;
    } else
#line 606
    if (pict_type == 4) {
#line 606
      goto _L___1;
    } else
#line 606
    if (pict_type == 5) {
      _L___1: /* CIL Label */ 
      {
      {
#line 609
      tmp___39 = getbits(4);
      }
#line 609
      enhancement_layer_num = (int )tmp___39;
      }
#line 610
      if (trace) {
        {
        {
#line 612
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nenhancement_layer_num: ");
        }
        {
#line 613
        printbits(enhancement_layer_num, 4, 4);
        }
        }
      }
#line 615
      if (UFEP) {
        {
        {
#line 617
        tmp___40 = getbits(4);
        }
#line 617
        reference_layer_number = (int )tmp___40;
        }
#line 618
        if (trace) {
          {
          {
#line 620
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nreference_layer_number: ");
          }
          {
#line 621
          printbits(reference_layer_number, 4, 4);
          }
          }
        }
      }
#line 624
      if (1 != enhancement_layer_num) {
#line 626
        if (source_format != base_source_format) {
#line 628
          if (source_format != 6) {
#line 630
            scalability_mode = 7;
          } else
#line 632
          if (coded_picture_width != ref_coded_picture_width) {
#line 634
            scalability_mode = 3;
          } else {
#line 638
            scalability_mode = 5;
          }
        } else {
#line 643
          scalability_mode = 1;
        }
      }
    } else {
#line 649
      reference_layer_number = 1;
#line 649
      enhancement_layer_num = reference_layer_number;
    }
#line 652
    if (reference_picture_selection_mode) {
#line 654
      if (UFEP) {
        {
        {
#line 656
        tmp___41 = getbits(3);
        }
#line 656
        MF_of_reference_picture_selection = (int )tmp___41;
        }
#line 657
        if (trace) {
          {
          {
#line 659
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nMF_of_reference_picture_selection: ");
          }
          {
#line 660
          printbits(MF_of_reference_picture_selection, 3, 3);
          }
          }
        }
      }
      {
      {
#line 663
      tmp___42 = getbits(1);
      }
#line 663
      TRPI___0 = (int )tmp___42;
      }
#line 664
      if (trace) {
        {
        {
#line 666
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nTRPI: ");
        }
        {
#line 667
        printbits(TRPI___0, 1, 1);
        }
        }
      }
#line 669
      if (TRPI___0) {
        {
        {
#line 673
        tmp___43 = getbits(10);
        }
#line 673
        temporal_reference_for_prediction = (int )tmp___43;
        }
#line 674
        if (trace) {
          {
          {
#line 676
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ntemporal_reference_for_prediction: ");
          }
          {
#line 677
          printbits(temporal_reference_for_prediction, 10, 10);
          }
          }
        }
      }
      {
      {
#line 680
      tmp___45 = showbits(1);
      }
      }
#line 680
      if (tmp___45) {
        {
        {
#line 684
        flushbits(1);
        }
        }
#line 685
        if (! quiet) {
          {
          {
#line 686
          printf((char const   */* __restrict  */)"error: BCM(backward channel message) is not implemented in this version\n");
          }
          }
        }
        {
        {
#line 687
        exit(-1);
        }
        }
      } else {
        {
        {
#line 692
        tmp___44 = getbits(2);
        }
#line 692
        BCI = (int )tmp___44;
        }
#line 693
        if (trace) {
          {
          {
#line 695
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nBCI: ");
          }
          {
#line 696
          printbits(BCI, 2, 2);
          }
          }
        }
      }
    }
#line 700
    if (reference_picture_resampling_mode) {
#line 703
      if (! quiet) {
        {
        {
#line 704
        printf((char const   */* __restrict  */)"error: RPRP reading is not implemented in this version\n");
        }
        }
      }
      {
      {
#line 705
      exit(-1);
      }
      }
    }
    {
    {
#line 707
    tmp___46 = getbits(5);
    }
#line 707
    pic_quant = (int )tmp___46;
#line 708
    quant = pic_quant;
    }
#line 710
    if (trace) {
      {
      {
#line 712
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nquant: ");
      }
      {
#line 713
      printbits(quant, 5, 5);
      }
      }
    }
  } else {
#line 718
    plus_type = 0;
#line 719
    rtype = 0;
#line 720
    source_format = tmp;
#line 721
    reference_layer_number = 1;
#line 721
    enhancement_layer_num = reference_layer_number;
#line 723
    horizontal_size = lines[source_format];
#line 724
    vertical_size = pels[source_format];
#line 726
    mb_width = horizontal_size / 16;
#line 727
    mb_height = vertical_size / 16;
#line 733
    coded_picture_width = horizontal_size;
#line 733
    ref_coded_picture_width = coded_picture_width;
#line 734
    coded_picture_height = vertical_size;
#line 734
    ref_coded_picture_height = coded_picture_height;
#line 735
    chrom_width = coded_picture_width >> 1;
#line 735
    ref_chrom_width = chrom_width;
#line 736
    chrom_height = coded_picture_height >> 1;
#line 736
    ref_chrom_height = chrom_height;
#line 738
    true_B_frame = 0;
#line 739
    prev_non_disposable_temp_ref = next_non_disposable_temp_ref;
#line 740
    next_non_disposable_temp_ref = temp_ref;
#line 741
    trd = temp_ref - prev_non_disposable_temp_ref;
#line 742
    if (trd < 0) {
#line 743
      trd += 256;
    }
    {
    {
#line 745
    tmp___47 = getbits(1);
    }
#line 745
    pict_type = (int )tmp___47;
    }
#line 746
    if (trace) {
      {
      {
#line 748
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\npict_type: ");
      }
      {
#line 749
      printbits(pict_type, 1, 1);
      }
      }
    }
    {
    {
#line 751
    tmp___48 = getbits(1);
    }
#line 751
    mv_outside_frame = (int )tmp___48;
    }
#line 752
    if (trace) {
      {
      {
#line 754
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nmv_outside_frame: ");
      }
      {
#line 755
      printbits(mv_outside_frame, 1, 1);
      }
      }
    }
#line 757
    if (mv_outside_frame) {
#line 757
      long_vectors = 1;
    } else {
#line 757
      long_vectors = 0;
    }
    {
    {
#line 758
    tmp___49 = getbits(1);
    }
#line 758
    syntax_arith_coding = (int )tmp___49;
    }
#line 759
    if (trace) {
      {
      {
#line 761
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nsyntax_arith_coding: ");
      }
      {
#line 762
      printbits(syntax_arith_coding, 1, 1);
      }
      }
    }
    {
    {
#line 764
    tmp___50 = getbits(1);
    }
#line 764
    adv_pred_mode = (int )tmp___50;
    }
#line 765
    if (trace) {
      {
      {
#line 767
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nadv_pred_mode: ");
      }
      {
#line 768
      printbits(adv_pred_mode, 1, 1);
      }
      }
    }
#line 770
    if (adv_pred_mode) {
#line 770
      mv_outside_frame = 1;
    } else {
#line 770
      mv_outside_frame = mv_outside_frame;
    }
#line 771
    if (adv_pred_mode) {
#line 771
      overlapping_MC = 1;
    } else {
#line 771
      overlapping_MC = 0;
    }
#line 772
    if (adv_pred_mode) {
#line 772
      use_4mv = 1;
    } else {
#line 772
      use_4mv = 0;
    }
    {
    {
#line 773
    tmp___51 = getbits(1);
    }
#line 773
    pb_frame = (int )tmp___51;
    }
#line 774
    if (trace) {
      {
      {
#line 776
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\npb_frame: ");
      }
      {
#line 777
      printbits(pb_frame, 1, 1);
      }
      }
    }
    {
    {
#line 780
    tmp___52 = getbits(5);
    }
#line 780
    pic_quant = (int )tmp___52;
#line 781
    quant = pic_quant;
    }
#line 783
    if (trace) {
      {
      {
#line 785
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nquant: ");
      }
      {
#line 786
      printbits(quant, 5, 5);
      }
      }
    }
    {
    {
#line 789
    tmp___53 = getbits(1);
    }
#line 789
    tmp = (int )tmp___53;
    }
#line 790
    if (trace) {
      {
      {
#line 792
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nCPM: ");
      }
      {
#line 793
      printbits(tmp, 5, 5);
      }
      }
    }
#line 795
    if (tmp) {
#line 797
      if (! quiet) {
        {
        {
#line 798
        printf((char const   */* __restrict  */)"error: CPM not supported in this version\n");
        }
        }
      }
      {
      {
#line 799
      exit(-1);
      }
      }
    }
  }
#line 803
  if (pb_frame) {
#line 805
    if (optional_custom_PCF) {
      {
      {
#line 807
      tmp___54 = getbits(5);
      }
#line 807
      trb = (int )tmp___54;
      }
#line 808
      if (trace) {
        {
        {
#line 810
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ntrb: ");
        }
        {
#line 811
        printbits(trb, 5, 5);
        }
        }
      }
    } else {
      {
      {
#line 815
      tmp___55 = getbits(3);
      }
#line 815
      trb = (int )tmp___55;
      }
#line 816
      if (trace) {
        {
        {
#line 818
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ntrb: ");
        }
        {
#line 819
        printbits(trb, 3, 3);
        }
        }
      }
    }
    {
    {
#line 823
    tmp___56 = getbits(2);
    }
#line 823
    bquant = (int )tmp___56;
    }
#line 824
    if (trace) {
      {
      {
#line 826
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nbquant: ");
      }
      {
#line 827
      printbits(bquant, 2, 2);
      }
      }
    }
  } else {
#line 831
    trb = 0;
  }
#line 835
  if (framerate > 0) {
#line 835
    if (trd > 0) {
      {
      {
#line 836
      doframerate(0);
      }
      }
    }
  }
  {
  {
#line 839
  tmp___57 = getbits(1);
  }
#line 839
  pei = (int )tmp___57;
  }
#line 840
  if (trace) {
    {
    {
#line 842
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\npei: ");
    }
    {
#line 843
    printbits(pei, 1, 1);
    }
    }
  }
  pspare: 
#line 847
  if (pei) {
    {
    {
#line 850
    getbits(8);
    }
    {
#line 851
    tmp___58 = getbits(1);
    }
#line 851
    pei = (int )tmp___58;
    }
#line 852
    if (pei) {
#line 853
      goto pspare;
    }
  }
#line 855
  if (verbose > 0) {
#line 858
    if (verbose > 1) {
      {
      {
#line 860
      printf((char const   */* __restrict  */)"  temp_ref=%d\n", temp_ref);
      }
      }
#line 867
      if (pb_frame) {
        {
        {
#line 870
        printf((char const   */* __restrict  */)"  trb=%d\n", trb);
        }
        }
      }
    }
  }
#line 875
  if (trace) {
    {
    {
#line 877
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\n--------------------------------------------------------\n");
    }
    }
  }
#line 879
  return;
}
}
#line 883 "gethdr.c"
void getgobheader(void) 
{ 
  int BCI ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 885
  BCI = 0;
  {
#line 888
  tmp = getbits(2);
  }
#line 888
  gfid = (int )tmp;
  }
#line 889
  if (trace) {
    {
    {
#line 891
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ngfid: ");
    }
    {
#line 892
    printbits(gfid, 2, 2);
    }
    }
  }
#line 899
  if (gfid != pgfid) {
#line 899
    if (newgob) {
#line 901
      if (pict_type == 0) {
#line 902
        pict_type = 1;
      } else
#line 903
      if (pict_type == 1) {
#line 904
        pict_type = 0;
      }
    }
  }
  {
  {
#line 907
  tmp___0 = getbits(5);
  }
#line 907
  quant = (int )tmp___0;
  }
#line 908
  if (trace) {
    {
    {
#line 910
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nquant: ");
    }
    {
#line 911
    printbits(quant, 5, 5);
    }
    }
  }
#line 914
  if (reference_picture_selection_mode) {
    {
    {
#line 916
    tmp___1 = getbits(1);
    }
#line 916
    TRI = (int )tmp___1;
    }
#line 917
    if (trace) {
      {
      {
#line 919
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nTRI: ");
      }
      {
#line 920
      printbits(TRI, 1, 1);
      }
      }
    }
#line 922
    if (TRI) {
#line 925
      if (optional_custom_PCF) {
        {
        {
#line 925
        tmp___2 = getbits(10);
        }
#line 925
        temp_ref = (int )tmp___2;
        }
      } else {
        {
        {
#line 925
        tmp___3 = getbits(8);
        }
#line 925
        temp_ref = (int )tmp___3;
        }
      }
#line 926
      if (trace) {
        {
        {
#line 928
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ntemp_ref: ");
        }
        }
#line 929
        if (optional_custom_PCF) {
#line 929
          tmp___4 = 10;
        } else {
#line 929
          tmp___4 = 8;
        }
#line 929
        if (optional_custom_PCF) {
#line 929
          tmp___5 = 10;
        } else {
#line 929
          tmp___5 = 8;
        }
        {
        {
#line 929
        printbits(temp_ref, tmp___5, tmp___4);
        }
        }
      }
    }
    {
    {
#line 933
    tmp___6 = getbits(1);
    }
#line 933
    TRPI = (int )tmp___6;
    }
#line 934
    if (trace) {
      {
      {
#line 936
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nTRPI: ");
      }
      {
#line 937
      printbits(TRPI, 1, 1);
      }
      }
    }
#line 939
    if (TRPI) {
      {
      {
#line 942
      tmp___7 = getbits(10);
      }
#line 942
      temporal_reference_for_prediction = (int )tmp___7;
      }
#line 943
      if (trace) {
        {
        {
#line 945
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\ntemporal_reference_for_prediction: ");
        }
        {
#line 946
        printbits(temporal_reference_for_prediction, 10, 10);
        }
        }
      }
    }
    {
    {
#line 949
    tmp___9 = showbits(1);
    }
    }
#line 949
    if (tmp___9) {
      {
      {
#line 953
      flushbits(1);
      }
      }
#line 954
      if (! quiet) {
        {
        {
#line 955
        printf((char const   */* __restrict  */)"error: BCM(backward channel message) is not implemented in this version\n");
        }
        }
      }
      {
      {
#line 956
      exit(-1);
      }
      }
    } else {
      {
      {
#line 961
      tmp___8 = getbits(2);
      }
#line 961
      BCI = (int )tmp___8;
      }
#line 962
      if (trace) {
        {
        {
#line 964
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"\nBCI: ");
        }
        {
#line 965
        printbits(BCI, 2, 2);
        }
        }
      }
    }
  }
#line 969
  pgfid = gfid;
#line 970
  return;
}
}
#line 971 "gethdr.c"
void initoptions(void) 
{ 


  {
#line 973
  mv_outside_frame = 0;
#line 974
  syntax_arith_coding = 0;
#line 975
  adv_pred_mode = 0;
#line 976
  pb_frame = 0;
#line 977
  long_vectors = 0;
#line 979
  plus_type = 0;
#line 980
  optional_custom_PCF = 0;
#line 981
  advanced_intra_coding = 0;
#line 982
  deblocking_filter_mode = 0;
#line 983
  slice_structured_mode = 0;
#line 984
  reference_picture_selection_mode = 0;
#line 985
  independently_segmented_decoding_mode = 0;
#line 986
  alternative_inter_VLC_mode = 0;
#line 987
  modified_quantization_mode = 0;
#line 988
  reduced_resolution_update_mode = 0;
#line 989
  reference_picture_resampling_mode = 0;
#line 990
  rtype = 0;
#line 991
  return;
}
}
#line 56 "indices.h"
int codtab[2]  = {      0,      1};
#line 58 "indices.h"
int mcbpctab[21]  = 
#line 58
  {      0,      16,      32,      48, 
        1,      17,      33,      49, 
        2,      18,      34,      50, 
        3,      19,      35,      51, 
        4,      20,      36,      52, 
        255};
#line 60 "indices.h"
int mcbpctab_4mvq[25]  = 
#line 60
  {      0,      16,      32,      48, 
        1,      17,      33,      49, 
        2,      18,      34,      50, 
        3,      19,      35,      51, 
        4,      20,      36,      52, 
        255,      5,      21,      37, 
        53};
#line 63 "indices.h"
int mcbpc_intratab[9]  = 
#line 63
  {      3,      19,      35,      51, 
        4,      20,      36,      52, 
        255};
#line 65 "indices.h"
int modb_tab_G[3]  = {      0,      1,      2};
#line 67 "indices.h"
int modb_tab_M[6]  = {      0,      2,      6,      14, 
        30,      31};
#line 69 "indices.h"
int ycbpb_tab[2]  = {      0,      1};
#line 71 "indices.h"
int uvcbpb_tab[2]  = {      0,      1};
#line 73 "indices.h"
int cbpytab[16]  = 
#line 73
  {      15,      14,      13,      12, 
        11,      10,      9,      8, 
        7,      6,      5,      4, 
        3,      2,      1,      0};
#line 75 "indices.h"
int cbpy_intratab[16]  = 
#line 75
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15};
#line 77 "indices.h"
int dquanttab[4]  = {      1,      0,      3,      4};
#line 79 "indices.h"
int mvdtab[64]  = 
#line 79
  {      32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      50,      51, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      62,      63, 
        0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        24,      25,      26,      27, 
        28,      29,      30,      31};
#line 81 "indices.h"
int intradctab[254]  = 
#line 81
  {      1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        13,      14,      15,      16, 
        17,      18,      19,      20, 
        21,      22,      23,      24, 
        25,      26,      27,      28, 
        29,      30,      31,      32, 
        33,      34,      35,      36, 
        37,      38,      39,      40, 
        41,      42,      43,      44, 
        45,      46,      47,      48, 
        49,      50,      51,      52, 
        53,      54,      55,      56, 
        57,      58,      59,      60, 
        61,      62,      63,      64, 
        65,      66,      67,      68, 
        69,      70,      71,      72, 
        73,      74,      75,      76, 
        77,      78,      79,      80, 
        81,      82,      83,      84, 
        85,      86,      87,      88, 
        89,      90,      91,      92, 
        93,      94,      95,      96, 
        97,      98,      99,      100, 
        101,      102,      103,      104, 
        105,      106,      107,      108, 
        109,      110,      111,      112, 
        113,      114,      115,      116, 
        117,      118,      119,      120, 
        121,      122,      123,      124, 
        125,      126,      127,      255, 
        129,      130,      131,      132, 
        133,      134,      135,      136, 
        137,      138,      139,      140, 
        141,      142,      143,      144, 
        145,      146,      147,      148, 
        149,      150,      151,      152, 
        153,      154,      155,      156, 
        157,      158,      159,      160, 
        161,      162,      163,      164, 
        165,      166,      167,      168, 
        169,      170,      171,      172, 
        173,      174,      175,      176, 
        177,      178,      179,      180, 
        181,      182,      183,      184, 
        185,      186,      187,      188, 
        189,      190,      191,      192, 
        193,      194,      195,      196, 
        197,      198,      199,      200, 
        201,      202,      203,      204, 
        205,      206,      207,      208, 
        209,      210,      211,      212, 
        213,      214,      215,      216, 
        217,      218,      219,      220, 
        221,      222,      223,      224, 
        225,      226,      227,      228, 
        229,      230,      231,      232, 
        233,      234,      235,      236, 
        237,      238,      239,      240, 
        241,      242,      243,      244, 
        245,      246,      247,      248, 
        249,      250,      251,      252, 
        253,      254};
#line 83 "indices.h"
int tcoeftab[103]  = 
#line 83
  {      1,      2,      3,      4, 
        5,      6,      7,      8, 
        9,      10,      11,      12, 
        17,      18,      19,      20, 
        21,      22,      33,      34, 
        35,      36,      49,      50, 
        51,      65,      66,      67, 
        81,      82,      83,      97, 
        98,      99,      113,      114, 
        129,      130,      145,      146, 
        161,      162,      177,      193, 
        209,      225,      241,      257, 
        273,      289,      305,      321, 
        337,      353,      369,      385, 
        401,      417,      4097,      4098, 
        4099,      4113,      4114,      4129, 
        4145,      4161,      4177,      4193, 
        4209,      4225,      4241,      4257, 
        4273,      4289,      4305,      4321, 
        4337,      4353,      4369,      4385, 
        4401,      4417,      4433,      4449, 
        4465,      4481,      4497,      4513, 
        4529,      4545,      4561,      4577, 
        4593,      4609,      4625,      4641, 
        4657,      4673,      4689,      4705, 
        4721,      4737,      7167};
#line 85 "indices.h"
int signtab[2]  = {      0,      1};
#line 87 "indices.h"
int lasttab[2]  = {      0,      1};
#line 89 "indices.h"
int last_intratab[2]  = {      0,      1};
#line 91 "indices.h"
int runtab[64]  = 
#line 91
  {      0,      1,      2,      3, 
        4,      5,      6,      7, 
        8,      9,      10,      11, 
        12,      13,      14,      15, 
        16,      17,      18,      19, 
        20,      21,      22,      23, 
        24,      25,      26,      27, 
        28,      29,      30,      31, 
        32,      33,      34,      35, 
        36,      37,      38,      39, 
        40,      41,      42,      43, 
        44,      45,      46,      47, 
        48,      49,      50,      51, 
        52,      53,      54,      55, 
        56,      57,      58,      59, 
        60,      61,      62,      63};
#line 93 "indices.h"
int leveltab[254]  = 
#line 93
  {      129,      130,      131,      132, 
        133,      134,      135,      136, 
        137,      138,      139,      140, 
        141,      142,      143,      144, 
        145,      146,      147,      148, 
        149,      150,      151,      152, 
        153,      154,      155,      156, 
        157,      158,      159,      160, 
        161,      162,      163,      164, 
        165,      166,      167,      168, 
        169,      170,      171,      172, 
        173,      174,      175,      176, 
        177,      178,      179,      180, 
        181,      182,      183,      184, 
        185,      186,      187,      188, 
        189,      190,      191,      192, 
        193,      194,      195,      196, 
        197,      198,      199,      200, 
        201,      202,      203,      204, 
        205,      206,      207,      208, 
        209,      210,      211,      212, 
        213,      214,      215,      216, 
        217,      218,      219,      220, 
        221,      222,      223,      224, 
        225,      226,      227,      228, 
        229,      230,      231,      232, 
        233,      234,      235,      236, 
        237,      238,      239,      240, 
        241,      242,      243,      244, 
        245,      246,      247,      248, 
        249,      250,      251,      252, 
        253,      254,      255,      1, 
        2,      3,      4,      5, 
        6,      7,      8,      9, 
        10,      11,      12,      13, 
        14,      15,      16,      17, 
        18,      19,      20,      21, 
        22,      23,      24,      25, 
        26,      27,      28,      29, 
        30,      31,      32,      33, 
        34,      35,      36,      37, 
        38,      39,      40,      41, 
        42,      43,      44,      45, 
        46,      47,      48,      49, 
        50,      51,      52,      53, 
        54,      55,      56,      57, 
        58,      59,      60,      61, 
        62,      63,      64,      65, 
        66,      67,      68,      69, 
        70,      71,      72,      73, 
        74,      75,      76,      77, 
        78,      79,      80,      81, 
        82,      83,      84,      85, 
        86,      87,      88,      89, 
        90,      91,      92,      93, 
        94,      95,      96,      97, 
        98,      99,      100,      101, 
        102,      103,      104,      105, 
        106,      107,      108,      109, 
        110,      111,      112,      113, 
        114,      115,      116,      117, 
        118,      119,      120,      121, 
        122,      123,      124,      125, 
        126,      127};
#line 95 "indices.h"
int intra_ac_dctab[3]  = {      0,      2,      3};
#line 69 "sactbls.h"
int cumf_COD[3]  = {      16383,      6849,      0};
#line 71 "sactbls.h"
int cumf_MCBPC_no4MVQ[22]  = 
#line 71
  {      16383,      4105,      3088,      2367, 
        1988,      1621,      1612,      1609, 
        1608,      496,      353,      195, 
        77,      22,      17,      12, 
        5,      4,      3,      2, 
        1,      0};
#line 73 "sactbls.h"
int cumf_MCBPC_4MVQ[26]  = 
#line 73
  {      16383,      6880,      6092,      5178, 
        4916,      3965,      3880,      3795, 
        3768,      1491,      1190,      889, 
        655,      442,      416,      390, 
        360,      337,      334,      331, 
        327,      326,      88,      57, 
        26,      0};
#line 75 "sactbls.h"
int cumf_MCBPC_intra[10]  = 
#line 75
  {      16383,      7410,      6549,      5188, 
        442,      182,      181,      141, 
        1,      0};
#line 77 "sactbls.h"
int cumf_MODB_G[4]  = {      16383,      6062,      2130,      0};
#line 79 "sactbls.h"
int cumf_MODB_M[7]  = {      16383,      6717,      4568,      2784, 
        1370,      655,      0};
#line 81 "sactbls.h"
int cumf_YCBPB[3]  = {      16383,      6062,      0};
#line 83 "sactbls.h"
int cumf_UVCBPB[3]  = {      16383,      491,      0};
#line 85 "sactbls.h"
int cumf_CBPY[17]  = 
#line 85
  {      16383,      14481,      13869,      13196, 
        12568,      11931,      11185,      10814, 
        9796,      9150,      8781,      7933, 
        6860,      6116,      4873,      3538, 
        0};
#line 87 "sactbls.h"
int cumf_CBPY_intra[17]  = 
#line 87
  {      16383,      13619,      13211,      12933, 
        12562,      12395,      11913,      11783, 
        11004,      10782,      10689,      9928, 
        9353,      8945,      8407,      7795, 
        0};
#line 89 "sactbls.h"
int cumf_DQUANT[5]  = {      16383,      12287,      8192,      4095, 
        0};
#line 91 "sactbls.h"
int cumf_MVD[65]  = 
#line 91
  {      16383,      16380,      16369,      16365, 
        16361,      16357,      16350,      16343, 
        16339,      16333,      16326,      16318, 
        16311,      16306,      16298,      16291, 
        16283,      16272,      16261,      16249, 
        16235,      16222,      16207,      16175, 
        16141,      16094,      16044,      15936, 
        15764,      15463,      14956,      13924, 
        11491,      4621,      2264,      1315, 
        854,      583,      420,      326, 
        273,      229,      196,      166, 
        148,      137,      123,      114, 
        101,      91,      82,      76, 
        66,      59,      53,      46, 
        36,      30,      26,      24, 
        18,      14,      10,      5, 
        0};
#line 93 "sactbls.h"
int cumf_INTRADC[255]  = 
#line 93
  {      16383,      16380,      16379,      16378, 
        16377,      16376,      16370,      16361, 
        16360,      16359,      16358,      16357, 
        16356,      16355,      16343,      16238, 
        16237,      16236,      16230,      16221, 
        16220,      16205,      16190,      16169, 
        16151,      16130,      16109,      16094, 
        16070,      16037,      16007,      15962, 
        15938,      15899,      15854,      15815, 
        15788,      15743,      15689,      15656, 
        15617,      15560,      15473,      15404, 
        15296,      15178,      15106,      14992, 
        14868,      14738,      14593,      14438, 
        14283,      14169,      14064,      14004, 
        13914,      13824,      13752,      13671, 
        13590,      13515,      13458,      13380, 
        13305,      13230,      13143,      13025, 
        12935,      12878,      12794,      12743, 
        12656,      12596,      12521,      12443, 
        12359,      12278,      12200,      12131, 
        12047,      12002,      11948,      11891, 
        11828,      11744,      11663,      11588, 
        11495,      11402,      11288,      11204, 
        11126,      11039,      10961,      10883, 
        10787,      10679,      10583,      10481, 
        10360,      10227,      10113,      9961, 
        9828,      9717,      9584,      9485, 
        9324,      9112,      9019,      8908, 
        8766,      8584,      8426,      8211, 
        7920,      7663,      7406,      7152, 
        6904,      6677,      6453,      6265, 
        6101,      5904,      5716,      5489, 
        5307,      5056,      4850,      4569, 
        4284,      3966,      3712,      3518, 
        3342,      3206,      3048,      2909, 
        2773,      2668,      2596,      2512, 
        2370,      2295,      2232,      2166, 
        2103,      2022,      1956,      1887, 
        1830,      1803,      1770,      1728, 
        1674,      1635,      1599,      1557, 
        1500,      1482,      1434,      1389, 
        1356,      1317,      1284,      1245, 
        1200,      1179,      1140,      1110, 
        1092,      1062,      1044,      1035, 
        1014,      1008,      993,      981, 
        954,      936,      912,      894, 
        876,      864,      849,      828, 
        816,      801,      792,      777, 
        756,      732,      690,      660, 
        642,      615,      597,      576, 
        555,      522,      489,      459, 
        435,      411,      405,      396, 
        387,      375,      360,      354, 
        345,      344,      329,      314, 
        293,      278,      251,      236, 
        230,      224,      215,      214, 
        208,      199,      193,      184, 
        178,      169,      154,      127, 
        100,      94,      73,      37, 
        36,      35,      34,      33, 
        32,      31,      30,      29, 
        28,      27,      26,      20, 
        19,      18,      17,      16, 
        15,      9,      0};
#line 95 "sactbls.h"
int cumf_TCOEF1[104]  = 
#line 95
  {      16383,      13455,      12458,      12079, 
        11885,      11800,      11738,      11700, 
        11681,      11661,      11651,      11645, 
        11641,      10572,      10403,      10361, 
        10346,      10339,      10335,      9554, 
        9445,      9427,      9419,      9006, 
        8968,      8964,      8643,      8627, 
        8624,      8369,      8354,      8352, 
        8200,      8192,      8191,      8039, 
        8036,      7920,      7917,      7800, 
        7793,      7730,      7727,      7674, 
        7613,      7564,      7513,      7484, 
        7466,      7439,      7411,      7389, 
        7373,      7369,      7359,      7348, 
        7321,      7302,      7294,      5013, 
        4819,      4789,      4096,      4073, 
        3373,      3064,      2674,      2357, 
        2177,      1975,      1798,      1618, 
        1517,      1421,      1303,      1194, 
        1087,      1027,      960,      890, 
        819,      758,      707,      680, 
        656,      613,      566,      534, 
        505,      475,      465,      449, 
        430,      395,      358,      335, 
        324,      303,      295,      286, 
        272,      233,      215,      0};
#line 97 "sactbls.h"
int cumf_TCOEF2[104]  = 
#line 97
  {      16383,      13582,      12709,      12402, 
        12262,      12188,      12150,      12131, 
        12125,      12117,      12113,      12108, 
        12104,      10567,      10180,      10070, 
        10019,      9998,      9987,      9158, 
        9037,      9010,      9005,      8404, 
        8323,      8312,      7813,      7743, 
        7726,      7394,      7366,      7364, 
        7076,      7062,      7060,      6810, 
        6797,      6614,      6602,      6459, 
        6454,      6304,      6303,      6200, 
        6121,      6059,      6012,      5973, 
        5928,      5893,      5871,      5847, 
        5823,      5809,      5796,      5781, 
        5771,      5763,      5752,      4754, 
        4654,      4631,      3934,      3873, 
        3477,      3095,      2758,      2502, 
        2257,      2054,      1869,      1715, 
        1599,      1431,      1305,      1174, 
        1059,      983,      901,      839, 
        777,      733,      683,      658, 
        606,      565,      526,      488, 
        456,      434,      408,      380, 
        361,      327,      310,      296, 
        267,      259,      249,      239, 
        230,      221,      214,      0};
#line 99 "sactbls.h"
int cumf_TCOEF3[104]  = 
#line 99
  {      16383,      13532,      12677,      12342, 
        12195,      12112,      12059,      12034, 
        12020,      12008,      12003,      12002, 
        12001,      10586,      10297,      10224, 
        10202,      10195,      10191,      9223, 
        9046,      8999,      8987,      8275, 
        8148,      8113,      7552,      7483, 
        7468,      7066,      7003,      6989, 
        6671,      6642,      6631,      6359, 
        6327,      6114,      6103,      5929, 
        5918,      5792,      5785,      5672, 
        5580,      5507,      5461,      5414, 
        5382,      5354,      5330,      5312, 
        5288,      5273,      5261,      5247, 
        5235,      5227,      5219,      4357, 
        4277,      4272,      3847,      3819, 
        3455,      3119,      2829,      2550, 
        2313,      2104,      1881,      1711, 
        1565,      1366,      1219,      1068, 
        932,      866,      799,      750, 
        701,      662,      605,      559, 
        513,      471,      432,      403, 
        365,      336,      312,      290, 
        276,      266,      254,      240, 
        228,      223,      216,      206, 
        199,      192,      189,      0};
#line 101 "sactbls.h"
int cumf_TCOEFr[104]  = 
#line 101
  {      16383,      13216,      12233,      11931, 
        11822,      11776,      11758,      11748, 
        11743,      11742,      11741,      11740, 
        11739,      10203,      9822,      9725, 
        9691,      9677,      9674,      8759, 
        8609,      8576,      8566,      7901, 
        7787,      7770,      7257,      7185, 
        7168,      6716,      6653,      6639, 
        6276,      6229,      6220,      5888, 
        5845,      5600,      5567,      5348, 
        5327,      5160,      5142,      5004, 
        4900,      4798,      4743,      4708, 
        4685,      4658,      4641,      4622, 
        4610,      4598,      4589,      4582, 
        4578,      4570,      4566,      3824, 
        3757,      3748,      3360,      3338, 
        3068,      2835,      2592,      2359, 
        2179,      1984,      1804,      1614, 
        1445,      1234,      1068,      870, 
        739,      668,      616,      566, 
        532,      489,      453,      426, 
        385,      357,      335,      316, 
        297,      283,      274,      266, 
        259,      251,      241,      233, 
        226,      222,      217,      214, 
        211,      209,      208,      0};
#line 103 "sactbls.h"
int cumf_TCOEF1_intra[104]  = 
#line 103
  {      16383,      13383,      11498,      10201, 
        9207,      8528,      8099,      7768, 
        7546,      7368,      7167,      6994, 
        6869,      6005,      5474,      5220, 
        5084,      4964,      4862,      4672, 
        4591,      4570,      4543,      4397, 
        4337,      4326,      4272,      4240, 
        4239,      4212,      4196,      4185, 
        4158,      4157,      4156,      4140, 
        4139,      4138,      4137,      4136, 
        4125,      4124,      4123,      4112, 
        4111,      4110,      4109,      4108, 
        4107,      4106,      4105,      4104, 
        4103,      4102,      4101,      4100, 
        4099,      4098,      4097,      3043, 
        2897,      2843,      1974,      1790, 
        1677,      1552,      1416,      1379, 
        1331,      1288,      1251,      1250, 
        1249,      1248,      1247,      1236, 
        1225,      1224,      1223,      1212, 
        1201,      1200,      1199,      1198, 
        1197,      1196,      1195,      1194, 
        1193,      1192,      1191,      1190, 
        1189,      1188,      1187,      1186, 
        1185,      1184,      1183,      1182, 
        1181,      1180,      1179,      0};
#line 105 "sactbls.h"
int cumf_TCOEF2_intra[104]  = 
#line 105
  {      16383,      13242,      11417,      10134, 
        9254,      8507,      8012,      7556, 
        7273,      7062,      6924,      6839, 
        6741,      6108,      5851,      5785, 
        5719,      5687,      5655,      5028, 
        4917,      4864,      4845,      4416, 
        4159,      4074,      3903,      3871, 
        3870,      3765,      3752,      3751, 
        3659,      3606,      3580,      3541, 
        3540,      3514,      3495,      3494, 
        3493,      3474,      3473,      3441, 
        3440,      3439,      3438,      3425, 
        3424,      3423,      3422,      3421, 
        3420,      3401,      3400,      3399, 
        3398,      3397,      3396,      2530, 
        2419,      2360,      2241,      2228, 
        2017,      1687,      1576,      1478, 
        1320,      1281,      1242,      1229, 
        1197,      1178,      1152,      1133, 
        1114,      1101,      1088,      1087, 
        1086,      1085,      1072,      1071, 
        1070,      1069,      1068,      1067, 
        1066,      1065,      1064,      1063, 
        1062,      1061,      1060,      1059, 
        1058,      1057,      1056,      1055, 
        1054,      1053,      1052,      0};
#line 107 "sactbls.h"
int cumf_TCOEF3_intra[104]  = 
#line 107
  {      16383,      12741,      10950,      10071, 
        9493,      9008,      8685,      8516, 
        8385,      8239,      8209,      8179, 
        8141,      6628,      5980,      5634, 
        5503,      5396,      5327,      4857, 
        4642,      4550,      4481,      4235, 
        4166,      4151,      3967,      3922, 
        3907,      3676,      3500,      3324, 
        3247,      3246,      3245,      3183, 
        3168,      3084,      3069,      3031, 
        3030,      3029,      3014,      3013, 
        2990,      2975,      2974,      2973, 
        2958,      2943,      2928,      2927, 
        2926,      2925,      2924,      2923, 
        2922,      2921,      2920,      2397, 
        2298,      2283,      1891,      1799, 
        1591,      1445,      1338,      1145, 
        1068,      1006,      791,      768, 
        661,      631,      630,      615, 
        592,      577,      576,      561, 
        546,      523,      508,      493, 
        492,      491,      476,      475, 
        474,      473,      472,      471, 
        470,      469,      468,      453, 
        452,      451,      450,      449, 
        448,      447,      446,      0};
#line 109 "sactbls.h"
int cumf_TCOEFr_intra[104]  = 
#line 109
  {      16383,      12514,      10776,      9969, 
        9579,      9306,      9168,      9082, 
        9032,      9000,      8981,      8962, 
        8952,      7630,      7212,      7053, 
        6992,      6961,      6940,      6195, 
        5988,      5948,      5923,      5370, 
        5244,      5210,      4854,      4762, 
        4740,      4384,      4300,      4288, 
        4020,      3968,      3964,      3752, 
        3668,      3511,      3483,      3354, 
        3322,      3205,      3183,      3108, 
        3046,      2999,      2981,      2974, 
        2968,      2961,      2955,      2949, 
        2943,      2942,      2939,      2935, 
        2934,      2933,      2929,      2270, 
        2178,      2162,      1959,      1946, 
        1780,      1651,      1524,      1400, 
        1289,      1133,      1037,      942, 
        849,      763,      711,      591, 
        521,      503,      496,      474, 
        461,      449,      442,      436, 
        426,      417,      407,      394, 
        387,      377,      373,      370, 
        367,      366,      365,      364, 
        363,      362,      358,      355, 
        352,      351,      350,      0};
#line 111 "sactbls.h"
int cumf_SIGN[3]  = {      16383,      8416,      0};
#line 113 "sactbls.h"
int cumf_LAST[3]  = {      16383,      9469,      0};
#line 115 "sactbls.h"
int cumf_LAST_intra[3]  = {      16383,      2820,      0};
#line 117 "sactbls.h"
int cumf_RUN[65]  = 
#line 117
  {      16383,      15310,      14702,      13022, 
        11883,      11234,      10612,      10192, 
        9516,      9016,      8623,      8366, 
        7595,      7068,      6730,      6487, 
        6379,      6285,      6177,      6150, 
        6083,      5989,      5949,      5922, 
        5895,      5828,      5774,      5773, 
        5394,      5164,      5016,      4569, 
        4366,      4136,      4015,      3867, 
        3773,      3692,      3611,      3476, 
        3341,      3301,      2787,      2503, 
        2219,      1989,      1515,      1095, 
        934,      799,      691,      583, 
        435,      300,      246,      206, 
        125,      124,      97,      57, 
        30,      3,      2,      1, 
        0};
#line 119 "sactbls.h"
int cumf_RUN_intra[65]  = 
#line 119
  {      16383,      10884,      8242,      7124, 
        5173,      4745,      4246,      3984, 
        3034,      2749,      2607,      2298, 
        966,      681,      396,      349, 
        302,      255,      254,      253, 
        206,      159,      158,      157, 
        156,      155,      154,      153, 
        106,      35,      34,      33, 
        32,      31,      30,      29, 
        28,      27,      26,      25, 
        24,      23,      22,      21, 
        20,      19,      18,      17, 
        16,      15,      14,      13, 
        12,      11,      10,      9, 
        8,      7,      6,      5, 
        4,      3,      2,      1, 
        0};
#line 121 "sactbls.h"
int cumf_LEVEL[255]  = 
#line 121
  {      16383,      16382,      16381,      16380, 
        16379,      16378,      16377,      16376, 
        16375,      16374,      16373,      16372, 
        16371,      16370,      16369,      16368, 
        16367,      16366,      16365,      16364, 
        16363,      16362,      16361,      16360, 
        16359,      16358,      16357,      16356, 
        16355,      16354,      16353,      16352, 
        16351,      16350,      16349,      16348, 
        16347,      16346,      16345,      16344, 
        16343,      16342,      16341,      16340, 
        16339,      16338,      16337,      16336, 
        16335,      16334,      16333,      16332, 
        16331,      16330,      16329,      16328, 
        16327,      16326,      16325,      16324, 
        16323,      16322,      16321,      16320, 
        16319,      16318,      16317,      16316, 
        16315,      16314,      16313,      16312, 
        16311,      16310,      16309,      16308, 
        16307,      16306,      16305,      16304, 
        16303,      16302,      16301,      16300, 
        16299,      16298,      16297,      16296, 
        16295,      16294,      16293,      16292, 
        16291,      16290,      16289,      16288, 
        16287,      16286,      16285,      16284, 
        16283,      16282,      16281,      16280, 
        16279,      16278,      16277,      16250, 
        16223,      16222,      16195,      16154, 
        16153,      16071,      15989,      15880, 
        15879,      15878,      15824,      15756, 
        15674,      15606,      15538,      15184, 
        14572,      13960,      10718,      7994, 
        5379,      2123,      1537,      992, 
        693,      611,      516,      448, 
        421,      380,      353,      352, 
        284,      257,      230,      203, 
        162,      161,      160,      133, 
        132,      105,      104,      103, 
        102,      101,      100,      99, 
        98,      97,      96,      95, 
        94,      93,      92,      91, 
        90,      89,      88,      87, 
        86,      85,      84,      83, 
        82,      81,      80,      79, 
        78,      77,      76,      75, 
        74,      73,      72,      71, 
        70,      69,      68,      67, 
        66,      65,      64,      63, 
        62,      61,      60,      59, 
        58,      57,      56,      55, 
        54,      53,      52,      51, 
        50,      49,      48,      47, 
        46,      45,      44,      43, 
        42,      41,      40,      39, 
        38,      37,      36,      35, 
        34,      33,      32,      31, 
        30,      29,      28,      27, 
        26,      25,      24,      23, 
        22,      21,      20,      19, 
        18,      17,      16,      15, 
        14,      13,      12,      11, 
        10,      9,      8,      7, 
        6,      5,      4,      3, 
        2,      1,      0};
#line 123 "sactbls.h"
int cumf_LEVEL_intra[255]  = 
#line 123
  {      16383,      16379,      16378,      16377, 
        16376,      16375,      16374,      16373, 
        16372,      16371,      16370,      16369, 
        16368,      16367,      16366,      16365, 
        16364,      16363,      16362,      16361, 
        16360,      16359,      16358,      16357, 
        16356,      16355,      16354,      16353, 
        16352,      16351,      16350,      16349, 
        16348,      16347,      16346,      16345, 
        16344,      16343,      16342,      16341, 
        16340,      16339,      16338,      16337, 
        16336,      16335,      16334,      16333, 
        16332,      16331,      16330,      16329, 
        16328,      16327,      16326,      16325, 
        16324,      16323,      16322,      16321, 
        16320,      16319,      16318,      16317, 
        16316,      16315,      16314,      16313, 
        16312,      16311,      16268,      16267, 
        16224,      16223,      16180,      16179, 
        16136,      16135,      16134,      16133, 
        16132,      16131,      16130,      16129, 
        16128,      16127,      16126,      16061, 
        16018,      16017,      16016,      16015, 
        16014,      15971,      15970,      15969, 
        15968,      15925,      15837,      15794, 
        15751,      15750,      15749,      15661, 
        15618,      15508,      15376,      15288, 
        15045,      14913,      14781,      14384, 
        13965,      13502,      13083,      12509, 
        12289,      12135,      11892,      11738, 
        11429,      11010,      10812,      10371, 
        9664,      9113,      8117,      8116, 
        8028,      6855,      5883,      4710, 
        4401,      4203,      3740,      3453, 
        3343,      3189,      2946,      2881, 
        2661,      2352,      2132,      1867, 
        1558,      1382,      1250,      1162, 
        1097,      1032,      967,      835, 
        681,      549,      439,      351, 
        350,      307,      306,      305, 
        304,      303,      302,      301, 
        300,      299,      298,      255, 
        212,      211,      210,      167, 
        166,      165,      164,      163, 
        162,      161,      160,      159, 
        158,      115,      114,      113, 
        112,      111,      68,      67, 
        66,      65,      64,      63, 
        62,      61,      60,      59, 
        58,      57,      56,      55, 
        54,      53,      52,      51, 
        50,      49,      48,      47, 
        46,      45,      44,      43, 
        42,      41,      40,      39, 
        38,      37,      36,      35, 
        34,      33,      32,      31, 
        30,      29,      28,      27, 
        26,      25,      24,      23, 
        22,      21,      20,      19, 
        18,      17,      16,      15, 
        14,      13,      12,      11, 
        10,      9,      8,      7, 
        6,      5,      4,      3, 
        2,      1,      0};
#line 125 "sactbls.h"
int cumf_INTRA_AC_DC[4]  = {      16383,      9229,      5461,      0};
#line 95 "getblk.c"
RunCoef vlc_word_decode(int symbol_word , int *last ) ;
#line 96
RunCoef Decode_Escape_Char(int intra , int *last ) ;
#line 97
int DecodeTCoef(int position , int intra ) ;
#line 108 "getblk.c"
void getblock(int comp , int mode , int INTRA_AC_DC , int Mode ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  unsigned int code ;
  VLCtab *tab ;
  short *bp ;
  int run ;
  int last ;
  int level ;
  int QP ;
  short *qval ;
  int use_intra ;
  CodeCoeff store_code[64] ;
  int coeff_ind ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char const   *tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  int tmp___13 ;
  int tmp___15 ;
  int tmp___16 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 119
  use_intra = 0;
#line 123
  bp = ld->block[comp];
#line 127
  if (trace) {
    {
    {
#line 128
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"block: %i\n",
            comp);
    }
    }
  }
#line 130
  if (alternative_inter_VLC_mode) {
#line 130
    if (! (Mode == 3)) {
#line 130
      if (! (Mode == 4)) {
#line 132
        coeff_ind = 0;
#line 133
        use_intra = 0;
#line 134
        i = mode == 0;
        {
        {
#line 134
        while (1) {
          while_continue___1: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
          {
          {
#line 136
          code = showbits(12);
          }
#line 137
          store_code[coeff_ind].code = (int )code;
          }
#line 138
          if (code >= 512U) {
#line 139
            tab = & DCT3Dtab0[(code >> 5) - 16U];
          } else
#line 140
          if (code >= 128U) {
#line 141
            tab = & DCT3Dtab1[(code >> 2) - 32U];
          } else
#line 142
          if (code >= 8U) {
#line 143
            tab = & DCT3Dtab2[code - 8U];
          } else {
#line 146
            if (! quiet) {
              {
              {
#line 147
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid Huffman code in getblock()\n");
              }
              }
            }
#line 148
            fault = 1;
#line 149
            return;
          }
          {
#line 152
          run = (tab->val >> 4) & 255;
#line 153
          last = (tab->val >> 12) & 1;
          {
#line 154
          flushbits(tab->len);
          }
          }
#line 155
          if (tab->val == 7167) {
            {
            {
#line 157
            tmp = getbits1();
            }
#line 157
            last = (int )tmp;
#line 158
            store_code[coeff_ind].last = last;
            {
#line 160
            tmp___0 = getbits(6);
            }
#line 160
            run = (int )tmp___0;
#line 160
            i += run;
#line 161
            store_code[coeff_ind].run = run;
            {
#line 163
            tmp___1 = getbits(8);
            }
#line 163
            level = (int )tmp___1;
#line 164
            store_code[coeff_ind].level = level;
            }
#line 167
            if (level == 128) {
#line 167
              if (modified_quantization_mode) {
                {
                {
#line 169
                tmp___2 = getbits(11);
                }
#line 169
                level = (int )tmp___2;
#line 170
                store_code[coeff_ind].extended_level = level;
                }
              }
            }
          } else {
            {
            {
#line 174
            tmp___3 = getbits(1);
            }
#line 174
            store_code[coeff_ind].sign = (int )tmp___3;
#line 175
            i += run;
            }
          }
#line 177
          coeff_ind ++;
#line 179
          if (i >= 64) {
#line 180
            use_intra = 1;
          }
#line 181
          if (last) {
#line 182
            goto while_break;
          }
#line 134
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
#line 184
        if (trace) {
#line 185
          if (use_intra) {
#line 185
            tmp___4 = "Intra";
          } else {
#line 185
            tmp___4 = "Inter";
          }
          {
          {
#line 185
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"inter VLC Table: %s\n",
                  tmp___4);
          }
          }
        }
      }
    }
  }
#line 187
  coeff_ind = 0;
#line 189
  i = mode == 0;
  {
  {
#line 189
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 191
    if (alternative_inter_VLC_mode) {
#line 191
      if (Mode == 3) {
#line 191
        goto _L___1;
      } else
#line 191
      if (Mode == 4) {
#line 191
        goto _L___1;
      } else {
#line 193
        if (use_intra) {
#line 195
          if (store_code[coeff_ind].code >= 512) {
#line 196
            tab = & INTRA_DCT3Dtab0[(store_code[coeff_ind].code >> 5) - 16];
          } else
#line 197
          if (store_code[coeff_ind].code >= 128) {
#line 198
            tab = & INTRA_DCT3Dtab1[(store_code[coeff_ind].code >> 2) - 32];
          } else
#line 199
          if (store_code[coeff_ind].code >= 8) {
#line 200
            tab = & INTRA_DCT3Dtab2[store_code[coeff_ind].code - 8];
          } else {
#line 203
            if (! quiet) {
              {
              {
#line 204
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid Huffman code in getblock()\n");
              }
              }
            }
#line 205
            fault = 1;
#line 206
            return;
          }
#line 208
          run = (tab->val >> 6) & 63;
#line 209
          level = tab->val & 63;
#line 210
          last = (tab->val >> 12) & 1;
        } else {
#line 213
          if (store_code[coeff_ind].code >= 512) {
#line 214
            tab = & DCT3Dtab0[(store_code[coeff_ind].code >> 5) - 16];
          } else
#line 215
          if (store_code[coeff_ind].code >= 128) {
#line 216
            tab = & DCT3Dtab1[(store_code[coeff_ind].code >> 2) - 32];
          } else
#line 217
          if (store_code[coeff_ind].code >= 8) {
#line 218
            tab = & DCT3Dtab2[store_code[coeff_ind].code - 8];
          } else {
#line 221
            if (! quiet) {
              {
              {
#line 222
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid Huffman code in getblock()\n");
              }
              }
            }
#line 223
            fault = 1;
#line 224
            return;
          }
#line 227
          run = (tab->val >> 4) & 255;
#line 228
          level = tab->val & 15;
#line 229
          last = (tab->val >> 12) & 1;
        }
#line 232
        if (trace) {
          {
          {
#line 234
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" (");
          }
          {
#line 235
          printbits(store_code[coeff_ind].code, 12, tab->len);
          }
          }
        }
#line 237
        if (tab->val == 7167) {
#line 239
          if (trace) {
            {
            {
#line 241
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" ");
            }
            {
#line 242
            printbits(store_code[coeff_ind].last, 1, 1);
            }
            }
          }
#line 244
          last = store_code[coeff_ind].last;
#line 245
          if (trace) {
            {
            {
#line 247
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" ");
            }
            {
#line 248
            printbits(store_code[coeff_ind].run, 6, 6);
            }
            }
          }
#line 250
          run = store_code[coeff_ind].run;
#line 250
          i += run;
#line 251
          if (trace) {
            {
            {
#line 253
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" ");
            }
            {
#line 254
            printbits(store_code[coeff_ind].level, 8, 8);
            }
            }
          }
#line 256
          level = store_code[coeff_ind].level;
#line 258
          sign = level >= 128;
#line 258
          if (sign) {
#line 259
            val = 256 - level;
          } else {
#line 261
            val = level;
          }
#line 263
          if (level == 128) {
#line 263
            if (modified_quantization_mode) {
#line 265
              level = store_code[coeff_ind].extended_level;
#line 266
              level = ((level >> 6) & 31) | (level << 5);
#line 268
              level = (level << (sizeof(int ) * 8UL - 11UL)) >> (sizeof(int ) * 8UL - 11UL);
#line 269
              if (level >= 0) {
#line 270
                sign = 0;
              } else {
#line 272
                sign = 1;
              }
              {
              {
#line 273
              val = abs(level);
              }
              }
            }
          }
        } else {
#line 277
          sign = store_code[coeff_ind].sign;
#line 278
          i += run;
#line 279
          val = level;
#line 281
          if (trace) {
            {
            {
#line 282
            fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"%d",
                    sign);
            }
            }
          }
        }
#line 284
        coeff_ind ++;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
      {
#line 288
      code = showbits(12);
      }
      }
#line 289
      if (advanced_intra_coding) {
#line 289
        if (Mode == 3) {
#line 289
          goto _L___0;
        } else
#line 289
        if (Mode == 4) {
          _L___0: /* CIL Label */ 
#line 291
          if (code >= 512U) {
#line 292
            tab = & INTRA_DCT3Dtab0[(code >> 5) - 16U];
          } else
#line 293
          if (code >= 128U) {
#line 294
            tab = & INTRA_DCT3Dtab1[(code >> 2) - 32U];
          } else
#line 295
          if (code >= 8U) {
#line 296
            tab = & INTRA_DCT3Dtab2[code - 8U];
          } else {
#line 299
            if (! quiet) {
              {
              {
#line 300
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid Huffman code in getblock()\n");
              }
              }
            }
#line 301
            fault = 1;
#line 302
            return;
          }
#line 304
          run = (tab->val >> 6) & 63;
#line 305
          level = tab->val & 63;
#line 306
          last = (tab->val >> 12) & 1;
        } else {
#line 289
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 310
        if (code >= 512U) {
#line 311
          tab = & DCT3Dtab0[(code >> 5) - 16U];
        } else
#line 312
        if (code >= 128U) {
#line 313
          tab = & DCT3Dtab1[(code >> 2) - 32U];
        } else
#line 314
        if (code >= 8U) {
#line 315
          tab = & DCT3Dtab2[code - 8U];
        } else {
#line 318
          if (! quiet) {
            {
            {
#line 319
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid Huffman code in getblock()\n");
            }
            }
          }
#line 320
          fault = 1;
#line 321
          return;
        }
#line 324
        run = (tab->val >> 4) & 255;
#line 325
        level = tab->val & 15;
#line 326
        last = (tab->val >> 12) & 1;
      }
      {
      {
#line 328
      flushbits(tab->len);
      }
      }
#line 329
      if (trace) {
        {
        {
#line 331
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" (");
        }
        {
#line 332
        printbits((int )code, 12, tab->len);
        }
        }
      }
#line 334
      if (tab->val == 7167) {
#line 336
        if (trace) {
          {
          {
#line 338
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" ");
          }
          {
#line 339
          tmp___5 = showbits(1);
          }
          {
#line 339
          printbits((int )tmp___5, 1, 1);
          }
          }
        }
        {
        {
#line 341
        tmp___6 = getbits1();
        }
#line 341
        last = (int )tmp___6;
        }
#line 342
        if (trace) {
          {
          {
#line 344
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" ");
          }
          {
#line 345
          tmp___7 = showbits(6);
          }
          {
#line 345
          printbits((int )tmp___7, 6, 6);
          }
          }
        }
        {
        {
#line 347
        tmp___8 = getbits(6);
        }
#line 347
        run = (int )tmp___8;
#line 347
        i += run;
        }
#line 348
        if (trace) {
          {
          {
#line 350
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)" ");
          }
          {
#line 351
          tmp___9 = showbits(8);
          }
          {
#line 351
          printbits((int )tmp___9, 8, 8);
          }
          }
        }
        {
        {
#line 353
        tmp___10 = getbits(8);
        }
#line 353
        level = (int )tmp___10;
#line 355
        sign = level >= 128;
        }
#line 355
        if (sign) {
#line 356
          val = 256 - level;
        } else {
#line 358
          val = level;
        }
#line 360
        if (level == 128) {
#line 360
          if (modified_quantization_mode) {
            {
            {
#line 363
            tmp___11 = getbits(11);
            }
#line 363
            level = (int )tmp___11;
#line 364
            level = ((level >> 6) & 31) | (level << 5);
#line 366
            level = (level << (sizeof(int ) * 8UL - 11UL)) >> (sizeof(int ) * 8UL - 11UL);
            }
#line 367
            if (level >= 0) {
#line 368
              sign = 0;
            } else {
#line 370
              sign = 1;
            }
            {
            {
#line 371
            val = abs(level);
            }
            }
          }
        }
      } else {
        {
#line 375
        i += run;
#line 376
        val = level;
        {
#line 377
        tmp___12 = getbits(1);
        }
#line 377
        sign = (int )tmp___12;
        }
#line 378
        if (trace) {
          {
          {
#line 379
          fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"%d",
                  sign);
          }
          }
        }
      }
    }
#line 383
    if (i >= 64) {
#line 385
      if (! quiet) {
        {
        {
#line 386
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DCT coeff index (i) out of bounds\n");
        }
        }
      }
#line 387
      fault = 1;
#line 388
      return;
    }
#line 390
    if (trace) {
#line 391
      if (sign) {
#line 391
        tmp___13 = - val;
      } else {
#line 391
        tmp___13 = val;
      }
      {
      {
#line 391
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"): %d/%d\n",
              run, tmp___13);
      }
      }
    }
#line 395
    if (advanced_intra_coding) {
#line 395
      if (Mode == 3) {
#line 395
        goto _L___2;
      } else
#line 395
      if (Mode == 4) {
        _L___2: /* CIL Label */ 
        {
#line 399
        if (INTRA_AC_DC == 0) {
#line 399
          goto case_0;
        }
#line 402
        if (INTRA_AC_DC == 2) {
#line 402
          goto case_2;
        }
#line 405
        if (INTRA_AC_DC == 3) {
#line 405
          goto case_3;
        }
#line 408
        goto switch_default;
        case_0: /* CIL Label */ 
#line 400
        j = (int )zig_zag_scan[i];
#line 401
        goto switch_break;
        case_2: /* CIL Label */ 
#line 403
        j = (int )alternate_horizontal_scan[i];
#line 404
        goto switch_break;
        case_3: /* CIL Label */ 
#line 406
        j = (int )alternate_vertical_scan[i];
#line 407
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        {
#line 409
        printf((char const   */* __restrict  */)"Invalid Intra_Mode in Advanced Intra Coding\n");
        }
        {
#line 410
        exit(-1);
        }
        }
#line 411
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 415
        j = (int )zig_zag_scan[i];
      }
    } else {
#line 415
      j = (int )zig_zag_scan[i];
    }
#line 417
    qval = bp + j;
#line 418
    if (comp >= 6) {
#line 419
      if (31 < bquant_tab[bquant] * quant >> 2) {
#line 419
        tmp___16 = 31;
      } else {
#line 419
        tmp___16 = bquant_tab[bquant] * quant >> 2;
      }
#line 419
      if (1 > tmp___16) {
#line 419
        QP = 1;
      } else {
#line 419
        if (31 < bquant_tab[bquant] * quant >> 2) {
#line 419
          tmp___15 = 31;
        } else {
#line 419
          tmp___15 = bquant_tab[bquant] * quant >> 2;
        }
#line 419
        QP = tmp___15;
      }
    } else {
#line 421
      QP = quant;
    }
#line 423
    if (modified_quantization_mode) {
#line 423
      if (comp == 4) {
#line 428
        QP = MQ_chroma_QP_table[QP];
      } else
#line 423
      if (comp == 5) {
#line 428
        QP = MQ_chroma_QP_table[QP];
      } else
#line 423
      if (comp == 10) {
#line 428
        QP = MQ_chroma_QP_table[QP];
      } else
#line 423
      if (comp == 11) {
#line 428
        QP = MQ_chroma_QP_table[QP];
      }
    }
#line 430
    if (advanced_intra_coding) {
#line 430
      if (Mode == 3) {
#line 430
        goto _L___4;
      } else
#line 430
      if (Mode == 4) {
        _L___4: /* CIL Label */ 
#line 433
        if (sign) {
#line 433
          *qval = (short )(- (QP * (2 * val)));
        } else {
#line 433
          *qval = (short )(QP * (2 * val));
        }
      } else {
#line 430
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 437
    if (QP % 2 == 1) {
#line 438
      if (sign) {
#line 438
        *qval = (short )(- (QP * (2 * val + 1)));
      } else {
#line 438
        *qval = (short )(QP * (2 * val + 1));
      }
    } else
#line 440
    if (sign) {
#line 440
      *qval = (short )(- (QP * (2 * val + 1) - 1));
    } else {
#line 440
      *qval = (short )(QP * (2 * val + 1) - 1);
    }
#line 442
    if (last) {
#line 444
      if (trace) {
        {
        {
#line 445
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"last\n------------------------------------------------------------------\n");
        }
        }
      }
#line 446
      return;
    }
#line 189
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 472 "getblk.c"
void get_sac_block(int comp , int ptype , int INTRA_AC_DC , int Mode ) 
{ 
  int position ;
  int TCOEF_index ;
  int symbol_word ;
  int last ;
  int QP ;
  int i ;
  int j ;
  short *qval ;
  short *bp ;
  RunCoef DCTcoef ;
  int intra ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 474
  position = 0;
#line 476
  last = 0;
#line 483
  bp = ld->block[comp];
#line 485
  i = ptype == 0;
#line 486
  if (Mode == 3) {
#line 486
    tmp = 1;
  } else
#line 486
  if (Mode == 4) {
#line 486
    tmp = 1;
  } else {
#line 486
    tmp = 0;
  }
#line 486
  intra = tmp;
  {
  {
#line 488
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 488
    if (! (! last)) {
#line 488
      goto while_break;
    }
    {
#line 491
    position ++;
    {
#line 493
    TCOEF_index = DecodeTCoef(position, intra);
    }
    }
#line 495
    if (TCOEF_index == 102) {
      {
      {
#line 497
      DCTcoef = Decode_Escape_Char(intra, & last);
      }
      }
#line 498
      if (trace) {
        {
        {
#line 499
        fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"ESC: ");
        }
        }
      }
    } else {
      {
#line 502
      symbol_word = tcoeftab[TCOEF_index];
      {
#line 504
      DCTcoef = vlc_word_decode(symbol_word, & last);
      }
      }
    }
#line 507
    if (trace) {
      {
      {
#line 509
      fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"val: %d, run: %d, sign: %d, last: %d\n",
              DCTcoef.val, DCTcoef.run, DCTcoef.sign, last);
      }
      }
    }
#line 512
    i += DCTcoef.run;
#line 513
    if (advanced_intra_coding) {
#line 513
      if (Mode == 3) {
#line 513
        goto _L;
      } else
#line 513
      if (Mode == 4) {
        _L: /* CIL Label */ 
        {
#line 517
        if (INTRA_AC_DC == 0) {
#line 517
          goto case_0;
        }
#line 520
        if (INTRA_AC_DC == 2) {
#line 520
          goto case_2;
        }
#line 523
        if (INTRA_AC_DC == 3) {
#line 523
          goto case_3;
        }
#line 526
        goto switch_default;
        case_0: /* CIL Label */ 
#line 518
        j = (int )zig_zag_scan[i];
#line 519
        goto switch_break;
        case_2: /* CIL Label */ 
#line 521
        j = (int )alternate_horizontal_scan[i];
#line 522
        goto switch_break;
        case_3: /* CIL Label */ 
#line 524
        j = (int )alternate_vertical_scan[i];
#line 525
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        {
#line 527
        printf((char const   */* __restrict  */)"Invalid Intra_Mode in Advanced Intra Coding");
        }
        {
#line 528
        exit(-1);
        }
        }
#line 529
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 533
        j = (int )zig_zag_scan[i];
      }
    } else {
#line 533
      j = (int )zig_zag_scan[i];
    }
#line 536
    qval = bp + j;
#line 538
    i ++;
#line 540
    if (comp >= 6) {
#line 541
      if (31 < bquant_tab[bquant] * quant >> 2) {
#line 541
        tmp___2 = 31;
      } else {
#line 541
        tmp___2 = bquant_tab[bquant] * quant >> 2;
      }
#line 541
      if (1 > tmp___2) {
#line 541
        QP = 1;
      } else {
#line 541
        if (31 < bquant_tab[bquant] * quant >> 2) {
#line 541
          tmp___1 = 31;
        } else {
#line 541
          tmp___1 = bquant_tab[bquant] * quant >> 2;
        }
#line 541
        QP = tmp___1;
      }
    } else {
#line 543
      QP = quant;
    }
#line 544
    if (advanced_intra_coding) {
#line 544
      if (Mode == 3) {
#line 544
        goto _L___1;
      } else
#line 544
      if (Mode == 4) {
        _L___1: /* CIL Label */ 
#line 547
        if (DCTcoef.sign) {
#line 547
          *qval = (short )(- (QP * (2 * DCTcoef.val)));
        } else {
#line 547
          *qval = (short )(QP * (2 * DCTcoef.val));
        }
      } else {
#line 544
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 551
    if (QP % 2 == 1) {
#line 552
      if (DCTcoef.sign) {
#line 552
        *qval = (short )(- (QP * (2 * DCTcoef.val + 1)));
      } else {
#line 552
        *qval = (short )(QP * (2 * DCTcoef.val + 1));
      }
    } else
#line 555
    if (DCTcoef.sign) {
#line 555
      *qval = (short )(- (QP * (2 * DCTcoef.val + 1) - 1));
    } else {
#line 555
      *qval = (short )(QP * (2 * DCTcoef.val + 1) - 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  return;
}
}
#line 579 "getblk.c"
RunCoef vlc_word_decode(int symbol_word , int *last ) 
{ 
  int sign_index ;
  RunCoef DCTcoef ;

  {
  {
#line 584
  *last = (symbol_word >> 12) & 1;
#line 586
  DCTcoef.run = (symbol_word >> 4) & 255;
#line 588
  DCTcoef.val = symbol_word & 15;
  {
#line 590
  sign_index = decode_a_symbol(cumf_SIGN);
  }
#line 592
  DCTcoef.sign = signtab[sign_index];
  }
#line 594
  return (DCTcoef);
}
}
#line 614 "getblk.c"
RunCoef Decode_Escape_Char(int intra , int *last ) 
{ 
  int last_index ;
  int run ;
  int run_index ;
  int level ;
  int level_index ;
  RunCoef DCTcoef ;
  char *__cil_tmp9 ;

  {
#line 619
  if (intra) {
    {
    {
#line 621
    last_index = decode_a_symbol(cumf_LAST_intra);
    }
#line 622
    *last = last_intratab[last_index];
    }
  } else {
    {
    {
#line 625
    last_index = decode_a_symbol(cumf_LAST);
    }
#line 626
    *last = lasttab[last_index];
    }
  }
#line 629
  if (intra) {
    {
    {
#line 630
    run_index = decode_a_symbol(cumf_RUN_intra);
    }
    }
  } else {
    {
    {
#line 632
    run_index = decode_a_symbol(cumf_RUN);
    }
    }
  }
#line 634
  run = runtab[run_index];
#line 638
  DCTcoef.run = run;
#line 640
  if (intra) {
    {
    {
#line 641
    level_index = decode_a_symbol(cumf_LEVEL_intra);
    }
    }
  } else {
    {
    {
#line 643
    level_index = decode_a_symbol(cumf_LEVEL);
    }
    }
  }
#line 645
  if (trace) {
    {
    {
#line 646
    fprintf((FILE */* __restrict  */)trace_file, (char const   */* __restrict  */)"level_idx: %d ",
            level_index);
    }
    }
  }
#line 648
  level = leveltab[level_index];
#line 650
  if (level > 128) {
#line 651
    level -= 256;
  }
#line 653
  if (level < 0) {
    {
#line 655
    DCTcoef.sign = 1;
    {
#line 656
    DCTcoef.val = abs(level);
    }
    }
  } else {
#line 659
    DCTcoef.sign = 0;
#line 660
    DCTcoef.val = level;
  }
#line 663
  return (DCTcoef);
}
}
#line 683 "getblk.c"
int DecodeTCoef(int position , int intra ) 
{ 
  int index ;

  {
  {
#line 689
  if (position == 1) {
#line 689
    goto case_1;
  }
#line 697
  if (position == 2) {
#line 697
    goto case_2;
  }
#line 705
  if (position == 3) {
#line 705
    goto case_3;
  }
#line 713
  goto switch_default;
  case_1: /* CIL Label */ 
#line 691
  if (intra) {
    {
    {
#line 692
    index = decode_a_symbol(cumf_TCOEF1_intra);
    }
    }
  } else {
    {
    {
#line 694
    index = decode_a_symbol(cumf_TCOEF1);
    }
    }
  }
#line 695
  goto switch_break;
  case_2: /* CIL Label */ 
#line 699
  if (intra) {
    {
    {
#line 700
    index = decode_a_symbol(cumf_TCOEF2_intra);
    }
    }
  } else {
    {
    {
#line 702
    index = decode_a_symbol(cumf_TCOEF2);
    }
    }
  }
#line 703
  goto switch_break;
  case_3: /* CIL Label */ 
#line 707
  if (intra) {
    {
    {
#line 708
    index = decode_a_symbol(cumf_TCOEF3_intra);
    }
    }
  } else {
    {
    {
#line 710
    index = decode_a_symbol(cumf_TCOEF3);
    }
    }
  }
#line 711
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 715
  if (intra) {
    {
    {
#line 716
    index = decode_a_symbol(cumf_TCOEFr_intra);
    }
    }
  } else {
    {
    {
#line 718
    index = decode_a_symbol(cumf_TCOEFr);
    }
    }
  }
#line 719
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 723
  return (index);
}
}
#line 82 "global.h"
void fillbfr(void) ;
#line 72 "getbits.c"
static unsigned int msk[33]  = 
#line 72 "getbits.c"
  {      0U,      1U,      3U,      7U, 
        15U,      31U,      63U,      127U, 
        255U,      511U,      1023U,      2047U, 
        4095U,      8191U,      16383U,      32767U, 
        65535U,      131071U,      262143U,      524287U, 
        1048575U,      2097151U,      4194303U,      8388607U, 
        16777215U,      33554431U,      67108863U,      134217727U, 
        268435455U,      536870911U,      1073741823U,      2147483647U, 
        4294967295U};
#line 88 "getbits.c"
void initbits(void) 
{ 


  {
#line 90
  ld->incnt = 0;
#line 91
  ld->rdptr = ld->rdbfr + 2048;
#line 92
  ld->bitcnt = 0;
#line 93
  return;
}
}
#line 106
extern int ( /* missing proto */  read)() ;
#line 95 "getbits.c"
void fillbfr(void) 
{ 
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 99
  ld->inbfr[0] = ld->inbfr[8];
#line 100
  ld->inbfr[1] = ld->inbfr[9];
#line 101
  ld->inbfr[2] = ld->inbfr[10];
#line 102
  ld->inbfr[3] = ld->inbfr[11];
#line 104
  if ((unsigned long )ld->rdptr >= (unsigned long )(ld->rdbfr + 2048)) {
    {
    {
#line 106
    l = read(ld->infile, ld->rdbfr, 2048);
    }
#line 107
    ld->rdptr = ld->rdbfr;
    }
#line 108
    if (l < 2048) {
#line 110
      if (l < 0) {
#line 111
        l = 0;
      }
      {
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 113
        if (! (l < 2048)) {
#line 113
          goto while_break;
        }
#line 115
        tmp = l;
#line 115
        l ++;
#line 115
        ld->rdbfr[tmp] = (unsigned char)0;
#line 116
        tmp___0 = l;
#line 116
        l ++;
#line 116
        ld->rdbfr[tmp___0] = (unsigned char)0;
#line 117
        tmp___1 = l;
#line 117
        l ++;
#line 117
        ld->rdbfr[tmp___1] = (unsigned char )((1 << 7) | (31 << 2));
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 121
  l = 0;
  {
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (l < 8)) {
#line 121
      goto while_break___0;
    }
#line 122
    ld->inbfr[l + 4] = *(ld->rdptr + l);
#line 121
    l ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  ld->rdptr += 8;
#line 125
  ld->incnt += 64;
#line 126
  return;
}
}
#line 131 "getbits.c"
unsigned int showbits(int n ) 
{ 
  unsigned char *v ;
  unsigned int b ;
  int c___0 ;

  {
#line 137
  if (ld->incnt < n) {
    {
    {
#line 138
    fillbfr();
    }
    }
  }
#line 140
  v = ld->inbfr + ((96 - ld->incnt) >> 3);
#line 141
  b = (unsigned int )(((((int )*(v + 0) << 24) | ((int )*(v + 1) << 16)) | ((int )*(v + 2) << 8)) | (int )*(v + 3));
#line 142
  c___0 = ((ld->incnt - 1) & 7) + 25;
#line 143
  return ((b >> (c___0 - n)) & msk[n]);
}
}
#line 149 "getbits.c"
unsigned int getbits1(void) 
{ 
  unsigned int tmp ;

  {
  {
  {
#line 151
  tmp = getbits(1);
  }
  }
#line 151
  return (tmp);
}
}
#line 157 "getbits.c"
void flushbits(int n ) 
{ 


  {
#line 160
  ld->bitcnt += n;
#line 161
  ld->incnt -= n;
#line 162
  if (ld->incnt < 0) {
    {
    {
#line 163
    fillbfr();
    }
    }
  }
#line 164
  return;
}
}
#line 169 "getbits.c"
unsigned int getbits(int n ) 
{ 
  unsigned int l ;

  {
  {
  {
#line 173
  l = showbits(n);
  }
  {
#line 174
  flushbits(n);
  }
  }
#line 176
  return (l);
}
}
#line 170 "global.h"
void ord4x4_dither_init(void) ;
#line 171
void ord4x4_dither_frame(unsigned char **src , unsigned char *dst ) ;
#line 70 "dither.c"
unsigned char pixel[256] ;
#line 72 "dither.c"
static unsigned char ytab[4352]  ;
#line 73 "dither.c"
static unsigned char uvtab[69134]  ;
#line 87 "dither.c"
void ord4x4_dither_init(void) 
{ 
  int i ;
  int j ;
  int v ;
  unsigned char ctab[288] ;
  void *__cil_tmp5 ;

  {
#line 93
  i = 0;
  {
  {
#line 93
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < 272)) {
#line 93
      goto while_break;
    }
#line 95
    v = (i - 8) >> 4;
#line 96
    if (v < 2) {
#line 97
      v = 2;
    } else
#line 98
    if (v > 14) {
#line 99
      v = 14;
    }
#line 100
    j = 0;
    {
    {
#line 100
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < 16)) {
#line 100
        goto while_break___0;
      }
#line 101
      ytab[16 * i + j] = pixel[(v << 4) + j];
#line 100
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 93
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  i = 0;
  {
  {
#line 104
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 104
    if (! (i < 288)) {
#line 104
      goto while_break___1;
    }
#line 106
    v = ((i + 48) - 128) >> 5;
#line 107
    if (v < 0) {
#line 108
      v = 0;
    } else
#line 109
    if (v > 3) {
#line 110
      v = 3;
    }
#line 111
    ctab[i] = (unsigned char )v;
#line 104
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 114
  i = 0;
  {
  {
#line 114
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 114
    if (! (i < 270)) {
#line 114
      goto while_break___2;
    }
#line 115
    j = 0;
    {
    {
#line 115
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 115
      if (! (j < 270)) {
#line 115
        goto while_break___3;
      }
#line 116
      uvtab[256 * i + j] = (unsigned char )(((((int )ctab[i + 16] << 6) | ((int )ctab[j + 16] << 4)) | ((int )ctab[i] << 2)) | (int )ctab[j]);
#line 115
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 114
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 121 "dither.c"
void ord4x4_dither_frame(unsigned char **src , unsigned char *dst ) 
{ 
  int i ;
  int j ;
  unsigned char *py ;
  unsigned char *pu ;
  unsigned char *pv ;
  int width ;
  int height ;
  int cwidth ;
  register unsigned int uv ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char *tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned char *tmp___41 ;
  unsigned char *tmp___42 ;
  unsigned char *tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;
  unsigned char *tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned char *tmp___48 ;
  unsigned char *tmp___49 ;
  unsigned char *tmp___50 ;
  unsigned char *tmp___51 ;
  unsigned char *tmp___52 ;
  unsigned char *tmp___53 ;
  unsigned char *tmp___54 ;
  unsigned char *tmp___55 ;
  unsigned char *tmp___56 ;
  unsigned char *tmp___57 ;
  unsigned char *tmp___58 ;
  unsigned char *tmp___59 ;
  unsigned char *tmp___60 ;
  unsigned char *tmp___61 ;
  unsigned char *tmp___62 ;
  unsigned char *tmp___63 ;
  unsigned char *tmp___64 ;
  unsigned char *tmp___65 ;
  unsigned char *tmp___66 ;
  unsigned char *tmp___67 ;
  unsigned char *tmp___68 ;
  unsigned char *tmp___69 ;
  unsigned char *tmp___70 ;
  unsigned char *tmp___71 ;
  unsigned char *tmp___72 ;
  unsigned char *tmp___73 ;
  unsigned char *tmp___74 ;
  unsigned char *tmp___75 ;
  unsigned char *tmp___76 ;
  unsigned char *tmp___77 ;
  unsigned char *tmp___78 ;
  unsigned char *tmp___79 ;
  unsigned char *tmp___80 ;
  unsigned char *tmp___81 ;
  unsigned char *tmp___82 ;
  unsigned char *tmp___83 ;
  unsigned char *tmp___84 ;
  unsigned char *tmp___85 ;
  unsigned char *tmp___86 ;
  unsigned char *tmp___87 ;
  unsigned char *tmp___88 ;
  unsigned char *tmp___89 ;
  unsigned char *tmp___90 ;
  unsigned char *tmp___91 ;
  unsigned char *tmp___92 ;
  unsigned char *tmp___93 ;
  unsigned char *tmp___94 ;

  {
#line 125
  py = *(src + 0);
#line 126
  pu = *(src + 1);
#line 127
  pv = *(src + 2);
#line 131
  if (expand) {
#line 133
    width = 2 * ref_coded_picture_width;
#line 134
    height = 2 * ref_coded_picture_height;
#line 135
    cwidth = 2 * ref_chrom_width;
  } else {
#line 138
    width = ref_coded_picture_width;
#line 139
    height = ref_coded_picture_height;
#line 140
    cwidth = ref_chrom_width;
  }
#line 143
  j = 0;
  {
  {
#line 143
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 143
    if (! (j < height)) {
#line 143
      goto while_break;
    }
#line 148
    i = 0;
    {
    {
#line 148
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! (i < width)) {
#line 148
        goto while_break___0;
      }
#line 150
      tmp = pu;
#line 150
      pu ++;
#line 150
      tmp___0 = pv;
#line 150
      pv ++;
#line 150
      uv = (unsigned int )uvtab[((int )*tmp << 8) | (int )*tmp___0];
#line 151
      tmp___1 = dst;
#line 151
      dst ++;
#line 151
      tmp___2 = py;
#line 151
      py ++;
#line 151
      *tmp___1 = ytab[(unsigned int )((int )*tmp___2 << 4) | (uv & 15U)];
#line 152
      tmp___3 = dst;
#line 152
      dst ++;
#line 152
      tmp___4 = py;
#line 152
      py ++;
#line 152
      *tmp___3 = ytab[(unsigned int )(((int )*tmp___4 + 8) << 4) | (uv >> 4)];
#line 153
      tmp___5 = pu;
#line 153
      pu ++;
#line 153
      tmp___6 = pv;
#line 153
      pv ++;
#line 153
      uv = (unsigned int )uvtab[(((int )*tmp___5 << 8) | (int )*tmp___6) + 1028];
#line 154
      tmp___7 = dst;
#line 154
      dst ++;
#line 154
      tmp___8 = py;
#line 154
      py ++;
#line 154
      *tmp___7 = ytab[(unsigned int )(((int )*tmp___8 + 2) << 4) | (uv & 15U)];
#line 155
      tmp___9 = dst;
#line 155
      dst ++;
#line 155
      tmp___10 = py;
#line 155
      py ++;
#line 155
      *tmp___9 = ytab[(unsigned int )(((int )*tmp___10 + 10) << 4) | (uv >> 4)];
#line 156
      tmp___11 = pu;
#line 156
      pu ++;
#line 156
      tmp___12 = pv;
#line 156
      pv ++;
#line 156
      uv = (unsigned int )uvtab[((int )*tmp___11 << 8) | (int )*tmp___12];
#line 157
      tmp___13 = dst;
#line 157
      dst ++;
#line 157
      tmp___14 = py;
#line 157
      py ++;
#line 157
      *tmp___13 = ytab[(unsigned int )((int )*tmp___14 << 4) | (uv & 15U)];
#line 158
      tmp___15 = dst;
#line 158
      dst ++;
#line 158
      tmp___16 = py;
#line 158
      py ++;
#line 158
      *tmp___15 = ytab[(unsigned int )(((int )*tmp___16 + 8) << 4) | (uv >> 4)];
#line 159
      tmp___17 = pu;
#line 159
      pu ++;
#line 159
      tmp___18 = pv;
#line 159
      pv ++;
#line 159
      uv = (unsigned int )uvtab[(((int )*tmp___17 << 8) | (int )*tmp___18) + 1028];
#line 160
      tmp___19 = dst;
#line 160
      dst ++;
#line 160
      tmp___20 = py;
#line 160
      py ++;
#line 160
      *tmp___19 = ytab[(unsigned int )(((int )*tmp___20 + 2) << 4) | (uv & 15U)];
#line 161
      tmp___21 = dst;
#line 161
      dst ++;
#line 161
      tmp___22 = py;
#line 161
      py ++;
#line 161
      *tmp___21 = ytab[(unsigned int )(((int )*tmp___22 + 10) << 4) | (uv >> 4)];
#line 148
      i += 8;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 164
    pu -= cwidth;
#line 165
    pv -= cwidth;
#line 168
    i = 0;
    {
    {
#line 168
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 168
      if (! (i < width)) {
#line 168
        goto while_break___1;
      }
#line 170
      tmp___23 = pu;
#line 170
      pu ++;
#line 170
      tmp___24 = pv;
#line 170
      pv ++;
#line 170
      uv = (unsigned int )uvtab[(((int )*tmp___23 << 8) | (int )*tmp___24) + 2056];
#line 171
      tmp___25 = dst;
#line 171
      dst ++;
#line 171
      tmp___26 = py;
#line 171
      py ++;
#line 171
      *tmp___25 = ytab[(unsigned int )(((int )*tmp___26 + 12) << 4) | (uv >> 4)];
#line 172
      tmp___27 = dst;
#line 172
      dst ++;
#line 172
      tmp___28 = py;
#line 172
      py ++;
#line 172
      *tmp___27 = ytab[(unsigned int )(((int )*tmp___28 + 4) << 4) | (uv & 15U)];
#line 173
      tmp___29 = pu;
#line 173
      pu ++;
#line 173
      tmp___30 = pv;
#line 173
      pv ++;
#line 173
      uv = (unsigned int )uvtab[(((int )*tmp___29 << 8) | (int )*tmp___30) + 3084];
#line 174
      tmp___31 = dst;
#line 174
      dst ++;
#line 174
      tmp___32 = py;
#line 174
      py ++;
#line 174
      *tmp___31 = ytab[(unsigned int )(((int )*tmp___32 + 14) << 4) | (uv >> 4)];
#line 175
      tmp___33 = dst;
#line 175
      dst ++;
#line 175
      tmp___34 = py;
#line 175
      py ++;
#line 175
      *tmp___33 = ytab[(unsigned int )(((int )*tmp___34 + 6) << 4) | (uv & 15U)];
#line 176
      tmp___35 = pu;
#line 176
      pu ++;
#line 176
      tmp___36 = pv;
#line 176
      pv ++;
#line 176
      uv = (unsigned int )uvtab[(((int )*tmp___35 << 8) | (int )*tmp___36) + 2056];
#line 177
      tmp___37 = dst;
#line 177
      dst ++;
#line 177
      tmp___38 = py;
#line 177
      py ++;
#line 177
      *tmp___37 = ytab[(unsigned int )(((int )*tmp___38 + 12) << 4) | (uv >> 4)];
#line 178
      tmp___39 = dst;
#line 178
      dst ++;
#line 178
      tmp___40 = py;
#line 178
      py ++;
#line 178
      *tmp___39 = ytab[(unsigned int )(((int )*tmp___40 + 4) << 4) | (uv & 15U)];
#line 179
      tmp___41 = pu;
#line 179
      pu ++;
#line 179
      tmp___42 = pv;
#line 179
      pv ++;
#line 179
      uv = (unsigned int )uvtab[(((int )*tmp___41 << 8) | (int )*tmp___42) + 3084];
#line 180
      tmp___43 = dst;
#line 180
      dst ++;
#line 180
      tmp___44 = py;
#line 180
      py ++;
#line 180
      *tmp___43 = ytab[(unsigned int )(((int )*tmp___44 + 14) << 4) | (uv >> 4)];
#line 181
      tmp___45 = dst;
#line 181
      dst ++;
#line 181
      tmp___46 = py;
#line 181
      py ++;
#line 181
      *tmp___45 = ytab[(unsigned int )(((int )*tmp___46 + 6) << 4) | (uv & 15U)];
#line 168
      i += 8;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 185
    i = 0;
    {
    {
#line 185
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 185
      if (! (i < width)) {
#line 185
        goto while_break___2;
      }
#line 187
      tmp___47 = pu;
#line 187
      pu ++;
#line 187
      tmp___48 = pv;
#line 187
      pv ++;
#line 187
      uv = (unsigned int )uvtab[(((int )*tmp___47 << 8) | (int )*tmp___48) + 1542];
#line 188
      tmp___49 = dst;
#line 188
      dst ++;
#line 188
      tmp___50 = py;
#line 188
      py ++;
#line 188
      *tmp___49 = ytab[(unsigned int )(((int )*tmp___50 + 3) << 4) | (uv & 15U)];
#line 189
      tmp___51 = dst;
#line 189
      dst ++;
#line 189
      tmp___52 = py;
#line 189
      py ++;
#line 189
      *tmp___51 = ytab[(unsigned int )(((int )*tmp___52 + 11) << 4) | (uv >> 4)];
#line 190
      tmp___53 = pu;
#line 190
      pu ++;
#line 190
      tmp___54 = pv;
#line 190
      pv ++;
#line 190
      uv = (unsigned int )uvtab[(((int )*tmp___53 << 8) | (int )*tmp___54) + 514];
#line 191
      tmp___55 = dst;
#line 191
      dst ++;
#line 191
      tmp___56 = py;
#line 191
      py ++;
#line 191
      *tmp___55 = ytab[(unsigned int )(((int )*tmp___56 + 1) << 4) | (uv & 15U)];
#line 192
      tmp___57 = dst;
#line 192
      dst ++;
#line 192
      tmp___58 = py;
#line 192
      py ++;
#line 192
      *tmp___57 = ytab[(unsigned int )(((int )*tmp___58 + 9) << 4) | (uv >> 4)];
#line 193
      tmp___59 = pu;
#line 193
      pu ++;
#line 193
      tmp___60 = pv;
#line 193
      pv ++;
#line 193
      uv = (unsigned int )uvtab[(((int )*tmp___59 << 8) | (int )*tmp___60) + 1542];
#line 194
      tmp___61 = dst;
#line 194
      dst ++;
#line 194
      tmp___62 = py;
#line 194
      py ++;
#line 194
      *tmp___61 = ytab[(unsigned int )(((int )*tmp___62 + 3) << 4) | (uv & 15U)];
#line 195
      tmp___63 = dst;
#line 195
      dst ++;
#line 195
      tmp___64 = py;
#line 195
      py ++;
#line 195
      *tmp___63 = ytab[(unsigned int )(((int )*tmp___64 + 11) << 4) | (uv >> 4)];
#line 196
      tmp___65 = pu;
#line 196
      pu ++;
#line 196
      tmp___66 = pv;
#line 196
      pv ++;
#line 196
      uv = (unsigned int )uvtab[(((int )*tmp___65 << 8) | (int )*tmp___66) + 514];
#line 197
      tmp___67 = dst;
#line 197
      dst ++;
#line 197
      tmp___68 = py;
#line 197
      py ++;
#line 197
      *tmp___67 = ytab[(unsigned int )(((int )*tmp___68 + 1) << 4) | (uv & 15U)];
#line 198
      tmp___69 = dst;
#line 198
      dst ++;
#line 198
      tmp___70 = py;
#line 198
      py ++;
#line 198
      *tmp___69 = ytab[(unsigned int )(((int )*tmp___70 + 9) << 4) | (uv >> 4)];
#line 185
      i += 8;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 201
    pu -= cwidth;
#line 202
    pv -= cwidth;
#line 205
    i = 0;
    {
    {
#line 205
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 205
      if (! (i < width)) {
#line 205
        goto while_break___3;
      }
#line 207
      tmp___71 = pu;
#line 207
      pu ++;
#line 207
      tmp___72 = pv;
#line 207
      pv ++;
#line 207
      uv = (unsigned int )uvtab[(((int )*tmp___71 << 8) | (int )*tmp___72) + 3598];
#line 208
      tmp___73 = dst;
#line 208
      dst ++;
#line 208
      tmp___74 = py;
#line 208
      py ++;
#line 208
      *tmp___73 = ytab[(unsigned int )(((int )*tmp___74 + 15) << 4) | (uv >> 4)];
#line 209
      tmp___75 = dst;
#line 209
      dst ++;
#line 209
      tmp___76 = py;
#line 209
      py ++;
#line 209
      *tmp___75 = ytab[(unsigned int )(((int )*tmp___76 + 7) << 4) | (uv & 15U)];
#line 210
      tmp___77 = pu;
#line 210
      pu ++;
#line 210
      tmp___78 = pv;
#line 210
      pv ++;
#line 210
      uv = (unsigned int )uvtab[(((int )*tmp___77 << 8) | (int )*tmp___78) + 2570];
#line 211
      tmp___79 = dst;
#line 211
      dst ++;
#line 211
      tmp___80 = py;
#line 211
      py ++;
#line 211
      *tmp___79 = ytab[(unsigned int )(((int )*tmp___80 + 13) << 4) | (uv >> 4)];
#line 212
      tmp___81 = dst;
#line 212
      dst ++;
#line 212
      tmp___82 = py;
#line 212
      py ++;
#line 212
      *tmp___81 = ytab[(unsigned int )(((int )*tmp___82 + 5) << 4) | (uv & 15U)];
#line 213
      tmp___83 = pu;
#line 213
      pu ++;
#line 213
      tmp___84 = pv;
#line 213
      pv ++;
#line 213
      uv = (unsigned int )uvtab[(((int )*tmp___83 << 8) | (int )*tmp___84) + 3598];
#line 214
      tmp___85 = dst;
#line 214
      dst ++;
#line 214
      tmp___86 = py;
#line 214
      py ++;
#line 214
      *tmp___85 = ytab[(unsigned int )(((int )*tmp___86 + 15) << 4) | (uv >> 4)];
#line 215
      tmp___87 = dst;
#line 215
      dst ++;
#line 215
      tmp___88 = py;
#line 215
      py ++;
#line 215
      *tmp___87 = ytab[(unsigned int )(((int )*tmp___88 + 7) << 4) | (uv & 15U)];
#line 216
      tmp___89 = pu;
#line 216
      pu ++;
#line 216
      tmp___90 = pv;
#line 216
      pv ++;
#line 216
      uv = (unsigned int )uvtab[(((int )*tmp___89 << 8) | (int )*tmp___90) + 2570];
#line 217
      tmp___91 = dst;
#line 217
      dst ++;
#line 217
      tmp___92 = py;
#line 217
      py ++;
#line 217
      *tmp___91 = ytab[(unsigned int )(((int )*tmp___92 + 13) << 4) | (uv >> 4)];
#line 218
      tmp___93 = dst;
#line 218
      dst ++;
#line 218
      tmp___94 = py;
#line 218
      py ++;
#line 218
      *tmp___93 = ytab[(unsigned int )(((int )*tmp___94 + 5) << 4) | (uv & 15U)];
#line 205
      i += 8;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 143
    j += 4;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 1464 "/usr/include/X11/Xlib.h"
extern XImage *XCreateImage(Display * , Visual * , unsigned int  , int  , int  , char * ,
                            unsigned int  , unsigned int  , int  , int  ) ;
#line 1514
extern Display *XOpenDisplay(char const   * ) ;
#line 1617
extern Colormap XCreateColormap(Display * , Window  , Visual * , int  ) ;
#line 1727
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 2036
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 2186
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2891
extern int XFlush(Display * ) ;
#line 2917
extern int XFreeColors(Display * , Colormap  , unsigned long * , int  , unsigned long  ) ;
#line 3131
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 3282
extern int XMapWindow(Display * , Window  ) ;
#line 3329
extern int XNextEvent(Display * , XEvent * ) ;
#line 3416
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 3702
extern int XSelectInput(Display * , Window  , long  ) ;
#line 4008
extern int XSetWindowColormap(Display * , Window  , Colormap  ) ;
#line 4068
extern int XSync(Display * , int  ) ;
#line 666 "/usr/include/X11/Xutil.h"
extern int XSetStandardProperties(Display * , Window  , char const   * , char const   * ,
                                  Pixmap  , char ** , int  , XSizeHints * ) ;
#line 75 "display.c"
static void display_image(XImage *ximage___0 , unsigned char *dithered_image___0 ) ;
#line 78 "display.c"
unsigned long wpixel[3]  ;
#line 79 "display.c"
static unsigned char *dithered_image  ;
#line 82 "display.c"
static Display *display  ;
#line 83 "display.c"
static Window window  ;
#line 84 "display.c"
static GC gc  ;
#line 85 "display.c"
static int dpy_depth  ;
#line 87 "display.c"
XImage *ximage  ;
#line 89 "display.c"
unsigned char pixel[256]  ;
#line 51 "/usr/include/sys/shm.h"
extern int shmctl(int __shmid , int __cmd , struct shmid_ds *__buf ) ;
#line 54
extern int shmget(key_t __key , size_t __size , int __shmflg ) ;
#line 57
extern void *shmat(int __shmid , void const   *__shmaddr , int __shmflg ) ;
#line 61
extern int shmdt(void const   *__shmaddr ) ;
#line 74 "/usr/include/X11/extensions/XShm.h"
extern int XShmQueryExtension(Display *dpy ) ;
#line 80
extern int XShmGetEventBase(Display *dpy ) ;
#line 101
extern int XShmAttach(Display * , XShmSegmentInfo * ) ;
#line 108
extern int XShmDetach(Display * , XShmSegmentInfo * ) ;
#line 115
extern int XShmPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                        int  , unsigned int  , unsigned int  , int  ) ;
#line 142
extern XImage *XShmCreateImage(Display * , Visual * , unsigned int  , int  , char * ,
                               XShmSegmentInfo * , unsigned int  , unsigned int  ) ;
#line 100 "display.c"
static int HandleXError(Display *dpy , XErrorEvent *event ) ;
#line 101
static void InstallXErrorHandler(void) ;
#line 102
static void DeInstallXErrorHandler(void) ;
#line 104 "display.c"
static int shmem_flag  ;
#line 105 "display.c"
static XShmSegmentInfo shminfo1  ;
#line 105 "display.c"
static XShmSegmentInfo shminfo2  ;
#line 106 "display.c"
static int gXErrorFlag  ;
#line 107 "display.c"
static int CompletionType  =    -1;
#line 109 "display.c"
static int HandleXError(Display *dpy , XErrorEvent *event ) 
{ 


  {
#line 113
  gXErrorFlag = 1;
#line 115
  return (0);
}
}
#line 118 "display.c"
static void InstallXErrorHandler(void) 
{ 


  {
  {
  {
#line 120
  XSetErrorHandler(& HandleXError);
  }
  {
#line 121
  XFlush(display);
  }
  }
#line 122
  return;
}
}
#line 124 "display.c"
static void DeInstallXErrorHandler(void) 
{ 


  {
  {
  {
#line 126
  XSetErrorHandler((int (*)(Display * , XErrorEvent * ))((void *)0));
  }
  {
#line 127
  XFlush(display);
  }
  }
#line 128
  return;
}
}
#line 134 "display.c"
void init_display(char *name ) 
{ 
  int crv ;
  int cbu ;
  int cgu ;
  int cgv ;
  int y ;
  int u ;
  int v ;
  int r ;
  int g ;
  int b ;
  int i ;
  char dummy ;
  int screen ;
  Visual *visual ;
  int dpy_class ;
  Colormap cmap ;
  int private ;
  XColor xcolor ;
  unsigned int fg ;
  unsigned int bg ;
  char *hello ;
  XSizeHints hint ;
  XEvent xev ;
  XSetWindowAttributes xswa ;
  unsigned long tmp_pixel ;
  unsigned int mask ;
  XWindowAttributes xwa ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  void *tmp___5 ;
  unsigned long tmp___6 ;
  void *tmp___7 ;
  XWindowAttributes xwa___0 ;
  int tmp___8 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
  {
#line 148
  hello = (char *)"H.263 Display";
  {
#line 155
  display = XOpenDisplay((char const   *)name);
  }
  }
#line 157
  if ((unsigned long )display == (unsigned long )((void *)0)) {
    {
    {
#line 158
    error((char *)"Can not open display\n");
    }
    }
  }
#line 160
  screen = ((_XPrivDisplay )display)->default_screen;
#line 162
  visual = (((_XPrivDisplay )display)->screens + screen)->root_visual;
#line 163
  dpy_depth = (((_XPrivDisplay )display)->screens + screen)->root_depth;
#line 164
  dpy_class = visual->class;
#line 166
  if (dpy_class == 4) {
#line 166
    if (! (dpy_depth == 32)) {
#line 166
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 166
  if (dpy_class == 4) {
#line 166
    if (! (dpy_depth == 24)) {
#line 166
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 166
  if (dpy_class == 4) {
#line 166
    if (! (dpy_depth == 16)) {
#line 166
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 166
  if (dpy_class == 3) {
#line 166
    if (! (dpy_depth == 8)) {
      {
      {
#line 170
      error((char *)"requires 8 bit PseudoColor or 16/24/32 bit TrueColor display\n");
      }
      }
    }
  } else {
    {
    {
#line 170
    error((char *)"requires 8 bit PseudoColor or 16/24/32 bit TrueColor display\n");
    }
    }
  }
#line 172
  if (dpy_class == 4) {
#line 172
    if (dpy_depth == 32) {
      {
      {
#line 173
      printf((char const   */* __restrict  */)"TrueColor : 32 bit colordepth\n");
      }
      }
    }
  }
#line 174
  if (dpy_class == 4) {
#line 174
    if (dpy_depth == 24) {
      {
      {
#line 175
      printf((char const   */* __restrict  */)"TrueColor : 24 bit colordepth\n");
      }
      }
    }
  }
#line 176
  if (dpy_class == 4) {
#line 176
    if (dpy_depth == 16) {
      {
      {
#line 177
      printf((char const   */* __restrict  */)"TrueColor : 16 bit colordepth\n");
      }
      }
    }
  }
#line 178
  if (dpy_class == 3) {
#line 178
    if (dpy_depth == 8) {
      {
      {
#line 179
      printf((char const   */* __restrict  */)"PseudoColor : 8 bit colordepth, 4x4 ordered dither\n");
      }
      }
    }
  }
#line 182
  if (expand) {
#line 184
    hint.width = 2 * horizontal_size;
#line 184
    hint.max_width = hint.width;
#line 184
    hint.min_width = hint.max_width;
#line 185
    hint.height = 2 * vertical_size;
#line 185
    hint.max_height = hint.height;
#line 185
    hint.min_height = hint.max_height;
  } else {
#line 188
    hint.width = horizontal_size;
#line 188
    hint.max_width = hint.width;
#line 188
    hint.min_width = hint.max_width;
#line 189
    hint.height = vertical_size;
#line 189
    hint.max_height = hint.height;
#line 189
    hint.min_height = hint.max_height;
  }
#line 192
  hint.flags = ((1L << 3) | (1L << 4)) | (1L << 5);
#line 196
  bg = (unsigned int )(((_XPrivDisplay )display)->screens + screen)->white_pixel;
#line 197
  fg = (unsigned int )(((_XPrivDisplay )display)->screens + screen)->black_pixel;
#line 200
  mask = (unsigned int )((1L << 1) | (1L << 3));
#line 201
  if (dpy_depth == 32) {
    {
#line 203
    mask = (unsigned int )((long )mask | (1L << 13));
    {
#line 204
    xswa.colormap = XCreateColormap(display, (((_XPrivDisplay )display)->screens + ((_XPrivDisplay )display)->default_screen)->root,
                                    visual, 0);
    }
    }
  } else
#line 201
  if (dpy_depth == 24) {
    {
#line 203
    mask = (unsigned int )((long )mask | (1L << 13));
    {
#line 204
    xswa.colormap = XCreateColormap(display, (((_XPrivDisplay )display)->screens + ((_XPrivDisplay )display)->default_screen)->root,
                                    visual, 0);
    }
    }
  } else
#line 201
  if (dpy_depth == 16) {
    {
#line 203
    mask = (unsigned int )((long )mask | (1L << 13));
    {
#line 204
    xswa.colormap = XCreateColormap(display, (((_XPrivDisplay )display)->screens + ((_XPrivDisplay )display)->default_screen)->root,
                                    visual, 0);
    }
    }
  }
  {
#line 207
  xswa.background_pixel = (unsigned long )bg;
#line 208
  xswa.border_pixel = (unsigned long )fg;
  {
#line 209
  window = XCreateWindow(display, (((_XPrivDisplay )display)->screens + ((_XPrivDisplay )display)->default_screen)->root,
                         hint.x, hint.y, (unsigned int )hint.width, (unsigned int )hint.height,
                         1U, dpy_depth, 1U, visual, (unsigned long )mask, & xswa);
  }
  {
#line 214
  XSelectInput(display, window, 1L << 17);
  }
  {
#line 218
  XSetStandardProperties(display, window, (char const   *)hello, (char const   *)hello,
                         (Pixmap )0L, (char **)((void *)0), 0, & hint);
  }
  {
#line 222
  XMapWindow(display, window);
  }
  }
  {
  {
#line 225
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 227
    XNextEvent(display, & xev);
    }
    }
#line 225
    if (! (xev.type != 19)) {
#line 225
      if (! (xev.xmap.event != window)) {
#line 225
        goto while_break;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 231
  XSelectInput(display, window, 0L);
  }
#line 235
  gc = (((_XPrivDisplay )display)->screens + screen)->default_gc;
  }
#line 237
  if (dpy_depth == 8) {
#line 241
    cmap = (((_XPrivDisplay )display)->screens + screen)->cmap;
#line 242
    private = 0;
#line 245
    crv = convmat[matrix_coefficients][0];
#line 246
    cbu = convmat[matrix_coefficients][1];
#line 247
    cgu = convmat[matrix_coefficients][2];
#line 248
    cgv = convmat[matrix_coefficients][3];
#line 264
    i = 32;
    {
    {
#line 264
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 264
      if (! (i < 240)) {
#line 264
        goto while_break___0;
      }
      {
#line 267
      y = 16 * ((i >> 4) & 15) + 8;
#line 268
      u = 32 * ((i >> 2) & 3) - 48;
#line 269
      v = 32 * (i & 3) - 48;
#line 271
      y = 76309 * (y - 16);
#line 273
      r = (int )*(clp + (((y + crv * v) + 32768) >> 16));
#line 274
      g = (int )*(clp + ((((y - cgu * u) - cgv * v) + 32768) >> 16));
#line 275
      b = (int )*(clp + (((y + cbu * u) + 32786) >> 16));
#line 278
      xcolor.red = (unsigned short )(r << 8);
#line 279
      xcolor.green = (unsigned short )(g << 8);
#line 280
      xcolor.blue = (unsigned short )(b << 8);
      {
#line 282
      tmp = XAllocColor(display, cmap, & xcolor);
      }
      }
#line 282
      if (tmp != 0) {
#line 283
        pixel[i] = (unsigned char )xcolor.pixel;
      } else {
#line 288
        if (private) {
          {
          {
#line 289
          error((char *)"Couldn\'t allocate private colormap");
          }
          }
        }
#line 291
        private = 1;
#line 293
        if (! quiet) {
          {
          {
#line 294
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Using private colormap (%d colors were available).\n",
                  i - 32);
          }
          }
        }
        {
        {
#line 298
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 298
          i --;
#line 298
          if (! (i >= 32)) {
#line 298
            goto while_break___1;
          }
          {
#line 300
          tmp_pixel = (unsigned long )pixel[i];
          {
#line 302
          XFreeColors(display, cmap, & tmp_pixel, 1, 0UL);
          }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        {
#line 309
        XGetWindowAttributes(display, window, & xwa);
        }
        {
#line 310
        cmap = XCreateColormap(display, window, xwa.visual, 0);
        }
        {
#line 311
        XSetWindowColormap(display, window, cmap);
        }
        }
      }
#line 264
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  {
#line 316
  tmp___0 = XShmQueryExtension(display);
  }
  }
#line 316
  if (tmp___0) {
#line 317
    shmem_flag = 1;
  } else {
#line 320
    shmem_flag = 0;
#line 321
    if (! quiet) {
      {
      {
#line 322
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shared memory not supported\nReverting to normal Xlib\n");
      }
      }
    }
  }
#line 326
  if (shmem_flag) {
    {
    {
#line 327
    tmp___1 = XShmGetEventBase(display);
    }
#line 327
    CompletionType = tmp___1;
    }
  }
  {
  {
#line 329
  InstallXErrorHandler();
  }
  }
#line 331
  if (shmem_flag) {
#line 334
    if (expand) {
      {
      {
#line 335
      ximage = XShmCreateImage(display, visual, (unsigned int )dpy_depth, 2, (char *)((void *)0),
                               & shminfo1, (unsigned int )(2 * coded_picture_width),
                               (unsigned int )(2 * coded_picture_height));
      }
      }
    } else {
      {
      {
#line 339
      ximage = XShmCreateImage(display, visual, (unsigned int )dpy_depth, 2, (char *)((void *)0),
                               & shminfo1, (unsigned int )coded_picture_width, (unsigned int )coded_picture_height);
      }
      }
    }
#line 346
    if ((unsigned long )ximage == (unsigned long )((void *)0)) {
#line 348
      if ((unsigned long )ximage != (unsigned long )((void *)0)) {
        {
        {
#line 349
        (*(ximage->f.destroy_image))(ximage);
        }
        }
      }
#line 350
      if (! quiet) {
        {
        {
#line 351
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shared memory error, disabling (Ximage error)\n");
        }
        }
      }
#line 352
      goto shmemerror;
    }
    {
    {
#line 356
    shminfo1.shmid = shmget(0, (size_t )(ximage->bytes_per_line * ximage->height),
                            1023);
    }
    }
#line 360
    if (shminfo1.shmid < 0) {
      {
      {
#line 362
      (*(ximage->f.destroy_image))(ximage);
      }
      }
#line 363
      if (! quiet) {
        {
        {
#line 364
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shared memory error, disabling (seg id error)\n");
        }
        }
      }
#line 365
      goto shmemerror;
    }
    {
    {
#line 367
    tmp___2 = shmat(shminfo1.shmid, (void const   *)0, 0);
    }
#line 367
    shminfo1.shmaddr = (char *)tmp___2;
    {
#line 368
    tmp___3 = shmat(shminfo2.shmid, (void const   *)0, 0);
    }
#line 368
    shminfo2.shmaddr = (char *)tmp___3;
    }
#line 370
    if ((unsigned long )shminfo1.shmaddr == (unsigned long )((char *)-1)) {
      {
      {
#line 372
      (*(ximage->f.destroy_image))(ximage);
      }
      }
#line 373
      if ((unsigned long )shminfo1.shmaddr != (unsigned long )((char *)-1)) {
        {
        {
#line 374
        shmdt((void const   *)shminfo1.shmaddr);
        }
        }
      }
#line 375
      if (! quiet) {
        {
        {
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shared memory error, disabling (address error)\n");
        }
        }
      }
#line 379
      goto shmemerror;
    }
    {
#line 381
    ximage->data = shminfo1.shmaddr;
#line 382
    dithered_image = (unsigned char *)ximage->data;
#line 383
    shminfo1.readOnly = 0;
    {
#line 384
    XShmAttach(display, & shminfo1);
    }
    {
#line 386
    XSync(display, 0);
    }
    }
#line 388
    if (gXErrorFlag) {
      {
      {
#line 391
      (*(ximage->f.destroy_image))(ximage);
      }
      {
#line 392
      shmdt((void const   *)shminfo1.shmaddr);
      }
      }
#line 393
      if (! quiet) {
        {
        {
#line 394
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shared memory error, disabling.\n");
        }
        }
      }
#line 395
      gXErrorFlag = 0;
#line 396
      goto shmemerror;
    } else {
      {
      {
#line 399
      shmctl(shminfo1.shmid, 0, (struct shmid_ds *)0);
      }
      }
    }
#line 402
    if (! quiet) {
      {
      {
#line 404
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sharing memory.\n");
      }
      }
    }
  } else {
    shmemerror: 
#line 409
    shmem_flag = 0;
#line 413
    if (expand) {
      {
      {
#line 415
      ximage = XCreateImage(display, visual, (unsigned int )dpy_depth, 2, 0, & dummy,
                            (unsigned int )(2 * coded_picture_width), (unsigned int )(2 * coded_picture_height),
                            8, 0);
      }
      }
#line 417
      if (dpy_depth > 8) {
#line 417
        tmp___4 = sizeof(int ) * 4UL;
      } else {
#line 417
        tmp___4 = sizeof(unsigned char );
      }
      {
      {
#line 417
      tmp___5 = malloc((size_t )(((unsigned long )(coded_picture_width * coded_picture_height) * tmp___4) * 4UL));
      }
#line 417
      dithered_image = (unsigned char *)tmp___5;
      }
#line 417
      if (! dithered_image) {
        {
        {
#line 421
        error((char *)"malloc failed");
        }
        }
      }
    } else {
      {
      {
#line 424
      ximage = XCreateImage(display, visual, (unsigned int )dpy_depth, 2, 0, & dummy,
                            (unsigned int )coded_picture_width, (unsigned int )coded_picture_height,
                            8, 0);
      }
      }
#line 426
      if (dpy_depth > 8) {
#line 426
        tmp___6 = sizeof(int );
      } else {
#line 426
        tmp___6 = sizeof(unsigned char );
      }
      {
      {
#line 426
      tmp___7 = malloc((size_t )((unsigned long )(coded_picture_width * coded_picture_height) * tmp___6));
      }
#line 426
      dithered_image = (unsigned char *)tmp___7;
      }
#line 426
      if (! dithered_image) {
        {
        {
#line 430
        error((char *)"malloc failed");
        }
        }
      }
    }
  }
  {
  {
#line 436
  DeInstallXErrorHandler();
  }
  }
#line 440
  if (dpy_depth == 32) {
#line 440
    goto _L___2;
  } else
#line 440
  if (dpy_depth == 24) {
#line 440
    goto _L___2;
  } else
#line 440
  if (dpy_depth == 16) {
    _L___2: /* CIL Label */ 
    {
    {
#line 444
    XGetWindowAttributes(display, window, & xwa___0);
    }
#line 447
    wpixel[0] = (xwa___0.visual)->red_mask;
#line 448
    wpixel[1] = (xwa___0.visual)->green_mask;
#line 449
    wpixel[2] = (xwa___0.visual)->blue_mask;
    }
#line 456
    if (dpy_depth == 24) {
#line 456
      tmp___8 = 1;
    } else
#line 456
    if (dpy_depth == 32) {
#line 456
      tmp___8 = 1;
    } else {
#line 456
      tmp___8 = 0;
    }
    {
    {
#line 456
    InitColorDither(tmp___8);
    }
    }
  } else {
    {
    {
#line 459
    ord4x4_dither_init();
    }
    }
  }
#line 461
  return;
}
}
#line 463 "display.c"
void exit_display(void) 
{ 


  {
#line 466
  if (shmem_flag) {
    {
    {
#line 468
    XShmDetach(display, & shminfo1);
    }
    {
#line 469
    (*(ximage->f.destroy_image))(ximage);
    }
    {
#line 470
    shmdt((void const   *)shminfo1.shmaddr);
    }
    }
  }
#line 473
  return;
}
}
#line 475 "display.c"
static void display_image(XImage *ximage___0 , unsigned char *dithered_image___0 ) 
{ 
  int t ;
  XEvent xev ;

  {
#line 479
  t = 1;
#line 486
  if ((int )*((char *)(& t)) == 1) {
#line 488
    ximage___0->byte_order = 0;
#line 489
    ximage___0->bitmap_bit_order = 0;
  } else {
#line 492
    ximage___0->byte_order = 1;
#line 493
    ximage___0->bitmap_bit_order = 1;
  }
#line 498
  if (shmem_flag) {
    {
    {
#line 500
    XShmPutImage(display, window, gc, ximage___0, 0, 0, 0, 0, (unsigned int )ximage___0->width,
                 (unsigned int )ximage___0->height, 1);
    }
    {
#line 502
    XFlush(display);
    }
    }
    {
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 508
      XNextEvent(display, & xev);
      }
      }
#line 509
      if (xev.type == CompletionType) {
#line 510
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 515
    ximage___0->data = (char *)dithered_image___0;
    {
#line 516
    XPutImage(display, window, gc, ximage___0, 0, 0, 0, 0, (unsigned int )ximage___0->width,
              (unsigned int )ximage___0->height);
    }
    }
  }
#line 518
  return;
}
}
#line 521 "display.c"
void dither(unsigned char **src ) 
{ 


  {
#line 524
  if (dpy_depth == 24) {
#line 524
    goto _L;
  } else
#line 524
  if (dpy_depth == 32) {
    _L: /* CIL Label */ 
#line 526
    if (ximage->bits_per_pixel == 24) {
      {
      {
#line 527
      ConvertYUVtoRGB(*(src + 0), *(src + 1), *(src + 2), dithered_image, coded_picture_width,
                      coded_picture_height);
      }
      }
    } else {
      {
      {
#line 531
      Color32DitherImage(src, dithered_image);
      }
      }
    }
  } else
#line 532
  if (dpy_depth == 16) {
    {
    {
#line 534
    Color16DitherImage(src, dithered_image);
    }
    }
  } else {
    {
    {
#line 537
    ord4x4_dither_frame(src, dithered_image);
    }
    }
  }
  {
  {
#line 540
  display_image(ximage, dithered_image);
  }
  }
#line 541
  return;
}
}
