/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 214 "/usr/lib/gcc/i486-linux-gnu/4.2.4/include/stddef.h"
typedef unsigned int size_t;
#line 31 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 19 "./buffer.h"
struct __anonstruct_Buffer_70 {
   u_char *buf ;
   u_int alloc ;
   u_int offset ;
   u_int end ;
};
#line 19 "./buffer.h"
typedef struct __anonstruct_Buffer_70 Buffer;
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 46 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
struct Authctxt;
#line 46 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
typedef struct Authctxt Authctxt;
#line 50 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
struct Authctxt {
   int success ;
   int postponed ;
   int valid ;
   int attempt ;
   int failures ;
   int force_pwchange ;
   char *user ;
   char *service ;
   struct passwd *pw ;
   char *style ;
   void *kbdintctxt ;
   Buffer *loginmsg ;
   void *methoddata ;
};
#line 42 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/bits/types.h"
typedef __u_quad_t __ino64_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 170 "/usr/include/bits/types.h"
typedef __quad_t __blkcnt64_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 38 "/usr/include/bits/utmp.h"
struct lastlog {
   __time_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 150 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 167 "/usr/include/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   __uint32_t __ss_align ;
   char __ss_padding[128UL - 2UL * sizeof(__uint32_t )] ;
};
#line 88 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 88
struct sockaddr_in6;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 93 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 137 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 138 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 194 "/usr/include/netinet/in.h"
union __anonunion_in6_u_62 {
   uint8_t u6_addr8[16] ;
   uint16_t u6_addr16[8] ;
   uint32_t u6_addr32[4] ;
};
#line 194 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_in6_u_62 in6_u ;
};
#line 217 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 231 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 48 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.h"
union login_netinfo {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_storage sa_storage ;
};
#line 68 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.h"
struct logininfo {
   char progname[64] ;
   int progname_null ;
   short type ;
   int pid ;
   int uid ;
   char line[64] ;
   char username[128] ;
   char hostname[256] ;
   int exit ;
   int termination ;
   unsigned int tv_sec ;
   unsigned int tv_usec ;
   union login_netinfo hostaddr ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 107 "/usr/include/openssl/ossl_typ.h"
struct bignum_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_st BIGNUM;
#line 108
struct bignum_ctx;
#line 108 "/usr/include/openssl/ossl_typ.h"
typedef struct bignum_ctx BN_CTX;
#line 109
struct bn_blinding_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 110
struct bn_mont_ctx_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 112
struct bn_gencb_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct bn_gencb_st BN_GENCB;
#line 118
struct env_md_st;
#line 118 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 119
struct env_md_ctx_st;
#line 119 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 122
struct dh_st;
#line 122 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_st DH;
#line 123
struct dh_method;
#line 123 "/usr/include/openssl/ossl_typ.h"
typedef struct dh_method DH_METHOD;
#line 125
struct dsa_st;
#line 125 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_st DSA;
#line 126
struct dsa_method;
#line 126 "/usr/include/openssl/ossl_typ.h"
typedef struct dsa_method DSA_METHOD;
#line 128
struct rsa_st;
#line 128 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_st RSA;
#line 129
struct rsa_meth_st;
#line 129 "/usr/include/openssl/ossl_typ.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 154
struct engine_st;
#line 154 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 165
struct crypto_ex_data_st;
#line 165 "/usr/include/openssl/ossl_typ.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 283 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 288 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 299 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 323 "/usr/include/openssl/bn.h"
union __anonunion_cb_72 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
#line 323 "/usr/include/openssl/bn.h"
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_72 cb ;
};
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
#line 128 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
#line 97 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
#line 115 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 108 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 108 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 114 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
#line 141 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
struct Key;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
typedef struct Key Key;
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
};
#line 223 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 290 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/cipher.h"
struct Cipher;
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/cipher.h"
typedef struct Cipher Cipher;
#line 71 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
struct Kex;
#line 71 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
typedef struct Kex Kex;
#line 72
struct Mac;
#line 72 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
typedef struct Mac Mac;
#line 73
struct Comp;
#line 73 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
typedef struct Comp Comp;
#line 74
struct Enc;
#line 74 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
typedef struct Enc Enc;
#line 75
struct Newkeys;
#line 75 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
typedef struct Newkeys Newkeys;
#line 77 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
struct Enc {
   char *name ;
   Cipher *cipher ;
   int enabled ;
   u_int key_len ;
   u_int block_size ;
   u_char *key ;
   u_char *iv ;
};
#line 86 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
struct Mac {
   char *name ;
   int enabled ;
   EVP_MD const   *md ;
   u_int mac_len ;
   u_char *key ;
   u_int key_len ;
};
#line 94 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
struct Comp {
   int type ;
   int enabled ;
   char *name ;
};
#line 99 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
struct Newkeys {
   Enc enc ;
   Mac mac ;
   Comp comp ;
};
#line 104 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
struct Kex {
   u_char *session_id ;
   u_int session_id_len ;
   Newkeys *newkeys[2] ;
   u_int we_need ;
   int server ;
   char *name ;
   int hostkey_type ;
   int kex_type ;
   Buffer my ;
   Buffer peer ;
   int done ;
   int flags ;
   EVP_MD const   *evp_md ;
   char *client_version_string ;
   char *server_version_string ;
   int (*verify_host_key)(Key * ) ;
   Key *(*load_host_key)(int  ) ;
   int (*host_key_index)(Key * ) ;
   void (*kex[3])(Kex * ) ;
};
#line 34 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 204 "/usr/include/sys/types.h"
typedef unsigned long u_int64_t;
#line 328 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 330 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 331 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 337 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 346 "/usr/include/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 1387 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.h"
enum monitor_reqtype {
    MONITOR_REQ_MODULI = 0,
    MONITOR_ANS_MODULI = 1,
    MONITOR_REQ_FREE = 2,
    MONITOR_REQ_AUTHSERV = 3,
    MONITOR_REQ_SIGN = 4,
    MONITOR_ANS_SIGN = 5,
    MONITOR_REQ_PWNAM = 6,
    MONITOR_ANS_PWNAM = 7,
    MONITOR_REQ_AUTH2_READ_BANNER = 8,
    MONITOR_ANS_AUTH2_READ_BANNER = 9,
    MONITOR_REQ_AUTHPASSWORD = 10,
    MONITOR_ANS_AUTHPASSWORD = 11,
    MONITOR_REQ_BSDAUTHQUERY = 12,
    MONITOR_ANS_BSDAUTHQUERY = 13,
    MONITOR_REQ_BSDAUTHRESPOND = 14,
    MONITOR_ANS_BSDAUTHRESPOND = 15,
    MONITOR_REQ_SKEYQUERY = 16,
    MONITOR_ANS_SKEYQUERY = 17,
    MONITOR_REQ_SKEYRESPOND = 18,
    MONITOR_ANS_SKEYRESPOND = 19,
    MONITOR_REQ_KEYALLOWED = 20,
    MONITOR_ANS_KEYALLOWED = 21,
    MONITOR_REQ_KEYVERIFY = 22,
    MONITOR_ANS_KEYVERIFY = 23,
    MONITOR_REQ_KEYEXPORT = 24,
    MONITOR_REQ_PTY = 25,
    MONITOR_ANS_PTY = 26,
    MONITOR_REQ_PTYCLEANUP = 27,
    MONITOR_REQ_SESSKEY = 28,
    MONITOR_ANS_SESSKEY = 29,
    MONITOR_REQ_SESSID = 30,
    MONITOR_REQ_RSAKEYALLOWED = 31,
    MONITOR_ANS_RSAKEYALLOWED = 32,
    MONITOR_REQ_RSACHALLENGE = 33,
    MONITOR_ANS_RSACHALLENGE = 34,
    MONITOR_REQ_RSARESPONSE = 35,
    MONITOR_ANS_RSARESPONSE = 36,
    MONITOR_REQ_GSSSETUP = 37,
    MONITOR_ANS_GSSSETUP = 38,
    MONITOR_REQ_GSSSTEP = 39,
    MONITOR_ANS_GSSSTEP = 40,
    MONITOR_REQ_GSSUSEROK = 41,
    MONITOR_ANS_GSSUSEROK = 42,
    MONITOR_REQ_GSSCHECKMIC = 43,
    MONITOR_ANS_GSSCHECKMIC = 44,
    MONITOR_REQ_PAM_START = 45,
    MONITOR_REQ_PAM_ACCOUNT = 46,
    MONITOR_ANS_PAM_ACCOUNT = 47,
    MONITOR_REQ_PAM_INIT_CTX = 48,
    MONITOR_ANS_PAM_INIT_CTX = 49,
    MONITOR_REQ_PAM_QUERY = 50,
    MONITOR_ANS_PAM_QUERY = 51,
    MONITOR_REQ_PAM_RESPOND = 52,
    MONITOR_ANS_PAM_RESPOND = 53,
    MONITOR_REQ_PAM_FREE_CTX = 54,
    MONITOR_ANS_PAM_FREE_CTX = 55,
    MONITOR_REQ_AUDIT_EVENT = 56,
    MONITOR_REQ_AUDIT_COMMAND = 57,
    MONITOR_REQ_TERM = 58
} ;
#line 66
struct mm_master;
#line 67 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.h"
struct monitor {
   int m_recvfd ;
   int m_sendfd ;
   struct mm_master *m_zback ;
   struct mm_master *m_zlib ;
   struct Kex **m_pkex ;
   pid_t m_pid ;
};
#line 36 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.h"
enum mm_keytype {
    MM_NOKEY = 0,
    MM_HOSTKEY = 1,
    MM_USERKEY = 2,
    MM_RSAHOSTKEY = 3,
    MM_RSAUSERKEY = 4
} ;
#line 83
struct Session;
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/session.h"
struct __anonstruct_env_79 {
   char *name ;
   char *val ;
};
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/session.h"
struct Session {
   int used ;
   int self ;
   struct passwd *pw ;
   Authctxt *authctxt ;
   pid_t pid ;
   char *term ;
   int ptyfd ;
   int ttyfd ;
   int ptymaster ;
   u_int row ;
   u_int col ;
   u_int xpixel ;
   u_int ypixel ;
   char tty[64] ;
   u_int display_number ;
   char *display ;
   u_int screen ;
   char *auth_display ;
   char *auth_proto ;
   char *auth_data ;
   int single_connection ;
   int chanid ;
   int *x11_chanids ;
   int is_subsystem ;
   u_int num_env ;
   struct __anonstruct_env_79 *env ;
};
#line 32 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 538 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 93 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/bsd-misc.h"
typedef void (*mysig_t)(int  );
#line 30 "/home/pronto/abs/test-suite/openssh-4.3p2/session.h"
typedef struct Session Session;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
enum __anonenum_SyslogFacility_77 {
    SYSLOG_FACILITY_DAEMON = 0,
    SYSLOG_FACILITY_USER = 1,
    SYSLOG_FACILITY_AUTH = 2,
    SYSLOG_FACILITY_AUTHPRIV = 3,
    SYSLOG_FACILITY_LOCAL0 = 4,
    SYSLOG_FACILITY_LOCAL1 = 5,
    SYSLOG_FACILITY_LOCAL2 = 6,
    SYSLOG_FACILITY_LOCAL3 = 7,
    SYSLOG_FACILITY_LOCAL4 = 8,
    SYSLOG_FACILITY_LOCAL5 = 9,
    SYSLOG_FACILITY_LOCAL6 = 10,
    SYSLOG_FACILITY_LOCAL7 = 11,
    SYSLOG_FACILITY_NOT_SET = -1
} ;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
typedef enum __anonenum_SyslogFacility_77 SyslogFacility;
#line 39
enum __anonenum_LogLevel_78 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 39 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
typedef enum __anonenum_LogLevel_78 LogLevel;
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.h"
struct __anonstruct_ServerOptions_79 {
   u_int num_ports ;
   u_int ports_from_cmdline ;
   u_short ports[256] ;
   char *listen_addr ;
   struct addrinfo *listen_addrs ;
   int address_family ;
   char *host_key_files[256] ;
   int num_host_key_files ;
   char *pid_file ;
   int server_key_bits ;
   int login_grace_time ;
   int key_regeneration_time ;
   int permit_root_login ;
   int ignore_rhosts ;
   int ignore_user_known_hosts ;
   int print_motd ;
   int print_lastlog ;
   int x11_forwarding ;
   int x11_display_offset ;
   int x11_use_localhost ;
   char *xauth_location ;
   int strict_modes ;
   int tcp_keep_alive ;
   char *ciphers ;
   char *macs ;
   int protocol ;
   int gateway_ports ;
   SyslogFacility log_facility ;
   LogLevel log_level ;
   int rhosts_rsa_authentication ;
   int hostbased_authentication ;
   int hostbased_uses_name_from_packet_only ;
   int rsa_authentication ;
   int pubkey_authentication ;
   int kerberos_authentication ;
   int kerberos_or_local_passwd ;
   int kerberos_ticket_cleanup ;
   int kerberos_get_afs_token ;
   int gss_authentication ;
   int gss_cleanup_creds ;
   int password_authentication ;
   int kbd_interactive_authentication ;
   int challenge_response_authentication ;
   int permit_empty_passwd ;
   int permit_user_env ;
   int use_login ;
   int compression ;
   int allow_tcp_forwarding ;
   u_int num_allow_users ;
   char *allow_users[256] ;
   u_int num_deny_users ;
   char *deny_users[256] ;
   u_int num_allow_groups ;
   char *allow_groups[256] ;
   u_int num_deny_groups ;
   char *deny_groups[256] ;
   u_int num_subsystems ;
   char *subsystem_name[256] ;
   char *subsystem_command[256] ;
   u_int num_accept_env ;
   char *accept_env[256] ;
   int max_startups_begin ;
   int max_startups_rate ;
   int max_startups ;
   int max_authtries ;
   char *banner ;
   int use_dns ;
   int client_alive_interval ;
   int client_alive_count_max ;
   char *authorized_keys_file ;
   char *authorized_keys_file2 ;
   int use_pam ;
   int permit_tun ;
};
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.h"
typedef struct __anonstruct_ServerOptions_79 ServerOptions;
#line 84 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.h"
struct mon_table;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.h"
struct __anonstruct_next_80 {
   struct mm_share *rbe_left ;
   struct mm_share *rbe_right ;
   struct mm_share *rbe_parent ;
   int rbe_color ;
};
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.h"
struct mm_share {
   struct __anonstruct_next_80 next ;
   void *address ;
   size_t size ;
};
#line 38 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.h"
struct mmtree {
   struct mm_share *rbh_root ;
};
#line 38 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.h"
struct mm_master {
   struct mmtree rb_free ;
   struct mmtree rb_allocated ;
   void *address ;
   size_t size ;
   struct mm_master *mmalloc ;
   int write ;
   int read ;
};
#line 86 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct __anonstruct_child_state_81 {
   z_stream incoming ;
   z_stream outgoing ;
   u_char *keyin ;
   u_int keyinlen ;
   u_char *keyout ;
   u_int keyoutlen ;
   u_char *ivin ;
   u_int ivinlen ;
   u_char *ivout ;
   u_int ivoutlen ;
   u_char *ssh1key ;
   u_int ssh1keylen ;
   int ssh1cipher ;
   int ssh1protoflags ;
   u_char *input ;
   u_int ilen ;
   u_char *output ;
   u_int olen ;
};
#line 165 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct mon_table {
   enum monitor_reqtype type ;
   int flags ;
   int (*f)(int  , Buffer * ) ;
};
#line 1510 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
union __anonunion___u_82 {
   int __in ;
   int __i ;
};
#line 1510 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
union __anonunion___u_83 {
   int __in ;
   int __i ;
};
#line 1510 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
union __anonunion___u_84 {
   int __in ;
   int __i ;
};
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 39 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
enum fp_type {
    SSH_FP_SHA1 = 0,
    SSH_FP_MD5 = 1
} ;
#line 43
enum fp_rep {
    SSH_FP_HEX = 0,
    SSH_FP_BUBBLEBABBLE = 1
} ;
#line 47 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
struct Authmethod;
#line 47 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
typedef struct Authmethod Authmethod;
#line 82 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
struct Authmethod {
   char *name ;
   int (*userauth)(Authctxt *authctxt ) ;
   int *enabled ;
};
#line 17 "/home/pronto/abs/test-suite/openssh-4.3p2/hostfile.h"
enum __anonenum_HostStatus_77 {
    HOST_OK = 0,
    HOST_NEW = 1,
    HOST_CHANGED = 2,
    HOST_FOUND = 3
} ;
#line 17 "/home/pronto/abs/test-suite/openssh-4.3p2/hostfile.h"
typedef enum __anonenum_HostStatus_77 HostStatus;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 48 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
struct KbdintDevice;
#line 48 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
typedef struct KbdintDevice KbdintDevice;
#line 95 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
struct KbdintDevice {
   char const   *name ;
   void *(*init_ctx)(Authctxt * ) ;
   int (*query)(void *ctx , char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                u_int **echo_on ) ;
   int (*respond)(void *ctx , u_int numresp , char **responses ) ;
   void (*free_ctx)(void *ctx ) ;
};
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/dispatch.h"
typedef void dispatch_fn(int  , u_int32_t  , void * );
#line 69 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
struct KbdintAuthctxt;
#line 69 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
typedef struct KbdintAuthctxt KbdintAuthctxt;
#line 70 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
struct KbdintAuthctxt {
   char *devices ;
   void *ctxt ;
   KbdintDevice *device ;
   u_int nreq ;
};
#line 88 "/usr/include/sys/socket.h"
struct sockaddr_un;
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 62 "./channels.h"
struct Channel;
#line 63 "./channels.h"
typedef struct Channel Channel;
#line 65 "./channels.h"
typedef void channel_callback_fn(int  , void * );
#line 66 "./channels.h"
typedef int channel_infilter_fn(struct Channel * , char * , int  );
#line 67 "./channels.h"
typedef u_char *channel_outfilter_fn(struct Channel * , u_char ** , u_int * );
#line 69 "./channels.h"
struct Channel {
   int type ;
   int self ;
   int remote_id ;
   u_int istate ;
   u_int ostate ;
   int flags ;
   int rfd ;
   int wfd ;
   int efd ;
   int sock ;
   int ctl_fd ;
   int isatty ;
   int wfd_isatty ;
   int client_tty ;
   int force_drain ;
   int delayed ;
   Buffer input ;
   Buffer output ;
   Buffer extended ;
   char path[256] ;
   int listening_port ;
   int host_port ;
   char *remote_name ;
   u_int remote_window ;
   u_int remote_maxpacket ;
   u_int local_window ;
   u_int local_window_max ;
   u_int local_consumed ;
   u_int local_maxpacket ;
   int extended_usage ;
   int single_connection ;
   char *ctype ;
   channel_callback_fn *confirm ;
   void *confirm_ctx ;
   channel_callback_fn *detach_user ;
   int detach_close ;
   channel_infilter_fn *input_filter ;
   channel_outfilter_fn *output_filter ;
   int datagram ;
};
#line 19 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.h"
struct envstring {
   struct envstring *next ;
   char *s ;
};
#line 2159 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
union __anonunion___u_80 {
   int __in ;
   int __i ;
};
#line 2163 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
union __anonunion___u_81 {
   int __in ;
   int __i ;
};
#line 2165 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
union __anonunion___u_82___0 {
   int __in ;
   int __i ;
};
#line 2161 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
union __anonunion___u_83___0 {
   int __in ;
   int __i ;
};
#line 2157 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
union __anonunion___u_84___0 {
   int __in ;
   int __i ;
};
#line 42 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
struct AuthMethod1 {
   int type ;
   char *name ;
   int *enabled ;
   int (*method)(Authctxt * , char * , size_t  ) ;
};
#line 43 "/usr/lib/gcc/i486-linux-gnu/4.2.4/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i486-linux-gnu/4.2.4/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 24 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_8 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_9 {
   __fd_mask fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_9 fd_set;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 709 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
union __anonunion___u_81___0 {
   int __in ;
   int __i ;
};
#line 711 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
union __anonunion___u_82___1 {
   int __in ;
   int __i ;
};
#line 707 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
union __anonunion___u_83___1 {
   int __in ;
   int __i ;
};
#line 733 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
union __anonunion___u_84___1 {
   int __in ;
   int __i ;
};
#line 731 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
union __anonunion___u_85 {
   int __in ;
   int __i ;
};
#line 252 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
enum __anonenum_ServerOpCodes_78 {
    sBadOption = 0,
    sUsePAM = 1,
    sPort = 2,
    sHostKeyFile = 3,
    sServerKeyBits = 4,
    sLoginGraceTime = 5,
    sKeyRegenerationTime = 6,
    sPermitRootLogin = 7,
    sLogFacility = 8,
    sLogLevel = 9,
    sRhostsRSAAuthentication = 10,
    sRSAAuthentication = 11,
    sKerberosAuthentication = 12,
    sKerberosOrLocalPasswd = 13,
    sKerberosTicketCleanup = 14,
    sKerberosGetAFSToken = 15,
    sKerberosTgtPassing = 16,
    sChallengeResponseAuthentication = 17,
    sPasswordAuthentication = 18,
    sKbdInteractiveAuthentication = 19,
    sListenAddress = 20,
    sAddressFamily = 21,
    sPrintMotd = 22,
    sPrintLastLog = 23,
    sIgnoreRhosts = 24,
    sX11Forwarding = 25,
    sX11DisplayOffset = 26,
    sX11UseLocalhost = 27,
    sStrictModes = 28,
    sEmptyPasswd = 29,
    sTCPKeepAlive = 30,
    sPermitUserEnvironment = 31,
    sUseLogin = 32,
    sAllowTcpForwarding = 33,
    sCompression = 34,
    sAllowUsers = 35,
    sDenyUsers = 36,
    sAllowGroups = 37,
    sDenyGroups = 38,
    sIgnoreUserKnownHosts = 39,
    sCiphers = 40,
    sMacs = 41,
    sProtocol = 42,
    sPidFile = 43,
    sGatewayPorts = 44,
    sPubkeyAuthentication = 45,
    sXAuthLocation = 46,
    sSubsystem = 47,
    sMaxStartups = 48,
    sMaxAuthTries = 49,
    sBanner = 50,
    sUseDNS = 51,
    sHostbasedAuthentication = 52,
    sHostbasedUsesNameFromPacketOnly = 53,
    sClientAliveInterval = 54,
    sClientAliveCountMax = 55,
    sAuthorizedKeysFile = 56,
    sAuthorizedKeysFile2 = 57,
    sGssAuthentication = 58,
    sGssCleanupCreds = 59,
    sAcceptEnv = 60,
    sPermitTunnel = 61,
    sUsePrivilegeSeparation = 62,
    sDeprecated = 63,
    sUnsupported = 64
} ;
#line 252 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
typedef enum __anonenum_ServerOpCodes_78 ServerOpCodes;
#line 282 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
struct __anonstruct_keywords_79 {
   char const   *name ;
   ServerOpCodes opcode ;
};
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 100 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 100 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 170 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
struct __anonstruct_sensitive_data_82 {
   Key *server_key ;
   Key *ssh1_host_key ;
   Key **host_keys ;
   int have_ssh1_key ;
   int have_ssh2_key ;
   u_char ssh1_cookie[32] ;
};
#line 361 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 242 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 36 "./buffer.h"
extern void buffer_append(Buffer * , void const   * , u_int  ) ;
#line 87 "/usr/include/shadow.h"
extern struct spwd *getspnam(char const   *__name ) ;
#line 130 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int auth_shadow_acctexpired(struct spwd *spw ) ;
#line 131
int auth_shadow_pwexpired(Authctxt *ctxt ) ;
#line 57 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
extern void ( /* format attribute */  error)(char const   *  , ...) ;
#line 58
extern void ( /* format attribute */  logit)(char const   *  , ...) ;
#line 62
extern void ( /* format attribute */  debug3)(char const   *  , ...) ;
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-shadow.c"
Buffer loginmsg ;
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-shadow.c"
int auth_shadow_acctexpired(struct spwd *spw ) 
{ 
  time_t today ;
  int daysleft ;
  char buf___1[256] ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 58
  tmp = time((time_t *)((void *)0));
  }
#line 58
  today = tmp / 86400L;
#line 59
  daysleft = (int )(spw->sp_expire - today);
  {
#line 60
  debug3("%s: today %d sp_expire %d days left %d", "auth_shadow_acctexpired", (int )today,
         (int )spw->sp_expire, daysleft);
  }
  }
#line 63
  if (spw->sp_expire == -1L) {
    {
    {
#line 64
    debug3("account expiration disabled");
    }
    }
  } else
#line 65
  if (daysleft < 0) {
    {
    {
#line 66
    logit("Account %.100s has expired", spw->sp_namp);
    }
    }
#line 67
    return (1);
  } else
#line 68
  if ((long )daysleft <= spw->sp_warn) {
    {
    {
#line 69
    debug3("account will expire in %d days", daysleft);
    }
    }
#line 70
    if (daysleft == 1) {
#line 70
      tmp___0 = "";
    } else {
#line 70
      tmp___0 = "s";
    }
    {
    {
#line 70
    snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"Your account will expire in %d day%s.\n",
             daysleft, tmp___0);
    }
    {
#line 73
    tmp___1 = strlen((char const   *)(buf___1));
    }
    {
#line 73
    buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
    }
    }
  }
#line 76
  return (0);
}
}
#line 83 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-shadow.c"
int auth_shadow_pwexpired(Authctxt *ctxt ) 
{ 
  struct spwd *spw ;
  char const   *user ;
  char buf___1[256] ;
  time_t today ;
  int daysleft ;
  int disabled ;
  time_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 86
  spw = (struct spwd *)((void *)0);
#line 87
  user = (char const   *)(ctxt->pw)->pw_name;
#line 90
  disabled = 0;
  {
#line 92
  spw = getspnam((char const   *)((char *)user));
  }
  }
#line 92
  if ((unsigned long )spw == (unsigned long )((void *)0)) {
    {
    {
#line 93
    error("Could not get shadow information for %.100s", user);
    }
    }
#line 94
    return (0);
  }
  {
  {
#line 97
  tmp = time((time_t *)((void *)0));
  }
#line 97
  today = tmp / 86400L;
  {
#line 98
  debug3("%s: today %d sp_lstchg %d sp_max %d", "auth_shadow_pwexpired", (int )today,
         (int )spw->sp_lstchg, (int )spw->sp_max);
  }
#line 117
  daysleft = (int )((spw->sp_lstchg + spw->sp_max) - today);
  }
#line 118
  if (disabled) {
    {
    {
#line 119
    debug3("password expiration disabled");
    }
    }
  } else
#line 120
  if (spw->sp_lstchg == 0L) {
    {
    {
#line 121
    logit("User %.100s password has expired (root forced)", user);
    }
    }
#line 122
    return (1);
  } else
#line 123
  if (spw->sp_max == -1L) {
    {
    {
#line 124
    debug3("password expiration disabled");
    }
    }
  } else
#line 125
  if (daysleft < 0) {
    {
    {
#line 126
    logit("User %.100s password has expired (password aged)", user);
    }
    }
#line 127
    return (1);
  } else
#line 128
  if ((long )daysleft <= spw->sp_warn) {
    {
    {
#line 129
    debug3("password will expire in %d days", daysleft);
    }
    }
#line 130
    if (daysleft == 1) {
#line 130
      tmp___0 = "";
    } else {
#line 130
      tmp___0 = "s";
    }
    {
    {
#line 130
    snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"Your password will expire in %d day%s.\n",
             daysleft, tmp___0);
    }
    {
#line 133
    tmp___1 = strlen((char const   *)(buf___1));
    }
    {
#line 133
    buffer_append(& loginmsg, (void const   *)(buf___1), tmp___1);
    }
    }
  }
#line 136
  return (0);
}
}
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 217 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf )  __asm__("fstat64")  ;
#line 88 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 59
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 87
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 102
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 304 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 320
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 46 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) void login(struct utmp  const  *__entry ) ;
#line 49
extern  __attribute__((__nothrow__)) int logout(char const   *__ut_line ) ;
#line 52
extern  __attribute__((__nothrow__)) void logwtmp(char const   *__ut_line , char const   *__ut_name ,
                                                  char const   *__ut_host ) ;
#line 129 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 355 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 69 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/openbsd-compat.h"
extern size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 74
extern size_t strlcat(char *dst , char const   *src , size_t siz ) ;
#line 22 "/home/pronto/abs/test-suite/openssh-4.3p2/xmalloc.h"
extern void *xmalloc(size_t  ) ;
#line 24
extern void xfree(void * ) ;
#line 95 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.h"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) ;
#line 98
void login_free_entry(struct logininfo *li ) ;
#line 100
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) ;
#line 103
void login_set_current_time(struct logininfo *li ) ;
#line 106
int login_login(struct logininfo *li ) ;
#line 107
int login_logout(struct logininfo *li ) ;
#line 115
int login_write(struct logininfo *li ) ;
#line 119
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int const   sa_size ) ;
#line 126
struct logininfo *login_get_lastlog(struct logininfo *li , int const   uid ) ;
#line 128
unsigned int login_get_lastlog_time(int const   uid ) ;
#line 131
char *line_fullname(char *dst , char const   *src , u_int dstsize ) ;
#line 132
char *line_stripname(char *dst , char const   *src , int dstsize ) ;
#line 133
char *line_abbrevname(char *dst , char const   *src , int dstsize ) ;
#line 135
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) ;
#line 56 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  fatal)(char const   * 
                                                                            , ...) ;
#line 60
extern void ( /* format attribute */  debug)(char const   *  , ...) ;
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/atomicio.h"
extern size_t atomicio(ssize_t (*)(int  , void * , size_t  ) , int  , void * , size_t  ) ;
#line 23 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern int packet_get_connection_in(void) ;
#line 77
extern int packet_connection_is_on_socket(void) ;
#line 27 "/home/pronto/abs/test-suite/openssh-4.3p2/canohost.h"
extern void ipv64_normalise_mapped(struct sockaddr_storage * , socklen_t * ) ;
#line 175 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) ;
#line 176
void construct_utmp(struct logininfo *li , struct utmp *ut ) ;
#line 188
int lastlog_write_entry(struct logininfo *li ) ;
#line 189
int syslogin_write_entry(struct logininfo *li ) ;
#line 191
int getlast_entry(struct logininfo *li ) ;
#line 192
int lastlog_get_entry(struct logininfo *li ) ;
#line 215 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int login_login(struct logininfo *li ) 
{ 
  int tmp ;

  {
  {
#line 218
  li->type = (short)7;
  {
#line 219
  tmp = login_write(li);
  }
  }
#line 219
  return (tmp);
}
}
#line 232 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int login_logout(struct logininfo *li ) 
{ 
  int tmp ;

  {
  {
#line 235
  li->type = (short)8;
  {
#line 236
  tmp = login_write(li);
  }
  }
#line 236
  return (tmp);
}
}
#line 257 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
unsigned int login_get_lastlog_time(int const   uid ) 
{ 
  struct logininfo li ;
  struct logininfo *tmp ;

  {
  {
  {
#line 262
  tmp = login_get_lastlog(& li, uid);
  }
  }
#line 262
  if (tmp) {
#line 263
    return (li.tv_sec);
  } else {
#line 265
    return (0U);
  }
}
}
#line 281 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
struct logininfo *login_get_lastlog(struct logininfo *li , int const   uid ) 
{ 
  struct passwd *pw ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 286
  memset((void *)li, '\000', (size_t )sizeof(*li));
  }
#line 287
  li->uid = (int )uid;
  {
#line 294
  pw = getpwuid((__uid_t )uid);
  }
  }
#line 295
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
    {
#line 296
    fatal("%s: Cannot find account for uid %i", "login_get_lastlog", uid);
    }
    }
  }
  {
  {
#line 300
  strlcpy(li->username, (char const   *)pw->pw_name, (size_t )sizeof(li->username));
  }
  {
#line 302
  tmp = getlast_entry(li);
  }
  }
#line 302
  if (tmp) {
#line 303
    return (li);
  } else {
#line 305
    return ((struct logininfo *)((void *)0));
  }
}
}
#line 319 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
struct logininfo *login_alloc_entry(int pid , char const   *username , char const   *hostname ,
                                    char const   *line ) 
{ 
  struct logininfo *newli ;
  void *tmp ;

  {
  {
  {
#line 325
  tmp = xmalloc((size_t )sizeof(*newli));
  }
#line 325
  newli = (struct logininfo *)tmp;
  {
#line 326
  login_init_entry(newli, pid, username, hostname, line);
  }
  }
#line 327
  return (newli);
}
}
#line 332 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void login_free_entry(struct logininfo *li ) 
{ 


  {
  {
  {
#line 335
  xfree((void *)li);
  }
  }
#line 336
  return;
}
}
#line 347 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int login_init_entry(struct logininfo *li , int pid , char const   *username , char const   *hostname ,
                     char const   *line ) 
{ 
  struct passwd *pw ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 353
  memset((void *)li, 0, (size_t )sizeof(*li));
  }
#line 355
  li->pid = pid;
  }
#line 358
  if (line) {
    {
    {
#line 359
    line_fullname(li->line, line, (u_int )sizeof(li->line));
    }
    }
  }
#line 361
  if (username) {
    {
    {
#line 362
    strlcpy(li->username, username, (size_t )sizeof(li->username));
    }
    {
#line 363
    pw = getpwnam((char const   *)(li->username));
    }
    }
#line 364
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
      {
#line 365
      fatal("%s: Cannot find user \"%s\"", "login_init_entry", li->username);
      }
      }
    }
#line 368
    li->uid = (int )pw->pw_uid;
  }
#line 371
  if (hostname) {
    {
    {
#line 372
    strlcpy(li->hostname, hostname, (size_t )sizeof(li->hostname));
    }
    }
  }
#line 374
  return (1);
}
}
#line 384 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void login_set_current_time(struct logininfo *li ) 
{ 
  struct timeval tv ;

  {
  {
  {
#line 389
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
  }
#line 391
  li->tv_sec = (unsigned int )tv.tv_sec;
#line 392
  li->tv_usec = (unsigned int )tv.tv_usec;
  }
#line 393
  return;
}
}
#line 396 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void login_set_addr(struct logininfo *li , struct sockaddr  const  *sa , unsigned int const   sa_size ) 
{ 
  unsigned int bufsize ;

  {
#line 400
  bufsize = (unsigned int )sa_size;
#line 403
  if (sizeof(li->hostaddr) < (unsigned long )sa_size) {
#line 404
    bufsize = (unsigned int )sizeof(li->hostaddr);
  }
  {
  {
#line 406
  memcpy((void */* __restrict  */)(& li->hostaddr.sa), (void const   */* __restrict  */)sa,
         bufsize);
  }
  }
#line 407
  return;
}
}
#line 414 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int login_write(struct logininfo *li ) 
{ 
  __uid_t tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 418
  tmp = geteuid();
  }
  }
#line 418
  if (tmp != 0U) {
    {
    {
#line 419
    logit("Attempt to write login records by non-root user (aborting)");
    }
    }
#line 420
    return (1);
  }
  {
  {
#line 425
  login_set_current_time(li);
  }
  {
#line 427
  syslogin_write_entry(li);
  }
  }
#line 430
  if ((int )li->type == 7) {
    {
    {
#line 431
    lastlog_write_entry(li);
    }
    }
  }
#line 457
  return (0);
}
}
#line 488 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int getlast_entry(struct logininfo *li ) 
{ 
  int tmp ;

  {
  {
  {
#line 492
  tmp = lastlog_get_entry(li);
  }
  }
#line 492
  return (tmp);
}
}
#line 537 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
char *line_fullname(char *dst , char const   *src , u_int dstsize ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 540
  memset((void *)dst, '\000', dstsize);
  }
  {
#line 541
  tmp = strncmp(src, "/dev/", (size_t )5);
  }
  }
#line 541
  if (tmp == 0) {
    {
    {
#line 542
    strlcpy(dst, src, dstsize);
    }
    }
  } else {
    {
    {
#line 541
    tmp___0 = strlen(src);
    }
    }
#line 541
    if (dstsize < tmp___0 + 5U) {
      {
      {
#line 542
      strlcpy(dst, src, dstsize);
      }
      }
    } else {
      {
      {
#line 544
      strlcpy(dst, "/dev/", dstsize);
      }
      {
#line 545
      strlcat(dst, src, dstsize);
      }
      }
    }
  }
#line 547
  return (dst);
}
}
#line 551 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
char *line_stripname(char *dst , char const   *src , int dstsize ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 554
  memset((void *)dst, '\000', (size_t )dstsize);
  }
  {
#line 555
  tmp = strncmp(src, "/dev/", (size_t )5);
  }
  }
#line 555
  if (tmp == 0) {
    {
    {
#line 556
    strlcpy(dst, src + 5, (size_t )dstsize);
    }
    }
  } else {
    {
    {
#line 558
    strlcpy(dst, src, (size_t )dstsize);
    }
    }
  }
#line 559
  return (dst);
}
}
#line 570 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
char *line_abbrevname(char *dst , char const   *src , int dstsize ) 
{ 
  size_t len ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 575
  memset((void *)dst, '\000', (size_t )dstsize);
  }
  {
#line 578
  tmp = strncmp(src, "/dev/", (size_t )5);
  }
  }
#line 578
  if (tmp == 0) {
#line 579
    src += 5;
  }
  {
  {
#line 586
  len = strlen(src);
  }
  }
#line 588
  if (len > 0U) {
#line 589
    if ((int )len - dstsize > 0) {
#line 590
      src += (int )len - dstsize;
    }
    {
    {
#line 593
    strncpy((char */* __restrict  */)dst, (char const   */* __restrict  */)src, (size_t )dstsize);
    }
    }
  }
#line 596
  return (dst);
}
}
#line 609 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void set_utmp_time(struct logininfo *li , struct utmp *ut ) 
{ 


  {
#line 613
  ut->ut_tv.tv_sec = (__time_t )li->tv_sec;
#line 614
  ut->ut_tv.tv_usec = (__suseconds_t )li->tv_usec;
#line 618
  return;
}
}
#line 620 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void construct_utmp(struct logininfo *li , struct utmp *ut ) 
{ 
  struct sockaddr_in6 *sa6 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
  {
#line 628
  memset((void *)ut, '\000', (size_t )sizeof(*ut));
  }
  {
#line 633
  line_abbrevname(ut->ut_id, (char const   *)(li->line), (int )sizeof(ut->ut_id));
  }
  }
  {
#line 639
  if ((int )li->type == 7) {
#line 639
    goto case_7;
  }
#line 645
  if ((int )li->type == 8) {
#line 645
    goto case_8;
  }
#line 638
  goto switch_break;
  case_7: /* CIL Label */ 
#line 640
  ut->ut_type = (short)7;
#line 644
  goto switch_break;
  case_8: /* CIL Label */ 
#line 646
  ut->ut_type = (short)8;
#line 650
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 653
  set_utmp_time(li, ut);
  }
  {
#line 655
  line_stripname(ut->ut_line, (char const   *)(li->line), (int )sizeof(ut->ut_line));
  }
#line 658
  ut->ut_pid = li->pid;
  }
#line 662
  if ((int )li->type == 8) {
#line 663
    return;
  }
#line 671
  if (sizeof(ut->ut_user) < sizeof(li->username)) {
#line 671
    tmp = sizeof(ut->ut_user);
  } else {
#line 671
    tmp = sizeof(li->username);
  }
  {
  {
#line 671
  strncpy((char */* __restrict  */)(ut->ut_user), (char const   */* __restrict  */)(li->username),
          (size_t )tmp);
  }
  }
#line 674
  if (sizeof(ut->ut_host) < sizeof(li->hostname)) {
#line 674
    tmp___0 = sizeof(ut->ut_host);
  } else {
#line 674
    tmp___0 = sizeof(li->hostname);
  }
  {
  {
#line 674
  strncpy((char */* __restrict  */)(ut->ut_host), (char const   */* __restrict  */)(li->hostname),
          (size_t )tmp___0);
  }
  }
#line 679
  if ((int )li->hostaddr.sa.sa_family == 2) {
#line 680
    ut->ut_addr_v6[0] = (int32_t )li->hostaddr.sa_in.sin_addr.s_addr;
  }
#line 684
  if ((int )li->hostaddr.sa.sa_family == 10) {
    {
#line 685
    sa6 = (struct sockaddr_in6 *)(& li->hostaddr.sa);
    {
#line 686
    memcpy((void */* __restrict  */)(ut->ut_addr_v6), (void const   */* __restrict  */)(sa6->sin6_addr.in6_u.u6_addr8),
           (size_t )16);
    }
    }
#line 687
    if (*((uint32_t const   *)(& sa6->sin6_addr) + 0) == 0U) {
#line 687
      if (*((uint32_t const   *)(& sa6->sin6_addr) + 1) == 0U) {
        {
        {
#line 687
        tmp___1 = htonl((uint32_t )65535);
        }
        }
#line 687
        if (*((uint32_t const   *)(& sa6->sin6_addr) + 2) == (uint32_t const   )tmp___1) {
#line 688
          ut->ut_addr_v6[0] = ut->ut_addr_v6[3];
#line 689
          ut->ut_addr_v6[1] = 0;
#line 690
          ut->ut_addr_v6[2] = 0;
#line 691
          ut->ut_addr_v6[3] = 0;
        }
      }
    }
  }
#line 695
  return;
}
}
#line 1385 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static int syslogin_perform_login(struct logininfo *li ) 
{ 
  struct utmp *ut ;
  void *tmp ;

  {
  {
  {
#line 1390
  tmp = xmalloc((size_t )sizeof(*ut));
  }
#line 1390
  ut = (struct utmp *)tmp;
  {
#line 1391
  construct_utmp(li, ut);
  }
  {
#line 1392
  login((struct utmp  const  *)ut);
  }
  {
#line 1393
  free((void *)ut);
  }
  }
#line 1395
  return (1);
}
}
#line 1398 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static int syslogin_perform_logout(struct logininfo *li ) 
{ 
  char line[32] ;
  int tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 1404
  line_stripname(line, (char const   *)(li->line), (int )sizeof(line));
  }
  {
#line 1406
  tmp = logout((char const   *)(line));
  }
  }
#line 1406
  if (tmp) {
    {
    {
#line 1410
    logwtmp((char const   *)(line), "", "");
    }
    }
  } else {
    {
    {
#line 1407
    logit("%s: logout() returned an error", "syslogin_perform_logout");
    }
    }
  }
#line 1417
  return (1);
}
}
#line 1420 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int syslogin_write_entry(struct logininfo *li ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1424
  if ((int )li->type == 7) {
#line 1424
    goto case_7;
  }
#line 1426
  if ((int )li->type == 8) {
#line 1426
    goto case_8;
  }
#line 1428
  goto switch_default;
  case_7: /* CIL Label */ 
  {
  {
#line 1425
  tmp = syslogin_perform_login(li);
  }
  }
#line 1425
  return (tmp);
  case_8: /* CIL Label */ 
  {
  {
#line 1427
  tmp___0 = syslogin_perform_logout(li);
  }
  }
#line 1427
  return (tmp___0);
  switch_default: /* CIL Label */ 
  {
  {
#line 1429
  logit("%s: Invalid type field", "syslogin_write_entry");
  }
  }
#line 1430
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1446 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static void lastlog_construct(struct logininfo *li , struct lastlog *last ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 1450
  memset((void *)last, '\000', (size_t )sizeof(*last));
  }
  {
#line 1452
  line_stripname(last->ll_line, (char const   *)(li->line), (int )sizeof(last->ll_line));
  }
  }
#line 1453
  if (sizeof(last->ll_host) < sizeof(li->hostname)) {
#line 1453
    tmp = sizeof(last->ll_host);
  } else {
#line 1453
    tmp = sizeof(li->hostname);
  }
  {
  {
#line 1453
  strlcpy(last->ll_host, (char const   *)(li->hostname), (size_t )tmp);
  }
#line 1455
  last->ll_time = (__time_t )li->tv_sec;
  }
#line 1456
  return;
}
}
#line 1458 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static int lastlog_filetype(char *filename ) 
{ 
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1463
  tmp___1 = stat((char const   */* __restrict  */)"/var/log/lastlog", (struct stat */* __restrict  */)(& st));
  }
  }
#line 1463
  if (tmp___1 != 0) {
    {
    {
#line 1464
    tmp = __errno_location();
    }
    {
#line 1464
    tmp___0 = strerror(*tmp);
    }
    {
#line 1464
    logit("%s: Couldn\'t stat %s: %s", "lastlog_filetype", "/var/log/lastlog", tmp___0);
    }
    }
#line 1466
    return (0);
  }
#line 1468
  if ((st.st_mode & 61440U) == 16384U) {
#line 1469
    return (2);
  } else
#line 1470
  if ((st.st_mode & 61440U) == 32768U) {
#line 1471
    return (1);
  } else {
#line 1473
    return (3);
  }
}
}
#line 1478 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static int lastlog_openseek(struct logininfo *li , int *fd , int filemode ) 
{ 
  off_t offset ;
  int type ;
  char lastlog_file[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __off64_t tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 1485
  type = lastlog_filetype((char *)"/var/log/lastlog");
  }
  }
  {
#line 1487
  if (type == 1) {
#line 1487
    goto case_1;
  }
#line 1491
  if (type == 2) {
#line 1491
    goto case_2;
  }
#line 1495
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  {
#line 1488
  strlcpy(lastlog_file, "/var/log/lastlog", (size_t )sizeof(lastlog_file));
  }
  }
#line 1490
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 1492
  snprintf((char */* __restrict  */)(lastlog_file), (size_t )sizeof(lastlog_file),
           (char const   */* __restrict  */)"%s/%s", "/var/log/lastlog", li->username);
  }
  }
#line 1494
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 1496
  logit("%s: %.100s is not a file or directory!", "lastlog_openseek", "/var/log/lastlog");
  }
  }
#line 1498
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1501
  *fd = open((char const   *)(lastlog_file), filemode, 384);
  }
  }
#line 1502
  if (*fd < 0) {
    {
    {
#line 1503
    tmp = __errno_location();
    }
    {
#line 1503
    tmp___0 = strerror(*tmp);
    }
    {
#line 1503
    debug("%s: Couldn\'t open %s: %s", "lastlog_openseek", lastlog_file, tmp___0);
    }
    }
#line 1505
    return (0);
  }
#line 1508
  if (type == 1) {
    {
#line 1510
    offset = (off_t )((unsigned long )((long )li->uid) * sizeof(struct lastlog ));
    {
#line 1512
    tmp___3 = lseek(*fd, offset, 0);
    }
    }
#line 1512
    if (tmp___3 != offset) {
      {
      {
#line 1513
      tmp___1 = __errno_location();
      }
      {
#line 1513
      tmp___2 = strerror(*tmp___1);
      }
      {
#line 1513
      logit("%s: %s->lseek(): %s", "lastlog_openseek", lastlog_file, tmp___2);
      }
      }
#line 1515
      return (0);
    }
  }
#line 1519
  return (1);
}
}
#line 1522 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static int lastlog_perform_login(struct logininfo *li ) 
{ 
  struct lastlog last ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 1529
  lastlog_construct(li, & last);
  }
  {
#line 1531
  tmp = lastlog_openseek(li, & fd, 66);
  }
  }
#line 1531
  if (! tmp) {
#line 1532
    return (0);
  }
  {
  {
#line 1535
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& last),
                     (size_t )sizeof(last));
  }
  }
#line 1535
  if ((unsigned long )tmp___2 != sizeof(last)) {
    {
    {
#line 1536
    close(fd);
    }
    {
#line 1537
    tmp___0 = __errno_location();
    }
    {
#line 1537
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 1537
    logit("%s: Error writing to %s: %s", "lastlog_perform_login", "/var/log/lastlog",
          tmp___1);
    }
    }
#line 1539
    return (0);
  }
  {
  {
#line 1542
  close(fd);
  }
  }
#line 1543
  return (1);
}
}
#line 1546 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int lastlog_write_entry(struct logininfo *li ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1550
  if ((int )li->type == 7) {
#line 1550
    goto case_7;
  }
#line 1552
  goto switch_default;
  case_7: /* CIL Label */ 
  {
  {
#line 1551
  tmp = lastlog_perform_login(li);
  }
  }
#line 1551
  return (tmp);
  switch_default: /* CIL Label */ 
  {
  {
#line 1553
  logit("%s: Invalid type field", "lastlog_write_entry");
  }
  }
#line 1554
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1558 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
static void lastlog_populate_entry(struct logininfo *li , struct lastlog *last ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 1561
  line_fullname(li->line, (char const   *)(last->ll_line), (u_int )sizeof(li->line));
  }
  }
#line 1562
  if (sizeof(li->hostname) < sizeof(last->ll_host)) {
#line 1562
    tmp = sizeof(li->hostname);
  } else {
#line 1562
    tmp = sizeof(last->ll_host);
  }
  {
  {
#line 1562
  strlcpy(li->hostname, (char const   *)(last->ll_host), (size_t )tmp);
  }
#line 1564
  li->tv_sec = (unsigned int )last->ll_time;
  }
#line 1565
  return;
}
}
#line 1567 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
int lastlog_get_entry(struct logininfo *li ) 
{ 
  struct lastlog last ;
  int fd ;
  int ret ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 1573
  tmp = lastlog_openseek(li, & fd, 0);
  }
  }
#line 1573
  if (! tmp) {
#line 1574
    return (0);
  }
  {
  {
#line 1576
  tmp___0 = atomicio(& read, fd, (void *)(& last), (size_t )sizeof(last));
  }
#line 1576
  ret = (int )tmp___0;
  {
#line 1577
  close(fd);
  }
  }
  {
#line 1580
  if (ret == 0) {
#line 1580
    goto case_0;
  }
#line 1583
  if (ret == (int )sizeof(last)) {
#line 1583
    goto case_exp;
  }
#line 1586
  if (ret == -1) {
#line 1586
    goto case_neg_1;
  }
#line 1590
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 1581
  memset((void *)(& last), '\000', (size_t )sizeof(last));
  }
  }
  case_exp: /* CIL Label */ 
  {
  {
#line 1584
  lastlog_populate_entry(li, & last);
  }
  }
#line 1585
  return (1);
  case_neg_1: /* CIL Label */ 
  {
  {
#line 1587
  tmp___1 = __errno_location();
  }
  {
#line 1587
  tmp___2 = strerror(*tmp___1);
  }
  {
#line 1587
  error("%s: Error reading from %s: %s", "lastlog_get_entry", "/var/log/lastlog",
        tmp___2);
  }
  }
#line 1589
  return (0);
  switch_default: /* CIL Label */ 
  {
  {
#line 1591
  error("%s: Error reading from %s: Expecting %d, got %d", "lastlog_get_entry", "/var/log/lastlog",
        (int )sizeof(last), ret);
  }
  }
#line 1593
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1597
  return (0);
}
}
#line 1609 "/home/pronto/abs/test-suite/openssh-4.3p2/loginrec.c"
void record_failed_login(char const   *username , char const   *hostname , char const   *ttyn ) 
{ 
  int fd ;
  struct utmp ut ;
  struct sockaddr_storage from ;
  socklen_t fromlen ;
  struct sockaddr_in *a4 ;
  struct sockaddr_in6 *a6 ;
  time_t t ;
  struct stat fst ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 1616
  fromlen = (socklen_t )sizeof(from);
  {
#line 1622
  tmp = geteuid();
  }
  }
#line 1622
  if (tmp != 0U) {
#line 1623
    return;
  }
  {
  {
#line 1624
  fd = open("/var/log/btmp", 1025);
  }
  }
#line 1624
  if (fd < 0) {
    {
    {
#line 1625
    tmp___0 = __errno_location();
    }
    {
#line 1625
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 1625
    debug("Unable to open the btmp file %s: %s", "/var/log/btmp", tmp___1);
    }
    }
#line 1627
    return;
  }
  {
  {
#line 1629
  tmp___4 = fstat(fd, & fst);
  }
  }
#line 1629
  if (tmp___4 < 0) {
    {
    {
#line 1630
    tmp___2 = __errno_location();
    }
    {
#line 1630
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 1630
    logit("%s: fstat of %s failed: %s", "record_failed_login", "/var/log/btmp", tmp___3);
    }
    }
#line 1632
    goto out;
  }
#line 1634
  if (fst.st_mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3))) {
    {
    {
#line 1635
    logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
    }
    }
#line 1637
    goto out;
  } else
#line 1634
  if (fst.st_uid != 0U) {
    {
    {
#line 1635
    logit("Excess permission or bad ownership on file %s", "/var/log/btmp");
    }
    }
#line 1637
    goto out;
  }
  {
  {
#line 1640
  memset((void *)(& ut), 0, (size_t )sizeof(ut));
  }
  {
#line 1642
  strncpy((char */* __restrict  */)(ut.ut_user), (char const   */* __restrict  */)username,
          (size_t )sizeof(ut.ut_user));
  }
  {
#line 1643
  strlcpy(ut.ut_line, "ssh:notty", (size_t )sizeof(ut.ut_line));
  }
  {
#line 1645
  time(& t);
  }
#line 1646
  ut.ut_tv.tv_sec = t;
#line 1647
  ut.ut_type = (short)6;
  {
#line 1648
  ut.ut_pid = getpid();
  }
  {
#line 1651
  strncpy((char */* __restrict  */)(ut.ut_host), (char const   */* __restrict  */)hostname,
          (size_t )sizeof(ut.ut_host));
  }
  {
#line 1653
  tmp___7 = packet_connection_is_on_socket();
  }
  }
#line 1653
  if (tmp___7) {
    {
    {
#line 1653
    tmp___8 = packet_get_connection_in();
    }
    {
#line 1653
    tmp___9 = getpeername(tmp___8, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                          (socklen_t */* __restrict  */)(& fromlen));
    }
    }
#line 1653
    if (tmp___9 == 0) {
      {
      {
#line 1656
      ipv64_normalise_mapped(& from, & fromlen);
      }
      }
#line 1657
      if ((int )from.ss_family == 2) {
#line 1658
        a4 = (struct sockaddr_in *)(& from);
#line 1659
        if (sizeof(ut.ut_addr_v6[0]) < sizeof(a4->sin_addr)) {
#line 1659
          tmp___5 = sizeof(ut.ut_addr_v6[0]);
        } else {
#line 1659
          tmp___5 = sizeof(a4->sin_addr);
        }
        {
        {
#line 1659
        memcpy((void */* __restrict  */)(& ut.ut_addr_v6[0]), (void const   */* __restrict  */)(& a4->sin_addr),
               (size_t )tmp___5);
        }
        }
      }
#line 1663
      if ((int )from.ss_family == 10) {
#line 1664
        a6 = (struct sockaddr_in6 *)(& from);
#line 1665
        if (sizeof(ut.ut_addr_v6) < sizeof(a6->sin6_addr)) {
#line 1665
          tmp___6 = sizeof(ut.ut_addr_v6);
        } else {
#line 1665
          tmp___6 = sizeof(a6->sin6_addr);
        }
        {
        {
#line 1665
        memcpy((void */* __restrict  */)(& ut.ut_addr_v6), (void const   */* __restrict  */)(& a6->sin6_addr),
               (size_t )tmp___6);
        }
        }
      }
    }
  }
  {
  {
#line 1671
  tmp___12 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), fd, (void *)(& ut),
                      (size_t )sizeof(ut));
  }
  }
#line 1671
  if ((unsigned long )tmp___12 != sizeof(ut)) {
    {
    {
#line 1672
    tmp___10 = __errno_location();
    }
    {
#line 1672
    tmp___11 = strerror(*tmp___10);
    }
    {
#line 1672
    error("Failed to write to %s: %s", "/var/log/btmp", tmp___11);
    }
    }
  }
  out: 
  {
  {
#line 1676
  close(fd);
  }
  }
#line 1677
  return;
}
}
#line 33 "./buffer.h"
extern u_int buffer_len(Buffer * ) ;
#line 34
extern void *buffer_ptr(Buffer * ) ;
#line 410 "/usr/include/openssl/bn.h"
extern BIGNUM *BN_new(void) ;
#line 412
extern void BN_clear_free(BIGNUM *a ) ;
#line 415
extern BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 176 "/usr/include/openssl/dh.h"
extern void DH_free(DH *dh ) ;
#line 178
extern int DH_size(DH const   *dh ) ;
#line 196
extern int DH_compute_key(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
#line 75 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
extern int key_to_blob(Key const   * , u_char ** , u_int * ) ;
#line 79
extern int key_sign(Key const   * , u_char ** , u_int * , u_char const   * , u_int  ) ;
#line 127 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
extern void kex_finish(Kex * ) ;
#line 131
extern void kex_derive_keys(Kex * , u_char * , u_int  , BIGNUM * ) ;
#line 138
void kexgex_server(Kex *kex ) ;
#line 143
extern void kexgex_hash(EVP_MD const   * , char * , char * , char * , int  , char * ,
                        int  , u_char * , int  , int  , int  , int  , BIGNUM * , BIGNUM * ,
                        BIGNUM * , BIGNUM * , BIGNUM * , u_char ** , u_int * ) ;
#line 36 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_start(u_char  ) ;
#line 40
extern void packet_put_bignum2(BIGNUM *value ) ;
#line 41
extern void packet_put_string(void const   *buf , u_int len ) ;
#line 44
extern void packet_send(void) ;
#line 46
extern int packet_read(void) ;
#line 47
extern void packet_read_expect(int type ) ;
#line 54
extern u_int packet_get_int(void) ;
#line 56
extern void packet_get_bignum2(BIGNUM *value ) ;
#line 59
extern void ( /* format attribute */  packet_disconnect)(char const   *fmt  , ...) ;
#line 73
extern void packet_write_wait(void) ;
#line 79
extern int packet_remaining(void) ;
#line 35 "/home/pronto/abs/test-suite/openssh-4.3p2/dh.h"
extern DH *choose_dh(int  , int  , int  ) ;
#line 41
extern void dh_gen_key(DH * , int  ) ;
#line 42
extern int dh_pub_is_valid(DH * , BIGNUM * ) ;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.h"
int use_privsep ;
#line 44
DH *mm_choose_dh(int min , int nbits , int max ) ;
#line 45
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) ;
#line 39 "/home/pronto/abs/test-suite/openssh-4.3p2/kexgexs.c"
void kexgex_server(Kex *kex ) 
{ 
  BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  Key *server_host_key ;
  DH *dh ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int slen ;
  u_int hashlen ;
  int min ;
  int max ;
  int nbits ;
  int type ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  DH *tmp___4 ;
  DH *tmp___5 ;
  int _len___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  u_int tmp___11 ;
  void *tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
#line 42
  shared_secret = (BIGNUM *)((void *)0);
#line 42
  dh_client_pub = (BIGNUM *)((void *)0);
#line 45
  signature = (u_char *)((void *)0);
#line 45
  server_host_key_blob = (u_char *)((void *)0);
#line 47
  min = -1;
#line 47
  max = -1;
#line 47
  nbits = -1;
#line 49
  if ((unsigned long )kex->load_host_key == (unsigned long )((void *)0)) {
    {
    {
#line 50
    fatal("Cannot load hostkey");
    }
    }
  }
  {
  {
#line 51
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
  }
  }
#line 52
  if ((unsigned long )server_host_key == (unsigned long )((void *)0)) {
    {
    {
#line 53
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
    }
    }
  }
  {
  {
#line 55
  type = packet_read();
  }
  }
  {
#line 57
  if (type == 34) {
#line 57
    goto case_34;
  }
#line 65
  if (type == 30) {
#line 65
    goto case_30;
  }
#line 72
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 58
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST received");
  }
  {
#line 59
  tmp = packet_get_int();
  }
#line 59
  min = (int )tmp;
  {
#line 60
  tmp___0 = packet_get_int();
  }
#line 60
  nbits = (int )tmp___0;
  {
#line 61
  tmp___1 = packet_get_int();
  }
#line 61
  max = (int )tmp___1;
  }
#line 62
  if (1024 > min) {
#line 62
    min = 1024;
  } else {
#line 62
    min = min;
  }
#line 63
  if (8192 < max) {
#line 63
    max = 8192;
  } else {
#line 63
    max = max;
  }
#line 64
  goto switch_break;
  case_30: /* CIL Label */ 
  {
  {
#line 66
  debug("SSH2_MSG_KEX_DH_GEX_REQUEST_OLD received");
  }
  {
#line 67
  tmp___2 = packet_get_int();
  }
#line 67
  nbits = (int )tmp___2;
#line 68
  min = 1024;
#line 69
  max = 8192;
  }
#line 71
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 73
  fatal("protocol error during kex, no DH_GEX_REQUEST: %d", type);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 75
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 75
    tmp___3 = packet_remaining();
    }
#line 75
    _len = tmp___3;
    }
#line 75
    if (_len > 0) {
      {
      {
#line 75
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/kexgexs.c",
            75);
      }
      {
#line 75
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 75
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if (max < min) {
    {
    {
#line 78
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    }
    }
  } else
#line 77
  if (nbits < min) {
    {
    {
#line 78
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    }
    }
  } else
#line 77
  if (max < nbits) {
    {
    {
#line 78
    fatal("DH_GEX_REQUEST, bad parameters: %d !< %d !< %d", min, nbits, max);
    }
    }
  }
#line 82
  if (use_privsep) {
    {
    {
#line 82
    tmp___4 = mm_choose_dh(min, nbits, max);
    }
#line 82
    dh = tmp___4;
    }
  } else {
    {
    {
#line 82
    tmp___5 = choose_dh(min, nbits, max);
    }
#line 82
    dh = tmp___5;
    }
  }
#line 83
  if ((unsigned long )dh == (unsigned long )((void *)0)) {
    {
    {
#line 84
    packet_disconnect("Protocol error: no matching DH grp found");
    }
    }
  }
  {
  {
#line 86
  debug("SSH2_MSG_KEX_DH_GEX_GROUP sent");
  }
  {
#line 87
  packet_start((u_char )31);
  }
  {
#line 88
  packet_put_bignum2(dh->p);
  }
  {
#line 89
  packet_put_bignum2(dh->g);
  }
  {
#line 90
  packet_send();
  }
  {
#line 93
  packet_write_wait();
  }
  {
#line 96
  dh_gen_key(dh, (int )(kex->we_need * 8U));
  }
  {
#line 98
  debug("expecting SSH2_MSG_KEX_DH_GEX_INIT");
  }
  {
#line 99
  packet_read_expect(32);
  }
  {
#line 102
  dh_client_pub = BN_new();
  }
  }
#line 102
  if ((unsigned long )dh_client_pub == (unsigned long )((void *)0)) {
    {
    {
#line 103
    fatal("dh_client_pub == NULL");
    }
    }
  }
  {
  {
#line 104
  packet_get_bignum2(dh_client_pub);
  }
  }
  {
  {
#line 105
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 105
    tmp___6 = packet_remaining();
    }
#line 105
    _len___0 = tmp___6;
    }
#line 105
    if (_len___0 > 0) {
      {
      {
#line 105
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "/home/pronto/abs/test-suite/openssh-4.3p2/kexgexs.c",
            105);
      }
      {
#line 105
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 105
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 120
  tmp___7 = dh_pub_is_valid(dh, dh_client_pub);
  }
  }
#line 120
  if (! tmp___7) {
    {
    {
#line 121
    packet_disconnect("bad client public DH value");
    }
    }
  }
  {
  {
#line 123
  tmp___8 = DH_size((DH const   *)dh);
  }
#line 123
  klen = (u_int )tmp___8;
  {
#line 124
  tmp___9 = xmalloc(klen);
  }
#line 124
  kbuf = (u_char *)tmp___9;
  {
#line 125
  tmp___10 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
  }
#line 125
  kout = (u_int )tmp___10;
  {
#line 129
  shared_secret = BN_new();
  }
  }
#line 129
  if ((unsigned long )shared_secret == (unsigned long )((void *)0)) {
    {
    {
#line 130
    fatal("kexgex_server: BN_new failed");
    }
    }
  }
  {
  {
#line 131
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
  }
  {
#line 132
  memset((void *)kbuf, 0, klen);
  }
  {
#line 133
  xfree((void *)kbuf);
  }
  {
#line 135
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
  }
  }
#line 137
  if (type == 30) {
#line 138
    max = -1;
#line 138
    min = max;
  }
  {
  {
#line 141
  tmp___11 = buffer_len(& kex->my);
  }
  {
#line 141
  tmp___12 = buffer_ptr(& kex->my);
  }
  {
#line 141
  tmp___13 = buffer_len(& kex->peer);
  }
  {
#line 141
  tmp___14 = buffer_ptr(& kex->peer);
  }
  {
#line 141
  kexgex_hash(kex->evp_md, kex->client_version_string, kex->server_version_string,
              (char *)tmp___14, (int )tmp___13, (char *)tmp___12, (int )tmp___11,
              server_host_key_blob, (int )sbloblen, min, nbits, max, dh->p, dh->g,
              dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
  }
  {
#line 155
  BN_clear_free(dh_client_pub);
  }
  }
#line 158
  if ((unsigned long )kex->session_id == (unsigned long )((void *)0)) {
    {
#line 159
    kex->session_id_len = hashlen;
    {
#line 160
    tmp___15 = xmalloc(kex->session_id_len);
    }
#line 160
    kex->session_id = (u_char *)tmp___15;
    {
#line 161
    memcpy((void */* __restrict  */)kex->session_id, (void const   */* __restrict  */)hash,
           kex->session_id_len);
    }
    }
  }
#line 165
  if (use_privsep) {
    {
    {
#line 165
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
    }
    }
  } else {
    {
    {
#line 165
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
    }
    }
  }
  {
  {
#line 170
  debug("SSH2_MSG_KEX_DH_GEX_REPLY sent");
  }
  {
#line 171
  packet_start((u_char )33);
  }
  {
#line 172
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
  }
  {
#line 173
  packet_put_bignum2(dh->pub_key);
  }
  {
#line 174
  packet_put_string((void const   *)signature, slen);
  }
  {
#line 175
  packet_send();
  }
  {
#line 177
  xfree((void *)signature);
  }
  {
#line 178
  xfree((void *)server_host_key_blob);
  }
  {
#line 180
  DH_free(dh);
  }
  {
#line 182
  kex_derive_keys(kex, hash, hashlen, shared_secret);
  }
  {
#line 183
  BN_clear_free(shared_secret);
  }
  {
#line 185
  kex_finish(kex);
  }
  }
#line 186
  return;
}
}
#line 136 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
void kexdh_server(Kex *kex ) ;
#line 140
extern void kex_dh_hash(char * , char * , char * , int  , char * , int  , u_char * ,
                        int  , BIGNUM * , BIGNUM * , BIGNUM * , u_char ** , u_int * ) ;
#line 38 "/home/pronto/abs/test-suite/openssh-4.3p2/dh.h"
extern DH *dh_new_group1(void) ;
#line 39
extern DH *dh_new_group14(void) ;
#line 37 "/home/pronto/abs/test-suite/openssh-4.3p2/kexdhs.c"
void kexdh_server(Kex *kex ) 
{ 
  BIGNUM *shared_secret ;
  BIGNUM *dh_client_pub ;
  DH *dh ;
  Key *server_host_key ;
  u_char *kbuf ;
  u_char *hash ;
  u_char *signature ;
  u_char *server_host_key_blob ;
  u_int sbloblen ;
  u_int klen ;
  u_int kout ;
  u_int hashlen ;
  u_int slen ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  u_int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 40
  shared_secret = (BIGNUM *)((void *)0);
#line 40
  dh_client_pub = (BIGNUM *)((void *)0);
#line 43
  signature = (u_char *)((void *)0);
#line 43
  server_host_key_blob = (u_char *)((void *)0);
  {
#line 49
  if (kex->kex_type == 0) {
#line 49
    goto case_0;
  }
#line 52
  if (kex->kex_type == 1) {
#line 52
    goto case_1;
  }
#line 55
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 50
  dh = dh_new_group1();
  }
  }
#line 51
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 53
  dh = dh_new_group14();
  }
  }
#line 54
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 56
  fatal("%s: Unexpected KEX type %d", "kexdh_server", kex->kex_type);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 58
  dh_gen_key(dh, (int )(kex->we_need * 8U));
  }
  {
#line 60
  debug("expecting SSH2_MSG_KEXDH_INIT");
  }
  {
#line 61
  packet_read_expect(30);
  }
  }
#line 63
  if ((unsigned long )kex->load_host_key == (unsigned long )((void *)0)) {
    {
    {
#line 64
    fatal("Cannot load hostkey");
    }
    }
  }
  {
  {
#line 65
  server_host_key = (*(kex->load_host_key))(kex->hostkey_type);
  }
  }
#line 66
  if ((unsigned long )server_host_key == (unsigned long )((void *)0)) {
    {
    {
#line 67
    fatal("Unsupported hostkey type %d", kex->hostkey_type);
    }
    }
  }
  {
  {
#line 70
  dh_client_pub = BN_new();
  }
  }
#line 70
  if ((unsigned long )dh_client_pub == (unsigned long )((void *)0)) {
    {
    {
#line 71
    fatal("dh_client_pub == NULL");
    }
    }
  }
  {
  {
#line 72
  packet_get_bignum2(dh_client_pub);
  }
  }
  {
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 73
    tmp = packet_remaining();
    }
#line 73
    _len = tmp;
    }
#line 73
    if (_len > 0) {
      {
      {
#line 73
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/kexdhs.c",
            73);
      }
      {
#line 73
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 73
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 88
  tmp___0 = dh_pub_is_valid(dh, dh_client_pub);
  }
  }
#line 88
  if (! tmp___0) {
    {
    {
#line 89
    packet_disconnect("bad client public DH value");
    }
    }
  }
  {
  {
#line 91
  tmp___1 = DH_size((DH const   *)dh);
  }
#line 91
  klen = (u_int )tmp___1;
  {
#line 92
  tmp___2 = xmalloc(klen);
  }
#line 92
  kbuf = (u_char *)tmp___2;
  {
#line 93
  tmp___3 = DH_compute_key(kbuf, (BIGNUM const   *)dh_client_pub, dh);
  }
#line 93
  kout = (u_int )tmp___3;
  {
#line 97
  shared_secret = BN_new();
  }
  }
#line 97
  if ((unsigned long )shared_secret == (unsigned long )((void *)0)) {
    {
    {
#line 98
    fatal("kexdh_server: BN_new failed");
    }
    }
  }
  {
  {
#line 99
  BN_bin2bn((unsigned char const   *)kbuf, (int )kout, shared_secret);
  }
  {
#line 100
  memset((void *)kbuf, 0, klen);
  }
  {
#line 101
  xfree((void *)kbuf);
  }
  {
#line 103
  key_to_blob((Key const   *)server_host_key, & server_host_key_blob, & sbloblen);
  }
  {
#line 106
  tmp___4 = buffer_len(& kex->my);
  }
  {
#line 106
  tmp___5 = buffer_ptr(& kex->my);
  }
  {
#line 106
  tmp___6 = buffer_len(& kex->peer);
  }
  {
#line 106
  tmp___7 = buffer_ptr(& kex->peer);
  }
  {
#line 106
  kex_dh_hash(kex->client_version_string, kex->server_version_string, (char *)tmp___7,
              (int )tmp___6, (char *)tmp___5, (int )tmp___4, server_host_key_blob,
              (int )sbloblen, dh_client_pub, dh->pub_key, shared_secret, & hash, & hashlen);
  }
  {
#line 117
  BN_clear_free(dh_client_pub);
  }
  }
#line 120
  if ((unsigned long )kex->session_id == (unsigned long )((void *)0)) {
    {
#line 121
    kex->session_id_len = hashlen;
    {
#line 122
    tmp___8 = xmalloc(kex->session_id_len);
    }
#line 122
    kex->session_id = (u_char *)tmp___8;
    {
#line 123
    memcpy((void */* __restrict  */)kex->session_id, (void const   */* __restrict  */)hash,
           kex->session_id_len);
    }
    }
  }
#line 127
  if (use_privsep) {
    {
    {
#line 127
    mm_key_sign(server_host_key, & signature, & slen, hash, hashlen);
    }
    }
  } else {
    {
    {
#line 127
    key_sign((Key const   *)server_host_key, & signature, & slen, (u_char const   *)hash,
             hashlen);
    }
    }
  }
  {
  {
#line 132
  packet_start((u_char )31);
  }
  {
#line 133
  packet_put_string((void const   *)server_host_key_blob, sbloblen);
  }
  {
#line 134
  packet_put_bignum2(dh->pub_key);
  }
  {
#line 135
  packet_put_string((void const   *)signature, slen);
  }
  {
#line 136
  packet_send();
  }
  {
#line 138
  xfree((void *)signature);
  }
  {
#line 139
  xfree((void *)server_host_key_blob);
  }
  {
#line 141
  DH_free(dh);
  }
  {
#line 143
  kex_derive_keys(kex, hash, hashlen, shared_secret);
  }
  {
#line 144
  BN_clear_free(shared_secret);
  }
  {
#line 145
  kex_finish(kex);
  }
  }
#line 146
  return;
}
}
#line 29 "./buffer.h"
extern void buffer_init(Buffer * ) ;
#line 30
extern void buffer_clear(Buffer * ) ;
#line 31
extern void buffer_free(Buffer * ) ;
#line 37
extern void *buffer_append_space(Buffer * , u_int  ) ;
#line 39
extern void buffer_get(Buffer * , void * , u_int  ) ;
#line 37 "/home/pronto/abs/test-suite/openssh-4.3p2/dh.h"
extern DH *dh_new_group(BIGNUM * , BIGNUM * ) ;
#line 72 "/home/pronto/abs/test-suite/openssh-4.3p2/cipher.h"
extern Cipher *cipher_by_name(char const   * ) ;
#line 74 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
extern Key *key_from_blob(u_char const   * , u_int  ) ;
#line 29 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.h"
char *forced_command ;
#line 34
void auth_clear_options(void) ;
#line 22 "/home/pronto/abs/test-suite/openssh-4.3p2/bufaux.h"
extern void buffer_put_bignum2(Buffer * , BIGNUM const   * ) ;
#line 24
extern void buffer_get_bignum2(Buffer * , BIGNUM * ) ;
#line 29
extern u_int buffer_get_int(Buffer * ) ;
#line 30
extern void buffer_put_int(Buffer * , u_int  ) ;
#line 33
extern void buffer_put_int64(Buffer * , u_int64_t  ) ;
#line 35
extern int buffer_get_char(Buffer * ) ;
#line 36
extern void buffer_put_char(Buffer * , int  ) ;
#line 38
extern void *buffer_get_string(Buffer * , u_int * ) ;
#line 39
extern void buffer_put_string(Buffer * , void const   * , u_int  ) ;
#line 40
extern void buffer_put_cstring(Buffer * , char const   * ) ;
#line 27 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern u_int packet_get_encryption_key(u_char * ) ;
#line 29
extern u_int packet_get_protocol_flags(void) ;
#line 60
extern void ( /* format attribute */  packet_send_debug)(char const   *fmt  , ...) ;
#line 63
extern int packet_get_keyiv_len(int  ) ;
#line 64
extern void packet_get_keyiv(int  , u_char * , u_int  ) ;
#line 65
extern int packet_get_keycontext(int  , u_char * ) ;
#line 67
extern void packet_get_state(int  , u_int32_t * , u_int64_t * , u_int32_t * ) ;
#line 69
extern int packet_get_ssh1_cipher(void) ;
#line 27 "/home/pronto/abs/test-suite/openssh-4.3p2/mac.h"
extern int mac_init(Mac * , char * ) ;
#line 65 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 88 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.h"
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m ) ;
#line 89
void mm_request_receive(int sock , Buffer *m ) ;
#line 90
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m ) ;
#line 43 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.h"
int mm_is_monitor(void) ;
#line 46
void mm_inform_authserv(char *service , char *style ) ;
#line 47
struct passwd *mm_getpwnamallow(char const   *username ) ;
#line 48
char *mm_auth2_read_banner(void) ;
#line 49
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) ;
#line 50
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) ;
#line 51
int mm_user_key_allowed(struct passwd *pw , Key *key ) ;
#line 52
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 53
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) ;
#line 54
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) ;
#line 55
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 56
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) ;
#line 57
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) ;
#line 84
void mm_terminate(void) ;
#line 85
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 86
void mm_session_pty_cleanup2(struct Session *s ) ;
#line 89
void mm_ssh1_session_id(u_char *session_id___0 ) ;
#line 90
int mm_ssh1_session_key(BIGNUM *num ) ;
#line 93
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) ;
#line 94
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) ;
#line 98
void mm_send_keystate(struct monitor *monitor ) ;
#line 101
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) ;
#line 102
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) ;
#line 25 "/home/pronto/abs/test-suite/openssh-4.3p2/xmalloc.h"
extern char *xstrdup(char const   * ) ;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_fdpass.h"
extern int mm_receive_fd(int  ) ;
#line 67 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
extern int compat20 ;
#line 68
extern Newkeys *newkeys[] ;
#line 69
extern z_stream incoming_stream ;
#line 70
extern z_stream outgoing_stream ;
#line 71
struct monitor *pmonitor ;
#line 72
extern Buffer input ;
#line 72
extern Buffer output ;
#line 76 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_is_monitor(void) 
{ 
  int tmp ;

  {
#line 83
  if (pmonitor) {
#line 83
    if (pmonitor->m_pid > 0) {
#line 83
      tmp = 1;
    } else {
#line 83
      tmp = 0;
    }
  } else {
#line 83
    tmp = 0;
  }
#line 83
  return (tmp);
}
}
#line 86 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_request_send(int sock , enum monitor_reqtype type , Buffer *m ) 
{ 
  u_int mlen ;
  u_int tmp ;
  u_char buf___1[5] ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 89
  tmp = buffer_len(m);
  }
#line 89
  mlen = tmp;
  {
#line 92
  debug3("%s entering: type %d", "mm_request_send", (unsigned int )type);
  }
  }
  {
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 94
    buf___1[0] = (u_char )((mlen + 1U) >> 24);
#line 94
    buf___1[1] = (u_char )((mlen + 1U) >> 16);
#line 94
    buf___1[2] = (u_char )((mlen + 1U) >> 8);
#line 94
    buf___1[3] = (u_char )(mlen + 1U);
#line 94
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 95
  buf___1[4] = (u_char )type;
  {
#line 96
  tmp___2 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, (void *)(buf___1),
                     (size_t )sizeof(buf___1));
  }
  }
#line 96
  if ((unsigned long )tmp___2 != sizeof(buf___1)) {
    {
    {
#line 97
    tmp___0 = __errno_location();
    }
    {
#line 97
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 97
    fatal("%s: write: %s", "mm_request_send", tmp___1);
    }
    }
  }
  {
  {
#line 98
  tmp___5 = buffer_ptr(m);
  }
  {
#line 98
  tmp___6 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock, tmp___5,
                     mlen);
  }
  }
#line 98
  if (tmp___6 != mlen) {
    {
    {
#line 99
    tmp___3 = __errno_location();
    }
    {
#line 99
    tmp___4 = strerror(*tmp___3);
    }
    {
#line 99
    fatal("%s: write: %s", "mm_request_send", tmp___4);
    }
    }
  }
#line 100
  return;
}
}
#line 102 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_request_receive(int sock , Buffer *m ) 
{ 
  u_char buf___1[4] ;
  u_int msg_len ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 108
  debug3("%s entering", "mm_request_receive");
  }
  {
#line 110
  tmp___2 = atomicio(& read, sock, (void *)(buf___1), (size_t )sizeof(buf___1));
  }
  }
#line 110
  if ((unsigned long )tmp___2 != sizeof(buf___1)) {
    {
    {
#line 111
    tmp = __errno_location();
    }
    }
#line 111
    if (*tmp == 32) {
      {
      {
#line 112
      cleanup_exit(255);
      }
      }
    }
    {
    {
#line 113
    tmp___0 = __errno_location();
    }
    {
#line 113
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 113
    fatal("%s: read: %s", "mm_request_receive", tmp___1);
    }
    }
  }
#line 115
  msg_len = (u_int )(((((u_long )buf___1[0] << 24) | ((u_long )buf___1[1] << 16)) | ((u_long )buf___1[2] << 8)) | (u_long )buf___1[3]);
#line 116
  if (msg_len > 262144U) {
    {
    {
#line 117
    fatal("%s: read: bad msg_len %d", "mm_request_receive", msg_len);
    }
    }
  }
  {
  {
#line 118
  buffer_clear(m);
  }
  {
#line 119
  buffer_append_space(m, msg_len);
  }
  {
#line 120
  tmp___5 = buffer_ptr(m);
  }
  {
#line 120
  tmp___6 = atomicio(& read, sock, tmp___5, msg_len);
  }
  }
#line 120
  if (tmp___6 != msg_len) {
    {
    {
#line 121
    tmp___3 = __errno_location();
    }
    {
#line 121
    tmp___4 = strerror(*tmp___3);
    }
    {
#line 121
    fatal("%s: read: %s", "mm_request_receive", tmp___4);
    }
    }
  }
#line 122
  return;
}
}
#line 124 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_request_receive_expect(int sock , enum monitor_reqtype type , Buffer *m ) 
{ 
  u_char rtype ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 129
  debug3("%s entering: type %d", "mm_request_receive_expect", (unsigned int )type);
  }
  {
#line 131
  mm_request_receive(sock, m);
  }
  {
#line 132
  tmp = buffer_get_char(m);
  }
#line 132
  rtype = (u_char )tmp;
  }
#line 133
  if ((unsigned int )rtype != (unsigned int )type) {
    {
    {
#line 134
    fatal("%s: read: rtype %d != type %d", "mm_request_receive_expect", (int )rtype,
          (unsigned int )type);
    }
    }
  }
#line 136
  return;
}
}
#line 138 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
DH *mm_choose_dh(int min , int nbits , int max ) 
{ 
  BIGNUM *p ;
  BIGNUM *g ;
  int success ;
  Buffer m ;
  u_int tmp ;
  DH *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 142
  success = 0;
  {
#line 145
  buffer_init(& m);
  }
  {
#line 146
  buffer_put_int(& m, (u_int )min);
  }
  {
#line 147
  buffer_put_int(& m, (u_int )nbits);
  }
  {
#line 148
  buffer_put_int(& m, (u_int )max);
  }
  {
#line 150
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )0, & m);
  }
  {
#line 152
  debug3("%s: waiting for MONITOR_ANS_MODULI", "mm_choose_dh");
  }
  {
#line 153
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )1, & m);
  }
  {
#line 155
  success = buffer_get_char(& m);
  }
  }
#line 156
  if (success == 0) {
    {
    {
#line 157
    fatal("%s: MONITOR_ANS_MODULI failed", "mm_choose_dh");
    }
    }
  }
  {
  {
#line 159
  p = BN_new();
  }
  }
#line 159
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 160
    fatal("%s: BN_new failed", "mm_choose_dh");
    }
    }
  }
  {
  {
#line 161
  g = BN_new();
  }
  }
#line 161
  if ((unsigned long )g == (unsigned long )((void *)0)) {
    {
    {
#line 162
    fatal("%s: BN_new failed", "mm_choose_dh");
    }
    }
  }
  {
  {
#line 163
  buffer_get_bignum2(& m, p);
  }
  {
#line 164
  buffer_get_bignum2(& m, g);
  }
  {
#line 166
  tmp = buffer_len(& m);
  }
  {
#line 166
  debug3("%s: remaining %d", "mm_choose_dh", tmp);
  }
  {
#line 167
  buffer_free(& m);
  }
  {
#line 169
  tmp___0 = dh_new_group(g, p);
  }
  }
#line 169
  return (tmp___0);
}
}
#line 172 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_key_sign(Key *key , u_char **sigp , u_int *lenp , u_char *data , u_int datalen ) 
{ 
  Kex *kex ;
  Buffer m ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 175
  kex = *(pmonitor->m_pkex);
  {
#line 178
  debug3("%s entering", "mm_key_sign");
  }
  {
#line 180
  buffer_init(& m);
  }
  {
#line 181
  tmp = (*(kex->host_key_index))(key);
  }
  {
#line 181
  buffer_put_int(& m, (u_int )tmp);
  }
  {
#line 182
  buffer_put_string(& m, (void const   *)data, datalen);
  }
  {
#line 184
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )4, & m);
  }
  {
#line 186
  debug3("%s: waiting for MONITOR_ANS_SIGN", "mm_key_sign");
  }
  {
#line 187
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )5, & m);
  }
  {
#line 188
  tmp___0 = buffer_get_string(& m, lenp);
  }
#line 188
  *sigp = (u_char *)tmp___0;
  {
#line 189
  buffer_free(& m);
  }
  }
#line 191
  return (0);
}
}
#line 194 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
struct passwd *mm_getpwnamallow(char const   *username ) 
{ 
  Buffer m ;
  struct passwd *pw ;
  u_int pwlen ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 201
  debug3("%s entering", "mm_getpwnamallow");
  }
  {
#line 203
  buffer_init(& m);
  }
  {
#line 204
  buffer_put_cstring(& m, username);
  }
  {
#line 206
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )6, & m);
  }
  {
#line 208
  debug3("%s: waiting for MONITOR_ANS_PWNAM", "mm_getpwnamallow");
  }
  {
#line 209
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )7, & m);
  }
  {
#line 211
  tmp = buffer_get_char(& m);
  }
  }
#line 211
  if (tmp == 0) {
    {
    {
#line 212
    buffer_free(& m);
    }
    }
#line 213
    return ((struct passwd *)((void *)0));
  }
  {
  {
#line 215
  tmp___0 = buffer_get_string(& m, & pwlen);
  }
#line 215
  pw = (struct passwd *)tmp___0;
  }
#line 216
  if ((unsigned long )pwlen != sizeof(struct passwd )) {
    {
    {
#line 217
    fatal("%s: struct passwd size mismatch", "mm_getpwnamallow");
    }
    }
  }
  {
  {
#line 218
  tmp___1 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 218
  pw->pw_name = (char *)tmp___1;
  {
#line 219
  tmp___2 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 219
  pw->pw_passwd = (char *)tmp___2;
  {
#line 220
  tmp___3 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 220
  pw->pw_gecos = (char *)tmp___3;
  {
#line 224
  tmp___4 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 224
  pw->pw_dir = (char *)tmp___4;
  {
#line 225
  tmp___5 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 225
  pw->pw_shell = (char *)tmp___5;
  {
#line 226
  buffer_free(& m);
  }
  }
#line 228
  return (pw);
}
}
#line 231 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
char *mm_auth2_read_banner(void) 
{ 
  Buffer m ;
  char *banner ;
  void *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 237
  debug3("%s entering", "mm_auth2_read_banner");
  }
  {
#line 239
  buffer_init(& m);
  }
  {
#line 240
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )8, & m);
  }
  {
#line 241
  buffer_clear(& m);
  }
  {
#line 243
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )9, & m);
  }
  {
#line 245
  tmp = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 245
  banner = (char *)tmp;
  {
#line 246
  buffer_free(& m);
  }
  {
#line 249
  tmp___0 = strlen((char const   *)banner);
  }
  }
#line 249
  if (tmp___0 == 0U) {
    {
    {
#line 250
    xfree((void *)banner);
    }
#line 251
    banner = (char *)((void *)0);
    }
  }
#line 253
  return (banner);
}
}
#line 258 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_inform_authserv(char *service , char *style ) 
{ 
  Buffer m ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 263
  debug3("%s entering", "mm_inform_authserv");
  }
  {
#line 265
  buffer_init(& m);
  }
  {
#line 266
  buffer_put_cstring(& m, (char const   *)service);
  }
  }
#line 267
  if (style) {
#line 267
    tmp = (char const   *)style;
  } else {
#line 267
    tmp = "";
  }
  {
  {
#line 267
  buffer_put_cstring(& m, tmp);
  }
  {
#line 269
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )3, & m);
  }
  {
#line 271
  buffer_free(& m);
  }
  }
#line 272
  return;
}
}
#line 275 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_auth_password(struct Authctxt *authctxt___0 , char *password ) 
{ 
  Buffer m ;
  int authenticated ;
  u_int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 279
  authenticated = 0;
  {
#line 281
  debug3("%s entering", "mm_auth_password");
  }
  {
#line 283
  buffer_init(& m);
  }
  {
#line 284
  buffer_put_cstring(& m, (char const   *)password);
  }
  {
#line 285
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )10, & m);
  }
  {
#line 287
  debug3("%s: waiting for MONITOR_ANS_AUTHPASSWORD", "mm_auth_password");
  }
  {
#line 288
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )11, & m);
  }
  {
#line 290
  tmp = buffer_get_int(& m);
  }
#line 290
  authenticated = (int )tmp;
  {
#line 292
  buffer_free(& m);
  }
  }
#line 294
  if (authenticated) {
#line 294
    tmp___0 = "";
  } else {
#line 294
    tmp___0 = "not ";
  }
  {
  {
#line 294
  debug3("%s: user %sauthenticated", "mm_auth_password", tmp___0);
  }
  }
#line 296
  return (authenticated);
}
}
#line 299 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_user_key_allowed(struct passwd *pw , Key *key ) 
{ 
  int tmp ;

  {
  {
  {
#line 302
  tmp = mm_key_allowed((enum mm_keytype )2, (char *)((void *)0), (char *)((void *)0),
                       key);
  }
  }
#line 302
  return (tmp);
}
}
#line 305 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_hostbased_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ 
  int tmp ;

  {
  {
  {
#line 309
  tmp = mm_key_allowed((enum mm_keytype )1, user, host, key);
  }
  }
#line 309
  return (tmp);
}
}
#line 312 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_auth_rhosts_rsa_key_allowed(struct passwd *pw , char *user , char *host , Key *key ) 
{ 
  int ret ;

  {
  {
#line 318
  key->type = 1;
  {
#line 319
  ret = mm_key_allowed((enum mm_keytype )3, user, host, key);
  }
#line 320
  key->type = 0;
  }
#line 321
  return (ret);
}
}
#line 324 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
static void mm_send_debug(Buffer *m ) 
{ 
  char *msg ;
  void *tmp ;
  u_int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 329
    tmp___0 = buffer_len(m);
    }
    }
#line 329
    if (! tmp___0) {
#line 329
      goto while_break;
    }
    {
    {
#line 330
    tmp = buffer_get_string(m, (u_int *)((void *)0));
    }
#line 330
    msg = (char *)tmp;
    {
#line 331
    debug3("%s: Sending debug: %s", "mm_send_debug", msg);
    }
    {
#line 332
    packet_send_debug("%s", msg);
    }
    {
#line 333
    xfree((void *)msg);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return;
}
}
#line 337 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_key_allowed(enum mm_keytype type , char *user , char *host , Key *key ) 
{ 
  Buffer m ;
  u_char *blob ;
  u_int len ;
  int allowed ;
  int have_forced ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 343
  allowed = 0;
#line 343
  have_forced = 0;
  {
#line 345
  debug3("%s entering", "mm_key_allowed");
  }
  {
#line 348
  tmp = key_to_blob((Key const   *)key, & blob, & len);
  }
  }
#line 348
  if (! tmp) {
#line 349
    return (0);
  }
  {
  {
#line 351
  buffer_init(& m);
  }
  {
#line 352
  buffer_put_int(& m, (u_int )type);
  }
  }
#line 353
  if (user) {
#line 353
    tmp___0 = (char const   *)user;
  } else {
#line 353
    tmp___0 = "";
  }
  {
  {
#line 353
  buffer_put_cstring(& m, tmp___0);
  }
  }
#line 354
  if (host) {
#line 354
    tmp___1 = (char const   *)host;
  } else {
#line 354
    tmp___1 = "";
  }
  {
  {
#line 354
  buffer_put_cstring(& m, tmp___1);
  }
  {
#line 355
  buffer_put_string(& m, (void const   *)blob, len);
  }
  {
#line 356
  xfree((void *)blob);
  }
  {
#line 358
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )20, & m);
  }
  {
#line 360
  debug3("%s: waiting for MONITOR_ANS_KEYALLOWED", "mm_key_allowed");
  }
  {
#line 361
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )21, & m);
  }
  {
#line 363
  tmp___2 = buffer_get_int(& m);
  }
#line 363
  allowed = (int )tmp___2;
  {
#line 366
  auth_clear_options();
  }
  {
#line 367
  tmp___3 = buffer_get_int(& m);
  }
#line 367
  have_forced = (int )tmp___3;
  }
#line 368
  if (have_forced) {
    {
    {
#line 368
    tmp___4 = xstrdup("true");
    }
#line 368
    forced_command = tmp___4;
    }
  } else {
#line 368
    forced_command = (char *)((void *)0);
  }
  {
  {
#line 371
  mm_send_debug(& m);
  }
  {
#line 373
  buffer_free(& m);
  }
  }
#line 375
  return (allowed);
}
}
#line 384 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_key_verify(Key *key , u_char *sig , u_int siglen , u_char *data , u_int datalen ) 
{ 
  Buffer m ;
  u_char *blob ;
  u_int len ;
  int verified ;
  int tmp ;
  u_int tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 390
  verified = 0;
  {
#line 392
  debug3("%s entering", "mm_key_verify");
  }
  {
#line 395
  tmp = key_to_blob((Key const   *)key, & blob, & len);
  }
  }
#line 395
  if (! tmp) {
#line 396
    return (0);
  }
  {
  {
#line 398
  buffer_init(& m);
  }
  {
#line 399
  buffer_put_string(& m, (void const   *)blob, len);
  }
  {
#line 400
  buffer_put_string(& m, (void const   *)sig, siglen);
  }
  {
#line 401
  buffer_put_string(& m, (void const   *)data, datalen);
  }
  {
#line 402
  xfree((void *)blob);
  }
  {
#line 404
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )22, & m);
  }
  {
#line 406
  debug3("%s: waiting for MONITOR_ANS_KEYVERIFY", "mm_key_verify");
  }
  {
#line 407
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )23, & m);
  }
  {
#line 409
  tmp___0 = buffer_get_int(& m);
  }
#line 409
  verified = (int )tmp___0;
  {
#line 411
  buffer_free(& m);
  }
  }
#line 413
  return (verified);
}
}
#line 417 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
struct Newkeys *mm_newkeys_from_blob(u_char *blob , int blen ) 
{ 
  Buffer b ;
  u_int len ;
  Newkeys *newkey ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  void *tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  Cipher *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  u_int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 422
  newkey = (Newkeys *)((void *)0);
  {
#line 427
  debug3("%s: %p(%d)", "mm_newkeys_from_blob", blob, blen);
  }
  {
#line 431
  buffer_init(& b);
  }
  {
#line 432
  buffer_append(& b, (void const   *)blob, (u_int )blen);
  }
  {
#line 434
  tmp = xmalloc((size_t )sizeof(*newkey));
  }
#line 434
  newkey = (Newkeys *)tmp;
#line 435
  enc = & newkey->enc;
#line 436
  mac = & newkey->mac;
#line 437
  comp = & newkey->comp;
  {
#line 440
  tmp___0 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 440
  enc->name = (char *)tmp___0;
  {
#line 441
  buffer_get(& b, (void *)(& enc->cipher), (u_int )sizeof(enc->cipher));
  }
  {
#line 442
  tmp___1 = buffer_get_int(& b);
  }
#line 442
  enc->enabled = (int )tmp___1;
  {
#line 443
  enc->block_size = buffer_get_int(& b);
  }
  {
#line 444
  tmp___2 = buffer_get_string(& b, & enc->key_len);
  }
#line 444
  enc->key = (u_char *)tmp___2;
  {
#line 445
  tmp___3 = buffer_get_string(& b, & len);
  }
#line 445
  enc->iv = (u_char *)tmp___3;
  }
#line 446
  if (len != enc->block_size) {
    {
    {
#line 447
    fatal("%s: bad ivlen: expected %u != %u", "mm_newkeys_from_blob", enc->block_size,
          len);
    }
    }
  }
#line 450
  if ((unsigned long )enc->name == (unsigned long )((void *)0)) {
    {
    {
#line 451
    fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
          enc->cipher);
    }
    }
  } else {
    {
    {
#line 450
    tmp___4 = cipher_by_name((char const   *)enc->name);
    }
    }
#line 450
    if ((unsigned long )tmp___4 != (unsigned long )enc->cipher) {
      {
      {
#line 451
      fatal("%s: bad cipher name %s or pointer %p", "mm_newkeys_from_blob", enc->name,
            enc->cipher);
      }
      }
    }
  }
  {
  {
#line 455
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 455
  mac->name = (char *)tmp___5;
  }
#line 456
  if ((unsigned long )mac->name == (unsigned long )((void *)0)) {
    {
    {
#line 457
    fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
    }
    }
  } else {
    {
    {
#line 456
    tmp___6 = mac_init(mac, mac->name);
    }
    }
#line 456
    if (tmp___6 == -1) {
      {
      {
#line 457
      fatal("%s: can not init mac %s", "mm_newkeys_from_blob", mac->name);
      }
      }
    }
  }
  {
  {
#line 458
  tmp___7 = buffer_get_int(& b);
  }
#line 458
  mac->enabled = (int )tmp___7;
  {
#line 459
  tmp___8 = buffer_get_string(& b, & len);
  }
#line 459
  mac->key = (u_char *)tmp___8;
  }
#line 460
  if (len > mac->key_len) {
    {
    {
#line 461
    fatal("%s: bad mac key length: %u > %d", "mm_newkeys_from_blob", len, mac->key_len);
    }
    }
  }
  {
#line 463
  mac->key_len = len;
  {
#line 466
  tmp___9 = buffer_get_int(& b);
  }
#line 466
  comp->type = (int )tmp___9;
  {
#line 467
  tmp___10 = buffer_get_int(& b);
  }
#line 467
  comp->enabled = (int )tmp___10;
  {
#line 468
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 468
  comp->name = (char *)tmp___11;
  {
#line 470
  len = buffer_len(& b);
  }
  }
#line 471
  if (len != 0U) {
    {
    {
#line 472
    error("newkeys_from_blob: remaining bytes in blob %u", len);
    }
    }
  }
  {
  {
#line 473
  buffer_free(& b);
  }
  }
#line 474
  return (newkey);
}
}
#line 477 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_newkeys_to_blob(int mode , u_char **blobp , u_int *lenp ) 
{ 
  Buffer b ;
  int len ;
  Enc *enc ;
  Mac *mac ;
  Comp *comp ;
  Newkeys *newkey ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 485
  newkey = newkeys[mode];
  {
#line 487
  debug3("%s: converting %p", "mm_newkeys_to_blob", newkey);
  }
  }
#line 489
  if ((unsigned long )newkey == (unsigned long )((void *)0)) {
    {
    {
#line 490
    error("%s: newkey == NULL", "mm_newkeys_to_blob");
    }
    }
#line 491
    return (0);
  }
  {
#line 493
  enc = & newkey->enc;
#line 494
  mac = & newkey->mac;
#line 495
  comp = & newkey->comp;
  {
#line 497
  buffer_init(& b);
  }
  {
#line 499
  buffer_put_cstring(& b, (char const   *)enc->name);
  }
  {
#line 501
  buffer_append(& b, (void const   *)(& enc->cipher), (u_int )sizeof(enc->cipher));
  }
  {
#line 502
  buffer_put_int(& b, (u_int )enc->enabled);
  }
  {
#line 503
  buffer_put_int(& b, enc->block_size);
  }
  {
#line 504
  buffer_put_string(& b, (void const   *)enc->key, enc->key_len);
  }
  {
#line 505
  packet_get_keyiv(mode, enc->iv, enc->block_size);
  }
  {
#line 506
  buffer_put_string(& b, (void const   *)enc->iv, enc->block_size);
  }
  {
#line 509
  buffer_put_cstring(& b, (char const   *)mac->name);
  }
  {
#line 510
  buffer_put_int(& b, (u_int )mac->enabled);
  }
  {
#line 511
  buffer_put_string(& b, (void const   *)mac->key, mac->key_len);
  }
  {
#line 514
  buffer_put_int(& b, (u_int )comp->type);
  }
  {
#line 515
  buffer_put_int(& b, (u_int )comp->enabled);
  }
  {
#line 516
  buffer_put_cstring(& b, (char const   *)comp->name);
  }
  {
#line 518
  tmp = buffer_len(& b);
  }
#line 518
  len = (int )tmp;
  }
#line 519
  if ((unsigned long )lenp != (unsigned long )((void *)0)) {
#line 520
    *lenp = (u_int )len;
  }
#line 521
  if ((unsigned long )blobp != (unsigned long )((void *)0)) {
    {
    {
#line 522
    tmp___0 = xmalloc((size_t )len);
    }
#line 522
    *blobp = (u_char *)tmp___0;
    {
#line 523
    tmp___1 = buffer_ptr(& b);
    }
    {
#line 523
    memcpy((void */* __restrict  */)*blobp, (void const   */* __restrict  */)tmp___1,
           (size_t )len);
    }
    }
  }
  {
  {
#line 525
  tmp___2 = buffer_ptr(& b);
  }
  {
#line 525
  memset(tmp___2, 0, (size_t )len);
  }
  {
#line 526
  buffer_free(& b);
  }
  }
#line 527
  return (len);
}
}
#line 530 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
static void mm_send_kex(Buffer *m , Kex *kex ) 
{ 
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  void *tmp___2 ;

  {
  {
  {
#line 533
  buffer_put_string(m, (void const   *)kex->session_id, kex->session_id_len);
  }
  {
#line 534
  buffer_put_int(m, kex->we_need);
  }
  {
#line 535
  buffer_put_int(m, (u_int )kex->hostkey_type);
  }
  {
#line 536
  buffer_put_int(m, (u_int )kex->kex_type);
  }
  {
#line 537
  tmp = buffer_len(& kex->my);
  }
  {
#line 537
  tmp___0 = buffer_ptr(& kex->my);
  }
  {
#line 537
  buffer_put_string(m, (void const   *)tmp___0, tmp);
  }
  {
#line 538
  tmp___1 = buffer_len(& kex->peer);
  }
  {
#line 538
  tmp___2 = buffer_ptr(& kex->peer);
  }
  {
#line 538
  buffer_put_string(m, (void const   *)tmp___2, tmp___1);
  }
  {
#line 539
  buffer_put_int(m, (u_int )kex->flags);
  }
  {
#line 540
  buffer_put_cstring(m, (char const   *)kex->client_version_string);
  }
  {
#line 541
  buffer_put_cstring(m, (char const   *)kex->server_version_string);
  }
  }
#line 542
  return;
}
}
#line 544 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_send_keystate(struct monitor *monitor ) 
{ 
  Buffer m ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_char iv[24] ;
  u_char *key ;
  u_int ivlen ;
  u_int keylen ;
  u_int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  u_int tmp___12 ;
  void *tmp___13 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
  {
#line 553
  buffer_init(& m);
  }
  }
#line 555
  if (! compat20) {
    {
    {
#line 560
    tmp = packet_get_protocol_flags();
    }
    {
#line 560
    buffer_put_int(& m, tmp);
    }
    {
#line 562
    tmp___0 = packet_get_ssh1_cipher();
    }
    {
#line 562
    buffer_put_int(& m, (u_int )tmp___0);
    }
    {
#line 564
    debug3("%s: Sending ssh1 KEY+IV", "mm_send_keystate");
    }
    {
#line 565
    keylen = packet_get_encryption_key((u_char *)((void *)0));
    }
    {
#line 566
    tmp___1 = xmalloc(keylen + 1U);
    }
#line 566
    key = (u_char *)tmp___1;
    {
#line 567
    keylen = packet_get_encryption_key(key);
    }
    {
#line 568
    buffer_put_string(& m, (void const   *)key, keylen);
    }
    {
#line 569
    memset((void *)key, 0, keylen);
    }
    {
#line 570
    xfree((void *)key);
    }
    {
#line 572
    tmp___2 = packet_get_keyiv_len(1);
    }
#line 572
    ivlen = (u_int )tmp___2;
    {
#line 573
    packet_get_keyiv(1, iv, ivlen);
    }
    {
#line 574
    buffer_put_string(& m, (void const   *)(iv), ivlen);
    }
    {
#line 575
    tmp___3 = packet_get_keyiv_len(1);
    }
#line 575
    ivlen = (u_int )tmp___3;
    {
#line 576
    packet_get_keyiv(0, iv, ivlen);
    }
    {
#line 577
    buffer_put_string(& m, (void const   *)(iv), ivlen);
    }
    }
#line 578
    goto skip;
  } else {
    {
    {
#line 581
    mm_send_kex(& m, *(monitor->m_pkex));
    }
    }
  }
  {
  {
#line 584
  debug3("%s: Sending new keys: %p %p", "mm_send_keystate", newkeys[1], newkeys[0]);
  }
  {
#line 588
  tmp___4 = mm_newkeys_to_blob(1, & blob, & bloblen);
  }
  }
#line 588
  if (! tmp___4) {
    {
    {
#line 589
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
    }
    }
  }
  {
  {
#line 591
  buffer_put_string(& m, (void const   *)blob, bloblen);
  }
  {
#line 592
  xfree((void *)blob);
  }
  {
#line 594
  tmp___5 = mm_newkeys_to_blob(0, & blob, & bloblen);
  }
  }
#line 594
  if (! tmp___5) {
    {
    {
#line 595
    fatal("%s: conversion of newkeys failed", "mm_send_keystate");
    }
    }
  }
  {
  {
#line 597
  buffer_put_string(& m, (void const   *)blob, bloblen);
  }
  {
#line 598
  xfree((void *)blob);
  }
  {
#line 600
  packet_get_state(1, & seqnr, & blocks, & packets);
  }
  {
#line 601
  buffer_put_int(& m, seqnr);
  }
  {
#line 602
  buffer_put_int64(& m, blocks);
  }
  {
#line 603
  buffer_put_int(& m, packets);
  }
  {
#line 604
  packet_get_state(0, & seqnr, & blocks, & packets);
  }
  {
#line 605
  buffer_put_int(& m, seqnr);
  }
  {
#line 606
  buffer_put_int64(& m, blocks);
  }
  {
#line 607
  buffer_put_int(& m, packets);
  }
  {
#line 609
  debug3("%s: New keys have been sent", "mm_send_keystate");
  }
  }
  skip: 
  {
  {
#line 612
  tmp___6 = packet_get_keycontext(1, (u_char *)((void *)0));
  }
#line 612
  plen = (u_int )tmp___6;
  {
#line 613
  tmp___7 = xmalloc(plen + 1U);
  }
#line 613
  p = (u_char *)tmp___7;
  {
#line 614
  packet_get_keycontext(1, p);
  }
  {
#line 615
  buffer_put_string(& m, (void const   *)p, plen);
  }
  {
#line 616
  xfree((void *)p);
  }
  {
#line 618
  tmp___8 = packet_get_keycontext(0, (u_char *)((void *)0));
  }
#line 618
  plen = (u_int )tmp___8;
  {
#line 619
  tmp___9 = xmalloc(plen + 1U);
  }
#line 619
  p = (u_char *)tmp___9;
  {
#line 620
  packet_get_keycontext(0, p);
  }
  {
#line 621
  buffer_put_string(& m, (void const   *)p, plen);
  }
  {
#line 622
  xfree((void *)p);
  }
  {
#line 625
  debug3("%s: Sending compression state", "mm_send_keystate");
  }
  {
#line 626
  buffer_put_string(& m, (void const   *)(& outgoing_stream), (u_int )sizeof(outgoing_stream));
  }
  {
#line 627
  buffer_put_string(& m, (void const   *)(& incoming_stream), (u_int )sizeof(incoming_stream));
  }
  {
#line 630
  tmp___10 = buffer_len(& input);
  }
  {
#line 630
  tmp___11 = buffer_ptr(& input);
  }
  {
#line 630
  buffer_put_string(& m, (void const   *)tmp___11, tmp___10);
  }
  {
#line 631
  tmp___12 = buffer_len(& output);
  }
  {
#line 631
  tmp___13 = buffer_ptr(& output);
  }
  {
#line 631
  buffer_put_string(& m, (void const   *)tmp___13, tmp___12);
  }
  {
#line 633
  mm_request_send(monitor->m_recvfd, (enum monitor_reqtype )24, & m);
  }
  {
#line 634
  debug3("%s: Finished sending state", "mm_send_keystate");
  }
  {
#line 636
  buffer_free(& m);
  }
  }
#line 637
  return;
}
}
#line 639 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ 
  Buffer m ;
  char *p ;
  char *msg ;
  int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 644
  success = 0;
  {
#line 646
  buffer_init(& m);
  }
  {
#line 647
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )25, & m);
  }
  {
#line 649
  debug3("%s: waiting for MONITOR_ANS_PTY", "mm_pty_allocate");
  }
  {
#line 650
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )26, & m);
  }
  {
#line 652
  tmp = buffer_get_int(& m);
  }
#line 652
  success = (int )tmp;
  }
#line 653
  if (success == 0) {
    {
    {
#line 654
    debug3("%s: pty alloc failed", "mm_pty_allocate");
    }
    {
#line 655
    buffer_free(& m);
    }
    }
#line 656
    return (0);
  }
  {
  {
#line 658
  tmp___0 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 658
  p = (char *)tmp___0;
  {
#line 659
  tmp___1 = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 659
  msg = (char *)tmp___1;
  {
#line 660
  buffer_free(& m);
  }
  {
#line 662
  strlcpy(namebuf, (char const   *)p, (size_t )namebuflen);
  }
  {
#line 663
  xfree((void *)p);
  }
  {
#line 665
  tmp___2 = strlen((char const   *)msg);
  }
  {
#line 665
  buffer_append(& loginmsg, (void const   *)msg, tmp___2);
  }
  {
#line 666
  xfree((void *)msg);
  }
  {
#line 668
  *ptyfd = mm_receive_fd(pmonitor->m_recvfd);
  }
  {
#line 669
  *ttyfd = mm_receive_fd(pmonitor->m_recvfd);
  }
  }
#line 672
  return (1);
}
}
#line 675 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_session_pty_cleanup2(struct Session *s ) 
{ 
  Buffer m ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 680
  if (s->ttyfd == -1) {
#line 681
    return;
  }
  {
  {
#line 682
  buffer_init(& m);
  }
  {
#line 683
  buffer_put_cstring(& m, (char const   *)(s->tty));
  }
  {
#line 684
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )27, & m);
  }
  {
#line 685
  buffer_free(& m);
  }
  {
#line 688
  tmp___1 = close(s->ptymaster);
  }
  }
#line 688
  if (tmp___1 < 0) {
    {
    {
#line 689
    tmp = __errno_location();
    }
    {
#line 689
    tmp___0 = strerror(*tmp);
    }
    {
#line 689
    error("close(s->ptymaster): %s", tmp___0);
    }
    }
  }
#line 692
  s->ttyfd = -1;
#line 693
  return;
}
}
#line 826 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_terminate(void) 
{ 
  Buffer m ;

  {
  {
  {
#line 831
  buffer_init(& m);
  }
  {
#line 832
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )58, & m);
  }
  {
#line 833
  buffer_free(& m);
  }
  }
#line 834
  return;
}
}
#line 836 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_ssh1_session_key(BIGNUM *num ) 
{ 
  int rsafail ;
  Buffer m ;
  u_int tmp ;

  {
  {
  {
#line 842
  buffer_init(& m);
  }
  {
#line 843
  buffer_put_bignum2(& m, (BIGNUM const   *)num);
  }
  {
#line 844
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )28, & m);
  }
  {
#line 846
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )29, & m);
  }
  {
#line 848
  tmp = buffer_get_int(& m);
  }
#line 848
  rsafail = (int )tmp;
  {
#line 849
  buffer_get_bignum2(& m, num);
  }
  {
#line 851
  buffer_free(& m);
  }
  }
#line 853
  return (rsafail);
}
}
#line 856 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
static void mm_chall_setup(char **name , char **infotxt , u_int *numprompts , char ***prompts ,
                           u_int **echo_on ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 860
  *name = xstrdup("");
  }
  {
#line 861
  *infotxt = xstrdup("");
  }
#line 862
  *numprompts = (u_int )1;
  {
#line 863
  tmp = xmalloc((size_t )((unsigned long )*numprompts * sizeof(char *)));
  }
#line 863
  *prompts = (char **)tmp;
  {
#line 864
  tmp___0 = xmalloc((size_t )((unsigned long )*numprompts * sizeof(u_int )));
  }
#line 864
  *echo_on = (u_int *)tmp___0;
#line 865
  *(*echo_on + 0) = (u_int )0;
  }
#line 866
  return;
}
}
#line 868 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_bsdauth_query(void *ctx , char **name , char **infotxt , u_int *numprompts ,
                     char ***prompts , u_int **echo_on ) 
{ 
  Buffer m ;
  u_int success ;
  char *challenge ;
  void *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 876
  debug3("%s: entering", "mm_bsdauth_query");
  }
  {
#line 878
  buffer_init(& m);
  }
  {
#line 879
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )12, & m);
  }
  {
#line 881
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )13, & m);
  }
  {
#line 883
  success = buffer_get_int(& m);
  }
  }
#line 884
  if (success == 0U) {
    {
    {
#line 885
    debug3("%s: no challenge", "mm_bsdauth_query");
    }
    {
#line 886
    buffer_free(& m);
    }
    }
#line 887
    return (-1);
  }
  {
  {
#line 891
  tmp = buffer_get_string(& m, (u_int *)((void *)0));
  }
#line 891
  challenge = (char *)tmp;
  {
#line 892
  buffer_free(& m);
  }
  {
#line 894
  mm_chall_setup(name, infotxt, numprompts, prompts, echo_on);
  }
#line 895
  *(*prompts + 0) = challenge;
  {
#line 897
  debug3("%s: received challenge: %s", "mm_bsdauth_query", challenge);
  }
  }
#line 899
  return (0);
}
}
#line 902 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_bsdauth_respond(void *ctx , u_int numresponses , char **responses ) 
{ 
  Buffer m ;
  int authok ;
  u_int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 908
  debug3("%s: entering", "mm_bsdauth_respond");
  }
  }
#line 909
  if (numresponses != 1U) {
#line 910
    return (-1);
  }
  {
  {
#line 912
  buffer_init(& m);
  }
  {
#line 913
  buffer_put_cstring(& m, (char const   *)*(responses + 0));
  }
  {
#line 914
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )14, & m);
  }
  {
#line 916
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )15, & m);
  }
  {
#line 919
  tmp = buffer_get_int(& m);
  }
#line 919
  authok = (int )tmp;
  {
#line 920
  buffer_free(& m);
  }
  }
#line 922
  if (authok == 0) {
#line 922
    tmp___0 = -1;
  } else {
#line 922
    tmp___0 = 0;
  }
#line 922
  return (tmp___0);
}
}
#line 991 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
void mm_ssh1_session_id(u_char *session_id___0 ) 
{ 
  Buffer m ;
  int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 997
  debug3("%s entering", "mm_ssh1_session_id");
  }
  {
#line 999
  buffer_init(& m);
  }
#line 1000
  i = 0;
  }
  {
  {
#line 1000
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1000
    if (! (i < 16)) {
#line 1000
      goto while_break;
    }
    {
    {
#line 1001
    buffer_put_char(& m, (int )*(session_id___0 + i));
    }
#line 1000
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1003
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )30, & m);
  }
  {
#line 1004
  buffer_free(& m);
  }
  }
#line 1005
  return;
}
}
#line 1007 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ 
  Buffer m ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int have_forced ;
  u_int tmp ;
  u_int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1014
  allowed = 0;
#line 1014
  have_forced = 0;
  {
#line 1016
  debug3("%s entering", "mm_auth_rsa_key_allowed");
  }
  {
#line 1018
  buffer_init(& m);
  }
  {
#line 1019
  buffer_put_bignum2(& m, (BIGNUM const   *)client_n);
  }
  {
#line 1021
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )31, & m);
  }
  {
#line 1022
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )32, & m);
  }
  {
#line 1024
  tmp = buffer_get_int(& m);
  }
#line 1024
  allowed = (int )tmp;
  {
#line 1027
  auth_clear_options();
  }
  {
#line 1028
  tmp___0 = buffer_get_int(& m);
  }
#line 1028
  have_forced = (int )tmp___0;
  }
#line 1029
  if (have_forced) {
    {
    {
#line 1029
    tmp___1 = xstrdup("true");
    }
#line 1029
    forced_command = tmp___1;
    }
  } else {
#line 1029
    forced_command = (char *)((void *)0);
  }
#line 1031
  if (allowed) {
#line 1031
    if ((unsigned long )rkey != (unsigned long )((void *)0)) {
      {
      {
#line 1032
      tmp___2 = buffer_get_string(& m, & blen);
      }
#line 1032
      blob = (u_char *)tmp___2;
      {
#line 1033
      key = key_from_blob((u_char const   *)blob, blen);
      }
      }
#line 1033
      if ((unsigned long )key == (unsigned long )((void *)0)) {
        {
        {
#line 1034
        fatal("%s: key_from_blob failed", "mm_auth_rsa_key_allowed");
        }
        }
      }
      {
#line 1035
      *rkey = key;
      {
#line 1036
      xfree((void *)blob);
      }
      }
    }
  }
  {
  {
#line 1038
  mm_send_debug(& m);
  }
  {
#line 1039
  buffer_free(& m);
  }
  }
#line 1041
  return (allowed);
}
}
#line 1044 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
BIGNUM *mm_auth_rsa_generate_challenge(Key *key ) 
{ 
  Buffer m ;
  BIGNUM *challenge ;
  u_char *blob ;
  u_int blen ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 1052
  debug3("%s entering", "mm_auth_rsa_generate_challenge");
  }
  {
#line 1054
  challenge = BN_new();
  }
  }
#line 1054
  if ((unsigned long )challenge == (unsigned long )((void *)0)) {
    {
    {
#line 1055
    fatal("%s: BN_new failed", "mm_auth_rsa_generate_challenge");
    }
    }
  }
  {
#line 1057
  key->type = 1;
  {
#line 1058
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
  }
  }
#line 1058
  if (tmp == 0) {
    {
    {
#line 1059
    fatal("%s: key_to_blob failed", "mm_auth_rsa_generate_challenge");
    }
    }
  }
  {
#line 1060
  key->type = 0;
  {
#line 1062
  buffer_init(& m);
  }
  {
#line 1063
  buffer_put_string(& m, (void const   *)blob, blen);
  }
  {
#line 1064
  xfree((void *)blob);
  }
  {
#line 1066
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )33, & m);
  }
  {
#line 1067
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )34, & m);
  }
  {
#line 1069
  buffer_get_bignum2(& m, challenge);
  }
  {
#line 1070
  buffer_free(& m);
  }
  }
#line 1072
  return (challenge);
}
}
#line 1075 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.c"
int mm_auth_rsa_verify_response(Key *key , BIGNUM *p , u_char *response ) 
{ 
  Buffer m ;
  u_char *blob ;
  u_int blen ;
  int success ;
  int tmp ;
  u_int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1081
  success = 0;
  {
#line 1083
  debug3("%s entering", "mm_auth_rsa_verify_response");
  }
#line 1085
  key->type = 1;
  {
#line 1086
  tmp = key_to_blob((Key const   *)key, & blob, & blen);
  }
  }
#line 1086
  if (tmp == 0) {
    {
    {
#line 1087
    fatal("%s: key_to_blob failed", "mm_auth_rsa_verify_response");
    }
    }
  }
  {
#line 1088
  key->type = 0;
  {
#line 1090
  buffer_init(& m);
  }
  {
#line 1091
  buffer_put_string(& m, (void const   *)blob, blen);
  }
  {
#line 1092
  buffer_put_string(& m, (void const   *)response, (u_int )16);
  }
  {
#line 1093
  xfree((void *)blob);
  }
  {
#line 1095
  mm_request_send(pmonitor->m_recvfd, (enum monitor_reqtype )35, & m);
  }
  {
#line 1096
  mm_request_receive_expect(pmonitor->m_recvfd, (enum monitor_reqtype )36, & m);
  }
  {
#line 1098
  tmp___0 = buffer_get_int(& m);
  }
#line 1098
  success = (int )tmp___0;
  {
#line 1099
  buffer_free(& m);
  }
  }
#line 1101
  return (success);
}
}
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 531 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 99
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 107 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 116 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/openbsd-compat.h"
extern void setproctitle(char const   *fmt  , ...) ;
#line 94 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/bsd-misc.h"
extern mysig_t mysignal(int sig , void (*act)(int  ) ) ;
#line 41 "./buffer.h"
extern void buffer_consume(Buffer * , u_int  ) ;
#line 60 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
extern void key_free(Key * ) ;
#line 80
extern int key_verify(Key const   * , u_char const   * , u_int  , u_char const   * ,
                      u_int  ) ;
#line 110 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int auth_password(Authctxt *authctxt___0 , char const   *password ) ;
#line 113
BIGNUM *auth_rsa_generate_challenge(Key *key ) ;
#line 114
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) ;
#line 115
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) ;
#line 117
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) ;
#line 118
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) ;
#line 119
int user_key_allowed(struct passwd *pw , Key *key ) ;
#line 143
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) ;
#line 146
int auth_root_allowed(char *method ) ;
#line 148
char *auth2_read_banner(void) ;
#line 160
struct passwd *getpwnamallow(char const   *user ) ;
#line 177
Key *get_hostkey_by_index(int ind ) ;
#line 178
Key *get_hostkey_by_type(int type ) ;
#line 179
int get_hostkey_index(Key *key ) ;
#line 180
int ssh1_session_key(BIGNUM *session_key_int ) ;
#line 187
struct passwd *fakepw(void) ;
#line 26 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_set_encryption_key(u_char const   * , u_int  , int  ) ;
#line 28
extern void packet_set_protocol_flags(u_int  ) ;
#line 62
extern void set_newkeys(int mode ) ;
#line 66
extern void packet_set_keycontext(int  , u_char * ) ;
#line 68
extern void packet_set_state(int  , u_int32_t  , u_int64_t  , u_int32_t  ) ;
#line 70
extern void packet_set_iv(int  , u_char * ) ;
#line 28 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.h"
int no_pty_flag ;
#line 24 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.h"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) ;
#line 28
void pty_setowner(struct passwd *pw , char const   *tty ) ;
#line 68 "/home/pronto/abs/test-suite/openssh-4.3p2/session.h"
void session_destroy_all(void (*closefunc)(Session * ) ) ;
#line 69
void session_pty_cleanup2(Session *s ) ;
#line 71
Session *session_new(void) ;
#line 72
Session *session_by_tty(char *tty ) ;
#line 17 "/home/pronto/abs/test-suite/openssh-4.3p2/sshlogin.h"
void record_login(pid_t pid , char const   *tty , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr , socklen_t addrlen ) ;
#line 17 "/home/pronto/abs/test-suite/openssh-4.3p2/canohost.h"
extern char const   *get_remote_name_or_ip(u_int  , int  ) ;
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
extern void ( /* format attribute */  debug2)(char const   *  , ...) ;
#line 76 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.h"
struct monitor *monitor_init(void) ;
#line 77
void monitor_reinit(struct monitor *mon ) ;
#line 78
void monitor_sync(struct monitor *pmonitor___0 ) ;
#line 81
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) ;
#line 82
void monitor_child_postauth(struct monitor *pmonitor___0 ) ;
#line 85
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) ;
#line 56 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.h"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) ;
#line 59
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) ;
#line 61
void *mm_malloc(struct mm_master *mm , size_t size ) ;
#line 63
void mm_free(struct mm_master *mm , void *address ) ;
#line 96 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.h"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) ;
#line 97
void mm_get_keystate(struct monitor *pmonitor___0 ) ;
#line 110
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) ;
#line 111
void mm_zfree(struct mm_master *mm , void *address ) ;
#line 112
void mm_init_compression(struct mm_master *mm ) ;
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_fdpass.h"
extern void mm_send_fd(int  , int  ) ;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/bufaux.h"
extern u_int64_t buffer_get_int64(Buffer * ) ;
#line 68 "/home/pronto/abs/test-suite/openssh-4.3p2/compat.h"
extern int datafellows ;
#line 73 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
ServerOptions options ;
#line 74
u_int utmp_len ;
#line 75
extern Newkeys *current_keys[] ;
#line 78
u_char session_id[16] ;
#line 80
Buffer auth_debug ;
#line 81
int auth_debug_init ;
#line 86 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct __anonstruct_child_state_81 child_state  ;
#line 109
int mm_answer_moduli(int sock , Buffer *m ) ;
#line 110
int mm_answer_sign(int sock , Buffer *m ) ;
#line 111
int mm_answer_pwnamallow(int sock , Buffer *m ) ;
#line 112
int mm_answer_auth2_read_banner(int sock , Buffer *m ) ;
#line 113
int mm_answer_authserv(int sock , Buffer *m ) ;
#line 114
int mm_answer_authpassword(int sock , Buffer *m ) ;
#line 119
int mm_answer_keyallowed(int sock , Buffer *m ) ;
#line 120
int mm_answer_keyverify(int sock , Buffer *m ) ;
#line 121
int mm_answer_pty(int sock , Buffer *m ) ;
#line 122
int mm_answer_pty_cleanup(int sock , Buffer *m ) ;
#line 123
int mm_answer_term(int sock , Buffer *req ) ;
#line 124
int mm_answer_rsa_keyallowed(int sock , Buffer *m ) ;
#line 125
int mm_answer_rsa_challenge(int sock , Buffer *m ) ;
#line 126
int mm_answer_rsa_response(int sock , Buffer *m ) ;
#line 127
int mm_answer_sesskey(int sock , Buffer *m ) ;
#line 128
int mm_answer_sessid(int sock , Buffer *m ) ;
#line 151 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static Authctxt *authctxt  ;
#line 152 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static BIGNUM *ssh1_challenge  =    (BIGNUM *)((void *)0);
#line 155 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static u_char *key_blob  =    (u_char *)((void *)0);
#line 156 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static u_int key_bloblen  =    (u_int )0;
#line 157 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static int key_blobtype  =    0;
#line 158 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static char *hostbased_cuser  =    (char *)((void *)0);
#line 159 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static char *hostbased_chost  =    (char *)((void *)0);
#line 160 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static char *auth_method  =    (char *)"unknown";
#line 161 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static u_int session_id2_len___0  =    (u_int )0;
#line 162 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static u_char *session_id2___0  =    (u_char *)((void *)0);
#line 163 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static pid_t monitor_child_pid  ;
#line 179 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct mon_table mon_dispatch_proto20[9]  = 
#line 179
  {      {(enum monitor_reqtype )0, 16, & mm_answer_moduli}, 
        {(enum monitor_reqtype )4, 16, & mm_answer_sign}, 
        {(enum monitor_reqtype )6, 16, & mm_answer_pwnamallow}, 
        {(enum monitor_reqtype )3, 16, & mm_answer_authserv}, 
        {(enum monitor_reqtype )8, 16, & mm_answer_auth2_read_banner}, 
        {(enum monitor_reqtype )10, 12, & mm_answer_authpassword}, 
        {(enum monitor_reqtype )20, 4, & mm_answer_keyallowed}, 
        {(enum monitor_reqtype )22, 12, & mm_answer_keyverify}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 216 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct mon_table mon_dispatch_postauth20[6]  = {      {(enum monitor_reqtype )0, 0, & mm_answer_moduli}, 
        {(enum monitor_reqtype )4, 0, & mm_answer_sign}, 
        {(enum monitor_reqtype )25, 0, & mm_answer_pty}, 
        {(enum monitor_reqtype )27, 0, & mm_answer_pty_cleanup}, 
        {(enum monitor_reqtype )58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 229 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct mon_table mon_dispatch_proto15[9]  = 
#line 229
  {      {(enum monitor_reqtype )6, 16, & mm_answer_pwnamallow}, 
        {(enum monitor_reqtype )28, 16, & mm_answer_sesskey}, 
        {(enum monitor_reqtype )30, 16, & mm_answer_sessid}, 
        {(enum monitor_reqtype )10, 12, & mm_answer_authpassword}, 
        {(enum monitor_reqtype )31, 4, & mm_answer_rsa_keyallowed}, 
        {(enum monitor_reqtype )20, 4, & mm_answer_keyallowed}, 
        {(enum monitor_reqtype )33, 16, & mm_answer_rsa_challenge}, 
        {(enum monitor_reqtype )35, 24, & mm_answer_rsa_response}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 260 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct mon_table mon_dispatch_postauth15[4]  = {      {(enum monitor_reqtype )25, 16, & mm_answer_pty}, 
        {(enum monitor_reqtype )27, 16, & mm_answer_pty_cleanup}, 
        {(enum monitor_reqtype )58, 0, & mm_answer_term}, 
        {(enum monitor_reqtype )0, 0, (int (*)(int  , Buffer * ))((void *)0)}};
#line 271 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct mon_table *mon_dispatch  ;
#line 275 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void monitor_permit(struct mon_table *ent , enum monitor_reqtype type , int permit ) 
{ 
  int tmp ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((unsigned long )ent->f != (unsigned long )((void *)0))) {
#line 278
      goto while_break;
    }
#line 279
    if ((unsigned int )ent->type == (unsigned int )type) {
#line 280
      ent->flags &= -4097;
#line 281
      if (permit) {
#line 281
        tmp = 4096;
      } else {
#line 281
        tmp = 0;
      }
#line 281
      ent->flags |= tmp;
#line 282
      return;
    }
#line 284
    ent ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 288 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void monitor_permit_authentications(int permit ) 
{ 
  struct mon_table *ent ;
  int tmp ;

  {
#line 291
  ent = mon_dispatch;
  {
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 293
    if (! ((unsigned long )ent->f != (unsigned long )((void *)0))) {
#line 293
      goto while_break;
    }
#line 294
    if (ent->flags & 12) {
#line 295
      ent->flags &= -4097;
#line 296
      if (permit) {
#line 296
        tmp = 4096;
      } else {
#line 296
        tmp = 0;
      }
#line 296
      ent->flags |= tmp;
    }
#line 298
    ent ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 302 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void monitor_child_preauth(struct Authctxt *_authctxt , struct monitor *pmonitor___0 ) 
{ 
  struct mon_table *ent ;
  int authenticated ;
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 306
  authenticated = 0;
  {
#line 308
  debug3("preauth child monitor started");
  }
#line 310
  authctxt = _authctxt;
  {
#line 311
  memset((void *)authctxt, 0, (size_t )sizeof(*authctxt));
  }
#line 313
  authctxt->loginmsg = & loginmsg;
  }
#line 315
  if (compat20) {
    {
#line 316
    mon_dispatch = mon_dispatch_proto20;
    {
#line 319
    monitor_permit(mon_dispatch, (enum monitor_reqtype )0, 1);
    }
    {
#line 320
    monitor_permit(mon_dispatch, (enum monitor_reqtype )4, 1);
    }
    }
  } else {
    {
#line 322
    mon_dispatch = mon_dispatch_proto15;
    {
#line 324
    monitor_permit(mon_dispatch, (enum monitor_reqtype )28, 1);
    }
    }
  }
  {
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 328
    if (! (! authenticated)) {
#line 328
      goto while_break;
    }
    {
    {
#line 329
    authenticated = monitor_read(pmonitor___0, mon_dispatch, & ent);
    }
    }
#line 330
    if (authenticated) {
#line 331
      if (! (ent->flags & 8)) {
        {
        {
#line 332
        fatal("%s: unexpected authentication from %d", "monitor_child_preauth", (unsigned int )ent->type);
        }
        }
      }
#line 334
      if ((authctxt->pw)->pw_uid == 0U) {
        {
        {
#line 334
        tmp = auth_root_allowed(auth_method);
        }
        }
#line 334
        if (! tmp) {
#line 336
          authenticated = 0;
        }
      }
    }
#line 351
    if (ent->flags & 8) {
#line 352
      if (compat20) {
#line 352
        tmp___0 = " ssh2";
      } else {
#line 352
        tmp___0 = "";
      }
      {
      {
#line 352
      auth_log(authctxt, authenticated, auth_method, (char *)tmp___0);
      }
      }
#line 354
      if (! authenticated) {
#line 355
        (authctxt->failures) ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if (! authctxt->valid) {
    {
    {
#line 360
    fatal("%s: authenticated invalid user", "monitor_child_preauth");
    }
    }
  }
  {
  {
#line 362
  debug("%s: %s has been authenticated by privileged process", "monitor_child_preauth",
        authctxt->user);
  }
  {
#line 365
  mm_get_keystate(pmonitor___0);
  }
  }
#line 366
  return;
}
}
#line 368 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void monitor_set_child_handler(pid_t pid ) 
{ 


  {
#line 371
  monitor_child_pid = pid;
#line 372
  return;
}
}
#line 374 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void monitor_child_handler(int sig ) 
{ 


  {
  {
  {
#line 377
  kill(monitor_child_pid, sig);
  }
  }
#line 378
  return;
}
}
#line 380 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void monitor_child_postauth(struct monitor *pmonitor___0 ) 
{ 


  {
  {
  {
#line 383
  monitor_set_child_handler(pmonitor___0->m_pid);
  }
  {
#line 384
  mysignal(1, & monitor_child_handler);
  }
  {
#line 385
  mysignal(15, & monitor_child_handler);
  }
  }
#line 387
  if (compat20) {
    {
#line 388
    mon_dispatch = mon_dispatch_postauth20;
    {
#line 391
    monitor_permit(mon_dispatch, (enum monitor_reqtype )0, 1);
    }
    {
#line 392
    monitor_permit(mon_dispatch, (enum monitor_reqtype )4, 1);
    }
    {
#line 393
    monitor_permit(mon_dispatch, (enum monitor_reqtype )58, 1);
    }
    }
  } else {
    {
#line 395
    mon_dispatch = mon_dispatch_postauth15;
    {
#line 396
    monitor_permit(mon_dispatch, (enum monitor_reqtype )58, 1);
    }
    }
  }
#line 398
  if (! no_pty_flag) {
    {
    {
#line 399
    monitor_permit(mon_dispatch, (enum monitor_reqtype )25, 1);
    }
    {
#line 400
    monitor_permit(mon_dispatch, (enum monitor_reqtype )27, 1);
    }
    }
  }
  {
  {
#line 403
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 404
    monitor_read(pmonitor___0, mon_dispatch, (struct mon_table **)((void *)0));
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 407 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void monitor_sync(struct monitor *pmonitor___0 ) 
{ 


  {
#line 410
  if (options.compression) {
    {
    {
#line 412
    mm_share_sync(& pmonitor___0->m_zlib, & pmonitor___0->m_zback);
    }
    }
  }
#line 414
  return;
}
}
#line 416 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int monitor_read(struct monitor *pmonitor___0 , struct mon_table *ent , struct mon_table **pent ) 
{ 
  Buffer m ;
  int ret ;
  u_char type ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 424
  buffer_init(& m);
  }
  {
#line 426
  mm_request_receive(pmonitor___0->m_sendfd, & m);
  }
  {
#line 427
  tmp = buffer_get_char(& m);
  }
#line 427
  type = (u_char )tmp;
  {
#line 429
  debug3("%s: checking request %d", "monitor_read", (int )type);
  }
  }
  {
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 431
    if (! ((unsigned long )ent->f != (unsigned long )((void *)0))) {
#line 431
      goto while_break;
    }
#line 432
    if ((unsigned int )ent->type == (unsigned int )type) {
#line 433
      goto while_break;
    }
#line 434
    ent ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  if ((unsigned long )ent->f != (unsigned long )((void *)0)) {
#line 438
    if (! (ent->flags & 4096)) {
      {
      {
#line 439
      fatal("%s: unpermitted request %d", "monitor_read", (int )type);
      }
      }
    }
    {
    {
#line 441
    ret = (*(ent->f))(pmonitor___0->m_sendfd, & m);
    }
    {
#line 442
    buffer_free(& m);
    }
    }
#line 445
    if (ent->flags & 16) {
      {
      {
#line 446
      debug2("%s: %d used once, disabling now", "monitor_read", (int )type);
      }
#line 448
      ent->flags &= -4097;
      }
    }
#line 451
    if ((unsigned long )pent != (unsigned long )((void *)0)) {
#line 452
      *pent = ent;
    }
#line 454
    return (ret);
  }
  {
  {
#line 457
  fatal("%s: unsupported request: %d", "monitor_read", (int )type);
  }
  }
#line 460
  return (-1);
}
}
#line 464 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static int monitor_allowed_key(u_char *blob , u_int bloblen ) 
{ 
  int tmp ;

  {
#line 468
  if ((unsigned long )key_blob == (unsigned long )((void *)0)) {
#line 470
    return (0);
  } else
#line 468
  if (key_bloblen != bloblen) {
#line 470
    return (0);
  } else {
    {
    {
#line 468
    tmp = memcmp((void const   *)key_blob, (void const   *)blob, key_bloblen);
    }
    }
#line 468
    if (tmp) {
#line 470
      return (0);
    }
  }
#line 471
  return (1);
}
}
#line 474 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void monitor_reset_key_state(void) 
{ 


  {
#line 478
  if ((unsigned long )key_blob != (unsigned long )((void *)0)) {
    {
    {
#line 479
    xfree((void *)key_blob);
    }
    }
  }
#line 480
  if ((unsigned long )hostbased_cuser != (unsigned long )((void *)0)) {
    {
    {
#line 481
    xfree((void *)hostbased_cuser);
    }
    }
  }
#line 482
  if ((unsigned long )hostbased_chost != (unsigned long )((void *)0)) {
    {
    {
#line 483
    xfree((void *)hostbased_chost);
    }
    }
  }
#line 484
  key_blob = (u_char *)((void *)0);
#line 485
  key_bloblen = (u_int )0;
#line 486
  key_blobtype = 0;
#line 487
  hostbased_cuser = (char *)((void *)0);
#line 488
  hostbased_chost = (char *)((void *)0);
#line 489
  return;
}
}
#line 491 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_moduli(int sock , Buffer *m ) 
{ 
  DH *dh ;
  int min ;
  int want ;
  int max ;
  u_int tmp ;
  u_int tmp___0 ;
  u_int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 497
  tmp = buffer_get_int(m);
  }
#line 497
  min = (int )tmp;
  {
#line 498
  tmp___0 = buffer_get_int(m);
  }
#line 498
  want = (int )tmp___0;
  {
#line 499
  tmp___1 = buffer_get_int(m);
  }
#line 499
  max = (int )tmp___1;
  {
#line 501
  debug3("%s: got parameters: %d %d %d", "mm_answer_moduli", min, want, max);
  }
  }
#line 504
  if (max < min) {
    {
    {
#line 505
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    }
    }
  } else
#line 504
  if (want < min) {
    {
    {
#line 505
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    }
    }
  } else
#line 504
  if (max < want) {
    {
    {
#line 505
    fatal("%s: bad parameters: %d %d %d", "mm_answer_moduli", min, want, max);
    }
    }
  }
  {
  {
#line 508
  buffer_clear(m);
  }
  {
#line 510
  dh = choose_dh(min, want, max);
  }
  }
#line 511
  if ((unsigned long )dh == (unsigned long )((void *)0)) {
    {
    {
#line 512
    buffer_put_char(m, 0);
    }
    }
#line 513
    return (0);
  } else {
    {
    {
#line 516
    buffer_put_char(m, 1);
    }
    {
#line 517
    buffer_put_bignum2(m, (BIGNUM const   *)dh->p);
    }
    {
#line 518
    buffer_put_bignum2(m, (BIGNUM const   *)dh->g);
    }
    {
#line 520
    DH_free(dh);
    }
    }
  }
  {
  {
#line 522
  mm_request_send(sock, (enum monitor_reqtype )1, m);
  }
  }
#line 523
  return (0);
}
}
#line 526 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_sign(int sock , Buffer *m ) 
{ 
  Key *key ;
  u_char *p ;
  u_char *signature ;
  u_int siglen ;
  u_int datlen ;
  int keyid ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 535
  debug3("%s", "mm_answer_sign");
  }
  {
#line 537
  tmp = buffer_get_int(m);
  }
#line 537
  keyid = (int )tmp;
  {
#line 538
  tmp___0 = buffer_get_string(m, & datlen);
  }
#line 538
  p = (u_char *)tmp___0;
  }
#line 540
  if (datlen != 20U) {
    {
    {
#line 541
    fatal("%s: data length incorrect: %u", "mm_answer_sign", datlen);
    }
    }
  }
#line 544
  if (session_id2_len___0 == 0U) {
    {
#line 545
    session_id2_len___0 = datlen;
    {
#line 546
    tmp___1 = xmalloc(session_id2_len___0);
    }
#line 546
    session_id2___0 = (u_char *)tmp___1;
    {
#line 547
    memcpy((void */* __restrict  */)session_id2___0, (void const   */* __restrict  */)p,
           session_id2_len___0);
    }
    }
  }
  {
  {
#line 550
  key = get_hostkey_by_index(keyid);
  }
  }
#line 550
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
    {
#line 551
    fatal("%s: no hostkey from index %d", "mm_answer_sign", keyid);
    }
    }
  }
  {
  {
#line 552
  tmp___2 = key_sign((Key const   *)key, & signature, & siglen, (u_char const   *)p,
                     datlen);
  }
  }
#line 552
  if (tmp___2 < 0) {
    {
    {
#line 553
    fatal("%s: key_sign failed", "mm_answer_sign");
    }
    }
  }
  {
  {
#line 555
  debug3("%s: signature %p(%u)", "mm_answer_sign", signature, siglen);
  }
  {
#line 557
  buffer_clear(m);
  }
  {
#line 558
  buffer_put_string(m, (void const   *)signature, siglen);
  }
  {
#line 560
  xfree((void *)p);
  }
  {
#line 561
  xfree((void *)signature);
  }
  {
#line 563
  mm_request_send(sock, (enum monitor_reqtype )5, m);
  }
  {
#line 566
  monitor_permit(mon_dispatch, (enum monitor_reqtype )6, 1);
  }
  }
#line 568
  return (0);
}
}
#line 573 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_pwnamallow(int sock , Buffer *m ) 
{ 
  char *username ;
  struct passwd *pwent ;
  int allowed ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 578
  allowed = 0;
  {
#line 580
  debug3("%s", "mm_answer_pwnamallow");
  }
#line 582
  tmp = authctxt->attempt;
#line 582
  (authctxt->attempt) ++;
  }
#line 582
  if (tmp != 0) {
    {
    {
#line 583
    fatal("%s: multiple attempts for getpwnam", "mm_answer_pwnamallow");
    }
    }
  }
  {
  {
#line 585
  tmp___0 = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 585
  username = (char *)tmp___0;
  {
#line 587
  pwent = getpwnamallow((char const   *)username);
  }
  {
#line 589
  authctxt->user = xstrdup((char const   *)username);
  }
  }
#line 590
  if (pwent) {
#line 590
    tmp___1 = (char const   *)username;
  } else {
#line 590
    tmp___1 = "unknown";
  }
  {
  {
#line 590
  setproctitle("%s [priv]", tmp___1);
  }
  {
#line 591
  xfree((void *)username);
  }
  {
#line 593
  buffer_clear(m);
  }
  }
#line 595
  if ((unsigned long )pwent == (unsigned long )((void *)0)) {
    {
    {
#line 596
    buffer_put_char(m, 0);
    }
    {
#line 597
    authctxt->pw = fakepw();
    }
    }
#line 598
    goto out;
  }
  {
#line 601
  allowed = 1;
#line 602
  authctxt->pw = pwent;
#line 603
  authctxt->valid = 1;
  {
#line 605
  buffer_put_char(m, 1);
  }
  {
#line 606
  buffer_put_string(m, (void const   *)pwent, (u_int )sizeof(struct passwd ));
  }
  {
#line 607
  buffer_put_cstring(m, (char const   *)pwent->pw_name);
  }
  {
#line 608
  buffer_put_cstring(m, "*");
  }
  {
#line 609
  buffer_put_cstring(m, (char const   *)pwent->pw_gecos);
  }
  {
#line 613
  buffer_put_cstring(m, (char const   *)pwent->pw_dir);
  }
  {
#line 614
  buffer_put_cstring(m, (char const   *)pwent->pw_shell);
  }
  }
  out: 
  {
  {
#line 617
  debug3("%s: sending MONITOR_ANS_PWNAM: %d", "mm_answer_pwnamallow", allowed);
  }
  {
#line 618
  mm_request_send(sock, (enum monitor_reqtype )7, m);
  }
  }
#line 621
  if (! compat20) {
    {
    {
#line 622
    monitor_permit_authentications(1);
    }
    }
  } else {
    {
    {
#line 625
    monitor_permit(mon_dispatch, (enum monitor_reqtype )3, 1);
    }
    {
#line 626
    monitor_permit(mon_dispatch, (enum monitor_reqtype )8, 1);
    }
    }
  }
#line 637
  return (0);
}
}
#line 640 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_auth2_read_banner(int sock , Buffer *m ) 
{ 
  char *banner ;
  char const   *tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 644
  buffer_clear(m);
  }
  {
#line 645
  banner = auth2_read_banner();
  }
  }
#line 646
  if ((unsigned long )banner != (unsigned long )((void *)0)) {
#line 646
    tmp = (char const   *)banner;
  } else {
#line 646
    tmp = "";
  }
  {
  {
#line 646
  buffer_put_cstring(m, tmp);
  }
  {
#line 647
  mm_request_send(sock, (enum monitor_reqtype )9, m);
  }
  }
#line 649
  if ((unsigned long )banner != (unsigned long )((void *)0)) {
    {
    {
#line 650
    xfree((void *)banner);
    }
    }
  }
#line 652
  return (0);
}
}
#line 655 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_authserv(int sock , Buffer *m ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 658
  monitor_permit_authentications(1);
  }
  {
#line 660
  tmp = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 660
  authctxt->service = (char *)tmp;
  {
#line 661
  tmp___0 = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 661
  authctxt->style = (char *)tmp___0;
  {
#line 662
  debug3("%s: service=%s, style=%s", "mm_answer_authserv", authctxt->service, authctxt->style);
  }
  {
#line 665
  tmp___1 = strlen((char const   *)authctxt->style);
  }
  }
#line 665
  if (tmp___1 == 0U) {
    {
    {
#line 666
    xfree((void *)authctxt->style);
    }
#line 667
    authctxt->style = (char *)((void *)0);
    }
  }
#line 670
  return (0);
}
}
#line 676 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static int call_count  ;
#line 673 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_authpassword(int sock , Buffer *m ) 
{ 
  char *passwd ;
  int authenticated ;
  u_int plen ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 681
  tmp = buffer_get_string(m, & plen);
  }
#line 681
  passwd = (char *)tmp;
  }
#line 683
  if (options.password_authentication) {
    {
    {
#line 683
    tmp___0 = auth_password(authctxt, (char const   *)passwd);
    }
    }
#line 683
    if (tmp___0) {
#line 683
      tmp___1 = 1;
    } else {
#line 683
      tmp___1 = 0;
    }
  } else {
#line 683
    tmp___1 = 0;
  }
  {
#line 683
  authenticated = tmp___1;
  {
#line 685
  tmp___2 = strlen((char const   *)passwd);
  }
  {
#line 685
  memset((void *)passwd, 0, tmp___2);
  }
  {
#line 686
  xfree((void *)passwd);
  }
  {
#line 688
  buffer_clear(m);
  }
  {
#line 689
  buffer_put_int(m, (u_int )authenticated);
  }
  {
#line 691
  debug3("%s: sending result %d", "mm_answer_authpassword", authenticated);
  }
  {
#line 692
  mm_request_send(sock, (enum monitor_reqtype )11, m);
  }
#line 694
  call_count ++;
  }
#line 695
  if (plen == 0U) {
#line 695
    if (call_count == 1) {
#line 696
      auth_method = (char *)"none";
    } else {
#line 698
      auth_method = (char *)"password";
    }
  } else {
#line 698
    auth_method = (char *)"password";
  }
#line 701
  return (authenticated);
}
}
#line 942 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void mm_append_debug(Buffer *m ) 
{ 
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 945
  if (auth_debug_init) {
    {
    {
#line 945
    tmp___1 = buffer_len(& auth_debug);
    }
    }
#line 945
    if (tmp___1) {
      {
      {
#line 946
      debug3("%s: Appending debug messages for child", "mm_append_debug");
      }
      {
#line 947
      tmp = buffer_len(& auth_debug);
      }
      {
#line 947
      tmp___0 = buffer_ptr(& auth_debug);
      }
      {
#line 947
      buffer_append(m, (void const   *)tmp___0, tmp);
      }
      {
#line 949
      buffer_clear(& auth_debug);
      }
      }
    }
  }
#line 951
  return;
}
}
#line 953 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_keyallowed(int sock , Buffer *m ) 
{ 
  Key *key ;
  char *cuser ;
  char *chost ;
  u_char *blob ;
  u_int bloblen ;
  enum mm_keytype type ;
  int allowed ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 960
  type = (enum mm_keytype )0;
#line 961
  allowed = 0;
  {
#line 963
  debug3("%s entering", "mm_answer_keyallowed");
  }
  {
#line 965
  tmp = buffer_get_int(m);
  }
#line 965
  type = (enum mm_keytype )tmp;
  {
#line 966
  tmp___0 = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 966
  cuser = (char *)tmp___0;
  {
#line 967
  tmp___1 = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 967
  chost = (char *)tmp___1;
  {
#line 968
  tmp___2 = buffer_get_string(m, & bloblen);
  }
#line 968
  blob = (u_char *)tmp___2;
  {
#line 970
  key = key_from_blob((u_char const   *)blob, bloblen);
  }
  }
#line 972
  if (compat20) {
#line 972
    if ((unsigned int )type == 3U) {
      {
      {
#line 974
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
      }
    } else {
#line 972
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 972
  if (! compat20) {
#line 972
    if ((unsigned int )type != 3U) {
      {
      {
#line 974
      fatal("%s: key type and protocol mismatch", "mm_answer_keyallowed");
      }
      }
    }
  }
  {
  {
#line 976
  debug3("%s: key_from_blob: %p", "mm_answer_keyallowed", key);
  }
  }
#line 978
  if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 978
    if (authctxt->valid) {
      {
#line 980
      if ((unsigned int )type == 2U) {
#line 980
        goto case_2;
      }
#line 984
      if ((unsigned int )type == 1U) {
#line 984
        goto case_1;
      }
#line 989
      if ((unsigned int )type == 3U) {
#line 989
        goto case_3;
      }
#line 995
      goto switch_default;
      case_2: /* CIL Label */ 
#line 981
      if (options.pubkey_authentication) {
        {
        {
#line 981
        tmp___3 = user_key_allowed(authctxt->pw, key);
        }
        }
#line 981
        if (tmp___3) {
#line 981
          tmp___4 = 1;
        } else {
#line 981
          tmp___4 = 0;
        }
      } else {
#line 981
        tmp___4 = 0;
      }
#line 981
      allowed = tmp___4;
#line 983
      goto switch_break;
      case_1: /* CIL Label */ 
#line 985
      if (options.hostbased_authentication) {
        {
        {
#line 985
        tmp___5 = hostbased_key_allowed(authctxt->pw, (char const   *)cuser, chost,
                                        key);
        }
        }
#line 985
        if (tmp___5) {
#line 985
          tmp___6 = 1;
        } else {
#line 985
          tmp___6 = 0;
        }
      } else {
#line 985
        tmp___6 = 0;
      }
#line 985
      allowed = tmp___6;
#line 988
      goto switch_break;
      case_3: /* CIL Label */ 
#line 990
      key->type = 0;
#line 991
      if (options.rhosts_rsa_authentication) {
        {
        {
#line 991
        tmp___7 = auth_rhosts_rsa_key_allowed(authctxt->pw, cuser, chost, key);
        }
        }
#line 991
        if (tmp___7) {
#line 991
          tmp___8 = 1;
        } else {
#line 991
          tmp___8 = 0;
        }
      } else {
#line 991
        tmp___8 = 0;
      }
#line 991
      allowed = tmp___8;
#line 994
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 996
      fatal("%s: unknown key type %d", "mm_answer_keyallowed", (unsigned int )type);
      }
      }
#line 997
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1000
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
    {
#line 1001
    key_free(key);
    }
    }
  }
  {
  {
#line 1004
  monitor_reset_key_state();
  }
  }
#line 1006
  if (allowed) {
#line 1008
    key_blob = blob;
#line 1009
    key_bloblen = bloblen;
#line 1010
    key_blobtype = (int )type;
#line 1011
    hostbased_cuser = cuser;
#line 1012
    hostbased_chost = chost;
  }
#line 1015
  if (allowed) {
#line 1015
    tmp___9 = "allowed";
  } else {
#line 1015
    tmp___9 = "disallowed";
  }
  {
  {
#line 1015
  debug3("%s: key %p is %s", "mm_answer_keyallowed", key, tmp___9);
  }
  {
#line 1018
  buffer_clear(m);
  }
  {
#line 1019
  buffer_put_int(m, (u_int )allowed);
  }
  {
#line 1020
  buffer_put_int(m, (u_int )((unsigned long )forced_command != (unsigned long )((void *)0)));
  }
  {
#line 1022
  mm_append_debug(m);
  }
  {
#line 1024
  mm_request_send(sock, (enum monitor_reqtype )21, m);
  }
  }
#line 1026
  if ((unsigned int )type == 3U) {
    {
    {
#line 1027
    monitor_permit(mon_dispatch, (enum monitor_reqtype )33, allowed);
    }
    }
  }
#line 1029
  return (0);
}
}
#line 1032 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static int monitor_valid_userblob(u_char *data , u_int datalen ) 
{ 
  Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  u_int l ;
  u_int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  u_int l___0 ;
  u_int tmp___11 ;
  u_int l___1 ;
  u_int tmp___12 ;
  u_int tmp___13 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 1038
  fail = 0;
  {
#line 1040
  buffer_init(& b);
  }
  {
#line 1041
  buffer_append(& b, (void const   *)data, datalen);
  }
  }
#line 1043
  if (datafellows & 16) {
    {
    {
#line 1044
    tmp = buffer_ptr(& b);
    }
#line 1044
    p = (char *)tmp;
    {
#line 1045
    len = buffer_len(& b);
    }
    }
#line 1046
    if ((unsigned long )session_id2___0 == (unsigned long )((void *)0)) {
#line 1049
      fail ++;
    } else
#line 1046
    if (len < session_id2_len___0) {
#line 1049
      fail ++;
    } else {
      {
      {
#line 1046
      tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
      }
      }
#line 1046
      if (tmp___0 != 0) {
#line 1049
        fail ++;
      }
    }
    {
    {
#line 1050
    buffer_consume(& b, session_id2_len___0);
    }
    }
  } else {
    {
    {
#line 1052
    tmp___1 = buffer_get_string(& b, & len);
    }
#line 1052
    p = (char *)tmp___1;
    }
#line 1053
    if ((unsigned long )session_id2___0 == (unsigned long )((void *)0)) {
#line 1056
      fail ++;
    } else
#line 1053
    if (len != session_id2_len___0) {
#line 1056
      fail ++;
    } else {
      {
      {
#line 1053
      tmp___2 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
      }
      }
#line 1053
      if (tmp___2 != 0) {
#line 1056
        fail ++;
      }
    }
    {
    {
#line 1057
    xfree((void *)p);
    }
    }
  }
  {
  {
#line 1059
  tmp___3 = buffer_get_char(& b);
  }
  }
#line 1059
  if (tmp___3 != 50) {
#line 1060
    fail ++;
  }
  {
  {
#line 1061
  tmp___4 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 1061
  p = (char *)tmp___4;
  {
#line 1062
  tmp___5 = strcmp((char const   *)authctxt->user, (char const   *)p);
  }
  }
#line 1062
  if (tmp___5 != 0) {
    {
    {
#line 1063
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
    }
#line 1065
    fail ++;
    }
  }
  {
  {
#line 1067
  xfree((void *)p);
  }
  }
  {
  {
#line 1068
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1068
    tmp___6 = buffer_get_int(& b);
    }
#line 1068
    l = tmp___6;
    {
#line 1068
    buffer_consume(& b, l);
    }
    }
#line 1068
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  if (datafellows & 32) {
    {
    {
#line 1070
    tmp___7 = buffer_get_char(& b);
    }
    }
#line 1070
    if (! tmp___7) {
#line 1071
      fail ++;
    }
  } else {
    {
    {
#line 1073
    tmp___8 = buffer_get_string(& b, (u_int *)((void *)0));
    }
#line 1073
    p = (char *)tmp___8;
    {
#line 1074
    tmp___9 = strcmp("publickey", (char const   *)p);
    }
    }
#line 1074
    if (tmp___9 != 0) {
#line 1075
      fail ++;
    }
    {
    {
#line 1076
    xfree((void *)p);
    }
    {
#line 1077
    tmp___10 = buffer_get_char(& b);
    }
    }
#line 1077
    if (! tmp___10) {
#line 1078
      fail ++;
    }
    {
    {
#line 1079
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 1079
      tmp___11 = buffer_get_int(& b);
      }
#line 1079
      l___0 = tmp___11;
      {
#line 1079
      buffer_consume(& b, l___0);
      }
      }
#line 1079
      goto while_break___0;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  {
#line 1081
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 1081
    tmp___12 = buffer_get_int(& b);
    }
#line 1081
    l___1 = tmp___12;
    {
#line 1081
    buffer_consume(& b, l___1);
    }
    }
#line 1081
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 1082
  tmp___13 = buffer_len(& b);
  }
  }
#line 1082
  if (tmp___13 != 0U) {
#line 1083
    fail ++;
  }
  {
  {
#line 1084
  buffer_free(& b);
  }
  }
#line 1085
  return (fail == 0);
}
}
#line 1088 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static int monitor_valid_hostbasedblob(u_char *data , u_int datalen , char *cuser ,
                                       char *chost ) 
{ 
  Buffer b ;
  char *p ;
  u_int len ;
  int fail ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  u_int l ;
  u_int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  u_int l___0 ;
  u_int tmp___7 ;
  u_int l___1 ;
  u_int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  u_int tmp___13 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1095
  fail = 0;
  {
#line 1097
  buffer_init(& b);
  }
  {
#line 1098
  buffer_append(& b, (void const   *)data, datalen);
  }
  {
#line 1100
  tmp = buffer_get_string(& b, & len);
  }
#line 1100
  p = (char *)tmp;
  }
#line 1101
  if ((unsigned long )session_id2___0 == (unsigned long )((void *)0)) {
#line 1104
    fail ++;
  } else
#line 1101
  if (len != session_id2_len___0) {
#line 1104
    fail ++;
  } else {
    {
    {
#line 1101
    tmp___0 = memcmp((void const   *)p, (void const   *)session_id2___0, session_id2_len___0);
    }
    }
#line 1101
    if (tmp___0 != 0) {
#line 1104
      fail ++;
    }
  }
  {
  {
#line 1105
  xfree((void *)p);
  }
  {
#line 1107
  tmp___1 = buffer_get_char(& b);
  }
  }
#line 1107
  if (tmp___1 != 50) {
#line 1108
    fail ++;
  }
  {
  {
#line 1109
  tmp___2 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 1109
  p = (char *)tmp___2;
  {
#line 1110
  tmp___3 = strcmp((char const   *)authctxt->user, (char const   *)p);
  }
  }
#line 1110
  if (tmp___3 != 0) {
    {
    {
#line 1111
    logit("wrong user name passed to monitor: expected %s != %.100s", authctxt->user,
          p);
    }
#line 1113
    fail ++;
    }
  }
  {
  {
#line 1115
  xfree((void *)p);
  }
  }
  {
  {
#line 1116
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1116
    tmp___4 = buffer_get_int(& b);
    }
#line 1116
    l = tmp___4;
    {
#line 1116
    buffer_consume(& b, l);
    }
    }
#line 1116
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1117
  tmp___5 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 1117
  p = (char *)tmp___5;
  {
#line 1118
  tmp___6 = strcmp((char const   *)p, "hostbased");
  }
  }
#line 1118
  if (tmp___6 != 0) {
#line 1119
    fail ++;
  }
  {
  {
#line 1120
  xfree((void *)p);
  }
  }
  {
  {
#line 1121
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1121
    tmp___7 = buffer_get_int(& b);
    }
#line 1121
    l___0 = tmp___7;
    {
#line 1121
    buffer_consume(& b, l___0);
    }
    }
#line 1121
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1122
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 1122
    tmp___8 = buffer_get_int(& b);
    }
#line 1122
    l___1 = tmp___8;
    {
#line 1122
    buffer_consume(& b, l___1);
    }
    }
#line 1122
    goto while_break___1;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 1125
  tmp___9 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 1125
  p = (char *)tmp___9;
  {
#line 1126
  len = strlen((char const   *)p);
  }
  }
#line 1126
  if (len > 0U) {
#line 1126
    if ((int )*(p + (len - 1U)) == 46) {
#line 1127
      *(p + (len - 1U)) = (char )'\000';
    }
  }
  {
  {
#line 1128
  tmp___10 = strcmp((char const   *)p, (char const   *)chost);
  }
  }
#line 1128
  if (tmp___10 != 0) {
#line 1129
    fail ++;
  }
  {
  {
#line 1130
  xfree((void *)p);
  }
  {
#line 1133
  tmp___11 = buffer_get_string(& b, (u_int *)((void *)0));
  }
#line 1133
  p = (char *)tmp___11;
  {
#line 1134
  tmp___12 = strcmp((char const   *)p, (char const   *)cuser);
  }
  }
#line 1134
  if (tmp___12 != 0) {
#line 1135
    fail ++;
  }
  {
  {
#line 1136
  xfree((void *)p);
  }
  {
#line 1138
  tmp___13 = buffer_len(& b);
  }
  }
#line 1138
  if (tmp___13 != 0U) {
#line 1139
    fail ++;
  }
  {
  {
#line 1140
  buffer_free(& b);
  }
  }
#line 1141
  return (fail == 0);
}
}
#line 1144 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_keyverify(int sock , Buffer *m ) 
{ 
  Key *key ;
  u_char *signature ;
  u_char *data ;
  u_char *blob ;
  u_int signaturelen ;
  u_int datalen ;
  u_int bloblen ;
  int verified ;
  int valid_data ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 1150
  verified = 0;
#line 1151
  valid_data = 0;
  {
#line 1153
  tmp = buffer_get_string(m, & bloblen);
  }
#line 1153
  blob = (u_char *)tmp;
  {
#line 1154
  tmp___0 = buffer_get_string(m, & signaturelen);
  }
#line 1154
  signature = (u_char *)tmp___0;
  {
#line 1155
  tmp___1 = buffer_get_string(m, & datalen);
  }
#line 1155
  data = (u_char *)tmp___1;
  }
#line 1157
  if ((unsigned long )hostbased_cuser == (unsigned long )((void *)0)) {
    {
    {
#line 1159
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    }
    }
  } else
#line 1157
  if ((unsigned long )hostbased_chost == (unsigned long )((void *)0)) {
    {
    {
#line 1159
    fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
    }
    }
  } else {
    {
    {
#line 1157
    tmp___2 = monitor_allowed_key(blob, bloblen);
    }
    }
#line 1157
    if (! tmp___2) {
      {
      {
#line 1159
      fatal("%s: bad key, not previously allowed", "mm_answer_keyverify");
      }
      }
    }
  }
  {
  {
#line 1161
  key = key_from_blob((u_char const   *)blob, bloblen);
  }
  }
#line 1162
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
    {
#line 1163
    fatal("%s: bad public key blob", "mm_answer_keyverify");
    }
    }
  }
  {
#line 1166
  if (key_blobtype == 2) {
#line 1166
    goto case_2;
  }
#line 1169
  if (key_blobtype == 1) {
#line 1169
    goto case_1;
  }
#line 1173
  goto switch_default;
  case_2: /* CIL Label */ 
  {
  {
#line 1167
  valid_data = monitor_valid_userblob(data, datalen);
  }
  }
#line 1168
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 1170
  valid_data = monitor_valid_hostbasedblob(data, datalen, hostbased_cuser, hostbased_chost);
  }
  }
#line 1172
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1174
  valid_data = 0;
#line 1175
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1177
  if (! valid_data) {
    {
    {
#line 1178
    fatal("%s: bad signature data blob", "mm_answer_keyverify");
    }
    }
  }
  {
  {
#line 1180
  verified = key_verify((Key const   *)key, (u_char const   *)signature, signaturelen,
                        (u_char const   *)data, datalen);
  }
  }
#line 1181
  if (verified) {
#line 1181
    tmp___3 = "verified";
  } else {
#line 1181
    tmp___3 = "unverified";
  }
  {
  {
#line 1181
  debug3("%s: key %p signature %s", "mm_answer_keyverify", key, tmp___3);
  }
  {
#line 1184
  key_free(key);
  }
  {
#line 1185
  xfree((void *)blob);
  }
  {
#line 1186
  xfree((void *)signature);
  }
  {
#line 1187
  xfree((void *)data);
  }
  }
#line 1189
  if (key_blobtype == 2) {
#line 1189
    auth_method = (char *)"publickey";
  } else {
#line 1189
    auth_method = (char *)"hostbased";
  }
  {
  {
#line 1191
  monitor_reset_key_state();
  }
  {
#line 1193
  buffer_clear(m);
  }
  {
#line 1194
  buffer_put_int(m, (u_int )verified);
  }
  {
#line 1195
  mm_request_send(sock, (enum monitor_reqtype )23, m);
  }
  }
#line 1197
  return (verified);
}
}
#line 1200 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void mm_record_login(Session *s , struct passwd *pw ) 
{ 
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1210
  memset((void *)(& from), 0, (size_t )sizeof(from));
  }
#line 1211
  fromlen = (socklen_t )sizeof(from);
  {
#line 1212
  tmp___3 = packet_connection_is_on_socket();
  }
  }
#line 1212
  if (tmp___3) {
    {
    {
#line 1213
    tmp___1 = packet_get_connection_in();
    }
    {
#line 1213
    tmp___2 = getpeername(tmp___1, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                          (socklen_t */* __restrict  */)(& fromlen));
    }
    }
#line 1213
    if (tmp___2 < 0) {
      {
      {
#line 1215
      tmp = __errno_location();
      }
      {
#line 1215
      tmp___0 = strerror(*tmp);
      }
      {
#line 1215
      debug("getpeername: %.100s", tmp___0);
      }
      {
#line 1216
      cleanup_exit(255);
      }
      }
    }
  }
  {
  {
#line 1220
  tmp___4 = get_remote_name_or_ip(utmp_len, options.use_dns);
  }
  {
#line 1220
  record_login(s->pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
               tmp___4, (struct sockaddr *)(& from), fromlen);
  }
  }
#line 1223
  return;
}
}
#line 1225 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void mm_session_close(Session *s ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1228
  debug3("%s: session %d pid %ld", "mm_session_close", s->self, (long )s->pid);
  }
  }
#line 1229
  if (s->ttyfd != -1) {
    {
    {
#line 1230
    debug3("%s: tty %s ptyfd %d", "mm_session_close", s->tty, s->ptyfd);
    }
    {
#line 1231
    session_pty_cleanup2(s);
    }
    }
  }
#line 1233
  s->used = 0;
#line 1234
  return;
}
}
#line 1236 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_pty(int sock , Buffer *m ) 
{ 
  Session *s ;
  int res ;
  int fd0 ;
  int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 1243
  debug3("%s entering", "mm_answer_pty");
  }
  {
#line 1245
  buffer_clear(m);
  }
  {
#line 1246
  s = session_new();
  }
  }
#line 1247
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1248
    goto error;
  }
  {
#line 1249
  s->authctxt = authctxt;
#line 1250
  s->pw = authctxt->pw;
#line 1251
  s->pid = pmonitor->m_pid;
  {
#line 1252
  res = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
  }
  }
#line 1253
  if (res == 0) {
#line 1254
    goto error;
  }
  {
  {
#line 1255
  pty_setowner(authctxt->pw, (char const   *)(s->tty));
  }
  {
#line 1257
  buffer_put_int(m, (u_int )1);
  }
  {
#line 1258
  buffer_put_cstring(m, (char const   *)(s->tty));
  }
  {
#line 1261
  tmp = dup2(s->ttyfd, 0);
  }
  }
#line 1261
  if (tmp == -1) {
    {
    {
#line 1262
    fatal("%s: dup2", "mm_answer_pty");
    }
    }
  }
  {
  {
#line 1264
  mm_record_login(s, authctxt->pw);
  }
  {
#line 1267
  close(0);
  }
  {
#line 1270
  tmp___0 = buffer_len(& loginmsg);
  }
  {
#line 1270
  tmp___1 = buffer_ptr(& loginmsg);
  }
  {
#line 1270
  buffer_put_string(m, (void const   *)tmp___1, tmp___0);
  }
  {
#line 1271
  buffer_clear(& loginmsg);
  }
  {
#line 1273
  mm_request_send(sock, (enum monitor_reqtype )26, m);
  }
  {
#line 1275
  mm_send_fd(sock, s->ptyfd);
  }
  {
#line 1276
  mm_send_fd(sock, s->ttyfd);
  }
  {
#line 1279
  fd0 = open("/dev/null", 0);
  }
  }
#line 1279
  if (fd0 < 0) {
    {
    {
#line 1280
    tmp___2 = __errno_location();
    }
    {
#line 1280
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 1280
    fatal("%s: open(/dev/null): %s", "mm_answer_pty", tmp___3);
    }
    }
  }
#line 1281
  if (fd0 != 0) {
    {
    {
#line 1282
    error("%s: fd0 %d != 0", "mm_answer_pty", fd0);
    }
    }
  }
  {
  {
#line 1285
  close(s->ttyfd);
  }
#line 1286
  s->ttyfd = s->ptyfd;
#line 1288
  s->ptymaster = s->ptyfd;
  {
#line 1290
  debug3("%s: tty %s ptyfd %d", "mm_answer_pty", s->tty, s->ttyfd);
  }
  }
#line 1292
  return (0);
  error: 
#line 1295
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    {
#line 1296
    mm_session_close(s);
    }
    }
  }
  {
  {
#line 1297
  buffer_put_int(m, (u_int )0);
  }
  {
#line 1298
  mm_request_send(sock, (enum monitor_reqtype )26, m);
  }
  }
#line 1299
  return (0);
}
}
#line 1302 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_pty_cleanup(int sock , Buffer *m ) 
{ 
  Session *s ;
  char *tty ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 1308
  debug3("%s entering", "mm_answer_pty_cleanup");
  }
  {
#line 1310
  tmp = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 1310
  tty = (char *)tmp;
  {
#line 1311
  s = session_by_tty(tty);
  }
  }
#line 1311
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
    {
#line 1312
    mm_session_close(s);
    }
    }
  }
  {
  {
#line 1313
  buffer_clear(m);
  }
  {
#line 1314
  xfree((void *)tty);
  }
  }
#line 1315
  return (0);
}
}
#line 1318 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_sesskey(int sock , Buffer *m ) 
{ 
  BIGNUM *p ;
  int rsafail ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1325
  monitor_permit(mon_dispatch, (enum monitor_reqtype )28, 0);
  }
  {
#line 1327
  p = BN_new();
  }
  }
#line 1327
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 1328
    fatal("%s: BN_new", "mm_answer_sesskey");
    }
    }
  }
  {
  {
#line 1330
  buffer_get_bignum2(m, p);
  }
  {
#line 1332
  rsafail = ssh1_session_key(p);
  }
  {
#line 1334
  buffer_clear(m);
  }
  {
#line 1335
  buffer_put_int(m, (u_int )rsafail);
  }
  {
#line 1336
  buffer_put_bignum2(m, (BIGNUM const   *)p);
  }
  {
#line 1338
  BN_clear_free(p);
  }
  {
#line 1340
  mm_request_send(sock, (enum monitor_reqtype )29, m);
  }
  {
#line 1343
  monitor_permit(mon_dispatch, (enum monitor_reqtype )30, 1);
  }
  }
#line 1345
  return (0);
}
}
#line 1348 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_sessid(int sock , Buffer *m ) 
{ 
  int i ;
  u_int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1353
  debug3("%s entering", "mm_answer_sessid");
  }
  {
#line 1355
  tmp = buffer_len(m);
  }
  }
#line 1355
  if (tmp != 16U) {
    {
    {
#line 1356
    fatal("%s: bad ssh1 session id", "mm_answer_sessid");
    }
    }
  }
#line 1357
  i = 0;
  {
  {
#line 1357
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1357
    if (! (i < 16)) {
#line 1357
      goto while_break;
    }
    {
    {
#line 1358
    tmp___0 = buffer_get_char(m);
    }
#line 1358
    session_id[i] = (u_char )tmp___0;
#line 1357
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1361
  monitor_permit(mon_dispatch, (enum monitor_reqtype )6, 1);
  }
  }
#line 1363
  return (0);
}
}
#line 1366 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_rsa_keyallowed(int sock , Buffer *m ) 
{ 
  BIGNUM *client_n ;
  Key *key ;
  u_char *blob ;
  u_int blen ;
  int allowed ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1370
  key = (Key *)((void *)0);
#line 1371
  blob = (u_char *)((void *)0);
#line 1372
  blen = (u_int )0;
#line 1373
  allowed = 0;
  {
#line 1375
  debug3("%s entering", "mm_answer_rsa_keyallowed");
  }
  }
#line 1377
  if (options.rsa_authentication) {
#line 1377
    if (authctxt->valid) {
      {
      {
#line 1378
      client_n = BN_new();
      }
      }
#line 1378
      if ((unsigned long )client_n == (unsigned long )((void *)0)) {
        {
        {
#line 1379
        fatal("%s: BN_new", "mm_answer_rsa_keyallowed");
        }
        }
      }
      {
      {
#line 1380
      buffer_get_bignum2(m, client_n);
      }
      {
#line 1381
      allowed = auth_rsa_key_allowed(authctxt->pw, client_n, & key);
      }
      {
#line 1382
      BN_clear_free(client_n);
      }
      }
    }
  }
  {
  {
#line 1384
  buffer_clear(m);
  }
  {
#line 1385
  buffer_put_int(m, (u_int )allowed);
  }
  {
#line 1386
  buffer_put_int(m, (u_int )((unsigned long )forced_command != (unsigned long )((void *)0)));
  }
  {
#line 1389
  monitor_reset_key_state();
  }
  }
#line 1391
  if (allowed) {
#line 1391
    if ((unsigned long )key != (unsigned long )((void *)0)) {
      {
#line 1392
      key->type = 1;
      {
#line 1393
      tmp = key_to_blob((Key const   *)key, & blob, & blen);
      }
      }
#line 1393
      if (tmp == 0) {
        {
        {
#line 1394
        fatal("%s: key_to_blob failed", "mm_answer_rsa_keyallowed");
        }
        }
      }
      {
      {
#line 1395
      buffer_put_string(m, (void const   *)blob, blen);
      }
#line 1398
      key_blob = blob;
#line 1399
      key_bloblen = blen;
#line 1400
      key_blobtype = 4;
      }
    }
  }
#line 1402
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
    {
#line 1403
    key_free(key);
    }
    }
  }
  {
  {
#line 1405
  mm_append_debug(m);
  }
  {
#line 1407
  mm_request_send(sock, (enum monitor_reqtype )32, m);
  }
  {
#line 1409
  monitor_permit(mon_dispatch, (enum monitor_reqtype )33, allowed);
  }
  {
#line 1410
  monitor_permit(mon_dispatch, (enum monitor_reqtype )35, 0);
  }
  }
#line 1411
  return (0);
}
}
#line 1414 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_rsa_challenge(int sock , Buffer *m ) 
{ 
  Key *key ;
  u_char *blob ;
  u_int blen ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 1417
  key = (Key *)((void *)0);
  {
#line 1421
  debug3("%s entering", "mm_answer_rsa_challenge");
  }
  }
#line 1423
  if (! authctxt->valid) {
    {
    {
#line 1424
    fatal("%s: authctxt not valid", "mm_answer_rsa_challenge");
    }
    }
  }
  {
  {
#line 1425
  tmp = buffer_get_string(m, & blen);
  }
#line 1425
  blob = (u_char *)tmp;
  {
#line 1426
  tmp___0 = monitor_allowed_key(blob, blen);
  }
  }
#line 1426
  if (! tmp___0) {
    {
    {
#line 1427
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_challenge");
    }
    }
  }
#line 1428
  if (key_blobtype != 4) {
#line 1428
    if (key_blobtype != 3) {
      {
      {
#line 1429
      fatal("%s: key type mismatch", "mm_answer_rsa_challenge");
      }
      }
    }
  }
  {
  {
#line 1430
  key = key_from_blob((u_char const   *)blob, blen);
  }
  }
#line 1430
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
    {
#line 1431
    fatal("%s: received bad key", "mm_answer_rsa_challenge");
    }
    }
  }
#line 1433
  if (ssh1_challenge) {
    {
    {
#line 1434
    BN_clear_free(ssh1_challenge);
    }
    }
  }
  {
  {
#line 1435
  ssh1_challenge = auth_rsa_generate_challenge(key);
  }
  {
#line 1437
  buffer_clear(m);
  }
  {
#line 1438
  buffer_put_bignum2(m, (BIGNUM const   *)ssh1_challenge);
  }
  {
#line 1440
  debug3("%s sending reply", "mm_answer_rsa_challenge");
  }
  {
#line 1441
  mm_request_send(sock, (enum monitor_reqtype )34, m);
  }
  {
#line 1443
  monitor_permit(mon_dispatch, (enum monitor_reqtype )35, 1);
  }
  {
#line 1445
  xfree((void *)blob);
  }
  {
#line 1446
  key_free(key);
  }
  }
#line 1447
  return (0);
}
}
#line 1450 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_rsa_response(int sock , Buffer *m ) 
{ 
  Key *key ;
  u_char *blob ;
  u_char *response ;
  u_int blen ;
  u_int len ;
  int success ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 1453
  key = (Key *)((void *)0);
  {
#line 1458
  debug3("%s entering", "mm_answer_rsa_response");
  }
  }
#line 1460
  if (! authctxt->valid) {
    {
    {
#line 1461
    fatal("%s: authctxt not valid", "mm_answer_rsa_response");
    }
    }
  }
#line 1462
  if ((unsigned long )ssh1_challenge == (unsigned long )((void *)0)) {
    {
    {
#line 1463
    fatal("%s: no ssh1_challenge", "mm_answer_rsa_response");
    }
    }
  }
  {
  {
#line 1465
  tmp = buffer_get_string(m, & blen);
  }
#line 1465
  blob = (u_char *)tmp;
  {
#line 1466
  tmp___0 = monitor_allowed_key(blob, blen);
  }
  }
#line 1466
  if (! tmp___0) {
    {
    {
#line 1467
    fatal("%s: bad key, not previously allowed", "mm_answer_rsa_response");
    }
    }
  }
#line 1468
  if (key_blobtype != 4) {
#line 1468
    if (key_blobtype != 3) {
      {
      {
#line 1469
      fatal("%s: key type mismatch: %d", "mm_answer_rsa_response", key_blobtype);
      }
      }
    }
  }
  {
  {
#line 1470
  key = key_from_blob((u_char const   *)blob, blen);
  }
  }
#line 1470
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
    {
#line 1471
    fatal("%s: received bad key", "mm_answer_rsa_response");
    }
    }
  }
  {
  {
#line 1472
  tmp___1 = buffer_get_string(m, & len);
  }
#line 1472
  response = (u_char *)tmp___1;
  }
#line 1473
  if (len != 16U) {
    {
    {
#line 1474
    fatal("%s: received bad response to challenge", "mm_answer_rsa_response");
    }
    }
  }
  {
  {
#line 1475
  success = auth_rsa_verify_response(key, ssh1_challenge, response);
  }
  {
#line 1477
  xfree((void *)blob);
  }
  {
#line 1478
  key_free(key);
  }
  {
#line 1479
  xfree((void *)response);
  }
  }
#line 1481
  if (key_blobtype == 4) {
#line 1481
    auth_method = (char *)"rsa";
  } else {
#line 1481
    auth_method = (char *)"rhosts-rsa";
  }
  {
  {
#line 1484
  BN_clear_free(ssh1_challenge);
  }
#line 1485
  ssh1_challenge = (BIGNUM *)((void *)0);
  {
#line 1486
  monitor_reset_key_state();
  }
  {
#line 1488
  buffer_clear(m);
  }
  {
#line 1489
  buffer_put_int(m, (u_int )success);
  }
  {
#line 1490
  mm_request_send(sock, (enum monitor_reqtype )36, m);
  }
  }
#line 1492
  return (success);
}
}
#line 1495 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
int mm_answer_term(int sock , Buffer *req ) 
{ 
  int res ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  union __anonunion___u_83 __u___0 ;
  union __anonunion___u_84 __u___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1501
  debug3("%s: tearing down sessions", "mm_answer_term");
  }
  {
#line 1504
  session_destroy_all(& mm_session_close);
  }
  }
  {
  {
#line 1506
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1506
    tmp___0 = waitpid(pmonitor->m_pid, & status, 0);
    }
    }
#line 1506
    if (! (tmp___0 == -1)) {
#line 1506
      goto while_break;
    }
    {
    {
#line 1507
    tmp = __errno_location();
    }
    }
#line 1507
    if (*tmp != 4) {
      {
      {
#line 1508
      exit(1);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1510
  __u___1.__in = status;
#line 1510
  if ((__u___1.__i & 127) == 0) {
#line 1510
    __u___0.__in = status;
#line 1510
    res = (__u___0.__i & 65280) >> 8;
  } else {
#line 1510
    res = 1;
  }
  {
  {
#line 1513
  exit(res);
  }
  }
}
}
#line 1558 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void monitor_apply_keystate(struct monitor *pmonitor___0 ) 
{ 


  {
#line 1561
  if (compat20) {
    {
    {
#line 1562
    set_newkeys(0);
    }
    {
#line 1563
    set_newkeys(1);
    }
    }
  } else {
    {
    {
#line 1565
    packet_set_protocol_flags((u_int )child_state.ssh1protoflags);
    }
    {
#line 1566
    packet_set_encryption_key((u_char const   *)child_state.ssh1key, child_state.ssh1keylen,
                              child_state.ssh1cipher);
    }
    {
#line 1568
    xfree((void *)child_state.ssh1key);
    }
    }
  }
  {
  {
#line 1572
  packet_set_keycontext(1, child_state.keyout);
  }
  {
#line 1573
  xfree((void *)child_state.keyout);
  }
  {
#line 1574
  packet_set_keycontext(0, child_state.keyin);
  }
  {
#line 1575
  xfree((void *)child_state.keyin);
  }
  }
#line 1577
  if (! compat20) {
    {
    {
#line 1578
    packet_set_iv(1, child_state.ivout);
    }
    {
#line 1579
    xfree((void *)child_state.ivout);
    }
    {
#line 1580
    packet_set_iv(0, child_state.ivin);
    }
    {
#line 1581
    xfree((void *)child_state.ivin);
    }
    }
  }
  {
  {
#line 1584
  memcpy((void */* __restrict  */)(& incoming_stream), (void const   */* __restrict  */)(& child_state.incoming),
         (size_t )sizeof(incoming_stream));
  }
  {
#line 1586
  memcpy((void */* __restrict  */)(& outgoing_stream), (void const   */* __restrict  */)(& child_state.outgoing),
         (size_t )sizeof(outgoing_stream));
  }
  }
#line 1590
  if (options.compression) {
    {
    {
#line 1591
    mm_init_compression(pmonitor___0->m_zlib);
    }
    }
  }
  {
  {
#line 1595
  buffer_clear(& input);
  }
  {
#line 1596
  buffer_append(& input, (void const   *)child_state.input, child_state.ilen);
  }
  {
#line 1597
  memset((void *)child_state.input, 0, child_state.ilen);
  }
  {
#line 1598
  xfree((void *)child_state.input);
  }
  {
#line 1600
  buffer_clear(& output);
  }
  {
#line 1601
  buffer_append(& output, (void const   *)child_state.output, child_state.olen);
  }
  {
#line 1602
  memset((void *)child_state.output, 0, child_state.olen);
  }
  {
#line 1603
  xfree((void *)child_state.output);
  }
  }
#line 1604
  return;
}
}
#line 1606 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static Kex *mm_get_kex(Buffer *m ) 
{ 
  Kex *kex ;
  void *blob ;
  u_int bloblen ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  u_int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1613
  tmp = xmalloc((size_t )sizeof(*kex));
  }
#line 1613
  kex = (Kex *)tmp;
  {
#line 1614
  memset((void *)kex, 0, (size_t )sizeof(*kex));
  }
  {
#line 1615
  tmp___0 = buffer_get_string(m, & kex->session_id_len);
  }
#line 1615
  kex->session_id = (u_char *)tmp___0;
  }
#line 1616
  if ((unsigned long )session_id2___0 == (unsigned long )((void *)0)) {
    {
    {
#line 1619
    fatal("mm_get_get: internal error: bad session id");
    }
    }
  } else
#line 1616
  if (kex->session_id_len != session_id2_len___0) {
    {
    {
#line 1619
    fatal("mm_get_get: internal error: bad session id");
    }
    }
  } else {
    {
    {
#line 1616
    tmp___1 = memcmp((void const   *)kex->session_id, (void const   *)session_id2___0,
                     session_id2_len___0);
    }
    }
#line 1616
    if (tmp___1 != 0) {
      {
      {
#line 1619
      fatal("mm_get_get: internal error: bad session id");
      }
      }
    }
  }
  {
  {
#line 1620
  kex->we_need = buffer_get_int(m);
  }
#line 1621
  kex->kex[0] = & kexdh_server;
#line 1622
  kex->kex[1] = & kexdh_server;
#line 1623
  kex->kex[2] = & kexgex_server;
#line 1624
  kex->server = 1;
  {
#line 1625
  tmp___2 = buffer_get_int(m);
  }
#line 1625
  kex->hostkey_type = (int )tmp___2;
  {
#line 1626
  tmp___3 = buffer_get_int(m);
  }
#line 1626
  kex->kex_type = (int )tmp___3;
  {
#line 1627
  blob = buffer_get_string(m, & bloblen);
  }
  {
#line 1628
  buffer_init(& kex->my);
  }
  {
#line 1629
  buffer_append(& kex->my, (void const   *)blob, bloblen);
  }
  {
#line 1630
  xfree(blob);
  }
  {
#line 1631
  blob = buffer_get_string(m, & bloblen);
  }
  {
#line 1632
  buffer_init(& kex->peer);
  }
  {
#line 1633
  buffer_append(& kex->peer, (void const   *)blob, bloblen);
  }
  {
#line 1634
  xfree(blob);
  }
#line 1635
  kex->done = 1;
  {
#line 1636
  tmp___4 = buffer_get_int(m);
  }
#line 1636
  kex->flags = (int )tmp___4;
  {
#line 1637
  tmp___5 = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 1637
  kex->client_version_string = (char *)tmp___5;
  {
#line 1638
  tmp___6 = buffer_get_string(m, (u_int *)((void *)0));
  }
#line 1638
  kex->server_version_string = (char *)tmp___6;
#line 1639
  kex->load_host_key = & get_hostkey_by_type;
#line 1640
  kex->host_key_index = & get_hostkey_index;
  }
#line 1642
  return (kex);
}
}
#line 1647 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void mm_get_keystate(struct monitor *pmonitor___0 ) 
{ 
  Buffer m ;
  u_char *blob ;
  u_char *p ;
  u_int bloblen ;
  u_int plen ;
  u_int32_t seqnr ;
  u_int32_t packets ;
  u_int64_t blocks ;
  u_int tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 1656
  debug3("%s: Waiting for new keys", "mm_get_keystate");
  }
  {
#line 1658
  buffer_init(& m);
  }
  {
#line 1659
  mm_request_receive_expect(pmonitor___0->m_sendfd, (enum monitor_reqtype )24, & m);
  }
  }
#line 1660
  if (! compat20) {
    {
    {
#line 1661
    tmp = buffer_get_int(& m);
    }
#line 1661
    child_state.ssh1protoflags = (int )tmp;
    {
#line 1662
    tmp___0 = buffer_get_int(& m);
    }
#line 1662
    child_state.ssh1cipher = (int )tmp___0;
    {
#line 1663
    tmp___1 = buffer_get_string(& m, & child_state.ssh1keylen);
    }
#line 1663
    child_state.ssh1key = (u_char *)tmp___1;
    {
#line 1665
    tmp___2 = buffer_get_string(& m, & child_state.ivoutlen);
    }
#line 1665
    child_state.ivout = (u_char *)tmp___2;
    {
#line 1667
    tmp___3 = buffer_get_string(& m, & child_state.ivinlen);
    }
#line 1667
    child_state.ivin = (u_char *)tmp___3;
    }
#line 1668
    goto skip;
  } else {
    {
    {
#line 1671
    *(pmonitor___0->m_pkex) = mm_get_kex(& m);
    }
    }
  }
  {
  {
#line 1674
  tmp___4 = buffer_get_string(& m, & bloblen);
  }
#line 1674
  blob = (u_char *)tmp___4;
  {
#line 1675
  current_keys[1] = mm_newkeys_from_blob(blob, (int )bloblen);
  }
  {
#line 1676
  xfree((void *)blob);
  }
  {
#line 1678
  debug3("%s: Waiting for second key", "mm_get_keystate");
  }
  {
#line 1679
  tmp___5 = buffer_get_string(& m, & bloblen);
  }
#line 1679
  blob = (u_char *)tmp___5;
  {
#line 1680
  current_keys[0] = mm_newkeys_from_blob(blob, (int )bloblen);
  }
  {
#line 1681
  xfree((void *)blob);
  }
  {
#line 1684
  seqnr = buffer_get_int(& m);
  }
  {
#line 1685
  blocks = buffer_get_int64(& m);
  }
  {
#line 1686
  packets = buffer_get_int(& m);
  }
  {
#line 1687
  packet_set_state(1, seqnr, blocks, packets);
  }
  {
#line 1688
  seqnr = buffer_get_int(& m);
  }
  {
#line 1689
  blocks = buffer_get_int64(& m);
  }
  {
#line 1690
  packets = buffer_get_int(& m);
  }
  {
#line 1691
  packet_set_state(0, seqnr, blocks, packets);
  }
  }
  skip: 
  {
  {
#line 1695
  tmp___6 = buffer_get_string(& m, & child_state.keyoutlen);
  }
#line 1695
  child_state.keyout = (u_char *)tmp___6;
  {
#line 1696
  tmp___7 = buffer_get_string(& m, & child_state.keyinlen);
  }
#line 1696
  child_state.keyin = (u_char *)tmp___7;
  {
#line 1698
  debug3("%s: Getting compression state", "mm_get_keystate");
  }
  {
#line 1700
  tmp___8 = buffer_get_string(& m, & plen);
  }
#line 1700
  p = (u_char *)tmp___8;
  }
#line 1701
  if ((unsigned long )plen != sizeof(child_state.outgoing)) {
    {
    {
#line 1702
    fatal("%s: bad request size", "mm_get_keystate");
    }
    }
  }
  {
  {
#line 1703
  memcpy((void */* __restrict  */)(& child_state.outgoing), (void const   */* __restrict  */)p,
         (size_t )sizeof(child_state.outgoing));
  }
  {
#line 1704
  xfree((void *)p);
  }
  {
#line 1706
  tmp___9 = buffer_get_string(& m, & plen);
  }
#line 1706
  p = (u_char *)tmp___9;
  }
#line 1707
  if ((unsigned long )plen != sizeof(child_state.incoming)) {
    {
    {
#line 1708
    fatal("%s: bad request size", "mm_get_keystate");
    }
    }
  }
  {
  {
#line 1709
  memcpy((void */* __restrict  */)(& child_state.incoming), (void const   */* __restrict  */)p,
         (size_t )sizeof(child_state.incoming));
  }
  {
#line 1710
  xfree((void *)p);
  }
  {
#line 1713
  debug3("%s: Getting Network I/O buffers", "mm_get_keystate");
  }
  {
#line 1714
  tmp___10 = buffer_get_string(& m, & child_state.ilen);
  }
#line 1714
  child_state.input = (u_char *)tmp___10;
  {
#line 1715
  tmp___11 = buffer_get_string(& m, & child_state.olen);
  }
#line 1715
  child_state.output = (u_char *)tmp___11;
  {
#line 1717
  buffer_free(& m);
  }
  }
#line 1718
  return;
}
}
#line 1722 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void *mm_zalloc(struct mm_master *mm , u_int ncount , u_int size ) 
{ 
  size_t len ;
  void *address ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1725
  len = size * ncount;
#line 1728
  if (len == 0U) {
    {
    {
#line 1729
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
    }
    }
  } else
#line 1728
  if ((unsigned long )ncount > 4294967295UL / (unsigned long )size) {
    {
    {
#line 1729
    fatal("%s: mm_zalloc(%u, %u)", "mm_zalloc", ncount, size);
    }
    }
  }
  {
  {
#line 1731
  address = mm_malloc(mm, len);
  }
  }
#line 1733
  return (address);
}
}
#line 1736 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void mm_zfree(struct mm_master *mm , void *address ) 
{ 


  {
  {
  {
#line 1739
  mm_free(mm, address);
  }
  }
#line 1740
  return;
}
}
#line 1742 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void mm_init_compression(struct mm_master *mm ) 
{ 


  {
#line 1745
  outgoing_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1746
  outgoing_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1747
  outgoing_stream.opaque = (voidpf )mm;
#line 1749
  incoming_stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& mm_zalloc);
#line 1750
  incoming_stream.zfree = (void (*)(voidpf opaque , voidpf address ))(& mm_zfree);
#line 1751
  incoming_stream.opaque = (voidpf )mm;
#line 1752
  return;
}
}
#line 1761 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
static void monitor_socketpair(int *pair ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 1765
  tmp = socketpair(1, 1, 0, (int *)pair);
  }
  }
#line 1765
  if (tmp == -1) {
    {
    {
#line 1766
    fatal("%s: socketpair", "monitor_socketpair");
    }
    }
  }
  {
  {
#line 1771
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1771
    tmp___0 = fcntl(*(pair + 0), 2, 1);
    }
    }
#line 1771
    if (tmp___0 == -1) {
      {
      {
#line 1771
      fatal("fcntl(%d, F_SETFD)", *(pair + 0));
      }
      }
    }
#line 1771
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1772
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1772
    tmp___1 = fcntl(*(pair + 1), 2, 1);
    }
    }
#line 1772
    if (tmp___1 == -1) {
      {
      {
#line 1772
      fatal("fcntl(%d, F_SETFD)", *(pair + 1));
      }
      }
    }
#line 1772
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1773
  return;
}
}
#line 1777 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
struct monitor *monitor_init(void) 
{ 
  struct monitor *mon ;
  int pair[2] ;
  void *tmp ;
  void *__cil_tmp4 ;

  {
  {
  {
#line 1783
  tmp = xmalloc((size_t )sizeof(*mon));
  }
#line 1783
  mon = (struct monitor *)tmp;
#line 1785
  mon->m_pid = 0;
  {
#line 1786
  monitor_socketpair(pair);
  }
#line 1788
  mon->m_recvfd = pair[0];
#line 1789
  mon->m_sendfd = pair[1];
  }
#line 1792
  if (options.compression) {
    {
    {
#line 1793
    mon->m_zback = mm_create((struct mm_master *)((void *)0), (size_t )65536);
    }
    {
#line 1794
    mon->m_zlib = mm_create(mon->m_zback, (size_t )1310720);
    }
    {
#line 1797
    mm_init_compression(mon->m_zlib);
    }
    }
  }
#line 1800
  return (mon);
}
}
#line 1803 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor.c"
void monitor_reinit(struct monitor *mon ) 
{ 
  int pair[2] ;
  void *__cil_tmp3 ;

  {
  {
  {
#line 1808
  monitor_socketpair(pair);
  }
#line 1810
  mon->m_recvfd = pair[0];
#line 1811
  mon->m_sendfd = pair[1];
  }
#line 1812
  return;
}
}
#line 77 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 175 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/openbsd-compat.h"
extern void *xmmap(size_t size ) ;
#line 50 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.h"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) ;
#line 50
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) ;
#line 50
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) ;
#line 57
void mm_destroy(struct mm_master *mm ) ;
#line 62
void *mm_xmalloc(struct mm_master *mm , size_t size ) ;
#line 65
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) ;
#line 38 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
static int mm_compare(struct mm_share *a , struct mm_share *b ) 
{ 
  long diff ;

  {
#line 41
  diff = (char *)a->address - (char *)b->address;
#line 43
  if (diff == 0L) {
#line 44
    return (0);
  } else
#line 45
  if (diff < 0L) {
#line 46
    return (-1);
  } else {
#line 48
    return (1);
  }
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void mmtree_RB_INSERT_COLOR(struct mmtree *head , struct mm_share *elm ) 
{ 
  struct mm_share *parent ;
  struct mm_share *gparent ;
  struct mm_share *tmp ;
  struct mm_share *tmp___0 ;
  struct mm_share *tmp___1 ;
  struct mm_share *tmp___2 ;
  struct mm_share *tmp___3 ;
  struct mm_share *tmp___4 ;
  struct mm_share *tmp___5 ;
  struct mm_share *tmp___6 ;
  struct mm_share *tmp___7 ;

  {
  {
  {
#line 51
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    parent = elm->next.rbe_parent;
#line 51
    if (parent) {
#line 51
      if (! (parent->next.rbe_color == 1)) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 51
    gparent = parent->next.rbe_parent;
#line 51
    if ((unsigned long )parent == (unsigned long )gparent->next.rbe_left) {
#line 51
      tmp = gparent->next.rbe_right;
#line 51
      if (tmp) {
#line 51
        if (tmp->next.rbe_color == 1) {
#line 51
          tmp->next.rbe_color = 0;
          {
          {
#line 51
          while (1) {
            while_continue___9: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
#line 51
            parent->next.rbe_color = 0;
#line 51
            gparent->next.rbe_color = 1;
#line 51
            goto while_break___0;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 51
          elm = gparent;
#line 51
          goto while_continue;
        }
      }
#line 51
      if ((unsigned long )parent->next.rbe_right == (unsigned long )elm) {
        {
        {
#line 51
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 51
          tmp = parent->next.rbe_right;
#line 51
          tmp___0 = tmp->next.rbe_left;
#line 51
          parent->next.rbe_right = tmp___0;
#line 51
          if (tmp___0) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp___1 = parent->next.rbe_parent;
#line 51
          tmp->next.rbe_parent = tmp___1;
#line 51
          if (tmp___1) {
#line 51
            if ((unsigned long )parent == (unsigned long )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          goto while_break___1;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 51
        tmp = parent;
#line 51
        parent = elm;
#line 51
        elm = tmp;
      }
      {
      {
#line 51
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 51
        parent->next.rbe_color = 0;
#line 51
        gparent->next.rbe_color = 1;
#line 51
        goto while_break___2;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      {
#line 51
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 51
        tmp = gparent->next.rbe_left;
#line 51
        tmp___2 = tmp->next.rbe_right;
#line 51
        gparent->next.rbe_left = tmp___2;
#line 51
        if (tmp___2) {
#line 51
          (tmp->next.rbe_right)->next.rbe_parent = gparent;
        }
#line 51
        tmp___3 = gparent->next.rbe_parent;
#line 51
        tmp->next.rbe_parent = tmp___3;
#line 51
        if (tmp___3) {
#line 51
          if ((unsigned long )gparent == (unsigned long )(gparent->next.rbe_parent)->next.rbe_left) {
#line 51
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 51
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 51
          head->rbh_root = tmp;
        }
#line 51
        tmp->next.rbe_right = gparent;
#line 51
        gparent->next.rbe_parent = tmp;
#line 51
        goto while_break___3;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 51
      tmp = gparent->next.rbe_left;
#line 51
      if (tmp) {
#line 51
        if (tmp->next.rbe_color == 1) {
#line 51
          tmp->next.rbe_color = 0;
          {
          {
#line 51
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___4: /* CIL Label */ ;
#line 51
            parent->next.rbe_color = 0;
#line 51
            gparent->next.rbe_color = 1;
#line 51
            goto while_break___4;
          }
          while_break___13: /* CIL Label */ ;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 51
          elm = gparent;
#line 51
          goto while_continue;
        }
      }
#line 51
      if ((unsigned long )parent->next.rbe_left == (unsigned long )elm) {
        {
        {
#line 51
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 51
          tmp = parent->next.rbe_left;
#line 51
          tmp___4 = tmp->next.rbe_right;
#line 51
          parent->next.rbe_left = tmp___4;
#line 51
          if (tmp___4) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp___5 = parent->next.rbe_parent;
#line 51
          tmp->next.rbe_parent = tmp___5;
#line 51
          if (tmp___5) {
#line 51
            if ((unsigned long )parent == (unsigned long )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          goto while_break___5;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 51
        tmp = parent;
#line 51
        parent = elm;
#line 51
        elm = tmp;
      }
      {
      {
#line 51
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 51
        parent->next.rbe_color = 0;
#line 51
        gparent->next.rbe_color = 1;
#line 51
        goto while_break___6;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      {
#line 51
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 51
        tmp = gparent->next.rbe_right;
#line 51
        tmp___6 = tmp->next.rbe_left;
#line 51
        gparent->next.rbe_right = tmp___6;
#line 51
        if (tmp___6) {
#line 51
          (tmp->next.rbe_left)->next.rbe_parent = gparent;
        }
#line 51
        tmp___7 = gparent->next.rbe_parent;
#line 51
        tmp->next.rbe_parent = tmp___7;
#line 51
        if (tmp___7) {
#line 51
          if ((unsigned long )gparent == (unsigned long )(gparent->next.rbe_parent)->next.rbe_left) {
#line 51
            (gparent->next.rbe_parent)->next.rbe_left = tmp;
          } else {
#line 51
            (gparent->next.rbe_parent)->next.rbe_right = tmp;
          }
        } else {
#line 51
          head->rbh_root = tmp;
        }
#line 51
        tmp->next.rbe_left = gparent;
#line 51
        gparent->next.rbe_parent = tmp;
#line 51
        goto while_break___7;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  (head->rbh_root)->next.rbe_color = 0;
#line 51
  return;
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void mmtree_RB_REMOVE_COLOR(struct mmtree *head , struct mm_share *parent , struct mm_share *elm ) 
{ 
  struct mm_share *tmp ;
  struct mm_share *tmp___0 ;
  struct mm_share *tmp___1 ;
  struct mm_share *oleft ;
  struct mm_share *tmp___2 ;
  struct mm_share *tmp___3 ;
  struct mm_share *tmp___4 ;
  struct mm_share *tmp___5 ;
  struct mm_share *tmp___6 ;
  struct mm_share *tmp___7 ;
  struct mm_share *oright ;
  struct mm_share *tmp___8 ;
  struct mm_share *tmp___9 ;
  struct mm_share *tmp___10 ;
  struct mm_share *tmp___11 ;

  {
  {
  {
#line 51
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 51
      goto _L___5;
    } else
#line 51
    if (elm->next.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 51
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 51
    if ((unsigned long )parent->next.rbe_left == (unsigned long )elm) {
#line 51
      tmp = parent->next.rbe_right;
#line 51
      if (tmp->next.rbe_color == 1) {
        {
        {
#line 51
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 51
          tmp->next.rbe_color = 0;
#line 51
          parent->next.rbe_color = 1;
#line 51
          goto while_break___0;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 51
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 51
          tmp = parent->next.rbe_right;
#line 51
          tmp___0 = tmp->next.rbe_left;
#line 51
          parent->next.rbe_right = tmp___0;
#line 51
          if (tmp___0) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp___1 = parent->next.rbe_parent;
#line 51
          tmp->next.rbe_parent = tmp___1;
#line 51
          if (tmp___1) {
#line 51
            if ((unsigned long )parent == (unsigned long )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          goto while_break___1;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 51
        tmp = parent->next.rbe_right;
      }
#line 51
      if ((unsigned long )tmp->next.rbe_left == (unsigned long )((void *)0)) {
#line 51
        goto _L___1;
      } else
#line 51
      if ((tmp->next.rbe_left)->next.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 51
        if ((unsigned long )tmp->next.rbe_right == (unsigned long )((void *)0)) {
#line 51
          tmp->next.rbe_color = 1;
#line 51
          elm = parent;
#line 51
          parent = elm->next.rbe_parent;
        } else
#line 51
        if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 51
          tmp->next.rbe_color = 1;
#line 51
          elm = parent;
#line 51
          parent = elm->next.rbe_parent;
        } else {
#line 51
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 51
        if ((unsigned long )tmp->next.rbe_right == (unsigned long )((void *)0)) {
#line 51
          goto _L;
        } else
#line 51
        if ((tmp->next.rbe_right)->next.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 51
          oleft = tmp->next.rbe_left;
#line 51
          if (oleft) {
#line 51
            oleft->next.rbe_color = 0;
          }
#line 51
          tmp->next.rbe_color = 1;
          {
          {
#line 51
          while (1) {
            while_continue___11: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 51
            oleft = tmp->next.rbe_left;
#line 51
            tmp___2 = oleft->next.rbe_right;
#line 51
            tmp->next.rbe_left = tmp___2;
#line 51
            if (tmp___2) {
#line 51
              (oleft->next.rbe_right)->next.rbe_parent = tmp;
            }
#line 51
            tmp___3 = tmp->next.rbe_parent;
#line 51
            oleft->next.rbe_parent = tmp___3;
#line 51
            if (tmp___3) {
#line 51
              if ((unsigned long )tmp == (unsigned long )(tmp->next.rbe_parent)->next.rbe_left) {
#line 51
                (tmp->next.rbe_parent)->next.rbe_left = oleft;
              } else {
#line 51
                (tmp->next.rbe_parent)->next.rbe_right = oleft;
              }
            } else {
#line 51
              head->rbh_root = oleft;
            }
#line 51
            oleft->next.rbe_right = tmp;
#line 51
            tmp->next.rbe_parent = oleft;
#line 51
            goto while_break___2;
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 51
          tmp = parent->next.rbe_right;
        }
#line 51
        tmp->next.rbe_color = parent->next.rbe_color;
#line 51
        parent->next.rbe_color = 0;
#line 51
        if (tmp->next.rbe_right) {
#line 51
          (tmp->next.rbe_right)->next.rbe_color = 0;
        }
        {
        {
#line 51
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 51
          tmp = parent->next.rbe_right;
#line 51
          tmp___4 = tmp->next.rbe_left;
#line 51
          parent->next.rbe_right = tmp___4;
#line 51
          if (tmp___4) {
#line 51
            (tmp->next.rbe_left)->next.rbe_parent = parent;
          }
#line 51
          tmp___5 = parent->next.rbe_parent;
#line 51
          tmp->next.rbe_parent = tmp___5;
#line 51
          if (tmp___5) {
#line 51
            if ((unsigned long )parent == (unsigned long )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_left = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          goto while_break___3;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 51
        elm = head->rbh_root;
#line 51
        goto while_break;
      }
    } else {
#line 51
      tmp = parent->next.rbe_left;
#line 51
      if (tmp->next.rbe_color == 1) {
        {
        {
#line 51
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 51
          tmp->next.rbe_color = 0;
#line 51
          parent->next.rbe_color = 1;
#line 51
          goto while_break___4;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
        {
#line 51
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 51
          tmp = parent->next.rbe_left;
#line 51
          tmp___6 = tmp->next.rbe_right;
#line 51
          parent->next.rbe_left = tmp___6;
#line 51
          if (tmp___6) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp___7 = parent->next.rbe_parent;
#line 51
          tmp->next.rbe_parent = tmp___7;
#line 51
          if (tmp___7) {
#line 51
            if ((unsigned long )parent == (unsigned long )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          goto while_break___5;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 51
        tmp = parent->next.rbe_left;
      }
#line 51
      if ((unsigned long )tmp->next.rbe_left == (unsigned long )((void *)0)) {
#line 51
        goto _L___4;
      } else
#line 51
      if ((tmp->next.rbe_left)->next.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 51
        if ((unsigned long )tmp->next.rbe_right == (unsigned long )((void *)0)) {
#line 51
          tmp->next.rbe_color = 1;
#line 51
          elm = parent;
#line 51
          parent = elm->next.rbe_parent;
        } else
#line 51
        if ((tmp->next.rbe_right)->next.rbe_color == 0) {
#line 51
          tmp->next.rbe_color = 1;
#line 51
          elm = parent;
#line 51
          parent = elm->next.rbe_parent;
        } else {
#line 51
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 51
        if ((unsigned long )tmp->next.rbe_left == (unsigned long )((void *)0)) {
#line 51
          goto _L___2;
        } else
#line 51
        if ((tmp->next.rbe_left)->next.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 51
          oright = tmp->next.rbe_right;
#line 51
          if (oright) {
#line 51
            oright->next.rbe_color = 0;
          }
#line 51
          tmp->next.rbe_color = 1;
          {
          {
#line 51
          while (1) {
            while_continue___15: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
#line 51
            oright = tmp->next.rbe_right;
#line 51
            tmp___8 = oright->next.rbe_left;
#line 51
            tmp->next.rbe_right = tmp___8;
#line 51
            if (tmp___8) {
#line 51
              (oright->next.rbe_left)->next.rbe_parent = tmp;
            }
#line 51
            tmp___9 = tmp->next.rbe_parent;
#line 51
            oright->next.rbe_parent = tmp___9;
#line 51
            if (tmp___9) {
#line 51
              if ((unsigned long )tmp == (unsigned long )(tmp->next.rbe_parent)->next.rbe_left) {
#line 51
                (tmp->next.rbe_parent)->next.rbe_left = oright;
              } else {
#line 51
                (tmp->next.rbe_parent)->next.rbe_right = oright;
              }
            } else {
#line 51
              head->rbh_root = oright;
            }
#line 51
            oright->next.rbe_left = tmp;
#line 51
            tmp->next.rbe_parent = oright;
#line 51
            goto while_break___6;
          }
          while_break___15: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 51
          tmp = parent->next.rbe_left;
        }
#line 51
        tmp->next.rbe_color = parent->next.rbe_color;
#line 51
        parent->next.rbe_color = 0;
#line 51
        if (tmp->next.rbe_left) {
#line 51
          (tmp->next.rbe_left)->next.rbe_color = 0;
        }
        {
        {
#line 51
        while (1) {
          while_continue___16: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 51
          tmp = parent->next.rbe_left;
#line 51
          tmp___10 = tmp->next.rbe_right;
#line 51
          parent->next.rbe_left = tmp___10;
#line 51
          if (tmp___10) {
#line 51
            (tmp->next.rbe_right)->next.rbe_parent = parent;
          }
#line 51
          tmp___11 = parent->next.rbe_parent;
#line 51
          tmp->next.rbe_parent = tmp___11;
#line 51
          if (tmp___11) {
#line 51
            if ((unsigned long )parent == (unsigned long )(parent->next.rbe_parent)->next.rbe_left) {
#line 51
              (parent->next.rbe_parent)->next.rbe_left = tmp;
            } else {
#line 51
              (parent->next.rbe_parent)->next.rbe_right = tmp;
            }
          } else {
#line 51
            head->rbh_root = tmp;
          }
#line 51
          tmp->next.rbe_right = parent;
#line 51
          parent->next.rbe_parent = tmp;
#line 51
          goto while_break___7;
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 51
        elm = head->rbh_root;
#line 51
        goto while_break;
      }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (elm) {
#line 51
    elm->next.rbe_color = 0;
  }
#line 51
  return;
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
struct mm_share *mmtree_RB_REMOVE(struct mmtree *head , struct mm_share *elm ) 
{ 
  struct mm_share *child ;
  struct mm_share *parent ;
  struct mm_share *old ;
  int color ;
  struct mm_share *left ;

  {
#line 51
  old = elm;
#line 51
  if ((unsigned long )elm->next.rbe_left == (unsigned long )((void *)0)) {
#line 51
    child = elm->next.rbe_right;
  } else
#line 51
  if ((unsigned long )elm->next.rbe_right == (unsigned long )((void *)0)) {
#line 51
    child = elm->next.rbe_left;
  } else {
#line 51
    elm = elm->next.rbe_right;
    {
    {
#line 51
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 51
      left = elm->next.rbe_left;
#line 51
      if (! left) {
#line 51
        goto while_break;
      }
#line 51
      elm = left;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 51
    child = elm->next.rbe_right;
#line 51
    parent = elm->next.rbe_parent;
#line 51
    color = elm->next.rbe_color;
#line 51
    if (child) {
#line 51
      child->next.rbe_parent = parent;
    }
#line 51
    if (parent) {
#line 51
      if ((unsigned long )parent->next.rbe_left == (unsigned long )elm) {
#line 51
        parent->next.rbe_left = child;
      } else {
#line 51
        parent->next.rbe_right = child;
      }
    } else {
#line 51
      head->rbh_root = child;
    }
#line 51
    if ((unsigned long )elm->next.rbe_parent == (unsigned long )old) {
#line 51
      parent = elm;
    }
#line 51
    elm->next = old->next;
#line 51
    if (old->next.rbe_parent) {
#line 51
      if ((unsigned long )(old->next.rbe_parent)->next.rbe_left == (unsigned long )old) {
#line 51
        (old->next.rbe_parent)->next.rbe_left = elm;
      } else {
#line 51
        (old->next.rbe_parent)->next.rbe_right = elm;
      }
    } else {
#line 51
      head->rbh_root = elm;
    }
#line 51
    (old->next.rbe_left)->next.rbe_parent = elm;
#line 51
    if (old->next.rbe_right) {
#line 51
      (old->next.rbe_right)->next.rbe_parent = elm;
    }
#line 51
    if (parent) {
#line 51
      left = parent;
      {
      {
#line 51
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 51
        left = left->next.rbe_parent;
#line 51
        if (! left) {
#line 51
          goto while_break___0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 51
    goto color;
  }
#line 51
  parent = elm->next.rbe_parent;
#line 51
  color = elm->next.rbe_color;
#line 51
  if (child) {
#line 51
    child->next.rbe_parent = parent;
  }
#line 51
  if (parent) {
#line 51
    if ((unsigned long )parent->next.rbe_left == (unsigned long )elm) {
#line 51
      parent->next.rbe_left = child;
    } else {
#line 51
      parent->next.rbe_right = child;
    }
  } else {
#line 51
    head->rbh_root = child;
  }
  color: 
#line 51
  if (color == 0) {
    {
    {
#line 51
    mmtree_RB_REMOVE_COLOR(head, parent, child);
    }
    }
  }
#line 51
  return (old);
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
struct mm_share *mmtree_RB_INSERT(struct mmtree *head , struct mm_share *elm ) 
{ 
  struct mm_share *tmp ;
  struct mm_share *parent ;
  int comp ;
  struct mm_share *tmp___0 ;

  {
#line 51
  parent = (struct mm_share *)((void *)0);
#line 51
  comp = 0;
#line 51
  tmp = head->rbh_root;
  {
  {
#line 51
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    if (! tmp) {
#line 51
      goto while_break;
    }
    {
#line 51
    parent = tmp;
    {
#line 51
    comp = mm_compare(elm, parent);
    }
    }
#line 51
    if (comp < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else
#line 51
    if (comp > 0) {
#line 51
      tmp = tmp->next.rbe_right;
    } else {
#line 51
      return (tmp);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 51
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 51
    elm->next.rbe_parent = parent;
#line 51
    tmp___0 = (struct mm_share *)((void *)0);
#line 51
    elm->next.rbe_right = tmp___0;
#line 51
    elm->next.rbe_left = tmp___0;
#line 51
    elm->next.rbe_color = 1;
#line 51
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 51
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 51
    if (comp < 0) {
#line 51
      parent->next.rbe_left = elm;
    } else {
#line 51
      parent->next.rbe_right = elm;
    }
  } else {
#line 51
    head->rbh_root = elm;
  }
  {
  {
#line 51
  mmtree_RB_INSERT_COLOR(head, elm);
  }
  }
#line 51
  return ((struct mm_share *)((void *)0));
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
struct mm_share *mmtree_RB_FIND(struct mmtree *head , struct mm_share *elm ) 
{ 
  struct mm_share *tmp ;
  int comp ;

  {
#line 51
  tmp = head->rbh_root;
  {
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    if (! tmp) {
#line 51
      goto while_break;
    }
    {
    {
#line 51
    comp = mm_compare(elm, tmp);
    }
    }
#line 51
    if (comp < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else
#line 51
    if (comp > 0) {
#line 51
      tmp = tmp->next.rbe_right;
    } else {
#line 51
      return (tmp);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((struct mm_share *)((void *)0));
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
struct mm_share *mmtree_RB_NEXT(struct mmtree *head , struct mm_share *elm ) 
{ 


  {
#line 51
  if (elm->next.rbe_right) {
#line 51
    elm = elm->next.rbe_right;
    {
    {
#line 51
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 51
      if (! elm->next.rbe_left) {
#line 51
        goto while_break;
      }
#line 51
      elm = elm->next.rbe_left;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 51
  if (elm->next.rbe_parent) {
#line 51
    if ((unsigned long )elm == (unsigned long )(elm->next.rbe_parent)->next.rbe_left) {
#line 51
      elm = elm->next.rbe_parent;
    } else {
#line 51
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 51
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 51
      if (elm->next.rbe_parent) {
#line 51
        if (! ((unsigned long )elm == (unsigned long )(elm->next.rbe_parent)->next.rbe_right)) {
#line 51
          goto while_break___0;
        }
      } else {
#line 51
        goto while_break___0;
      }
#line 51
      elm = elm->next.rbe_parent;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 51
    elm = elm->next.rbe_parent;
  }
#line 51
  return (elm);
}
}
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
struct mm_share *mmtree_RB_MINMAX(struct mmtree *head , int val ) 
{ 
  struct mm_share *tmp ;
  struct mm_share *parent ;

  {
#line 51
  tmp = head->rbh_root;
#line 51
  parent = (struct mm_share *)((void *)0);
  {
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    if (! tmp) {
#line 51
      goto while_break;
    }
#line 51
    parent = tmp;
#line 51
    if (val < 0) {
#line 51
      tmp = tmp->next.rbe_left;
    } else {
#line 51
      tmp = tmp->next.rbe_right;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (parent);
}
}
#line 53 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
static struct mm_share *mm_make_entry(struct mm_master *mm , struct mmtree *head ,
                                      void *address , size_t size ) 
{ 
  struct mm_share *tmp ;
  struct mm_share *tmp2 ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;

  {
#line 59
  if ((unsigned long )mm->mmalloc == (unsigned long )((void *)0)) {
    {
    {
#line 60
    tmp___0 = xmalloc((size_t )sizeof(struct mm_share ));
    }
#line 60
    tmp = (struct mm_share *)tmp___0;
    }
  } else {
    {
    {
#line 62
    tmp___1 = mm_xmalloc(mm->mmalloc, (size_t )sizeof(struct mm_share ));
    }
#line 62
    tmp = (struct mm_share *)tmp___1;
    }
  }
  {
#line 63
  tmp->address = address;
#line 64
  tmp->size = size;
  {
#line 66
  tmp2 = mmtree_RB_INSERT(head, tmp);
  }
  }
#line 67
  if ((unsigned long )tmp2 != (unsigned long )((void *)0)) {
    {
    {
#line 68
    fatal("mm_make_entry(%p): double address %p->%p(%lu)", mm, tmp2, address, (u_long )size);
    }
    }
  }
#line 71
  return (tmp);
}
}
#line 76 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
struct mm_master *mm_create(struct mm_master *mmalloc , size_t size ) 
{ 
  void *address ;
  struct mm_master *mm ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 82
  if ((unsigned long )mmalloc == (unsigned long )((void *)0)) {
    {
    {
#line 83
    tmp = xmalloc((size_t )sizeof(struct mm_master ));
    }
#line 83
    mm = (struct mm_master *)tmp;
    }
  } else {
    {
    {
#line 85
    tmp___0 = mm_xmalloc(mmalloc, (size_t )sizeof(struct mm_master ));
    }
#line 85
    mm = (struct mm_master *)tmp___0;
    }
  }
  {
#line 92
  mm->mmalloc = mmalloc;
  {
#line 94
  address = xmmap(size);
  }
  }
#line 95
  if ((unsigned long )address == (unsigned long )((void *)-1)) {
    {
    {
#line 96
    tmp___1 = __errno_location();
    }
    {
#line 96
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 96
    fatal("mmap(%lu): %s", (u_long )size, tmp___2);
    }
    }
  }
#line 98
  mm->address = address;
#line 99
  mm->size = size;
  {
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 101
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 101
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 102
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 102
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 104
  mm_make_entry(mm, & mm->rb_free, address, size);
  }
  }
#line 106
  return (mm);
}
}
#line 111 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
static void mm_freelist(struct mm_master *mmalloc , struct mmtree *head ) 
{ 
  struct mm_share *mms ;
  struct mm_share *next ;

  {
#line 116
  mms = head->rbh_root;
  {
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! mms) {
#line 116
      goto while_break;
    }
    {
    {
#line 117
    next = mmtree_RB_NEXT(head, mms);
    }
    {
#line 118
    mmtree_RB_REMOVE(head, mms);
    }
    }
#line 119
    if ((unsigned long )mmalloc == (unsigned long )((void *)0)) {
      {
      {
#line 120
      xfree((void *)mms);
      }
      }
    } else {
      {
      {
#line 122
      mm_free(mmalloc, (void *)mms);
      }
      }
    }
#line 116
    mms = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 128 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void mm_destroy(struct mm_master *mm ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 131
  mm_freelist(mm->mmalloc, & mm->rb_free);
  }
  {
#line 132
  mm_freelist(mm->mmalloc, & mm->rb_allocated);
  }
  {
#line 135
  tmp___1 = munmap(mm->address, mm->size);
  }
  }
#line 135
  if (tmp___1 == -1) {
    {
    {
#line 136
    tmp = __errno_location();
    }
    {
#line 136
    tmp___0 = strerror(*tmp);
    }
    {
#line 136
    fatal("munmap(%p, %lu): %s", mm->address, (u_long )mm->size, tmp___0);
    }
    }
  }
#line 142
  if ((unsigned long )mm->mmalloc == (unsigned long )((void *)0)) {
    {
    {
#line 143
    xfree((void *)mm);
    }
    }
  } else {
    {
    {
#line 145
    mm_free(mm->mmalloc, (void *)mm);
    }
    }
  }
#line 146
  return;
}
}
#line 148 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void *mm_xmalloc(struct mm_master *mm , size_t size ) 
{ 
  void *address ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 153
  address = mm_malloc(mm, size);
  }
  }
#line 154
  if ((unsigned long )address == (unsigned long )((void *)0)) {
    {
    {
#line 155
    fatal("%s: mm_malloc(%lu)", "mm_xmalloc", (u_long )size);
    }
    }
  }
#line 156
  return (address);
}
}
#line 162 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void *mm_malloc(struct mm_master *mm , size_t size ) 
{ 
  struct mm_share *mms ;
  struct mm_share *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 167
  if (size == 0U) {
    {
    {
#line 168
    fatal("mm_malloc: try to allocate 0 space");
    }
    }
  }
#line 169
  if ((unsigned long )size > 4294967168UL) {
    {
    {
#line 170
    fatal("mm_malloc: size too big");
    }
    }
  }
  {
#line 172
  size = ((size + 127U) / 128U) * 128U;
  {
#line 174
  mms = mmtree_RB_MINMAX(& mm->rb_free, -1);
  }
  }
  {
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )mms != (unsigned long )((void *)0))) {
#line 174
      goto while_break;
    }
#line 175
    if (mms->size >= size) {
#line 176
      goto while_break;
    }
    {
    {
#line 174
    mms = mmtree_RB_NEXT(& mm->rb_free, mms);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  if ((unsigned long )mms == (unsigned long )((void *)0)) {
#line 180
    return ((void *)0);
  }
  {
  {
#line 183
  memset(mms->address, 208, size);
  }
  {
#line 185
  tmp = mm_make_entry(mm, & mm->rb_allocated, mms->address, size);
  }
#line 188
  mms->size -= size;
#line 189
  mms->address = (void *)((u_char *)mms->address + size);
  }
#line 191
  if (mms->size == 0U) {
    {
    {
#line 192
    mmtree_RB_REMOVE(& mm->rb_free, mms);
    }
    }
#line 193
    if ((unsigned long )mm->mmalloc == (unsigned long )((void *)0)) {
      {
      {
#line 194
      xfree((void *)mms);
      }
      }
    } else {
      {
      {
#line 196
      mm_free(mm->mmalloc, (void *)mms);
      }
      }
    }
  }
#line 199
  return (tmp->address);
}
}
#line 204 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void mm_free(struct mm_master *mm , void *address ) 
{ 
  struct mm_share *mms ;
  struct mm_share *prev ;
  struct mm_share tmp ;
  struct mm_share *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 209
  tmp.address = address;
  {
#line 210
  mms = mmtree_RB_FIND(& mm->rb_allocated, & tmp);
  }
  }
#line 211
  if ((unsigned long )mms == (unsigned long )((void *)0)) {
    {
    {
#line 212
    fatal("mm_free(%p): can not find %p", mm, address);
    }
    }
  }
  {
  {
#line 215
  memset(mms->address, 208, mms->size);
  }
  {
#line 218
  mmtree_RB_REMOVE(& mm->rb_allocated, mms);
  }
  {
#line 219
  tmp___0 = mmtree_RB_INSERT(& mm->rb_free, mms);
  }
  }
#line 219
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
    {
#line 220
    fatal("mm_free(%p): double address %p", mm, address);
    }
    }
  }
#line 223
  prev = mms;
#line 224
  if (prev->next.rbe_left) {
#line 225
    prev = prev->next.rbe_left;
    {
    {
#line 226
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 226
      if (! prev->next.rbe_right) {
#line 226
        goto while_break;
      }
#line 227
      prev = prev->next.rbe_right;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 229
  if (prev->next.rbe_parent) {
#line 229
    if ((unsigned long )prev == (unsigned long )(prev->next.rbe_parent)->next.rbe_right) {
#line 231
      prev = prev->next.rbe_parent;
    } else {
#line 229
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 233
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 233
      if (prev->next.rbe_parent) {
#line 233
        if (! ((unsigned long )prev == (unsigned long )(prev->next.rbe_parent)->next.rbe_left)) {
#line 233
          goto while_break___0;
        }
      } else {
#line 233
        goto while_break___0;
      }
#line 235
      prev = prev->next.rbe_parent;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    prev = prev->next.rbe_parent;
  }
#line 241
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 241
    if ((unsigned long )((void *)((u_char *)prev->address + prev->size)) > (unsigned long )address) {
      {
      {
#line 242
      fatal("mm_free: memory corruption: %p(%lu) > %p", prev->address, (u_long )prev->size,
            address);
      }
      }
    }
  }
#line 246
  if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 246
    if ((unsigned long )((void *)((u_char *)prev->address + prev->size)) == (unsigned long )address) {
      {
#line 247
      prev->size += mms->size;
      {
#line 248
      mmtree_RB_REMOVE(& mm->rb_free, mms);
      }
      }
#line 249
      if ((unsigned long )mm->mmalloc == (unsigned long )((void *)0)) {
        {
        {
#line 250
        xfree((void *)mms);
        }
        }
      } else {
        {
        {
#line 252
        mm_free(mm->mmalloc, (void *)mms);
        }
        }
      }
    } else {
#line 254
      prev = mms;
    }
  } else {
#line 254
    prev = mms;
  }
#line 256
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 257
    return;
  }
  {
  {
#line 260
  mms = mmtree_RB_NEXT(& mm->rb_free, prev);
  }
  }
#line 261
  if ((unsigned long )mms == (unsigned long )((void *)0)) {
#line 262
    return;
  }
#line 264
  if ((unsigned long )((void *)((u_char *)prev->address + prev->size)) > (unsigned long )mms->address) {
    {
    {
#line 265
    fatal("mm_free: memory corruption: %p < %p(%lu)", mms->address, prev->address,
          (u_long )prev->size);
    }
    }
  }
#line 267
  if ((unsigned long )((void *)((u_char *)prev->address + prev->size)) != (unsigned long )mms->address) {
#line 268
    return;
  }
  {
#line 270
  prev->size += mms->size;
  {
#line 271
  mmtree_RB_REMOVE(& mm->rb_free, mms);
  }
  }
#line 273
  if ((unsigned long )mm->mmalloc == (unsigned long )((void *)0)) {
    {
    {
#line 274
    xfree((void *)mms);
    }
    }
  } else {
    {
    {
#line 276
    mm_free(mm->mmalloc, (void *)mms);
    }
    }
  }
#line 277
  return;
}
}
#line 279 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
static void mm_sync_list(struct mmtree *oldtree , struct mmtree *newtree , struct mm_master *mm ,
                         struct mm_master *mmold ) 
{ 
  struct mm_master *mmalloc ;
  struct mm_share *mms ;
  struct mm_share *new ;
  void *tmp ;

  {
  {
#line 283
  mmalloc = mm->mmalloc;
  {
#line 287
  mms = mmtree_RB_MINMAX(oldtree, -1);
  }
  }
  {
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 287
    if (! ((unsigned long )mms != (unsigned long )((void *)0))) {
#line 287
      goto while_break;
    }
    {
    {
#line 289
    mm_memvalid(mmold, (void *)mms, (size_t )sizeof(struct mm_share ));
    }
    {
#line 290
    mm_memvalid(mm, mms->address, mms->size);
    }
    {
#line 292
    tmp = mm_xmalloc(mmalloc, (size_t )sizeof(struct mm_share ));
    }
#line 292
    new = (struct mm_share *)tmp;
    {
#line 293
    memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)mms, (size_t )sizeof(struct mm_share ));
    }
    {
#line 294
    mmtree_RB_INSERT(newtree, new);
    }
    {
#line 287
    mms = mmtree_RB_NEXT(oldtree, mms);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void mm_share_sync(struct mm_master **pmm , struct mm_master **pmmalloc ) 
{ 
  struct mm_master *mm ;
  struct mm_master *mmalloc ;
  struct mm_master *mmold ;
  struct mmtree rb_free ;
  struct mmtree rb_allocated ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 306
  debug3("%s: Share sync", "mm_share_sync");
  }
#line 308
  mm = *pmm;
#line 309
  mmold = mm->mmalloc;
  {
#line 310
  mm_memvalid(mmold, (void *)mm, (size_t )sizeof(*mm));
  }
  {
#line 312
  mmalloc = mm_create((struct mm_master *)((void *)0), mm->size);
  }
  {
#line 313
  tmp = mm_xmalloc(mmalloc, (size_t )sizeof(struct mm_master ));
  }
#line 313
  mm = (struct mm_master *)tmp;
  {
#line 314
  memcpy((void */* __restrict  */)mm, (void const   */* __restrict  */)*pmm, (size_t )sizeof(struct mm_master ));
  }
#line 315
  mm->mmalloc = mmalloc;
#line 317
  rb_free = mm->rb_free;
#line 318
  rb_allocated = mm->rb_allocated;
  }
  {
  {
#line 320
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 320
    mm->rb_free.rbh_root = (struct mm_share *)((void *)0);
#line 320
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 321
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 321
    mm->rb_allocated.rbh_root = (struct mm_share *)((void *)0);
#line 321
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 323
  mm_sync_list(& rb_free, & mm->rb_free, mm, mmold);
  }
  {
#line 324
  mm_sync_list(& rb_allocated, & mm->rb_allocated, mm, mmold);
  }
  {
#line 326
  mm_destroy(mmold);
  }
#line 328
  *pmm = mm;
#line 329
  *pmmalloc = mmalloc;
  {
#line 331
  debug3("%s: Share sync end", "mm_share_sync");
  }
  }
#line 332
  return;
}
}
#line 334 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_mm.c"
void mm_memvalid(struct mm_master *mm , void *address , size_t size ) 
{ 
  void *end ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 337
  end = (void *)((u_char *)address + size);
#line 339
  if ((unsigned long )address < (unsigned long )mm->address) {
    {
    {
#line 340
    fatal("mm_memvalid: address too small: %p", address);
    }
    }
  }
#line 341
  if ((unsigned long )end < (unsigned long )address) {
    {
    {
#line 342
    fatal("mm_memvalid: end < address: %p < %p", end, address);
    }
    }
  }
#line 343
  if ((unsigned long )end > (unsigned long )((void *)((u_char *)mm->address + mm->size))) {
    {
    {
#line 344
    fatal("mm_memvalid: address too large: %p", address);
    }
    }
  }
#line 345
  return;
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 53 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern u_int packet_get_char(void) ;
#line 58
extern void *packet_get_string(u_int *length_ptr ) ;
#line 59 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
extern void ( /* format attribute */  verbose)(char const   *  , ...) ;
#line 58 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
extern Key *key_new(int  ) ;
#line 62
extern int key_equal(Key const   * , Key const   * ) ;
#line 63
extern char *key_fingerprint(Key const   * , enum fp_type  , enum fp_rep  ) ;
#line 65
extern char const   *key_type(Key const   * ) ;
#line 67
extern int key_read(Key * , char ** ) ;
#line 72
extern int key_type_from_name(char * ) ;
#line 166 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
char *authorized_keys_file(struct passwd *pw ) ;
#line 167
char *authorized_keys_file2(struct passwd *pw ) ;
#line 169
int secure_filename(FILE *f , char const   *file , struct passwd *pw , char *err ,
                    size_t errlen ) ;
#line 18 "/home/pronto/abs/test-suite/openssh-4.3p2/uidswap.h"
extern void temporarily_use_uid(struct passwd * ) ;
#line 19
extern void restore_uid(void) ;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.h"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) ;
#line 56 "/home/pronto/abs/test-suite/openssh-4.3p2/misc.h"
extern int read_keyfile_line(FILE * , char const   * , char * , size_t  , u_long * ) ;
#line 48 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c"
u_char *session_id2 ;
#line 49
u_int session_id2_len ;
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c"
static int userauth_pubkey(Authctxt *authctxt___0 ) 
{ 
  Buffer b ;
  Key *key ;
  char *pkalg ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int have_sig ;
  int pktype ;
  int authenticated ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int _len ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  u_int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int _len___0 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 55
  key = (Key *)((void *)0);
#line 60
  authenticated = 0;
#line 62
  if (! authctxt___0->valid) {
    {
    {
#line 63
    debug2("userauth_pubkey: disabled because of invalid user");
    }
    }
#line 64
    return (0);
  }
  {
  {
#line 66
  tmp = packet_get_char();
  }
#line 66
  have_sig = (int )tmp;
  }
#line 67
  if (datafellows & 32) {
    {
    {
#line 68
    debug2("userauth_pubkey: SSH_BUG_PKAUTH");
    }
    {
#line 70
    tmp___0 = packet_get_string(& blen);
    }
#line 70
    pkblob = (u_char *)tmp___0;
    {
#line 71
    buffer_init(& b);
    }
    {
#line 72
    buffer_append(& b, (void const   *)pkblob, blen);
    }
    {
#line 74
    tmp___1 = buffer_get_string(& b, & alen);
    }
#line 74
    pkalg = (char *)tmp___1;
    {
#line 75
    buffer_free(& b);
    }
    }
  } else {
    {
    {
#line 77
    tmp___2 = packet_get_string(& alen);
    }
#line 77
    pkalg = (char *)tmp___2;
    {
#line 78
    tmp___3 = packet_get_string(& blen);
    }
#line 78
    pkblob = (u_char *)tmp___3;
    }
  }
  {
  {
#line 80
  pktype = key_type_from_name(pkalg);
  }
  }
#line 81
  if (pktype == 3) {
    {
    {
#line 83
    logit("userauth_pubkey: unsupported public key algorithm: %s", pkalg);
    }
    }
#line 85
    goto done;
  }
  {
  {
#line 87
  key = key_from_blob((u_char const   *)pkblob, blen);
  }
  }
#line 88
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
    {
#line 89
    error("userauth_pubkey: cannot decode key: %s", pkalg);
    }
    }
#line 90
    goto done;
  }
#line 92
  if (key->type != pktype) {
    {
    {
#line 93
    error("userauth_pubkey: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    }
    }
#line 95
    goto done;
  }
#line 97
  if (have_sig) {
    {
    {
#line 98
    tmp___4 = packet_get_string(& slen);
    }
#line 98
    sig = (u_char *)tmp___4;
    }
    {
    {
#line 99
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 99
      tmp___5 = packet_remaining();
      }
#line 99
      _len = tmp___5;
      }
#line 99
      if (_len > 0) {
        {
        {
#line 99
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c",
              99);
        }
        {
#line 99
        packet_disconnect("Packet integrity error.");
        }
        }
      }
#line 99
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 100
    buffer_init(& b);
    }
    }
#line 101
    if (datafellows & 16) {
      {
      {
#line 102
      buffer_append(& b, (void const   *)session_id2, session_id2_len);
      }
      }
    } else {
      {
      {
#line 104
      buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
      }
      }
    }
    {
    {
#line 107
    buffer_put_char(& b, 50);
    }
    {
#line 108
    buffer_put_cstring(& b, (char const   *)authctxt___0->user);
    }
    }
#line 109
    if (datafellows & 2) {
#line 109
      tmp___6 = "ssh-userauth";
    } else {
#line 109
      tmp___6 = (char const   *)authctxt___0->service;
    }
    {
    {
#line 109
    buffer_put_cstring(& b, tmp___6);
    }
    }
#line 113
    if (datafellows & 32) {
      {
      {
#line 114
      buffer_put_char(& b, have_sig);
      }
      }
    } else {
      {
      {
#line 116
      buffer_put_cstring(& b, "publickey");
      }
      {
#line 117
      buffer_put_char(& b, have_sig);
      }
      {
#line 118
      buffer_put_cstring(& b, (char const   *)pkalg);
      }
      }
    }
    {
    {
#line 120
    buffer_put_string(& b, (void const   *)pkblob, blen);
    }
#line 125
    authenticated = 0;
    }
#line 126
    if (use_privsep) {
      {
      {
#line 126
      tmp___7 = mm_user_key_allowed(authctxt___0->pw, key);
      }
#line 126
      tmp___9 = tmp___7;
      }
    } else {
      {
      {
#line 126
      tmp___8 = user_key_allowed(authctxt___0->pw, key);
      }
#line 126
      tmp___9 = tmp___8;
      }
    }
#line 126
    if (tmp___9) {
#line 126
      if (use_privsep) {
        {
        {
#line 126
        tmp___10 = buffer_len(& b);
        }
        {
#line 126
        tmp___11 = buffer_ptr(& b);
        }
        {
#line 126
        tmp___12 = mm_key_verify(key, sig, slen, (u_char *)tmp___11, tmp___10);
        }
#line 126
        tmp___16 = tmp___12;
        }
      } else {
        {
        {
#line 126
        tmp___13 = buffer_len(& b);
        }
        {
#line 126
        tmp___14 = buffer_ptr(& b);
        }
        {
#line 126
        tmp___15 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___14,
                              tmp___13);
        }
#line 126
        tmp___16 = tmp___15;
        }
      }
#line 126
      if (tmp___16 == 1) {
#line 129
        authenticated = 1;
      }
    }
    {
    {
#line 130
    buffer_free(& b);
    }
    {
#line 131
    xfree((void *)sig);
    }
    }
  } else {
    {
    {
#line 133
    debug("test whether pkalg/pkblob are acceptable");
    }
    }
    {
    {
#line 134
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 134
      tmp___17 = packet_remaining();
      }
#line 134
      _len___0 = tmp___17;
      }
#line 134
      if (_len___0 > 0) {
        {
        {
#line 134
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c",
              134);
        }
        {
#line 134
        packet_disconnect("Packet integrity error.");
        }
        }
      }
#line 134
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    if (use_privsep) {
      {
      {
#line 144
      tmp___18 = mm_user_key_allowed(authctxt___0->pw, key);
      }
#line 144
      tmp___20 = tmp___18;
      }
    } else {
      {
      {
#line 144
      tmp___19 = user_key_allowed(authctxt___0->pw, key);
      }
#line 144
      tmp___20 = tmp___19;
      }
    }
#line 144
    if (tmp___20) {
      {
      {
#line 145
      packet_start((u_char )60);
      }
      {
#line 146
      packet_put_string((void const   *)pkalg, alen);
      }
      {
#line 147
      packet_put_string((void const   *)pkblob, blen);
      }
      {
#line 148
      packet_send();
      }
      {
#line 149
      packet_write_wait();
      }
#line 150
      authctxt___0->postponed = 1;
      }
    }
  }
#line 153
  if (authenticated != 1) {
    {
    {
#line 154
    auth_clear_options();
    }
    }
  }
  done: 
  {
  {
#line 156
  debug2("userauth_pubkey: authenticated %d pkalg %s", authenticated, pkalg);
  }
  }
#line 157
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
    {
#line 158
    key_free(key);
    }
    }
  }
  {
  {
#line 159
  xfree((void *)pkalg);
  }
  {
#line 160
  xfree((void *)pkblob);
  }
  }
#line 165
  return (authenticated);
}
}
#line 169 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c"
static int user_key_allowed2(struct passwd *pw , Key *key , char *file ) 
{ 
  char line[8192] ;
  int found_key ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *found ;
  char *fp ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *key_options ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 173
  found_key = 0;
#line 175
  linenum = (u_long )0;
  {
#line 181
  temporarily_use_uid(pw);
  }
  {
#line 183
  debug("trying public key file %s", file);
  }
  {
#line 186
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
  }
#line 186
  if (tmp < 0) {
    {
    {
#line 188
    restore_uid();
    }
    }
#line 189
    return (0);
  }
  {
  {
#line 192
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
  }
#line 193
  if (! f) {
    {
    {
#line 195
    restore_uid();
    }
    }
#line 196
    return (0);
  }
#line 198
  if (options.strict_modes) {
    {
    {
#line 198
    tmp___0 = secure_filename(f, (char const   *)file, pw, line, (size_t )sizeof(line));
    }
    }
#line 198
    if (tmp___0 != 0) {
      {
      {
#line 200
      fclose(f);
      }
      {
#line 201
      logit("Authentication refused: %s", line);
      }
      {
#line 202
      restore_uid();
      }
      }
#line 203
      return (0);
    }
  }
  {
#line 206
  found_key = 0;
  {
#line 207
  found = key_new(key->type);
  }
  }
  {
  {
#line 209
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 209
    tmp___6 = read_keyfile_line(f, (char const   *)file, line, (size_t )sizeof(line),
                                & linenum);
    }
    }
#line 209
    if (! (tmp___6 != -1)) {
#line 209
      goto while_break;
    }
#line 210
    key_options = (char *)((void *)0);
#line 213
    cp = line;
    {
    {
#line 213
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 213
      if (! ((int )*cp == 32)) {
#line 213
        if (! ((int )*cp == 9)) {
#line 213
          goto while_break___0;
        }
      }
#line 213
      cp ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 215
    if (! *cp) {
#line 216
      goto while_continue;
    } else
#line 215
    if ((int )*cp == 10) {
#line 216
      goto while_continue;
    } else
#line 215
    if ((int )*cp == 35) {
#line 216
      goto while_continue;
    }
    {
    {
#line 218
    tmp___2 = key_read(found, & cp);
    }
    }
#line 218
    if (tmp___2 != 1) {
      {
#line 220
      quoted = 0;
      {
#line 221
      debug2("user_key_allowed: check options: \'%s\'", cp);
      }
#line 222
      key_options = cp;
      }
      {
      {
#line 223
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 223
        if (*cp) {
#line 223
          if (! quoted) {
#line 223
            if ((int )*cp != 32) {
#line 223
              if (! ((int )*cp != 9)) {
#line 223
                goto while_break___1;
              }
            } else {
#line 223
              goto while_break___1;
            }
          }
        } else {
#line 223
          goto while_break___1;
        }
#line 224
        if ((int )*cp == 92) {
#line 224
          if ((int )*(cp + 1) == 34) {
#line 225
            cp ++;
          } else {
#line 224
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 226
        if ((int )*cp == 34) {
#line 227
          quoted = ! quoted;
        }
#line 223
        cp ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 230
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 230
        if (! ((int )*cp == 32)) {
#line 230
          if (! ((int )*cp == 9)) {
#line 230
            goto while_break___2;
          }
        }
#line 230
        cp ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      {
#line 232
      tmp___1 = key_read(found, & cp);
      }
      }
#line 232
      if (tmp___1 != 1) {
        {
        {
#line 233
        debug2("user_key_allowed: advance: \'%s\'", cp);
        }
        }
#line 235
        goto while_continue;
      }
    }
    {
    {
#line 238
    tmp___4 = key_equal((Key const   *)found, (Key const   *)key);
    }
    }
#line 238
    if (tmp___4) {
      {
      {
#line 238
      tmp___5 = auth_parse_options(pw, key_options, file, linenum);
      }
      }
#line 238
      if (tmp___5 == 1) {
        {
#line 240
        found_key = 1;
        {
#line 241
        debug("matching key found: file %s, line %lu", file, linenum);
        }
        {
#line 243
        fp = key_fingerprint((Key const   *)found, (enum fp_type )1, (enum fp_rep )0);
        }
        {
#line 244
        tmp___3 = key_type((Key const   *)found);
        }
        {
#line 244
        verbose("Found matching %s key: %s", tmp___3, fp);
        }
        {
#line 246
        xfree((void *)fp);
        }
        }
#line 247
        goto while_break;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 250
  restore_uid();
  }
  {
#line 251
  fclose(f);
  }
  {
#line 252
  key_free(found);
  }
  }
#line 253
  if (! found_key) {
    {
    {
#line 254
    debug2("key not found");
    }
    }
  }
#line 255
  return (found_key);
}
}
#line 259 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c"
int user_key_allowed(struct passwd *pw , Key *key ) 
{ 
  int success ;
  char *file ;

  {
  {
  {
#line 265
  file = authorized_keys_file(pw);
  }
  {
#line 266
  success = user_key_allowed2(pw, key, file);
  }
  {
#line 267
  xfree((void *)file);
  }
  }
#line 268
  if (success) {
#line 269
    return (success);
  }
  {
  {
#line 272
  file = authorized_keys_file2(pw);
  }
  {
#line 273
  success = user_key_allowed2(pw, key, file);
  }
  {
#line 274
  xfree((void *)file);
  }
  }
#line 275
  return (success);
}
}
#line 278 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-pubkey.c"
Authmethod method_pubkey  =    {(char *)"publickey", & userauth_pubkey, & options.pubkey_authentication};
#line 38 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-passwd.c"
static int userauth_passwd(Authctxt *authctxt___0 ) 
{ 
  char *password ;
  char *newpass ;
  int authenticated ;
  int change ;
  u_int len ;
  u_int newlen ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 42
  authenticated = 0;
  {
#line 46
  tmp = packet_get_char();
  }
#line 46
  change = (int )tmp;
  {
#line 47
  tmp___0 = packet_get_string(& len);
  }
#line 47
  password = (char *)tmp___0;
  }
#line 48
  if (change) {
    {
    {
#line 50
    tmp___1 = packet_get_string(& newlen);
    }
#line 50
    newpass = (char *)tmp___1;
    {
#line 51
    memset((void *)newpass, 0, newlen);
    }
    {
#line 52
    xfree((void *)newpass);
    }
    }
  }
  {
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 54
    tmp___2 = packet_remaining();
    }
#line 54
    _len = tmp___2;
    }
#line 54
    if (_len > 0) {
      {
      {
#line 54
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-passwd.c",
            54);
      }
      {
#line 54
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 54
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (change) {
    {
    {
#line 57
    logit("password change not supported");
    }
    }
  } else {
#line 58
    if (use_privsep) {
      {
      {
#line 58
      tmp___3 = mm_auth_password(authctxt___0, password);
      }
#line 58
      tmp___5 = tmp___3;
      }
    } else {
      {
      {
#line 58
      tmp___4 = auth_password(authctxt___0, (char const   *)password);
      }
#line 58
      tmp___5 = tmp___4;
      }
    }
#line 58
    if (tmp___5 == 1) {
#line 59
      authenticated = 1;
    }
  }
  {
  {
#line 64
  memset((void *)password, 0, len);
  }
  {
#line 65
  xfree((void *)password);
  }
  }
#line 66
  return (authenticated);
}
}
#line 69 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-passwd.c"
Authmethod method_passwd  =    {(char *)"password", & userauth_passwd, & options.password_authentication};
#line 145 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
void userauth_send_banner(char const   *msg ) ;
#line 42 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_put_cstring(char const   *str ) ;
#line 42 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c"
static int none_enabled  =    1;
#line 44 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c"
char *auth2_read_banner(void) 
{ 
  struct stat st ;
  char *banner ;
  size_t len ;
  size_t n ;
  int fd ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 48
  banner = (char *)((void *)0);
  {
#line 52
  fd = open((char const   *)options.banner, 0);
  }
  }
#line 52
  if (fd == -1) {
#line 53
    return ((char *)((void *)0));
  }
  {
  {
#line 54
  tmp = fstat(fd, & st);
  }
  }
#line 54
  if (tmp == -1) {
    {
    {
#line 55
    close(fd);
    }
    }
#line 56
    return ((char *)((void *)0));
  }
#line 58
  if (st.st_size > 1048576LL) {
    {
    {
#line 59
    close(fd);
    }
    }
#line 60
    return ((char *)((void *)0));
  }
  {
#line 63
  len = (size_t )st.st_size;
  {
#line 64
  tmp___0 = xmalloc(len + 1U);
  }
#line 64
  banner = (char *)tmp___0;
  {
#line 65
  n = atomicio(& read, fd, (void *)banner, len);
  }
  {
#line 66
  close(fd);
  }
  }
#line 68
  if (n != len) {
    {
    {
#line 69
    xfree((void *)banner);
    }
    }
#line 70
    return ((char *)((void *)0));
  }
#line 72
  *(banner + n) = (char )'\000';
#line 74
  return (banner);
}
}
#line 77 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c"
void userauth_send_banner(char const   *msg ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 80
  if (datafellows & 128) {
#line 81
    return;
  }
  {
  {
#line 83
  packet_start((u_char )53);
  }
  {
#line 84
  packet_put_cstring(msg);
  }
  {
#line 85
  packet_put_cstring("");
  }
  {
#line 86
  packet_send();
  }
  {
#line 87
  debug("%s: sent", "userauth_send_banner");
  }
  }
#line 88
  return;
}
}
#line 90 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c"
static void userauth_banner(void) 
{ 
  char *banner ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 93
  banner = (char *)((void *)0);
#line 95
  if ((unsigned long )options.banner == (unsigned long )((void *)0)) {
#line 96
    return;
  } else
#line 95
  if (datafellows & 128) {
#line 96
    return;
  }
#line 98
  if (use_privsep) {
    {
    {
#line 98
    tmp = mm_auth2_read_banner();
    }
#line 98
    banner = tmp;
    }
  } else {
    {
    {
#line 98
    tmp___0 = auth2_read_banner();
    }
#line 98
    banner = tmp___0;
    }
  }
#line 98
  if ((unsigned long )banner == (unsigned long )((void *)0)) {
#line 99
    goto done;
  }
  {
  {
#line 100
  userauth_send_banner((char const   *)banner);
  }
  }
  done: 
#line 103
  if (banner) {
    {
    {
#line 104
    xfree((void *)banner);
    }
    }
  }
#line 105
  return;
}
}
#line 107 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c"
static int userauth_none(Authctxt *authctxt___0 ) 
{ 
  int _len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 110
  none_enabled = 0;
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 111
    tmp = packet_remaining();
    }
#line 111
    _len = tmp;
    }
#line 111
    if (_len > 0) {
      {
      {
#line 111
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c",
            111);
      }
      {
#line 111
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 111
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 112
  userauth_banner();
  }
  }
#line 117
  if (options.password_authentication) {
#line 118
    if (use_privsep) {
      {
      {
#line 118
      tmp___0 = mm_auth_password(authctxt___0, (char *)"");
      }
#line 118
      tmp___2 = tmp___0;
      }
    } else {
      {
      {
#line 118
      tmp___1 = auth_password(authctxt___0, "");
      }
#line 118
      tmp___2 = tmp___1;
      }
    }
#line 118
    return (tmp___2);
  }
#line 119
  return (0);
}
}
#line 122 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-none.c"
Authmethod method_none  =    {(char *)"none", & userauth_none, & none_enabled};
#line 152 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) ;
#line 37 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-kbdint.c"
static int userauth_kbdint(Authctxt *authctxt___0 ) 
{ 
  int authenticated ;
  char *lang ;
  char *devs ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 40
  authenticated = 0;
  {
#line 43
  tmp = packet_get_string((u_int *)((void *)0));
  }
#line 43
  lang = (char *)tmp;
  {
#line 44
  tmp___0 = packet_get_string((u_int *)((void *)0));
  }
#line 44
  devs = (char *)tmp___0;
  }
  {
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 45
    tmp___1 = packet_remaining();
    }
#line 45
    _len = tmp___1;
    }
#line 45
    if (_len > 0) {
      {
      {
#line 45
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-kbdint.c",
            45);
      }
      {
#line 45
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 45
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 47
  debug("keyboard-interactive devs %s", devs);
  }
  }
#line 49
  if (options.challenge_response_authentication) {
    {
    {
#line 50
    authenticated = auth2_challenge(authctxt___0, devs);
    }
    }
  }
  {
  {
#line 52
  xfree((void *)devs);
  }
  {
#line 53
  xfree((void *)lang);
  }
  }
#line 58
  return (authenticated);
}
}
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-kbdint.c"
Authmethod method_kbdint  =    {(char *)"keyboard-interactive", & userauth_kbdint, & options.kbd_interactive_authentication};
#line 331 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 106 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int auth_rhosts2(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) ;
#line 172
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) ;
#line 15 "/home/pronto/abs/test-suite/openssh-4.3p2/canohost.h"
extern char const   *get_canonical_hostname(int  ) ;
#line 16
extern char const   *get_remote_ipaddr(void) ;
#line 47 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-hostbased.c"
static int userauth_hostbased(Authctxt *authctxt___0 ) 
{ 
  Buffer b ;
  Key *key ;
  char *pkalg ;
  char *cuser ;
  char *chost ;
  char *service ;
  u_char *pkblob ;
  u_char *sig ;
  u_int alen ;
  u_int blen ;
  u_int slen ;
  int pktype ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  u_int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 51
  key = (Key *)((void *)0);
#line 56
  authenticated = 0;
#line 58
  if (! authctxt___0->valid) {
    {
    {
#line 59
    debug2("userauth_hostbased: disabled because of invalid user");
    }
    }
#line 60
    return (0);
  }
  {
  {
#line 62
  tmp = packet_get_string(& alen);
  }
#line 62
  pkalg = (char *)tmp;
  {
#line 63
  tmp___0 = packet_get_string(& blen);
  }
#line 63
  pkblob = (u_char *)tmp___0;
  {
#line 64
  tmp___1 = packet_get_string((u_int *)((void *)0));
  }
#line 64
  chost = (char *)tmp___1;
  {
#line 65
  tmp___2 = packet_get_string((u_int *)((void *)0));
  }
#line 65
  cuser = (char *)tmp___2;
  {
#line 66
  tmp___3 = packet_get_string(& slen);
  }
#line 66
  sig = (u_char *)tmp___3;
  {
#line 68
  debug("userauth_hostbased: cuser %s chost %s pkalg %s slen %d", cuser, chost, pkalg,
        slen);
  }
  {
#line 77
  pktype = key_type_from_name(pkalg);
  }
  }
#line 78
  if (pktype == 3) {
    {
    {
#line 80
    logit("userauth_hostbased: unsupported public key algorithm: %s", pkalg);
    }
    }
#line 82
    goto done;
  }
  {
  {
#line 84
  key = key_from_blob((u_char const   *)pkblob, blen);
  }
  }
#line 85
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
    {
#line 86
    error("userauth_hostbased: cannot decode key: %s", pkalg);
    }
    }
#line 87
    goto done;
  }
#line 89
  if (key->type != pktype) {
    {
    {
#line 90
    error("userauth_hostbased: type mismatch for decoded key (received %d, expected %d)",
          key->type, pktype);
    }
    }
#line 92
    goto done;
  }
#line 94
  if (datafellows & 65536) {
#line 94
    service = (char *)"ssh-userauth";
  } else {
#line 94
    service = authctxt___0->service;
  }
  {
  {
#line 96
  buffer_init(& b);
  }
  {
#line 97
  buffer_put_string(& b, (void const   *)session_id2, session_id2_len);
  }
  {
#line 99
  buffer_put_char(& b, 50);
  }
  {
#line 100
  buffer_put_cstring(& b, (char const   *)authctxt___0->user);
  }
  {
#line 101
  buffer_put_cstring(& b, (char const   *)service);
  }
  {
#line 102
  buffer_put_cstring(& b, "hostbased");
  }
  {
#line 103
  buffer_put_string(& b, (void const   *)pkalg, alen);
  }
  {
#line 104
  buffer_put_string(& b, (void const   *)pkblob, blen);
  }
  {
#line 105
  buffer_put_cstring(& b, (char const   *)chost);
  }
  {
#line 106
  buffer_put_cstring(& b, (char const   *)cuser);
  }
#line 111
  authenticated = 0;
  }
#line 112
  if (use_privsep) {
    {
    {
#line 112
    tmp___4 = mm_hostbased_key_allowed(authctxt___0->pw, cuser, chost, key);
    }
#line 112
    tmp___6 = tmp___4;
    }
  } else {
    {
    {
#line 112
    tmp___5 = hostbased_key_allowed(authctxt___0->pw, (char const   *)cuser, chost,
                                    key);
    }
#line 112
    tmp___6 = tmp___5;
    }
  }
#line 112
  if (tmp___6) {
#line 112
    if (use_privsep) {
      {
      {
#line 112
      tmp___7 = buffer_len(& b);
      }
      {
#line 112
      tmp___8 = buffer_ptr(& b);
      }
      {
#line 112
      tmp___9 = mm_key_verify(key, sig, slen, (u_char *)tmp___8, tmp___7);
      }
#line 112
      tmp___13 = tmp___9;
      }
    } else {
      {
      {
#line 112
      tmp___10 = buffer_len(& b);
      }
      {
#line 112
      tmp___11 = buffer_ptr(& b);
      }
      {
#line 112
      tmp___12 = key_verify((Key const   *)key, (u_char const   *)sig, slen, (u_char const   *)tmp___11,
                            tmp___10);
      }
#line 112
      tmp___13 = tmp___12;
      }
    }
#line 112
    if (tmp___13 == 1) {
#line 115
      authenticated = 1;
    }
  }
  {
  {
#line 117
  buffer_free(& b);
  }
  }
  done: 
  {
  {
#line 119
  debug2("userauth_hostbased: authenticated %d", authenticated);
  }
  }
#line 120
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
    {
#line 121
    key_free(key);
    }
    }
  }
  {
  {
#line 122
  xfree((void *)pkalg);
  }
  {
#line 123
  xfree((void *)pkblob);
  }
  {
#line 124
  xfree((void *)cuser);
  }
  {
#line 125
  xfree((void *)chost);
  }
  {
#line 126
  xfree((void *)sig);
  }
  }
#line 127
  return (authenticated);
}
}
#line 131 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-hostbased.c"
int hostbased_key_allowed(struct passwd *pw , char const   *cuser , char *chost ,
                          Key *key ) 
{ 
  char const   *resolvedname ;
  char const   *ipaddr ;
  char const   *lookup ;
  HostStatus host_status ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 139
  resolvedname = get_canonical_hostname(options.use_dns);
  }
  {
#line 140
  ipaddr = get_remote_ipaddr();
  }
  {
#line 142
  debug2("userauth_hostbased: chost %s resolvedname %s ipaddr %s", chost, resolvedname,
         ipaddr);
  }
  }
#line 145
  if (options.hostbased_uses_name_from_packet_only) {
    {
    {
#line 146
    tmp = auth_rhosts2(pw, cuser, (char const   *)chost, (char const   *)chost);
    }
    }
#line 146
    if (tmp == 0) {
#line 147
      return (0);
    }
#line 148
    lookup = (char const   *)chost;
  } else {
    {
    {
#line 150
    tmp___0 = strlen((char const   *)chost);
    }
#line 150
    len = (int )tmp___0;
    }
#line 150
    if (len > 0) {
#line 150
      if ((int )*(chost + (len - 1)) == 46) {
        {
        {
#line 151
        debug2("stripping trailing dot from chost %s", chost);
        }
#line 152
        *(chost + (len - 1)) = (char )'\000';
        }
      }
    }
    {
    {
#line 154
    tmp___1 = strcasecmp(resolvedname, (char const   *)chost);
    }
    }
#line 154
    if (tmp___1 != 0) {
      {
      {
#line 155
      logit("userauth_hostbased mismatch: client sends %s, but we resolve %s to %s",
            chost, ipaddr, resolvedname);
      }
      }
    }
    {
    {
#line 158
    tmp___2 = auth_rhosts2(pw, cuser, resolvedname, ipaddr);
    }
    }
#line 158
    if (tmp___2 == 0) {
#line 159
      return (0);
    }
#line 160
    lookup = resolvedname;
  }
  {
  {
#line 162
  debug2("userauth_hostbased: access allowed by auth_rhosts2");
  }
  }
#line 164
  if (options.ignore_user_known_hosts) {
#line 164
    tmp___3 = (char const   *)((void *)0);
  } else {
#line 164
    tmp___3 = "~/.ssh/known_hosts";
  }
  {
  {
#line 164
  host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts",
                                       tmp___3);
  }
  }
#line 169
  if ((unsigned int )host_status == 1U) {
#line 170
    if (options.ignore_user_known_hosts) {
#line 170
      tmp___4 = (char const   *)((void *)0);
    } else {
#line 170
      tmp___4 = "~/.ssh/known_hosts2";
    }
    {
    {
#line 170
    host_status = check_key_in_hostfiles(pw, key, lookup, "/usr/local/etc/ssh_known_hosts2",
                                         tmp___4);
    }
    }
  }
#line 175
  return ((unsigned int )host_status == 0U);
}
}
#line 178 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-hostbased.c"
Authmethod method_hostbased  =    {(char *)"hostbased", & userauth_hostbased, & options.hostbased_authentication};
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 188
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 564 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/groupaccess.h"
int ga_init(char const   *user , gid_t base ) ;
#line 33
int ga_match(char * const  *groups , int n ) ;
#line 34
void ga_free(void) ;
#line 17 "/home/pronto/abs/test-suite/openssh-4.3p2/match.h"
extern int match_pattern(char const   * , char const   * ) ;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/groupaccess.c"
static int ngroups  ;
#line 34 "/home/pronto/abs/test-suite/openssh-4.3p2/groupaccess.c"
static char **groups_byname  ;
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/groupaccess.c"
int ga_init(char const   *user , gid_t base ) 
{ 
  gid_t *groups_bygid ;
  int i ;
  int j ;
  struct group *gr ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp14 ;

  {
#line 47
  if (ngroups > 0) {
    {
    {
#line 48
    ga_free();
    }
    }
  }
  {
#line 50
  ngroups = 65536;
  {
#line 52
  tmp___1 = sysconf(3);
  }
  }
#line 52
  if (65536L > tmp___1) {
#line 52
    ngroups = 65536;
  } else {
    {
    {
#line 52
    tmp___0 = sysconf(3);
    }
#line 52
    ngroups = (int )tmp___0;
    }
  }
  {
  {
#line 55
  tmp___2 = xmalloc((size_t )((unsigned long )ngroups * sizeof(*groups_bygid)));
  }
#line 55
  groups_bygid = (gid_t *)tmp___2;
  {
#line 56
  tmp___3 = xmalloc((size_t )((unsigned long )ngroups * sizeof(*groups_byname)));
  }
#line 56
  groups_byname = (char **)tmp___3;
  {
#line 58
  tmp___4 = getgrouplist(user, base, groups_bygid, & ngroups);
  }
  }
#line 58
  if (tmp___4 == -1) {
    {
    {
#line 59
    logit("getgrouplist: groups list too small");
    }
    }
  }
#line 60
  i = 0;
#line 60
  j = 0;
  {
  {
#line 60
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < ngroups)) {
#line 60
      goto while_break;
    }
    {
    {
#line 61
    gr = getgrgid(*(groups_bygid + i));
    }
    }
#line 61
    if ((unsigned long )gr != (unsigned long )((void *)0)) {
      {
#line 62
      tmp___5 = j;
#line 62
      j ++;
      {
#line 62
      *(groups_byname + tmp___5) = xstrdup((char const   *)gr->gr_name);
      }
      }
    }
#line 60
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 63
  xfree((void *)groups_bygid);
  }
#line 64
  ngroups = j;
  }
#line 64
  return (ngroups);
}
}
#line 71 "/home/pronto/abs/test-suite/openssh-4.3p2/groupaccess.c"
int ga_match(char * const  *groups , int n ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 76
  i = 0;
  {
  {
#line 76
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < ngroups)) {
#line 76
      goto while_break;
    }
#line 77
    j = 0;
    {
    {
#line 77
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! (j < n)) {
#line 77
        goto while_break___0;
      }
      {
      {
#line 78
      tmp = match_pattern((char const   *)*(groups_byname + i), (char const   *)*(groups + j));
      }
      }
#line 78
      if (tmp) {
#line 79
        return (1);
      }
#line 77
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 76
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (0);
}
}
#line 86 "/home/pronto/abs/test-suite/openssh-4.3p2/groupaccess.c"
void ga_free(void) 
{ 
  int i ;

  {
#line 91
  if (ngroups > 0) {
#line 92
    i = 0;
    {
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 92
      if (! (i < ngroups)) {
#line 92
        goto while_break;
      }
      {
      {
#line 93
      xfree((void *)*(groups_byname + i));
      }
#line 92
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 94
    ngroups = 0;
    {
#line 95
    xfree((void *)groups_byname);
    }
    }
  }
#line 97
  return;
}
}
#line 184 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 144 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) ;
#line 150
void privsep_challenge_enable(void) ;
#line 153
void auth2_challenge_stop(Authctxt *authctxt___0 ) ;
#line 37 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_put_char(int ch ) ;
#line 38
extern void packet_put_int(u_int value ) ;
#line 34 "/home/pronto/abs/test-suite/openssh-4.3p2/dispatch.h"
extern void dispatch_set(int  , dispatch_fn * ) ;
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) ;
#line 41
static int send_userauth_info_request(Authctxt *authctxt___0 ) ;
#line 42
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) ;
#line 55 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
KbdintDevice *devices[1]  = {      (KbdintDevice *)((void *)0)};
#line 93 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static KbdintAuthctxt *kbdint_alloc(char const   *devs ) 
{ 
  KbdintAuthctxt *kbdintctxt ;
  Buffer b ;
  int i ;
  void *tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 105
  tmp = xmalloc((size_t )sizeof(KbdintAuthctxt ));
  }
#line 105
  kbdintctxt = (KbdintAuthctxt *)tmp;
  {
#line 106
  tmp___3 = strcmp(devs, "");
  }
  }
#line 106
  if (tmp___3 == 0) {
    {
    {
#line 107
    buffer_init(& b);
    }
#line 108
    i = 0;
    }
    {
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 108
      if (! devices[i]) {
#line 108
        goto while_break;
      }
      {
      {
#line 109
      tmp___0 = buffer_len(& b);
      }
      }
#line 109
      if (tmp___0 > 0U) {
        {
        {
#line 110
        buffer_append(& b, (void const   *)",", (u_int )1);
        }
        }
      }
      {
      {
#line 111
      tmp___1 = strlen((devices[i])->name);
      }
      {
#line 111
      buffer_append(& b, (void const   *)(devices[i])->name, tmp___1);
      }
#line 108
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 114
    buffer_append(& b, (void const   *)"\000", (u_int )1);
    }
    {
#line 115
    tmp___2 = buffer_ptr(& b);
    }
    {
#line 115
    kbdintctxt->devices = xstrdup((char const   *)tmp___2);
    }
    {
#line 116
    buffer_free(& b);
    }
    }
  } else {
    {
    {
#line 118
    kbdintctxt->devices = xstrdup(devs);
    }
    }
  }
  {
  {
#line 120
  debug("kbdint_alloc: devices \'%s\'", kbdintctxt->devices);
  }
#line 121
  kbdintctxt->ctxt = (void *)0;
#line 122
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 123
  kbdintctxt->nreq = (u_int )0;
  }
#line 125
  return (kbdintctxt);
}
}
#line 127 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static void kbdint_reset_device(KbdintAuthctxt *kbdintctxt ) 
{ 


  {
#line 130
  if (kbdintctxt->ctxt) {
    {
    {
#line 131
    (*((kbdintctxt->device)->free_ctx))(kbdintctxt->ctxt);
    }
#line 132
    kbdintctxt->ctxt = (void *)0;
    }
  }
#line 134
  kbdintctxt->device = (KbdintDevice *)((void *)0);
#line 135
  return;
}
}
#line 136 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static void kbdint_free(KbdintAuthctxt *kbdintctxt ) 
{ 


  {
#line 139
  if (kbdintctxt->device) {
    {
    {
#line 140
    kbdint_reset_device(kbdintctxt);
    }
    }
  }
#line 141
  if (kbdintctxt->devices) {
    {
    {
#line 142
    xfree((void *)kbdintctxt->devices);
    }
#line 143
    kbdintctxt->devices = (char *)((void *)0);
    }
  }
  {
  {
#line 145
  xfree((void *)kbdintctxt);
  }
  }
#line 146
  return;
}
}
#line 148 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static int kbdint_next_device(KbdintAuthctxt *kbdintctxt ) 
{ 
  size_t len ;
  char *t ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 155
  if (kbdintctxt->device) {
    {
    {
#line 156
    kbdint_reset_device(kbdintctxt);
    }
    }
  }
  {
  {
#line 157
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 158
    if (kbdintctxt->devices) {
      {
      {
#line 158
      tmp = strcspn((char const   *)kbdintctxt->devices, ",");
      }
#line 158
      len = tmp;
      }
    } else {
#line 158
      len = (size_t )0;
    }
#line 161
    if (len == 0U) {
#line 162
      goto while_break;
    }
#line 163
    i = 0;
    {
    {
#line 163
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 163
      if (! devices[i]) {
#line 163
        goto while_break___0;
      }
      {
      {
#line 164
      tmp___0 = strncmp((char const   *)kbdintctxt->devices, (devices[i])->name, len);
      }
      }
#line 164
      if (tmp___0 == 0) {
#line 165
        kbdintctxt->device = devices[i];
      }
#line 163
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    t = kbdintctxt->devices;
#line 167
    if (*(t + len)) {
      {
      {
#line 167
      tmp___1 = xstrdup((char const   *)((t + len) + 1));
      }
#line 167
      kbdintctxt->devices = tmp___1;
      }
    } else {
#line 167
      kbdintctxt->devices = (char *)((void *)0);
    }
    {
    {
#line 168
    xfree((void *)t);
    }
    }
#line 169
    if (kbdintctxt->devices) {
#line 169
      tmp___2 = (char const   *)kbdintctxt->devices;
    } else {
#line 169
      tmp___2 = "<empty>";
    }
    {
    {
#line 169
    debug2("kbdint_next_device: devices %s", tmp___2);
    }
    }
#line 157
    if (kbdintctxt->devices) {
#line 157
      if (! (! kbdintctxt->device)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  if (kbdintctxt->device) {
#line 173
    tmp___3 = 1;
  } else {
#line 173
    tmp___3 = 0;
  }
#line 173
  return (tmp___3);
}
}
#line 180 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
int auth2_challenge(Authctxt *authctxt___0 , char *devs ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  KbdintAuthctxt *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 183
  if (devs) {
#line 183
    tmp = (char const   *)devs;
  } else {
#line 183
    tmp = "<no devs>";
  }
#line 183
  if (authctxt___0->user) {
#line 183
    tmp___0 = (char const   *)authctxt___0->user;
  } else {
#line 183
    tmp___0 = "<nouser>";
  }
  {
  {
#line 183
  debug("auth2_challenge: user=%s devs=%s", tmp___0, tmp);
  }
  }
#line 187
  if ((unsigned long )authctxt___0->user == (unsigned long )((void *)0)) {
#line 188
    return (0);
  } else
#line 187
  if (! devs) {
#line 188
    return (0);
  }
#line 189
  if ((unsigned long )authctxt___0->kbdintctxt == (unsigned long )((void *)0)) {
    {
    {
#line 190
    tmp___1 = kbdint_alloc((char const   *)devs);
    }
#line 190
    authctxt___0->kbdintctxt = (void *)tmp___1;
    }
  }
  {
  {
#line 191
  tmp___2 = auth2_challenge_start(authctxt___0);
  }
  }
#line 191
  return (tmp___2);
}
}
#line 195 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
void auth2_challenge_stop(Authctxt *authctxt___0 ) 
{ 


  {
  {
  {
#line 199
  dispatch_set(61, (dispatch_fn *)((void *)0));
  }
  }
#line 200
  if ((unsigned long )authctxt___0->kbdintctxt != (unsigned long )((void *)0)) {
    {
    {
#line 201
    kbdint_free((KbdintAuthctxt *)authctxt___0->kbdintctxt);
    }
#line 202
    authctxt___0->kbdintctxt = (void *)0;
    }
  }
#line 204
  return;
}
}
#line 207 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static int auth2_challenge_start(Authctxt *authctxt___0 ) 
{ 
  KbdintAuthctxt *kbdintctxt ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 210
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 212
  if (kbdintctxt->devices) {
#line 212
    tmp = (char const   *)kbdintctxt->devices;
  } else {
#line 212
    tmp = "<empty>";
  }
  {
  {
#line 212
  debug2("auth2_challenge_start: devices %s", tmp);
  }
  {
#line 215
  tmp___0 = kbdint_next_device(kbdintctxt);
  }
  }
#line 215
  if (tmp___0 == 0) {
    {
    {
#line 216
    auth2_challenge_stop(authctxt___0);
    }
    }
#line 217
    return (0);
  }
  {
  {
#line 219
  debug("auth2_challenge_start: trying authentication method \'%s\'", (kbdintctxt->device)->name);
  }
  {
#line 222
  tmp___1 = (*((kbdintctxt->device)->init_ctx))(authctxt___0);
  }
#line 222
  kbdintctxt->ctxt = tmp___1;
  }
#line 222
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
    {
#line 223
    auth2_challenge_stop(authctxt___0);
    }
    }
#line 224
    return (0);
  }
  {
  {
#line 226
  tmp___2 = send_userauth_info_request(authctxt___0);
  }
  }
#line 226
  if (tmp___2 == 0) {
    {
    {
#line 227
    auth2_challenge_stop(authctxt___0);
    }
    }
#line 228
    return (0);
  }
  {
  {
#line 230
  dispatch_set(61, & input_userauth_info_response);
  }
#line 233
  authctxt___0->postponed = 1;
  }
#line 234
  return (0);
}
}
#line 237 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static int send_userauth_info_request(Authctxt *authctxt___0 ) 
{ 
  KbdintAuthctxt *kbdintctxt ;
  char *name ;
  char *instr ;
  char **prompts ;
  u_int i ;
  u_int *echo_on ;
  int tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 244
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
  {
#line 245
  tmp = (*((kbdintctxt->device)->query))(kbdintctxt->ctxt, & name, & instr, & kbdintctxt->nreq,
                                         & prompts, & echo_on);
  }
  }
#line 245
  if (tmp) {
#line 247
    return (0);
  }
  {
  {
#line 249
  packet_start((u_char )60);
  }
  {
#line 250
  packet_put_cstring((char const   *)name);
  }
  {
#line 251
  packet_put_cstring((char const   *)instr);
  }
  {
#line 252
  packet_put_cstring("");
  }
  {
#line 253
  packet_put_int(kbdintctxt->nreq);
  }
#line 254
  i = (u_int )0;
  }
  {
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i < kbdintctxt->nreq)) {
#line 254
      goto while_break;
    }
    {
    {
#line 255
    packet_put_cstring((char const   *)*(prompts + i));
    }
    {
#line 256
    packet_put_char((int )*(echo_on + i));
    }
#line 254
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 258
  packet_send();
  }
  {
#line 259
  packet_write_wait();
  }
#line 261
  i = (u_int )0;
  }
  {
  {
#line 261
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 261
    if (! (i < kbdintctxt->nreq)) {
#line 261
      goto while_break___0;
    }
    {
    {
#line 262
    xfree((void *)*(prompts + i));
    }
#line 261
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 263
  xfree((void *)prompts);
  }
  {
#line 264
  xfree((void *)echo_on);
  }
  {
#line 265
  xfree((void *)name);
  }
  {
#line 266
  xfree((void *)instr);
  }
  }
#line 267
  return (1);
}
}
#line 270 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
static void input_userauth_info_response(int type , u_int32_t seq , void *ctxt ) 
{ 
  Authctxt *authctxt___0 ;
  KbdintAuthctxt *kbdintctxt ;
  int authenticated ;
  int res ;
  int len ;
  u_int i ;
  u_int nresp ;
  char **response ;
  char *method ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 273
  authctxt___0 = (Authctxt *)ctxt;
#line 275
  authenticated = 0;
#line 277
  response = (char **)((void *)0);
#line 279
  if ((unsigned long )authctxt___0 == (unsigned long )((void *)0)) {
    {
    {
#line 280
    fatal("input_userauth_info_response: no authctxt");
    }
    }
  }
#line 281
  kbdintctxt = (KbdintAuthctxt *)authctxt___0->kbdintctxt;
#line 282
  if ((unsigned long )kbdintctxt == (unsigned long )((void *)0)) {
    {
    {
#line 283
    fatal("input_userauth_info_response: no kbdintctxt");
    }
    }
  } else
#line 282
  if ((unsigned long )kbdintctxt->ctxt == (unsigned long )((void *)0)) {
    {
    {
#line 283
    fatal("input_userauth_info_response: no kbdintctxt");
    }
    }
  }
#line 284
  if ((unsigned long )kbdintctxt->device == (unsigned long )((void *)0)) {
    {
    {
#line 285
    fatal("input_userauth_info_response: no device");
    }
    }
  }
  {
#line 287
  authctxt___0->postponed = 0;
  {
#line 288
  nresp = packet_get_int();
  }
  }
#line 289
  if (nresp != kbdintctxt->nreq) {
    {
    {
#line 290
    fatal("input_userauth_info_response: wrong number of replies");
    }
    }
  }
#line 291
  if (nresp > 100U) {
    {
    {
#line 292
    fatal("input_userauth_info_response: too many replies");
    }
    }
  }
#line 293
  if (nresp > 0U) {
    {
    {
#line 294
    tmp = xmalloc((size_t )((unsigned long )nresp * sizeof(char *)));
    }
#line 294
    response = (char **)tmp;
#line 295
    i = (u_int )0;
    }
    {
    {
#line 295
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 295
      if (! (i < nresp)) {
#line 295
        goto while_break;
      }
      {
      {
#line 296
      tmp___0 = packet_get_string((u_int *)((void *)0));
      }
#line 296
      *(response + i) = (char *)tmp___0;
#line 295
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 298
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 298
    tmp___1 = packet_remaining();
    }
#line 298
    _len = tmp___1;
    }
#line 298
    if (_len > 0) {
      {
      {
#line 298
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c",
            298);
      }
      {
#line 298
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 298
    goto while_break___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 300
  res = (*((kbdintctxt->device)->respond))(kbdintctxt->ctxt, nresp, response);
  }
#line 302
  i = (u_int )0;
  }
  {
  {
#line 302
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 302
    if (! (i < nresp)) {
#line 302
      goto while_break___1;
    }
    {
    {
#line 303
    tmp___2 = strlen((char const   *)*(response + i));
    }
    {
#line 303
    memset((void *)*(response + i), 'r', tmp___2);
    }
    {
#line 304
    xfree((void *)*(response + i));
    }
#line 302
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 306
  if (response) {
    {
    {
#line 307
    xfree((void *)response);
    }
    }
  }
  {
#line 310
  if (res == 0) {
#line 310
    goto case_0;
  }
#line 314
  if (res == 1) {
#line 314
    goto case_1;
  }
#line 319
  goto switch_default;
  case_0: /* CIL Label */ 
#line 312
  if (authctxt___0->valid) {
#line 312
    authenticated = 1;
  } else {
#line 312
    authenticated = 0;
  }
#line 313
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 316
  tmp___3 = send_userauth_info_request(authctxt___0);
  }
  }
#line 316
  if (tmp___3 == 1) {
#line 317
    authctxt___0->postponed = 1;
  }
#line 318
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 321
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 324
  tmp___4 = strlen("keyboard-interactive");
  }
  {
#line 324
  tmp___5 = strlen((kbdintctxt->device)->name);
  }
#line 324
  len = (int )((tmp___4 + 2U) + tmp___5);
  {
#line 326
  tmp___6 = xmalloc((size_t )len);
  }
#line 326
  method = (char *)tmp___6;
  {
#line 327
  snprintf((char */* __restrict  */)method, (size_t )len, (char const   */* __restrict  */)"keyboard-interactive/%s",
           (kbdintctxt->device)->name);
  }
  }
#line 330
  if (! authctxt___0->postponed) {
#line 331
    if (authenticated) {
      {
      {
#line 332
      auth2_challenge_stop(authctxt___0);
      }
      }
    } else {
      {
      {
#line 336
      auth2_challenge_start(authctxt___0);
      }
      }
    }
  }
  {
  {
#line 339
  userauth_finish(authctxt___0, authenticated, method);
  }
  {
#line 340
  xfree((void *)method);
  }
  }
#line 341
  return;
}
}
#line 343 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2-chall.c"
void privsep_challenge_enable(void) 
{ 


  {
#line 369
  return;
}
}
#line 162 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
char *get_challenge(Authctxt *authctxt___0 ) ;
#line 163
int verify_response(Authctxt *authctxt___0 , char const   *response ) ;
#line 164
void abandon_challenge_response(Authctxt *authctxt___0 ) ;
#line 36 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-chall.c"
static KbdintDevice *device  ;
#line 39 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-chall.c"
char *get_challenge(Authctxt *authctxt___0 ) 
{ 
  char *challenge ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 51
  device = devices[0];
#line 52
  if ((unsigned long )device == (unsigned long )((void *)0)) {
#line 53
    return ((char *)((void *)0));
  }
  {
  {
#line 54
  tmp = (*(device->init_ctx))(authctxt___0);
  }
#line 54
  authctxt___0->kbdintctxt = tmp;
  }
#line 54
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 55
    return ((char *)((void *)0));
  }
  {
  {
#line 56
  tmp___0 = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                               & prompts, & echo_on);
  }
  }
#line 56
  if (tmp___0) {
    {
    {
#line 58
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
    }
#line 59
    authctxt___0->kbdintctxt = (void *)0;
    }
#line 60
    return ((char *)((void *)0));
  }
#line 62
  if (numprompts < 1U) {
    {
    {
#line 63
    fatal("get_challenge: numprompts < 1");
    }
    }
  }
  {
  {
#line 64
  challenge = xstrdup((char const   *)*(prompts + 0));
  }
#line 65
  i = (u_int )0;
  }
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    if (! (i < numprompts)) {
#line 65
      goto while_break;
    }
    {
    {
#line 66
    xfree((void *)*(prompts + i));
    }
#line 65
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 67
  xfree((void *)prompts);
  }
  {
#line 68
  xfree((void *)name);
  }
  {
#line 69
  xfree((void *)echo_on);
  }
  {
#line 70
  xfree((void *)info);
  }
  }
#line 72
  return (challenge);
}
}
#line 74 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-chall.c"
int verify_response(Authctxt *authctxt___0 , char const   *response ) 
{ 
  char *resp[1] ;
  char *name ;
  char *info ;
  char **prompts ;
  u_int i ;
  u_int numprompts ;
  u_int *echo_on ;
  int authenticated ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;

  {
#line 79
  authenticated = 0;
#line 81
  if ((unsigned long )device == (unsigned long )((void *)0)) {
#line 82
    return (0);
  }
#line 83
  if ((unsigned long )authctxt___0->kbdintctxt == (unsigned long )((void *)0)) {
#line 84
    return (0);
  }
  {
#line 85
  resp[0] = (char *)response;
  {
#line 86
  tmp = (*(device->respond))(authctxt___0->kbdintctxt, (u_int )1, resp);
  }
  }
  {
#line 87
  if (tmp == 0) {
#line 87
    goto case_0;
  }
#line 90
  if (tmp == 1) {
#line 90
    goto case_1;
  }
#line 86
  goto switch_break;
  case_0: /* CIL Label */ 
#line 88
  authenticated = 1;
#line 89
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 91
  tmp___0 = (*(device->query))(authctxt___0->kbdintctxt, & name, & info, & numprompts,
                               & prompts, & echo_on);
  }
  }
#line 91
  if (tmp___0 != 0) {
#line 93
    goto switch_break;
  }
#line 94
  if (numprompts == 0U) {
    {
    {
#line 94
    tmp___1 = (*(device->respond))(authctxt___0->kbdintctxt, (u_int )0, resp);
    }
    }
#line 94
    if (tmp___1 == 0) {
#line 96
      authenticated = 1;
    }
  }
#line 98
  i = (u_int )0;
  {
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < numprompts)) {
#line 98
      goto while_break;
    }
    {
    {
#line 99
    xfree((void *)*(prompts + i));
    }
#line 98
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 100
  xfree((void *)prompts);
  }
  {
#line 101
  xfree((void *)name);
  }
  {
#line 102
  xfree((void *)echo_on);
  }
  {
#line 103
  xfree((void *)info);
  }
  }
#line 104
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 106
  (*(device->free_ctx))(authctxt___0->kbdintctxt);
  }
#line 107
  authctxt___0->kbdintctxt = (void *)0;
  }
#line 108
  return (authenticated);
}
}
#line 110 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-chall.c"
void abandon_challenge_response(Authctxt *authctxt___0 ) 
{ 


  {
#line 113
  if ((unsigned long )authctxt___0->kbdintctxt != (unsigned long )((void *)0)) {
    {
    {
#line 114
    (*(device->free_ctx))(authctxt___0->kbdintctxt);
    }
#line 115
    authctxt___0->kbdintctxt = (void *)0;
    }
  }
#line 117
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 331
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 337
extern int printf(char const   * __restrict  __format  , ...) ;
#line 600
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 658
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 815
extern void perror(char const   *__s ) ;
#line 842
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 848
extern int pclose(FILE *__stream ) ;
#line 545 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 614
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) mkdtemp)(char *path ) ;
#line 167 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 170
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 194
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 79 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 457 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 498
extern char **environ ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execve)(char const   *__path ,
                                                                                   char * const  *__argv ,
                                                                                   char * const  *__envp ) ;
#line 526
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 792
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 801
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) setlogin)(char const   *__name ) ;
#line 845
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 81 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 101 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 111
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 200
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 164 "./channels.h"
extern Channel *channel_by_id(int  ) ;
#line 165
extern Channel *channel_lookup(int  ) ;
#line 166
extern Channel *channel_new(char * , int  , int  , int  , int  , u_int  , u_int  ,
                            int  , char * , int  ) ;
#line 167
extern void channel_set_fds(int  , int  , int  , int  , int  , int  , u_int  ) ;
#line 173
extern void channel_request_start(int  , char * , int  ) ;
#line 174
extern void channel_register_cleanup(int  , channel_callback_fn * , int  ) ;
#line 177
extern void channel_cancel_cleanup(int  ) ;
#line 201
extern void channel_close_all(void) ;
#line 208
extern void channel_permit_all_opens(void) ;
#line 211
extern void channel_input_port_forward_request(int  , int  ) ;
#line 225
extern int x11_create_display_inet(int  , int  , int  , u_int * , int ** ) ;
#line 238
extern void chan_mark_dead(Channel * ) ;
#line 247
extern void chan_write_failed(Channel * ) ;
#line 23 "/home/pronto/abs/test-suite/openssh-4.3p2/xmalloc.h"
extern void *xrealloc(void * , size_t  ) ;
#line 25 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.h"
void pty_release(char const   *tty ) ;
#line 26
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) ;
#line 27
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) ;
#line 24 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern int packet_get_connection_out(void) ;
#line 30
extern void packet_start_compression(int  ) ;
#line 31
extern void packet_set_interactive(int  ) ;
#line 84
extern void tty_parse_modes(int  , int * ) ;
#line 87
extern int packet_set_maxsize(u_int  ) ;
#line 20 "/home/pronto/abs/test-suite/openssh-4.3p2/uidswap.h"
extern void permanently_set_uid(struct passwd * ) ;
#line 66 "/home/pronto/abs/test-suite/openssh-4.3p2/compat.h"
extern int compat13 ;
#line 25 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.h"
int no_port_forwarding_flag ;
#line 26
int no_agent_forwarding_flag ;
#line 27
int no_x11_forwarding_flag ;
#line 30
struct envstring *custom_environment ;
#line 51 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
extern void log_init(char * , LogLevel  , SyslogFacility  , int  ) ;
#line 20 "/home/pronto/abs/test-suite/openssh-4.3p2/sshlogin.h"
void record_logout(pid_t pid , char const   *tty , char const   *user ) ;
#line 24 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.h"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) ;
#line 25
void server_loop2(Authctxt *authctxt___0 ) ;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/canohost.h"
extern char *get_local_ipaddr(int  ) ;
#line 24
extern int get_remote_port(void) ;
#line 25
extern int get_local_port(void) ;
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/session.h"
void do_authenticated(Authctxt *authctxt___0 ) ;
#line 62
void do_cleanup(Authctxt *authctxt___0 ) ;
#line 64
int session_open(Authctxt *authctxt___0 , int chanid ) ;
#line 65
int session_input_channel_req(Channel *c , char const   *rtype ) ;
#line 66
void session_close_by_pid(pid_t pid , int status ) ;
#line 67
void session_close_by_channel(int id , void *arg ) ;
#line 73
void session_close(Session *s ) ;
#line 74
void do_setusercontext(struct passwd *pw ) ;
#line 75
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) ;
#line 73 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) ;
#line 74
void session_pty_cleanup(Session *s ) ;
#line 75
void session_proctitle(Session *s ) ;
#line 76
int session_setup_x11fwd(Session *s ) ;
#line 77
void do_exec_pty(Session *s , char const   *command ) ;
#line 78
void do_exec_no_pty(Session *s , char const   *command ) ;
#line 79
void do_exec(Session *s , char const   *command ) ;
#line 80
void do_login(Session *s , char const   *command ) ;
#line 84
void do_child(Session *s , char const   *command ) ;
#line 85
void do_motd(void) ;
#line 86
int check_quietlogin(Session *s , char const   *command ) ;
#line 88
static void do_authenticated1(Authctxt *authctxt___0 ) ;
#line 89
static void do_authenticated2(Authctxt *authctxt___0 ) ;
#line 91
static int session_pty_req(Session *s ) ;
#line 95
extern char *__progname ;
#line 96
int log_stderr ;
#line 97
int debug_flag ;
#line 100
void destroy_sensitive_data(void) ;
#line 104 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
char const   *original_command  =    (char const   *)((void *)0);
#line 108 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
Session sessions[10]  ;
#line 114 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int is_child  =    0;
#line 117 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static char *auth_sock_name  =    (char *)((void *)0);
#line 118 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static char *auth_sock_dir  =    (char *)((void *)0);
#line 122 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void auth_sock_cleanup_proc(struct passwd *pw ) 
{ 


  {
#line 125
  if ((unsigned long )auth_sock_name != (unsigned long )((void *)0)) {
    {
    {
#line 126
    temporarily_use_uid(pw);
    }
    {
#line 127
    unlink((char const   *)auth_sock_name);
    }
    {
#line 128
    rmdir((char const   *)auth_sock_dir);
    }
#line 129
    auth_sock_name = (char *)((void *)0);
    {
#line 130
    restore_uid();
    }
    }
  }
#line 132
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int auth_input_request_forwarding(struct passwd *pw ) 
{ 
  Channel *nc ;
  int sock ;
  struct sockaddr_un sunaddr ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 141
  if ((unsigned long )auth_sock_name != (unsigned long )((void *)0)) {
    {
    {
#line 142
    error("authentication forwarding requested twice.");
    }
    }
#line 143
    return (0);
  }
  {
  {
#line 147
  temporarily_use_uid(pw);
  }
  {
#line 150
  tmp = xmalloc((size_t )4096);
  }
#line 150
  auth_sock_name = (char *)tmp;
  {
#line 151
  tmp___0 = xmalloc((size_t )4096);
  }
#line 151
  auth_sock_dir = (char *)tmp___0;
  {
#line 152
  strlcpy(auth_sock_dir, "/tmp/ssh-XXXXXXXXXX", (size_t )4096);
  }
  {
#line 155
  tmp___3 = mkdtemp(auth_sock_dir);
  }
  }
#line 155
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
    {
#line 156
    tmp___1 = __errno_location();
    }
    {
#line 156
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 156
    packet_send_debug("Agent forwarding disabled: mkdtemp() failed: %.100s", tmp___2);
    }
    {
#line 158
    restore_uid();
    }
    {
#line 159
    xfree((void *)auth_sock_name);
    }
    {
#line 160
    xfree((void *)auth_sock_dir);
    }
#line 161
    auth_sock_name = (char *)((void *)0);
#line 162
    auth_sock_dir = (char *)((void *)0);
    }
#line 163
    return (0);
  }
  {
  {
#line 165
  tmp___4 = getpid();
  }
  {
#line 165
  snprintf((char */* __restrict  */)auth_sock_name, (size_t )4096, (char const   */* __restrict  */)"%s/agent.%ld",
           auth_sock_dir, (long )tmp___4);
  }
  {
#line 169
  sock = socket(1, 1, 0);
  }
  }
#line 170
  if (sock < 0) {
    {
    {
#line 171
    tmp___5 = __errno_location();
    }
    {
#line 171
    tmp___6 = strerror(*tmp___5);
    }
    {
#line 171
    packet_disconnect("socket: %.100s", tmp___6);
    }
    }
  }
  {
  {
#line 174
  memset((void *)(& sunaddr), 0, (size_t )sizeof(sunaddr));
  }
#line 175
  sunaddr.sun_family = (sa_family_t )1;
  {
#line 176
  strlcpy(sunaddr.sun_path, (char const   *)auth_sock_name, (size_t )sizeof(sunaddr.sun_path));
  }
  {
#line 178
  tmp___9 = bind(sock, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sunaddr)),
                 (socklen_t )sizeof(sunaddr));
  }
  }
#line 178
  if (tmp___9 < 0) {
    {
    {
#line 179
    tmp___7 = __errno_location();
    }
    {
#line 179
    tmp___8 = strerror(*tmp___7);
    }
    {
#line 179
    packet_disconnect("bind: %.100s", tmp___8);
    }
    }
  }
  {
  {
#line 182
  restore_uid();
  }
  {
#line 185
  tmp___12 = listen(sock, 128);
  }
  }
#line 185
  if (tmp___12 < 0) {
    {
    {
#line 186
    tmp___10 = __errno_location();
    }
    {
#line 186
    tmp___11 = strerror(*tmp___10);
    }
    {
#line 186
    packet_disconnect("listen: %.100s", tmp___11);
    }
    }
  }
  {
  {
#line 189
  nc = channel_new((char *)"auth socket", 6, sock, sock, -1, (u_int )65536, (u_int )16384,
                   0, (char *)"auth socket", 1);
  }
  {
#line 193
  strlcpy(nc->path, (char const   *)auth_sock_name, (size_t )sizeof(nc->path));
  }
  }
#line 194
  return (1);
}
}
#line 197 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void display_loginmsg(void) 
{ 
  void *tmp ;
  u_int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 200
  tmp___0 = buffer_len(& loginmsg);
  }
  }
#line 200
  if (tmp___0 > 0U) {
    {
    {
#line 201
    buffer_append(& loginmsg, (void const   *)"\000", (u_int )1);
    }
    {
#line 202
    tmp = buffer_ptr(& loginmsg);
    }
    {
#line 202
    printf((char const   */* __restrict  */)"%s", (char *)tmp);
    }
    {
#line 203
    buffer_clear(& loginmsg);
    }
    }
  }
#line 205
  return;
}
}
#line 207 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_authenticated(Authctxt *authctxt___0 ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 210
  setproctitle("%s", (authctxt___0->pw)->pw_name);
  }
  }
#line 213
  if (! no_port_forwarding_flag) {
#line 213
    if (options.allow_tcp_forwarding) {
      {
      {
#line 214
      channel_permit_all_opens();
      }
      }
    }
  }
#line 216
  if (compat20) {
    {
    {
#line 217
    do_authenticated2(authctxt___0);
    }
    }
  } else {
    {
    {
#line 219
    do_authenticated1(authctxt___0);
    }
    }
  }
  {
  {
#line 221
  do_cleanup(authctxt___0);
  }
  }
#line 222
  return;
}
}
#line 230 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void do_authenticated1(Authctxt *authctxt___0 ) 
{ 
  Session *s ;
  char *command ;
  int success ;
  int type ;
  int screen_flag ;
  int enable_compression_after_reply ;
  u_int proto_len ;
  u_int data_len ;
  u_int dlen ;
  u_int compression_level ;
  int _len ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int _len___0 ;
  int tmp___4 ;
  u_int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int _len___1 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 236
  enable_compression_after_reply = 0;
#line 237
  compression_level = (u_int )0;
  {
#line 239
  s = session_new();
  }
  }
#line 240
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 241
    error("no more sessions");
    }
    }
#line 242
    return;
  }
#line 244
  s->authctxt = authctxt___0;
#line 245
  s->pw = authctxt___0->pw;
  {
  {
#line 251
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 252
    success = 0;
    {
#line 255
    type = packet_read();
    }
    }
    {
#line 259
    if (type == 37) {
#line 259
      goto case_37;
    }
#line 276
    if (type == 10) {
#line 276
      goto case_10;
    }
#line 280
    if (type == 34) {
#line 280
      goto case_34;
    }
#line 306
    if (type == 30) {
#line 306
      goto case_30;
    }
#line 315
    if (type == 28) {
#line 315
      goto case_28;
    }
#line 329
    if (type == 38) {
#line 329
      goto case_38;
    }
#line 335
    if (type == 13) {
#line 335
      goto case_13;
    }
#line 335
    if (type == 12) {
#line 335
      goto case_13;
    }
#line 348
    goto switch_default;
    case_37: /* CIL Label */ 
    {
    {
#line 260
    compression_level = packet_get_int();
    }
    }
    {
    {
#line 261
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 261
      tmp = packet_remaining();
      }
#line 261
      _len = tmp;
      }
#line 261
      if (_len > 0) {
        {
        {
#line 261
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
              261);
        }
        {
#line 261
        packet_disconnect("Packet integrity error.");
        }
        }
      }
#line 261
      goto while_break___0;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 262
    if (compression_level < 1U) {
      {
      {
#line 263
      packet_send_debug("Received invalid compression level %d.", compression_level);
      }
      }
#line 265
      goto switch_break;
    } else
#line 262
    if (compression_level > 9U) {
      {
      {
#line 263
      packet_send_debug("Received invalid compression level %d.", compression_level);
      }
      }
#line 265
      goto switch_break;
    }
#line 267
    if (options.compression == 0) {
      {
      {
#line 268
      debug2("compression disabled");
      }
      }
#line 269
      goto switch_break;
    }
#line 272
    enable_compression_after_reply = 1;
#line 273
    success = 1;
#line 274
    goto switch_break;
    case_10: /* CIL Label */ 
    {
    {
#line 277
    success = session_pty_req(s);
    }
    }
#line 278
    goto switch_break;
    case_34: /* CIL Label */ 
    {
    {
#line 281
    tmp___0 = packet_get_string(& proto_len);
    }
#line 281
    s->auth_proto = (char *)tmp___0;
    {
#line 282
    tmp___1 = packet_get_string(& data_len);
    }
#line 282
    s->auth_data = (char *)tmp___1;
    {
#line 284
    tmp___2 = packet_get_protocol_flags();
    }
#line 284
    screen_flag = (int )(tmp___2 & 1U);
    {
#line 286
    debug2("SSH_PROTOFLAG_SCREEN_NUMBER: %d", screen_flag);
    }
    {
#line 288
    tmp___3 = packet_remaining();
    }
    }
#line 288
    if (tmp___3 == 4) {
#line 289
      if (! screen_flag) {
        {
        {
#line 290
        debug2("Buggy client: X11 screen flag missing");
        }
        }
      }
      {
      {
#line 292
      s->screen = packet_get_int();
      }
      }
    } else {
#line 294
      s->screen = (u_int )0;
    }
    {
    {
#line 296
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 296
      tmp___4 = packet_remaining();
      }
#line 296
      _len___0 = tmp___4;
      }
#line 296
      if (_len___0 > 0) {
        {
        {
#line 296
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___0, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
              296);
        }
        {
#line 296
        packet_disconnect("Packet integrity error.");
        }
        }
      }
#line 296
      goto while_break___1;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 297
    success = session_setup_x11fwd(s);
    }
    }
#line 298
    if (! success) {
      {
      {
#line 299
      xfree((void *)s->auth_proto);
      }
      {
#line 300
      xfree((void *)s->auth_data);
      }
#line 301
      s->auth_proto = (char *)((void *)0);
#line 302
      s->auth_data = (char *)((void *)0);
      }
    }
#line 304
    goto switch_break;
    case_30: /* CIL Label */ 
#line 307
    if (no_agent_forwarding_flag) {
      {
      {
#line 308
      debug("Authentication agent forwarding not permitted for this authentication.");
      }
      }
#line 309
      goto switch_break;
    } else
#line 307
    if (compat13) {
      {
      {
#line 308
      debug("Authentication agent forwarding not permitted for this authentication.");
      }
      }
#line 309
      goto switch_break;
    }
    {
    {
#line 311
    debug("Received authentication agent forwarding request.");
    }
    {
#line 312
    success = auth_input_request_forwarding(s->pw);
    }
    }
#line 313
    goto switch_break;
    case_28: /* CIL Label */ 
#line 316
    if (no_port_forwarding_flag) {
      {
      {
#line 317
      debug("Port forwarding not permitted for this authentication.");
      }
      }
#line 318
      goto switch_break;
    }
#line 320
    if (! options.allow_tcp_forwarding) {
      {
      {
#line 321
      debug("Port forwarding not permitted.");
      }
      }
#line 322
      goto switch_break;
    }
    {
    {
#line 324
    debug("Received TCP/IP port forwarding request.");
    }
    {
#line 325
    channel_input_port_forward_request((s->pw)->pw_uid == 0U, options.gateway_ports);
    }
#line 326
    success = 1;
    }
#line 327
    goto switch_break;
    case_38: /* CIL Label */ 
    {
    {
#line 330
    tmp___5 = packet_get_int();
    }
    {
#line 330
    tmp___6 = packet_set_maxsize(tmp___5);
    }
    }
#line 330
    if (tmp___6 > 0) {
#line 331
      success = 1;
    }
#line 332
    goto switch_break;
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
#line 336
    if (type == 13) {
      {
      {
#line 337
      tmp___7 = packet_get_string(& dlen);
      }
#line 337
      command = (char *)tmp___7;
      {
#line 338
      debug("Exec command \'%.500s\'", command);
      }
      {
#line 339
      do_exec(s, (char const   *)command);
      }
      {
#line 340
      xfree((void *)command);
      }
      }
    } else {
      {
      {
#line 342
      do_exec(s, (char const   *)((void *)0));
      }
      }
    }
    {
    {
#line 344
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 344
      tmp___8 = packet_remaining();
      }
#line 344
      _len___1 = tmp___8;
      }
#line 344
      if (_len___1 > 0) {
        {
        {
#line 344
        logit("Packet integrity error (%d bytes remaining) at %s:%d", _len___1, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
              344);
        }
        {
#line 344
        packet_disconnect("Packet integrity error.");
        }
        }
      }
#line 344
      goto while_break___2;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 345
    session_close(s);
    }
    }
#line 346
    return;
    switch_default: /* CIL Label */ 
    {
    {
#line 353
    logit("Unknown packet type received after authentication: %d", type);
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 355
    if (success) {
#line 355
      tmp___9 = 14;
    } else {
#line 355
      tmp___9 = 15;
    }
    {
    {
#line 355
    packet_start((u_char )tmp___9);
    }
    {
#line 356
    packet_send();
    }
    {
#line 357
    packet_write_wait();
    }
    }
#line 360
    if (enable_compression_after_reply) {
      {
#line 361
      enable_compression_after_reply = 0;
      {
#line 362
      packet_start_compression((int )compression_level);
      }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 372 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_exec_no_pty(Session *s , char const   *command ) 
{ 
  pid_t pid ;
  int inout[2] ;
  int err[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
  {
#line 386
  tmp___1 = socketpair(1, 1, 0, (int *)(inout));
  }
  }
#line 386
  if (tmp___1 < 0) {
    {
    {
#line 388
    tmp = __errno_location();
    }
    {
#line 388
    tmp___0 = strerror(*tmp);
    }
    {
#line 388
    packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
    }
    }
  } else {
    {
    {
#line 386
    tmp___2 = socketpair(1, 1, 0, (int *)(err));
    }
    }
#line 386
    if (tmp___2 < 0) {
      {
      {
#line 388
      tmp = __errno_location();
      }
      {
#line 388
      tmp___0 = strerror(*tmp);
      }
      {
#line 388
      packet_disconnect("Could not create socket pairs: %.100s", tmp___0);
      }
      }
    }
  }
#line 391
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 392
    fatal("do_exec_no_pty: no session");
    }
    }
  }
  {
  {
#line 394
  session_proctitle(s);
  }
  {
#line 402
  pid = fork();
  }
  }
#line 402
  if (pid == 0) {
    {
#line 403
    is_child = 1;
    {
#line 406
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
    }
    {
#line 412
    tmp___5 = setsid();
    }
    }
#line 412
    if (tmp___5 < 0) {
      {
      {
#line 413
      tmp___3 = __errno_location();
      }
      {
#line 413
      tmp___4 = strerror(*tmp___3);
      }
      {
#line 413
      error("setsid failed: %.100s", tmp___4);
      }
      }
    }
    {
    {
#line 442
    close(inout[1]);
    }
    {
#line 443
    close(err[1]);
    }
    {
#line 444
    tmp___6 = dup2(inout[0], 0);
    }
    }
#line 444
    if (tmp___6 < 0) {
      {
      {
#line 445
      perror("dup2 stdin");
      }
      }
    }
    {
    {
#line 446
    tmp___7 = dup2(inout[0], 1);
    }
    }
#line 446
    if (tmp___7 < 0) {
      {
      {
#line 447
      perror("dup2 stdout");
      }
      }
    }
    {
    {
#line 448
    tmp___8 = dup2(err[0], 2);
    }
    }
#line 448
    if (tmp___8 < 0) {
      {
      {
#line 449
      perror("dup2 stderr");
      }
      }
    }
    {
    {
#line 457
    do_child(s, command);
    }
    }
  }
#line 467
  if (pid < 0) {
    {
    {
#line 468
    tmp___9 = __errno_location();
    }
    {
#line 468
    tmp___10 = strerror(*tmp___9);
    }
    {
#line 468
    packet_disconnect("fork failed: %.100s", tmp___10);
    }
    }
  }
  {
#line 469
  s->pid = pid;
  {
#line 471
  packet_set_interactive((unsigned long )s->display != (unsigned long )((void *)0));
  }
  {
#line 491
  close(inout[0]);
  }
  {
#line 492
  close(err[0]);
  }
  {
#line 499
  buffer_clear(& loginmsg);
  }
  }
#line 505
  if (compat20) {
#line 506
    if (s->is_subsystem) {
#line 506
      tmp___11 = -1;
    } else {
#line 506
      tmp___11 = err[1];
    }
    {
    {
#line 506
    session_set_fds(s, inout[1], inout[1], tmp___11);
    }
    }
  } else {
    {
    {
#line 508
    server_loop(pid, inout[1], inout[1], err[1]);
    }
    }
  }
#line 512
  return;
}
}
#line 520 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_exec_pty(Session *s , char const   *command ) 
{ 
  int fdout___0 ;
  int ptyfd ;
  int ttyfd ;
  int ptymaster ;
  pid_t pid ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 526
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 527
    fatal("do_exec_pty: no session");
    }
    }
  }
  {
#line 528
  ptyfd = s->ptyfd;
#line 529
  ttyfd = s->ttyfd;
  {
#line 540
  pid = fork();
  }
  }
#line 540
  if (pid == 0) {
    {
#line 541
    is_child = 1;
    {
#line 544
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
    }
    {
#line 546
    close(ptyfd);
    }
    {
#line 549
    pty_make_controlling_tty(& ttyfd, (char const   *)(s->tty));
    }
    {
#line 552
    tmp___1 = dup2(ttyfd, 0);
    }
    }
#line 552
    if (tmp___1 < 0) {
      {
      {
#line 553
      tmp = __errno_location();
      }
      {
#line 553
      tmp___0 = strerror(*tmp);
      }
      {
#line 553
      error("dup2 stdin: %s", tmp___0);
      }
      }
    }
    {
    {
#line 554
    tmp___4 = dup2(ttyfd, 1);
    }
    }
#line 554
    if (tmp___4 < 0) {
      {
      {
#line 555
      tmp___2 = __errno_location();
      }
      {
#line 555
      tmp___3 = strerror(*tmp___2);
      }
      {
#line 555
      error("dup2 stdout: %s", tmp___3);
      }
      }
    }
    {
    {
#line 556
    tmp___7 = dup2(ttyfd, 2);
    }
    }
#line 556
    if (tmp___7 < 0) {
      {
      {
#line 557
      tmp___5 = __errno_location();
      }
      {
#line 557
      tmp___6 = strerror(*tmp___5);
      }
      {
#line 557
      error("dup2 stderr: %s", tmp___6);
      }
      }
    }
    {
    {
#line 560
    close(ttyfd);
    }
    }
#line 564
    if (options.use_login) {
#line 564
      if (! ((unsigned long )command == (unsigned long )((void *)0))) {
        {
        {
#line 568
        do_login(s, command);
        }
        }
      }
    } else {
      {
      {
#line 568
      do_login(s, command);
      }
      }
    }
    {
    {
#line 577
    do_child(s, command);
    }
    }
  }
#line 587
  if (pid < 0) {
    {
    {
#line 588
    tmp___8 = __errno_location();
    }
    {
#line 588
    tmp___9 = strerror(*tmp___8);
    }
    {
#line 588
    packet_disconnect("fork failed: %.100s", tmp___9);
    }
    }
  }
  {
#line 589
  s->pid = pid;
  {
#line 592
  close(ttyfd);
  }
  {
#line 599
  fdout___0 = dup(ptyfd);
  }
  }
#line 600
  if (fdout___0 < 0) {
    {
    {
#line 601
    tmp___10 = __errno_location();
    }
    {
#line 601
    tmp___11 = strerror(*tmp___10);
    }
    {
#line 601
    packet_disconnect("dup #1 failed: %.100s", tmp___11);
    }
    }
  }
  {
  {
#line 604
  ptymaster = dup(ptyfd);
  }
  }
#line 605
  if (ptymaster < 0) {
    {
    {
#line 606
    tmp___12 = __errno_location();
    }
    {
#line 606
    tmp___13 = strerror(*tmp___12);
    }
    {
#line 606
    packet_disconnect("dup #2 failed: %.100s", tmp___13);
    }
    }
  }
  {
#line 607
  s->ptymaster = ptymaster;
  {
#line 610
  packet_set_interactive(1);
  }
  }
#line 611
  if (compat20) {
    {
    {
#line 612
    session_set_fds(s, ptyfd, fdout___0, -1);
    }
    }
  } else {
    {
    {
#line 614
    server_loop(pid, ptyfd, fdout___0, -1);
    }
    }
  }
#line 617
  return;
}
}
#line 651 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_exec(Session *s , char const   *command ) 
{ 
  char *__cil_tmp3 ;

  {
#line 654
  if (forced_command) {
    {
#line 655
    original_command = command;
#line 656
    command = (char const   *)forced_command;
    {
#line 657
    debug("Forced command \'%.900s\'", command);
    }
    }
  }
#line 672
  if (s->ttyfd != -1) {
    {
    {
#line 673
    do_exec_pty(s, command);
    }
    }
  } else {
    {
    {
#line 675
    do_exec_no_pty(s, command);
    }
    }
  }
  {
#line 677
  original_command = (char const   *)((void *)0);
  {
#line 684
  buffer_clear(& loginmsg);
  }
  }
#line 685
  return;
}
}
#line 688 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_login(Session *s , char const   *command ) 
{ 
  socklen_t fromlen ;
  struct sockaddr_storage from ;
  struct passwd *pw ;
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;

  {
  {
#line 693
  pw = s->pw;
  {
#line 694
  tmp = getpid();
  }
#line 694
  pid = tmp;
  {
#line 700
  memset((void *)(& from), 0, (size_t )sizeof(from));
  }
#line 701
  fromlen = (socklen_t )sizeof(from);
  {
#line 702
  tmp___4 = packet_connection_is_on_socket();
  }
  }
#line 702
  if (tmp___4) {
    {
    {
#line 703
    tmp___2 = packet_get_connection_in();
    }
    {
#line 703
    tmp___3 = getpeername(tmp___2, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                          (socklen_t */* __restrict  */)(& fromlen));
    }
    }
#line 703
    if (tmp___3 < 0) {
      {
      {
#line 705
      tmp___0 = __errno_location();
      }
      {
#line 705
      tmp___1 = strerror(*tmp___0);
      }
      {
#line 705
      debug("getpeername: %.100s", tmp___1);
      }
      {
#line 706
      cleanup_exit(255);
      }
      }
    }
  }
#line 711
  if (! use_privsep) {
    {
    {
#line 712
    tmp___5 = get_remote_name_or_ip(utmp_len, options.use_dns);
    }
    {
#line 712
    record_login(pid, (char const   *)(s->tty), (char const   *)pw->pw_name, pw->pw_uid,
                 tmp___5, (struct sockaddr *)(& from), fromlen);
    }
    }
  }
  {
  {
#line 730
  tmp___6 = check_quietlogin(s, command);
  }
  }
#line 730
  if (tmp___6) {
#line 731
    return;
  }
  {
  {
#line 733
  display_loginmsg();
  }
  {
#line 735
  do_motd();
  }
  }
#line 736
  return;
}
}
#line 741 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_motd(void) 
{ 
  FILE *f ;
  char buf___1[256] ;
  char *tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 747
  if (options.print_motd) {
    {
    {
#line 752
    f = fopen((char const   */* __restrict  */)"/etc/motd", (char const   */* __restrict  */)"r");
    }
    }
#line 754
    if (f) {
      {
      {
#line 755
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 755
        tmp = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)f);
        }
        }
#line 755
        if (! tmp) {
#line 755
          goto while_break;
        }
        {
        {
#line 756
        fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)stdout);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 757
      fclose(f);
      }
      }
    }
  }
#line 760
  return;
}
}
#line 766 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
int check_quietlogin(Session *s , char const   *command ) 
{ 
  char buf___1[256] ;
  struct passwd *pw ;
  struct stat st ;
  int tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 770
  pw = s->pw;
#line 774
  if ((unsigned long )command != (unsigned long )((void *)0)) {
#line 775
    return (1);
  }
  {
  {
#line 776
  snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.200s/.hushlogin",
           pw->pw_dir);
  }
  {
#line 781
  tmp = stat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)(& st));
  }
  }
#line 781
  if (tmp >= 0) {
#line 782
    return (1);
  }
#line 784
  return (0);
}
}
#line 791 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void child_set_env(char ***envp , u_int *envsizep , char const   *name , char const   *value ) 
{ 
  char **env ;
  u_int envsize ;
  u_int i ;
  u_int namelen ;
  void *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 803
  if ((unsigned long )*envp == (unsigned long )((void *)0)) {
#line 803
    if (*envsizep == 0U) {
      {
      {
#line 804
      tmp = xmalloc((size_t )sizeof(char *));
      }
#line 804
      *envp = (char **)tmp;
#line 805
      *(*(envp + 0)) = (char *)((void *)0);
#line 806
      *envsizep = (u_int )1;
      }
    }
  }
  {
#line 814
  env = *envp;
  {
#line 815
  namelen = strlen(name);
  }
#line 816
  i = (u_int )0;
  }
  {
  {
#line 816
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 816
    if (! *(env + i)) {
#line 816
      goto while_break;
    }
    {
    {
#line 817
    tmp___0 = strncmp((char const   *)*(env + i), name, namelen);
    }
    }
#line 817
    if (tmp___0 == 0) {
#line 817
      if ((int )*(*(env + i) + namelen) == 61) {
#line 818
        goto while_break;
      }
    }
#line 816
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  if (*(env + i)) {
    {
    {
#line 821
    xfree((void *)*(env + i));
    }
    }
  } else {
#line 824
    envsize = *envsizep;
#line 825
    if (i >= envsize - 1U) {
#line 826
      if (envsize >= 1000U) {
        {
        {
#line 827
        fatal("child_set_env: too many env vars");
        }
        }
      }
      {
#line 828
      envsize += 50U;
      {
#line 829
      tmp___2 = xrealloc((void *)env, (size_t )((unsigned long )envsize * sizeof(char *)));
      }
#line 829
      tmp___1 = (char **)tmp___2;
#line 829
      *envp = tmp___1;
#line 829
      env = tmp___1;
#line 830
      *envsizep = envsize;
      }
    }
#line 833
    *(env + (i + 1U)) = (char *)((void *)0);
  }
  {
  {
#line 837
  tmp___3 = strlen(name);
  }
  {
#line 837
  tmp___4 = strlen(value);
  }
  {
#line 837
  tmp___5 = xmalloc(((tmp___3 + 1U) + tmp___4) + 1U);
  }
#line 837
  *(env + i) = (char *)tmp___5;
  {
#line 838
  tmp___6 = strlen(name);
  }
  {
#line 838
  tmp___7 = strlen(value);
  }
  {
#line 838
  snprintf((char */* __restrict  */)*(env + i), ((tmp___6 + 1U) + tmp___7) + 1U, (char const   */* __restrict  */)"%s=%s",
           name, value);
  }
  }
#line 839
  return;
}
}
#line 847 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void read_environment_file(char ***env , u_int *envsize , char const   *filename ) 
{ 
  FILE *f ;
  char buf___1[4096] ;
  char *cp ;
  char *value ;
  u_int lineno ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 854
  lineno = (u_int )0;
  {
#line 856
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
  }
#line 857
  if (! f) {
#line 858
    return;
  }
  {
  {
#line 860
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 860
    tmp___1 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)f);
    }
    }
#line 860
    if (! tmp___1) {
#line 860
      goto while_break;
    }
#line 861
    lineno ++;
#line 861
    if (lineno > 1000U) {
      {
      {
#line 862
      fatal("Too many lines in environment file %s", filename);
      }
      }
    }
#line 863
    cp = buf___1;
    {
    {
#line 863
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 863
      if (! ((int )*cp == 32)) {
#line 863
        if (! ((int )*cp == 9)) {
#line 863
          goto while_break___0;
        }
      }
#line 863
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 865
    if (! *cp) {
#line 866
      goto while_continue;
    } else
#line 865
    if ((int )*cp == 35) {
#line 866
      goto while_continue;
    } else
#line 865
    if ((int )*cp == 10) {
#line 866
      goto while_continue;
    }
    {
    {
#line 867
    tmp___0 = strchr((char const   *)cp, '\n');
    }
    }
#line 867
    if (tmp___0) {
      {
      {
#line 868
      tmp = strchr((char const   *)cp, '\n');
      }
#line 868
      *tmp = (char )'\000';
      }
    }
    {
    {
#line 869
    value = strchr((char const   *)cp, '=');
    }
    }
#line 870
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
      {
#line 871
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad line %u in %.100s\n",
              lineno, filename);
      }
      }
#line 873
      goto while_continue;
    }
    {
#line 879
    *value = (char )'\000';
#line 880
    value ++;
    {
#line 881
    child_set_env(env, envsize, (char const   *)cp, (char const   *)value);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 883
  fclose(f);
  }
  }
#line 884
  return;
}
}
#line 941 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void copy_environment(char **source , char ***env , u_int *envsize ) 
{ 
  char *var_name ;
  char *var_val ;
  int i ;
  char *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 947
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 948
    return;
  }
#line 950
  i = 0;
  {
  {
#line 950
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 950
    if (! ((unsigned long )*(source + i) != (unsigned long )((void *)0))) {
#line 950
      goto while_break;
    }
    {
    {
#line 951
    var_name = xstrdup((char const   *)*(source + i));
    }
    {
#line 952
    var_val = strstr((char const   *)var_name, "=");
    }
    }
#line 952
    if ((unsigned long )var_val == (unsigned long )((void *)0)) {
      {
      {
#line 953
      xfree((void *)var_name);
      }
      }
#line 954
      goto __Cont;
    }
    {
#line 956
    tmp = var_val;
#line 956
    var_val ++;
#line 956
    *tmp = (char )'\000';
    {
#line 958
    debug3("Copy environment: %s=%s", var_name, var_val);
    }
    {
#line 959
    child_set_env(env, envsize, (char const   *)var_name, (char const   *)var_val);
    }
    {
#line 961
    xfree((void *)var_name);
    }
    }
    __Cont: /* CIL Label */ 
#line 950
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 963
  return;
}
}
#line 965 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static char **do_setup_env(Session *s , char const   *shell ) 
{ 
  char buf___1[256] ;
  u_int i ;
  u_int envsize ;
  char **env ;
  char *laddr ;
  char *path ;
  struct passwd *pw ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct envstring *ce ;
  char *str ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *cp ;
  char const   *tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 970
  path = (char *)((void *)0);
#line 971
  pw = s->pw;
#line 974
  envsize = (u_int )100;
  {
#line 975
  tmp = xmalloc((size_t )((unsigned long )envsize * sizeof(char *)));
  }
#line 975
  env = (char **)tmp;
#line 976
  *(env + 0) = (char *)((void *)0);
  }
#line 999
  if (! options.use_login) {
#line 1001
    i = (u_int )0;
    {
    {
#line 1001
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1001
      if (! (i < s->num_env)) {
#line 1001
        goto while_break;
      }
      {
      {
#line 1002
      child_set_env(& env, & envsize, (char const   *)(s->env + i)->name, (char const   *)(s->env + i)->val);
      }
#line 1001
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1005
    child_set_env(& env, & envsize, "USER", (char const   *)pw->pw_name);
    }
    {
#line 1006
    child_set_env(& env, & envsize, "LOGNAME", (char const   *)pw->pw_name);
    }
    {
#line 1010
    child_set_env(& env, & envsize, "HOME", (char const   *)pw->pw_dir);
    }
    }
#line 1028
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 1028
      goto _L;
    } else
#line 1028
    if ((int )*path == 0) {
      _L: /* CIL Label */ 
#line 1029
      if ((s->pw)->pw_uid == 0U) {
#line 1029
        tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
      } else {
#line 1029
        tmp___0 = "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin";
      }
      {
      {
#line 1029
      child_set_env(& env, & envsize, "PATH", tmp___0);
      }
      }
    }
    {
    {
#line 1036
    snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.200s/%.50s",
             "/var/mail", pw->pw_name);
    }
    {
#line 1038
    child_set_env(& env, & envsize, "MAIL", (char const   *)(buf___1));
    }
    {
#line 1041
    child_set_env(& env, & envsize, "SHELL", shell);
    }
    }
  }
  {
  {
#line 1043
  tmp___2 = getenv("TZ");
  }
  }
#line 1043
  if (tmp___2) {
    {
    {
#line 1044
    tmp___1 = getenv("TZ");
    }
    {
#line 1044
    child_set_env(& env, & envsize, "TZ", (char const   *)tmp___1);
    }
    }
  }
#line 1047
  if (! options.use_login) {
    {
    {
#line 1048
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1048
      if (! custom_environment) {
#line 1048
        goto while_break___0;
      }
#line 1049
      ce = custom_environment;
#line 1050
      str = ce->s;
#line 1052
      i = (u_int )0;
      {
      {
#line 1052
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 1052
        if ((int )*(str + i) != 61) {
#line 1052
          if (! *(str + i)) {
#line 1052
            goto while_break___1;
          }
        } else {
#line 1052
          goto while_break___1;
        }
#line 1052
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1054
      if ((int )*(str + i) == 61) {
        {
#line 1055
        *(str + i) = (char)0;
        {
#line 1056
        child_set_env(& env, & envsize, (char const   *)str, (char const   *)((str + i) + 1));
        }
        }
      }
      {
#line 1058
      custom_environment = ce->next;
      {
#line 1059
      xfree((void *)ce->s);
      }
      {
#line 1060
      xfree((void *)ce);
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  {
#line 1065
  tmp___3 = get_local_port();
  }
  {
#line 1065
  tmp___4 = get_remote_port();
  }
  {
#line 1065
  tmp___5 = get_remote_ipaddr();
  }
  {
#line 1065
  snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.50s %d %d",
           tmp___5, tmp___4, tmp___3);
  }
  {
#line 1067
  child_set_env(& env, & envsize, "SSH_CLIENT", (char const   *)(buf___1));
  }
  {
#line 1069
  tmp___6 = packet_get_connection_in();
  }
  {
#line 1069
  laddr = get_local_ipaddr(tmp___6);
  }
  {
#line 1070
  tmp___7 = get_local_port();
  }
  {
#line 1070
  tmp___8 = get_remote_port();
  }
  {
#line 1070
  tmp___9 = get_remote_ipaddr();
  }
  {
#line 1070
  snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.50s %d %.50s %d",
           tmp___9, tmp___8, laddr, tmp___7);
  }
  {
#line 1072
  xfree((void *)laddr);
  }
  {
#line 1073
  child_set_env(& env, & envsize, "SSH_CONNECTION", (char const   *)(buf___1));
  }
  }
#line 1075
  if (s->ttyfd != -1) {
    {
    {
#line 1076
    child_set_env(& env, & envsize, "SSH_TTY", (char const   *)(s->tty));
    }
    }
  }
#line 1077
  if (s->term) {
    {
    {
#line 1078
    child_set_env(& env, & envsize, "TERM", (char const   *)s->term);
    }
    }
  }
#line 1079
  if (s->display) {
    {
    {
#line 1080
    child_set_env(& env, & envsize, "DISPLAY", (char const   *)s->display);
    }
    }
  }
#line 1081
  if (original_command) {
    {
    {
#line 1082
    child_set_env(& env, & envsize, "SSH_ORIGINAL_COMMAND", original_command);
    }
    }
  }
  {
  {
#line 1098
  cp = getenv("KRB5CCNAME");
  }
  }
#line 1098
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
    {
#line 1099
    child_set_env(& env, & envsize, "KRB5CCNAME", (char const   *)cp);
    }
    }
  }
#line 1134
  if ((unsigned long )auth_sock_name != (unsigned long )((void *)0)) {
    {
    {
#line 1135
    child_set_env(& env, & envsize, "SSH_AUTH_SOCK", (char const   *)auth_sock_name);
    }
    }
  }
#line 1139
  if (options.permit_user_env) {
#line 1139
    if (! options.use_login) {
      {
      {
#line 1140
      tmp___12 = strcmp((char const   *)pw->pw_dir, "/");
      }
      }
#line 1140
      if (tmp___12) {
#line 1140
        tmp___11 = (char const   *)pw->pw_dir;
      } else {
#line 1140
        tmp___11 = "";
      }
      {
      {
#line 1140
      snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.200s/.ssh/environment",
               tmp___11);
      }
      {
#line 1142
      read_environment_file(& env, & envsize, (char const   *)(buf___1));
      }
      }
    }
  }
#line 1144
  if (debug_flag) {
    {
    {
#line 1146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Environment:\n");
    }
#line 1147
    i = (u_int )0;
    }
    {
    {
#line 1147
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1147
      if (! *(env + i)) {
#line 1147
        goto while_break___2;
      }
      {
      {
#line 1148
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %.200s\n",
              *(env + i));
      }
#line 1147
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1150
  return (env);
}
}
#line 1157 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void do_rc_files(Session *s , char const   *shell ) 
{ 
  FILE *f ;
  char cmd[1024] ;
  int do_xauth ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1160
  f = (FILE *)((void *)0);
#line 1165
  if ((unsigned long )s->display != (unsigned long )((void *)0)) {
#line 1165
    if ((unsigned long )s->auth_proto != (unsigned long )((void *)0)) {
#line 1165
      if ((unsigned long )s->auth_data != (unsigned long )((void *)0)) {
#line 1165
        tmp = 1;
      } else {
#line 1165
        tmp = 0;
      }
    } else {
#line 1165
      tmp = 0;
    }
  } else {
#line 1165
    tmp = 0;
  }
#line 1165
  do_xauth = tmp;
#line 1169
  if (! s->is_subsystem) {
    {
    {
#line 1169
    tmp___1 = stat((char const   */* __restrict  */)".ssh/rc", (struct stat */* __restrict  */)(& st));
    }
    }
#line 1169
    if (tmp___1 >= 0) {
      {
      {
#line 1170
      snprintf((char */* __restrict  */)(cmd), (size_t )sizeof(cmd), (char const   */* __restrict  */)"%s -c \'%s %s\'",
               shell, "/bin/sh", ".ssh/rc");
      }
      }
#line 1172
      if (debug_flag) {
        {
        {
#line 1173
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Running %s\n",
                cmd);
        }
        }
      }
      {
      {
#line 1174
      f = popen((char const   *)(cmd), "w");
      }
      }
#line 1175
      if (f) {
#line 1176
        if (do_xauth) {
          {
          {
#line 1177
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s %s\n",
                  s->auth_proto, s->auth_data);
          }
          }
        }
        {
        {
#line 1179
        pclose(f);
        }
        }
      } else {
        {
        {
#line 1181
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not run %s\n",
                ".ssh/rc");
        }
        }
      }
    } else {
#line 1169
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 1183
    tmp___0 = stat((char const   */* __restrict  */)"/usr/local/etc/sshrc", (struct stat */* __restrict  */)(& st));
    }
    }
#line 1183
    if (tmp___0 >= 0) {
#line 1184
      if (debug_flag) {
        {
        {
#line 1185
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Running %s %s\n",
                "/bin/sh", "/usr/local/etc/sshrc");
        }
        }
      }
      {
      {
#line 1187
      f = popen("/bin/sh /usr/local/etc/sshrc", "w");
      }
      }
#line 1188
      if (f) {
#line 1189
        if (do_xauth) {
          {
          {
#line 1190
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s %s\n",
                  s->auth_proto, s->auth_data);
          }
          }
        }
        {
        {
#line 1192
        pclose(f);
        }
        }
      } else {
        {
        {
#line 1194
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not run %s\n",
                "/usr/local/etc/sshrc");
        }
        }
      }
    } else
#line 1196
    if (do_xauth) {
#line 1196
      if ((unsigned long )options.xauth_location != (unsigned long )((void *)0)) {
#line 1198
        if (debug_flag) {
          {
          {
#line 1199
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Running %.500s remove %.100s\n",
                  options.xauth_location, s->auth_display);
          }
          {
#line 1202
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%.500s add %.100s %.100s %.100s\n",
                  options.xauth_location, s->auth_display, s->auth_proto, s->auth_data);
          }
          }
        }
        {
        {
#line 1207
        snprintf((char */* __restrict  */)(cmd), (size_t )sizeof(cmd), (char const   */* __restrict  */)"%s -q -",
                 options.xauth_location);
        }
        {
#line 1209
        f = popen((char const   *)(cmd), "w");
        }
        }
#line 1210
        if (f) {
          {
          {
#line 1211
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"remove %s\n",
                  s->auth_display);
          }
          {
#line 1213
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"add %s %s %s\n",
                  s->auth_display, s->auth_proto, s->auth_data);
          }
          {
#line 1216
          pclose(f);
          }
          }
        } else {
          {
          {
#line 1218
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not run %s\n",
                  cmd);
          }
          }
        }
      }
    }
  }
#line 1222
  return;
}
}
#line 1224 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void do_nologin(struct passwd *pw ) 
{ 
  FILE *f ;
  char buf___1[1024] ;
  char *tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1227
  f = (FILE *)((void *)0);
#line 1235
  if (pw->pw_uid) {
    {
    {
#line 1236
    f = fopen((char const   */* __restrict  */)"/etc/nologin", (char const   */* __restrict  */)"r");
    }
    }
  }
#line 1238
  if (f) {
    {
    {
#line 1240
    logit("User %.100s not allowed because %s exists", pw->pw_name, "/etc/nologin");
    }
    }
    {
    {
#line 1242
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1242
      tmp = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)f);
      }
      }
#line 1242
      if (! tmp) {
#line 1242
        goto while_break;
      }
      {
      {
#line 1243
      fputs((char const   */* __restrict  */)(buf___1), (FILE */* __restrict  */)stderr);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1244
    fclose(f);
    }
    {
#line 1245
    fflush((FILE *)((void *)0));
    }
    {
#line 1246
    exit(254);
    }
    }
  }
#line 1248
  return;
}
}
#line 1251 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_setusercontext(struct passwd *pw ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  __uid_t tmp___4 ;
  __uid_t tmp___5 ;
  __uid_t tmp___6 ;
  __uid_t tmp___7 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1255
  tmp___4 = getuid();
  }
  }
#line 1255
  if (tmp___4 == 0U) {
#line 1255
    goto _L;
  } else {
    {
    {
#line 1255
    tmp___5 = geteuid();
    }
    }
#line 1255
    if (tmp___5 == 0U) {
      _L: /* CIL Label */ 
      {
      {
#line 1292
      tmp___1 = setlogin((char const   *)pw->pw_name);
      }
      }
#line 1292
      if (tmp___1 < 0) {
        {
        {
#line 1293
        tmp = __errno_location();
        }
        {
#line 1293
        tmp___0 = strerror(*tmp);
        }
        {
#line 1293
        error("setlogin failed: %s", tmp___0);
        }
        }
      }
      {
      {
#line 1294
      tmp___2 = setgid(pw->pw_gid);
      }
      }
#line 1294
      if (tmp___2 < 0) {
        {
        {
#line 1295
        perror("setgid");
        }
        {
#line 1296
        exit(1);
        }
        }
      }
      {
      {
#line 1299
      tmp___3 = initgroups((char const   *)pw->pw_name, pw->pw_gid);
      }
      }
#line 1299
      if (tmp___3 < 0) {
        {
        {
#line 1300
        perror("initgroups");
        }
        {
#line 1301
        exit(1);
        }
        }
      }
      {
      {
#line 1303
      endgrent();
      }
      {
#line 1334
      permanently_set_uid(pw);
      }
      }
    }
  }
  {
  {
#line 1341
  tmp___6 = getuid();
  }
  }
#line 1341
  if (tmp___6 != pw->pw_uid) {
    {
    {
#line 1342
    fatal("Failed to set uids to %u.", pw->pw_uid);
    }
    }
  } else {
    {
    {
#line 1341
    tmp___7 = geteuid();
    }
    }
#line 1341
    if (tmp___7 != pw->pw_uid) {
      {
      {
#line 1342
      fatal("Failed to set uids to %u.", pw->pw_uid);
      }
      }
    }
  }
#line 1343
  return;
}
}
#line 1345 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void do_pwchange(Session *s ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 1348
  fflush((FILE *)((void *)0));
  }
  {
#line 1349
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Your password has expired.\n");
  }
  }
#line 1350
  if (s->ttyfd != -1) {
    {
    {
#line 1351
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must change your password now and login again!\n");
    }
    {
#line 1357
    execl("/usr/bin/passwd", "passwd", (char *)((void *)0));
    }
    {
#line 1359
    perror("passwd");
    }
    }
  } else {
    {
    {
#line 1361
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Password change required but no TTY available.\n");
    }
    }
  }
  {
  {
#line 1364
  exit(1);
  }
  }
}
}
#line 1367 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void launch_login(struct passwd *pw , char const   *hostname ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1372
  execl("/bin/login", "login", "-h", hostname, "-p", "-f", "--", pw->pw_name, (char *)((void *)0));
  }
  {
#line 1384
  perror("login");
  }
  {
#line 1385
  exit(1);
  }
  }
}
}
#line 1388 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void child_close_fds(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 1393
  tmp___2 = packet_get_connection_in();
  }
  {
#line 1393
  tmp___3 = packet_get_connection_out();
  }
  }
#line 1393
  if (tmp___2 == tmp___3) {
    {
    {
#line 1394
    tmp = packet_get_connection_in();
    }
    {
#line 1394
    close(tmp);
    }
    }
  } else {
    {
    {
#line 1396
    tmp___0 = packet_get_connection_in();
    }
    {
#line 1396
    close(tmp___0);
    }
    {
#line 1397
    tmp___1 = packet_get_connection_out();
    }
    {
#line 1397
    close(tmp___1);
    }
    }
  }
  {
  {
#line 1404
  channel_close_all();
  }
  {
#line 1410
  endpwent();
  }
#line 1418
  i = 3;
  }
  {
  {
#line 1418
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1418
    if (! (i < 64)) {
#line 1418
      goto while_break;
    }
    {
    {
#line 1419
    close(i);
    }
#line 1418
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  return;
}
}
#line 1427 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_child(Session *s , char const   *command ) 
{ 
  char **env ;
  char *argv[10] ;
  char const   *shell ;
  char const   *shell0 ;
  char const   *hostname ;
  struct passwd *pw ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char argv0[256] ;
  int *tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 1433
  hostname = (char const   *)((void *)0);
#line 1434
  pw = s->pw;
  {
#line 1437
  destroy_sensitive_data();
  }
  }
#line 1440
  if ((s->authctxt)->force_pwchange) {
    {
    {
#line 1441
    do_setusercontext(pw);
    }
    {
#line 1442
    child_close_fds();
    }
    {
#line 1443
    do_pwchange(s);
    }
    {
#line 1444
    exit(1);
    }
    }
  }
#line 1448
  if (options.use_login) {
#line 1448
    if ((unsigned long )command != (unsigned long )((void *)0)) {
#line 1449
      options.use_login = 0;
    }
  }
#line 1459
  if (! options.use_login) {
#line 1466
    if (! options.use_pam) {
      {
      {
#line 1467
      do_nologin(pw);
      }
      }
    }
    {
    {
#line 1468
    do_setusercontext(pw);
    }
    {
#line 1474
    tmp = check_quietlogin(s, command);
    }
    }
#line 1474
    if (! tmp) {
      {
      {
#line 1475
      display_loginmsg();
      }
      }
    }
  }
#line 1491
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 1491
    shell = "/bin/sh";
  } else {
#line 1491
    shell = (char const   *)pw->pw_shell;
  }
  {
  {
#line 1497
  env = do_setup_env(s, shell);
  }
  }
#line 1504
  if (options.use_login) {
    {
    {
#line 1505
    hostname = get_remote_name_or_ip(utmp_len, options.use_dns);
    }
    }
  }
  {
  {
#line 1514
  child_close_fds();
  }
#line 1520
  environ = env;
  {
#line 1549
  tmp___2 = chdir((char const   *)pw->pw_dir);
  }
  }
#line 1549
  if (tmp___2 < 0) {
    {
    {
#line 1550
    tmp___0 = __errno_location();
    }
    {
#line 1550
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 1550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not chdir to home directory %s: %s\n",
            pw->pw_dir, tmp___1);
    }
    }
  }
#line 1558
  if (! options.use_login) {
    {
    {
#line 1559
    do_rc_files(s, shell);
    }
    }
  }
  {
  {
#line 1562
  mysignal(13, (void (*)(int  ))0);
  }
  }
#line 1564
  if (options.use_login) {
    {
    {
#line 1565
    launch_login(pw, hostname);
    }
    }
  }
  {
  {
#line 1570
  tmp___3 = strrchr(shell, '/');
  }
#line 1570
  shell0 = (char const   *)tmp___3;
  }
#line 1570
  if ((unsigned long )shell0 != (unsigned long )((void *)0)) {
#line 1571
    shell0 ++;
  } else {
#line 1573
    shell0 = shell;
  }
#line 1580
  if (! command) {
    {
#line 1584
    argv0[0] = (char )'-';
    {
#line 1586
    tmp___5 = strlcpy(argv0 + 1, shell0, (size_t )(sizeof(argv0) - 1UL));
    }
    }
#line 1586
    if ((unsigned long )tmp___5 >= sizeof(argv0) - 1UL) {
      {
      {
#line 1588
      tmp___4 = __errno_location();
      }
#line 1588
      *tmp___4 = 22;
      {
#line 1589
      perror(shell);
      }
      {
#line 1590
      exit(1);
      }
      }
    }
    {
#line 1594
    argv[0] = argv0;
#line 1595
    argv[1] = (char *)((void *)0);
    {
#line 1596
    execve(shell, (char * const  *)(argv), (char * const  *)env);
    }
    {
#line 1599
    perror(shell);
    }
    {
#line 1600
    exit(1);
    }
    }
  }
  {
#line 1606
  argv[0] = (char *)shell0;
#line 1607
  argv[1] = (char *)"-c";
#line 1608
  argv[2] = (char *)command;
#line 1609
  argv[3] = (char *)((void *)0);
  {
#line 1610
  execve(shell, (char * const  *)(argv), (char * const  *)env);
  }
  {
#line 1611
  perror(shell);
  }
  {
#line 1612
  exit(1);
  }
  }
}
}
#line 1619 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int did_init  =    0;
#line 1615 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
Session *session_new(void) 
{ 
  int i ;
  Session *s ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1620
  if (! did_init) {
    {
    {
#line 1621
    debug("session_new: init");
    }
#line 1622
    i = 0;
    }
    {
    {
#line 1622
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1622
      if (! (i < 10)) {
#line 1622
        goto while_break;
      }
#line 1623
      sessions[i].used = 0;
#line 1622
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1625
    did_init = 1;
  }
#line 1627
  i = 0;
  {
  {
#line 1627
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1627
    if (! (i < 10)) {
#line 1627
      goto while_break___0;
    }
#line 1628
    s = & sessions[i];
#line 1629
    if (! s->used) {
      {
      {
#line 1630
      memset((void *)s, 0, (size_t )sizeof(*s));
      }
#line 1631
      s->chanid = -1;
#line 1632
      s->ptyfd = -1;
#line 1633
      s->ttyfd = -1;
#line 1634
      s->used = 1;
#line 1635
      s->self = i;
#line 1636
      s->x11_chanids = (int *)((void *)0);
      {
#line 1637
      debug("session_new: session %d", i);
      }
      }
#line 1638
      return (s);
    }
#line 1627
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1641
  return ((Session *)((void *)0));
}
}
#line 1644 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void session_dump(void) 
{ 
  int i ;
  Session *s ;
  char *__cil_tmp3 ;

  {
#line 1648
  i = 0;
  {
  {
#line 1648
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1648
    if (! (i < 10)) {
#line 1648
      goto while_break;
    }
    {
#line 1649
    s = & sessions[i];
    {
#line 1650
    debug("dump: used %d session %d %p channel %d pid %ld", s->used, s->self, s, s->chanid,
          (long )s->pid);
    }
#line 1648
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1657
  return;
}
}
#line 1659 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
int session_open(Authctxt *authctxt___0 , int chanid ) 
{ 
  Session *s ;
  Session *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1662
  tmp = session_new();
  }
#line 1662
  s = tmp;
  {
#line 1663
  debug("session_open: channel %d", chanid);
  }
  }
#line 1664
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 1665
    error("no more sessions");
    }
    }
#line 1666
    return (0);
  }
#line 1668
  s->authctxt = authctxt___0;
#line 1669
  s->pw = authctxt___0->pw;
#line 1670
  if ((unsigned long )s->pw == (unsigned long )((void *)0)) {
    {
    {
#line 1671
    fatal("no user for session %d", s->self);
    }
    }
  } else
#line 1670
  if (! authctxt___0->valid) {
    {
    {
#line 1671
    fatal("no user for session %d", s->self);
    }
    }
  }
  {
  {
#line 1672
  debug("session_open: session %d: link with channel %d", s->self, chanid);
  }
#line 1673
  s->chanid = chanid;
  }
#line 1674
  return (1);
}
}
#line 1677 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
Session *session_by_tty(char *tty ) 
{ 
  int i ;
  Session *s ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1681
  i = 0;
  {
  {
#line 1681
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1681
    if (! (i < 10)) {
#line 1681
      goto while_break;
    }
#line 1682
    s = & sessions[i];
#line 1683
    if (s->used) {
#line 1683
      if (s->ttyfd != -1) {
        {
        {
#line 1683
        tmp = strcmp((char const   *)(s->tty), (char const   *)tty);
        }
        }
#line 1683
        if (tmp == 0) {
          {
          {
#line 1684
          debug("session_by_tty: session %d tty %s", i, tty);
          }
          }
#line 1685
          return (s);
        }
      }
    }
#line 1681
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1688
  debug("session_by_tty: unknown tty %.100s", tty);
  }
  {
#line 1689
  session_dump();
  }
  }
#line 1690
  return ((Session *)((void *)0));
}
}
#line 1693 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static Session *session_by_channel(int id ) 
{ 
  int i ;
  Session *s ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1697
  i = 0;
  {
  {
#line 1697
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1697
    if (! (i < 10)) {
#line 1697
      goto while_break;
    }
#line 1698
    s = & sessions[i];
#line 1699
    if (s->used) {
#line 1699
      if (s->chanid == id) {
        {
        {
#line 1700
        debug("session_by_channel: session %d channel %d", i, id);
        }
        }
#line 1701
        return (s);
      }
    }
#line 1697
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1704
  debug("session_by_channel: unknown channel %d", id);
  }
  {
#line 1705
  session_dump();
  }
  }
#line 1706
  return ((Session *)((void *)0));
}
}
#line 1709 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static Session *session_by_x11_channel(int id ) 
{ 
  int i ;
  int j ;
  Session *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1714
  i = 0;
  {
  {
#line 1714
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1714
    if (! (i < 10)) {
#line 1714
      goto while_break;
    }
#line 1715
    s = & sessions[i];
#line 1717
    if ((unsigned long )s->x11_chanids == (unsigned long )((void *)0)) {
#line 1718
      goto __Cont;
    } else
#line 1717
    if (! s->used) {
#line 1718
      goto __Cont;
    }
#line 1719
    j = 0;
    {
    {
#line 1719
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1719
      if (! (*(s->x11_chanids + j) != -1)) {
#line 1719
        goto while_break___0;
      }
#line 1720
      if (*(s->x11_chanids + j) == id) {
        {
        {
#line 1721
        debug("session_by_x11_channel: session %d channel %d", s->self, id);
        }
        }
#line 1723
        return (s);
      }
#line 1719
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1714
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1727
  debug("session_by_x11_channel: unknown channel %d", id);
  }
  {
#line 1728
  session_dump();
  }
  }
#line 1729
  return ((Session *)((void *)0));
}
}
#line 1732 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static Session *session_by_pid(pid_t pid ) 
{ 
  int i ;
  Session *s ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1736
  debug("session_by_pid: pid %ld", (long )pid);
  }
#line 1737
  i = 0;
  }
  {
  {
#line 1737
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1737
    if (! (i < 10)) {
#line 1737
      goto while_break;
    }
#line 1738
    s = & sessions[i];
#line 1739
    if (s->used) {
#line 1739
      if (s->pid == pid) {
#line 1740
        return (s);
      }
    }
#line 1737
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1742
  error("session_by_pid: unknown pid %ld", (long )pid);
  }
  {
#line 1743
  session_dump();
  }
  }
#line 1744
  return ((Session *)((void *)0));
}
}
#line 1747 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_window_change_req(Session *s ) 
{ 
  int _len ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1750
  s->col = packet_get_int();
  }
  {
#line 1751
  s->row = packet_get_int();
  }
  {
#line 1752
  s->xpixel = packet_get_int();
  }
  {
#line 1753
  s->ypixel = packet_get_int();
  }
  }
  {
  {
#line 1754
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1754
    tmp = packet_remaining();
    }
#line 1754
    _len = tmp;
    }
#line 1754
    if (_len > 0) {
      {
      {
#line 1754
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1754);
      }
      {
#line 1754
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1754
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1755
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
  }
  }
#line 1756
  return (1);
}
}
#line 1759 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_pty_req(Session *s ) 
{ 
  u_int len ;
  int n_bytes ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int _len ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1765
  if (no_pty_flag) {
    {
    {
#line 1766
    debug("Allocating a pty not permitted for this authentication.");
    }
    }
#line 1767
    return (0);
  }
#line 1769
  if (s->ttyfd != -1) {
    {
    {
#line 1770
    packet_disconnect("Protocol error: you already have a pty.");
    }
    }
#line 1771
    return (0);
  }
  {
  {
#line 1774
  tmp = packet_get_string(& len);
  }
#line 1774
  s->term = (char *)tmp;
  }
#line 1776
  if (compat20) {
    {
    {
#line 1777
    s->col = packet_get_int();
    }
    {
#line 1778
    s->row = packet_get_int();
    }
    }
  } else {
    {
    {
#line 1780
    s->row = packet_get_int();
    }
    {
#line 1781
    s->col = packet_get_int();
    }
    }
  }
  {
  {
#line 1783
  s->xpixel = packet_get_int();
  }
  {
#line 1784
  s->ypixel = packet_get_int();
  }
  {
#line 1786
  tmp___0 = strcmp((char const   *)s->term, "");
  }
  }
#line 1786
  if (tmp___0 == 0) {
    {
    {
#line 1787
    xfree((void *)s->term);
    }
#line 1788
    s->term = (char *)((void *)0);
    }
  }
  {
  {
#line 1792
  debug("Allocating pty.");
  }
  }
#line 1793
  if (use_privsep) {
    {
    {
#line 1793
    tmp___1 = mm_pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
    }
#line 1793
    tmp___3 = tmp___1;
    }
  } else {
    {
    {
#line 1793
    tmp___2 = pty_allocate(& s->ptyfd, & s->ttyfd, s->tty, (int )sizeof(s->tty));
    }
#line 1793
    tmp___3 = tmp___2;
    }
  }
#line 1793
  if (! tmp___3) {
#line 1794
    if (s->term) {
      {
      {
#line 1795
      xfree((void *)s->term);
      }
      }
    }
    {
#line 1796
    s->term = (char *)((void *)0);
#line 1797
    s->ptyfd = -1;
#line 1798
    s->ttyfd = -1;
    {
#line 1799
    error("session_pty_req: session %d alloc failed", s->self);
    }
    }
#line 1800
    return (0);
  }
  {
  {
#line 1802
  debug("session_pty_req: session %d alloc %s", s->self, s->tty);
  }
  }
#line 1805
  if (! compat20) {
    {
    {
#line 1806
    n_bytes = packet_remaining();
    }
    }
  }
  {
  {
#line 1807
  tty_parse_modes(s->ttyfd, & n_bytes);
  }
  }
#line 1809
  if (! use_privsep) {
    {
    {
#line 1810
    pty_setowner(s->pw, (char const   *)(s->tty));
    }
    }
  }
  {
  {
#line 1813
  pty_change_window_size(s->ptyfd, (int )s->row, (int )s->col, (int )s->xpixel, (int )s->ypixel);
  }
  }
  {
  {
#line 1815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1815
    tmp___4 = packet_remaining();
    }
#line 1815
    _len = tmp___4;
    }
#line 1815
    if (_len > 0) {
      {
      {
#line 1815
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1815);
      }
      {
#line 1815
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1815
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1816
  session_proctitle(s);
  }
  }
#line 1817
  return (1);
}
}
#line 1820 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_subsystem_req(Session *s ) 
{ 
  struct stat st ;
  u_int len ;
  int success ;
  char *cmd ;
  char *subsys ;
  void *tmp ;
  u_int i ;
  int _len ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 1825
  success = 0;
  {
#line 1826
  tmp = packet_get_string(& len);
  }
#line 1826
  subsys = (char *)tmp;
  }
  {
  {
#line 1829
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1829
    tmp___0 = packet_remaining();
    }
#line 1829
    _len = tmp___0;
    }
#line 1829
    if (_len > 0) {
      {
      {
#line 1829
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1829);
      }
      {
#line 1829
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1829
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1830
  logit("subsystem request for %.100s", subsys);
  }
#line 1832
  i = (u_int )0;
  }
  {
  {
#line 1832
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1832
    if (! (i < options.num_subsystems)) {
#line 1832
      goto while_break___0;
    }
    {
    {
#line 1833
    tmp___4 = strcmp((char const   *)subsys, (char const   *)options.subsystem_name[i]);
    }
    }
#line 1833
    if (tmp___4 == 0) {
      {
#line 1834
      cmd = options.subsystem_command[i];
      {
#line 1835
      tmp___3 = stat((char const   */* __restrict  */)cmd, (struct stat */* __restrict  */)(& st));
      }
      }
#line 1835
      if (tmp___3 < 0) {
        {
        {
#line 1836
        tmp___1 = __errno_location();
        }
        {
#line 1836
        tmp___2 = strerror(*tmp___1);
        }
        {
#line 1836
        error("subsystem: cannot stat %s: %s", cmd, tmp___2);
        }
        }
#line 1838
        goto while_break___0;
      }
      {
      {
#line 1840
      debug("subsystem: exec() %s", cmd);
      }
#line 1841
      s->is_subsystem = 1;
      {
#line 1842
      do_exec(s, (char const   *)cmd);
      }
#line 1843
      success = 1;
      }
#line 1844
      goto while_break___0;
    }
#line 1832
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1848
  if (! success) {
    {
    {
#line 1849
    logit("subsystem request for %.100s failed, subsystem not found", subsys);
    }
    }
  }
  {
  {
#line 1852
  xfree((void *)subsys);
  }
  }
#line 1853
  return (success);
}
}
#line 1856 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_x11_req(Session *s ) 
{ 
  int success ;
  u_int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int _len ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1861
  if ((unsigned long )s->auth_proto != (unsigned long )((void *)0)) {
    {
    {
#line 1862
    error("session_x11_req: session %d: x11 forwarding already active", s->self);
    }
    }
#line 1864
    return (0);
  } else
#line 1861
  if ((unsigned long )s->auth_data != (unsigned long )((void *)0)) {
    {
    {
#line 1862
    error("session_x11_req: session %d: x11 forwarding already active", s->self);
    }
    }
#line 1864
    return (0);
  }
  {
  {
#line 1866
  tmp = packet_get_char();
  }
#line 1866
  s->single_connection = (int )tmp;
  {
#line 1867
  tmp___0 = packet_get_string((u_int *)((void *)0));
  }
#line 1867
  s->auth_proto = (char *)tmp___0;
  {
#line 1868
  tmp___1 = packet_get_string((u_int *)((void *)0));
  }
#line 1868
  s->auth_data = (char *)tmp___1;
  {
#line 1869
  s->screen = packet_get_int();
  }
  }
  {
  {
#line 1870
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1870
    tmp___2 = packet_remaining();
    }
#line 1870
    _len = tmp___2;
    }
#line 1870
    if (_len > 0) {
      {
      {
#line 1870
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1870);
      }
      {
#line 1870
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1870
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1872
  success = session_setup_x11fwd(s);
  }
  }
#line 1873
  if (! success) {
    {
    {
#line 1874
    xfree((void *)s->auth_proto);
    }
    {
#line 1875
    xfree((void *)s->auth_data);
    }
#line 1876
    s->auth_proto = (char *)((void *)0);
#line 1877
    s->auth_data = (char *)((void *)0);
    }
  }
#line 1879
  return (success);
}
}
#line 1882 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_shell_req(Session *s ) 
{ 
  int _len ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1885
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1885
    tmp = packet_remaining();
    }
#line 1885
    _len = tmp;
    }
#line 1885
    if (_len > 0) {
      {
      {
#line 1885
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1885);
      }
      {
#line 1885
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1885
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1886
  do_exec(s, (char const   *)((void *)0));
  }
  }
#line 1887
  return (1);
}
}
#line 1890 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_exec_req(Session *s ) 
{ 
  u_int len ;
  char *command ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1894
  tmp = packet_get_string(& len);
  }
#line 1894
  command = (char *)tmp;
  }
  {
  {
#line 1895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1895
    tmp___0 = packet_remaining();
    }
#line 1895
    _len = tmp___0;
    }
#line 1895
    if (_len > 0) {
      {
      {
#line 1895
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1895);
      }
      {
#line 1895
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1895
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1896
  do_exec(s, (char const   *)command);
  }
  {
#line 1897
  xfree((void *)command);
  }
  }
#line 1898
  return (1);
}
}
#line 1901 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_break_req(Session *s ) 
{ 
  int _len ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 1905
  packet_get_int();
  }
  }
  {
  {
#line 1906
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1906
    tmp = packet_remaining();
    }
#line 1906
    _len = tmp;
    }
#line 1906
    if (_len > 0) {
      {
      {
#line 1906
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1906);
      }
      {
#line 1906
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1906
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1908
  if (s->ttyfd == -1) {
#line 1910
    return (0);
  } else {
    {
    {
#line 1908
    tmp___0 = tcsendbreak(s->ttyfd, 0);
    }
    }
#line 1908
    if (tmp___0 < 0) {
#line 1910
      return (0);
    }
  }
#line 1911
  return (1);
}
}
#line 1914 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_env_req(Session *s ) 
{ 
  char *name ;
  char *val ;
  u_int name_len ;
  u_int val_len ;
  u_int i ;
  void *tmp ;
  void *tmp___0 ;
  int _len ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 1920
  tmp = packet_get_string(& name_len);
  }
#line 1920
  name = (char *)tmp;
  {
#line 1921
  tmp___0 = packet_get_string(& val_len);
  }
#line 1921
  val = (char *)tmp___0;
  }
  {
  {
#line 1922
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1922
    tmp___1 = packet_remaining();
    }
#line 1922
    _len = tmp___1;
    }
#line 1922
    if (_len > 0) {
      {
      {
#line 1922
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1922);
      }
      {
#line 1922
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1922
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1925
  if (s->num_env > 128U) {
    {
    {
#line 1926
    debug2("Ignoring env request %s: too many env vars", name);
    }
    }
#line 1927
    goto fail;
  }
#line 1930
  i = (u_int )0;
  {
  {
#line 1930
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1930
    if (! (i < options.num_accept_env)) {
#line 1930
      goto while_break___0;
    }
    {
    {
#line 1931
    tmp___3 = match_pattern((char const   *)name, (char const   *)options.accept_env[i]);
    }
    }
#line 1931
    if (tmp___3) {
      {
      {
#line 1932
      debug2("Setting env %d: %s=%s", s->num_env, name, val);
      }
      {
#line 1933
      tmp___2 = xrealloc((void *)s->env, (size_t )(sizeof(*(s->env)) * (unsigned long )(s->num_env + 1U)));
      }
#line 1933
      s->env = (struct __anonstruct_env_79 *)tmp___2;
#line 1935
      (s->env + s->num_env)->name = name;
#line 1936
      (s->env + s->num_env)->val = val;
#line 1937
      (s->num_env) ++;
      }
#line 1938
      return (1);
    }
#line 1930
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1941
  debug2("Ignoring env request %s: disallowed name", name);
  }
  }
  fail: 
  {
  {
#line 1944
  xfree((void *)name);
  }
  {
#line 1945
  xfree((void *)val);
  }
  }
#line 1946
  return (0);
}
}
#line 1952
static int session_auth_agent_req(Session *s ) ;
#line 1952 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int called  =    0;
#line 1949 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int session_auth_agent_req(Session *s ) 
{ 
  int _len ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 1953
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1953
    tmp = packet_remaining();
    }
#line 1953
    _len = tmp;
    }
#line 1953
    if (_len > 0) {
      {
      {
#line 1953
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/session.c",
            1953);
      }
      {
#line 1953
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1953
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1954
  if (no_agent_forwarding_flag) {
    {
    {
#line 1955
    debug("session_auth_agent_req: no_agent_forwarding_flag");
    }
    }
#line 1956
    return (0);
  }
#line 1958
  if (called) {
#line 1959
    return (0);
  } else {
    {
#line 1961
    called = 1;
    {
#line 1962
    tmp___0 = auth_input_request_forwarding(s->pw);
    }
    }
#line 1962
    return (tmp___0);
  }
}
}
#line 1966 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
int session_input_channel_req(Channel *c , char const   *rtype ) 
{ 
  int success ;
  Session *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 1969
  success = 0;
  {
#line 1972
  s = session_by_channel(c->self);
  }
  }
#line 1972
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 1973
    logit("session_input_channel_req: no session %d req %.100s", c->self, rtype);
    }
    }
#line 1975
    return (0);
  }
  {
  {
#line 1977
  debug("session_input_channel_req: session %d req %s", s->self, rtype);
  }
  }
#line 1983
  if (c->type == 10) {
    {
    {
#line 1984
    tmp___5 = strcmp(rtype, "shell");
    }
    }
#line 1984
    if (tmp___5 == 0) {
      {
      {
#line 1985
      success = session_shell_req(s);
      }
      }
    } else {
      {
      {
#line 1986
      tmp___4 = strcmp(rtype, "exec");
      }
      }
#line 1986
      if (tmp___4 == 0) {
        {
        {
#line 1987
        success = session_exec_req(s);
        }
        }
      } else {
        {
        {
#line 1988
        tmp___3 = strcmp(rtype, "pty-req");
        }
        }
#line 1988
        if (tmp___3 == 0) {
          {
          {
#line 1989
          success = session_pty_req(s);
          }
          }
        } else {
          {
          {
#line 1990
          tmp___2 = strcmp(rtype, "x11-req");
          }
          }
#line 1990
          if (tmp___2 == 0) {
            {
            {
#line 1991
            success = session_x11_req(s);
            }
            }
          } else {
            {
            {
#line 1992
            tmp___1 = strcmp(rtype, "auth-agent-req@openssh.com");
            }
            }
#line 1992
            if (tmp___1 == 0) {
              {
              {
#line 1993
              success = session_auth_agent_req(s);
              }
              }
            } else {
              {
              {
#line 1994
              tmp___0 = strcmp(rtype, "subsystem");
              }
              }
#line 1994
              if (tmp___0 == 0) {
                {
                {
#line 1995
                success = session_subsystem_req(s);
                }
                }
              } else {
                {
                {
#line 1996
                tmp = strcmp(rtype, "env");
                }
                }
#line 1996
                if (tmp == 0) {
                  {
                  {
#line 1997
                  success = session_env_req(s);
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
  {
#line 2000
  tmp___7 = strcmp(rtype, "window-change");
  }
  }
#line 2000
  if (tmp___7 == 0) {
    {
    {
#line 2001
    success = session_window_change_req(s);
    }
    }
  } else {
    {
    {
#line 2002
    tmp___6 = strcmp(rtype, "break");
    }
    }
#line 2002
    if (tmp___6 == 0) {
      {
      {
#line 2003
      success = session_break_req(s);
      }
      }
    }
  }
#line 2006
  return (success);
}
}
#line 2009 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_set_fds(Session *s , int fdin___0 , int fdout___0 , int fderr___0 ) 
{ 
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 2012
  if (! compat20) {
    {
    {
#line 2013
    fatal("session_set_fds: called for proto != 2.0");
    }
    }
  }
#line 2018
  if (s->chanid == -1) {
    {
    {
#line 2019
    fatal("no channel for session %d", s->self);
    }
    }
  }
#line 2020
  if (fderr___0 == -1) {
#line 2020
    tmp = 0;
  } else {
#line 2020
    tmp = 1;
  }
  {
  {
#line 2020
  channel_set_fds(s->chanid, fdout___0, fdin___0, fderr___0, tmp, 1, (u_int )131072);
  }
  }
#line 2025
  return;
}
}
#line 2031 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_pty_cleanup2(Session *s ) 
{ 
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2034
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 2035
    error("session_pty_cleanup: no session");
    }
    }
#line 2036
    return;
  }
#line 2038
  if (s->ttyfd == -1) {
#line 2039
    return;
  }
  {
  {
#line 2041
  debug("session_pty_cleanup: session %d release %s", s->self, s->tty);
  }
  }
#line 2044
  if (s->pid != 0) {
    {
    {
#line 2045
    record_logout(s->pid, (char const   *)(s->tty), (char const   *)(s->pw)->pw_name);
    }
    }
  }
  {
  {
#line 2048
  tmp = getuid();
  }
  }
#line 2048
  if (tmp == 0U) {
    {
    {
#line 2049
    pty_release((char const   *)(s->tty));
    }
    }
  }
  {
  {
#line 2056
  tmp___2 = close(s->ptymaster);
  }
  }
#line 2056
  if (tmp___2 < 0) {
    {
    {
#line 2057
    tmp___0 = __errno_location();
    }
    {
#line 2057
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 2057
    error("close(s->ptymaster/%d): %s", s->ptymaster, tmp___1);
    }
    }
  }
#line 2060
  s->ttyfd = -1;
#line 2061
  return;
}
}
#line 2063 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_pty_cleanup(Session *s ) 
{ 


  {
#line 2066
  if (use_privsep) {
    {
    {
#line 2066
    mm_session_pty_cleanup2(s);
    }
    }
  } else {
    {
    {
#line 2066
    session_pty_cleanup2(s);
    }
    }
  }
#line 2067
  return;
}
}
#line 2069 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static char *sig2name(int sig ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2073
  if (sig == 6) {
#line 2073
    return ((char *)"ABRT");
  }
#line 2074
  if (sig == 14) {
#line 2074
    return ((char *)"ALRM");
  }
#line 2075
  if (sig == 8) {
#line 2075
    return ((char *)"FPE");
  }
#line 2076
  if (sig == 1) {
#line 2076
    return ((char *)"HUP");
  }
#line 2077
  if (sig == 4) {
#line 2077
    return ((char *)"ILL");
  }
#line 2078
  if (sig == 2) {
#line 2078
    return ((char *)"INT");
  }
#line 2079
  if (sig == 9) {
#line 2079
    return ((char *)"KILL");
  }
#line 2080
  if (sig == 13) {
#line 2080
    return ((char *)"PIPE");
  }
#line 2081
  if (sig == 3) {
#line 2081
    return ((char *)"QUIT");
  }
#line 2082
  if (sig == 11) {
#line 2082
    return ((char *)"SEGV");
  }
#line 2083
  if (sig == 15) {
#line 2083
    return ((char *)"TERM");
  }
#line 2084
  if (sig == 10) {
#line 2084
    return ((char *)"USR1");
  }
#line 2085
  if (sig == 12) {
#line 2085
    return ((char *)"USR2");
  }
#line 2087
  return ((char *)"SIG@openssh.com");
}
}
#line 2090 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void session_close_x11(int id ) 
{ 
  Channel *c ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 2095
  c = channel_by_id(id);
  }
  }
#line 2095
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
    {
#line 2096
    debug("session_close_x11: x11 channel %d missing", id);
    }
    }
  } else {
    {
    {
#line 2099
    debug("session_close_x11: detach x11 channel %d", id);
    }
    {
#line 2100
    channel_cancel_cleanup(id);
    }
    }
#line 2101
    if (c->ostate != 3U) {
      {
      {
#line 2102
      chan_mark_dead(c);
      }
      }
    }
  }
#line 2104
  return;
}
}
#line 2106 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void session_close_single_x11(int id , void *arg ) 
{ 
  Session *s ;
  u_int i ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 2112
  debug3("session_close_single_x11: channel %d", id);
  }
  {
#line 2113
  channel_cancel_cleanup(id);
  }
  {
#line 2114
  s = session_by_x11_channel(id);
  }
  }
#line 2114
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 2115
    fatal("session_close_single_x11: no x11 channel %d", id);
    }
    }
  }
#line 2116
  i = (u_int )0;
  {
  {
#line 2116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2116
    if (! (*(s->x11_chanids + i) != -1)) {
#line 2116
      goto while_break;
    }
    {
    {
#line 2117
    debug("session_close_single_x11: session %d: closing channel %d", s->self, *(s->x11_chanids + i));
    }
    }
#line 2123
    if (*(s->x11_chanids + i) != id) {
      {
      {
#line 2124
      session_close_x11(*(s->x11_chanids + i));
      }
      }
    }
#line 2116
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2126
  xfree((void *)s->x11_chanids);
  }
#line 2127
  s->x11_chanids = (int *)((void *)0);
  }
#line 2128
  if (s->display) {
    {
    {
#line 2129
    xfree((void *)s->display);
    }
#line 2130
    s->display = (char *)((void *)0);
    }
  }
#line 2132
  if (s->auth_proto) {
    {
    {
#line 2133
    xfree((void *)s->auth_proto);
    }
#line 2134
    s->auth_proto = (char *)((void *)0);
    }
  }
#line 2136
  if (s->auth_data) {
    {
    {
#line 2137
    xfree((void *)s->auth_data);
    }
#line 2138
    s->auth_data = (char *)((void *)0);
    }
  }
#line 2140
  if (s->auth_display) {
    {
    {
#line 2141
    xfree((void *)s->auth_display);
    }
#line 2142
    s->auth_display = (char *)((void *)0);
    }
  }
#line 2144
  return;
}
}
#line 2146 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void session_exit_message(Session *s , int status ) 
{ 
  Channel *c ;
  union __anonunion___u_80 __u ;
  union __anonunion___u_81 __u___0 ;
  char *tmp ;
  union __anonunion___u_82___0 __u___1 ;
  union __anonunion___u_83___0 __u___2 ;
  union __anonunion___u_84___0 __u___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 2151
  c = channel_lookup(s->chanid);
  }
  }
#line 2151
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
    {
#line 2152
    fatal("session_exit_message: session %d: no channel %d", s->self, s->chanid);
    }
    }
  }
  {
  {
#line 2154
  debug("session_exit_message: session %d channel %d pid %ld", s->self, s->chanid,
        (long )s->pid);
  }
#line 2157
  __u___3.__in = status;
  }
#line 2157
  if ((__u___3.__i & 127) == 0) {
    {
    {
#line 2158
    channel_request_start(s->chanid, (char *)"exit-status", 0);
    }
#line 2159
    __u.__in = status;
    {
#line 2159
    packet_put_int((u_int )((__u.__i & 65280) >> 8));
    }
    {
#line 2160
    packet_send();
    }
    }
  } else {
#line 2161
    __u___2.__in = status;
#line 2161
    if ((int )((signed char )((__u___2.__i & 127) + 1)) >> 1 > 0) {
      {
      {
#line 2162
      channel_request_start(s->chanid, (char *)"exit-signal", 0);
      }
#line 2163
      __u___0.__in = status;
      {
#line 2163
      tmp = sig2name(__u___0.__i & 127);
      }
      {
#line 2163
      packet_put_cstring((char const   *)tmp);
      }
#line 2165
      __u___1.__in = status;
      {
#line 2165
      packet_put_char(__u___1.__i & 128);
      }
      {
#line 2169
      packet_put_cstring("");
      }
      {
#line 2170
      packet_put_cstring("");
      }
      {
#line 2171
      packet_send();
      }
      }
    } else {
      {
      {
#line 2174
      packet_disconnect("wait returned status %04x.", status);
      }
      }
    }
  }
  {
  {
#line 2178
  debug("session_exit_message: release channel %d", s->chanid);
  }
  {
#line 2185
  channel_register_cleanup(c->self, & session_close_by_channel, 1);
  }
  }
#line 2193
  if (c->ostate != 3U) {
    {
    {
#line 2194
    chan_write_failed(c);
    }
    }
  }
#line 2195
  return;
}
}
#line 2197 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_close(Session *s ) 
{ 
  u_int i ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 2202
  debug("session_close: session %d pid %ld", s->self, (long )s->pid);
  }
  }
#line 2203
  if (s->ttyfd != -1) {
    {
    {
#line 2204
    session_pty_cleanup(s);
    }
    }
  }
#line 2205
  if (s->term) {
    {
    {
#line 2206
    xfree((void *)s->term);
    }
    }
  }
#line 2207
  if (s->display) {
    {
    {
#line 2208
    xfree((void *)s->display);
    }
    }
  }
#line 2209
  if (s->x11_chanids) {
    {
    {
#line 2210
    xfree((void *)s->x11_chanids);
    }
    }
  }
#line 2211
  if (s->auth_display) {
    {
    {
#line 2212
    xfree((void *)s->auth_display);
    }
    }
  }
#line 2213
  if (s->auth_data) {
    {
    {
#line 2214
    xfree((void *)s->auth_data);
    }
    }
  }
#line 2215
  if (s->auth_proto) {
    {
    {
#line 2216
    xfree((void *)s->auth_proto);
    }
    }
  }
#line 2217
  s->used = 0;
#line 2218
  i = (u_int )0;
  {
  {
#line 2218
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2218
    if (! (i < s->num_env)) {
#line 2218
      goto while_break;
    }
    {
    {
#line 2219
    xfree((void *)(s->env + i)->name);
    }
    {
#line 2220
    xfree((void *)(s->env + i)->val);
    }
#line 2218
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2222
  if ((unsigned long )s->env != (unsigned long )((void *)0)) {
    {
    {
#line 2223
    xfree((void *)s->env);
    }
    }
  }
  {
  {
#line 2224
  session_proctitle(s);
  }
  }
#line 2225
  return;
}
}
#line 2227 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_close_by_pid(pid_t pid , int status ) 
{ 
  Session *s ;
  Session *tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 2230
  tmp = session_by_pid(pid);
  }
#line 2230
  s = tmp;
  }
#line 2231
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 2232
    debug("session_close_by_pid: no session for pid %ld", (long )pid);
    }
    }
#line 2234
    return;
  }
#line 2236
  if (s->chanid != -1) {
    {
    {
#line 2237
    session_exit_message(s, status);
    }
    }
  }
#line 2238
  if (s->ttyfd != -1) {
    {
    {
#line 2239
    session_pty_cleanup(s);
    }
    }
  }
#line 2240
  s->pid = 0;
#line 2241
  return;
}
}
#line 2247 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_close_by_channel(int id , void *arg ) 
{ 
  Session *s ;
  Session *tmp ;
  u_int i ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 2250
  tmp = session_by_channel(id);
  }
#line 2250
  s = tmp;
  }
#line 2253
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
    {
#line 2254
    debug("session_close_by_channel: no session for id %d", id);
    }
    }
#line 2255
    return;
  }
  {
  {
#line 2257
  debug("session_close_by_channel: channel %d child %ld", id, (long )s->pid);
  }
  }
#line 2259
  if (s->pid != 0) {
    {
    {
#line 2260
    debug("session_close_by_channel: channel %d: has child", id);
    }
    }
#line 2265
    if (s->ttyfd != -1) {
      {
      {
#line 2266
      session_pty_cleanup(s);
      }
      }
    }
#line 2267
    return;
  }
  {
  {
#line 2270
  channel_cancel_cleanup(s->chanid);
  }
  }
#line 2273
  if ((unsigned long )s->x11_chanids != (unsigned long )((void *)0)) {
#line 2274
    i = (u_int )0;
    {
    {
#line 2274
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2274
      if (! (*(s->x11_chanids + i) != -1)) {
#line 2274
        goto while_break;
      }
      {
      {
#line 2275
      session_close_x11(*(s->x11_chanids + i));
      }
#line 2276
      *(s->x11_chanids + i) = -1;
#line 2274
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2280
  s->chanid = -1;
  {
#line 2281
  session_close(s);
  }
  }
#line 2282
  return;
}
}
#line 2284 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_destroy_all(void (*closefunc)(Session * ) ) 
{ 
  int i ;
  Session *s ;

  {
#line 2288
  i = 0;
  {
  {
#line 2288
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2288
    if (! (i < 10)) {
#line 2288
      goto while_break;
    }
#line 2289
    s = & sessions[i];
#line 2290
    if (s->used) {
#line 2291
      if ((unsigned long )closefunc != (unsigned long )((void *)0)) {
        {
        {
#line 2292
        (*closefunc)(s);
        }
        }
      } else {
        {
        {
#line 2294
        session_close(s);
        }
        }
      }
    }
#line 2288
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2297
  return;
}
}
#line 2302 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static char buf[1024]  ;
#line 2299 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static char *session_tty_list(void) 
{ 
  int i ;
  char *cp ;
  Session *s ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 2306
  buf[0] = (char )'\000';
#line 2307
  i = 0;
  {
  {
#line 2307
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2307
    if (! (i < 10)) {
#line 2307
      goto while_break;
    }
#line 2308
    s = & sessions[i];
#line 2309
    if (s->used) {
#line 2309
      if (s->ttyfd != -1) {
        {
        {
#line 2311
        tmp = strncmp((char const   *)(s->tty), "/dev/", (size_t )5);
        }
        }
#line 2311
        if (tmp != 0) {
          {
          {
#line 2312
          cp = strrchr((char const   *)(s->tty), '/');
          }
          }
#line 2313
          if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 2313
            cp = s->tty;
          } else {
#line 2313
            cp ++;
          }
        } else {
#line 2315
          cp = s->tty + 5;
        }
#line 2317
        if ((int )buf[0] != 0) {
          {
          {
#line 2318
          strlcat(buf, ",", (size_t )sizeof(buf));
          }
          }
        }
        {
        {
#line 2319
        strlcat(buf, (char const   *)cp, (size_t )sizeof(buf));
        }
        }
      }
    }
#line 2307
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2322
  if ((int )buf[0] == 0) {
    {
    {
#line 2323
    strlcpy(buf, "notty", (size_t )sizeof(buf));
    }
    }
  }
#line 2324
  return (buf);
}
}
#line 2327 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void session_proctitle(Session *s ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2330
  if ((unsigned long )s->pw == (unsigned long )((void *)0)) {
    {
    {
#line 2331
    error("no user for session %d", s->self);
    }
    }
  } else {
    {
    {
#line 2333
    tmp = session_tty_list();
    }
    {
#line 2333
    setproctitle("%s@%s", (s->pw)->pw_name, tmp);
    }
    }
  }
#line 2334
  return;
}
}
#line 2336 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
int session_setup_x11fwd(Session *s ) 
{ 
  struct stat st ;
  char display[512] ;
  char auth_display[512] ;
  char hostname[64] ;
  u_int i ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 2344
  if (no_x11_forwarding_flag) {
    {
    {
#line 2345
    packet_send_debug("X11 forwarding disabled in user configuration file.");
    }
    }
#line 2346
    return (0);
  }
#line 2348
  if (! options.x11_forwarding) {
    {
    {
#line 2349
    debug("X11 forwarding disabled in server configuration file.");
    }
    }
#line 2350
    return (0);
  }
#line 2352
  if (! options.xauth_location) {
    {
    {
#line 2354
    packet_send_debug("No xauth program; cannot forward with spoofing.");
    }
    }
#line 2355
    return (0);
  } else {
    {
    {
#line 2352
    tmp = stat((char const   */* __restrict  */)options.xauth_location, (struct stat */* __restrict  */)(& st));
    }
    }
#line 2352
    if (tmp == -1) {
      {
      {
#line 2354
      packet_send_debug("No xauth program; cannot forward with spoofing.");
      }
      }
#line 2355
      return (0);
    }
  }
#line 2357
  if (options.use_login) {
    {
    {
#line 2358
    packet_send_debug("X11 forwarding disabled; not compatible with UseLogin=yes.");
    }
    }
#line 2360
    return (0);
  }
#line 2362
  if ((unsigned long )s->display != (unsigned long )((void *)0)) {
    {
    {
#line 2363
    debug("X11 display already set.");
    }
    }
#line 2364
    return (0);
  }
  {
  {
#line 2366
  tmp___0 = x11_create_display_inet(options.x11_display_offset, options.x11_use_localhost,
                                    s->single_connection, & s->display_number, & s->x11_chanids);
  }
  }
#line 2366
  if (tmp___0 == -1) {
    {
    {
#line 2369
    debug("x11_create_display_inet failed.");
    }
    }
#line 2370
    return (0);
  }
#line 2372
  i = (u_int )0;
  {
  {
#line 2372
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2372
    if (! (*(s->x11_chanids + i) != -1)) {
#line 2372
      goto while_break;
    }
    {
    {
#line 2373
    channel_register_cleanup(*(s->x11_chanids + i), & session_close_single_x11, 0);
    }
#line 2372
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2378
  tmp___3 = gethostname(hostname, (size_t )sizeof(hostname));
  }
  }
#line 2378
  if (tmp___3 < 0) {
    {
    {
#line 2379
    tmp___1 = __errno_location();
    }
    {
#line 2379
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 2379
    fatal("gethostname: %.100s", tmp___2);
    }
    }
  }
#line 2385
  if (options.x11_use_localhost) {
    {
    {
#line 2386
    snprintf((char */* __restrict  */)(display), (size_t )sizeof(display), (char const   */* __restrict  */)"localhost:%u.%u",
             s->display_number, s->screen);
    }
    {
#line 2388
    snprintf((char */* __restrict  */)(auth_display), (size_t )sizeof(auth_display),
             (char const   */* __restrict  */)"unix:%u.%u", s->display_number, s->screen);
    }
    {
#line 2390
    s->display = xstrdup((char const   *)(display));
    }
    {
#line 2391
    s->auth_display = xstrdup((char const   *)(auth_display));
    }
    }
  } else {
    {
    {
#line 2407
    snprintf((char */* __restrict  */)(display), (size_t )sizeof(display), (char const   */* __restrict  */)"%.400s:%u.%u",
             hostname, s->display_number, s->screen);
    }
    {
#line 2410
    s->display = xstrdup((char const   *)(display));
    }
    {
#line 2411
    s->auth_display = xstrdup((char const   *)(display));
    }
    }
  }
#line 2414
  return (1);
}
}
#line 2417 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static void do_authenticated2(Authctxt *authctxt___0 ) 
{ 


  {
  {
  {
#line 2420
  server_loop2(authctxt___0);
  }
  }
#line 2421
  return;
}
}
#line 2426 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
static int called___0  =    0;
#line 2423 "/home/pronto/abs/test-suite/openssh-4.3p2/session.c"
void do_cleanup(Authctxt *authctxt___0 ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 2428
  debug("do_cleanup");
  }
  }
#line 2431
  if (is_child) {
#line 2432
    return;
  }
#line 2435
  if (called___0) {
#line 2436
    return;
  }
#line 2437
  called___0 = 1;
#line 2439
  if ((unsigned long )authctxt___0 == (unsigned long )((void *)0)) {
#line 2440
    return;
  }
  {
  {
#line 2460
  auth_sock_cleanup_proc(authctxt___0->pw);
  }
  }
#line 2466
  if (! use_privsep) {
    {
    {
#line 2467
    session_destroy_all(& session_pty_cleanup2);
    }
    }
  } else {
    {
    {
#line 2466
    tmp = mm_is_monitor();
    }
    }
#line 2466
    if (tmp) {
      {
      {
#line 2467
      session_destroy_all(& session_pty_cleanup2);
      }
      }
    }
  }
#line 2468
  return;
}
}
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 209 "./channels.h"
extern void channel_add_permitted_opens(char * , int  ) ;
#line 210
extern void channel_clear_permitted_opens(void) ;
#line 20 "/home/pronto/abs/test-suite/openssh-4.3p2/match.h"
extern int match_host_and_ip(char const   * , char const   * , char const   * ) ;
#line 31 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.h"
int forced_tun_device ;
#line 22 "/home/pronto/abs/test-suite/openssh-4.3p2/misc.h"
extern int a2port(char const   * ) ;
#line 23
extern int a2tun(char const   * , int * ) ;
#line 24
extern char *hpdelim(char ** ) ;
#line 25
extern char *cleanhostname(char * ) ;
#line 183 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) ;
#line 184
void auth_debug_send(void) ;
#line 185
void auth_debug_reset(void) ;
#line 27 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
int no_port_forwarding_flag  =    0;
#line 28 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
int no_agent_forwarding_flag  =    0;
#line 29 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
int no_x11_forwarding_flag  =    0;
#line 30 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
int no_pty_flag  =    0;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
char *forced_command  =    (char *)((void *)0);
#line 36 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
struct envstring *custom_environment  =    (struct envstring *)((void *)0);
#line 39 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
int forced_tun_device  =    -1;
#line 43 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
void auth_clear_options(void) 
{ 
  struct envstring *ce ;

  {
#line 46
  no_agent_forwarding_flag = 0;
#line 47
  no_port_forwarding_flag = 0;
#line 48
  no_pty_flag = 0;
#line 49
  no_x11_forwarding_flag = 0;
  {
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 50
    if (! custom_environment) {
#line 50
      goto while_break;
    }
    {
#line 51
    ce = custom_environment;
#line 52
    custom_environment = ce->next;
    {
#line 53
    xfree((void *)ce->s);
    }
    {
#line 54
    xfree((void *)ce);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (forced_command) {
    {
    {
#line 57
    xfree((void *)forced_command);
    }
#line 58
    forced_command = (char *)((void *)0);
    }
  }
  {
#line 60
  forced_tun_device = -1;
  {
#line 61
  channel_clear_permitted_opens();
  }
  {
#line 62
  auth_debug_reset();
  }
  }
#line 63
  return;
}
}
#line 69 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-options.c"
int auth_parse_options(struct passwd *pw , char *opts , char *file , u_long linenum ) 
{ 
  char const   *cp ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char *s ;
  struct envstring *new_envstring ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  char const   *remote_ip ;
  char const   *tmp___28 ;
  char const   *remote_host ;
  char const   *tmp___29 ;
  char *patterns ;
  size_t tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char *host ;
  char *p ;
  u_short port ;
  char *patterns___0 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  size_t tmp___45 ;
  char const   *tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  char *tun ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  void *tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  size_t tmp___55 ;
  int tmp___56 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;

  {
  {
  {
#line 76
  auth_clear_options();
  }
  }
#line 78
  if (! opts) {
#line 79
    return (1);
  }
  {
  {
#line 81
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (*opts) {
#line 81
      if ((int )*opts != 32) {
#line 81
        if (! ((int )*opts != 9)) {
#line 81
          goto while_break;
        }
      } else {
#line 81
        goto while_break;
      }
    } else {
#line 81
      goto while_break;
    }
    {
#line 82
    cp = "no-port-forwarding";
    {
#line 83
    tmp___0 = strlen(cp);
    }
    {
#line 83
    tmp___1 = strncasecmp((char const   *)opts, cp, tmp___0);
    }
    }
#line 83
    if (tmp___1 == 0) {
      {
      {
#line 84
      auth_debug_add("Port forwarding disabled.");
      }
#line 85
      no_port_forwarding_flag = 1;
      {
#line 86
      tmp = strlen(cp);
      }
#line 86
      opts += tmp;
      }
#line 87
      goto next_option;
    }
    {
#line 89
    cp = "no-agent-forwarding";
    {
#line 90
    tmp___3 = strlen(cp);
    }
    {
#line 90
    tmp___4 = strncasecmp((char const   *)opts, cp, tmp___3);
    }
    }
#line 90
    if (tmp___4 == 0) {
      {
      {
#line 91
      auth_debug_add("Agent forwarding disabled.");
      }
#line 92
      no_agent_forwarding_flag = 1;
      {
#line 93
      tmp___2 = strlen(cp);
      }
#line 93
      opts += tmp___2;
      }
#line 94
      goto next_option;
    }
    {
#line 96
    cp = "no-X11-forwarding";
    {
#line 97
    tmp___6 = strlen(cp);
    }
    {
#line 97
    tmp___7 = strncasecmp((char const   *)opts, cp, tmp___6);
    }
    }
#line 97
    if (tmp___7 == 0) {
      {
      {
#line 98
      auth_debug_add("X11 forwarding disabled.");
      }
#line 99
      no_x11_forwarding_flag = 1;
      {
#line 100
      tmp___5 = strlen(cp);
      }
#line 100
      opts += tmp___5;
      }
#line 101
      goto next_option;
    }
    {
#line 103
    cp = "no-pty";
    {
#line 104
    tmp___9 = strlen(cp);
    }
    {
#line 104
    tmp___10 = strncasecmp((char const   *)opts, cp, tmp___9);
    }
    }
#line 104
    if (tmp___10 == 0) {
      {
      {
#line 105
      auth_debug_add("Pty allocation disabled.");
      }
#line 106
      no_pty_flag = 1;
      {
#line 107
      tmp___8 = strlen(cp);
      }
#line 107
      opts += tmp___8;
      }
#line 108
      goto next_option;
    }
    {
#line 110
    cp = "command=\"";
    {
#line 111
    tmp___17 = strlen(cp);
    }
    {
#line 111
    tmp___18 = strncasecmp((char const   *)opts, cp, tmp___17);
    }
    }
#line 111
    if (tmp___18 == 0) {
      {
      {
#line 112
      tmp___11 = strlen(cp);
      }
#line 112
      opts += tmp___11;
      {
#line 113
      tmp___12 = strlen((char const   *)opts);
      }
      {
#line 113
      tmp___13 = xmalloc(tmp___12 + 1U);
      }
#line 113
      forced_command = (char *)tmp___13;
#line 114
      i = 0;
      }
      {
      {
#line 115
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 115
        if (! *opts) {
#line 115
          goto while_break___0;
        }
#line 116
        if ((int )*opts == 34) {
#line 117
          goto while_break___0;
        }
#line 118
        if ((int )*opts == 92) {
#line 118
          if ((int )*(opts + 1) == 34) {
#line 119
            opts += 2;
#line 120
            tmp___14 = i;
#line 120
            i ++;
#line 120
            *(forced_command + tmp___14) = (char )'\"';
#line 121
            goto while_continue___0;
          }
        }
#line 123
        tmp___15 = i;
#line 123
        i ++;
#line 123
        tmp___16 = opts;
#line 123
        opts ++;
#line 123
        *(forced_command + tmp___15) = *tmp___16;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 125
      if (! *opts) {
        {
        {
#line 126
        debug("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 128
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 130
        xfree((void *)forced_command);
        }
#line 131
        forced_command = (char *)((void *)0);
        }
#line 132
        goto bad_option;
      }
      {
#line 134
      *(forced_command + i) = (char)0;
      {
#line 135
      auth_debug_add("Forced command: %.900s", forced_command);
      }
#line 136
      opts ++;
      }
#line 137
      goto next_option;
    }
#line 139
    cp = "environment=\"";
#line 140
    if (options.permit_user_env) {
      {
      {
#line 140
      tmp___26 = strlen(cp);
      }
      {
#line 140
      tmp___27 = strncasecmp((char const   *)opts, cp, tmp___26);
      }
      }
#line 140
      if (tmp___27 == 0) {
        {
        {
#line 145
        tmp___19 = strlen(cp);
        }
#line 145
        opts += tmp___19;
        {
#line 146
        tmp___20 = strlen((char const   *)opts);
        }
        {
#line 146
        tmp___21 = xmalloc(tmp___20 + 1U);
        }
#line 146
        s = (char *)tmp___21;
#line 147
        i = 0;
        }
        {
        {
#line 148
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 148
          if (! *opts) {
#line 148
            goto while_break___1;
          }
#line 149
          if ((int )*opts == 34) {
#line 150
            goto while_break___1;
          }
#line 151
          if ((int )*opts == 92) {
#line 151
            if ((int )*(opts + 1) == 34) {
#line 152
              opts += 2;
#line 153
              tmp___22 = i;
#line 153
              i ++;
#line 153
              *(s + tmp___22) = (char )'\"';
#line 154
              goto while_continue___1;
            }
          }
#line 156
          tmp___23 = i;
#line 156
          i ++;
#line 156
          tmp___24 = opts;
#line 156
          opts ++;
#line 156
          *(s + tmp___23) = *tmp___24;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 158
        if (! *opts) {
          {
          {
#line 159
          debug("%.100s, line %lu: missing end quote", file, linenum);
          }
          {
#line 161
          auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
          }
          {
#line 163
          xfree((void *)s);
          }
          }
#line 164
          goto bad_option;
        }
        {
#line 166
        *(s + i) = (char)0;
        {
#line 167
        auth_debug_add("Adding to environment: %.900s", s);
        }
        {
#line 168
        debug("Adding to environment: %.900s", s);
        }
#line 169
        opts ++;
        {
#line 170
        tmp___25 = xmalloc((size_t )sizeof(struct envstring ));
        }
#line 170
        new_envstring = (struct envstring *)tmp___25;
#line 171
        new_envstring->s = s;
#line 172
        new_envstring->next = custom_environment;
#line 173
        custom_environment = new_envstring;
        }
#line 174
        goto next_option;
      }
    }
    {
#line 176
    cp = "from=\"";
    {
#line 177
    tmp___37 = strlen(cp);
    }
    {
#line 177
    tmp___38 = strncasecmp((char const   *)opts, cp, tmp___37);
    }
    }
#line 177
    if (tmp___38 == 0) {
      {
      {
#line 178
      tmp___28 = get_remote_ipaddr();
      }
#line 178
      remote_ip = tmp___28;
      {
#line 179
      tmp___29 = get_canonical_hostname(options.use_dns);
      }
#line 179
      remote_host = tmp___29;
      {
#line 181
      tmp___30 = strlen((char const   *)opts);
      }
      {
#line 181
      tmp___31 = xmalloc(tmp___30 + 1U);
      }
#line 181
      patterns = (char *)tmp___31;
      {
#line 183
      tmp___32 = strlen(cp);
      }
#line 183
      opts += tmp___32;
#line 184
      i = 0;
      }
      {
      {
#line 185
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 185
        if (! *opts) {
#line 185
          goto while_break___2;
        }
#line 186
        if ((int )*opts == 34) {
#line 187
          goto while_break___2;
        }
#line 188
        if ((int )*opts == 92) {
#line 188
          if ((int )*(opts + 1) == 34) {
#line 189
            opts += 2;
#line 190
            tmp___33 = i;
#line 190
            i ++;
#line 190
            *(patterns + tmp___33) = (char )'\"';
#line 191
            goto while_continue___2;
          }
        }
#line 193
        tmp___34 = i;
#line 193
        i ++;
#line 193
        tmp___35 = opts;
#line 193
        opts ++;
#line 193
        *(patterns + tmp___34) = *tmp___35;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 195
      if (! *opts) {
        {
        {
#line 196
        debug("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 198
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 200
        xfree((void *)patterns);
        }
        }
#line 201
        goto bad_option;
      }
      {
#line 203
      *(patterns + i) = (char)0;
#line 204
      opts ++;
      {
#line 205
      tmp___36 = match_host_and_ip(remote_host, remote_ip, (char const   *)patterns);
      }
      }
#line 205
      if (tmp___36 != 1) {
        {
        {
#line 207
        xfree((void *)patterns);
        }
        {
#line 208
        logit("Authentication tried for %.100s with correct key but not from a permitted host (host=%.200s, ip=%.200s).",
              pw->pw_name, remote_host, remote_ip);
        }
        {
#line 212
        auth_debug_add("Your host \'%.200s\' is not permitted to use this key for login.",
                       remote_host);
        }
        }
#line 216
        return (0);
      }
      {
      {
#line 218
      xfree((void *)patterns);
      }
      }
#line 220
      goto next_option;
    }
    {
#line 222
    cp = "permitopen=\"";
    {
#line 223
    tmp___48 = strlen(cp);
    }
    {
#line 223
    tmp___49 = strncasecmp((char const   *)opts, cp, tmp___48);
    }
    }
#line 223
    if (tmp___49 == 0) {
      {
      {
#line 226
      tmp___39 = strlen((char const   *)opts);
      }
      {
#line 226
      tmp___40 = xmalloc(tmp___39 + 1U);
      }
#line 226
      patterns___0 = (char *)tmp___40;
      {
#line 228
      tmp___41 = strlen(cp);
      }
#line 228
      opts += tmp___41;
#line 229
      i = 0;
      }
      {
      {
#line 230
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 230
        if (! *opts) {
#line 230
          goto while_break___3;
        }
#line 231
        if ((int )*opts == 34) {
#line 232
          goto while_break___3;
        }
#line 233
        if ((int )*opts == 92) {
#line 233
          if ((int )*(opts + 1) == 34) {
#line 234
            opts += 2;
#line 235
            tmp___42 = i;
#line 235
            i ++;
#line 235
            *(patterns___0 + tmp___42) = (char )'\"';
#line 236
            goto while_continue___3;
          }
        }
#line 238
        tmp___43 = i;
#line 238
        i ++;
#line 238
        tmp___44 = opts;
#line 238
        opts ++;
#line 238
        *(patterns___0 + tmp___43) = *tmp___44;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 240
      if (! *opts) {
        {
        {
#line 241
        debug("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 243
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 245
        xfree((void *)patterns___0);
        }
        }
#line 246
        goto bad_option;
      }
      {
#line 248
      *(patterns___0 + i) = (char)0;
#line 249
      opts ++;
#line 250
      p = patterns___0;
      {
#line 251
      host = hpdelim(& p);
      }
      }
#line 252
      if ((unsigned long )host == (unsigned long )((void *)0)) {
        {
        {
#line 253
        debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file, linenum,
              patterns___0);
        }
        {
#line 256
        auth_debug_add("%.100s, line %lu: Bad permitopen specification", file, linenum);
        }
        {
#line 259
        xfree((void *)patterns___0);
        }
        }
#line 260
        goto bad_option;
      } else {
        {
        {
#line 252
        tmp___45 = strlen((char const   *)host);
        }
        }
#line 252
        if (tmp___45 >= 1025U) {
          {
          {
#line 253
          debug("%.100s, line %lu: Bad permitopen specification <%.100s>", file, linenum,
                patterns___0);
          }
          {
#line 256
          auth_debug_add("%.100s, line %lu: Bad permitopen specification", file, linenum);
          }
          {
#line 259
          xfree((void *)patterns___0);
          }
          }
#line 260
          goto bad_option;
        }
      }
      {
      {
#line 262
      host = cleanhostname(host);
      }
      }
#line 263
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 263
        goto _L;
      } else {
        {
        {
#line 263
        tmp___47 = a2port((char const   *)p);
        }
#line 263
        port = (u_short )tmp___47;
        }
#line 263
        if ((int )port == 0) {
          _L: /* CIL Label */ 
#line 264
          if (p) {
#line 264
            tmp___46 = (char const   *)p;
          } else {
#line 264
            tmp___46 = "";
          }
          {
          {
#line 264
          debug("%.100s, line %lu: Bad permitopen port <%.100s>", file, linenum, tmp___46);
          }
          {
#line 266
          auth_debug_add("%.100s, line %lu: Bad permitopen port", file, linenum);
          }
          {
#line 268
          xfree((void *)patterns___0);
          }
          }
#line 269
          goto bad_option;
        }
      }
#line 271
      if (options.allow_tcp_forwarding) {
        {
        {
#line 272
        channel_add_permitted_opens(host, (int )port);
        }
        }
      }
      {
      {
#line 273
      xfree((void *)patterns___0);
      }
      }
#line 274
      goto next_option;
    }
    {
#line 276
    cp = "tunnel=\"";
    {
#line 277
    tmp___55 = strlen(cp);
    }
    {
#line 277
    tmp___56 = strncasecmp((char const   *)opts, cp, tmp___55);
    }
    }
#line 277
    if (tmp___56 == 0) {
      {
#line 278
      tun = (char *)((void *)0);
      {
#line 279
      tmp___50 = strlen(cp);
      }
#line 279
      opts += tmp___50;
      {
#line 280
      tmp___51 = strlen((char const   *)opts);
      }
      {
#line 280
      tmp___52 = xmalloc(tmp___51 + 1U);
      }
#line 280
      tun = (char *)tmp___52;
#line 281
      i = 0;
      }
      {
      {
#line 282
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 282
        if (! *opts) {
#line 282
          goto while_break___4;
        }
#line 283
        if ((int )*opts == 34) {
#line 284
          goto while_break___4;
        }
#line 285
        tmp___53 = i;
#line 285
        i ++;
#line 285
        tmp___54 = opts;
#line 285
        opts ++;
#line 285
        *(tun + tmp___53) = *tmp___54;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 287
      if (! *opts) {
        {
        {
#line 288
        debug("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 290
        auth_debug_add("%.100s, line %lu: missing end quote", file, linenum);
        }
        {
#line 292
        xfree((void *)tun);
        }
#line 293
        forced_tun_device = -1;
        }
#line 294
        goto bad_option;
      }
      {
#line 296
      *(tun + i) = (char)0;
      {
#line 297
      forced_tun_device = a2tun((char const   *)tun, (int *)((void *)0));
      }
      {
#line 298
      xfree((void *)tun);
      }
      }
#line 299
      if (forced_tun_device == 2147483646) {
        {
        {
#line 300
        debug("%.100s, line %lu: invalid tun device", file, linenum);
        }
        {
#line 302
        auth_debug_add("%.100s, line %lu: invalid tun device", file, linenum);
        }
#line 304
        forced_tun_device = -1;
        }
#line 305
        goto bad_option;
      }
      {
      {
#line 307
      auth_debug_add("Forced tun device: %d", forced_tun_device);
      }
#line 308
      opts ++;
      }
#line 309
      goto next_option;
    }
    next_option: 
#line 316
    if (! *opts) {
      {
      {
#line 317
      fatal("Bugs in auth-options.c option processing.");
      }
      }
    }
#line 318
    if ((int )*opts == 32) {
#line 319
      goto while_break;
    } else
#line 318
    if ((int )*opts == 9) {
#line 319
      goto while_break;
    }
#line 320
    if ((int )*opts != 44) {
#line 321
      goto bad_option;
    }
#line 322
    opts ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (! use_privsep) {
    {
    {
#line 327
    auth_debug_send();
    }
    }
  }
#line 330
  return (1);
  bad_option: 
  {
  {
#line 333
  logit("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
  }
  {
#line 335
  auth_debug_add("Bad options in %.100s file, line %lu: %.50s", file, linenum, opts);
  }
  }
#line 338
  if (! use_privsep) {
    {
    {
#line 339
    auth_debug_send();
    }
    }
  }
#line 342
  return (0);
}
}
#line 141 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
void do_authentication2(Authctxt *authctxt___0 ) ;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/dispatch.h"
extern void dispatch_init(dispatch_fn * ) ;
#line 36
extern void dispatch_run(int  , int * , void * ) ;
#line 37
extern void dispatch_protocol_error(int  , u_int32_t  , void * ) ;
#line 38
extern void dispatch_protocol_ignore(int  , u_int32_t  , void * ) ;
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
Authmethod *authmethods[6]  = {      & method_none,      & method_pubkey,      & method_passwd,      & method_kbdint, 
        & method_hostbased,      (Authmethod *)((void *)0)};
#line 75
static void input_service_request(int type , u_int32_t seq , void *ctxt ) ;
#line 76
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) ;
#line 79
static Authmethod *authmethod_lookup(char const   *name ) ;
#line 80
static char *authmethods_get(void) ;
#line 87 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
void do_authentication2(Authctxt *authctxt___0 ) 
{ 


  {
#line 91
  if (options.challenge_response_authentication) {
#line 92
    options.kbd_interactive_authentication = 1;
  }
  {
  {
#line 94
  dispatch_init(& dispatch_protocol_error);
  }
  {
#line 95
  dispatch_set(5, & input_service_request);
  }
  {
#line 96
  dispatch_run(0, & authctxt___0->success, (void *)authctxt___0);
  }
  }
#line 97
  return;
}
}
#line 99 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
static void input_service_request(int type , u_int32_t seq , void *ctxt ) 
{ 
  Authctxt *authctxt___0 ;
  u_int len ;
  int acceptit ;
  char *service ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 102
  authctxt___0 = (Authctxt *)ctxt;
#line 104
  acceptit = 0;
  {
#line 105
  tmp = packet_get_string(& len);
  }
#line 105
  service = (char *)tmp;
  }
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 106
    tmp___0 = packet_remaining();
    }
#line 106
    _len = tmp___0;
    }
#line 106
    if (_len > 0) {
      {
      {
#line 106
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c",
            106);
      }
      {
#line 106
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 106
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((unsigned long )authctxt___0 == (unsigned long )((void *)0)) {
    {
    {
#line 109
    fatal("input_service_request: no authctxt");
    }
    }
  }
  {
  {
#line 111
  tmp___1 = strcmp((char const   *)service, "ssh-userauth");
  }
  }
#line 111
  if (tmp___1 == 0) {
#line 112
    if (! authctxt___0->success) {
      {
#line 113
      acceptit = 1;
      {
#line 115
      dispatch_set(50, & input_userauth_request);
      }
      }
    }
  }
#line 120
  if (acceptit) {
    {
    {
#line 121
    packet_start((u_char )6);
    }
    {
#line 122
    packet_put_cstring((char const   *)service);
    }
    {
#line 123
    packet_send();
    }
    {
#line 124
    packet_write_wait();
    }
    }
  } else {
    {
    {
#line 126
    debug("bad service request %s", service);
    }
    {
#line 127
    packet_disconnect("bad service request %s", service);
    }
    }
  }
  {
  {
#line 129
  xfree((void *)service);
  }
  }
#line 130
  return;
}
}
#line 132 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
static void input_userauth_request(int type , u_int32_t seq , void *ctxt ) 
{ 
  Authctxt *authctxt___0 ;
  Authmethod *m ;
  char *user ;
  char *service ;
  char *method ;
  char *style ;
  int authenticated ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  struct passwd *tmp___3 ;
  struct passwd *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 135
  authctxt___0 = (Authctxt *)ctxt;
#line 136
  m = (Authmethod *)((void *)0);
#line 137
  style = (char *)((void *)0);
#line 138
  authenticated = 0;
#line 140
  if ((unsigned long )authctxt___0 == (unsigned long )((void *)0)) {
    {
    {
#line 141
    fatal("input_userauth_request: no authctxt");
    }
    }
  }
  {
  {
#line 143
  tmp = packet_get_string((u_int *)((void *)0));
  }
#line 143
  user = (char *)tmp;
  {
#line 144
  tmp___0 = packet_get_string((u_int *)((void *)0));
  }
#line 144
  service = (char *)tmp___0;
  {
#line 145
  tmp___1 = packet_get_string((u_int *)((void *)0));
  }
#line 145
  method = (char *)tmp___1;
  {
#line 146
  debug("userauth-request for user %s service %s method %s", user, service, method);
  }
  {
#line 147
  debug("attempt %d failures %d", authctxt___0->attempt, authctxt___0->failures);
  }
  {
#line 149
  style = strchr((char const   *)user, ':');
  }
  }
#line 149
  if ((unsigned long )style != (unsigned long )((void *)0)) {
#line 150
    tmp___2 = style;
#line 150
    style ++;
#line 150
    *tmp___2 = (char)0;
  }
#line 152
  tmp___11 = authctxt___0->attempt;
#line 152
  (authctxt___0->attempt) ++;
#line 152
  if (tmp___11 == 0) {
#line 154
    if (use_privsep) {
      {
      {
#line 154
      tmp___3 = mm_getpwnamallow((char const   *)user);
      }
#line 154
      authctxt___0->pw = tmp___3;
      }
    } else {
      {
      {
#line 154
      tmp___4 = getpwnamallow((char const   *)user);
      }
#line 154
      authctxt___0->pw = tmp___4;
      }
    }
    {
    {
#line 155
    authctxt___0->user = xstrdup((char const   *)user);
    }
    }
#line 156
    if (authctxt___0->pw) {
      {
      {
#line 156
      tmp___5 = strcmp((char const   *)service, "ssh-connection");
      }
      }
#line 156
      if (tmp___5 == 0) {
        {
#line 157
        authctxt___0->valid = 1;
        {
#line 158
        debug2("input_userauth_request: setting up authctxt for %s", user);
        }
        }
      } else {
        {
        {
#line 160
        logit("input_userauth_request: invalid user %s", user);
        }
        {
#line 161
        authctxt___0->pw = fakepw();
        }
        }
      }
    } else {
      {
      {
#line 160
      logit("input_userauth_request: invalid user %s", user);
      }
      {
#line 161
      authctxt___0->pw = fakepw();
      }
      }
    }
#line 170
    if (use_privsep) {
#line 170
      tmp___6 = " [net]";
    } else {
#line 170
      tmp___6 = "";
    }
#line 170
    if (authctxt___0->valid) {
#line 170
      tmp___7 = (char const   *)user;
    } else {
#line 170
      tmp___7 = "unknown";
    }
    {
    {
#line 170
    setproctitle("%s%s", tmp___7, tmp___6);
    }
    {
#line 172
    authctxt___0->service = xstrdup((char const   *)service);
    }
    }
#line 173
    if (style) {
      {
      {
#line 173
      tmp___8 = xstrdup((char const   *)style);
      }
#line 173
      authctxt___0->style = tmp___8;
      }
    } else {
#line 173
      authctxt___0->style = (char *)((void *)0);
    }
#line 174
    if (use_privsep) {
      {
      {
#line 175
      mm_inform_authserv(service, style);
      }
      }
    }
  } else {
    {
    {
#line 176
    tmp___9 = strcmp((char const   *)user, (char const   *)authctxt___0->user);
    }
    }
#line 176
    if (tmp___9 != 0) {
      {
      {
#line 178
      packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                        authctxt___0->user, authctxt___0->service, user, service);
      }
      }
    } else {
      {
      {
#line 176
      tmp___10 = strcmp((char const   *)service, (char const   *)authctxt___0->service);
      }
      }
#line 176
      if (tmp___10 != 0) {
        {
        {
#line 178
        packet_disconnect("Change of username or service not allowed: (%s,%s) -> (%s,%s)",
                          authctxt___0->user, authctxt___0->service, user, service);
        }
        }
      }
    }
  }
  {
  {
#line 183
  auth2_challenge_stop(authctxt___0);
  }
#line 190
  authctxt___0->postponed = 0;
  {
#line 193
  m = authmethod_lookup((char const   *)method);
  }
  }
#line 194
  if ((unsigned long )m != (unsigned long )((void *)0)) {
    {
    {
#line 195
    debug2("input_userauth_request: try method %s", method);
    }
    {
#line 196
    authenticated = (*(m->userauth))(authctxt___0);
    }
    }
  }
  {
  {
#line 198
  userauth_finish(authctxt___0, authenticated, method);
  }
  {
#line 200
  xfree((void *)service);
  }
  {
#line 201
  xfree((void *)user);
  }
  {
#line 202
  xfree((void *)method);
  }
  }
#line 203
  return;
}
}
#line 205 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
void userauth_finish(Authctxt *authctxt___0 , int authenticated , char *method ) 
{ 
  char *methods ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 210
  if (! authctxt___0->valid) {
#line 210
    if (authenticated) {
      {
      {
#line 211
      fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
      }
      }
    }
  }
#line 215
  if (authenticated) {
#line 215
    if ((authctxt___0->pw)->pw_uid == 0U) {
      {
      {
#line 215
      tmp = auth_root_allowed(method);
      }
      }
#line 215
      if (! tmp) {
#line 217
        authenticated = 0;
      }
    }
  }
  {
  {
#line 246
  auth_log(authctxt___0, authenticated, method, (char *)" ssh2");
  }
  }
#line 248
  if (authctxt___0->postponed) {
#line 249
    return;
  }
#line 252
  if (authenticated == 1) {
    {
    {
#line 254
    dispatch_set(50, & dispatch_protocol_ignore);
    }
    {
#line 255
    packet_start((u_char )52);
    }
    {
#line 256
    packet_send();
    }
    {
#line 257
    packet_write_wait();
    }
#line 259
    authctxt___0->success = 1;
    }
  } else {
#line 261
    tmp___0 = authctxt___0->failures;
#line 261
    (authctxt___0->failures) ++;
#line 261
    if (tmp___0 > options.max_authtries) {
      {
      {
#line 265
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
      }
      }
    }
    {
    {
#line 267
    methods = authmethods_get();
    }
    {
#line 268
    packet_start((u_char )51);
    }
    {
#line 269
    packet_put_cstring((char const   *)methods);
    }
    {
#line 270
    packet_put_char(0);
    }
    {
#line 271
    packet_send();
    }
    {
#line 272
    packet_write_wait();
    }
    {
#line 273
    xfree((void *)methods);
    }
    }
  }
#line 275
  return;
}
}
#line 279 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
static char *authmethods_get(void) 
{ 
  Buffer b ;
  char *list ;
  int i ;
  int tmp ;
  u_int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 286
  buffer_init(& b);
  }
#line 287
  i = 0;
  }
  {
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 287
    if (! ((unsigned long )authmethods[i] != (unsigned long )((void *)0))) {
#line 287
      goto while_break;
    }
    {
    {
#line 288
    tmp = strcmp((char const   *)(authmethods[i])->name, "none");
    }
    }
#line 288
    if (tmp == 0) {
#line 289
      goto __Cont;
    }
#line 290
    if ((unsigned long )(authmethods[i])->enabled != (unsigned long )((void *)0)) {
#line 290
      if (*((authmethods[i])->enabled) != 0) {
        {
        {
#line 292
        tmp___0 = buffer_len(& b);
        }
        }
#line 292
        if (tmp___0 > 0U) {
          {
          {
#line 293
          buffer_append(& b, (void const   *)",", (u_int )1);
          }
          }
        }
        {
        {
#line 294
        tmp___1 = strlen((char const   *)(authmethods[i])->name);
        }
        {
#line 294
        buffer_append(& b, (void const   *)(authmethods[i])->name, tmp___1);
        }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 287
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 298
  buffer_append(& b, (void const   *)"\000", (u_int )1);
  }
  {
#line 299
  tmp___2 = buffer_ptr(& b);
  }
  {
#line 299
  list = xstrdup((char const   *)tmp___2);
  }
  {
#line 300
  buffer_free(& b);
  }
  }
#line 301
  return (list);
}
}
#line 304 "/home/pronto/abs/test-suite/openssh-4.3p2/auth2.c"
static Authmethod *authmethod_lookup(char const   *name ) 
{ 
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 309
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 310
    i = 0;
    {
    {
#line 310
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 310
      if (! ((unsigned long )authmethods[i] != (unsigned long )((void *)0))) {
#line 310
        goto while_break;
      }
#line 311
      if ((unsigned long )(authmethods[i])->enabled != (unsigned long )((void *)0)) {
#line 311
        if (*((authmethods[i])->enabled) != 0) {
          {
          {
#line 311
          tmp = strcmp(name, (char const   *)(authmethods[i])->name);
          }
          }
#line 311
          if (tmp == 0) {
#line 314
            return (authmethods[i]);
          }
        }
      }
#line 310
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 315
  if (name) {
#line 315
    tmp___0 = name;
  } else {
#line 315
    tmp___0 = "NULL";
  }
  {
  {
#line 315
  debug2("Unrecognized authentication method name: %s", tmp___0);
  }
  }
#line 317
  return ((Authmethod *)((void *)0));
}
}
#line 408 "/usr/include/openssl/bn.h"
extern int BN_num_bits(BIGNUM const   *a ) ;
#line 55 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_get_bignum(BIGNUM *value ) ;
#line 109 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) ;
#line 111
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) ;
#line 140
void do_authentication(Authctxt *authctxt___0 ) ;
#line 34 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 35
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 36
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 37
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 38
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) ;
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static char *client_user  =    (char *)((void *)0);
#line 49 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
struct AuthMethod1  const  auth1_methods[6]  = {      {9, (char *)"password", & options.password_authentication, & auth1_process_password}, 
        {6,
      (char *)"rsa", & options.rsa_authentication, & auth1_process_rsa}, 
        {35, (char *)"rhosts-rsa", & options.rhosts_rsa_authentication, & auth1_process_rhosts_rsa}, 
        {39,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_challenge}, 
        {41,
      (char *)"challenge-response", & options.challenge_response_authentication, & auth1_process_tis_response}, 
        {-1,
      (char *)((void *)0), (int *)((void *)0), (int (*)(Authctxt * , char * , size_t  ))((void *)0)}};
#line 75 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static struct AuthMethod1  const  *lookup_authmethod1(int type ) 
{ 
  int i ;

  {
#line 80
  i = 0;
  {
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )auth1_methods[i].name != (unsigned long )((void *)0))) {
#line 80
      goto while_break;
    }
#line 81
    if (auth1_methods[i].type == (int const   )type) {
#line 82
      return (& auth1_methods[i]);
    }
#line 80
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return ((struct AuthMethod1  const  *)((void *)0));
}
}
#line 91 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static char buf___0[64]  ;
#line 87 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static char *get_authname(int type ) 
{ 
  struct AuthMethod1  const  *a ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 93
  a = lookup_authmethod1(type);
  }
  }
#line 93
  if ((unsigned long )a != (unsigned long )((void *)0)) {
#line 94
    return ((char *)a->name);
  }
  {
  {
#line 95
  snprintf((char */* __restrict  */)(buf___0), (size_t )sizeof(buf___0), (char const   */* __restrict  */)"bad-auth-msg-%d",
           type);
  }
  }
#line 96
  return (buf___0);
}
}
#line 99 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static int auth1_process_password(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ 
  int authenticated ;
  char *password ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 102
  authenticated = 0;
  {
#line 111
  tmp = packet_get_string(& dlen);
  }
#line 111
  password = (char *)tmp;
  }
  {
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 112
    tmp___0 = packet_remaining();
    }
#line 112
    _len = tmp___0;
    }
#line 112
    if (_len > 0) {
      {
      {
#line 112
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            112);
      }
      {
#line 112
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 112
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (use_privsep) {
    {
    {
#line 115
    tmp___1 = mm_auth_password(authctxt___0, password);
    }
#line 115
    authenticated = tmp___1;
    }
  } else {
    {
    {
#line 115
    tmp___2 = auth_password(authctxt___0, (char const   *)password);
    }
#line 115
    authenticated = tmp___2;
    }
  }
  {
  {
#line 117
  memset((void *)password, 0, dlen);
  }
  {
#line 118
  xfree((void *)password);
  }
  }
#line 120
  return (authenticated);
}
}
#line 123 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static int auth1_process_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ 
  int authenticated ;
  BIGNUM *n ;
  int _len ;
  int tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 126
  authenticated = 0;
  {
#line 130
  n = BN_new();
  }
  }
#line 130
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
    {
#line 131
    fatal("do_authloop: BN_new failed");
    }
    }
  }
  {
  {
#line 132
  packet_get_bignum(n);
  }
  }
  {
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 133
    tmp = packet_remaining();
    }
#line 133
    _len = tmp;
    }
#line 133
    if (_len > 0) {
      {
      {
#line 133
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            133);
      }
      {
#line 133
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 133
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  authenticated = auth_rsa(authctxt___0, n);
  }
  {
#line 135
  BN_clear_free(n);
  }
  }
#line 137
  return (authenticated);
}
}
#line 140 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static int auth1_process_rhosts_rsa(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ 
  int keybits ;
  int authenticated ;
  u_int bits ;
  Key *client_host_key ;
  u_int ulen ;
  void *tmp ;
  int tmp___0 ;
  int _len ;
  int tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 143
  authenticated = 0;
  {
#line 153
  tmp = packet_get_string(& ulen);
  }
#line 153
  client_user = (char *)tmp;
  {
#line 156
  client_host_key = key_new(0);
  }
  {
#line 157
  bits = packet_get_int();
  }
  {
#line 158
  packet_get_bignum((client_host_key->rsa)->e);
  }
  {
#line 159
  packet_get_bignum((client_host_key->rsa)->n);
  }
  {
#line 161
  keybits = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
  }
  }
#line 162
  if (keybits < 0) {
    {
    {
#line 163
    tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
    }
    {
#line 163
    verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp___0, bits);
    }
    }
  } else
#line 162
  if (bits != (u_int )keybits) {
    {
    {
#line 163
    tmp___0 = BN_num_bits((BIGNUM const   *)(client_host_key->rsa)->n);
    }
    {
#line 163
    verbose("Warning: keysize mismatch for client_host_key: actual %d, announced %d",
            tmp___0, bits);
    }
    }
  }
  {
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 167
    tmp___1 = packet_remaining();
    }
#line 167
    _len = tmp___1;
    }
#line 167
    if (_len > 0) {
      {
      {
#line 167
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            167);
      }
      {
#line 167
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 167
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 169
  authenticated = auth_rhosts_rsa(authctxt___0, client_user, client_host_key);
  }
  {
#line 171
  key_free(client_host_key);
  }
  {
#line 173
  snprintf((char */* __restrict  */)info, infolen, (char const   */* __restrict  */)" ruser %.100s",
           client_user);
  }
  }
#line 175
  return (authenticated);
}
}
#line 178 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static int auth1_process_tis_challenge(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ 
  char *challenge ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 183
  challenge = get_challenge(authctxt___0);
  }
  }
#line 183
  if ((unsigned long )challenge == (unsigned long )((void *)0)) {
#line 184
    return (0);
  }
  {
  {
#line 186
  debug("sending challenge \'%s\'", challenge);
  }
  {
#line 187
  packet_start((u_char )40);
  }
  {
#line 188
  packet_put_cstring((char const   *)challenge);
  }
  {
#line 189
  xfree((void *)challenge);
  }
  {
#line 190
  packet_send();
  }
  {
#line 191
  packet_write_wait();
  }
  }
#line 193
  return (-1);
}
}
#line 196 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static int auth1_process_tis_response(Authctxt *authctxt___0 , char *info , size_t infolen ) 
{ 
  int authenticated ;
  char *response ;
  u_int dlen ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 199
  authenticated = 0;
  {
#line 203
  tmp = packet_get_string(& dlen);
  }
#line 203
  response = (char *)tmp;
  }
  {
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 204
    tmp___0 = packet_remaining();
    }
#line 204
    _len = tmp___0;
    }
#line 204
    if (_len > 0) {
      {
      {
#line 204
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            204);
      }
      {
#line 204
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 204
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 205
  authenticated = verify_response(authctxt___0, (char const   *)response);
  }
  {
#line 206
  memset((void *)response, 'r', dlen);
  }
  {
#line 207
  xfree((void *)response);
  }
  }
#line 209
  return (authenticated);
}
}
#line 216 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
static void do_authloop(Authctxt *authctxt___0 ) 
{ 
  int authenticated ;
  char info[1024] ;
  int prev ;
  int type ;
  struct AuthMethod1  const  *meth ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 219
  authenticated = 0;
#line 221
  prev = 0;
#line 221
  type = 0;
#line 224
  if (authctxt___0->valid) {
#line 224
    tmp = "";
  } else {
#line 224
    tmp = "invalid user ";
  }
  {
  {
#line 224
  debug("Attempting authentication for %s%.100s.", tmp, authctxt___0->user);
  }
  }
#line 228
  if (options.password_authentication) {
#line 228
    if (use_privsep) {
      {
      {
#line 228
      tmp___0 = mm_auth_password(authctxt___0, (char *)"");
      }
#line 228
      tmp___2 = tmp___0;
      }
    } else {
      {
      {
#line 228
      tmp___1 = auth_password(authctxt___0, "");
      }
#line 228
      tmp___2 = tmp___1;
      }
    }
#line 228
    if (tmp___2) {
      {
      {
#line 237
      auth_log(authctxt___0, 1, (char *)"without authentication", (char *)"");
      }
      }
#line 238
      return;
    }
  }
  {
  {
#line 243
  packet_start((u_char )15);
  }
  {
#line 244
  packet_send();
  }
  {
#line 245
  packet_write_wait();
  }
  }
  {
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 249
    authenticated = 0;
#line 251
    info[0] = (char )'\000';
#line 254
    prev = type;
    {
#line 255
    type = packet_read();
    }
    }
#line 264
    if (prev == 39) {
#line 264
      if (type != 41) {
        {
        {
#line 266
        abandon_challenge_response(authctxt___0);
        }
        }
      }
    }
    {
    {
#line 268
    meth = lookup_authmethod1(type);
    }
    }
#line 268
    if ((unsigned long )meth == (unsigned long )((void *)0)) {
      {
      {
#line 269
      logit("Unknown message during authentication: type %d", type);
      }
      }
#line 271
      goto skip;
    }
#line 274
    if (! *(meth->enabled)) {
      {
      {
#line 275
      verbose("%s authentication disabled.", meth->name);
      }
      }
#line 276
      goto skip;
    }
    {
    {
#line 279
    authenticated = (*(meth->method))(authctxt___0, info, (size_t )sizeof(info));
    }
    }
#line 280
    if (authenticated == -1) {
#line 281
      goto __Cont;
    }
#line 289
    if (! authctxt___0->valid) {
#line 289
      if (authenticated) {
        {
        {
#line 290
        fatal("INTERNAL ERROR: authenticated invalid user %s", authctxt___0->user);
        }
        }
      }
    }
#line 310
    if (authenticated) {
#line 310
      if ((authctxt___0->pw)->pw_uid == 0U) {
        {
        {
#line 310
        tmp___3 = auth_root_allowed((char *)meth->name);
        }
        }
#line 310
        if (! tmp___3) {
#line 312
          authenticated = 0;
        }
      }
    }
    skip: 
    {
    {
#line 342
    tmp___4 = get_authname(type);
    }
    {
#line 342
    auth_log(authctxt___0, authenticated, tmp___4, info);
    }
    }
#line 344
    if ((unsigned long )client_user != (unsigned long )((void *)0)) {
      {
      {
#line 345
      xfree((void *)client_user);
      }
#line 346
      client_user = (char *)((void *)0);
      }
    }
#line 349
    if (authenticated) {
#line 350
      return;
    }
#line 352
    tmp___5 = authctxt___0->failures;
#line 352
    (authctxt___0->failures) ++;
#line 352
    if (tmp___5 > options.max_authtries) {
      {
      {
#line 356
      packet_disconnect("Too many authentication failures for %.100s", authctxt___0->user);
      }
      }
    }
    {
    {
#line 359
    packet_start((u_char )15);
    }
    {
#line 360
    packet_send();
    }
    {
#line 361
    packet_write_wait();
    }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 369 "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c"
void do_authentication(Authctxt *authctxt___0 ) 
{ 
  u_int ulen ;
  char *user ;
  char *style ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *tmp___1 ;
  struct passwd *tmp___2 ;
  struct passwd *tmp___3 ;
  struct passwd *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 373
  style = (char *)((void *)0);
  {
#line 376
  packet_read_expect(4);
  }
  {
#line 379
  tmp = packet_get_string(& ulen);
  }
#line 379
  user = (char *)tmp;
  }
  {
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 380
    tmp___0 = packet_remaining();
    }
#line 380
    _len = tmp___0;
    }
#line 380
    if (_len > 0) {
      {
      {
#line 380
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth1.c",
            380);
      }
      {
#line 380
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 380
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 382
  style = strchr((char const   *)user, ':');
  }
  }
#line 382
  if ((unsigned long )style != (unsigned long )((void *)0)) {
#line 383
    tmp___1 = style;
#line 383
    style ++;
#line 383
    *tmp___1 = (char )'\000';
  }
#line 385
  authctxt___0->user = user;
#line 386
  authctxt___0->style = style;
#line 389
  if (use_privsep) {
    {
    {
#line 389
    tmp___3 = mm_getpwnamallow((char const   *)user);
    }
#line 389
    tmp___2 = tmp___3;
    }
  } else {
    {
    {
#line 389
    tmp___4 = getpwnamallow((char const   *)user);
    }
#line 389
    tmp___2 = tmp___4;
    }
  }
#line 389
  authctxt___0->pw = tmp___2;
#line 389
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 390
    authctxt___0->valid = 1;
  } else {
    {
    {
#line 392
    debug("do_authentication: invalid user %s", user);
    }
    {
#line 393
    authctxt___0->pw = fakepw();
    }
    }
  }
#line 396
  if (use_privsep) {
#line 396
    tmp___5 = " [net]";
  } else {
#line 396
    tmp___5 = "";
  }
#line 396
  if (authctxt___0->valid) {
#line 396
    tmp___6 = (char const   *)user;
  } else {
#line 396
    tmp___6 = "unknown";
  }
  {
  {
#line 396
  setproctitle("%s%s", tmp___6, tmp___5);
  }
  }
#line 409
  if (! use_privsep) {
    {
    {
#line 409
    tmp___7 = getuid();
    }
    }
#line 409
    if (tmp___7 != 0U) {
#line 409
      if (authctxt___0->pw) {
        {
        {
#line 409
        tmp___8 = getuid();
        }
        }
#line 409
        if ((authctxt___0->pw)->pw_uid != tmp___8) {
          {
          {
#line 411
          packet_disconnect("Cannot change user when server not running as root.");
          }
          }
        }
      }
    }
  }
  {
  {
#line 418
  do_authloop(authctxt___0);
  }
  {
#line 421
  packet_start((u_char )14);
  }
  {
#line 422
  packet_send();
  }
  {
#line 423
  packet_write_wait();
  }
  }
#line 424
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 365 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 827
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 662 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 27 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/match.h"
extern int match_user(char const   * , char const   * , char const   * , char const   * ) ;
#line 22 "/home/pronto/abs/test-suite/openssh-4.3p2/hostfile.h"
extern HostStatus check_host_in_hostfile(char const   * , char const   * , Key const   * ,
                                         Key * , int * ) ;
#line 159 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int allowed_user(struct passwd *pw ) ;
#line 28 "/home/pronto/abs/test-suite/openssh-4.3p2/misc.h"
extern char *tilde_expand_filename(char const   * , uid_t  ) ;
#line 29
extern char *percent_expand(char const   *  , ...) ;
#line 33
extern struct passwd *pwcopy(struct passwd * ) ;
#line 61 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
Buffer auth_debug  ;
#line 62 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
int auth_debug_init  ;
#line 73 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
int allowed_user(struct passwd *pw ) 
{ 
  struct stat st ;
  char const   *hostname ;
  char const   *ipaddr ;
  char const   *passwd ;
  char *shell ;
  u_int i ;
  struct spwd *spw ;
  int tmp ;
  int locked ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 77
  hostname = (char const   *)((void *)0);
#line 77
  ipaddr = (char const   *)((void *)0);
#line 77
  passwd = (char const   *)((void *)0);
#line 81
  spw = (struct spwd *)((void *)0);
#line 85
  if (! pw) {
#line 86
    return (0);
  } else
#line 85
  if (! pw->pw_name) {
#line 86
    return (0);
  }
#line 89
  if (! options.use_pam) {
    {
    {
#line 90
    spw = getspnam((char const   *)pw->pw_name);
    }
    }
  }
#line 92
  if (! options.use_pam) {
#line 92
    if ((unsigned long )spw != (unsigned long )((void *)0)) {
      {
      {
#line 92
      tmp = auth_shadow_acctexpired(spw);
      }
      }
#line 92
      if (tmp) {
#line 93
        return (0);
      }
    }
  }
#line 99
  if ((unsigned long )spw != (unsigned long )((void *)0)) {
#line 103
    passwd = (char const   *)spw->sp_pwdp;
  }
#line 110
  if (! options.use_pam) {
#line 110
    if (passwd) {
#line 110
      if (*passwd) {
        {
#line 111
        locked = 0;
        {
#line 118
        tmp___0 = strlen("!");
        }
        {
#line 118
        tmp___1 = strncmp(passwd, "!", tmp___0);
        }
        }
#line 118
        if (tmp___1 == 0) {
#line 120
          locked = 1;
        }
#line 129
        if (locked) {
          {
          {
#line 130
          logit("User %.100s not allowed because account is locked", pw->pw_name);
          }
          }
#line 132
          return (0);
        }
      }
    }
  }
#line 140
  if ((int )*(pw->pw_shell + 0) == 0) {
#line 140
    shell = (char *)"/bin/sh";
  } else {
#line 140
    shell = pw->pw_shell;
  }
  {
  {
#line 143
  tmp___2 = stat((char const   */* __restrict  */)shell, (struct stat */* __restrict  */)(& st));
  }
  }
#line 143
  if (tmp___2 != 0) {
    {
    {
#line 144
    logit("User %.100s not allowed because shell %.100s does not exist", pw->pw_name,
          shell);
    }
    }
#line 146
    return (0);
  }
#line 148
  if (((st.st_mode & 61440U) == 32768U) == 0) {
    {
    {
#line 150
    logit("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
          shell);
    }
    }
#line 152
    return (0);
  } else
#line 148
  if ((st.st_mode & (unsigned int )((((64 >> 3) >> 3) | 64) | (64 >> 3))) == 0U) {
    {
    {
#line 150
    logit("User %.100s not allowed because shell %.100s is not executable", pw->pw_name,
          shell);
    }
    }
#line 152
    return (0);
  }
#line 155
  if (options.num_deny_users > 0U) {
    {
    {
#line 157
    hostname = get_canonical_hostname(options.use_dns);
    }
    {
#line 158
    ipaddr = get_remote_ipaddr();
    }
    }
  } else
#line 155
  if (options.num_allow_users > 0U) {
    {
    {
#line 157
    hostname = get_canonical_hostname(options.use_dns);
    }
    {
#line 158
    ipaddr = get_remote_ipaddr();
    }
    }
  } else
#line 155
  if (options.num_deny_groups > 0U) {
    {
    {
#line 157
    hostname = get_canonical_hostname(options.use_dns);
    }
    {
#line 158
    ipaddr = get_remote_ipaddr();
    }
    }
  } else
#line 155
  if (options.num_allow_groups > 0U) {
    {
    {
#line 157
    hostname = get_canonical_hostname(options.use_dns);
    }
    {
#line 158
    ipaddr = get_remote_ipaddr();
    }
    }
  }
#line 162
  if (options.num_deny_users > 0U) {
#line 163
    i = (u_int )0;
    {
    {
#line 163
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 163
      if (! (i < options.num_deny_users)) {
#line 163
        goto while_break;
      }
      {
      {
#line 164
      tmp___3 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.deny_users[i]);
      }
      }
#line 164
      if (tmp___3) {
        {
        {
#line 166
        logit("User %.100s from %.100s not allowed because listed in DenyUsers", pw->pw_name,
              hostname);
        }
        }
#line 169
        return (0);
      }
#line 163
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 173
  if (options.num_allow_users > 0U) {
#line 174
    i = (u_int )0;
    {
    {
#line 174
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 174
      if (! (i < options.num_allow_users)) {
#line 174
        goto while_break___0;
      }
      {
      {
#line 175
      tmp___4 = match_user((char const   *)pw->pw_name, hostname, ipaddr, (char const   *)options.allow_users[i]);
      }
      }
#line 175
      if (tmp___4) {
#line 177
        goto while_break___0;
      }
#line 174
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 179
    if (i >= options.num_allow_users) {
      {
      {
#line 180
      logit("User %.100s from %.100s not allowed because not listed in AllowUsers",
            pw->pw_name, hostname);
      }
      }
#line 182
      return (0);
    }
  }
#line 185
  if (options.num_deny_groups > 0U) {
#line 185
    goto _L;
  } else
#line 185
  if (options.num_allow_groups > 0U) {
    _L: /* CIL Label */ 
    {
    {
#line 187
    tmp___5 = ga_init((char const   *)pw->pw_name, pw->pw_gid);
    }
    }
#line 187
    if (tmp___5 == 0) {
      {
      {
#line 188
      logit("User %.100s from %.100s not allowed because not in any group", pw->pw_name,
            hostname);
      }
      }
#line 190
      return (0);
    }
#line 194
    if (options.num_deny_groups > 0U) {
      {
      {
#line 195
      tmp___6 = ga_match((char * const  *)(options.deny_groups), (int )options.num_deny_groups);
      }
      }
#line 195
      if (tmp___6) {
        {
        {
#line 197
        ga_free();
        }
        {
#line 198
        logit("User %.100s from %.100s not allowed because a group is listed in DenyGroups",
              pw->pw_name, hostname);
        }
        }
#line 201
        return (0);
      }
    }
#line 207
    if (options.num_allow_groups > 0U) {
      {
      {
#line 208
      tmp___7 = ga_match((char * const  *)(options.allow_groups), (int )options.num_allow_groups);
      }
      }
#line 208
      if (! tmp___7) {
        {
        {
#line 210
        ga_free();
        }
        {
#line 211
        logit("User %.100s from %.100s not allowed because none of user\'s groups are listed in AllowGroups",
              pw->pw_name, hostname);
        }
        }
#line 214
        return (0);
      }
    }
    {
    {
#line 216
    ga_free();
    }
    }
  }
#line 225
  return (1);
}
}
#line 228 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
void auth_log(Authctxt *authctxt___0 , int authenticated , char *method , char *info ) 
{ 
  void (*authlog)(char const   *fmt  , ...) ;
  char *authmsg ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 231
  authlog = (void (*)(char const   *fmt  , ...))(& verbose);
#line 235
  if (authenticated == 1) {
#line 239
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else
#line 235
  if (! authctxt___0->valid) {
#line 239
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else
#line 235
  if (authctxt___0->failures >= options.max_authtries / 2) {
#line 239
    authlog = (void (*)(char const   *fmt  , ...))(& logit);
  } else {
    {
    {
#line 235
    tmp = strcmp((char const   *)method, "password");
    }
    }
#line 235
    if (tmp == 0) {
#line 239
      authlog = (void (*)(char const   *fmt  , ...))(& logit);
    }
  }
#line 241
  if (authctxt___0->postponed) {
#line 242
    authmsg = (char *)"Postponed";
  } else
#line 244
  if (authenticated) {
#line 244
    authmsg = (char *)"Accepted";
  } else {
#line 244
    authmsg = (char *)"Failed";
  }
  {
  {
#line 246
  tmp___0 = get_remote_port();
  }
  {
#line 246
  tmp___1 = get_remote_ipaddr();
  }
  }
#line 246
  if (authctxt___0->valid) {
#line 246
    tmp___2 = "";
  } else {
#line 246
    tmp___2 = "invalid user ";
  }
  {
  {
#line 246
  (*authlog)("%s %s for %s%.100s from %.200s port %d%s", authmsg, method, tmp___2,
             authctxt___0->user, tmp___1, tmp___0, info);
  }
  }
#line 256
  if (authenticated == 0) {
#line 256
    if (! authctxt___0->postponed) {
      {
      {
#line 256
      tmp___4 = strcmp((char const   *)method, "password");
      }
      }
#line 256
      if (tmp___4 == 0) {
        {
        {
#line 260
        tmp___3 = get_canonical_hostname(options.use_dns);
        }
        {
#line 260
        record_failed_login((char const   *)authctxt___0->user, tmp___3, "ssh");
        }
        }
      } else {
        {
        {
#line 256
        tmp___5 = strncmp((char const   *)method, "keyboard-interactive", (size_t )20);
        }
        }
#line 256
        if (tmp___5 == 0) {
          {
          {
#line 260
          tmp___3 = get_canonical_hostname(options.use_dns);
          }
          {
#line 260
          record_failed_login((char const   *)authctxt___0->user, tmp___3, "ssh");
          }
          }
        } else {
          {
          {
#line 256
          tmp___6 = strcmp((char const   *)method, "challenge-response");
          }
          }
#line 256
          if (tmp___6 == 0) {
            {
            {
#line 260
            tmp___3 = get_canonical_hostname(options.use_dns);
            }
            {
#line 260
            record_failed_login((char const   *)authctxt___0->user, tmp___3, "ssh");
            }
            }
          }
        }
      }
    }
  }
#line 301
  return;
}
}
#line 306 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
int auth_root_allowed(char *method ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 310
  if (options.permit_root_login == 3) {
#line 310
    goto case_3;
  }
#line 313
  if (options.permit_root_login == 2) {
#line 313
    goto case_2;
  }
#line 317
  if (options.permit_root_login == 1) {
#line 317
    goto case_1;
  }
#line 309
  goto switch_break;
  case_3: /* CIL Label */ 
#line 311
  return (1);
#line 312
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 314
  tmp = strcmp((char const   *)method, "password");
  }
  }
#line 314
  if (tmp != 0) {
#line 315
    return (1);
  }
#line 316
  goto switch_break;
  case_1: /* CIL Label */ 
#line 318
  if (forced_command) {
    {
    {
#line 319
    logit("Root login accepted for forced command.");
    }
    }
#line 320
    return (1);
  }
#line 322
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 324
  tmp___0 = get_remote_ipaddr();
  }
  {
#line 324
  logit("ROOT LOGIN REFUSED FROM %.200s", tmp___0);
  }
  }
#line 325
  return (0);
}
}
#line 336 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
static char *expand_authorized_keys(char const   *filename , struct passwd *pw ) 
{ 
  char *file ;
  char *ret ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 341
  file = percent_expand(filename, "h", pw->pw_dir, "u", pw->pw_name, (char *)((void *)0));
  }
  }
#line 348
  if ((int )*file == 47) {
#line 349
    return (file);
  }
  {
  {
#line 351
  tmp = xmalloc((size_t )4096);
  }
#line 351
  ret = (char *)tmp;
  {
#line 352
  tmp___0 = strlcpy(ret, (char const   *)pw->pw_dir, (size_t )4096);
  }
  }
#line 352
  if (tmp___0 >= 4096U) {
    {
    {
#line 355
    fatal("expand_authorized_keys: path too long");
    }
    }
  } else {
    {
    {
#line 352
    tmp___1 = strlcat(ret, "/", (size_t )4096);
    }
    }
#line 352
    if (tmp___1 >= 4096U) {
      {
      {
#line 355
      fatal("expand_authorized_keys: path too long");
      }
      }
    } else {
      {
      {
#line 352
      tmp___2 = strlcat(ret, (char const   *)file, (size_t )4096);
      }
      }
#line 352
      if (tmp___2 >= 4096U) {
        {
        {
#line 355
        fatal("expand_authorized_keys: path too long");
        }
        }
      }
    }
  }
  {
  {
#line 357
  xfree((void *)file);
  }
  }
#line 358
  return (ret);
}
}
#line 361 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
char *authorized_keys_file(struct passwd *pw ) 
{ 
  char *tmp ;

  {
  {
  {
#line 364
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file, pw);
  }
  }
#line 364
  return (tmp);
}
}
#line 367 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
char *authorized_keys_file2(struct passwd *pw ) 
{ 
  char *tmp ;

  {
  {
  {
#line 370
  tmp = expand_authorized_keys((char const   *)options.authorized_keys_file2, pw);
  }
  }
#line 370
  return (tmp);
}
}
#line 374 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
HostStatus check_key_in_hostfiles(struct passwd *pw , Key *key , char const   *host ,
                                  char const   *sysfile , char const   *userfile ) 
{ 
  Key *found ;
  char *user_hostfile ;
  struct stat st ;
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 384
  found = key_new(key->type);
  }
  {
#line 385
  host_status = check_host_in_hostfile(sysfile, host, (Key const   *)key, found, (int *)((void *)0));
  }
  }
#line 387
  if ((unsigned int )host_status != 0U) {
#line 387
    if ((unsigned long )userfile != (unsigned long )((void *)0)) {
      {
      {
#line 388
      user_hostfile = tilde_expand_filename(userfile, pw->pw_uid);
      }
      }
#line 389
      if (options.strict_modes) {
        {
        {
#line 389
        tmp = stat((char const   */* __restrict  */)user_hostfile, (struct stat */* __restrict  */)(& st));
        }
        }
#line 389
        if (tmp == 0) {
#line 389
          if (st.st_uid != 0U) {
#line 389
            if (st.st_uid != pw->pw_uid) {
              {
              {
#line 393
              logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                    pw->pw_name, user_hostfile);
              }
              }
            } else {
#line 389
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 389
          if ((st.st_mode & 18U) != 0U) {
            {
            {
#line 393
            logit("Authentication refused for %.100s: bad owner or modes for %.200s",
                  pw->pw_name, user_hostfile);
            }
            }
          } else {
            {
            {
#line 397
            temporarily_use_uid(pw);
            }
            {
#line 398
            host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                                 (Key const   *)key, found, (int *)((void *)0));
            }
            {
#line 400
            restore_uid();
            }
            }
          }
        } else {
          {
          {
#line 397
          temporarily_use_uid(pw);
          }
          {
#line 398
          host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                               (Key const   *)key, found, (int *)((void *)0));
          }
          {
#line 400
          restore_uid();
          }
          }
        }
      } else {
        {
        {
#line 397
        temporarily_use_uid(pw);
        }
        {
#line 398
        host_status = check_host_in_hostfile((char const   *)user_hostfile, host,
                                             (Key const   *)key, found, (int *)((void *)0));
        }
        {
#line 400
        restore_uid();
        }
        }
      }
      {
      {
#line 402
      xfree((void *)user_hostfile);
      }
      }
    }
  }
  {
  {
#line 404
  key_free(found);
  }
  }
#line 406
  if ((unsigned int )host_status == 0U) {
#line 406
    tmp___0 = "ok";
  } else {
#line 406
    tmp___0 = "not found";
  }
  {
  {
#line 406
  debug2("check_key_in_hostfiles: key %s for %s", tmp___0, host);
  }
  }
#line 408
  return (host_status);
}
}
#line 424 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
int secure_filename(FILE *f , char const   *file , struct passwd *pw , char *err ,
                    size_t errlen ) 
{ 
  uid_t uid ;
  char buf___1[4096] ;
  char homedir[4096] ;
  char *cp ;
  int comparehome ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 428
  uid = pw->pw_uid;
#line 431
  comparehome = 0;
  {
#line 434
  tmp___1 = realpath((char const   */* __restrict  */)file, (char */* __restrict  */)(buf___1));
  }
  }
#line 434
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
    {
#line 435
    tmp = __errno_location();
    }
    {
#line 435
    tmp___0 = strerror(*tmp);
    }
    {
#line 435
    snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"realpath %s failed: %s",
             file, tmp___0);
    }
    }
#line 437
    return (-1);
  }
  {
  {
#line 439
  tmp___2 = realpath((char const   */* __restrict  */)pw->pw_dir, (char */* __restrict  */)(homedir));
  }
  }
#line 439
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 440
    comparehome = 1;
  }
  {
  {
#line 443
  tmp___3 = fileno(f);
  }
  {
#line 443
  tmp___4 = fstat(tmp___3, & st);
  }
  }
#line 443
  if (tmp___4 < 0) {
    {
    {
#line 446
    snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"bad ownership or modes for file %s",
             buf___1);
    }
    }
#line 448
    return (-1);
  } else
#line 443
  if (st.st_uid != 0U) {
#line 443
    if (st.st_uid != uid) {
      {
      {
#line 446
      snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"bad ownership or modes for file %s",
               buf___1);
      }
      }
#line 448
      return (-1);
    } else {
#line 443
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 443
  if ((st.st_mode & 18U) != 0U) {
    {
    {
#line 446
    snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"bad ownership or modes for file %s",
             buf___1);
    }
    }
#line 448
    return (-1);
  }
  {
  {
#line 452
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 453
    cp = dirname(buf___1);
    }
    }
#line 453
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
      {
#line 454
      snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"dirname() failed");
      }
      }
#line 455
      return (-1);
    }
    {
    {
#line 457
    strlcpy(buf___1, (char const   *)cp, (size_t )sizeof(buf___1));
    }
    {
#line 459
    debug3("secure_filename: checking \'%s\'", buf___1);
    }
    {
#line 460
    tmp___5 = stat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)(& st));
    }
    }
#line 460
    if (tmp___5 < 0) {
      {
      {
#line 463
      snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"bad ownership or modes for directory %s",
               buf___1);
      }
      }
#line 465
      return (-1);
    } else
#line 460
    if (st.st_uid != 0U) {
#line 460
      if (st.st_uid != uid) {
        {
        {
#line 463
        snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"bad ownership or modes for directory %s",
                 buf___1);
        }
        }
#line 465
        return (-1);
      } else {
#line 460
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 460
    if ((st.st_mode & 18U) != 0U) {
      {
      {
#line 463
      snprintf((char */* __restrict  */)err, errlen, (char const   */* __restrict  */)"bad ownership or modes for directory %s",
               buf___1);
      }
      }
#line 465
      return (-1);
    }
#line 469
    if (comparehome) {
      {
      {
#line 469
      tmp___6 = strcmp((char const   *)(homedir), (char const   *)(buf___1));
      }
      }
#line 469
      if (tmp___6 == 0) {
        {
        {
#line 470
        debug3("secure_filename: terminating check at \'%s\'", buf___1);
        }
        }
#line 472
        goto while_break;
      }
    }
    {
    {
#line 478
    tmp___7 = strcmp("/", (char const   *)(buf___1));
    }
    }
#line 478
    if (tmp___7 == 0) {
#line 479
      goto while_break;
    } else {
      {
      {
#line 478
      tmp___8 = strcmp(".", (char const   *)(buf___1));
      }
      }
#line 478
      if (tmp___8 == 0) {
#line 479
        goto while_break;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  return (0);
}
}
#line 484 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
struct passwd *getpwnamallow(char const   *user ) 
{ 
  struct passwd *pw ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  struct passwd *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 495
  pw = getpwnam(user);
  }
  }
#line 496
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
    {
#line 497
    tmp = get_remote_ipaddr();
    }
    {
#line 497
    logit("Invalid user %.100s from %.100s", user, tmp);
    }
    {
#line 500
    tmp___0 = get_canonical_hostname(options.use_dns);
    }
    {
#line 500
    record_failed_login(user, tmp___0, "ssh");
    }
    }
#line 506
    return ((struct passwd *)((void *)0));
  }
  {
  {
#line 508
  tmp___1 = allowed_user(pw);
  }
  }
#line 508
  if (! tmp___1) {
#line 509
    return ((struct passwd *)((void *)0));
  }
#line 525
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
    {
    {
#line 526
    tmp___2 = pwcopy(pw);
    }
    }
#line 526
    return (tmp___2);
  }
#line 527
  return ((struct passwd *)((void *)0));
}
}
#line 530 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
void ( /* format attribute */  auth_debug_add)(char const   *fmt  , ...) 
{ 
  char buf___1[1024] ;
  va_list args ;
  void *__cil_tmp4 ;

  {
#line 536
  if (! auth_debug_init) {
#line 537
    return;
  }
  {
  {
#line 539
  __builtin_va_start(args, fmt);
  }
  {
#line 540
  vsnprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)fmt,
            args);
  }
  {
#line 541
  __builtin_va_end(args);
  }
  {
#line 542
  buffer_put_cstring(& auth_debug, (char const   *)(buf___1));
  }
  }
#line 543
  return;
}
}
#line 545 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
void auth_debug_send(void) 
{ 
  char *msg ;
  void *tmp ;
  u_int tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 550
  if (! auth_debug_init) {
#line 551
    return;
  }
  {
  {
#line 552
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 552
    tmp___0 = buffer_len(& auth_debug);
    }
    }
#line 552
    if (! tmp___0) {
#line 552
      goto while_break;
    }
    {
    {
#line 553
    tmp = buffer_get_string(& auth_debug, (u_int *)((void *)0));
    }
#line 553
    msg = (char *)tmp;
    {
#line 554
    packet_send_debug("%s", msg);
    }
    {
#line 555
    xfree((void *)msg);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return;
}
}
#line 559 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
void auth_debug_reset(void) 
{ 


  {
#line 562
  if (auth_debug_init) {
    {
    {
#line 563
    buffer_clear(& auth_debug);
    }
    }
  } else {
    {
    {
#line 565
    buffer_init(& auth_debug);
    }
#line 566
    auth_debug_init = 1;
    }
  }
#line 568
  return;
}
}
#line 573 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
static struct passwd fake  ;
#line 570 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.c"
struct passwd *fakepw(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 575
  memset((void *)(& fake), 0, (size_t )sizeof(fake));
  }
#line 576
  fake.pw_name = (char *)"NOUSER";
#line 577
  fake.pw_passwd = (char *)"$2a$06$r3.juUaHZDlIbQaO2dS9FuYxL1W9M81R1Tc92PoSNmzvpEqLkLGrK";
#line 579
  fake.pw_gecos = (char *)"NOUSER";
#line 580
  fake.pw_uid = (uid_t )-1;
#line 581
  fake.pw_gid = (gid_t )-1;
#line 585
  fake.pw_dir = (char *)"/nonexist";
#line 586
  fake.pw_shell = (char *)"/nonexist";
  }
#line 588
  return (& fake);
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 222
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 745
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 219 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 168 "./channels.h"
extern void channel_free(Channel * ) ;
#line 169
extern void channel_free_all(void) ;
#line 176
extern void channel_register_filter(int  , channel_infilter_fn * , channel_outfilter_fn * ) ;
#line 183
extern void channel_input_close(int  , u_int32_t  , void * ) ;
#line 184
extern void channel_input_close_confirmation(int  , u_int32_t  , void * ) ;
#line 185
extern void channel_input_data(int  , u_int32_t  , void * ) ;
#line 186
extern void channel_input_extended_data(int  , u_int32_t  , void * ) ;
#line 187
extern void channel_input_ieof(int  , u_int32_t  , void * ) ;
#line 188
extern void channel_input_oclose(int  , u_int32_t  , void * ) ;
#line 189
extern void channel_input_open_confirmation(int  , u_int32_t  , void * ) ;
#line 190
extern void channel_input_open_failure(int  , u_int32_t  , void * ) ;
#line 191
extern void channel_input_port_open(int  , u_int32_t  , void * ) ;
#line 192
extern void channel_input_window_adjust(int  , u_int32_t  , void * ) ;
#line 196
extern void channel_prepare_select(fd_set ** , fd_set ** , int * , u_int * , int  ) ;
#line 197
extern void channel_after_select(fd_set * , fd_set * ) ;
#line 198
extern void channel_output_poll(void) ;
#line 200
extern int channel_not_very_much_buffered_data(void) ;
#line 202
extern int channel_still_open(void) ;
#line 203
extern char *channel_open_message(void) ;
#line 204
extern int channel_find_open(void) ;
#line 212
extern int channel_connect_to(char const   * , u_short  ) ;
#line 219
extern int channel_setup_remote_fwd_listener(char const   * , u_short  , int  ) ;
#line 220
extern int channel_cancel_rport_listener(char const   * , u_short  ) ;
#line 29 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/port-tun.h"
extern int sys_tun_infilter(struct Channel * , char * , int  ) ;
#line 30
extern u_char *sys_tun_outfilter(struct Channel * , u_char ** , u_int * ) ;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern int packet_is_interactive(void) ;
#line 49
extern void packet_process_incoming(char const   *buf , u_int len ) ;
#line 72
extern void packet_write_poll(void) ;
#line 74
extern int packet_have_data_to_write(void) ;
#line 75
extern int packet_not_very_much_data_to_write(void) ;
#line 80
extern void packet_send_ignore(int  ) ;
#line 86
extern u_int max_packet_size ;
#line 101
extern int packet_need_rekeying(void) ;
#line 19 "/home/pronto/abs/test-suite/openssh-4.3p2/misc.h"
extern int set_nonblock(int  ) ;
#line 58
extern int tun_open(int  , int  ) ;
#line 129 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
extern void kex_send_kexinit(Kex * ) ;
#line 130
extern void kex_input_kexinit(int  , u_int32_t  , void * ) ;
#line 62 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
Kex *xxx_kex ;
#line 63
Authctxt *the_authctxt ;
#line 66 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static Buffer stdin_buffer  ;
#line 67 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static Buffer stdout_buffer  ;
#line 68 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static Buffer stderr_buffer  ;
#line 69 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int fdin  ;
#line 70 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int fdout  ;
#line 72 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int fderr  ;
#line 73 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static long stdin_bytes  =    0L;
#line 74 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static long stdout_bytes  =    0L;
#line 75 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static long stderr_bytes  =    0L;
#line 76 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static long fdout_bytes  =    0L;
#line 77 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int stdin_eof  =    0;
#line 78 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int fdout_eof  =    0;
#line 79 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int fderr_eof  =    0;
#line 80 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int fdin_is_tty  =    0;
#line 81 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int connection_in  ;
#line 82 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int connection_out  ;
#line 83 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int connection_closed  =    0;
#line 84 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static u_int buffer_high  ;
#line 85 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int client_alive_timeouts  =    0;
#line 92 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int volatile   child_terminated  =    (sig_atomic_t volatile   )0;
#line 95 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int volatile   received_sigterm  =    (sig_atomic_t volatile   )0;
#line 98
static void server_init_dispatch(void) ;
#line 104 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static int notify_pipe[2]  ;
#line 105 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void notify_setup(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 108
  tmp___5 = pipe((int *)(notify_pipe));
  }
  }
#line 108
  if (tmp___5 < 0) {
    {
    {
#line 109
    tmp = __errno_location();
    }
    {
#line 109
    tmp___0 = strerror(*tmp);
    }
    {
#line 109
    error("pipe(notify_pipe) failed %s", tmp___0);
    }
    }
  } else {
    {
    {
#line 110
    tmp___3 = fcntl(notify_pipe[0], 2, 1);
    }
    }
#line 110
    if (tmp___3 == -1) {
      {
      {
#line 112
      tmp___1 = __errno_location();
      }
      {
#line 112
      tmp___2 = strerror(*tmp___1);
      }
      {
#line 112
      error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
      }
      {
#line 113
      close(notify_pipe[0]);
      }
      {
#line 114
      close(notify_pipe[1]);
      }
      }
    } else {
      {
      {
#line 110
      tmp___4 = fcntl(notify_pipe[1], 2, 1);
      }
      }
#line 110
      if (tmp___4 == -1) {
        {
        {
#line 112
        tmp___1 = __errno_location();
        }
        {
#line 112
        tmp___2 = strerror(*tmp___1);
        }
        {
#line 112
        error("fcntl(notify_pipe, F_SETFD) failed %s", tmp___2);
        }
        {
#line 113
        close(notify_pipe[0]);
        }
        {
#line 114
        close(notify_pipe[1]);
        }
        }
      } else {
        {
        {
#line 116
        set_nonblock(notify_pipe[0]);
        }
        {
#line 117
        set_nonblock(notify_pipe[1]);
        }
        }
#line 118
        return;
      }
    }
  }
#line 120
  notify_pipe[0] = -1;
#line 121
  notify_pipe[1] = -1;
#line 122
  return;
}
}
#line 123 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void notify_parent(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 126
  if (notify_pipe[1] != -1) {
    {
    {
#line 127
    write(notify_pipe[1], (void const   *)"", (size_t )1);
    }
    }
  }
#line 128
  return;
}
}
#line 129 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void notify_prepare(fd_set *readset ) 
{ 


  {
#line 132
  if (notify_pipe[0] != -1) {
#line 133
    readset->fds_bits[(unsigned long )notify_pipe[0] / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )notify_pipe[0] % (8UL * sizeof(__fd_mask ));
  }
#line 134
  return;
}
}
#line 135 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void notify_done(fd_set *readset ) 
{ 
  char c ;
  ssize_t tmp ;
  char *__cil_tmp4 ;

  {
#line 140
  if (notify_pipe[0] != -1) {
#line 140
    if ((readset->fds_bits[(unsigned long )notify_pipe[0] / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )notify_pipe[0] % (8UL * sizeof(__fd_mask )))) != 0L) {
      {
      {
#line 141
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 141
        tmp = read(notify_pipe[0], (void *)(& c), (size_t )1);
        }
        }
#line 141
        if (! (tmp != -1)) {
#line 141
          goto while_break;
        }
        {
        {
#line 142
        debug2("notify_done: reading");
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 143
  return;
}
}
#line 145 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void sigchld_handler(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 148
  tmp = __errno_location();
  }
#line 148
  save_errno = *tmp;
  {
#line 149
  debug("Received SIGCHLD.");
  }
#line 150
  child_terminated = (int volatile   )1;
  {
#line 152
  mysignal(17, & sigchld_handler);
  }
  {
#line 154
  notify_parent();
  }
  {
#line 155
  tmp___0 = __errno_location();
  }
#line 155
  *tmp___0 = save_errno;
  }
#line 156
  return;
}
}
#line 158 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void sigterm_handler(int sig ) 
{ 


  {
#line 161
  received_sigterm = (int volatile   )sig;
#line 162
  return;
}
}
#line 168 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void make_packets_from_stderr_data(void) 
{ 
  u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 174
    tmp___1 = buffer_len(& stderr_buffer);
    }
    }
#line 174
    if (tmp___1 > 0U) {
      {
      {
#line 174
      tmp___2 = packet_not_very_much_data_to_write();
      }
      }
#line 174
      if (! tmp___2) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
    {
    {
#line 176
    len = buffer_len(& stderr_buffer);
    }
    {
#line 177
    tmp = packet_is_interactive();
    }
    }
#line 177
    if (tmp) {
#line 178
      if (len > 512U) {
#line 179
        len = (u_int )512;
      }
    } else
#line 182
    if (len > max_packet_size) {
#line 183
      len = max_packet_size;
    }
    {
    {
#line 185
    packet_start((u_char )18);
    }
    {
#line 186
    tmp___0 = buffer_ptr(& stderr_buffer);
    }
    {
#line 186
    packet_put_string((void const   *)tmp___0, len);
    }
    {
#line 187
    packet_send();
    }
    {
#line 188
    buffer_consume(& stderr_buffer, len);
    }
#line 189
    stderr_bytes += (long )len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 197 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void make_packets_from_stdout_data(void) 
{ 
  u_int len ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 203
    tmp___1 = buffer_len(& stdout_buffer);
    }
    }
#line 203
    if (tmp___1 > 0U) {
      {
      {
#line 203
      tmp___2 = packet_not_very_much_data_to_write();
      }
      }
#line 203
      if (! tmp___2) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
    {
    {
#line 205
    len = buffer_len(& stdout_buffer);
    }
    {
#line 206
    tmp = packet_is_interactive();
    }
    }
#line 206
    if (tmp) {
#line 207
      if (len > 512U) {
#line 208
        len = (u_int )512;
      }
    } else
#line 211
    if (len > max_packet_size) {
#line 212
      len = max_packet_size;
    }
    {
    {
#line 214
    packet_start((u_char )17);
    }
    {
#line 215
    tmp___0 = buffer_ptr(& stdout_buffer);
    }
    {
#line 215
    packet_put_string((void const   *)tmp___0, len);
    }
    {
#line 216
    packet_send();
    }
    {
#line 217
    buffer_consume(& stdout_buffer, len);
    }
#line 218
    stdout_bytes += (long )len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 222 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void client_alive_check(void) 
{ 
  int channel_id ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 228
  client_alive_timeouts ++;
#line 228
  if (client_alive_timeouts > options.client_alive_count_max) {
    {
    {
#line 229
    packet_disconnect("Timeout, your session not responding.");
    }
    }
  }
  {
  {
#line 235
  channel_id = channel_find_open();
  }
  }
#line 235
  if (channel_id == -1) {
    {
    {
#line 236
    packet_start((u_char )80);
    }
    {
#line 237
    packet_put_cstring("keepalive@openssh.com");
    }
    {
#line 238
    packet_put_char(1);
    }
    }
  } else {
    {
    {
#line 240
    channel_request_start(channel_id, (char *)"keepalive@openssh.com", 1);
    }
    }
  }
  {
  {
#line 242
  packet_send();
  }
  }
#line 243
  return;
}
}
#line 251 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void wait_until_can_do_something(fd_set **readsetp , fd_set **writesetp , int *maxfdp ,
                                        u_int *nallocp , u_int max_time_milliseconds ) 
{ 
  struct timeval tv ;
  struct timeval *tvp ;
  int ret ;
  int client_alive_scheduled ;
  u_int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *__cil_tmp19 ;

  {
#line 257
  client_alive_scheduled = 0;
#line 267
  if (compat20) {
#line 267
    if (max_time_milliseconds == 0U) {
#line 267
      if (options.client_alive_interval) {
#line 269
        client_alive_scheduled = 1;
#line 270
        max_time_milliseconds = (u_int )(options.client_alive_interval * 1000);
      }
    }
  }
  {
  {
#line 274
  channel_prepare_select(readsetp, writesetp, maxfdp, nallocp, 0);
  }
  }
#line 276
  if (compat20) {
#line 281
    (*readsetp)->fds_bits[(unsigned long )connection_in / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )connection_in % (8UL * sizeof(__fd_mask ));
  } else {
    {
    {
#line 287
    tmp = buffer_len(& stdin_buffer);
    }
    }
#line 287
    if (tmp < buffer_high) {
      {
      {
#line 287
      tmp___0 = channel_not_very_much_buffered_data();
      }
      }
#line 287
      if (tmp___0) {
#line 289
        (*readsetp)->fds_bits[(unsigned long )connection_in / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )connection_in % (8UL * sizeof(__fd_mask ));
      }
    }
    {
    {
#line 294
    tmp___1 = packet_not_very_much_data_to_write();
    }
    }
#line 294
    if (tmp___1) {
#line 295
      if (! fdout_eof) {
#line 296
        (*readsetp)->fds_bits[(unsigned long )fdout / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )fdout % (8UL * sizeof(__fd_mask ));
      }
#line 297
      if (! fderr_eof) {
#line 298
        (*readsetp)->fds_bits[(unsigned long )fderr / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )fderr % (8UL * sizeof(__fd_mask ));
      }
    }
#line 304
    if (fdin != -1) {
      {
      {
#line 304
      tmp___2 = buffer_len(& stdin_buffer);
      }
      }
#line 304
      if (tmp___2 > 0U) {
#line 305
        (*writesetp)->fds_bits[(unsigned long )fdin / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )fdin % (8UL * sizeof(__fd_mask ));
      }
    }
  }
  {
  {
#line 307
  notify_prepare(*readsetp);
  }
  {
#line 313
  tmp___3 = packet_have_data_to_write();
  }
  }
#line 313
  if (tmp___3) {
#line 314
    (*writesetp)->fds_bits[(unsigned long )connection_out / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )connection_out % (8UL * sizeof(__fd_mask ));
  }
#line 320
  if (child_terminated) {
    {
    {
#line 320
    tmp___4 = packet_not_very_much_data_to_write();
    }
    }
#line 320
    if (tmp___4) {
#line 321
      if (max_time_milliseconds == 0U) {
#line 322
        max_time_milliseconds = (u_int )100;
      } else
#line 321
      if (client_alive_scheduled) {
#line 322
        max_time_milliseconds = (u_int )100;
      }
    }
  }
#line 324
  if (max_time_milliseconds == 0U) {
#line 325
    tvp = (struct timeval *)((void *)0);
  } else {
#line 327
    tv.tv_sec = (__time_t )(max_time_milliseconds / 1000U);
#line 328
    tv.tv_usec = (__suseconds_t )(1000U * (max_time_milliseconds % 1000U));
#line 329
    tvp = & tv;
  }
  {
  {
#line 333
  ret = select(*maxfdp + 1, (fd_set */* __restrict  */)*readsetp, (fd_set */* __restrict  */)*writesetp,
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tvp);
  }
  }
#line 335
  if (ret == -1) {
    {
    {
#line 336
    memset((void *)*readsetp, 0, *nallocp);
    }
    {
#line 337
    memset((void *)*writesetp, 0, *nallocp);
    }
    {
#line 338
    tmp___7 = __errno_location();
    }
    }
#line 338
    if (*tmp___7 != 4) {
      {
      {
#line 339
      tmp___5 = __errno_location();
      }
      {
#line 339
      tmp___6 = strerror(*tmp___5);
      }
      {
#line 339
      error("select: %.100s", tmp___6);
      }
      }
    }
  } else
#line 340
  if (ret == 0) {
#line 340
    if (client_alive_scheduled) {
      {
      {
#line 341
      client_alive_check();
      }
      }
    }
  }
  {
  {
#line 343
  notify_done(*readsetp);
  }
  }
#line 344
  return;
}
}
#line 350 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void process_input(fd_set *readset ) 
{ 
  int len ;
  char buf___1[16384] ;
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 357
  if ((readset->fds_bits[(unsigned long )connection_in / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )connection_in % (8UL * sizeof(__fd_mask )))) != 0L) {
    {
    {
#line 358
    len = read(connection_in, (void *)(buf___1), (size_t )sizeof(buf___1));
    }
    }
#line 359
    if (len == 0) {
      {
      {
#line 360
      tmp = get_remote_ipaddr();
      }
      {
#line 360
      verbose("Connection closed by %.100s", tmp);
      }
#line 362
      connection_closed = 1;
      }
#line 363
      if (compat20) {
#line 364
        return;
      }
      {
      {
#line 365
      cleanup_exit(255);
      }
      }
    } else
#line 366
    if (len < 0) {
      {
      {
#line 367
      tmp___3 = __errno_location();
      }
      }
#line 367
      if (*tmp___3 != 4) {
        {
        {
#line 367
        tmp___4 = __errno_location();
        }
        }
#line 367
        if (*tmp___4 != 11) {
          {
          {
#line 368
          tmp___0 = __errno_location();
          }
          {
#line 368
          tmp___1 = strerror(*tmp___0);
          }
          {
#line 368
          tmp___2 = get_remote_ipaddr();
          }
          {
#line 368
          verbose("Read error from remote host %.100s: %.100s", tmp___2, tmp___1);
          }
          {
#line 371
          cleanup_exit(255);
          }
          }
        }
      }
    } else {
      {
      {
#line 375
      packet_process_incoming((char const   *)(buf___1), (u_int )len);
      }
      }
    }
  }
#line 378
  if (compat20) {
#line 379
    return;
  }
#line 382
  if (! fdout_eof) {
#line 382
    if ((readset->fds_bits[(unsigned long )fdout / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )fdout % (8UL * sizeof(__fd_mask )))) != 0L) {
      {
      {
#line 383
      len = read(fdout, (void *)(buf___1), (size_t )sizeof(buf___1));
      }
      }
#line 384
      if (len < 0) {
        {
        {
#line 384
        tmp___5 = __errno_location();
        }
        }
#line 384
        if (! (*tmp___5 == 4)) {
          {
          {
#line 384
          tmp___6 = __errno_location();
          }
          }
#line 384
          if (! (*tmp___6 == 11)) {
#line 384
            goto _L;
          }
        }
      } else
      _L: /* CIL Label */ 
#line 386
      if (len <= 0) {
#line 387
        fdout_eof = 1;
      } else {
        {
        {
#line 389
        buffer_append(& stdout_buffer, (void const   *)(buf___1), (u_int )len);
        }
#line 390
        fdout_bytes += (long )len;
        }
      }
    }
  }
#line 394
  if (! fderr_eof) {
#line 394
    if ((readset->fds_bits[(unsigned long )fderr / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )fderr % (8UL * sizeof(__fd_mask )))) != 0L) {
      {
      {
#line 395
      len = read(fderr, (void *)(buf___1), (size_t )sizeof(buf___1));
      }
      }
#line 396
      if (len < 0) {
        {
        {
#line 396
        tmp___7 = __errno_location();
        }
        }
#line 396
        if (! (*tmp___7 == 4)) {
          {
          {
#line 396
          tmp___8 = __errno_location();
          }
          }
#line 396
          if (! (*tmp___8 == 11)) {
#line 396
            goto _L___0;
          }
        }
      } else
      _L___0: /* CIL Label */ 
#line 398
      if (len <= 0) {
#line 399
        fderr_eof = 1;
      } else {
        {
        {
#line 401
        buffer_append(& stderr_buffer, (void const   *)(buf___1), (u_int )len);
        }
        }
      }
    }
  }
#line 404
  return;
}
}
#line 409 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void process_output(fd_set *writeset ) 
{ 
  struct termios tio ;
  u_char *data ;
  u_int dlen ;
  int len ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 418
  if (! compat20) {
#line 418
    if (fdin != -1) {
#line 418
      if ((writeset->fds_bits[(unsigned long )fdin / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )fdin % (8UL * sizeof(__fd_mask )))) != 0L) {
        {
        {
#line 419
        tmp = buffer_ptr(& stdin_buffer);
        }
#line 419
        data = (u_char *)tmp;
        {
#line 420
        dlen = buffer_len(& stdin_buffer);
        }
        {
#line 421
        len = write(fdin, (void const   *)data, dlen);
        }
        }
#line 422
        if (len < 0) {
          {
          {
#line 422
          tmp___1 = __errno_location();
          }
          }
#line 422
          if (! (*tmp___1 == 4)) {
            {
            {
#line 422
            tmp___2 = __errno_location();
            }
            }
#line 422
            if (! (*tmp___2 == 11)) {
#line 422
              goto _L;
            }
          }
        } else
        _L: /* CIL Label */ 
#line 424
        if (len <= 0) {
#line 425
          if (fdin != fdout) {
            {
            {
#line 426
            close(fdin);
            }
            }
          } else {
            {
            {
#line 428
            shutdown(fdin, 1);
            }
            }
          }
#line 429
          fdin = -1;
        } else {
#line 432
          if (fdin_is_tty) {
#line 432
            if (dlen >= 1U) {
#line 432
              if ((int )*(data + 0) != 13) {
                {
                {
#line 432
                tmp___0 = tcgetattr(fdin, & tio);
                }
                }
#line 432
                if (tmp___0 == 0) {
#line 432
                  if (! (tio.c_lflag & 8U)) {
#line 432
                    if (tio.c_lflag & 2U) {
                      {
                      {
#line 439
                      packet_send_ignore(len);
                      }
                      {
#line 440
                      packet_send();
                      }
                      }
                    }
                  }
                }
              }
            }
          }
          {
          {
#line 443
          buffer_consume(& stdin_buffer, (u_int )len);
          }
#line 445
          stdin_bytes += (long )len;
          }
        }
      }
    }
  }
#line 449
  if ((writeset->fds_bits[(unsigned long )connection_out / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )connection_out % (8UL * sizeof(__fd_mask )))) != 0L) {
    {
    {
#line 450
    packet_write_poll();
    }
    }
  }
#line 451
  return;
}
}
#line 457 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void drain_output(void) 
{ 
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  u_int tmp___2 ;
  u_int tmp___3 ;
  void *tmp___4 ;
  u_int tmp___5 ;
  u_int tmp___6 ;

  {
  {
  {
#line 461
  tmp___2 = buffer_len(& stdout_buffer);
  }
  }
#line 461
  if (tmp___2 > 0U) {
    {
    {
#line 462
    packet_start((u_char )17);
    }
    {
#line 463
    tmp = buffer_len(& stdout_buffer);
    }
    {
#line 463
    tmp___0 = buffer_ptr(& stdout_buffer);
    }
    {
#line 463
    packet_put_string((void const   *)tmp___0, tmp);
    }
    {
#line 465
    packet_send();
    }
    {
#line 467
    tmp___1 = buffer_len(& stdout_buffer);
    }
#line 467
    stdout_bytes += (long )tmp___1;
    }
  }
  {
  {
#line 470
  tmp___6 = buffer_len(& stderr_buffer);
  }
  }
#line 470
  if (tmp___6 > 0U) {
    {
    {
#line 471
    packet_start((u_char )18);
    }
    {
#line 472
    tmp___3 = buffer_len(& stderr_buffer);
    }
    {
#line 472
    tmp___4 = buffer_ptr(& stderr_buffer);
    }
    {
#line 472
    packet_put_string((void const   *)tmp___4, tmp___3);
    }
    {
#line 474
    packet_send();
    }
    {
#line 476
    tmp___5 = buffer_len(& stderr_buffer);
    }
#line 476
    stderr_bytes += (long )tmp___5;
    }
  }
  {
  {
#line 479
  packet_write_wait();
  }
  }
#line 480
  return;
}
}
#line 482 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void process_buffered_input_packets(void) 
{ 
  Kex *tmp ;

  {
#line 485
  if (compat20) {
#line 485
    tmp = xxx_kex;
  } else {
#line 485
    tmp = (Kex *)((void *)0);
  }
  {
  {
#line 485
  dispatch_run(1, (int *)((void *)0), (void *)tmp);
  }
  }
#line 486
  return;
}
}
#line 495 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
void server_loop(pid_t pid , int fdin_arg , int fdout_arg , int fderr_arg ) 
{ 
  fd_set *readset ;
  fd_set *writeset ;
  int max_fd ;
  u_int nalloc ;
  int wait_status ;
  pid_t wait_pid ;
  int waiting_termination ;
  u_int max_time_milliseconds ;
  u_int previous_stdout_buffer_bytes ;
  u_int stdout_buffer_bytes ;
  int type ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *s ;
  char *cp ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  u_int tmp___7 ;
  u_int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  union __anonunion___u_81___0 __u ;
  union __anonunion___u_82___1 __u___0 ;
  union __anonunion___u_83___1 __u___1 ;
  union __anonunion___u_84___1 __u___2 ;
  union __anonunion___u_85 __u___3 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
#line 498
  readset = (fd_set *)((void *)0);
#line 498
  writeset = (fd_set *)((void *)0);
#line 499
  max_fd = 0;
#line 500
  nalloc = (u_int )0;
#line 503
  waiting_termination = 0;
  {
#line 509
  debug("Entering interactive session.");
  }
#line 512
  child_terminated = (int volatile   )0;
  {
#line 513
  mysignal(17, & sigchld_handler);
  }
  }
#line 515
  if (! use_privsep) {
    {
    {
#line 516
    mysignal(15, & sigterm_handler);
    }
    {
#line 517
    mysignal(2, & sigterm_handler);
    }
    {
#line 518
    mysignal(3, & sigterm_handler);
    }
    }
  }
  {
#line 522
  fdin = fdin_arg;
#line 523
  fdout = fdout_arg;
#line 524
  fderr = fderr_arg;
  {
#line 527
  set_nonblock(fdin);
  }
  {
#line 528
  set_nonblock(fdout);
  }
  }
#line 530
  if (fderr != -1) {
    {
    {
#line 531
    set_nonblock(fderr);
    }
    }
  }
#line 533
  if (! (datafellows & 256)) {
    {
    {
#line 533
    tmp = isatty(fdin);
    }
    }
#line 533
    if (tmp) {
#line 534
      fdin_is_tty = 1;
    }
  }
  {
  {
#line 536
  connection_in = packet_get_connection_in();
  }
  {
#line 537
  connection_out = packet_get_connection_out();
  }
  {
#line 539
  notify_setup();
  }
#line 541
  previous_stdout_buffer_bytes = (u_int )0;
  {
#line 544
  tmp___0 = packet_is_interactive();
  }
  }
#line 544
  if (tmp___0) {
#line 545
    buffer_high = (u_int )4096;
  } else {
#line 547
    buffer_high = (u_int )65536;
  }
  {
  {
#line 559
  buffer_init(& stdin_buffer);
  }
  {
#line 560
  buffer_init(& stdout_buffer);
  }
  {
#line 561
  buffer_init(& stderr_buffer);
  }
  }
#line 569
  if (fderr == -1) {
#line 570
    fderr_eof = 1;
  }
  {
  {
#line 572
  server_init_dispatch();
  }
  }
  {
  {
#line 575
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 578
    process_buffered_input_packets();
    }
    }
#line 584
    if (stdin_eof) {
#line 584
      if (fdin != -1) {
        {
        {
#line 584
        tmp___1 = buffer_len(& stdin_buffer);
        }
        }
#line 584
        if (tmp___1 == 0U) {
#line 585
          if (fdin != fdout) {
            {
            {
#line 586
            close(fdin);
            }
            }
          } else {
            {
            {
#line 588
            shutdown(fdin, 1);
            }
            }
          }
#line 589
          fdin = -1;
        }
      }
    }
    {
    {
#line 592
    make_packets_from_stderr_data();
    }
#line 601
    max_time_milliseconds = (u_int )0;
    {
#line 602
    stdout_buffer_bytes = buffer_len(& stdout_buffer);
    }
    }
#line 603
    if (stdout_buffer_bytes != 0U) {
#line 603
      if (stdout_buffer_bytes < 256U) {
#line 603
        if (stdout_buffer_bytes != previous_stdout_buffer_bytes) {
#line 606
          max_time_milliseconds = (u_int )10;
        } else {
          {
          {
#line 609
          make_packets_from_stdout_data();
          }
          }
        }
      } else {
        {
        {
#line 609
        make_packets_from_stdout_data();
        }
        }
      }
    } else {
      {
      {
#line 609
      make_packets_from_stdout_data();
      }
      }
    }
    {
    {
#line 611
    previous_stdout_buffer_bytes = buffer_len(& stdout_buffer);
    }
    {
#line 614
    tmp___2 = packet_not_very_much_data_to_write();
    }
    }
#line 614
    if (tmp___2) {
      {
      {
#line 615
      channel_output_poll();
      }
      }
    }
#line 622
    if (fdout_eof) {
#line 622
      if (fderr_eof) {
        {
        {
#line 622
        tmp___6 = packet_have_data_to_write();
        }
        }
#line 622
        if (! tmp___6) {
          {
          {
#line 622
          tmp___7 = buffer_len(& stdout_buffer);
          }
          }
#line 622
          if (tmp___7 == 0U) {
            {
            {
#line 622
            tmp___8 = buffer_len(& stderr_buffer);
            }
            }
#line 622
            if (tmp___8 == 0U) {
              {
              {
#line 624
              tmp___3 = channel_still_open();
              }
              }
#line 624
              if (! tmp___3) {
#line 625
                goto while_break;
              }
#line 626
              if (! waiting_termination) {
                {
#line 627
                s = "Waiting for forwarded connections to terminate...\r\n";
#line 629
                waiting_termination = 1;
                {
#line 630
                tmp___4 = strlen(s);
                }
                {
#line 630
                buffer_append(& stderr_buffer, (void const   *)s, tmp___4);
                }
                {
#line 633
                cp = channel_open_message();
                }
                {
#line 634
                tmp___5 = strlen((char const   *)cp);
                }
                {
#line 634
                buffer_append(& stderr_buffer, (void const   *)cp, tmp___5);
                }
                {
#line 635
                xfree((void *)cp);
                }
                }
              }
            }
          }
        }
      }
    }
#line 638
    if (connection_in > connection_out) {
#line 638
      max_fd = connection_in;
    } else {
#line 638
      max_fd = connection_out;
    }
#line 639
    if (max_fd > fdin) {
#line 639
      max_fd = max_fd;
    } else {
#line 639
      max_fd = fdin;
    }
#line 640
    if (max_fd > fdout) {
#line 640
      max_fd = max_fd;
    } else {
#line 640
      max_fd = fdout;
    }
#line 641
    if (max_fd > fderr) {
#line 641
      max_fd = max_fd;
    } else {
#line 641
      max_fd = fderr;
    }
#line 642
    if (max_fd > notify_pipe[0]) {
#line 642
      max_fd = max_fd;
    } else {
#line 642
      max_fd = notify_pipe[0];
    }
    {
    {
#line 645
    wait_until_can_do_something(& readset, & writeset, & max_fd, & nalloc, max_time_milliseconds);
    }
    }
#line 648
    if (received_sigterm) {
      {
      {
#line 649
      logit("Exiting on signal %d", received_sigterm);
      }
      {
#line 651
      cleanup_exit(255);
      }
      }
    }
    {
    {
#line 655
    channel_after_select(readset, writeset);
    }
    {
#line 658
    process_input(readset);
    }
    {
#line 661
    process_output(writeset);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  if (readset) {
    {
    {
#line 664
    xfree((void *)readset);
    }
    }
  }
#line 665
  if (writeset) {
    {
    {
#line 666
    xfree((void *)writeset);
    }
    }
  }
  {
  {
#line 671
  drain_output();
  }
  {
#line 673
  debug("End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes.",
        stdin_bytes, fdout_bytes, stdout_bytes, stderr_bytes);
  }
  {
#line 677
  buffer_free(& stdin_buffer);
  }
  {
#line 678
  buffer_free(& stdout_buffer);
  }
  {
#line 679
  buffer_free(& stderr_buffer);
  }
  }
#line 682
  if (fdout != -1) {
    {
    {
#line 683
    close(fdout);
    }
    }
  }
#line 684
  fdout = -1;
#line 685
  fdout_eof = 1;
#line 686
  if (fderr != -1) {
    {
    {
#line 687
    close(fderr);
    }
    }
  }
#line 688
  fderr = -1;
#line 689
  fderr_eof = 1;
#line 690
  if (fdin != -1) {
    {
    {
#line 691
    close(fdin);
    }
    }
  }
  {
#line 692
  fdin = -1;
  {
#line 694
  channel_free_all();
  }
  {
#line 697
  mysignal(17, (void (*)(int  ))0);
  }
  }
  {
  {
#line 699
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 699
    wait_pid = waitpid(-1, & wait_status, 0);
    }
    }
#line 699
    if (! (wait_pid < 0)) {
#line 699
      goto while_break___0;
    }
    {
    {
#line 700
    tmp___11 = __errno_location();
    }
    }
#line 700
    if (*tmp___11 != 4) {
      {
      {
#line 701
      tmp___9 = __errno_location();
      }
      {
#line 701
      tmp___10 = strerror(*tmp___9);
      }
      {
#line 701
      packet_disconnect("wait: %.100s", tmp___10);
      }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 702
  if (wait_pid != pid) {
    {
    {
#line 703
    error("Strange, wait returned pid %ld, expected %ld", (long )wait_pid, (long )pid);
    }
    }
  }
#line 707
  __u___1.__in = wait_status;
#line 707
  if ((__u___1.__i & 127) == 0) {
    {
#line 709
    __u.__in = wait_status;
    {
#line 709
    debug("Command exited with status %d.", (__u.__i & 65280) >> 8);
    }
    {
#line 710
    packet_start((u_char )20);
    }
#line 711
    __u___0.__in = wait_status;
    {
#line 711
    packet_put_int((u_int )((__u___0.__i & 65280) >> 8));
    }
    {
#line 712
    packet_send();
    }
    {
#line 713
    packet_write_wait();
    }
    }
    {
    {
#line 722
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 723
      type = packet_read();
      }
      }
#line 722
      if (! (type != 33)) {
#line 722
        goto while_break___1;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 727
    debug("Received exit confirmation.");
    }
    }
#line 728
    return;
  }
#line 731
  __u___3.__in = wait_status;
#line 731
  if ((int )((signed char )((__u___3.__i & 127) + 1)) >> 1 > 0) {
    {
#line 733
    __u___2.__in = wait_status;
    {
#line 733
    packet_disconnect("Command terminated on signal %d.", __u___2.__i & 127);
    }
    }
  }
  {
  {
#line 736
  packet_disconnect("wait returned status %04x.", wait_status);
  }
  }
#line 738
  return;
}
}
#line 740 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void collect_children(void) 
{ 
  pid_t pid ;
  sigset_t oset ;
  sigset_t nset ;
  int status ;
  int *tmp ;

  {
  {
  {
#line 748
  sigemptyset(& nset);
  }
  {
#line 749
  sigaddset(& nset, 17);
  }
  {
#line 750
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& nset), (sigset_t */* __restrict  */)(& oset));
  }
  }
#line 751
  if (child_terminated) {
    {
    {
#line 752
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 752
      pid = waitpid(-1, & status, 1);
      }
      }
#line 752
      if (! (pid > 0)) {
#line 752
        if (pid < 0) {
          {
          {
#line 752
          tmp = __errno_location();
          }
          }
#line 752
          if (! (*tmp == 4)) {
#line 752
            goto while_break;
          }
        } else {
#line 752
          goto while_break;
        }
      }
#line 754
      if (pid > 0) {
        {
        {
#line 755
        session_close_by_pid(pid, status);
        }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 756
    child_terminated = (int volatile   )0;
  }
  {
  {
#line 758
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oset), (sigset_t */* __restrict  */)((void *)0));
  }
  }
#line 759
  return;
}
}
#line 761 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
void server_loop2(Authctxt *authctxt___0 ) 
{ 
  fd_set *readset ;
  fd_set *writeset ;
  int rekeying ;
  int max_fd ;
  int nalloc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 764
  readset = (fd_set *)((void *)0);
#line 764
  writeset = (fd_set *)((void *)0);
#line 765
  rekeying = 0;
#line 765
  nalloc = 0;
  {
#line 767
  debug("Entering interactive session for SSH2.");
  }
  {
#line 769
  mysignal(17, & sigchld_handler);
  }
#line 770
  child_terminated = (int volatile   )0;
  {
#line 771
  connection_in = packet_get_connection_in();
  }
  {
#line 772
  connection_out = packet_get_connection_out();
  }
  }
#line 774
  if (! use_privsep) {
    {
    {
#line 775
    mysignal(15, & sigterm_handler);
    }
    {
#line 776
    mysignal(2, & sigterm_handler);
    }
    {
#line 777
    mysignal(3, & sigterm_handler);
    }
    }
  }
  {
  {
#line 780
  notify_setup();
  }
  }
#line 782
  if (connection_in > connection_out) {
#line 782
    max_fd = connection_in;
  } else {
#line 782
    max_fd = connection_out;
  }
#line 783
  if (max_fd > notify_pipe[0]) {
#line 783
    max_fd = max_fd;
  } else {
#line 783
    max_fd = notify_pipe[0];
  }
  {
  {
#line 785
  server_init_dispatch();
  }
  }
  {
  {
#line 787
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 788
    process_buffered_input_packets();
    }
    }
#line 790
    if ((unsigned long )xxx_kex != (unsigned long )((void *)0)) {
#line 790
      if (! xxx_kex->done) {
#line 790
        tmp = 1;
      } else {
#line 790
        tmp = 0;
      }
    } else {
#line 790
      tmp = 0;
    }
#line 790
    rekeying = tmp;
#line 792
    if (! rekeying) {
      {
      {
#line 792
      tmp___0 = packet_not_very_much_data_to_write();
      }
      }
#line 792
      if (tmp___0) {
        {
        {
#line 793
        channel_output_poll();
        }
        }
      }
    }
    {
    {
#line 794
    wait_until_can_do_something(& readset, & writeset, & max_fd, (u_int *)(& nalloc),
                                (u_int )0);
    }
    }
#line 797
    if (received_sigterm) {
      {
      {
#line 798
      logit("Exiting on signal %d", received_sigterm);
      }
      {
#line 800
      cleanup_exit(255);
      }
      }
    }
    {
    {
#line 803
    collect_children();
    }
    }
#line 804
    if (! rekeying) {
      {
      {
#line 805
      channel_after_select(readset, writeset);
      }
      {
#line 806
      tmp___1 = packet_need_rekeying();
      }
      }
#line 806
      if (tmp___1) {
        {
        {
#line 807
        debug("need rekeying");
        }
#line 808
        xxx_kex->done = 0;
        {
#line 809
        kex_send_kexinit(xxx_kex);
        }
        }
      }
    }
    {
    {
#line 812
    process_input(readset);
    }
    }
#line 813
    if (connection_closed) {
#line 814
      goto while_break;
    }
    {
    {
#line 815
    process_output(writeset);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 817
  collect_children();
  }
  }
#line 819
  if (readset) {
    {
    {
#line 820
    xfree((void *)readset);
    }
    }
  }
#line 821
  if (writeset) {
    {
    {
#line 822
    xfree((void *)writeset);
    }
    }
  }
  {
  {
#line 825
  channel_free_all();
  }
  {
#line 828
  session_destroy_all((void (*)(Session * ))((void *)0));
  }
  }
#line 829
  return;
}
}
#line 831 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_keep_alive(int type , u_int32_t seq , void *ctxt ) 
{ 
  char *__cil_tmp4 ;

  {
  {
  {
#line 834
  debug("Got %d/%u for keepalive", type, seq);
  }
#line 840
  client_alive_timeouts = 0;
  }
#line 841
  return;
}
}
#line 843 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_stdin_data(int type , u_int32_t seq , void *ctxt ) 
{ 
  char *data ;
  u_int data_len ;
  void *tmp ;
  int _len ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 851
  if (fdin == -1) {
#line 852
    return;
  }
  {
  {
#line 853
  tmp = packet_get_string(& data_len);
  }
#line 853
  data = (char *)tmp;
  }
  {
  {
#line 854
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 854
    tmp___0 = packet_remaining();
    }
#line 854
    _len = tmp___0;
    }
#line 854
    if (_len > 0) {
      {
      {
#line 854
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c",
            854);
      }
      {
#line 854
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 854
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 855
  buffer_append(& stdin_buffer, (void const   *)data, data_len);
  }
  {
#line 856
  memset((void *)data, 0, data_len);
  }
  {
#line 857
  xfree((void *)data);
  }
  }
#line 858
  return;
}
}
#line 860 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_eof(int type , u_int32_t seq , void *ctxt ) 
{ 
  int _len ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 868
  debug("EOF received for stdin.");
  }
  }
  {
  {
#line 869
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 869
    tmp = packet_remaining();
    }
#line 869
    _len = tmp;
    }
#line 869
    if (_len > 0) {
      {
      {
#line 869
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c",
            869);
      }
      {
#line 869
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 869
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 870
  stdin_eof = 1;
#line 871
  return;
}
}
#line 873 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_window_size(int type , u_int32_t seq , void *ctxt ) 
{ 
  int row ;
  u_int tmp ;
  int col ;
  u_int tmp___0 ;
  int xpixel ;
  u_int tmp___1 ;
  int ypixel ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 876
  tmp = packet_get_int();
  }
#line 876
  row = (int )tmp;
  {
#line 877
  tmp___0 = packet_get_int();
  }
#line 877
  col = (int )tmp___0;
  {
#line 878
  tmp___1 = packet_get_int();
  }
#line 878
  xpixel = (int )tmp___1;
  {
#line 879
  tmp___2 = packet_get_int();
  }
#line 879
  ypixel = (int )tmp___2;
  {
#line 881
  debug("Window change received.");
  }
  }
  {
  {
#line 882
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 882
    tmp___3 = packet_remaining();
    }
#line 882
    _len = tmp___3;
    }
#line 882
    if (_len > 0) {
      {
      {
#line 882
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c",
            882);
      }
      {
#line 882
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 882
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  if (fdin != -1) {
    {
    {
#line 884
    pty_change_window_size(fdin, row, col, xpixel, ypixel);
    }
    }
  }
#line 885
  return;
}
}
#line 887 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static Channel *server_request_direct_tcpip(void) 
{ 
  Channel *c ;
  int sock ;
  char *target ;
  char *originator ;
  int target_port ;
  int originator_port ;
  void *tmp ;
  u_int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  int _len ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 895
  tmp = packet_get_string((u_int *)((void *)0));
  }
#line 895
  target = (char *)tmp;
  {
#line 896
  tmp___0 = packet_get_int();
  }
#line 896
  target_port = (int )tmp___0;
  {
#line 897
  tmp___1 = packet_get_string((u_int *)((void *)0));
  }
#line 897
  originator = (char *)tmp___1;
  {
#line 898
  tmp___2 = packet_get_int();
  }
#line 898
  originator_port = (int )tmp___2;
  }
  {
  {
#line 899
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 899
    tmp___3 = packet_remaining();
    }
#line 899
    _len = tmp___3;
    }
#line 899
    if (_len > 0) {
      {
      {
#line 899
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c",
            899);
      }
      {
#line 899
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 899
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 901
  debug("server_request_direct_tcpip: originator %s port %d, target %s port %d", originator,
        originator_port, target, target_port);
  }
  {
#line 905
  sock = channel_connect_to((char const   *)target, (u_short )target_port);
  }
  {
#line 906
  xfree((void *)target);
  }
  {
#line 907
  xfree((void *)originator);
  }
  }
#line 908
  if (sock < 0) {
#line 909
    return ((Channel *)((void *)0));
  }
  {
  {
#line 910
  c = channel_new((char *)"direct-tcpip", 12, sock, sock, -1, (u_int )131072, (u_int )32768,
                  0, (char *)"direct-tcpip", 1);
  }
  }
#line 913
  return (c);
}
}
#line 916 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static Channel *server_request_tun(void) 
{ 
  Channel *c ;
  int mode ;
  int tun ;
  int sock ;
  u_int tmp ;
  u_int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 919
  c = (Channel *)((void *)0);
  {
#line 923
  tmp = packet_get_int();
  }
#line 923
  mode = (int )tmp;
  }
  {
#line 926
  if (mode == 2) {
#line 926
    goto case_2;
  }
#line 926
  if (mode == 1) {
#line 926
    goto case_2;
  }
#line 928
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 927
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 929
  packet_send_debug("Unsupported tunnel device mode.");
  }
  }
#line 930
  return ((Channel *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 932
  if ((options.permit_tun & mode) == 0) {
    {
    {
#line 933
    packet_send_debug("Server has rejected tunnel device forwarding");
    }
    }
#line 935
    return ((Channel *)((void *)0));
  }
  {
  {
#line 938
  tmp___0 = packet_get_int();
  }
#line 938
  tun = (int )tmp___0;
  }
#line 939
  if (forced_tun_device != -1) {
#line 940
    if (tun != 2147483647) {
#line 940
      if (forced_tun_device != tun) {
#line 941
        goto done;
      }
    }
#line 942
    tun = forced_tun_device;
  }
  {
  {
#line 944
  sock = tun_open(tun, mode);
  }
  }
#line 945
  if (sock < 0) {
#line 946
    goto done;
  }
  {
  {
#line 947
  c = channel_new((char *)"tun", 4, sock, sock, -1, (u_int )131072, (u_int )32768,
                  0, (char *)"tun", 1);
  }
#line 949
  c->datagram = 1;
  }
#line 951
  if (mode == 1) {
    {
    {
#line 952
    channel_register_filter(c->self, & sys_tun_infilter, & sys_tun_outfilter);
    }
    }
  }
  done: 
#line 957
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
    {
#line 958
    packet_send_debug("Failed to open the tunnel device.");
    }
    }
  }
#line 959
  return (c);
}
}
#line 962 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static Channel *server_request_session(void) 
{ 
  Channel *c ;
  int _len ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 967
  debug("input_session_request");
  }
  }
  {
  {
#line 968
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 968
    tmp = packet_remaining();
    }
#line 968
    _len = tmp;
    }
#line 968
    if (_len > 0) {
      {
      {
#line 968
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c",
            968);
      }
      {
#line 968
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 968
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 975
  c = channel_new((char *)"session", 10, -1, -1, -1, (u_int )0, (u_int )32768, 0,
                  (char *)"server-session", 1);
  }
  {
#line 978
  tmp___0 = session_open(the_authctxt, c->self);
  }
  }
#line 978
  if (tmp___0 != 1) {
    {
    {
#line 979
    debug("session open failed, free channel %d", c->self);
    }
    {
#line 980
    channel_free(c);
    }
    }
#line 981
    return ((Channel *)((void *)0));
  }
  {
  {
#line 983
  channel_register_cleanup(c->self, & session_close_by_channel, 0);
  }
  }
#line 984
  return (c);
}
}
#line 987 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_channel_open(int type , u_int32_t seq , void *ctxt ) 
{ 
  Channel *c ;
  char *ctype ;
  int rchan ;
  u_int rmaxpack ;
  u_int rwindow ;
  u_int len ;
  void *tmp ;
  u_int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 990
  c = (Channel *)((void *)0);
  {
#line 995
  tmp = packet_get_string(& len);
  }
#line 995
  ctype = (char *)tmp;
  {
#line 996
  tmp___0 = packet_get_int();
  }
#line 996
  rchan = (int )tmp___0;
  {
#line 997
  rwindow = packet_get_int();
  }
  {
#line 998
  rmaxpack = packet_get_int();
  }
  {
#line 1000
  debug("server_input_channel_open: ctype %s rchan %d win %d max %d", ctype, rchan,
        rwindow, rmaxpack);
  }
  {
#line 1003
  tmp___3 = strcmp((char const   *)ctype, "session");
  }
  }
#line 1003
  if (tmp___3 == 0) {
    {
    {
#line 1004
    c = server_request_session();
    }
    }
  } else {
    {
    {
#line 1005
    tmp___2 = strcmp((char const   *)ctype, "direct-tcpip");
    }
    }
#line 1005
    if (tmp___2 == 0) {
      {
      {
#line 1006
      c = server_request_direct_tcpip();
      }
      }
    } else {
      {
      {
#line 1007
      tmp___1 = strcmp((char const   *)ctype, "tun@openssh.com");
      }
      }
#line 1007
      if (tmp___1 == 0) {
        {
        {
#line 1008
        c = server_request_tun();
        }
        }
      }
    }
  }
#line 1010
  if ((unsigned long )c != (unsigned long )((void *)0)) {
    {
    {
#line 1011
    debug("server_input_channel_open: confirm %s", ctype);
    }
#line 1012
    c->remote_id = rchan;
#line 1013
    c->remote_window = rwindow;
#line 1014
    c->remote_maxpacket = rmaxpack;
    }
#line 1015
    if (c->type != 12) {
      {
      {
#line 1016
      packet_start((u_char )91);
      }
      {
#line 1017
      packet_put_int((u_int )c->remote_id);
      }
      {
#line 1018
      packet_put_int((u_int )c->self);
      }
      {
#line 1019
      packet_put_int(c->local_window);
      }
      {
#line 1020
      packet_put_int(c->local_maxpacket);
      }
      {
#line 1021
      packet_send();
      }
      }
    }
  } else {
    {
    {
#line 1024
    debug("server_input_channel_open: failure %s", ctype);
    }
    {
#line 1025
    packet_start((u_char )92);
    }
    {
#line 1026
    packet_put_int((u_int )rchan);
    }
    {
#line 1027
    packet_put_int((u_int )1);
    }
    }
#line 1028
    if (! (datafellows & 131072)) {
      {
      {
#line 1029
      packet_put_cstring("open failed");
      }
      {
#line 1030
      packet_put_cstring("");
      }
      }
    }
    {
    {
#line 1032
    packet_send();
    }
    }
  }
  {
  {
#line 1034
  xfree((void *)ctype);
  }
  }
#line 1035
  return;
}
}
#line 1037 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_global_request(int type , u_int32_t seq , void *ctxt ) 
{ 
  char *rtype ;
  int want_reply ;
  int success ;
  void *tmp ;
  u_int tmp___0 ;
  struct passwd *pw ;
  char *listen_address ;
  u_short listen_port ;
  void *tmp___1 ;
  u_int tmp___2 ;
  char *cancel_address ;
  u_short cancel_port ;
  void *tmp___3 ;
  u_int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 1042
  success = 0;
  {
#line 1044
  tmp = packet_get_string((u_int *)((void *)0));
  }
#line 1044
  rtype = (char *)tmp;
  {
#line 1045
  tmp___0 = packet_get_char();
  }
#line 1045
  want_reply = (int )tmp___0;
  {
#line 1046
  debug("server_input_global_request: rtype %s want_reply %d", rtype, want_reply);
  }
  {
#line 1049
  tmp___6 = strcmp((char const   *)rtype, "tcpip-forward");
  }
  }
#line 1049
  if (tmp___6 == 0) {
#line 1054
    pw = the_authctxt->pw;
#line 1055
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
      {
#line 1056
      fatal("server_input_global_request: no/invalid user");
      }
      }
    } else
#line 1055
    if (! the_authctxt->valid) {
      {
      {
#line 1056
      fatal("server_input_global_request: no/invalid user");
      }
      }
    }
    {
    {
#line 1057
    tmp___1 = packet_get_string((u_int *)((void *)0));
    }
#line 1057
    listen_address = (char *)tmp___1;
    {
#line 1058
    tmp___2 = packet_get_int();
    }
#line 1058
    listen_port = (u_short )tmp___2;
    {
#line 1059
    debug("server_input_global_request: tcpip-forward listen %s port %d", listen_address,
          (int )listen_port);
    }
    }
#line 1063
    if (! options.allow_tcp_forwarding) {
      {
#line 1069
      success = 0;
      {
#line 1070
      packet_send_debug("Server has disabled port forwarding.");
      }
      }
    } else
#line 1063
    if (no_port_forwarding_flag) {
      {
#line 1069
      success = 0;
      {
#line 1070
      packet_send_debug("Server has disabled port forwarding.");
      }
      }
    } else
#line 1063
    if ((int )listen_port < 1024) {
#line 1063
      if (pw->pw_uid != 0U) {
        {
#line 1069
        success = 0;
        {
#line 1070
        packet_send_debug("Server has disabled port forwarding.");
        }
        }
      } else {
        {
        {
#line 1073
        success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                    listen_port, options.gateway_ports);
        }
        }
      }
    } else {
      {
      {
#line 1073
      success = channel_setup_remote_fwd_listener((char const   *)listen_address,
                                                  listen_port, options.gateway_ports);
      }
      }
    }
    {
    {
#line 1076
    xfree((void *)listen_address);
    }
    }
  } else {
    {
    {
#line 1077
    tmp___5 = strcmp((char const   *)rtype, "cancel-tcpip-forward");
    }
    }
#line 1077
    if (tmp___5 == 0) {
      {
      {
#line 1081
      tmp___3 = packet_get_string((u_int *)((void *)0));
      }
#line 1081
      cancel_address = (char *)tmp___3;
      {
#line 1082
      tmp___4 = packet_get_int();
      }
#line 1082
      cancel_port = (u_short )tmp___4;
      {
#line 1083
      debug("%s: cancel-tcpip-forward addr %s port %d", "server_input_global_request",
            cancel_address, (int )cancel_port);
      }
      {
#line 1086
      success = channel_cancel_rport_listener((char const   *)cancel_address, cancel_port);
      }
      }
    }
  }
#line 1089
  if (want_reply) {
#line 1090
    if (success) {
#line 1090
      tmp___7 = 81;
    } else {
#line 1090
      tmp___7 = 82;
    }
    {
    {
#line 1090
    packet_start((u_char )tmp___7);
    }
    {
#line 1092
    packet_send();
    }
    {
#line 1093
    packet_write_wait();
    }
    }
  }
  {
  {
#line 1095
  xfree((void *)rtype);
  }
  }
#line 1096
  return;
}
}
#line 1097 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_input_channel_req(int type , u_int32_t seq , void *ctxt ) 
{ 
  Channel *c ;
  int id ;
  int reply ;
  int success ;
  char *rtype ;
  u_int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1101
  success = 0;
  {
#line 1104
  tmp = packet_get_int();
  }
#line 1104
  id = (int )tmp;
  {
#line 1105
  tmp___0 = packet_get_string((u_int *)((void *)0));
  }
#line 1105
  rtype = (char *)tmp___0;
  {
#line 1106
  tmp___1 = packet_get_char();
  }
#line 1106
  reply = (int )tmp___1;
  {
#line 1108
  debug("server_input_channel_req: channel %d request %s reply %d", id, rtype, reply);
  }
  {
#line 1111
  c = channel_lookup(id);
  }
  }
#line 1111
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
    {
#line 1112
    packet_disconnect("server_input_channel_req: unknown channel %d", id);
    }
    }
  }
#line 1114
  if (c->type == 10) {
    {
    {
#line 1115
    success = session_input_channel_req(c, (char const   *)rtype);
    }
    }
  } else
#line 1114
  if (c->type == 4) {
    {
    {
#line 1115
    success = session_input_channel_req(c, (char const   *)rtype);
    }
    }
  }
#line 1116
  if (reply) {
#line 1117
    if (success) {
#line 1117
      tmp___2 = 99;
    } else {
#line 1117
      tmp___2 = 100;
    }
    {
    {
#line 1117
    packet_start((u_char )tmp___2);
    }
    {
#line 1119
    packet_put_int((u_int )c->remote_id);
    }
    {
#line 1120
    packet_send();
    }
    }
  }
  {
  {
#line 1122
  xfree((void *)rtype);
  }
  }
#line 1123
  return;
}
}
#line 1125 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_init_dispatch_20(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 1128
  debug("server_init_dispatch_20");
  }
  {
#line 1129
  dispatch_init(& dispatch_protocol_error);
  }
  {
#line 1130
  dispatch_set(97, & channel_input_oclose);
  }
  {
#line 1131
  dispatch_set(94, & channel_input_data);
  }
  {
#line 1132
  dispatch_set(96, & channel_input_ieof);
  }
  {
#line 1133
  dispatch_set(95, & channel_input_extended_data);
  }
  {
#line 1134
  dispatch_set(90, & server_input_channel_open);
  }
  {
#line 1135
  dispatch_set(91, & channel_input_open_confirmation);
  }
  {
#line 1136
  dispatch_set(92, & channel_input_open_failure);
  }
  {
#line 1137
  dispatch_set(98, & server_input_channel_req);
  }
  {
#line 1138
  dispatch_set(93, & channel_input_window_adjust);
  }
  {
#line 1139
  dispatch_set(80, & server_input_global_request);
  }
  {
#line 1141
  dispatch_set(100, & server_input_keep_alive);
  }
  {
#line 1142
  dispatch_set(81, & server_input_keep_alive);
  }
  {
#line 1143
  dispatch_set(82, & server_input_keep_alive);
  }
  {
#line 1145
  dispatch_set(20, & kex_input_kexinit);
  }
  }
#line 1146
  return;
}
}
#line 1147 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_init_dispatch_13(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 1150
  debug("server_init_dispatch_13");
  }
  {
#line 1151
  dispatch_init((dispatch_fn *)((void *)0));
  }
  {
#line 1152
  dispatch_set(19, & server_input_eof);
  }
  {
#line 1153
  dispatch_set(16, & server_input_stdin_data);
  }
  {
#line 1154
  dispatch_set(11, & server_input_window_size);
  }
  {
#line 1155
  dispatch_set(24, & channel_input_close);
  }
  {
#line 1156
  dispatch_set(25, & channel_input_close_confirmation);
  }
  {
#line 1157
  dispatch_set(23, & channel_input_data);
  }
  {
#line 1158
  dispatch_set(21, & channel_input_open_confirmation);
  }
  {
#line 1159
  dispatch_set(22, & channel_input_open_failure);
  }
  {
#line 1160
  dispatch_set(29, & channel_input_port_open);
  }
  }
#line 1161
  return;
}
}
#line 1162 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_init_dispatch_15(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 1165
  server_init_dispatch_13();
  }
  {
#line 1166
  debug("server_init_dispatch_15");
  }
  {
#line 1167
  dispatch_set(24, & channel_input_ieof);
  }
  {
#line 1168
  dispatch_set(25, & channel_input_oclose);
  }
  }
#line 1169
  return;
}
}
#line 1170 "/home/pronto/abs/test-suite/openssh-4.3p2/serverloop.c"
static void server_init_dispatch(void) 
{ 


  {
#line 1173
  if (compat20) {
    {
    {
#line 1174
    server_init_dispatch_20();
    }
    }
  } else
#line 1175
  if (compat13) {
    {
    {
#line 1176
    server_init_dispatch_13();
    }
    }
  } else {
    {
    {
#line 1178
    server_init_dispatch_15();
    }
    }
  }
#line 1179
  return;
}
}
#line 411 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 188 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 354
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
#line 631 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 640
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 53 "/home/pronto/abs/test-suite/openssh-4.3p2/log.h"
extern SyslogFacility log_facility_number(char * ) ;
#line 54
extern LogLevel log_level_number(char * ) ;
#line 142 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.h"
void initialize_server_options(ServerOptions *options___0 ) ;
#line 143
void fill_default_server_options(ServerOptions *options___0 ) ;
#line 144
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) ;
#line 145
void load_server_config(char const   *filename , Buffer *conf ) ;
#line 146
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ) ;
#line 63 "/home/pronto/abs/test-suite/openssh-4.3p2/compat.h"
extern int proto_spec(char const   * ) ;
#line 18 "/home/pronto/abs/test-suite/openssh-4.3p2/misc.h"
extern char *strdelim(char ** ) ;
#line 27
extern long convtime(char const   * ) ;
#line 76 "/home/pronto/abs/test-suite/openssh-4.3p2/cipher.h"
extern int ciphers_valid(char const   * ) ;
#line 26 "/home/pronto/abs/test-suite/openssh-4.3p2/mac.h"
extern int mac_valid(char const   * ) ;
#line 26 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 27
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) ;
#line 34 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
void initialize_server_options(ServerOptions *options___0 ) 
{ 


  {
  {
  {
#line 37
  memset((void *)options___0, 0, (size_t )sizeof(*options___0));
  }
#line 40
  options___0->use_pam = -1;
#line 43
  options___0->num_ports = (u_int )0;
#line 44
  options___0->ports_from_cmdline = (u_int )0;
#line 45
  options___0->listen_addrs = (struct addrinfo *)((void *)0);
#line 46
  options___0->address_family = -1;
#line 47
  options___0->num_host_key_files = 0;
#line 48
  options___0->pid_file = (char *)((void *)0);
#line 49
  options___0->server_key_bits = -1;
#line 50
  options___0->login_grace_time = -1;
#line 51
  options___0->key_regeneration_time = -1;
#line 52
  options___0->permit_root_login = -1;
#line 53
  options___0->ignore_rhosts = -1;
#line 54
  options___0->ignore_user_known_hosts = -1;
#line 55
  options___0->print_motd = -1;
#line 56
  options___0->print_lastlog = -1;
#line 57
  options___0->x11_forwarding = -1;
#line 58
  options___0->x11_display_offset = -1;
#line 59
  options___0->x11_use_localhost = -1;
#line 60
  options___0->xauth_location = (char *)((void *)0);
#line 61
  options___0->strict_modes = -1;
#line 62
  options___0->tcp_keep_alive = -1;
#line 63
  options___0->log_facility = (SyslogFacility )-1;
#line 64
  options___0->log_level = (LogLevel )-1;
#line 65
  options___0->rhosts_rsa_authentication = -1;
#line 66
  options___0->hostbased_authentication = -1;
#line 67
  options___0->hostbased_uses_name_from_packet_only = -1;
#line 68
  options___0->rsa_authentication = -1;
#line 69
  options___0->pubkey_authentication = -1;
#line 70
  options___0->kerberos_authentication = -1;
#line 71
  options___0->kerberos_or_local_passwd = -1;
#line 72
  options___0->kerberos_ticket_cleanup = -1;
#line 73
  options___0->kerberos_get_afs_token = -1;
#line 74
  options___0->gss_authentication = -1;
#line 75
  options___0->gss_cleanup_creds = -1;
#line 76
  options___0->password_authentication = -1;
#line 77
  options___0->kbd_interactive_authentication = -1;
#line 78
  options___0->challenge_response_authentication = -1;
#line 79
  options___0->permit_empty_passwd = -1;
#line 80
  options___0->permit_user_env = -1;
#line 81
  options___0->use_login = -1;
#line 82
  options___0->compression = -1;
#line 83
  options___0->allow_tcp_forwarding = -1;
#line 84
  options___0->num_allow_users = (u_int )0;
#line 85
  options___0->num_deny_users = (u_int )0;
#line 86
  options___0->num_allow_groups = (u_int )0;
#line 87
  options___0->num_deny_groups = (u_int )0;
#line 88
  options___0->ciphers = (char *)((void *)0);
#line 89
  options___0->macs = (char *)((void *)0);
#line 90
  options___0->protocol = 0;
#line 91
  options___0->gateway_ports = -1;
#line 92
  options___0->num_subsystems = (u_int )0;
#line 93
  options___0->max_startups_begin = -1;
#line 94
  options___0->max_startups_rate = -1;
#line 95
  options___0->max_startups = -1;
#line 96
  options___0->max_authtries = -1;
#line 97
  options___0->banner = (char *)((void *)0);
#line 98
  options___0->use_dns = -1;
#line 99
  options___0->client_alive_interval = -1;
#line 100
  options___0->client_alive_count_max = -1;
#line 101
  options___0->authorized_keys_file = (char *)((void *)0);
#line 102
  options___0->authorized_keys_file2 = (char *)((void *)0);
#line 103
  options___0->num_accept_env = (u_int )0;
#line 104
  options___0->permit_tun = -1;
#line 107
  use_privsep = -1;
  }
#line 108
  return;
}
}
#line 110 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
void fill_default_server_options(ServerOptions *options___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 114
  if (options___0->use_pam == -1) {
#line 115
    options___0->use_pam = 0;
  }
#line 118
  if (options___0->protocol == 0) {
#line 119
    options___0->protocol = 5;
  }
#line 120
  if (options___0->num_host_key_files == 0) {
#line 122
    if (options___0->protocol & 1) {
#line 123
      tmp = options___0->num_host_key_files;
#line 123
      (options___0->num_host_key_files) ++;
#line 123
      options___0->host_key_files[tmp] = (char *)"/usr/local/etc/ssh_host_key";
    }
#line 125
    if (options___0->protocol & 4) {
#line 126
      tmp___0 = options___0->num_host_key_files;
#line 126
      (options___0->num_host_key_files) ++;
#line 126
      options___0->host_key_files[tmp___0] = (char *)"/usr/local/etc/ssh_host_rsa_key";
#line 128
      tmp___1 = options___0->num_host_key_files;
#line 128
      (options___0->num_host_key_files) ++;
#line 128
      options___0->host_key_files[tmp___1] = (char *)"/usr/local/etc/ssh_host_dsa_key";
    }
  }
#line 132
  if (options___0->num_ports == 0U) {
#line 133
    tmp___2 = options___0->num_ports;
#line 133
    (options___0->num_ports) ++;
#line 133
    options___0->ports[tmp___2] = (u_short )22;
  }
#line 134
  if ((unsigned long )options___0->listen_addrs == (unsigned long )((void *)0)) {
    {
    {
#line 135
    add_listen_addr(options___0, (char *)((void *)0), (u_short )0);
    }
    }
  }
#line 136
  if ((unsigned long )options___0->pid_file == (unsigned long )((void *)0)) {
#line 137
    options___0->pid_file = (char *)"/var/run/sshd.pid";
  }
#line 138
  if (options___0->server_key_bits == -1) {
#line 139
    options___0->server_key_bits = 768;
  }
#line 140
  if (options___0->login_grace_time == -1) {
#line 141
    options___0->login_grace_time = 120;
  }
#line 142
  if (options___0->key_regeneration_time == -1) {
#line 143
    options___0->key_regeneration_time = 3600;
  }
#line 144
  if (options___0->permit_root_login == -1) {
#line 145
    options___0->permit_root_login = 3;
  }
#line 146
  if (options___0->ignore_rhosts == -1) {
#line 147
    options___0->ignore_rhosts = 1;
  }
#line 148
  if (options___0->ignore_user_known_hosts == -1) {
#line 149
    options___0->ignore_user_known_hosts = 0;
  }
#line 150
  if (options___0->print_motd == -1) {
#line 151
    options___0->print_motd = 1;
  }
#line 152
  if (options___0->print_lastlog == -1) {
#line 153
    options___0->print_lastlog = 1;
  }
#line 154
  if (options___0->x11_forwarding == -1) {
#line 155
    options___0->x11_forwarding = 0;
  }
#line 156
  if (options___0->x11_display_offset == -1) {
#line 157
    options___0->x11_display_offset = 10;
  }
#line 158
  if (options___0->x11_use_localhost == -1) {
#line 159
    options___0->x11_use_localhost = 1;
  }
#line 160
  if ((unsigned long )options___0->xauth_location == (unsigned long )((void *)0)) {
#line 161
    options___0->xauth_location = (char *)"/usr/bin/xauth";
  }
#line 162
  if (options___0->strict_modes == -1) {
#line 163
    options___0->strict_modes = 1;
  }
#line 164
  if (options___0->tcp_keep_alive == -1) {
#line 165
    options___0->tcp_keep_alive = 1;
  }
#line 166
  if ((int )options___0->log_facility == -1) {
#line 167
    options___0->log_facility = (SyslogFacility )2;
  }
#line 168
  if ((int )options___0->log_level == -1) {
#line 169
    options___0->log_level = (LogLevel )3;
  }
#line 170
  if (options___0->rhosts_rsa_authentication == -1) {
#line 171
    options___0->rhosts_rsa_authentication = 0;
  }
#line 172
  if (options___0->hostbased_authentication == -1) {
#line 173
    options___0->hostbased_authentication = 0;
  }
#line 174
  if (options___0->hostbased_uses_name_from_packet_only == -1) {
#line 175
    options___0->hostbased_uses_name_from_packet_only = 0;
  }
#line 176
  if (options___0->rsa_authentication == -1) {
#line 177
    options___0->rsa_authentication = 1;
  }
#line 178
  if (options___0->pubkey_authentication == -1) {
#line 179
    options___0->pubkey_authentication = 1;
  }
#line 180
  if (options___0->kerberos_authentication == -1) {
#line 181
    options___0->kerberos_authentication = 0;
  }
#line 182
  if (options___0->kerberos_or_local_passwd == -1) {
#line 183
    options___0->kerberos_or_local_passwd = 1;
  }
#line 184
  if (options___0->kerberos_ticket_cleanup == -1) {
#line 185
    options___0->kerberos_ticket_cleanup = 1;
  }
#line 186
  if (options___0->kerberos_get_afs_token == -1) {
#line 187
    options___0->kerberos_get_afs_token = 0;
  }
#line 188
  if (options___0->gss_authentication == -1) {
#line 189
    options___0->gss_authentication = 0;
  }
#line 190
  if (options___0->gss_cleanup_creds == -1) {
#line 191
    options___0->gss_cleanup_creds = 1;
  }
#line 192
  if (options___0->password_authentication == -1) {
#line 193
    options___0->password_authentication = 1;
  }
#line 194
  if (options___0->kbd_interactive_authentication == -1) {
#line 195
    options___0->kbd_interactive_authentication = 0;
  }
#line 196
  if (options___0->challenge_response_authentication == -1) {
#line 197
    options___0->challenge_response_authentication = 1;
  }
#line 198
  if (options___0->permit_empty_passwd == -1) {
#line 199
    options___0->permit_empty_passwd = 0;
  }
#line 200
  if (options___0->permit_user_env == -1) {
#line 201
    options___0->permit_user_env = 0;
  }
#line 202
  if (options___0->use_login == -1) {
#line 203
    options___0->use_login = 0;
  }
#line 204
  if (options___0->compression == -1) {
#line 205
    options___0->compression = 2;
  }
#line 206
  if (options___0->allow_tcp_forwarding == -1) {
#line 207
    options___0->allow_tcp_forwarding = 1;
  }
#line 208
  if (options___0->gateway_ports == -1) {
#line 209
    options___0->gateway_ports = 0;
  }
#line 210
  if (options___0->max_startups == -1) {
#line 211
    options___0->max_startups = 10;
  }
#line 212
  if (options___0->max_startups_rate == -1) {
#line 213
    options___0->max_startups_rate = 100;
  }
#line 214
  if (options___0->max_startups_begin == -1) {
#line 215
    options___0->max_startups_begin = options___0->max_startups;
  }
#line 216
  if (options___0->max_authtries == -1) {
#line 217
    options___0->max_authtries = 6;
  }
#line 218
  if (options___0->use_dns == -1) {
#line 219
    options___0->use_dns = 1;
  }
#line 220
  if (options___0->client_alive_interval == -1) {
#line 221
    options___0->client_alive_interval = 0;
  }
#line 222
  if (options___0->client_alive_count_max == -1) {
#line 223
    options___0->client_alive_count_max = 3;
  }
#line 224
  if ((unsigned long )options___0->authorized_keys_file2 == (unsigned long )((void *)0)) {
#line 226
    if ((unsigned long )options___0->authorized_keys_file != (unsigned long )((void *)0)) {
#line 227
      options___0->authorized_keys_file2 = options___0->authorized_keys_file;
    } else {
#line 229
      options___0->authorized_keys_file2 = (char *)".ssh/authorized_keys2";
    }
  }
#line 231
  if ((unsigned long )options___0->authorized_keys_file == (unsigned long )((void *)0)) {
#line 232
    options___0->authorized_keys_file = (char *)".ssh/authorized_keys";
  }
#line 233
  if (options___0->permit_tun == -1) {
#line 234
    options___0->permit_tun = 0;
  }
#line 237
  if (use_privsep == -1) {
#line 238
    use_privsep = 1;
  }
#line 249
  return;
}
}
#line 282 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
static struct __anonstruct_keywords_79 keywords[73]  = 
#line 282
  {      {"usepam", (ServerOpCodes )64}, 
        {"pamauthenticationviakbdint", (ServerOpCodes )63}, 
        {"port", (ServerOpCodes )2}, 
        {"hostkey", (ServerOpCodes )3}, 
        {"hostdsakey", (ServerOpCodes )3}, 
        {"pidfile", (ServerOpCodes )43}, 
        {"serverkeybits", (ServerOpCodes )4}, 
        {"logingracetime", (ServerOpCodes )5}, 
        {"keyregenerationinterval", (ServerOpCodes )6}, 
        {"permitrootlogin", (ServerOpCodes )7}, 
        {"syslogfacility", (ServerOpCodes )8}, 
        {"loglevel", (ServerOpCodes )9}, 
        {"rhostsauthentication", (ServerOpCodes )63}, 
        {"rhostsrsaauthentication", (ServerOpCodes )10}, 
        {"hostbasedauthentication", (ServerOpCodes )52}, 
        {"hostbasedusesnamefrompacketonly", (ServerOpCodes )53}, 
        {"rsaauthentication", (ServerOpCodes )11}, 
        {"pubkeyauthentication", (ServerOpCodes )45}, 
        {"dsaauthentication", (ServerOpCodes )45}, 
        {"kerberosauthentication", (ServerOpCodes )64}, 
        {"kerberosorlocalpasswd", (ServerOpCodes )64}, 
        {"kerberosticketcleanup", (ServerOpCodes )64}, 
        {"kerberosgetafstoken", (ServerOpCodes )64}, 
        {"kerberostgtpassing", (ServerOpCodes )64}, 
        {"afstokenpassing", (ServerOpCodes )64}, 
        {"gssapiauthentication", (ServerOpCodes )64}, 
        {"gssapicleanupcredentials", (ServerOpCodes )64}, 
        {"passwordauthentication", (ServerOpCodes )18}, 
        {"kbdinteractiveauthentication", (ServerOpCodes )19}, 
        {"challengeresponseauthentication", (ServerOpCodes )17}, 
        {"skeyauthentication", (ServerOpCodes )17}, 
        {"checkmail", (ServerOpCodes )63}, 
        {"listenaddress", (ServerOpCodes )20}, 
        {"addressfamily", (ServerOpCodes )21}, 
        {"printmotd", (ServerOpCodes )22}, 
        {"printlastlog", (ServerOpCodes )23}, 
        {"ignorerhosts", (ServerOpCodes )24}, 
        {"ignoreuserknownhosts", (ServerOpCodes )39}, 
        {"x11forwarding", (ServerOpCodes )25}, 
        {"x11displayoffset", (ServerOpCodes )26}, 
        {"x11uselocalhost", (ServerOpCodes )27}, 
        {"xauthlocation", (ServerOpCodes )46}, 
        {"strictmodes", (ServerOpCodes )28}, 
        {"permitemptypasswords", (ServerOpCodes )29}, 
        {"permituserenvironment", (ServerOpCodes )31}, 
        {"uselogin", (ServerOpCodes )32}, 
        {"compression", (ServerOpCodes )34}, 
        {"tcpkeepalive", (ServerOpCodes )30}, 
        {"keepalive", (ServerOpCodes )30}, 
        {"allowtcpforwarding", (ServerOpCodes )33}, 
        {"allowusers", (ServerOpCodes )35}, 
        {"denyusers", (ServerOpCodes )36}, 
        {"allowgroups", (ServerOpCodes )37}, 
        {"denygroups", (ServerOpCodes )38}, 
        {"ciphers", (ServerOpCodes )40}, 
        {"macs", (ServerOpCodes )41}, 
        {"protocol", (ServerOpCodes )42}, 
        {"gatewayports", (ServerOpCodes )44}, 
        {"subsystem", (ServerOpCodes )47}, 
        {"maxstartups", (ServerOpCodes )48}, 
        {"maxauthtries", (ServerOpCodes )49}, 
        {"banner", (ServerOpCodes )50}, 
        {"usedns", (ServerOpCodes )51}, 
        {"verifyreversemapping", (ServerOpCodes )63}, 
        {"reversemappingcheck", (ServerOpCodes )63}, 
        {"clientaliveinterval", (ServerOpCodes )54}, 
        {"clientalivecountmax", (ServerOpCodes )55}, 
        {"authorizedkeysfile", (ServerOpCodes )56}, 
        {"authorizedkeysfile2", (ServerOpCodes )57}, 
        {"useprivilegeseparation", (ServerOpCodes )62}, 
        {"acceptenv", (ServerOpCodes )60}, 
        {"permittunnel", (ServerOpCodes )61}, 
        {(char const   *)((void *)0), (ServerOpCodes )0}};
#line 387 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
static ServerOpCodes parse_token(char const   *cp , char const   *filename , int linenum ) 
{ 
  u_int i ;
  int tmp ;
  char *__cil_tmp6 ;

  {
#line 393
  i = (u_int )0;
  {
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 393
    if (! keywords[i].name) {
#line 393
      goto while_break;
    }
    {
    {
#line 394
    tmp = strcasecmp(cp, keywords[i].name);
    }
    }
#line 394
    if (tmp == 0) {
#line 395
      return (keywords[i].opcode);
    }
#line 393
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 397
  error("%s: line %d: Bad configuration option: %s", filename, linenum, cp);
  }
  }
#line 399
  return ((ServerOpCodes )0);
}
}
#line 402 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
static void add_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ 
  u_int i ;
  u_int tmp ;

  {
#line 407
  if (options___0->num_ports == 0U) {
#line 408
    tmp = options___0->num_ports;
#line 408
    (options___0->num_ports) ++;
#line 408
    options___0->ports[tmp] = (u_short )22;
  }
#line 409
  if (options___0->address_family == -1) {
#line 410
    options___0->address_family = 0;
  }
#line 411
  if ((int )port == 0) {
#line 412
    i = (u_int )0;
    {
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 412
      if (! (i < options___0->num_ports)) {
#line 412
        goto while_break;
      }
      {
      {
#line 413
      add_one_listen_addr(options___0, addr, options___0->ports[i]);
      }
#line 412
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 415
    add_one_listen_addr(options___0, addr, port);
    }
    }
  }
#line 416
  return;
}
}
#line 418 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
static void add_one_listen_addr(ServerOptions *options___0 , char *addr , u_short port ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *ai ;
  struct addrinfo *aitop ;
  char strport[32] ;
  int gaierr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 425
  memset((void *)(& hints), 0, (size_t )sizeof(hints));
  }
#line 426
  hints.ai_family = options___0->address_family;
#line 427
  hints.ai_socktype = 1;
  }
#line 428
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 428
    hints.ai_flags = 1;
  } else {
#line 428
    hints.ai_flags = 0;
  }
  {
  {
#line 429
  snprintf((char */* __restrict  */)(strport), (size_t )sizeof(strport), (char const   */* __restrict  */)"%u",
           (int )port);
  }
  {
#line 430
  gaierr = getaddrinfo((char const   */* __restrict  */)addr, (char const   */* __restrict  */)(strport),
                       (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& aitop));
  }
  }
#line 430
  if (gaierr != 0) {
    {
    {
#line 431
    tmp = gai_strerror(gaierr);
    }
    }
#line 431
    if (addr) {
#line 431
      tmp___0 = (char const   *)addr;
    } else {
#line 431
      tmp___0 = "<NULL>";
    }
    {
    {
#line 431
    fatal("bad addr or host: %s (%s)", tmp___0, tmp);
    }
    }
  }
#line 434
  ai = aitop;
  {
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 434
    if (! ai->ai_next) {
#line 434
      goto while_break;
    }
#line 434
    ai = ai->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  ai->ai_next = options___0->listen_addrs;
#line 437
  options___0->listen_addrs = aitop;
#line 438
  return;
}
}
#line 440 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
int process_server_config_line(ServerOptions *options___0 , char *line , char const   *filename ,
                               int linenum ) 
{ 
  char *cp ;
  char **charptr ;
  char *arg ;
  char *p ;
  int *intptr ;
  int value ;
  int n ;
  ServerOpCodes opcode ;
  u_short port ;
  u_int i ;
  u_int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  __uid_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  SyslogFacility tmp___21 ;
  char const   *tmp___22 ;
  LogLevel tmp___23 ;
  char const   *tmp___24 ;
  u_int tmp___25 ;
  u_int tmp___26 ;
  u_int tmp___27 ;
  u_int tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  u_int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;

  {
  {
#line 450
  cp = line;
  {
#line 451
  arg = strdelim(& cp);
  }
  }
#line 453
  if ((int )*arg == 0) {
    {
    {
#line 454
    arg = strdelim(& cp);
    }
    }
  }
#line 455
  if (! arg) {
#line 456
    return (0);
  } else
#line 455
  if (! *arg) {
#line 456
    return (0);
  } else
#line 455
  if ((int )*arg == 35) {
#line 456
    return (0);
  }
  {
#line 457
  intptr = (int *)((void *)0);
#line 458
  charptr = (char **)((void *)0);
  {
#line 459
  opcode = parse_token((char const   *)arg, filename, linenum);
  }
  }
  {
#line 462
  if ((unsigned int )opcode == 1U) {
#line 462
    goto case_1;
  }
#line 467
  if ((unsigned int )opcode == 0U) {
#line 467
    goto case_0;
  }
#line 469
  if ((unsigned int )opcode == 2U) {
#line 469
    goto case_2;
  }
#line 489
  if ((unsigned int )opcode == 4U) {
#line 489
    goto case_4;
  }
#line 501
  if ((unsigned int )opcode == 5U) {
#line 501
    goto case_5;
  }
#line 515
  if ((unsigned int )opcode == 6U) {
#line 515
    goto case_6;
  }
#line 519
  if ((unsigned int )opcode == 20U) {
#line 519
    goto case_20;
  }
#line 544
  if ((unsigned int )opcode == 21U) {
#line 544
    goto case_21;
  }
#line 566
  if ((unsigned int )opcode == 3U) {
#line 566
    goto case_3;
  }
#line 585
  if ((unsigned int )opcode == 43U) {
#line 585
    goto case_43;
  }
#line 589
  if ((unsigned int )opcode == 7U) {
#line 589
    goto case_7;
  }
#line 613
  if ((unsigned int )opcode == 24U) {
#line 613
    goto case_24;
  }
#line 632
  if ((unsigned int )opcode == 39U) {
#line 632
    goto case_39;
  }
#line 636
  if ((unsigned int )opcode == 10U) {
#line 636
    goto case_10;
  }
#line 640
  if ((unsigned int )opcode == 52U) {
#line 640
    goto case_52;
  }
#line 644
  if ((unsigned int )opcode == 53U) {
#line 644
    goto case_53;
  }
#line 648
  if ((unsigned int )opcode == 11U) {
#line 648
    goto case_11;
  }
#line 652
  if ((unsigned int )opcode == 45U) {
#line 652
    goto case_45;
  }
#line 656
  if ((unsigned int )opcode == 12U) {
#line 656
    goto case_12;
  }
#line 660
  if ((unsigned int )opcode == 13U) {
#line 660
    goto case_13;
  }
#line 664
  if ((unsigned int )opcode == 14U) {
#line 664
    goto case_14;
  }
#line 668
  if ((unsigned int )opcode == 15U) {
#line 668
    goto case_15;
  }
#line 672
  if ((unsigned int )opcode == 58U) {
#line 672
    goto case_58;
  }
#line 676
  if ((unsigned int )opcode == 59U) {
#line 676
    goto case_59;
  }
#line 680
  if ((unsigned int )opcode == 18U) {
#line 680
    goto case_18;
  }
#line 684
  if ((unsigned int )opcode == 19U) {
#line 684
    goto case_19;
  }
#line 688
  if ((unsigned int )opcode == 17U) {
#line 688
    goto case_17;
  }
#line 692
  if ((unsigned int )opcode == 22U) {
#line 692
    goto case_22;
  }
#line 696
  if ((unsigned int )opcode == 23U) {
#line 696
    goto case_23;
  }
#line 700
  if ((unsigned int )opcode == 25U) {
#line 700
    goto case_25;
  }
#line 704
  if ((unsigned int )opcode == 26U) {
#line 704
    goto case_26;
  }
#line 708
  if ((unsigned int )opcode == 27U) {
#line 708
    goto case_27;
  }
#line 712
  if ((unsigned int )opcode == 46U) {
#line 712
    goto case_46;
  }
#line 716
  if ((unsigned int )opcode == 28U) {
#line 716
    goto case_28;
  }
#line 720
  if ((unsigned int )opcode == 30U) {
#line 720
    goto case_30;
  }
#line 724
  if ((unsigned int )opcode == 29U) {
#line 724
    goto case_29;
  }
#line 728
  if ((unsigned int )opcode == 31U) {
#line 728
    goto case_31;
  }
#line 732
  if ((unsigned int )opcode == 32U) {
#line 732
    goto case_32;
  }
#line 736
  if ((unsigned int )opcode == 34U) {
#line 736
    goto case_34;
  }
#line 756
  if ((unsigned int )opcode == 44U) {
#line 756
    goto case_44;
  }
#line 776
  if ((unsigned int )opcode == 51U) {
#line 776
    goto case_51;
  }
#line 780
  if ((unsigned int )opcode == 8U) {
#line 780
    goto case_8;
  }
#line 791
  if ((unsigned int )opcode == 9U) {
#line 791
    goto case_9;
  }
#line 802
  if ((unsigned int )opcode == 33U) {
#line 802
    goto case_33;
  }
#line 806
  if ((unsigned int )opcode == 62U) {
#line 806
    goto case_62;
  }
#line 810
  if ((unsigned int )opcode == 35U) {
#line 810
    goto case_35;
  }
#line 820
  if ((unsigned int )opcode == 36U) {
#line 820
    goto case_36;
  }
#line 830
  if ((unsigned int )opcode == 37U) {
#line 830
    goto case_37;
  }
#line 840
  if ((unsigned int )opcode == 38U) {
#line 840
    goto case_38;
  }
#line 849
  if ((unsigned int )opcode == 40U) {
#line 849
    goto case_40;
  }
#line 860
  if ((unsigned int )opcode == 41U) {
#line 860
    goto case_41;
  }
#line 871
  if ((unsigned int )opcode == 42U) {
#line 871
    goto case_42;
  }
#line 884
  if ((unsigned int )opcode == 47U) {
#line 884
    goto case_47;
  }
#line 906
  if ((unsigned int )opcode == 48U) {
#line 906
    goto case_48;
  }
#line 928
  if ((unsigned int )opcode == 49U) {
#line 928
    goto case_49;
  }
#line 932
  if ((unsigned int )opcode == 50U) {
#line 932
    goto case_50;
  }
#line 942
  if ((unsigned int )opcode == 57U) {
#line 942
    goto case_57;
  }
#line 942
  if ((unsigned int )opcode == 56U) {
#line 942
    goto case_57;
  }
#line 948
  if ((unsigned int )opcode == 54U) {
#line 948
    goto case_54;
  }
#line 952
  if ((unsigned int )opcode == 55U) {
#line 952
    goto case_55;
  }
#line 956
  if ((unsigned int )opcode == 60U) {
#line 956
    goto case_60;
  }
#line 969
  if ((unsigned int )opcode == 61U) {
#line 969
    goto case_61;
  }
#line 991
  if ((unsigned int )opcode == 63U) {
#line 991
    goto case_63;
  }
#line 998
  if ((unsigned int )opcode == 64U) {
#line 998
    goto case_64;
  }
#line 1005
  goto switch_default;
  case_1: /* CIL Label */ 
#line 463
  intptr = & options___0->use_pam;
#line 464
  goto parse_flag;
  case_0: /* CIL Label */ 
#line 468
  return (-1);
  case_2: /* CIL Label */ 
#line 471
  if (options___0->ports_from_cmdline) {
#line 472
    return (0);
  }
#line 473
  if ((unsigned long )options___0->listen_addrs != (unsigned long )((void *)0)) {
    {
    {
#line 474
    fatal("%s line %d: ports must be specified before ListenAddress.", filename, linenum);
    }
    }
  }
#line 476
  if (options___0->num_ports >= 256U) {
    {
    {
#line 477
    fatal("%s line %d: too many ports.", filename, linenum);
    }
    }
  }
  {
  {
#line 479
  arg = strdelim(& cp);
  }
  }
#line 480
  if (! arg) {
    {
    {
#line 481
    fatal("%s line %d: missing port number.", filename, linenum);
    }
    }
  } else
#line 480
  if ((int )*arg == 0) {
    {
    {
#line 481
    fatal("%s line %d: missing port number.", filename, linenum);
    }
    }
  }
  {
#line 483
  tmp = options___0->num_ports;
#line 483
  (options___0->num_ports) ++;
  {
#line 483
  tmp___0 = a2port((char const   *)arg);
  }
#line 483
  options___0->ports[tmp] = (u_short )tmp___0;
  }
#line 484
  if ((int )options___0->ports[options___0->num_ports - 1U] == 0) {
    {
    {
#line 485
    fatal("%s line %d: Badly formatted port number.", filename, linenum);
    }
    }
  }
#line 487
  goto switch_break;
  case_4: /* CIL Label */ 
#line 490
  intptr = & options___0->server_key_bits;
  parse_int: 
  {
  {
#line 492
  arg = strdelim(& cp);
  }
  }
#line 493
  if (! arg) {
    {
    {
#line 494
    fatal("%s line %d: missing integer value.", filename, linenum);
    }
    }
  } else
#line 493
  if ((int )*arg == 0) {
    {
    {
#line 494
    fatal("%s line %d: missing integer value.", filename, linenum);
    }
    }
  }
  {
  {
#line 496
  value = atoi((char const   *)arg);
  }
  }
#line 497
  if (*intptr == -1) {
#line 498
    *intptr = value;
  }
#line 499
  goto switch_break;
  case_5: /* CIL Label */ 
#line 502
  intptr = & options___0->login_grace_time;
  parse_time: 
  {
  {
#line 504
  arg = strdelim(& cp);
  }
  }
#line 505
  if (! arg) {
    {
    {
#line 506
    fatal("%s line %d: missing time value.", filename, linenum);
    }
    }
  } else
#line 505
  if ((int )*arg == 0) {
    {
    {
#line 506
    fatal("%s line %d: missing time value.", filename, linenum);
    }
    }
  }
  {
  {
#line 508
  tmp___1 = convtime((char const   *)arg);
  }
#line 508
  value = (int )tmp___1;
  }
#line 508
  if (value == -1) {
    {
    {
#line 509
    fatal("%s line %d: invalid time value.", filename, linenum);
    }
    }
  }
#line 511
  if (*intptr == -1) {
#line 512
    *intptr = value;
  }
#line 513
  goto switch_break;
  case_6: /* CIL Label */ 
#line 516
  intptr = & options___0->key_regeneration_time;
#line 517
  goto parse_time;
  case_20: /* CIL Label */ 
  {
  {
#line 520
  arg = strdelim(& cp);
  }
  }
#line 521
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
    {
#line 522
    fatal("%s line %d: missing address", filename, linenum);
    }
    }
  } else
#line 521
  if ((int )*arg == 0) {
    {
    {
#line 522
    fatal("%s line %d: missing address", filename, linenum);
    }
    }
  }
  {
  {
#line 525
  tmp___2 = strchr((char const   *)arg, '[');
  }
  }
#line 525
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
    {
#line 525
    p = strchr((char const   *)arg, ':');
    }
    }
#line 525
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
      {
#line 525
      tmp___3 = strchr((char const   *)(p + 1), ':');
      }
      }
#line 525
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        {
        {
#line 527
        add_listen_addr(options___0, arg, (u_short )0);
        }
        }
#line 528
        goto switch_break;
      }
    }
  }
  {
  {
#line 530
  p = hpdelim(& arg);
  }
  }
#line 531
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 532
    fatal("%s line %d: bad address:port usage", filename, linenum);
    }
    }
  }
  {
  {
#line 534
  p = cleanhostname(p);
  }
  }
#line 535
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 536
    port = (u_short )0;
  } else {
    {
    {
#line 537
    tmp___4 = a2port((char const   *)arg);
    }
#line 537
    port = (u_short )tmp___4;
    }
#line 537
    if ((int )port == 0) {
      {
      {
#line 538
      fatal("%s line %d: bad port number", filename, linenum);
      }
      }
    }
  }
  {
  {
#line 540
  add_listen_addr(options___0, p, port);
  }
  }
#line 542
  goto switch_break;
  case_21: /* CIL Label */ 
  {
  {
#line 545
  arg = strdelim(& cp);
  }
  }
#line 546
  if (! arg) {
    {
    {
#line 547
    fatal("%s line %d: missing address family.", filename, linenum);
    }
    }
  } else
#line 546
  if ((int )*arg == 0) {
    {
    {
#line 547
    fatal("%s line %d: missing address family.", filename, linenum);
    }
    }
  }
#line 549
  intptr = & options___0->address_family;
#line 550
  if ((unsigned long )options___0->listen_addrs != (unsigned long )((void *)0)) {
    {
    {
#line 551
    fatal("%s line %d: address family must be specified before ListenAddress.", filename,
          linenum);
    }
    }
  }
  {
  {
#line 553
  tmp___7 = strcasecmp((char const   *)arg, "inet");
  }
  }
#line 553
  if (tmp___7 == 0) {
#line 554
    value = 2;
  } else {
    {
    {
#line 555
    tmp___6 = strcasecmp((char const   *)arg, "inet6");
    }
    }
#line 555
    if (tmp___6 == 0) {
#line 556
      value = 10;
    } else {
      {
      {
#line 557
      tmp___5 = strcasecmp((char const   *)arg, "any");
      }
      }
#line 557
      if (tmp___5 == 0) {
#line 558
        value = 0;
      } else {
        {
        {
#line 560
        fatal("%s line %d: unsupported address family \"%s\".", filename, linenum,
              arg);
        }
        }
      }
    }
  }
#line 562
  if (*intptr == -1) {
#line 563
    *intptr = value;
  }
#line 564
  goto switch_break;
  case_3: /* CIL Label */ 
#line 567
  intptr = & options___0->num_host_key_files;
#line 568
  if (*intptr >= 256) {
    {
    {
#line 569
    fatal("%s line %d: too many host keys specified (max %d).", filename, linenum,
          256);
    }
    }
  }
#line 571
  charptr = & options___0->host_key_files[*intptr];
  parse_filename: 
  {
  {
#line 573
  arg = strdelim(& cp);
  }
  }
#line 574
  if (! arg) {
    {
    {
#line 575
    fatal("%s line %d: missing file name.", filename, linenum);
    }
    }
  } else
#line 574
  if ((int )*arg == 0) {
    {
    {
#line 575
    fatal("%s line %d: missing file name.", filename, linenum);
    }
    }
  }
#line 577
  if ((unsigned long )*charptr == (unsigned long )((void *)0)) {
    {
    {
#line 578
    tmp___8 = getuid();
    }
    {
#line 578
    *charptr = tilde_expand_filename((char const   *)arg, tmp___8);
    }
    }
#line 580
    if ((unsigned long )intptr != (unsigned long )((void *)0)) {
#line 581
      (*intptr) ++;
    }
  }
#line 583
  goto switch_break;
  case_43: /* CIL Label */ 
#line 586
  charptr = & options___0->pid_file;
#line 587
  goto parse_filename;
  case_7: /* CIL Label */ 
  {
#line 590
  intptr = & options___0->permit_root_login;
  {
#line 591
  arg = strdelim(& cp);
  }
  }
#line 592
  if (! arg) {
    {
    {
#line 593
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
    }
    }
  } else
#line 592
  if ((int )*arg == 0) {
    {
    {
#line 593
    fatal("%s line %d: missing yes/without-password/forced-commands-only/no argument.",
          filename, linenum);
    }
    }
  }
  {
#line 596
  value = 0;
  {
#line 597
  tmp___12 = strcmp((char const   *)arg, "without-password");
  }
  }
#line 597
  if (tmp___12 == 0) {
#line 598
    value = 2;
  } else {
    {
    {
#line 599
    tmp___11 = strcmp((char const   *)arg, "forced-commands-only");
    }
    }
#line 599
    if (tmp___11 == 0) {
#line 600
      value = 1;
    } else {
      {
      {
#line 601
      tmp___10 = strcmp((char const   *)arg, "yes");
      }
      }
#line 601
      if (tmp___10 == 0) {
#line 602
        value = 3;
      } else {
        {
        {
#line 603
        tmp___9 = strcmp((char const   *)arg, "no");
        }
        }
#line 603
        if (tmp___9 == 0) {
#line 604
          value = 0;
        } else {
          {
          {
#line 606
          fatal("%s line %d: Bad yes/without-password/forced-commands-only/no argument: %s",
                filename, linenum, arg);
          }
          }
        }
      }
    }
  }
#line 609
  if (*intptr == -1) {
#line 610
    *intptr = value;
  }
#line 611
  goto switch_break;
  case_24: /* CIL Label */ 
#line 614
  intptr = & options___0->ignore_rhosts;
  parse_flag: 
  {
  {
#line 616
  arg = strdelim(& cp);
  }
  }
#line 617
  if (! arg) {
    {
    {
#line 618
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
    }
  } else
#line 617
  if ((int )*arg == 0) {
    {
    {
#line 618
    fatal("%s line %d: missing yes/no argument.", filename, linenum);
    }
    }
  }
  {
#line 620
  value = 0;
  {
#line 621
  tmp___14 = strcmp((char const   *)arg, "yes");
  }
  }
#line 621
  if (tmp___14 == 0) {
#line 622
    value = 1;
  } else {
    {
    {
#line 623
    tmp___13 = strcmp((char const   *)arg, "no");
    }
    }
#line 623
    if (tmp___13 == 0) {
#line 624
      value = 0;
    } else {
      {
      {
#line 626
      fatal("%s line %d: Bad yes/no argument: %s", filename, linenum, arg);
      }
      }
    }
  }
#line 628
  if (*intptr == -1) {
#line 629
    *intptr = value;
  }
#line 630
  goto switch_break;
  case_39: /* CIL Label */ 
#line 633
  intptr = & options___0->ignore_user_known_hosts;
#line 634
  goto parse_flag;
  case_10: /* CIL Label */ 
#line 637
  intptr = & options___0->rhosts_rsa_authentication;
#line 638
  goto parse_flag;
  case_52: /* CIL Label */ 
#line 641
  intptr = & options___0->hostbased_authentication;
#line 642
  goto parse_flag;
  case_53: /* CIL Label */ 
#line 645
  intptr = & options___0->hostbased_uses_name_from_packet_only;
#line 646
  goto parse_flag;
  case_11: /* CIL Label */ 
#line 649
  intptr = & options___0->rsa_authentication;
#line 650
  goto parse_flag;
  case_45: /* CIL Label */ 
#line 653
  intptr = & options___0->pubkey_authentication;
#line 654
  goto parse_flag;
  case_12: /* CIL Label */ 
#line 657
  intptr = & options___0->kerberos_authentication;
#line 658
  goto parse_flag;
  case_13: /* CIL Label */ 
#line 661
  intptr = & options___0->kerberos_or_local_passwd;
#line 662
  goto parse_flag;
  case_14: /* CIL Label */ 
#line 665
  intptr = & options___0->kerberos_ticket_cleanup;
#line 666
  goto parse_flag;
  case_15: /* CIL Label */ 
#line 669
  intptr = & options___0->kerberos_get_afs_token;
#line 670
  goto parse_flag;
  case_58: /* CIL Label */ 
#line 673
  intptr = & options___0->gss_authentication;
#line 674
  goto parse_flag;
  case_59: /* CIL Label */ 
#line 677
  intptr = & options___0->gss_cleanup_creds;
#line 678
  goto parse_flag;
  case_18: /* CIL Label */ 
#line 681
  intptr = & options___0->password_authentication;
#line 682
  goto parse_flag;
  case_19: /* CIL Label */ 
#line 685
  intptr = & options___0->kbd_interactive_authentication;
#line 686
  goto parse_flag;
  case_17: /* CIL Label */ 
#line 689
  intptr = & options___0->challenge_response_authentication;
#line 690
  goto parse_flag;
  case_22: /* CIL Label */ 
#line 693
  intptr = & options___0->print_motd;
#line 694
  goto parse_flag;
  case_23: /* CIL Label */ 
#line 697
  intptr = & options___0->print_lastlog;
#line 698
  goto parse_flag;
  case_25: /* CIL Label */ 
#line 701
  intptr = & options___0->x11_forwarding;
#line 702
  goto parse_flag;
  case_26: /* CIL Label */ 
#line 705
  intptr = & options___0->x11_display_offset;
#line 706
  goto parse_int;
  case_27: /* CIL Label */ 
#line 709
  intptr = & options___0->x11_use_localhost;
#line 710
  goto parse_flag;
  case_46: /* CIL Label */ 
#line 713
  charptr = & options___0->xauth_location;
#line 714
  goto parse_filename;
  case_28: /* CIL Label */ 
#line 717
  intptr = & options___0->strict_modes;
#line 718
  goto parse_flag;
  case_30: /* CIL Label */ 
#line 721
  intptr = & options___0->tcp_keep_alive;
#line 722
  goto parse_flag;
  case_29: /* CIL Label */ 
#line 725
  intptr = & options___0->permit_empty_passwd;
#line 726
  goto parse_flag;
  case_31: /* CIL Label */ 
#line 729
  intptr = & options___0->permit_user_env;
#line 730
  goto parse_flag;
  case_32: /* CIL Label */ 
#line 733
  intptr = & options___0->use_login;
#line 734
  goto parse_flag;
  case_34: /* CIL Label */ 
  {
#line 737
  intptr = & options___0->compression;
  {
#line 738
  arg = strdelim(& cp);
  }
  }
#line 739
  if (! arg) {
    {
    {
#line 740
    fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
    }
    }
  } else
#line 739
  if ((int )*arg == 0) {
    {
    {
#line 740
    fatal("%s line %d: missing yes/no/delayed argument.", filename, linenum);
    }
    }
  }
  {
#line 742
  value = 0;
  {
#line 743
  tmp___17 = strcmp((char const   *)arg, "delayed");
  }
  }
#line 743
  if (tmp___17 == 0) {
#line 744
    value = 2;
  } else {
    {
    {
#line 745
    tmp___16 = strcmp((char const   *)arg, "yes");
    }
    }
#line 745
    if (tmp___16 == 0) {
#line 746
      value = 1;
    } else {
      {
      {
#line 747
      tmp___15 = strcmp((char const   *)arg, "no");
      }
      }
#line 747
      if (tmp___15 == 0) {
#line 748
        value = 0;
      } else {
        {
        {
#line 750
        fatal("%s line %d: Bad yes/no/delayed argument: %s", filename, linenum, arg);
        }
        }
      }
    }
  }
#line 752
  if (*intptr == -1) {
#line 753
    *intptr = value;
  }
#line 754
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 757
  intptr = & options___0->gateway_ports;
  {
#line 758
  arg = strdelim(& cp);
  }
  }
#line 759
  if (! arg) {
    {
    {
#line 760
    fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
    }
    }
  } else
#line 759
  if ((int )*arg == 0) {
    {
    {
#line 760
    fatal("%s line %d: missing yes/no/clientspecified argument.", filename, linenum);
    }
    }
  }
  {
#line 762
  value = 0;
  {
#line 763
  tmp___20 = strcmp((char const   *)arg, "clientspecified");
  }
  }
#line 763
  if (tmp___20 == 0) {
#line 764
    value = 2;
  } else {
    {
    {
#line 765
    tmp___19 = strcmp((char const   *)arg, "yes");
    }
    }
#line 765
    if (tmp___19 == 0) {
#line 766
      value = 1;
    } else {
      {
      {
#line 767
      tmp___18 = strcmp((char const   *)arg, "no");
      }
      }
#line 767
      if (tmp___18 == 0) {
#line 768
        value = 0;
      } else {
        {
        {
#line 770
        fatal("%s line %d: Bad yes/no/clientspecified argument: %s", filename, linenum,
              arg);
        }
        }
      }
    }
  }
#line 772
  if (*intptr == -1) {
#line 773
    *intptr = value;
  }
#line 774
  goto switch_break;
  case_51: /* CIL Label */ 
#line 777
  intptr = & options___0->use_dns;
#line 778
  goto parse_flag;
  case_8: /* CIL Label */ 
  {
#line 781
  intptr = (int *)(& options___0->log_facility);
  {
#line 782
  arg = strdelim(& cp);
  }
  {
#line 783
  tmp___21 = log_facility_number(arg);
  }
#line 783
  value = (int )tmp___21;
  }
#line 784
  if (value == -1) {
#line 785
    if (arg) {
#line 785
      tmp___22 = (char const   *)arg;
    } else {
#line 785
      tmp___22 = "<NONE>";
    }
    {
    {
#line 785
    fatal("%.200s line %d: unsupported log facility \'%s\'", filename, linenum, tmp___22);
    }
    }
  }
#line 787
  if (*intptr == -1) {
#line 788
    *intptr = (int )((SyslogFacility )value);
  }
#line 789
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 792
  intptr = (int *)(& options___0->log_level);
  {
#line 793
  arg = strdelim(& cp);
  }
  {
#line 794
  tmp___23 = log_level_number(arg);
  }
#line 794
  value = (int )tmp___23;
  }
#line 795
  if (value == -1) {
#line 796
    if (arg) {
#line 796
      tmp___24 = (char const   *)arg;
    } else {
#line 796
      tmp___24 = "<NONE>";
    }
    {
    {
#line 796
    fatal("%.200s line %d: unsupported log level \'%s\'", filename, linenum, tmp___24);
    }
    }
  }
#line 798
  if (*intptr == -1) {
#line 799
    *intptr = (int )((LogLevel )value);
  }
#line 800
  goto switch_break;
  case_33: /* CIL Label */ 
#line 803
  intptr = & options___0->allow_tcp_forwarding;
#line 804
  goto parse_flag;
  case_62: /* CIL Label */ 
#line 807
  intptr = & use_privsep;
#line 808
  goto parse_flag;
  case_35: /* CIL Label */ 
  {
  {
#line 811
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 811
    arg = strdelim(& cp);
    }
    }
#line 811
    if (arg) {
#line 811
      if (! ((int )*arg != 0)) {
#line 811
        goto while_break;
      }
    } else {
#line 811
      goto while_break;
    }
#line 812
    if (options___0->num_allow_users >= 256U) {
      {
      {
#line 813
      fatal("%s line %d: too many allow users.", filename, linenum);
      }
      }
    }
    {
#line 815
    tmp___25 = options___0->num_allow_users;
#line 815
    (options___0->num_allow_users) ++;
    {
#line 815
    options___0->allow_users[tmp___25] = xstrdup((char const   *)arg);
    }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  goto switch_break;
  case_36: /* CIL Label */ 
  {
  {
#line 821
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 821
    arg = strdelim(& cp);
    }
    }
#line 821
    if (arg) {
#line 821
      if (! ((int )*arg != 0)) {
#line 821
        goto while_break___0;
      }
    } else {
#line 821
      goto while_break___0;
    }
#line 822
    if (options___0->num_deny_users >= 256U) {
      {
      {
#line 823
      fatal("%s line %d: too many deny users.", filename, linenum);
      }
      }
    }
    {
#line 825
    tmp___26 = options___0->num_deny_users;
#line 825
    (options___0->num_deny_users) ++;
    {
#line 825
    options___0->deny_users[tmp___26] = xstrdup((char const   *)arg);
    }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 828
  goto switch_break;
  case_37: /* CIL Label */ 
  {
  {
#line 831
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 831
    arg = strdelim(& cp);
    }
    }
#line 831
    if (arg) {
#line 831
      if (! ((int )*arg != 0)) {
#line 831
        goto while_break___1;
      }
    } else {
#line 831
      goto while_break___1;
    }
#line 832
    if (options___0->num_allow_groups >= 256U) {
      {
      {
#line 833
      fatal("%s line %d: too many allow groups.", filename, linenum);
      }
      }
    }
    {
#line 835
    tmp___27 = options___0->num_allow_groups;
#line 835
    (options___0->num_allow_groups) ++;
    {
#line 835
    options___0->allow_groups[tmp___27] = xstrdup((char const   *)arg);
    }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 838
  goto switch_break;
  case_38: /* CIL Label */ 
  {
  {
#line 841
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 841
    arg = strdelim(& cp);
    }
    }
#line 841
    if (arg) {
#line 841
      if (! ((int )*arg != 0)) {
#line 841
        goto while_break___2;
      }
    } else {
#line 841
      goto while_break___2;
    }
#line 842
    if (options___0->num_deny_groups >= 256U) {
      {
      {
#line 843
      fatal("%s line %d: too many deny groups.", filename, linenum);
      }
      }
    }
    {
#line 845
    tmp___28 = options___0->num_deny_groups;
#line 845
    (options___0->num_deny_groups) ++;
    {
#line 845
    options___0->deny_groups[tmp___28] = xstrdup((char const   *)arg);
    }
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 847
  goto switch_break;
  case_40: /* CIL Label */ 
  {
  {
#line 850
  arg = strdelim(& cp);
  }
  }
#line 851
  if (! arg) {
    {
    {
#line 852
    fatal("%s line %d: Missing argument.", filename, linenum);
    }
    }
  } else
#line 851
  if ((int )*arg == 0) {
    {
    {
#line 852
    fatal("%s line %d: Missing argument.", filename, linenum);
    }
    }
  }
  {
  {
#line 853
  tmp___30 = ciphers_valid((char const   *)arg);
  }
  }
#line 853
  if (! tmp___30) {
#line 854
    if (arg) {
#line 854
      tmp___29 = (char const   *)arg;
    } else {
#line 854
      tmp___29 = "<NONE>";
    }
    {
    {
#line 854
    fatal("%s line %d: Bad SSH2 cipher spec \'%s\'.", filename, linenum, tmp___29);
    }
    }
  }
#line 856
  if ((unsigned long )options___0->ciphers == (unsigned long )((void *)0)) {
    {
    {
#line 857
    options___0->ciphers = xstrdup((char const   *)arg);
    }
    }
  }
#line 858
  goto switch_break;
  case_41: /* CIL Label */ 
  {
  {
#line 861
  arg = strdelim(& cp);
  }
  }
#line 862
  if (! arg) {
    {
    {
#line 863
    fatal("%s line %d: Missing argument.", filename, linenum);
    }
    }
  } else
#line 862
  if ((int )*arg == 0) {
    {
    {
#line 863
    fatal("%s line %d: Missing argument.", filename, linenum);
    }
    }
  }
  {
  {
#line 864
  tmp___32 = mac_valid((char const   *)arg);
  }
  }
#line 864
  if (! tmp___32) {
#line 865
    if (arg) {
#line 865
      tmp___31 = (char const   *)arg;
    } else {
#line 865
      tmp___31 = "<NONE>";
    }
    {
    {
#line 865
    fatal("%s line %d: Bad SSH2 mac spec \'%s\'.", filename, linenum, tmp___31);
    }
    }
  }
#line 867
  if ((unsigned long )options___0->macs == (unsigned long )((void *)0)) {
    {
    {
#line 868
    options___0->macs = xstrdup((char const   *)arg);
    }
    }
  }
#line 869
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 872
  intptr = & options___0->protocol;
  {
#line 873
  arg = strdelim(& cp);
  }
  }
#line 874
  if (! arg) {
    {
    {
#line 875
    fatal("%s line %d: Missing argument.", filename, linenum);
    }
    }
  } else
#line 874
  if ((int )*arg == 0) {
    {
    {
#line 875
    fatal("%s line %d: Missing argument.", filename, linenum);
    }
    }
  }
  {
  {
#line 876
  value = proto_spec((char const   *)arg);
  }
  }
#line 877
  if (value == 0) {
#line 878
    if (arg) {
#line 878
      tmp___33 = (char const   *)arg;
    } else {
#line 878
      tmp___33 = "<NONE>";
    }
    {
    {
#line 878
    fatal("%s line %d: Bad protocol spec \'%s\'.", filename, linenum, tmp___33);
    }
    }
  }
#line 880
  if (*intptr == 0) {
#line 881
    *intptr = value;
  }
#line 882
  goto switch_break;
  case_47: /* CIL Label */ 
#line 885
  if (options___0->num_subsystems >= 256U) {
    {
    {
#line 886
    fatal("%s line %d: too many subsystems defined.", filename, linenum);
    }
    }
  }
  {
  {
#line 889
  arg = strdelim(& cp);
  }
  }
#line 890
  if (! arg) {
    {
    {
#line 891
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
    }
  } else
#line 890
  if ((int )*arg == 0) {
    {
    {
#line 891
    fatal("%s line %d: Missing subsystem name.", filename, linenum);
    }
    }
  }
#line 893
  i = (u_int )0;
  {
  {
#line 893
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 893
    if (! (i < options___0->num_subsystems)) {
#line 893
      goto while_break___3;
    }
    {
    {
#line 894
    tmp___34 = strcmp((char const   *)arg, (char const   *)options___0->subsystem_name[i]);
    }
    }
#line 894
    if (tmp___34 == 0) {
      {
      {
#line 895
      fatal("%s line %d: Subsystem \'%s\' already defined.", filename, linenum, arg);
      }
      }
    }
#line 893
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 897
  options___0->subsystem_name[options___0->num_subsystems] = xstrdup((char const   *)arg);
  }
  {
#line 898
  arg = strdelim(& cp);
  }
  }
#line 899
  if (! arg) {
    {
    {
#line 900
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
    }
  } else
#line 899
  if ((int )*arg == 0) {
    {
    {
#line 900
    fatal("%s line %d: Missing subsystem command.", filename, linenum);
    }
    }
  }
  {
  {
#line 902
  options___0->subsystem_command[options___0->num_subsystems] = xstrdup((char const   *)arg);
  }
#line 903
  (options___0->num_subsystems) ++;
  }
#line 904
  goto switch_break;
  case_48: /* CIL Label */ 
  {
  {
#line 907
  arg = strdelim(& cp);
  }
  }
#line 908
  if (! arg) {
    {
    {
#line 909
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
    }
  } else
#line 908
  if ((int )*arg == 0) {
    {
    {
#line 909
    fatal("%s line %d: Missing MaxStartups spec.", filename, linenum);
    }
    }
  }
  {
  {
#line 911
  n = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d:%d:%d",
             & options___0->max_startups_begin, & options___0->max_startups_rate,
             & options___0->max_startups);
  }
  }
#line 911
  if (n == 3) {
#line 915
    if (options___0->max_startups_begin > options___0->max_startups) {
      {
      {
#line 919
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      }
      }
    } else
#line 915
    if (options___0->max_startups_rate > 100) {
      {
      {
#line 919
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      }
      }
    } else
#line 915
    if (options___0->max_startups_rate < 1) {
      {
      {
#line 919
      fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
      }
      }
    }
  } else
#line 921
  if (n != 1) {
    {
    {
#line 922
    fatal("%s line %d: Illegal MaxStartups spec.", filename, linenum);
    }
    }
  } else {
#line 925
    options___0->max_startups = options___0->max_startups_begin;
  }
#line 926
  goto switch_break;
  case_49: /* CIL Label */ 
#line 929
  intptr = & options___0->max_authtries;
#line 930
  goto parse_int;
  case_50: /* CIL Label */ 
#line 933
  charptr = & options___0->banner;
#line 934
  goto parse_filename;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
#line 943
  if ((unsigned int )opcode == 56U) {
#line 943
    charptr = & options___0->authorized_keys_file;
  } else {
#line 943
    charptr = & options___0->authorized_keys_file2;
  }
#line 946
  goto parse_filename;
  case_54: /* CIL Label */ 
#line 949
  intptr = & options___0->client_alive_interval;
#line 950
  goto parse_time;
  case_55: /* CIL Label */ 
#line 953
  intptr = & options___0->client_alive_count_max;
#line 954
  goto parse_int;
  case_60: /* CIL Label */ 
  {
  {
#line 957
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
    {
    {
#line 957
    arg = strdelim(& cp);
    }
    }
#line 957
    if (arg) {
#line 957
      if (! ((int )*arg != 0)) {
#line 957
        goto while_break___4;
      }
    } else {
#line 957
      goto while_break___4;
    }
    {
    {
#line 958
    tmp___35 = strchr((char const   *)arg, '=');
    }
    }
#line 958
    if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
      {
      {
#line 959
      fatal("%s line %d: Invalid environment name.", filename, linenum);
      }
      }
    }
#line 961
    if (options___0->num_accept_env >= 256U) {
      {
      {
#line 962
      fatal("%s line %d: too many allow env.", filename, linenum);
      }
      }
    }
    {
#line 964
    tmp___36 = options___0->num_accept_env;
#line 964
    (options___0->num_accept_env) ++;
    {
#line 964
    options___0->accept_env[tmp___36] = xstrdup((char const   *)arg);
    }
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 967
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 970
  intptr = & options___0->permit_tun;
  {
#line 971
  arg = strdelim(& cp);
  }
  }
#line 972
  if (! arg) {
    {
    {
#line 973
    fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
          linenum);
    }
    }
  } else
#line 972
  if ((int )*arg == 0) {
    {
    {
#line 973
    fatal("%s line %d: Missing yes/point-to-point/ethernet/no argument.", filename,
          linenum);
    }
    }
  }
  {
#line 975
  value = 0;
  {
#line 976
  tmp___40 = strcasecmp((char const   *)arg, "ethernet");
  }
  }
#line 976
  if (tmp___40 == 0) {
#line 977
    value = 2;
  } else {
    {
    {
#line 978
    tmp___39 = strcasecmp((char const   *)arg, "point-to-point");
    }
    }
#line 978
    if (tmp___39 == 0) {
#line 979
      value = 1;
    } else {
      {
      {
#line 980
      tmp___38 = strcasecmp((char const   *)arg, "yes");
      }
      }
#line 980
      if (tmp___38 == 0) {
#line 981
        value = 3;
      } else {
        {
        {
#line 982
        tmp___37 = strcasecmp((char const   *)arg, "no");
        }
        }
#line 982
        if (tmp___37 == 0) {
#line 983
          value = 0;
        } else {
          {
          {
#line 985
          fatal("%s line %d: Bad yes/point-to-point/ethernet/no argument: %s", filename,
                linenum, arg);
          }
          }
        }
      }
    }
  }
#line 987
  if (*intptr == -1) {
#line 988
    *intptr = value;
  }
#line 989
  goto switch_break;
  case_63: /* CIL Label */ 
  {
  {
#line 992
  logit("%s line %d: Deprecated option %s", filename, linenum, arg);
  }
  }
  {
  {
#line 994
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 994
    if (! arg) {
#line 994
      goto while_break___5;
    }
    {
    {
#line 995
    arg = strdelim(& cp);
    }
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 996
  goto switch_break;
  case_64: /* CIL Label */ 
  {
  {
#line 999
  logit("%s line %d: Unsupported option %s", filename, linenum, arg);
  }
  }
  {
  {
#line 1001
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 1001
    if (! arg) {
#line 1001
      goto while_break___6;
    }
    {
    {
#line 1002
    arg = strdelim(& cp);
    }
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1003
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 1006
  fatal("%s line %d: Missing handler for opcode %s (%d)", filename, linenum, arg,
        (unsigned int )opcode);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1009
  arg = strdelim(& cp);
  }
  }
#line 1009
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 1009
    if ((int )*arg != 0) {
      {
      {
#line 1010
      fatal("%s line %d: garbage at end of line; \"%.200s\".", filename, linenum,
            arg);
      }
      }
    }
  }
#line 1012
  return (0);
}
}
#line 1017 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
void load_server_config(char const   *filename , Buffer *conf ) 
{ 
  char line[1024] ;
  char *cp ;
  FILE *f ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  u_int tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 1023
  debug2("%s: filename %s", "load_server_config", filename);
  }
  {
#line 1024
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
  }
#line 1024
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
    {
#line 1025
    perror(filename);
    }
    {
#line 1026
    exit(1);
    }
    }
  }
  {
  {
#line 1028
  buffer_clear(conf);
  }
  }
  {
  {
#line 1029
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1029
    tmp___1 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)f);
    }
    }
#line 1029
    if (! tmp___1) {
#line 1029
      goto while_break;
    }
    {
    {
#line 1035
    cp = strchr((char const   *)(line), '#');
    }
    }
#line 1035
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
      {
#line 1036
      memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)"\n", (size_t )2);
      }
      }
    }
    {
    {
#line 1037
    tmp = strspn((char const   *)(line), " \t\r");
    }
#line 1037
    cp = line + tmp;
    {
#line 1039
    tmp___0 = strlen((char const   *)cp);
    }
    {
#line 1039
    buffer_append(conf, (void const   *)cp, tmp___0);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1041
  buffer_append(conf, (void const   *)"\000", (u_int )1);
  }
  {
#line 1042
  fclose(f);
  }
  {
#line 1043
  tmp___2 = buffer_len(conf);
  }
  {
#line 1043
  debug2("%s: done config len = %d", "load_server_config", tmp___2);
  }
  }
#line 1044
  return;
}
}
#line 1046 "/home/pronto/abs/test-suite/openssh-4.3p2/servconf.c"
void parse_server_config(ServerOptions *options___0 , char const   *filename , Buffer *conf ) 
{ 
  int linenum ;
  int bad_options ;
  char *cp ;
  char *obuf ;
  char *cbuf ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 1049
  bad_options = 0;
  {
#line 1052
  tmp = buffer_len(conf);
  }
  {
#line 1052
  debug2("%s: config %s len %d", "parse_server_config", filename, tmp);
  }
  {
#line 1054
  tmp___0 = buffer_ptr(conf);
  }
  {
#line 1054
  cbuf = xstrdup((char const   *)tmp___0);
  }
#line 1054
  obuf = cbuf;
#line 1055
  linenum = 1;
  }
  {
  {
#line 1056
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1056
    cp = strsep((char **/* __restrict  */)(& cbuf), (char const   */* __restrict  */)"\n");
    }
    }
#line 1056
    if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 1056
      goto while_break;
    }
    {
#line 1057
    tmp___1 = linenum;
#line 1057
    linenum ++;
    {
#line 1057
    tmp___2 = process_server_config_line(options___0, cp, filename, tmp___1);
    }
    }
#line 1057
    if (tmp___2 != 0) {
#line 1059
      bad_options ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1061
  xfree((void *)obuf);
  }
  }
#line 1062
  if (bad_options > 0) {
    {
    {
#line 1063
    fatal("%s: terminating, %d bad configuration options", filename, bad_options);
    }
    }
  }
#line 1065
  return;
}
}
#line 257 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 57 "/home/pronto/abs/test-suite/openssh-4.3p2/sshlogin.c"
u_long get_last_login_time(uid_t uid , char const   *logname , char *buf___1 , u_int bufsize ) 
{ 
  struct logininfo li ;

  {
  {
  {
#line 63
  login_get_lastlog(& li, (int const   )uid);
  }
  {
#line 64
  strlcpy(buf___1, (char const   *)(li.hostname), bufsize);
  }
  }
#line 65
  return ((u_long )li.tv_sec);
}
}
#line 72 "/home/pronto/abs/test-suite/openssh-4.3p2/sshlogin.c"
static void store_lastlog_message(char const   *user , uid_t uid ) 
{ 
  char *time_string ;
  char hostname[64] ;
  unsigned int tmp ;
  char buf___1[512] ;
  time_t last_login_time ;
  u_long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 75
  hostname[0] = (char )'\000';
#line 75
  tmp = 1U;
  {
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 75
    if (tmp >= 64U) {
#line 75
      goto while_break;
    }
#line 75
    hostname[tmp] = (char)0;
#line 75
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (! options.print_lastlog) {
#line 80
    return;
  }
  {
  {
#line 82
  tmp___0 = get_last_login_time(uid, user, hostname, (u_int )sizeof(hostname));
  }
#line 82
  last_login_time = (time_t )tmp___0;
  }
#line 85
  if (last_login_time != 0L) {
    {
    {
#line 86
    time_string = ctime((time_t const   *)(& last_login_time));
    }
    {
#line 87
    tmp___2 = strchr((char const   *)time_string, '\n');
    }
    }
#line 87
    if (tmp___2) {
      {
      {
#line 88
      tmp___1 = strchr((char const   *)time_string, '\n');
      }
#line 88
      *tmp___1 = (char )'\000';
      }
    }
    {
    {
#line 89
    tmp___3 = strcmp((char const   *)(hostname), "");
    }
    }
#line 89
    if (tmp___3 == 0) {
      {
      {
#line 90
      snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"Last login: %s\r\n",
               time_string);
      }
      }
    } else {
      {
      {
#line 93
      snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"Last login: %s from %s\r\n",
               time_string, hostname);
      }
      }
    }
    {
    {
#line 95
    tmp___4 = strlen((char const   *)(buf___1));
    }
    {
#line 95
    buffer_append(& loginmsg, (void const   *)(buf___1), tmp___4);
    }
    }
  }
#line 98
  return;
}
}
#line 104 "/home/pronto/abs/test-suite/openssh-4.3p2/sshlogin.c"
void record_login(pid_t pid , char const   *tty , char const   *user , uid_t uid ,
                  char const   *host , struct sockaddr *addr , socklen_t addrlen ) 
{ 
  struct logininfo *li ;

  {
  {
  {
#line 111
  store_lastlog_message(user, uid);
  }
  {
#line 113
  li = login_alloc_entry(pid, user, host, tty);
  }
  {
#line 114
  login_set_addr(li, (struct sockaddr  const  *)addr, (unsigned int const   )addrlen);
  }
  {
#line 115
  login_login(li);
  }
  {
#line 116
  login_free_entry(li);
  }
  }
#line 117
  return;
}
}
#line 134 "/home/pronto/abs/test-suite/openssh-4.3p2/sshlogin.c"
void record_logout(pid_t pid , char const   *tty , char const   *user ) 
{ 
  struct logininfo *li ;

  {
  {
  {
#line 139
  li = login_alloc_entry(pid, user, (char const   *)((void *)0), tty);
  }
  {
#line 140
  login_logout(li);
  }
  {
#line 141
  login_free_entry(li);
  }
  }
#line 142
  return;
}
}
#line 282 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 433 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 34 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int openpty(int *__amaster , int *__aslave ,
                                                 char *__name , struct termios *__termp ,
                                                 struct winsize *__winp ) ;
#line 40 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.c"
int pty_allocate(int *ptyfd , int *ttyfd , char *namebuf , int namebuflen ) 
{ 
  char *name ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 47
  i = openpty(ptyfd, ttyfd, (char *)((void *)0), (struct termios *)((void *)0), (struct winsize *)((void *)0));
  }
  }
#line 48
  if (i < 0) {
    {
    {
#line 49
    tmp = __errno_location();
    }
    {
#line 49
    tmp___0 = strerror(*tmp);
    }
    {
#line 49
    error("openpty: %.100s", tmp___0);
    }
    }
#line 50
    return (0);
  }
  {
  {
#line 52
  name = ttyname(*ttyfd);
  }
  }
#line 53
  if (! name) {
    {
    {
#line 54
    fatal("openpty returns device for which ttyname fails.");
    }
    }
  }
  {
  {
#line 56
  strlcpy(namebuf, (char const   *)name, (size_t )namebuflen);
  }
  }
#line 57
  return (1);
}
}
#line 62 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.c"
void pty_release(char const   *tty ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 65
  tmp___1 = chown(tty, (uid_t )0, (gid_t )0);
  }
  }
#line 65
  if (tmp___1 < 0) {
    {
    {
#line 66
    tmp = __errno_location();
    }
    {
#line 66
    tmp___0 = strerror(*tmp);
    }
    {
#line 66
    error("chown %.100s 0 0 failed: %.100s", tty, tmp___0);
    }
    }
  }
  {
  {
#line 67
  tmp___4 = chmod(tty, (mode_t )438);
  }
  }
#line 67
  if (tmp___4 < 0) {
    {
    {
#line 68
    tmp___2 = __errno_location();
    }
    {
#line 68
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 68
    error("chmod %.100s 0666 failed: %.100s", tty, tmp___3);
    }
    }
  }
#line 69
  return;
}
}
#line 73 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.c"
void pty_make_controlling_tty(int *ttyfd , char const   *tty ) 
{ 
  int fd ;
  void *old ;
  int *tmp ;
  char *tmp___0 ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  mysig_t tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 107
  fd = open("/dev/tty", 258);
  }
  }
#line 108
  if (fd >= 0) {
    {
    {
#line 109
    ioctl(fd, 21538UL, (void *)0);
    }
    {
#line 110
    close(fd);
    }
    }
  }
  {
  {
#line 113
  tmp___1 = setsid();
  }
  }
#line 113
  if (tmp___1 < 0) {
    {
    {
#line 114
    tmp = __errno_location();
    }
    {
#line 114
    tmp___0 = strerror(*tmp);
    }
    {
#line 114
    error("setsid: %.100s", tmp___0);
    }
    }
  }
  {
  {
#line 120
  fd = open("/dev/tty", 258);
  }
  }
#line 121
  if (fd >= 0) {
    {
    {
#line 122
    error("Failed to disconnect from controlling tty.");
    }
    {
#line 123
    close(fd);
    }
    }
  }
  {
  {
#line 127
  debug("Setting controlling tty using TIOCSCTTY.");
  }
  {
#line 128
  tmp___4 = ioctl(*ttyfd, 21518UL, (void *)0);
  }
  }
#line 128
  if (tmp___4 < 0) {
    {
    {
#line 129
    tmp___2 = __errno_location();
    }
    {
#line 129
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 129
    error("ioctl(TIOCSCTTY): %.100s", tmp___3);
    }
    }
  }
  {
  {
#line 136
  tmp___5 = mysignal(1, (void (*)(int  ))1);
  }
#line 136
  old = (void *)tmp___5;
  {
#line 137
  vhangup();
  }
  {
#line 138
  mysignal(1, (void (*)(int  ))old);
  }
  {
#line 140
  fd = open(tty, 2);
  }
  }
#line 141
  if (fd < 0) {
    {
    {
#line 142
    tmp___6 = __errno_location();
    }
    {
#line 142
    tmp___7 = strerror(*tmp___6);
    }
    {
#line 142
    error("%.100s: %.100s", tty, tmp___7);
    }
    }
  } else {
    {
    {
#line 145
    close(*ttyfd);
    }
#line 146
    *ttyfd = fd;
    }
  }
  {
  {
#line 152
  fd = open("/dev/tty", 1);
  }
  }
#line 153
  if (fd < 0) {
    {
    {
#line 154
    tmp___8 = __errno_location();
    }
    {
#line 154
    tmp___9 = strerror(*tmp___8);
    }
    {
#line 154
    error("open /dev/tty failed - could not set controlling tty: %.100s", tmp___9);
    }
    }
  } else {
    {
    {
#line 157
    close(fd);
    }
    }
  }
#line 159
  return;
}
}
#line 163 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.c"
void pty_change_window_size(int ptyfd , int row , int col , int xpixel , int ypixel ) 
{ 
  struct winsize w ;

  {
  {
#line 169
  w.ws_row = (unsigned short )row;
#line 170
  w.ws_col = (unsigned short )col;
#line 171
  w.ws_xpixel = (unsigned short )xpixel;
#line 172
  w.ws_ypixel = (unsigned short )ypixel;
  {
#line 173
  ioctl(ptyfd, 21524UL, & w);
  }
  }
#line 174
  return;
}
}
#line 176 "/home/pronto/abs/test-suite/openssh-4.3p2/sshpty.c"
void pty_setowner(struct passwd *pw , char const   *tty ) 
{ 
  struct group *grp ;
  gid_t gid ;
  mode_t mode ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 185
  grp = getgrnam("tty");
  }
  }
#line 186
  if (grp) {
#line 187
    gid = grp->gr_gid;
#line 188
    mode = (mode_t )(384 | (128 >> 3));
  } else {
#line 190
    gid = pw->pw_gid;
#line 191
    mode = (mode_t )((384 | (128 >> 3)) | ((128 >> 3) >> 3));
  }
  {
  {
#line 199
  tmp___1 = stat((char const   */* __restrict  */)tty, (struct stat */* __restrict  */)(& st));
  }
  }
#line 199
  if (tmp___1) {
    {
    {
#line 200
    tmp = __errno_location();
    }
    {
#line 200
    tmp___0 = strerror(*tmp);
    }
    {
#line 200
    fatal("stat(%.100s) failed: %.100s", tty, tmp___0);
    }
    }
  }
#line 203
  if (st.st_uid != pw->pw_uid) {
#line 203
    goto _L;
  } else
#line 203
  if (st.st_gid != gid) {
    _L: /* CIL Label */ 
    {
    {
#line 204
    tmp___7 = chown(tty, pw->pw_uid, gid);
    }
    }
#line 204
    if (tmp___7 < 0) {
      {
      {
#line 205
      tmp___6 = __errno_location();
      }
      }
#line 205
      if (*tmp___6 == 30) {
#line 205
        if (st.st_uid == pw->pw_uid) {
          {
          {
#line 207
          tmp___2 = __errno_location();
          }
          {
#line 207
          tmp___3 = strerror(*tmp___2);
          }
          {
#line 207
          debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid, tmp___3);
          }
          }
        } else
#line 205
        if (st.st_uid == 0U) {
          {
          {
#line 207
          tmp___2 = __errno_location();
          }
          {
#line 207
          tmp___3 = strerror(*tmp___2);
          }
          {
#line 207
          debug("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid, tmp___3);
          }
          }
        } else {
          {
          {
#line 211
          tmp___4 = __errno_location();
          }
          {
#line 211
          tmp___5 = strerror(*tmp___4);
          }
          {
#line 211
          fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid, tmp___5);
          }
          }
        }
      } else {
        {
        {
#line 211
        tmp___4 = __errno_location();
        }
        {
#line 211
        tmp___5 = strerror(*tmp___4);
        }
        {
#line 211
        fatal("chown(%.100s, %u, %u) failed: %.100s", tty, pw->pw_uid, gid, tmp___5);
        }
        }
      }
    }
  }
#line 217
  if ((st.st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
    {
    {
#line 218
    tmp___13 = chmod(tty, mode);
    }
    }
#line 218
    if (tmp___13 < 0) {
      {
      {
#line 219
      tmp___12 = __errno_location();
      }
      }
#line 219
      if (*tmp___12 == 30) {
#line 219
        if ((st.st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) == 0U) {
          {
          {
#line 221
          tmp___8 = __errno_location();
          }
          {
#line 221
          tmp___9 = strerror(*tmp___8);
          }
          {
#line 221
          debug("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___9);
          }
          }
        } else {
          {
          {
#line 224
          tmp___10 = __errno_location();
          }
          {
#line 224
          tmp___11 = strerror(*tmp___10);
          }
          {
#line 224
          fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
          }
          }
        }
      } else {
        {
        {
#line 224
        tmp___10 = __errno_location();
        }
        {
#line 224
        tmp___11 = strerror(*tmp___10);
        }
        {
#line 224
        fatal("chmod(%.100s, 0%o) failed: %.100s", tty, mode, tmp___11);
        }
        }
      }
    }
  }
#line 228
  return;
}
}
#line 105 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
int auth_rhosts(struct passwd *pw , char const   *client_user___0 ) ;
#line 112
int auth_rsa_challenge_dialog(Key *key ) ;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rh-rsa.c"
int auth_rhosts_rsa_key_allowed(struct passwd *pw , char *cuser , char *chost , Key *client_host_key ) 
{ 
  HostStatus host_status ;
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 40
  tmp = auth_rhosts(pw, (char const   *)cuser);
  }
  }
#line 40
  if (! tmp) {
#line 41
    return (0);
  }
#line 43
  if (options.ignore_user_known_hosts) {
#line 43
    tmp___0 = (char const   *)((void *)0);
  } else {
#line 43
    tmp___0 = "~/.ssh/known_hosts";
  }
  {
  {
#line 43
  host_status = check_key_in_hostfiles(pw, client_host_key, (char const   *)chost,
                                       "/usr/local/etc/ssh_known_hosts", tmp___0);
  }
  }
#line 47
  return ((unsigned int )host_status == 0U);
}
}
#line 54 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rh-rsa.c"
int auth_rhosts_rsa(Authctxt *authctxt___0 , char *cuser , Key *client_host_key ) 
{ 
  char *chost ;
  struct passwd *pw ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 58
  pw = authctxt___0->pw;
  {
#line 60
  debug("Trying rhosts with RSA host authentication for client user %.100s", cuser);
  }
  }
#line 63
  if (! authctxt___0->valid) {
#line 65
    return (0);
  } else
#line 63
  if ((unsigned long )client_host_key == (unsigned long )((void *)0)) {
#line 65
    return (0);
  } else
#line 63
  if ((unsigned long )client_host_key->rsa == (unsigned long )((void *)0)) {
#line 65
    return (0);
  }
  {
  {
#line 67
  tmp = get_canonical_hostname(options.use_dns);
  }
#line 67
  chost = (char *)tmp;
  {
#line 68
  debug("Rhosts RSA authentication: canonical host %.900s", chost);
  }
  }
#line 70
  if (use_privsep) {
    {
    {
#line 70
    tmp___0 = mm_auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
    }
#line 70
    tmp___2 = tmp___0;
    }
  } else {
    {
    {
#line 70
    tmp___1 = auth_rhosts_rsa_key_allowed(pw, cuser, chost, client_host_key);
    }
#line 70
    tmp___2 = tmp___1;
    }
  }
#line 70
  if (! tmp___2) {
    {
    {
#line 71
    debug("Rhosts with RSA host authentication denied: unknown or invalid host key");
    }
    {
#line 72
    packet_send_debug("Your host key cannot be verified: unknown or invalid host key.");
    }
    }
#line 73
    return (0);
  }
  {
  {
#line 78
  tmp___3 = auth_rsa_challenge_dialog(client_host_key);
  }
  }
#line 78
  if (! tmp___3) {
    {
    {
#line 79
    logit("Client on %.800s failed to respond correctly to host authentication.",
          chost);
    }
    }
#line 81
    return (0);
  }
  {
  {
#line 88
  verbose("Rhosts with RSA host authentication accepted for %.100s, %.100s on %.700s.",
          pw->pw_name, cuser, chost);
  }
  {
#line 90
  packet_send_debug("Rhosts with RSA host authentication accepted.");
  }
  }
#line 91
  return (1);
}
}
#line 396 "/usr/include/openssl/bn.h"
extern BN_CTX *BN_CTX_new(void) ;
#line 400
extern void BN_CTX_free(BN_CTX *c ) ;
#line 404
extern int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 416
extern int BN_bn2bin(BIGNUM const   *a , unsigned char *to ) ;
#line 436
extern int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM const   *m , BIGNUM const   *d ,
                  BN_CTX *ctx ) ;
#line 460
extern int BN_cmp(BIGNUM const   *a , BIGNUM const   *b ) ;
#line 108 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 109
extern int MD5_Update(MD5_CTX *c , void const   *data , size_t len ) ;
#line 110
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 22 "/home/pronto/abs/test-suite/openssh-4.3p2/rsa.h"
extern void rsa_public_encrypt(BIGNUM * , BIGNUM * , RSA * ) ;
#line 39 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_put_bignum(BIGNUM *value ) ;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/hostfile.h"
extern int hostfile_read_key(char ** , u_int * , Key * ) ;
#line 57 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rsa.c"
BIGNUM *auth_rsa_generate_challenge(Key *key ) 
{ 
  BIGNUM *challenge ;
  BN_CTX *ctx ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 63
  challenge = BN_new();
  }
  }
#line 63
  if ((unsigned long )challenge == (unsigned long )((void *)0)) {
    {
    {
#line 64
    fatal("auth_rsa_generate_challenge: BN_new() failed");
    }
    }
  }
  {
  {
#line 66
  BN_rand(challenge, 256, 0, 0);
  }
  {
#line 67
  ctx = BN_CTX_new();
  }
  }
#line 67
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
    {
#line 68
    fatal("auth_rsa_generate_challenge: BN_CTX_new() failed");
    }
    }
  }
  {
  {
#line 69
  BN_div((BIGNUM *)((void *)0), challenge, (BIGNUM const   *)challenge, (BIGNUM const   *)(key->rsa)->n,
         ctx);
  }
  {
#line 70
  BN_CTX_free(ctx);
  }
  }
#line 72
  return (challenge);
}
}
#line 75 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rsa.c"
int auth_rsa_verify_response(Key *key , BIGNUM *challenge , u_char *response ) 
{ 
  u_char buf___1[32] ;
  u_char mdbuf[16] ;
  MD5_CTX md ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 83
  tmp___0 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
  }
  }
#line 83
  if (tmp___0 < 768) {
    {
    {
#line 84
    tmp = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
    }
    {
#line 84
    error("auth_rsa_verify_response: RSA modulus too small: %d < minimum %d bits",
          tmp, 768);
    }
    }
#line 86
    return (0);
  }
  {
  {
#line 90
  tmp___1 = BN_num_bits((BIGNUM const   *)challenge);
  }
#line 90
  len = (tmp___1 + 7) / 8;
  }
#line 91
  if (len <= 0) {
    {
    {
#line 92
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
    }
  } else
#line 91
  if (len > 32) {
    {
    {
#line 92
    fatal("auth_rsa_verify_response: bad challenge length %d", len);
    }
    }
  }
  {
  {
#line 93
  memset((void *)(buf___1), 0, (size_t )32);
  }
  {
#line 94
  BN_bn2bin((BIGNUM const   *)challenge, (buf___1 + 32) - len);
  }
  {
#line 95
  MD5_Init(& md);
  }
  {
#line 96
  MD5_Update(& md, (void const   *)(buf___1), (size_t )32);
  }
  {
#line 97
  MD5_Update(& md, (void const   *)(session_id), (size_t )16);
  }
  {
#line 98
  MD5_Final(mdbuf, & md);
  }
  {
#line 101
  tmp___2 = memcmp((void const   *)response, (void const   *)(mdbuf), (size_t )16);
  }
  }
#line 101
  if (tmp___2 != 0) {
#line 103
    return (0);
  }
#line 106
  return (1);
}
}
#line 115 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rsa.c"
int auth_rsa_challenge_dialog(Key *key ) 
{ 
  BIGNUM *challenge ;
  BIGNUM *encrypted_challenge ;
  u_char response[16] ;
  int i ;
  int success ;
  BIGNUM *tmp ;
  BIGNUM *tmp___0 ;
  u_int tmp___1 ;
  int _len ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 122
  encrypted_challenge = BN_new();
  }
  }
#line 122
  if ((unsigned long )encrypted_challenge == (unsigned long )((void *)0)) {
    {
    {
#line 123
    fatal("auth_rsa_challenge_dialog: BN_new() failed");
    }
    }
  }
#line 125
  if (use_privsep) {
    {
    {
#line 125
    tmp = mm_auth_rsa_generate_challenge(key);
    }
#line 125
    challenge = tmp;
    }
  } else {
    {
    {
#line 125
    tmp___0 = auth_rsa_generate_challenge(key);
    }
#line 125
    challenge = tmp___0;
    }
  }
  {
  {
#line 128
  rsa_public_encrypt(encrypted_challenge, challenge, key->rsa);
  }
  {
#line 131
  packet_start((u_char )7);
  }
  {
#line 132
  packet_put_bignum(encrypted_challenge);
  }
  {
#line 133
  packet_send();
  }
  {
#line 134
  BN_clear_free(encrypted_challenge);
  }
  {
#line 135
  packet_write_wait();
  }
  {
#line 138
  packet_read_expect(8);
  }
#line 139
  i = 0;
  }
  {
  {
#line 139
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < 16)) {
#line 139
      goto while_break;
    }
    {
    {
#line 140
    tmp___1 = packet_get_char();
    }
#line 140
    response[i] = (u_char )tmp___1;
#line 139
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 141
    tmp___2 = packet_remaining();
    }
#line 141
    _len = tmp___2;
    }
#line 141
    if (_len > 0) {
      {
      {
#line 141
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rsa.c",
            141);
      }
      {
#line 141
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 141
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  if (use_privsep) {
    {
    {
#line 143
    tmp___3 = mm_auth_rsa_verify_response(key, challenge, response);
    }
#line 143
    success = tmp___3;
    }
  } else {
    {
    {
#line 143
    tmp___4 = auth_rsa_verify_response(key, challenge, (u_char *)(response));
    }
#line 143
    success = tmp___4;
    }
  }
  {
  {
#line 144
  BN_clear_free(challenge);
  }
  }
#line 145
  return (success);
}
}
#line 153 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rsa.c"
int auth_rsa_key_allowed(struct passwd *pw , BIGNUM *client_n , Key **rkey ) 
{ 
  char line[8192] ;
  char *file ;
  int allowed ;
  u_int bits ;
  FILE *f ;
  u_long linenum ;
  struct stat st ;
  Key *key ;
  int tmp ;
  int tmp___0 ;
  char *cp ;
  char *key_options ;
  int keybits ;
  int quoted ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 157
  allowed = 0;
#line 160
  linenum = (u_long )0;
  {
#line 165
  temporarily_use_uid(pw);
  }
  {
#line 168
  file = authorized_keys_file(pw);
  }
  {
#line 169
  debug("trying public RSA key file %s", file);
  }
  {
#line 172
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
  }
#line 172
  if (tmp < 0) {
    {
    {
#line 174
    restore_uid();
    }
    {
#line 175
    xfree((void *)file);
    }
    }
#line 176
    return (0);
  }
  {
  {
#line 179
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
  }
#line 180
  if (! f) {
    {
    {
#line 182
    restore_uid();
    }
    {
#line 183
    xfree((void *)file);
    }
    }
#line 184
    return (0);
  }
#line 186
  if (options.strict_modes) {
    {
    {
#line 186
    tmp___0 = secure_filename(f, (char const   *)file, pw, line, (size_t )sizeof(line));
    }
    }
#line 186
    if (tmp___0 != 0) {
      {
      {
#line 188
      xfree((void *)file);
      }
      {
#line 189
      fclose(f);
      }
      {
#line 190
      logit("Authentication refused: %s", line);
      }
      {
#line 191
      restore_uid();
      }
      }
#line 192
      return (0);
    }
  }
  {
#line 196
  allowed = 0;
  {
#line 198
  key = key_new(0);
  }
  }
  {
  {
#line 205
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 205
    tmp___5 = read_keyfile_line(f, (char const   *)file, line, (size_t )sizeof(line),
                                & linenum);
    }
    }
#line 205
    if (! (tmp___5 != -1)) {
#line 205
      goto while_break;
    }
#line 211
    cp = line;
    {
    {
#line 211
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! ((int )*cp == 32)) {
#line 211
        if (! ((int )*cp == 9)) {
#line 211
          goto while_break___0;
        }
      }
#line 211
      cp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 213
    if (! *cp) {
#line 214
      goto while_continue;
    } else
#line 213
    if ((int )*cp == 10) {
#line 214
      goto while_continue;
    } else
#line 213
    if ((int )*cp == 35) {
#line 214
      goto while_continue;
    }
#line 222
    if ((int )*cp < 48) {
#line 222
      goto _L___0;
    } else
#line 222
    if ((int )*cp > 57) {
      _L___0: /* CIL Label */ 
#line 223
      quoted = 0;
#line 224
      key_options = cp;
      {
      {
#line 225
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 225
        if (*cp) {
#line 225
          if (! quoted) {
#line 225
            if ((int )*cp != 32) {
#line 225
              if (! ((int )*cp != 9)) {
#line 225
                goto while_break___1;
              }
            } else {
#line 225
              goto while_break___1;
            }
          }
        } else {
#line 225
          goto while_break___1;
        }
#line 226
        if ((int )*cp == 92) {
#line 226
          if ((int )*(cp + 1) == 34) {
#line 227
            cp ++;
          } else {
#line 226
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 228
        if ((int )*cp == 34) {
#line 229
          quoted = ! quoted;
        }
#line 225
        cp ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 232
      key_options = (char *)((void *)0);
    }
    {
    {
#line 235
    tmp___1 = hostfile_read_key(& cp, & bits, key);
    }
    }
#line 235
    if (tmp___1 == 0) {
      {
      {
#line 236
      debug("%.100s, line %lu: non ssh1 key syntax", file, linenum);
      }
      }
#line 238
      goto while_continue;
    }
    {
    {
#line 243
    tmp___2 = BN_cmp((BIGNUM const   *)(key->rsa)->n, (BIGNUM const   *)client_n);
    }
    }
#line 243
    if (tmp___2 != 0) {
#line 244
      goto while_continue;
    }
    {
    {
#line 247
    keybits = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
    }
    }
#line 248
    if (keybits < 0) {
      {
      {
#line 249
      tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
      }
      {
#line 249
      logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
            file, linenum, tmp___3, bits);
      }
      }
    } else
#line 248
    if (bits != (u_int )keybits) {
      {
      {
#line 249
      tmp___3 = BN_num_bits((BIGNUM const   *)(key->rsa)->n);
      }
      {
#line 249
      logit("Warning: %s, line %lu: keysize mismatch: actual %d vs. announced %d.",
            file, linenum, tmp___3, bits);
      }
      }
    }
    {
    {
#line 258
    tmp___4 = auth_parse_options(pw, key_options, file, linenum);
    }
    }
#line 258
    if (! tmp___4) {
#line 259
      goto while_continue;
    }
#line 262
    allowed = 1;
#line 263
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 267
  restore_uid();
  }
  {
#line 270
  xfree((void *)file);
  }
  {
#line 271
  fclose(f);
  }
  }
#line 274
  if (allowed) {
#line 274
    if ((unsigned long )rkey != (unsigned long )((void *)0)) {
#line 275
      *rkey = key;
    } else {
      {
      {
#line 277
      key_free(key);
      }
      }
    }
  } else {
    {
    {
#line 277
    key_free(key);
    }
    }
  }
#line 278
  return (allowed);
}
}
#line 286 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rsa.c"
int auth_rsa(Authctxt *authctxt___0 , BIGNUM *client_n ) 
{ 
  Key *key ;
  char *fp ;
  struct passwd *pw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 291
  pw = authctxt___0->pw;
#line 294
  if (! authctxt___0->valid) {
#line 295
    return (0);
  }
#line 297
  if (use_privsep) {
    {
    {
#line 297
    tmp = mm_auth_rsa_key_allowed(pw, client_n, & key);
    }
#line 297
    tmp___1 = tmp;
    }
  } else {
    {
    {
#line 297
    tmp___0 = auth_rsa_key_allowed(pw, client_n, & key);
    }
#line 297
    tmp___1 = tmp___0;
    }
  }
#line 297
  if (! tmp___1) {
    {
    {
#line 298
    auth_clear_options();
    }
    }
#line 299
    return (0);
  }
  {
  {
#line 303
  tmp___2 = auth_rsa_challenge_dialog(key);
  }
  }
#line 303
  if (! tmp___2) {
    {
    {
#line 305
    verbose("Wrong response to RSA authentication challenge.");
    }
    {
#line 306
    packet_send_debug("Wrong response to RSA authentication challenge.");
    }
    {
#line 311
    key_free(key);
    }
    }
#line 312
    return (0);
  }
  {
  {
#line 320
  fp = key_fingerprint((Key const   *)key, (enum fp_type )1, (enum fp_rep )0);
  }
  {
#line 321
  tmp___3 = key_type((Key const   *)key);
  }
  {
#line 321
  verbose("Found matching %s key: %s", tmp___3, fp);
  }
  {
#line 323
  xfree((void *)fp);
  }
  {
#line 324
  key_free(key);
  }
  {
#line 326
  packet_send_debug("RSA authentication accepted.");
  }
  }
#line 327
  return (1);
}
}
#line 176 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/openbsd-compat.h"
extern char *xcrypt(char const   *password , char const   *salt ) ;
#line 177
extern char *shadow_pw(struct passwd *pw ) ;
#line 138 "/home/pronto/abs/test-suite/openssh-4.3p2/auth.h"
void disable_forwarding(void) ;
#line 189
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) ;
#line 59 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-passwd.c"
void disable_forwarding(void) 
{ 


  {
#line 62
  no_port_forwarding_flag = 1;
#line 63
  no_agent_forwarding_flag = 1;
#line 64
  no_x11_forwarding_flag = 1;
#line 65
  return;
}
}
#line 77 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-passwd.c"
static int expire_checked  =    0;
#line 71 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-passwd.c"
int auth_password(Authctxt *authctxt___0 , char const   *password ) 
{ 
  struct passwd *pw ;
  int result ;
  int ok ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  pw = authctxt___0->pw;
#line 75
  ok = authctxt___0->valid;
#line 81
  if (pw->pw_uid == 0U) {
#line 81
    if (options.permit_root_login != 3) {
#line 82
      ok = 0;
    }
  }
#line 84
  if ((int const   )*password == 0) {
#line 84
    if (options.permit_empty_passwd == 0) {
#line 85
      return (0);
    }
  }
#line 110
  if (! expire_checked) {
    {
#line 111
    expire_checked = 1;
    {
#line 112
    tmp = auth_shadow_pwexpired(authctxt___0);
    }
    }
#line 112
    if (tmp) {
#line 113
      authctxt___0->force_pwchange = 1;
    }
  }
  {
  {
#line 116
  result = sys_auth_passwd(authctxt___0, password);
  }
  }
#line 117
  if (authctxt___0->force_pwchange) {
    {
    {
#line 118
    disable_forwarding();
    }
    }
  }
#line 119
  if (result) {
#line 119
    if (ok) {
#line 119
      tmp___0 = 1;
    } else {
#line 119
      tmp___0 = 0;
    }
  } else {
#line 119
    tmp___0 = 0;
  }
#line 119
  return (tmp___0);
}
}
#line 182 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-passwd.c"
int sys_auth_passwd(Authctxt *authctxt___0 , char const   *password ) 
{ 
  struct passwd *pw ;
  char *encrypted_password ;
  char *pw_password ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 185
  pw = authctxt___0->pw;
#line 189
  if (authctxt___0->valid) {
    {
    {
#line 189
    tmp = shadow_pw(pw);
    }
#line 189
    tmp___0 = tmp;
    }
  } else {
#line 189
    tmp___0 = pw->pw_passwd;
  }
  {
#line 189
  pw_password = tmp___0;
  {
#line 192
  tmp___1 = strcmp((char const   *)pw_password, "");
  }
  }
#line 192
  if (tmp___1 == 0) {
    {
    {
#line 192
    tmp___2 = strcmp(password, "");
    }
    }
#line 192
    if (tmp___2 == 0) {
#line 193
      return (1);
    }
  }
#line 196
  if (*(pw_password + 0)) {
#line 196
    if (*(pw_password + 1)) {
#line 196
      tmp___3 = (char const   *)pw_password;
    } else {
#line 196
      tmp___3 = "xx";
    }
  } else {
#line 196
    tmp___3 = "xx";
  }
  {
  {
#line 196
  encrypted_password = xcrypt(password, tmp___3);
  }
  {
#line 203
  tmp___4 = strcmp((char const   *)encrypted_password, (char const   *)pw_password);
  }
  }
#line 203
  return (tmp___4 == 0);
}
}
#line 418 "/usr/include/netdb.h"
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *domain ) ;
#line 37 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rhosts.c"
static int check_rhosts_file(char const   *filename , char const   *hostname , char const   *ipaddr ,
                             char const   *client_user___0 , char const   *server_user ) 
{ 
  FILE *f ;
  char buf___1[1024] ;
  char hostbuf[1024] ;
  char userbuf[1024] ;
  char dummy[1024] ;
  char *host ;
  char *user ;
  char *cp ;
  int negated ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 46
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
  }
#line 47
  if (! f) {
#line 48
    return (0);
  }
  {
  {
#line 50
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 50
    tmp___7 = fgets((char */* __restrict  */)(buf___1), (int )sizeof(buf___1), (FILE */* __restrict  */)f);
    }
    }
#line 50
    if (! tmp___7) {
#line 50
      goto while_break;
    }
#line 55
    cp = buf___1;
    {
    {
#line 55
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 55
      if (! ((int )*cp == 32)) {
#line 55
        if (! ((int )*cp == 9)) {
#line 55
          goto while_break___0;
        }
      }
#line 55
      cp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 57
    if ((int )*cp == 35) {
#line 58
      goto while_continue;
    } else
#line 57
    if ((int )*cp == 10) {
#line 58
      goto while_continue;
    } else
#line 57
    if (! *cp) {
#line 58
      goto while_continue;
    }
    {
    {
#line 64
    tmp = strncmp((char const   *)cp, "NO_PLUS", (size_t )7);
    }
    }
#line 64
    if (tmp == 0) {
#line 65
      goto while_continue;
    }
    {
    {
#line 71
    tmp___0 = sscanf((char const   */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%1023s %1023s %1023s",
                     hostbuf, userbuf, dummy);
    }
    }
    {
#line 73
    if (tmp___0 == 0) {
#line 73
      goto case_0;
    }
#line 76
    if (tmp___0 == 1) {
#line 76
      goto case_1;
    }
#line 80
    if (tmp___0 == 2) {
#line 80
      goto case_2;
    }
#line 83
    if (tmp___0 == 3) {
#line 83
      goto case_3;
    }
#line 86
    goto switch_default;
    case_0: /* CIL Label */ 
    {
    {
#line 74
    auth_debug_add("Found empty line in %.100s.", filename);
    }
    }
#line 75
    goto while_continue;
    case_1: /* CIL Label */ 
    {
    {
#line 78
    strlcpy(userbuf, server_user, (size_t )sizeof(userbuf));
    }
    }
#line 79
    goto switch_break;
    case_2: /* CIL Label */ 
#line 82
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 84
    auth_debug_add("Found garbage in %.100s.", filename);
    }
    }
#line 85
    goto while_continue;
    switch_default: /* CIL Label */ 
#line 88
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
#line 91
    host = hostbuf;
#line 92
    user = userbuf;
#line 93
    negated = 0;
#line 96
    if ((int )*(host + 0) == 45) {
#line 97
      negated = 1;
#line 98
      host ++;
    } else
#line 99
    if ((int )*(host + 0) == 43) {
#line 100
      host ++;
    }
#line 102
    if ((int )*(user + 0) == 45) {
#line 103
      negated = 1;
#line 104
      user ++;
    } else
#line 105
    if ((int )*(user + 0) == 43) {
#line 106
      user ++;
    }
#line 109
    if (! *(host + 0)) {
      {
      {
#line 111
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
      }
      }
#line 113
      goto while_continue;
    } else
#line 109
    if (! *(user + 0)) {
      {
      {
#line 111
      auth_debug_add("Ignoring wild host/user names in %.100s.", filename);
      }
      }
#line 113
      goto while_continue;
    }
#line 116
    if ((int )*(host + 0) == 64) {
      {
      {
#line 117
      tmp___1 = innetgr((char const   *)(host + 1), hostname, (char const   *)((void *)0),
                        (char const   *)((void *)0));
      }
      }
#line 117
      if (! tmp___1) {
        {
        {
#line 117
        tmp___2 = innetgr((char const   *)(host + 1), ipaddr, (char const   *)((void *)0),
                          (char const   *)((void *)0));
        }
        }
#line 117
        if (! tmp___2) {
#line 119
          goto while_continue;
        }
      }
    } else {
      {
      {
#line 120
      tmp___3 = strcasecmp((char const   *)host, hostname);
      }
      }
#line 120
      if (tmp___3) {
        {
        {
#line 120
        tmp___4 = strcmp((char const   *)host, ipaddr);
        }
        }
#line 120
        if (tmp___4 != 0) {
#line 121
          goto while_continue;
        }
      }
    }
#line 124
    if ((int )*(user + 0) == 64) {
      {
      {
#line 125
      tmp___5 = innetgr((char const   *)(user + 1), (char const   *)((void *)0), client_user___0,
                        (char const   *)((void *)0));
      }
      }
#line 125
      if (! tmp___5) {
#line 126
        goto while_continue;
      }
    } else {
      {
      {
#line 127
      tmp___6 = strcmp((char const   *)user, client_user___0);
      }
      }
#line 127
      if (tmp___6 != 0) {
#line 128
        goto while_continue;
      }
    }
    {
    {
#line 131
    fclose(f);
    }
    }
#line 134
    if (negated) {
      {
      {
#line 135
      auth_debug_add("Matched negative entry in %.100s.", filename);
      }
      }
#line 137
      return (0);
    }
#line 140
    return (1);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 144
  fclose(f);
  }
  }
#line 145
  return (0);
}
}
#line 154 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rhosts.c"
int auth_rhosts(struct passwd *pw , char const   *client_user___0 ) 
{ 
  char const   *hostname ;
  char const   *ipaddr ;
  int tmp ;

  {
  {
  {
#line 159
  hostname = get_canonical_hostname(options.use_dns);
  }
  {
#line 160
  ipaddr = get_remote_ipaddr();
  }
  {
#line 161
  tmp = auth_rhosts2(pw, client_user___0, hostname, ipaddr);
  }
  }
#line 161
  return (tmp);
}
}
#line 170
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                            char const   *ipaddr ) ;
#line 170 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rhosts.c"
static char const   *rhosts_files[3]  = {      ".shosts",      ".rhosts",      (char const   *)((void *)0)};
#line 164 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rhosts.c"
static int auth_rhosts2_raw(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                            char const   *ipaddr ) 
{ 
  char buf___1[1024] ;
  struct stat st ;
  u_int rhosts_file_index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
  {
#line 173
  debug2("auth_rhosts2: clientuser %s hostname %s ipaddr %s", client_user___0, hostname,
         ipaddr);
  }
  {
#line 177
  temporarily_use_uid(pw);
  }
#line 183
  rhosts_file_index = (u_int )0;
  }
  {
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 183
    if (! rhosts_files[rhosts_file_index]) {
#line 183
      goto while_break;
    }
    {
    {
#line 186
    snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
    }
    {
#line 188
    tmp = stat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)(& st));
    }
    }
#line 188
    if (tmp >= 0) {
#line 189
      goto while_break;
    }
#line 183
    rhosts_file_index ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 192
  restore_uid();
  }
  }
#line 195
  if (! rhosts_files[rhosts_file_index]) {
    {
    {
#line 195
    tmp___0 = stat((char const   */* __restrict  */)"/etc/hosts.equiv", (struct stat */* __restrict  */)(& st));
    }
    }
#line 195
    if (tmp___0 < 0) {
      {
      {
#line 195
      tmp___1 = stat((char const   */* __restrict  */)"/usr/local/etc/shosts.equiv",
                     (struct stat */* __restrict  */)(& st));
      }
      }
#line 195
      if (tmp___1 < 0) {
#line 198
        return (0);
      }
    }
  }
#line 201
  if (pw->pw_uid != 0U) {
    {
    {
#line 202
    tmp___2 = check_rhosts_file("/etc/hosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw->pw_name);
    }
    }
#line 202
    if (tmp___2) {
      {
      {
#line 204
      auth_debug_add("Accepted for %.100s [%.100s] by /etc/hosts.equiv.", hostname,
                     ipaddr);
      }
      }
#line 206
      return (1);
    }
    {
    {
#line 208
    tmp___3 = check_rhosts_file("/usr/local/etc/shosts.equiv", hostname, ipaddr, client_user___0,
                                (char const   *)pw->pw_name);
    }
    }
#line 208
    if (tmp___3) {
      {
      {
#line 210
      auth_debug_add("Accepted for %.100s [%.100s] by %.100s.", hostname, ipaddr,
                     "/usr/local/etc/shosts.equiv");
      }
      }
#line 212
      return (1);
    }
  }
  {
  {
#line 219
  tmp___4 = stat((char const   */* __restrict  */)pw->pw_dir, (struct stat */* __restrict  */)(& st));
  }
  }
#line 219
  if (tmp___4 < 0) {
    {
    {
#line 220
    logit("Rhosts authentication refused for %.100s: no home directory %.200s", pw->pw_name,
          pw->pw_dir);
    }
    {
#line 222
    auth_debug_add("Rhosts authentication refused for %.100s: no home directory %.200s",
                   pw->pw_name, pw->pw_dir);
    }
    }
#line 224
    return (0);
  }
#line 226
  if (options.strict_modes) {
#line 226
    if (st.st_uid != 0U) {
#line 226
      if (st.st_uid != pw->pw_uid) {
        {
        {
#line 229
        logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
              pw->pw_name);
        }
        {
#line 231
        auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                       pw->pw_name);
        }
        }
#line 233
        return (0);
      } else {
#line 226
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 226
    if ((st.st_mode & 18U) != 0U) {
      {
      {
#line 229
      logit("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
            pw->pw_name);
      }
      {
#line 231
      auth_debug_add("Rhosts authentication refused for %.100s: bad ownership or modes for home directory.",
                     pw->pw_name);
      }
      }
#line 233
      return (0);
    }
  }
  {
  {
#line 236
  temporarily_use_uid(pw);
  }
#line 239
  rhosts_file_index = (u_int )0;
  }
  {
  {
#line 239
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 239
    if (! rhosts_files[rhosts_file_index]) {
#line 239
      goto while_break___0;
    }
    {
    {
#line 242
    snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"%.500s/%.100s",
             pw->pw_dir, rhosts_files[rhosts_file_index]);
    }
    {
#line 244
    tmp___5 = stat((char const   */* __restrict  */)(buf___1), (struct stat */* __restrict  */)(& st));
    }
    }
#line 244
    if (tmp___5 < 0) {
#line 245
      goto __Cont;
    }
#line 253
    if (options.strict_modes) {
#line 253
      if (st.st_uid != 0U) {
#line 253
        if (st.st_uid != pw->pw_uid) {
          {
          {
#line 256
          logit("Rhosts authentication refused for %.100s: bad modes for %.200s",
                pw->pw_name, buf___1);
          }
          {
#line 258
          auth_debug_add("Bad file modes for %.200s", buf___1);
          }
          }
#line 259
          goto __Cont;
        } else {
#line 253
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 253
      if ((st.st_mode & 18U) != 0U) {
        {
        {
#line 256
        logit("Rhosts authentication refused for %.100s: bad modes for %.200s", pw->pw_name,
              buf___1);
        }
        {
#line 258
        auth_debug_add("Bad file modes for %.200s", buf___1);
        }
        }
#line 259
        goto __Cont;
      }
    }
#line 262
    if (options.ignore_rhosts) {
      {
      {
#line 263
      auth_debug_add("Server has been configured to ignore %.100s.", rhosts_files[rhosts_file_index]);
      }
      }
#line 265
      goto __Cont;
    }
    {
    {
#line 268
    tmp___6 = check_rhosts_file((char const   *)(buf___1), hostname, ipaddr, client_user___0,
                                (char const   *)pw->pw_name);
    }
    }
#line 268
    if (tmp___6) {
      {
      {
#line 269
      auth_debug_add("Accepted by %.100s.", rhosts_files[rhosts_file_index]);
      }
      {
#line 272
      restore_uid();
      }
      {
#line 273
      auth_debug_add("Accepted host %s ip %s client_user %s server_user %s", hostname,
                     ipaddr, client_user___0, pw->pw_name);
      }
      }
#line 275
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 239
    rhosts_file_index ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 280
  restore_uid();
  }
  }
#line 281
  return (0);
}
}
#line 284 "/home/pronto/abs/test-suite/openssh-4.3p2/auth-rhosts.c"
int auth_rhosts2(struct passwd *pw , char const   *client_user___0 , char const   *hostname ,
                 char const   *ipaddr ) 
{ 
  int ret ;

  {
  {
  {
#line 290
  auth_debug_reset();
  }
  {
#line 291
  ret = auth_rhosts2_raw(pw, client_user___0, hostname, ipaddr);
  }
  }
#line 292
  if (! use_privsep) {
    {
    {
#line 293
    auth_debug_send();
    }
    }
  }
#line 294
  return (ret);
}
}
#line 567 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 178 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int setgroups(size_t __n , __gid_t const   *__groups ) ;
#line 393 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 516
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execv)(char const   *__path ,
                                                                                  char * const  *__argv ) ;
#line 548
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chroot)(char const   *__path ) ;
#line 193 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 210
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 637 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 646
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
#line 52 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/openbsd-compat.h"
extern void closefrom(int  ) ;
#line 117
extern void compat_init_setproctitle(int argc , char **argv ) ;
#line 126
extern int BSDgetopt(int argc , char * const  *argv , char const   *opts ) ;
#line 24 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/bsd-misc.h"
extern char *ssh_get_progname(char * ) ;
#line 141 "/home/pronto/abs/test-suite/openssh-4.3p2/openbsd-compat/openbsd-compat.h"
extern unsigned int arc4random(void) ;
#line 142
extern void arc4random_stir(void) ;
#line 207 "./channels.h"
extern void channel_set_af(int af ) ;
#line 32 "/home/pronto/abs/test-suite/openssh-4.3p2/entropy.h"
extern void seed_rng(void) ;
#line 33
extern void init_rng(void) ;
#line 380 "/usr/include/openssl/crypto.h"
extern char const   *SSLeay_version(int type ) ;
#line 481 "/usr/include/openssl/bn.h"
extern int BN_mask_bits(BIGNUM *a , int n ) ;
#line 104 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 23 "/home/pronto/abs/test-suite/openssh-4.3p2/rsa.h"
extern int rsa_private_decrypt(BIGNUM * , BIGNUM * , RSA * ) ;
#line 24
extern void rsa_generate_additional_parameters(RSA * ) ;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/packet.h"
extern void packet_set_connection(int  , int  ) ;
#line 22
extern void packet_set_nonblocking(void) ;
#line 25
extern void packet_close(void) ;
#line 33
extern void packet_set_server(void) ;
#line 34
extern void packet_set_authenticated(void) ;
#line 60 "/home/pronto/abs/test-suite/openssh-4.3p2/compat.h"
extern void enable_compat13(void) ;
#line 61
extern void enable_compat20(void) ;
#line 62
extern void compat_datafellows(char const   * ) ;
#line 64
extern char *compat_cipher_proposal(char * ) ;
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/bufaux.h"
extern void buffer_put_bignum(Buffer * , BIGNUM const   * ) ;
#line 23
extern void buffer_get_bignum(Buffer * , BIGNUM * ) ;
#line 777 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 71 "/home/pronto/abs/test-suite/openssh-4.3p2/cipher.h"
extern u_int cipher_mask_ssh1(int  ) ;
#line 75
extern char *cipher_name(int  ) ;
#line 59 "/home/pronto/abs/test-suite/openssh-4.3p2/key.h"
extern Key *key_new_private(int  ) ;
#line 61
extern Key *key_demote(Key const   * ) ;
#line 70
extern Key *key_generate(int  , u_int  ) ;
#line 76
extern char const   *key_ssh_name(Key const   * ) ;
#line 126 "/home/pronto/abs/test-suite/openssh-4.3p2/kex.h"
extern Kex *kex_setup(char ** ) ;
#line 148
extern void derive_ssh1_session_id(BIGNUM * , BIGNUM * , u_int8_t * , u_int8_t * ) ;
#line 43 "/home/pronto/abs/test-suite/openssh-4.3p2/myproposal.h"
static char *myproposal[10]  = 
#line 43 "/home/pronto/abs/test-suite/openssh-4.3p2/myproposal.h"
  {      (char *)"diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1",      (char *)"ssh-rsa,ssh-dss",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr",      (char *)"aes128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctr", 
        (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"hmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96",      (char *)"none,zlib@openssh.com,zlib",      (char *)"none,zlib@openssh.com,zlib", 
        (char *)"",      (char *)""};
#line 21 "/home/pronto/abs/test-suite/openssh-4.3p2/authfile.h"
extern Key *key_load_private(char const   * , char const   * , char ** ) ;
#line 17 "/home/pronto/abs/test-suite/openssh-4.3p2/misc.h"
extern char *chop(char * ) ;
#line 20
extern int unset_nonblock(int  ) ;
#line 31
extern void sanitise_stdfd(void) ;
#line 28 "/home/pronto/abs/test-suite/openssh-4.3p2/msg.h"
extern int ssh_msg_send(int  , u_char  , Buffer * ) ;
#line 29
extern int ssh_msg_recv(int  , Buffer * ) ;
#line 33 "/home/pronto/abs/test-suite/openssh-4.3p2/monitor_wrap.h"
int use_privsep  ;
#line 109 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
ServerOptions options  ;
#line 112 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
char *config_file_name  =    (char *)"/usr/local/etc/sshd_config";
#line 120 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int debug_flag  =    0;
#line 123 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int test_flag  =    0;
#line 126 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int inetd_flag  =    0;
#line 129 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int no_daemon_flag  =    0;
#line 132 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int log_stderr  =    0;
#line 135 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
char **saved_argv  ;
#line 136 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int saved_argc  ;
#line 139 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int rexeced_flag  =    0;
#line 140 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int rexec_flag  =    1;
#line 141 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int rexec_argc  =    0;
#line 142 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
char **rexec_argv  ;
#line 149 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int listen_socks[16]  ;
#line 150 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int num_listen_socks  =    0;
#line 156 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
char *client_version_string  =    (char *)((void *)0);
#line 157 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
char *server_version_string  =    (char *)((void *)0);
#line 160 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
Kex *xxx_kex  ;
#line 170 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
struct __anonstruct_sensitive_data_82 sensitive_data  ;
#line 183 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static int volatile   key_do_regen  =    (sig_atomic_t volatile   )0;
#line 186 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static int volatile   received_sighup  =    (sig_atomic_t volatile   )0;
#line 187 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static int volatile   received_sigterm___0  =    (sig_atomic_t volatile   )0;
#line 190 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
u_char session_id[16]  ;
#line 193 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
u_char *session_id2  =    (u_char *)((void *)0);
#line 194 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
u_int session_id2_len  =    (u_int )0;
#line 197 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
u_int utmp_len  =    (u_int )64;
#line 200 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int *startup_pipes  =    (int *)((void *)0);
#line 201 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int startup_pipe  ;
#line 205 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
struct monitor *pmonitor  =    (struct monitor *)((void *)0);
#line 208 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
Authctxt *the_authctxt  =    (Authctxt *)((void *)0);
#line 211 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
Buffer loginmsg  ;
#line 215
void demote_sensitive_data(void) ;
#line 217
static void do_ssh1_kex(void) ;
#line 218
static void do_ssh2_kex(void) ;
#line 223 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void close_listen_socks(void) 
{ 
  int i ;

  {
#line 228
  i = 0;
  {
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < num_listen_socks)) {
#line 228
      goto while_break;
    }
    {
    {
#line 229
    close(listen_socks[i]);
    }
#line 228
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  num_listen_socks = -1;
#line 231
  return;
}
}
#line 233 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void close_startup_pipes(void) 
{ 
  int i ;

  {
#line 238
  if (startup_pipes) {
#line 239
    i = 0;
    {
    {
#line 239
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 239
      if (! (i < options.max_startups)) {
#line 239
        goto while_break;
      }
#line 240
      if (*(startup_pipes + i) != -1) {
        {
        {
#line 241
        close(*(startup_pipes + i));
        }
        }
      }
#line 239
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 242
  return;
}
}
#line 249 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void sighup_handler(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
  {
#line 252
  tmp = __errno_location();
  }
#line 252
  save_errno = *tmp;
#line 254
  received_sighup = (int volatile   )1;
  {
#line 255
  mysignal(1, & sighup_handler);
  }
  {
#line 256
  tmp___0 = __errno_location();
  }
#line 256
  *tmp___0 = save_errno;
  }
#line 257
  return;
}
}
#line 263 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void sighup_restart(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 266
  logit("Received SIGHUP; restarting.");
  }
  {
#line 267
  close_listen_socks();
  }
  {
#line 268
  close_startup_pipes();
  }
  {
#line 269
  execv((char const   *)*(saved_argv + 0), (char * const  *)saved_argv);
  }
  {
#line 270
  tmp = __errno_location();
  }
  {
#line 270
  tmp___0 = strerror(*tmp);
  }
  {
#line 270
  logit("RESTART FAILED: av[0]=\'%.100s\', error: %.100s.", *(saved_argv + 0), tmp___0);
  }
  {
#line 272
  exit(1);
  }
  }
}
}
#line 278 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void sigterm_handler___0(int sig ) 
{ 


  {
#line 281
  received_sigterm___0 = (int volatile   )sig;
#line 282
  return;
}
}
#line 288 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void main_sigchld_handler(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  pid_t pid ;
  int status ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
  {
#line 291
  tmp = __errno_location();
  }
#line 291
  save_errno = *tmp;
  }
  {
  {
#line 295
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 295
    pid = waitpid(-1, & status, 1);
    }
    }
#line 295
    if (! (pid > 0)) {
#line 295
      if (pid < 0) {
        {
        {
#line 295
        tmp___0 = __errno_location();
        }
        }
#line 295
        if (! (*tmp___0 == 4)) {
#line 295
          goto while_break;
        }
      } else {
#line 295
        goto while_break;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 299
  mysignal(17, & main_sigchld_handler);
  }
  {
#line 300
  tmp___1 = __errno_location();
  }
#line 300
  *tmp___1 = save_errno;
  }
#line 301
  return;
}
}
#line 306 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void grace_alarm_handler(int sig ) 
{ 
  char const   *tmp ;
  char *__cil_tmp3 ;

  {
#line 311
  if (use_privsep) {
#line 311
    if ((unsigned long )pmonitor != (unsigned long )((void *)0)) {
#line 311
      if (pmonitor->m_pid > 0) {
        {
        {
#line 312
        kill(pmonitor->m_pid, 14);
        }
        }
      }
    }
  }
  {
  {
#line 315
  tmp = get_remote_ipaddr();
  }
  {
#line 315
  fatal("Timeout before authentication for %s", tmp);
  }
  }
}
}
#line 325 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void generate_ephemeral_server_key(void) 
{ 
  u_int32_t rnd ;
  int i ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 328
  rnd = (u_int32_t )0;
#line 331
  if (sensitive_data.server_key) {
#line 331
    tmp = "new ";
  } else {
#line 331
    tmp = "";
  }
  {
  {
#line 331
  verbose("Generating %s%d bit RSA key.", tmp, options.server_key_bits);
  }
  }
#line 333
  if ((unsigned long )sensitive_data.server_key != (unsigned long )((void *)0)) {
    {
    {
#line 334
    key_free(sensitive_data.server_key);
    }
    }
  }
  {
  {
#line 335
  sensitive_data.server_key = key_generate(0, (u_int )options.server_key_bits);
  }
  {
#line 337
  verbose("RSA key generation complete.");
  }
#line 339
  i = 0;
  }
  {
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i < 32)) {
#line 339
      goto while_break;
    }
#line 340
    if (i % 4 == 0) {
      {
      {
#line 341
      rnd = arc4random();
      }
      }
    }
#line 342
    sensitive_data.ssh1_cookie[i] = (u_char )(rnd & 255U);
#line 343
    rnd >>= 8;
#line 339
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 345
  arc4random_stir();
  }
  }
#line 346
  return;
}
}
#line 348 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void key_regeneration_alarm(int sig ) 
{ 
  int save_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
  {
#line 351
  tmp = __errno_location();
  }
#line 351
  save_errno = *tmp;
  {
#line 353
  mysignal(14, (void (*)(int  ))0);
  }
  {
#line 354
  tmp___0 = __errno_location();
  }
#line 354
  *tmp___0 = save_errno;
#line 355
  key_do_regen = (int volatile   )1;
  }
#line 356
  return;
}
}
#line 358 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void sshd_exchange_identification(int sock_in , int sock_out ) 
{ 
  u_int i ;
  int mismatch ;
  int remote_major ;
  int remote_minor ;
  int major ;
  int minor ;
  char *s ;
  char buf___1[256] ;
  char remote_version[256] ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  char const   *tmp___12 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 369
  if (options.protocol & 1) {
#line 369
    if (options.protocol & 4) {
#line 371
      major = 1;
#line 372
      minor = 99;
    } else {
#line 369
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 373
  if (options.protocol & 4) {
#line 374
    major = 2;
#line 375
    minor = 0;
  } else {
#line 377
    major = 1;
#line 378
    minor = 5;
  }
  {
  {
#line 380
  snprintf((char */* __restrict  */)(buf___1), (size_t )sizeof(buf___1), (char const   */* __restrict  */)"SSH-%d.%d-%.100s\n",
           major, minor, "OpenSSH_4.3");
  }
  {
#line 381
  server_version_string = xstrdup((char const   *)(buf___1));
  }
  {
#line 384
  tmp___0 = strlen((char const   *)server_version_string);
  }
  {
#line 384
  tmp___1 = atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)server_version_string,
                     tmp___0);
  }
  {
#line 384
  tmp___2 = strlen((char const   *)server_version_string);
  }
  }
#line 384
  if (tmp___1 != tmp___2) {
    {
    {
#line 387
    tmp = get_remote_ipaddr();
    }
    {
#line 387
    logit("Could not write ident string to %s", tmp);
    }
    {
#line 388
    cleanup_exit(255);
    }
    }
  }
  {
  {
#line 392
  memset((void *)(buf___1), 0, (size_t )sizeof(buf___1));
  }
#line 393
  i = (u_int )0;
  }
  {
  {
#line 393
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 393
    if (! ((unsigned long )i < sizeof(buf___1) - 1UL)) {
#line 393
      goto while_break;
    }
    {
    {
#line 394
    tmp___4 = atomicio(& read, sock_in, (void *)(& buf___1[i]), (size_t )1);
    }
    }
#line 394
    if (tmp___4 != 1U) {
      {
      {
#line 395
      tmp___3 = get_remote_ipaddr();
      }
      {
#line 395
      logit("Did not receive identification string from %s", tmp___3);
      }
      {
#line 397
      cleanup_exit(255);
      }
      }
    }
#line 399
    if ((int )buf___1[i] == 13) {
#line 400
      buf___1[i] = (char)0;
#line 402
      if (i == 12U) {
        {
        {
#line 402
        tmp___5 = strncmp((char const   *)(buf___1), "SSH-1.5-W1.0", (size_t )12);
        }
        }
#line 402
        if (tmp___5 == 0) {
#line 404
          goto while_break;
        }
      }
#line 405
      goto __Cont;
    }
#line 407
    if ((int )buf___1[i] == 10) {
#line 408
      buf___1[i] = (char)0;
#line 409
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 393
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  buf___1[sizeof(buf___1) - 1UL] = (char)0;
  {
#line 413
  client_version_string = xstrdup((char const   *)(buf___1));
  }
  {
#line 419
  tmp___8 = sscanf((char const   */* __restrict  */)client_version_string, (char const   */* __restrict  */)"SSH-%d.%d-%[^\n]\n",
                   & remote_major, & remote_minor, remote_version);
  }
  }
#line 419
  if (tmp___8 != 3) {
    {
#line 421
    s = (char *)"Protocol mismatch.\n";
    {
#line 422
    tmp___6 = strlen((char const   *)s);
    }
    {
#line 422
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___6);
    }
    {
#line 423
    close(sock_in);
    }
    {
#line 424
    close(sock_out);
    }
    {
#line 425
    tmp___7 = get_remote_ipaddr();
    }
    {
#line 425
    logit("Bad protocol version identification \'%.100s\' from %s", client_version_string,
          tmp___7);
    }
    {
#line 427
    cleanup_exit(255);
    }
    }
  }
  {
  {
#line 429
  debug("Client protocol version %d.%d; client software version %.100s", remote_major,
        remote_minor, remote_version);
  }
  {
#line 432
  compat_datafellows((char const   *)(remote_version));
  }
  }
#line 434
  if (datafellows & 4194304) {
    {
    {
#line 435
    tmp___9 = get_remote_ipaddr();
    }
    {
#line 435
    logit("probed from %s with %s.  Don\'t panic.", tmp___9, client_version_string);
    }
    {
#line 437
    cleanup_exit(255);
    }
    }
  }
#line 440
  if (datafellows & 2048) {
    {
    {
#line 441
    tmp___10 = get_remote_ipaddr();
    }
    {
#line 441
    logit("scanned from %s with %s.  Don\'t panic.", tmp___10, client_version_string);
    }
    {
#line 443
    cleanup_exit(255);
    }
    }
  }
#line 446
  mismatch = 0;
  {
#line 448
  if (remote_major == 1) {
#line 448
    goto case_1;
  }
#line 468
  if (remote_major == 2) {
#line 468
    goto case_2;
  }
#line 474
  goto switch_default;
  case_1: /* CIL Label */ 
#line 449
  if (remote_minor == 99) {
#line 450
    if (options.protocol & 4) {
      {
      {
#line 451
      enable_compat20();
      }
      }
    } else {
#line 453
      mismatch = 1;
    }
#line 454
    goto switch_break;
  }
#line 456
  if (! (options.protocol & 1)) {
#line 457
    mismatch = 1;
#line 458
    goto switch_break;
  }
#line 460
  if (remote_minor < 3) {
    {
    {
#line 461
    packet_disconnect("Your ssh version is too old and is no longer supported.  Please install a newer version.");
    }
    }
  } else
#line 463
  if (remote_minor == 3) {
    {
    {
#line 465
    enable_compat13();
    }
    }
  }
#line 467
  goto switch_break;
  case_2: /* CIL Label */ 
#line 469
  if (options.protocol & 4) {
    {
    {
#line 470
    enable_compat20();
    }
    }
#line 471
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 475
  mismatch = 1;
#line 476
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 478
  chop(server_version_string);
  }
  {
#line 479
  debug("Local version string %.200s", server_version_string);
  }
  }
#line 481
  if (mismatch) {
    {
#line 482
    s = (char *)"Protocol major versions differ.\n";
    {
#line 483
    tmp___11 = strlen((char const   *)s);
    }
    {
#line 483
    atomicio((ssize_t (*)(int  , void * , size_t  ))(& write), sock_out, (void *)s,
             tmp___11);
    }
    {
#line 484
    close(sock_in);
    }
    {
#line 485
    close(sock_out);
    }
    {
#line 486
    tmp___12 = get_remote_ipaddr();
    }
    {
#line 486
    logit("Protocol major versions differ for %s: %.200s vs. %.200s", tmp___12, server_version_string,
          client_version_string);
    }
    {
#line 489
    cleanup_exit(255);
    }
    }
  }
#line 491
  return;
}
}
#line 494 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
void destroy_sensitive_data(void) 
{ 
  int i ;

  {
#line 499
  if (sensitive_data.server_key) {
    {
    {
#line 500
    key_free(sensitive_data.server_key);
    }
#line 501
    sensitive_data.server_key = (Key *)((void *)0);
    }
  }
#line 503
  i = 0;
  {
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < options.num_host_key_files)) {
#line 503
      goto while_break;
    }
#line 504
    if (*(sensitive_data.host_keys + i)) {
      {
      {
#line 505
      key_free(*(sensitive_data.host_keys + i));
      }
#line 506
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      }
    }
#line 503
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
  {
#line 510
  memset((void *)(sensitive_data.ssh1_cookie), 0, (size_t )32);
  }
  }
#line 511
  return;
}
}
#line 514 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
void demote_sensitive_data(void) 
{ 
  Key *tmp ;
  int i ;

  {
#line 520
  if (sensitive_data.server_key) {
    {
    {
#line 521
    tmp = key_demote((Key const   *)sensitive_data.server_key);
    }
    {
#line 522
    key_free(sensitive_data.server_key);
    }
#line 523
    sensitive_data.server_key = tmp;
    }
  }
#line 526
  i = 0;
  {
  {
#line 526
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 526
    if (! (i < options.num_host_key_files)) {
#line 526
      goto while_break;
    }
#line 527
    if (*(sensitive_data.host_keys + i)) {
      {
      {
#line 528
      tmp = key_demote((Key const   *)*(sensitive_data.host_keys + i));
      }
      {
#line 529
      key_free(*(sensitive_data.host_keys + i));
      }
#line 530
      *(sensitive_data.host_keys + i) = tmp;
      }
#line 531
      if (tmp->type == 0) {
#line 532
        sensitive_data.ssh1_host_key = tmp;
      }
    }
#line 526
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return;
}
}
#line 539 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void privsep_preauth_child(void) 
{ 
  u_int32_t rnd[256] ;
  gid_t gidset[1] ;
  struct passwd *pw ;
  int i ;
  size_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 548
  privsep_challenge_enable();
  }
#line 550
  i = 0;
  }
  {
  {
#line 550
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 550
    if (! (i < 256)) {
#line 550
      goto while_break;
    }
    {
    {
#line 551
    rnd[i] = arc4random();
    }
#line 550
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 552
  RAND_seed((void const   *)(rnd), (int )sizeof(rnd));
  }
  {
#line 555
  demote_sensitive_data();
  }
  {
#line 557
  pw = getpwnam("sshd");
  }
  }
#line 557
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
    {
#line 558
    fatal("Privilege separation user %s does not exist", "sshd");
    }
    }
  }
  {
  {
#line 560
  tmp = strlen((char const   *)pw->pw_passwd);
  }
  {
#line 560
  memset((void *)pw->pw_passwd, 0, tmp);
  }
  {
#line 561
  endpwent();
  }
  {
#line 564
  tmp___2 = chroot("/var/empty");
  }
  }
#line 564
  if (tmp___2 == -1) {
    {
    {
#line 565
    tmp___0 = __errno_location();
    }
    {
#line 565
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 565
    fatal("chroot(\"%s\"): %s", "/var/empty", tmp___1);
    }
    }
  }
  {
  {
#line 567
  tmp___5 = chdir("/");
  }
  }
#line 567
  if (tmp___5 == -1) {
    {
    {
#line 568
    tmp___3 = __errno_location();
    }
    {
#line 568
    tmp___4 = strerror(*tmp___3);
    }
    {
#line 568
    fatal("chdir(\"/\"): %s", tmp___4);
    }
    }
  }
  {
  {
#line 571
  debug3("privsep user:group %u:%u", pw->pw_uid, pw->pw_gid);
  }
#line 577
  gidset[0] = pw->pw_gid;
  {
#line 578
  tmp___8 = setgroups((size_t )1, (__gid_t const   *)(gidset));
  }
  }
#line 578
  if (tmp___8 < 0) {
    {
    {
#line 579
    tmp___6 = __errno_location();
    }
    {
#line 579
    tmp___7 = strerror(*tmp___6);
    }
    {
#line 579
    fatal("setgroups: %.100s", tmp___7);
    }
    }
  }
  {
  {
#line 580
  permanently_set_uid(pw);
  }
  }
#line 582
  return;
}
}
#line 584 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static int privsep_preauth(Authctxt *authctxt___0 ) 
{ 
  int status ;
  pid_t pid ;
  int *tmp ;
  __pid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 591
  pmonitor = monitor_init();
  }
#line 593
  pmonitor->m_pkex = & xxx_kex;
  {
#line 595
  pid = fork();
  }
  }
#line 596
  if (pid == -1) {
    {
    {
#line 597
    fatal("fork of unprivileged child failed");
    }
    }
  } else
#line 598
  if (pid != 0) {
    {
    {
#line 599
    debug2("Network child is on pid %ld", (long )pid);
    }
    {
#line 601
    close(pmonitor->m_recvfd);
    }
#line 602
    pmonitor->m_pid = pid;
    {
#line 603
    monitor_child_preauth(authctxt___0, pmonitor);
    }
    {
#line 604
    close(pmonitor->m_sendfd);
    }
    {
#line 607
    monitor_sync(pmonitor);
    }
    }
    {
    {
#line 610
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 610
      tmp___0 = waitpid(pid, & status, 0);
      }
      }
#line 610
      if (! (tmp___0 < 0)) {
#line 610
        goto while_break;
      }
      {
      {
#line 611
      tmp = __errno_location();
      }
      }
#line 611
      if (*tmp != 4) {
#line 612
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 613
    return (1);
  } else {
    {
    {
#line 617
    close(pmonitor->m_sendfd);
    }
    {
#line 620
    tmp___1 = getuid();
    }
    }
#line 620
    if (tmp___1 == 0U) {
      {
      {
#line 621
      privsep_preauth_child();
      }
      }
    } else {
      {
      {
#line 620
      tmp___2 = geteuid();
      }
      }
#line 620
      if (tmp___2 == 0U) {
        {
        {
#line 621
        privsep_preauth_child();
        }
        }
      }
    }
    {
    {
#line 622
    setproctitle("%s", "[net]");
    }
    }
  }
#line 624
  return (0);
}
}
#line 627 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void privsep_postauth(Authctxt *authctxt___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 633
  if ((authctxt___0->pw)->pw_uid == 0U) {
#line 636
    use_privsep = 0;
#line 637
    goto skip;
  } else
#line 633
  if (options.use_login) {
#line 636
    use_privsep = 0;
#line 637
    goto skip;
  }
  {
  {
#line 641
  monitor_reinit(pmonitor);
  }
  {
#line 643
  pmonitor->m_pid = fork();
  }
  }
#line 644
  if (pmonitor->m_pid == -1) {
    {
    {
#line 645
    fatal("fork of unprivileged child failed");
    }
    }
  } else
#line 646
  if (pmonitor->m_pid != 0) {
    {
    {
#line 647
    debug2("User child is on pid %ld", (long )pmonitor->m_pid);
    }
    {
#line 648
    close(pmonitor->m_recvfd);
    }
    {
#line 649
    buffer_clear(& loginmsg);
    }
    {
#line 650
    monitor_child_postauth(pmonitor);
    }
    {
#line 653
    exit(0);
    }
    }
  }
  {
  {
#line 656
  close(pmonitor->m_sendfd);
  }
  {
#line 659
  demote_sensitive_data();
  }
  {
#line 662
  do_setusercontext(authctxt___0->pw);
  }
  }
  skip: 
  {
  {
#line 666
  monitor_apply_keystate(pmonitor);
  }
  {
#line 672
  packet_set_authenticated();
  }
  }
#line 673
  return;
}
}
#line 675 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static char *list_hostkey_types(void) 
{ 
  Buffer b ;
  char const   *p ;
  char *ret ;
  int i ;
  Key *key ;
  u_int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 683
  buffer_init(& b);
  }
#line 684
  i = 0;
  }
  {
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i < options.num_host_key_files)) {
#line 684
      goto while_break;
    }
#line 685
    key = *(sensitive_data.host_keys + i);
#line 686
    if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 687
      goto __Cont;
    }
    {
#line 690
    if (key->type == 2) {
#line 690
      goto case_2;
    }
#line 690
    if (key->type == 1) {
#line 690
      goto case_2;
    }
#line 688
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
    {
#line 691
    tmp = buffer_len(& b);
    }
    }
#line 691
    if (tmp > 0U) {
      {
      {
#line 692
      buffer_append(& b, (void const   *)",", (u_int )1);
      }
      }
    }
    {
    {
#line 693
    p = key_ssh_name((Key const   *)key);
    }
    {
#line 694
    tmp___0 = strlen(p);
    }
    {
#line 694
    buffer_append(& b, (void const   *)p, tmp___0);
    }
    }
#line 695
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 684
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 698
  buffer_append(& b, (void const   *)"\000", (u_int )1);
  }
  {
#line 699
  tmp___1 = buffer_ptr(& b);
  }
  {
#line 699
  ret = xstrdup((char const   *)tmp___1);
  }
  {
#line 700
  buffer_free(& b);
  }
  {
#line 701
  debug("list_hostkey_types: %s", ret);
  }
  }
#line 702
  return (ret);
}
}
#line 705 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
Key *get_hostkey_by_type(int type ) 
{ 
  int i ;
  Key *key ;

  {
#line 710
  i = 0;
  {
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 710
    if (! (i < options.num_host_key_files)) {
#line 710
      goto while_break;
    }
#line 711
    key = *(sensitive_data.host_keys + i);
#line 712
    if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 712
      if (key->type == type) {
#line 713
        return (key);
      }
    }
#line 710
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 715
  return ((Key *)((void *)0));
}
}
#line 718 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
Key *get_hostkey_by_index(int ind ) 
{ 


  {
#line 721
  if (ind < 0) {
#line 722
    return ((Key *)((void *)0));
  } else
#line 721
  if (ind >= options.num_host_key_files) {
#line 722
    return ((Key *)((void *)0));
  }
#line 723
  return (*(sensitive_data.host_keys + ind));
}
}
#line 726 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int get_hostkey_index(Key *key ) 
{ 
  int i ;

  {
#line 731
  i = 0;
  {
  {
#line 731
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 731
    if (! (i < options.num_host_key_files)) {
#line 731
      goto while_break;
    }
#line 732
    if ((unsigned long )key == (unsigned long )*(sensitive_data.host_keys + i)) {
#line 733
      return (i);
    }
#line 731
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  return (-1);
}
}
#line 744 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static int drop_connection(int startups ) 
{ 
  int p ;
  int r ;
  unsigned int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 749
  if (startups < options.max_startups_begin) {
#line 750
    return (0);
  }
#line 751
  if (startups >= options.max_startups) {
#line 752
    return (1);
  }
#line 753
  if (options.max_startups_rate == 100) {
#line 754
    return (1);
  }
  {
#line 756
  p = 100 - options.max_startups_rate;
#line 757
  p *= startups - options.max_startups_begin;
#line 758
  p /= options.max_startups - options.max_startups_begin;
#line 759
  p += options.max_startups_rate;
  {
#line 760
  tmp = arc4random();
  }
#line 760
  r = (int )(tmp % 100U);
  {
#line 762
  debug("drop_connection: p %d, r %d", p, r);
  }
  }
#line 763
  if (r < p) {
#line 763
    tmp___0 = 1;
  } else {
#line 763
    tmp___0 = 0;
  }
#line 763
  return (tmp___0);
}
}
#line 766 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void usage(void) 
{ 
  char const   *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 769
  tmp = SSLeay_version(0);
  }
  {
#line 769
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s, %s\n",
          "OpenSSH_4.3p2", tmp);
  }
  {
#line 771
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: sshd [-46Ddeiqt] [-b bits] [-f config_file] [-g login_grace_time]\n            [-h host_key_file] [-k key_gen_time] [-o option] [-p port] [-u len]\n");
  }
  {
#line 775
  exit(1);
  }
  }
}
}
#line 778 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void send_rexec_state(int fd , Buffer *conf ) 
{ 
  Buffer m ;
  u_int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 783
  tmp = buffer_len(conf);
  }
  {
#line 783
  debug3("%s: entering fd = %d config len %d", "send_rexec_state", fd, tmp);
  }
  {
#line 798
  buffer_init(& m);
  }
  {
#line 799
  tmp___0 = buffer_ptr(conf);
  }
  {
#line 799
  buffer_put_cstring(& m, (char const   *)tmp___0);
  }
  }
#line 801
  if ((unsigned long )sensitive_data.server_key != (unsigned long )((void *)0)) {
#line 801
    if ((sensitive_data.server_key)->type == 0) {
      {
      {
#line 803
      buffer_put_int(& m, (u_int )1);
      }
      {
#line 804
      buffer_put_bignum(& m, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->e);
      }
      {
#line 805
      buffer_put_bignum(& m, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
      }
      {
#line 806
      buffer_put_bignum(& m, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->d);
      }
      {
#line 807
      buffer_put_bignum(& m, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->iqmp);
      }
      {
#line 808
      buffer_put_bignum(& m, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->p);
      }
      {
#line 809
      buffer_put_bignum(& m, (BIGNUM const   *)((sensitive_data.server_key)->rsa)->q);
      }
      }
    } else {
      {
      {
#line 811
      buffer_put_int(& m, (u_int )0);
      }
      }
    }
  } else {
    {
    {
#line 811
    buffer_put_int(& m, (u_int )0);
    }
    }
  }
  {
  {
#line 817
  tmp___1 = ssh_msg_send(fd, (u_char )0, & m);
  }
  }
#line 817
  if (tmp___1 == -1) {
    {
    {
#line 818
    fatal("%s: ssh_msg_send failed", "send_rexec_state");
    }
    }
  }
  {
  {
#line 820
  buffer_free(& m);
  }
  {
#line 822
  debug3("%s: done", "send_rexec_state");
  }
  }
#line 823
  return;
}
}
#line 825 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void recv_rexec_state(int fd , Buffer *conf ) 
{ 
  Buffer m ;
  char *cp ;
  u_int len ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  u_int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 832
  debug3("%s: entering fd = %d", "recv_rexec_state", fd);
  }
  {
#line 834
  buffer_init(& m);
  }
  {
#line 836
  tmp = ssh_msg_recv(fd, & m);
  }
  }
#line 836
  if (tmp == -1) {
    {
    {
#line 837
    fatal("%s: ssh_msg_recv failed", "recv_rexec_state");
    }
    }
  }
  {
  {
#line 838
  tmp___0 = buffer_get_char(& m);
  }
  }
#line 838
  if (tmp___0 != 0) {
    {
    {
#line 839
    fatal("%s: rexec version mismatch", "recv_rexec_state");
    }
    }
  }
  {
  {
#line 841
  tmp___1 = buffer_get_string(& m, & len);
  }
#line 841
  cp = (char *)tmp___1;
  }
#line 842
  if ((unsigned long )conf != (unsigned long )((void *)0)) {
    {
    {
#line 843
    buffer_append(conf, (void const   *)cp, len + 1U);
    }
    }
  }
  {
  {
#line 844
  xfree((void *)cp);
  }
  {
#line 846
  tmp___2 = buffer_get_int(& m);
  }
  }
#line 846
  if (tmp___2) {
#line 847
    if ((unsigned long )sensitive_data.server_key != (unsigned long )((void *)0)) {
      {
      {
#line 848
      key_free(sensitive_data.server_key);
      }
      }
    }
    {
    {
#line 849
    sensitive_data.server_key = key_new_private(0);
    }
    {
#line 850
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->e);
    }
    {
#line 851
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->n);
    }
    {
#line 852
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->d);
    }
    {
#line 853
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->iqmp);
    }
    {
#line 854
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->p);
    }
    {
#line 855
    buffer_get_bignum(& m, ((sensitive_data.server_key)->rsa)->q);
    }
    {
#line 856
    rsa_generate_additional_parameters((sensitive_data.server_key)->rsa);
    }
    }
  }
  {
  {
#line 864
  buffer_free(& m);
  }
  {
#line 866
  debug3("%s: done", "recv_rexec_state");
  }
  }
#line 867
  return;
}
}
#line 875
extern char *BSDoptarg ;
#line 876
extern int BSDoptind ;
#line 872 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int main(int ac , char **av ) 
{ 
  int opt ;
  int j ;
  int i ;
  int fdsetsz ;
  int on ;
  int sock_in ;
  int sock_out ;
  int newsock ;
  pid_t pid ;
  socklen_t fromlen ;
  fd_set *fdset ;
  struct sockaddr_storage from ;
  char const   *remote_ip ;
  int remote_port ;
  FILE *f ;
  struct addrinfo *ai ;
  char ntop[1025] ;
  char strport[32] ;
  char *line ;
  int listen_sock ;
  int maxfd ;
  int startup_p[2] ;
  int config_s[2] ;
  int startups ;
  Key *key ;
  Authctxt *authctxt___0 ;
  int ret ;
  int key_used ;
  Buffer cfg ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  void *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct passwd *pw ;
  struct stat st ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  void *tmp___25 ;
  int fd ;
  int *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int fd___0 ;
  char const   *tmp___29 ;
  int *tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  int *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  __pid_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  int *tmp___50 ;
  char *tmp___51 ;
  int *tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  int *tmp___55 ;
  int *tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int *tmp___65 ;
  char *tmp___66 ;
  __pid_t tmp___67 ;
  int fd___1 ;
  int *tmp___68 ;
  char *tmp___69 ;
  int *tmp___70 ;
  char *tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  void *tmp___74 ;
  int tmp___75 ;
  void *__cil_tmp114 ;
  void *__cil_tmp115 ;
  void *__cil_tmp116 ;
  void *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;

  {
  {
#line 877
  on = 1;
#line 878
  sock_in = -1;
#line 878
  sock_out = -1;
#line 878
  newsock = -1;
#line 890
  startup_p[0] = -1;
#line 890
  startup_p[1] = -1;
#line 890
  config_s[0] = -1;
#line 890
  config_s[1] = -1;
#line 891
  startups = 0;
#line 894
  key_used = 0;
  {
#line 900
  __progname = ssh_get_progname(*(av + 0));
  }
  {
#line 901
  init_rng();
  }
#line 904
  saved_argc = ac;
#line 905
  rexec_argc = ac;
  {
#line 906
  tmp = xmalloc((size_t )(sizeof(*saved_argv) * (unsigned long )(ac + 1)));
  }
#line 906
  saved_argv = (char **)tmp;
#line 907
  i = 0;
  }
  {
  {
#line 907
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 907
    if (! (i < ac)) {
#line 907
      goto while_break;
    }
    {
    {
#line 908
    *(saved_argv + i) = xstrdup((char const   *)*(av + i));
    }
#line 907
    i ++;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 909
  *(saved_argv + i) = (char *)((void *)0);
  {
#line 913
  compat_init_setproctitle(ac, av);
  }
#line 914
  av = saved_argv;
  {
#line 917
  tmp___2 = geteuid();
  }
  }
#line 917
  if (tmp___2 == 0U) {
    {
    {
#line 917
    tmp___3 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
    }
    }
#line 917
    if (tmp___3 == -1) {
      {
      {
#line 918
      tmp___0 = __errno_location();
      }
      {
#line 918
      tmp___1 = strerror(*tmp___0);
      }
      {
#line 918
      debug("setgroups(): %.200s", tmp___1);
      }
      }
    }
  }
  {
  {
#line 921
  sanitise_stdfd();
  }
  {
#line 924
  initialize_server_options(& options);
  }
  }
  {
  {
#line 927
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 927
    opt = BSDgetopt(ac, (char * const  *)av, "f:p:b:k:h:g:u:o:dDeiqrtQR46");
    }
    }
#line 927
    if (! (opt != -1)) {
#line 927
      goto while_break___0;
    }
    {
#line 929
    if (opt == 52) {
#line 929
      goto case_52;
    }
#line 932
    if (opt == 54) {
#line 932
      goto case_54;
    }
#line 935
    if (opt == 102) {
#line 935
      goto case_102;
    }
#line 938
    if (opt == 100) {
#line 938
      goto case_100;
    }
#line 945
    if (opt == 68) {
#line 945
      goto case_68;
    }
#line 948
    if (opt == 101) {
#line 948
      goto case_101;
    }
#line 951
    if (opt == 105) {
#line 951
      goto case_105;
    }
#line 954
    if (opt == 114) {
#line 954
      goto case_114;
    }
#line 957
    if (opt == 82) {
#line 957
      goto case_82;
    }
#line 961
    if (opt == 81) {
#line 961
      goto case_81;
    }
#line 964
    if (opt == 113) {
#line 964
      goto case_113;
    }
#line 967
    if (opt == 98) {
#line 967
      goto case_98;
    }
#line 970
    if (opt == 112) {
#line 970
      goto case_112;
    }
#line 982
    if (opt == 103) {
#line 982
      goto case_103;
    }
#line 988
    if (opt == 107) {
#line 988
      goto case_107;
    }
#line 994
    if (opt == 104) {
#line 994
      goto case_104;
    }
#line 1001
    if (opt == 116) {
#line 1001
      goto case_116;
    }
#line 1004
    if (opt == 117) {
#line 1004
      goto case_117;
    }
#line 1011
    if (opt == 111) {
#line 1011
      goto case_111;
    }
#line 1019
    goto switch_default;
    case_52: /* CIL Label */ 
#line 930
    options.address_family = 2;
#line 931
    goto switch_break;
    case_54: /* CIL Label */ 
#line 933
    options.address_family = 10;
#line 934
    goto switch_break;
    case_102: /* CIL Label */ 
#line 936
    config_file_name = BSDoptarg;
#line 937
    goto switch_break;
    case_100: /* CIL Label */ 
#line 939
    if (debug_flag == 0) {
#line 940
      debug_flag = 1;
#line 941
      options.log_level = (LogLevel )5;
    } else
#line 942
    if ((int )options.log_level < 7) {
#line 943
      options.log_level = (LogLevel )((int )options.log_level + 1);
    }
#line 944
    goto switch_break;
    case_68: /* CIL Label */ 
#line 946
    no_daemon_flag = 1;
#line 947
    goto switch_break;
    case_101: /* CIL Label */ 
#line 949
    log_stderr = 1;
#line 950
    goto switch_break;
    case_105: /* CIL Label */ 
#line 952
    inetd_flag = 1;
#line 953
    goto switch_break;
    case_114: /* CIL Label */ 
#line 955
    rexec_flag = 0;
#line 956
    goto switch_break;
    case_82: /* CIL Label */ 
#line 958
    rexeced_flag = 1;
#line 959
    inetd_flag = 1;
#line 960
    goto switch_break;
    case_81: /* CIL Label */ 
#line 963
    goto switch_break;
    case_113: /* CIL Label */ 
#line 965
    options.log_level = (LogLevel )0;
#line 966
    goto switch_break;
    case_98: /* CIL Label */ 
    {
    {
#line 968
    options.server_key_bits = atoi((char const   *)BSDoptarg);
    }
    }
#line 969
    goto switch_break;
    case_112: /* CIL Label */ 
#line 971
    options.ports_from_cmdline = (u_int )1;
#line 972
    if (options.num_ports >= 256U) {
      {
      {
#line 973
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many ports.\n");
      }
      {
#line 974
      exit(1);
      }
      }
    }
    {
#line 976
    tmp___4 = options.num_ports;
#line 976
    (options.num_ports) ++;
    {
#line 976
    tmp___5 = a2port((char const   *)BSDoptarg);
    }
#line 976
    options.ports[tmp___4] = (u_short )tmp___5;
    }
#line 977
    if ((int )options.ports[options.num_ports - 1U] == 0) {
      {
      {
#line 978
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad port number.\n");
      }
      {
#line 979
      exit(1);
      }
      }
    }
#line 981
    goto switch_break;
    case_103: /* CIL Label */ 
    {
    {
#line 983
    tmp___6 = convtime((char const   *)BSDoptarg);
    }
#line 983
    options.login_grace_time = (int )tmp___6;
    }
#line 983
    if (options.login_grace_time == -1) {
      {
      {
#line 984
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid login grace time.\n");
      }
      {
#line 985
      exit(1);
      }
      }
    }
#line 987
    goto switch_break;
    case_107: /* CIL Label */ 
    {
    {
#line 989
    tmp___7 = convtime((char const   *)BSDoptarg);
    }
#line 989
    options.key_regeneration_time = (int )tmp___7;
    }
#line 989
    if (options.key_regeneration_time == -1) {
      {
      {
#line 990
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid key regeneration interval.\n");
      }
      {
#line 991
      exit(1);
      }
      }
    }
#line 993
    goto switch_break;
    case_104: /* CIL Label */ 
#line 995
    if (options.num_host_key_files >= 256) {
      {
      {
#line 996
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many host keys.\n");
      }
      {
#line 997
      exit(1);
      }
      }
    }
#line 999
    tmp___8 = options.num_host_key_files;
#line 999
    (options.num_host_key_files) ++;
#line 999
    options.host_key_files[tmp___8] = BSDoptarg;
#line 1000
    goto switch_break;
    case_116: /* CIL Label */ 
#line 1002
    test_flag = 1;
#line 1003
    goto switch_break;
    case_117: /* CIL Label */ 
    {
    {
#line 1005
    tmp___9 = atoi((char const   *)BSDoptarg);
    }
#line 1005
    utmp_len = (u_int )tmp___9;
    }
#line 1006
    if (utmp_len > 64U) {
      {
      {
#line 1007
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid utmp length.\n");
      }
      {
#line 1008
      exit(1);
      }
      }
    }
#line 1010
    goto switch_break;
    case_111: /* CIL Label */ 
    {
    {
#line 1012
    line = xstrdup((char const   *)BSDoptarg);
    }
    {
#line 1013
    tmp___10 = process_server_config_line(& options, line, "command-line", 0);
    }
    }
#line 1013
    if (tmp___10 != 0) {
      {
      {
#line 1015
      exit(1);
      }
      }
    }
    {
    {
#line 1016
    xfree((void *)line);
    }
    }
#line 1017
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 1020
    usage();
    }
    }
#line 1021
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1024
  if (rexeced_flag) {
#line 1025
    rexec_flag = 0;
  } else
#line 1024
  if (inetd_flag) {
#line 1025
    rexec_flag = 0;
  }
#line 1026
  if (rexec_flag) {
#line 1026
    if ((unsigned long )*(av + 0) == (unsigned long )((void *)0)) {
      {
      {
#line 1027
      fatal("sshd re-exec requires execution with an absolute path");
      }
      }
    } else
#line 1026
    if ((int )*(*(av + 0)) != 47) {
      {
      {
#line 1027
      fatal("sshd re-exec requires execution with an absolute path");
      }
      }
    }
  }
#line 1028
  if (rexeced_flag) {
    {
    {
#line 1029
    closefrom(6);
    }
    }
  } else {
    {
    {
#line 1031
    closefrom(3);
    }
    }
  }
  {
  {
#line 1033
  OPENSSL_add_all_algorithms_noconf();
  }
  }
#line 1039
  if (log_stderr) {
#line 1039
    tmp___11 = 1;
  } else
#line 1039
  if (! inetd_flag) {
#line 1039
    tmp___11 = 1;
  } else {
#line 1039
    tmp___11 = 0;
  }
#line 1039
  if ((int )options.log_facility == -1) {
#line 1039
    tmp___12 = 2;
  } else {
#line 1039
    tmp___12 = (int )options.log_facility;
  }
#line 1039
  if ((int )options.log_level == -1) {
#line 1039
    tmp___13 = 3;
  } else {
#line 1039
    tmp___13 = (int )options.log_level;
  }
  {
  {
#line 1039
  log_init(__progname, (LogLevel )tmp___13, (SyslogFacility )tmp___12, tmp___11);
  }
  {
#line 1050
  tmp___14 = getenv("KRB5CCNAME");
  }
  }
#line 1050
  if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
    {
    {
#line 1051
    unsetenv("KRB5CCNAME");
    }
    }
  }
  {
#line 1060
  sensitive_data.server_key = (Key *)((void *)0);
#line 1061
  sensitive_data.ssh1_host_key = (Key *)((void *)0);
#line 1062
  sensitive_data.have_ssh1_key = 0;
#line 1063
  sensitive_data.have_ssh2_key = 0;
  {
#line 1066
  buffer_init(& cfg);
  }
  }
#line 1067
  if (rexeced_flag) {
    {
    {
#line 1068
    recv_rexec_state(5, & cfg);
    }
    }
  } else {
    {
    {
#line 1070
    load_server_config((char const   *)config_file_name, & cfg);
    }
    }
  }
#line 1072
  if (rexeced_flag) {
#line 1072
    tmp___15 = "rexec";
  } else {
#line 1072
    tmp___15 = (char const   *)config_file_name;
  }
  {
  {
#line 1072
  parse_server_config(& options, tmp___15, & cfg);
  }
  }
#line 1075
  if (! rexec_flag) {
    {
    {
#line 1076
    buffer_free(& cfg);
    }
    }
  }
  {
  {
#line 1078
  seed_rng();
  }
  {
#line 1081
  fill_default_server_options(& options);
  }
  {
#line 1084
  channel_set_af(options.address_family);
  }
  }
#line 1087
  if (BSDoptind < ac) {
    {
    {
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Extra argument %s.\n",
            *(av + BSDoptind));
    }
    {
#line 1089
    exit(1);
    }
    }
  }
  {
  {
#line 1092
  debug("sshd version %.100s", "OpenSSH_4.3p2");
  }
  {
#line 1095
  tmp___16 = xmalloc((size_t )((unsigned long )options.num_host_key_files * sizeof(Key *)));
  }
#line 1095
  sensitive_data.host_keys = (Key **)tmp___16;
#line 1097
  i = 0;
  }
  {
  {
#line 1097
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1097
    if (! (i < options.num_host_key_files)) {
#line 1097
      goto while_break___1;
    }
#line 1098
    *(sensitive_data.host_keys + i) = (Key *)((void *)0);
#line 1097
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1100
  i = 0;
  {
  {
#line 1100
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 1100
    if (! (i < options.num_host_key_files)) {
#line 1100
      goto while_break___2;
    }
    {
    {
#line 1101
    key = key_load_private((char const   *)options.host_key_files[i], "", (char **)((void *)0));
    }
#line 1102
    *(sensitive_data.host_keys + i) = key;
    }
#line 1103
    if ((unsigned long )key == (unsigned long )((void *)0)) {
      {
      {
#line 1104
      error("Could not load host key: %s", options.host_key_files[i]);
      }
#line 1106
      *(sensitive_data.host_keys + i) = (Key *)((void *)0);
      }
#line 1107
      goto __Cont;
    }
    {
#line 1110
    if (key->type == 0) {
#line 1110
      goto case_0;
    }
#line 1115
    if (key->type == 2) {
#line 1115
      goto case_2;
    }
#line 1115
    if (key->type == 1) {
#line 1115
      goto case_2;
    }
#line 1109
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 1111
    sensitive_data.ssh1_host_key = key;
#line 1112
    sensitive_data.have_ssh1_key = 1;
#line 1113
    goto switch_break___0;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1116
    sensitive_data.have_ssh2_key = 1;
#line 1117
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1119
    tmp___17 = key_type((Key const   *)key);
    }
    {
#line 1119
    debug("private host key: #%d type %d %s", i, key->type, tmp___17);
    }
    }
    __Cont: /* CIL Label */ 
#line 1100
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1122
  if (options.protocol & 1) {
#line 1122
    if (! sensitive_data.have_ssh1_key) {
      {
      {
#line 1123
      logit("Disabling protocol version 1. Could not load host key");
      }
#line 1124
      options.protocol &= -2;
      }
    }
  }
#line 1126
  if (options.protocol & 4) {
#line 1126
    if (! sensitive_data.have_ssh2_key) {
      {
      {
#line 1127
      logit("Disabling protocol version 2. Could not load host key");
      }
#line 1128
      options.protocol &= -5;
      }
    }
  }
#line 1130
  if (! (options.protocol & 5)) {
    {
    {
#line 1131
    logit("sshd: no hostkeys available -- exiting.");
    }
    {
#line 1132
    exit(1);
    }
    }
  }
#line 1136
  if (options.protocol & 1) {
#line 1137
    if (options.server_key_bits < 512) {
      {
      {
#line 1139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad server key size.\n");
      }
      {
#line 1140
      exit(1);
      }
      }
    } else
#line 1137
    if (options.server_key_bits > 32768) {
      {
      {
#line 1139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad server key size.\n");
      }
      {
#line 1140
      exit(1);
      }
      }
    }
    {
    {
#line 1147
    tmp___19 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
    }
    }
#line 1147
    if (options.server_key_bits > tmp___19 - 128) {
      {
      {
#line 1147
      tmp___20 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
      }
      }
#line 1147
      if (options.server_key_bits < tmp___20 + 128) {
        {
        {
#line 1152
        tmp___18 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
        }
#line 1152
        options.server_key_bits = tmp___18 + 128;
        {
#line 1155
        debug("Forcing server key to %d bits to make it differ from host key.", options.server_key_bits);
        }
        }
      }
    }
  }
#line 1160
  if (use_privsep) {
    {
    {
#line 1164
    pw = getpwnam("sshd");
    }
    }
#line 1164
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
      {
#line 1165
      fatal("Privilege separation user %s does not exist", "sshd");
      }
      }
    }
    {
    {
#line 1167
    tmp___21 = stat((char const   */* __restrict  */)"/var/empty", (struct stat */* __restrict  */)(& st));
    }
    }
#line 1167
    if (tmp___21 == -1) {
      {
      {
#line 1169
      fatal("Missing privilege separation directory: %s", "/var/empty");
      }
      }
    } else
#line 1167
    if (((st.st_mode & 61440U) == 16384U) == 0) {
      {
      {
#line 1169
      fatal("Missing privilege separation directory: %s", "/var/empty");
      }
      }
    }
#line 1177
    if (st.st_uid != 0U) {
      {
      {
#line 1179
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
      }
    } else
#line 1177
    if ((st.st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) != 0U) {
      {
      {
#line 1179
      fatal("%s must be owned by root and not group or world-writable.", "/var/empty");
      }
      }
    }
  }
#line 1184
  if (test_flag) {
    {
    {
#line 1185
    exit(0);
    }
    }
  }
  {
  {
#line 1194
  tmp___24 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
  }
  }
#line 1194
  if (tmp___24 < 0) {
    {
    {
#line 1195
    tmp___22 = __errno_location();
    }
    {
#line 1195
    tmp___23 = strerror(*tmp___22);
    }
    {
#line 1195
    debug("setgroups() failed: %.200s", tmp___23);
    }
    }
  }
#line 1197
  if (rexec_flag) {
    {
    {
#line 1198
    tmp___25 = xmalloc((size_t )(sizeof(char *) * (unsigned long )(rexec_argc + 2)));
    }
#line 1198
    rexec_argv = (char **)tmp___25;
#line 1199
    i = 0;
    }
    {
    {
#line 1199
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 1199
      if (! (i < rexec_argc)) {
#line 1199
        goto while_break___3;
      }
      {
      {
#line 1200
      debug("rexec_argv[%d]=\'%s\'", i, *(saved_argv + i));
      }
#line 1201
      *(rexec_argv + i) = *(saved_argv + i);
#line 1199
      i ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1203
    *(rexec_argv + rexec_argc) = (char *)"-R";
#line 1204
    *(rexec_argv + (rexec_argc + 1)) = (char *)((void *)0);
  }
#line 1208
  if (debug_flag) {
#line 1208
    if (! inetd_flag) {
#line 1209
      log_stderr = 1;
    } else
#line 1208
    if (rexeced_flag) {
#line 1209
      log_stderr = 1;
    }
  }
  {
  {
#line 1210
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
  }
  }
#line 1217
  if (! debug_flag) {
#line 1217
    if (! inetd_flag) {
#line 1217
      if (! no_daemon_flag) {
        {
        {
#line 1221
        tmp___28 = daemon(0, 0);
        }
        }
#line 1221
        if (tmp___28 < 0) {
          {
          {
#line 1222
          tmp___26 = __errno_location();
          }
          {
#line 1222
          tmp___27 = strerror(*tmp___26);
          }
          {
#line 1222
          fatal("daemon() failed: %.200s", tmp___27);
          }
          }
        }
        {
        {
#line 1226
        fd = open("/dev/tty", 258);
        }
        }
#line 1227
        if (fd >= 0) {
          {
          {
#line 1228
          ioctl(fd, 21538UL, (void *)0);
          }
          {
#line 1229
          close(fd);
          }
          }
        }
      }
    }
  }
  {
  {
#line 1234
  log_init(__progname, options.log_level, options.log_facility, log_stderr);
  }
  {
#line 1237
  arc4random_stir();
  }
  {
#line 1241
  chdir("/");
  }
  {
#line 1244
  mysignal(13, (void (*)(int  ))1);
  }
  }
#line 1247
  if (inetd_flag) {
#line 1250
    startup_pipe = -1;
#line 1251
    if (rexeced_flag) {
      {
      {
#line 1252
      close(5);
      }
      {
#line 1253
      sock_out = dup(0);
      }
#line 1253
      sock_in = sock_out;
      }
#line 1254
      if (! debug_flag) {
        {
        {
#line 1255
        startup_pipe = dup(4);
        }
        {
#line 1256
        close(4);
        }
        }
      }
    } else {
      {
      {
#line 1259
      sock_in = dup(0);
      }
      {
#line 1260
      sock_out = dup(1);
      }
      }
    }
    {
    {
#line 1267
    fd___0 = open("/dev/null", 2, 0);
    }
    }
#line 1267
    if (fd___0 != -1) {
      {
      {
#line 1268
      dup2(fd___0, 0);
      }
      {
#line 1269
      dup2(fd___0, 1);
      }
      }
#line 1270
      if (fd___0 > 1) {
        {
        {
#line 1271
        close(fd___0);
        }
        }
      }
    }
    {
    {
#line 1273
    debug("inetd sockets after dupping: %d, %d", sock_in, sock_out);
    }
    }
#line 1274
    if (options.protocol & 1) {
#line 1274
      if ((unsigned long )sensitive_data.server_key == (unsigned long )((void *)0)) {
        {
        {
#line 1276
        generate_ephemeral_server_key();
        }
        }
      }
    }
  } else {
#line 1278
    ai = options.listen_addrs;
    {
    {
#line 1278
    while (1) {
      while_continue___18: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 1278
      if (! ai) {
#line 1278
        goto while_break___4;
      }
#line 1279
      if (ai->ai_family != 2) {
#line 1279
        if (ai->ai_family != 10) {
#line 1280
          goto __Cont___0;
        }
      }
#line 1281
      if (num_listen_socks >= 16) {
        {
        {
#line 1282
        fatal("Too many listen sockets. Enlarge MAX_LISTEN_SOCKS");
        }
        }
      }
      {
      {
#line 1284
      ret = getnameinfo((struct sockaddr  const  */* __restrict  */)ai->ai_addr, ai->ai_addrlen,
                        (char */* __restrict  */)(ntop), (socklen_t )sizeof(ntop),
                        (char */* __restrict  */)(strport), (socklen_t )sizeof(strport),
                        3U);
      }
      }
#line 1284
      if (ret != 0) {
#line 1287
        if (ret != -11) {
          {
          {
#line 1287
          tmp___29 = gai_strerror(ret);
          }
#line 1287
          tmp___32 = tmp___29;
          }
        } else {
          {
          {
#line 1287
          tmp___30 = __errno_location();
          }
          {
#line 1287
          tmp___31 = strerror(*tmp___30);
          }
#line 1287
          tmp___32 = (char const   *)tmp___31;
          }
        }
        {
        {
#line 1287
        error("getnameinfo failed: %.100s", tmp___32);
        }
        }
#line 1290
        goto __Cont___0;
      }
      {
      {
#line 1293
      listen_sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      }
      }
#line 1295
      if (listen_sock < 0) {
        {
        {
#line 1297
        tmp___33 = __errno_location();
        }
        {
#line 1297
        tmp___34 = strerror(*tmp___33);
        }
        {
#line 1297
        verbose("socket: %.100s", tmp___34);
        }
        }
#line 1298
        goto __Cont___0;
      }
      {
      {
#line 1300
      tmp___35 = set_nonblock(listen_sock);
      }
      }
#line 1300
      if (tmp___35 == -1) {
        {
        {
#line 1301
        close(listen_sock);
        }
        }
#line 1302
        goto __Cont___0;
      }
      {
      {
#line 1308
      tmp___38 = setsockopt(listen_sock, 1, 2, (void const   *)(& on), (socklen_t )sizeof(on));
      }
      }
#line 1308
      if (tmp___38 == -1) {
        {
        {
#line 1310
        tmp___36 = __errno_location();
        }
        {
#line 1310
        tmp___37 = strerror(*tmp___36);
        }
        {
#line 1310
        error("setsockopt SO_REUSEADDR: %s", tmp___37);
        }
        }
      }
      {
      {
#line 1312
      debug("Bind to port %s on %s.", strport, ntop);
      }
      {
#line 1315
      tmp___41 = bind(listen_sock, (struct sockaddr  const  */* __restrict  */)ai->ai_addr,
                      ai->ai_addrlen);
      }
      }
#line 1315
      if (tmp___41 < 0) {
#line 1316
        if (! ai->ai_next) {
          {
          {
#line 1317
          tmp___39 = __errno_location();
          }
          {
#line 1317
          tmp___40 = strerror(*tmp___39);
          }
          {
#line 1317
          error("Bind to port %s on %s failed: %.200s.", strport, ntop, tmp___40);
          }
          }
        }
        {
        {
#line 1319
        close(listen_sock);
        }
        }
#line 1320
        goto __Cont___0;
      }
      {
#line 1322
      listen_socks[num_listen_socks] = listen_sock;
#line 1323
      num_listen_socks ++;
      {
#line 1326
      logit("Server listening on %s port %s.", ntop, strport);
      }
      {
#line 1327
      tmp___44 = listen(listen_sock, 128);
      }
      }
#line 1327
      if (tmp___44 < 0) {
        {
        {
#line 1328
        tmp___42 = __errno_location();
        }
        {
#line 1328
        tmp___43 = strerror(*tmp___42);
        }
        {
#line 1328
        fatal("listen: %.100s", tmp___43);
        }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1278
      ai = ai->ai_next;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    {
#line 1331
    freeaddrinfo(options.listen_addrs);
    }
    }
#line 1333
    if (! num_listen_socks) {
      {
      {
#line 1334
      fatal("Cannot bind any address.");
      }
      }
    }
#line 1336
    if (options.protocol & 1) {
      {
      {
#line 1337
      generate_ephemeral_server_key();
      }
      }
    }
    {
    {
#line 1343
    mysignal(1, & sighup_handler);
    }
    {
#line 1345
    mysignal(15, & sigterm_handler___0);
    }
    {
#line 1346
    mysignal(3, & sigterm_handler___0);
    }
    {
#line 1349
    mysignal(17, & main_sigchld_handler);
    }
    }
#line 1352
    if (! debug_flag) {
      {
      {
#line 1360
      f = fopen((char const   */* __restrict  */)options.pid_file, (char const   */* __restrict  */)"wb");
      }
      }
#line 1361
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
        {
#line 1362
        tmp___45 = __errno_location();
        }
        {
#line 1362
        tmp___46 = strerror(*tmp___45);
        }
        {
#line 1362
        error("Couldn\'t create pid file \"%s\": %s", options.pid_file, tmp___46);
        }
        }
      } else {
        {
        {
#line 1365
        tmp___47 = getpid();
        }
        {
#line 1365
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld\n",
                (long )tmp___47);
        }
        {
#line 1366
        fclose(f);
        }
        }
      }
    }
#line 1371
    fdset = (fd_set *)((void *)0);
#line 1372
    maxfd = 0;
#line 1373
    i = 0;
    {
    {
#line 1373
    while (1) {
      while_continue___19: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 1373
      if (! (i < num_listen_socks)) {
#line 1373
        goto while_break___5;
      }
#line 1374
      if (listen_socks[i] > maxfd) {
#line 1375
        maxfd = listen_socks[i];
      }
#line 1373
      i ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
    {
#line 1377
    tmp___48 = xmalloc((size_t )((unsigned long )options.max_startups * sizeof(int )));
    }
#line 1377
    startup_pipes = (int *)tmp___48;
#line 1378
    i = 0;
    }
    {
    {
#line 1378
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 1378
      if (! (i < options.max_startups)) {
#line 1378
        goto while_break___6;
      }
#line 1379
      *(startup_pipes + i) = -1;
#line 1378
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
    {
#line 1385
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 1386
      if (received_sighup) {
        {
        {
#line 1387
        sighup_restart();
        }
        }
      }
#line 1388
      if ((unsigned long )fdset != (unsigned long )((void *)0)) {
        {
        {
#line 1389
        xfree((void *)fdset);
        }
        }
      }
      {
#line 1390
      fdsetsz = (int )((((unsigned long )(maxfd + 1) + (8UL * sizeof(__fd_mask ) - 1UL)) / (8UL * sizeof(__fd_mask ))) * sizeof(fd_mask ));
      {
#line 1391
      tmp___49 = xmalloc((size_t )fdsetsz);
      }
#line 1391
      fdset = (fd_set *)tmp___49;
      {
#line 1392
      memset((void *)fdset, 0, (size_t )fdsetsz);
      }
#line 1394
      i = 0;
      }
      {
      {
#line 1394
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 1394
        if (! (i < num_listen_socks)) {
#line 1394
          goto while_break___8;
        }
#line 1395
        fdset->fds_bits[(unsigned long )listen_socks[i] / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )listen_socks[i] % (8UL * sizeof(__fd_mask ));
#line 1394
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1396
      i = 0;
      {
      {
#line 1396
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 1396
        if (! (i < options.max_startups)) {
#line 1396
          goto while_break___9;
        }
#line 1397
        if (*(startup_pipes + i) != -1) {
#line 1398
          fdset->fds_bits[(unsigned long )*(startup_pipes + i) / (8UL * sizeof(__fd_mask ))] |= 1L << (unsigned long )*(startup_pipes + i) % (8UL * sizeof(__fd_mask ));
        }
#line 1396
        i ++;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
      {
#line 1401
      ret = select(maxfd + 1, (fd_set */* __restrict  */)fdset, (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
      }
#line 1402
      if (ret < 0) {
        {
        {
#line 1402
        tmp___52 = __errno_location();
        }
        }
#line 1402
        if (*tmp___52 != 4) {
          {
          {
#line 1403
          tmp___50 = __errno_location();
          }
          {
#line 1403
          tmp___51 = strerror(*tmp___50);
          }
          {
#line 1403
          error("select: %.100s", tmp___51);
          }
          }
        }
      }
#line 1404
      if (received_sigterm___0) {
        {
        {
#line 1405
        logit("Received signal %d; terminating.", (int )received_sigterm___0);
        }
        {
#line 1407
        close_listen_socks();
        }
        {
#line 1408
        unlink((char const   *)options.pid_file);
        }
        {
#line 1409
        exit(255);
        }
        }
      }
#line 1411
      if (key_used) {
#line 1411
        if (key_do_regen) {
          {
          {
#line 1412
          generate_ephemeral_server_key();
          }
#line 1413
          key_used = 0;
#line 1414
          key_do_regen = (int volatile   )0;
          }
        }
      }
#line 1416
      if (ret < 0) {
#line 1417
        goto __Cont___1;
      }
#line 1419
      i = 0;
      {
      {
#line 1419
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 1419
        if (! (i < options.max_startups)) {
#line 1419
          goto while_break___10;
        }
#line 1420
        if (*(startup_pipes + i) != -1) {
#line 1420
          if ((fdset->fds_bits[(unsigned long )*(startup_pipes + i) / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )*(startup_pipes + i) % (8UL * sizeof(__fd_mask )))) != 0L) {
            {
            {
#line 1428
            close(*(startup_pipes + i));
            }
#line 1429
            *(startup_pipes + i) = -1;
#line 1430
            startups --;
            }
          }
        }
#line 1419
        i ++;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1432
      i = 0;
      {
      {
#line 1432
      while (1) {
        while_continue___25: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
#line 1432
        if (! (i < num_listen_socks)) {
#line 1432
          goto while_break___11;
        }
#line 1433
        if (! ((fdset->fds_bits[(unsigned long )listen_socks[i] / (8UL * sizeof(__fd_mask ))] & (1L << (unsigned long )listen_socks[i] % (8UL * sizeof(__fd_mask )))) != 0L)) {
#line 1434
          goto __Cont___2;
        }
        {
#line 1435
        fromlen = (socklen_t )sizeof(from);
        {
#line 1436
        newsock = accept(listen_socks[i], (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                         (socklen_t */* __restrict  */)(& fromlen));
        }
        }
#line 1438
        if (newsock < 0) {
          {
          {
#line 1439
          tmp___55 = __errno_location();
          }
          }
#line 1439
          if (*tmp___55 != 4) {
            {
            {
#line 1439
            tmp___56 = __errno_location();
            }
            }
#line 1439
            if (*tmp___56 != 11) {
              {
              {
#line 1440
              tmp___53 = __errno_location();
              }
              {
#line 1440
              tmp___54 = strerror(*tmp___53);
              }
              {
#line 1440
              error("accept: %.100s", tmp___54);
              }
              }
            }
          }
#line 1441
          goto __Cont___2;
        }
        {
        {
#line 1443
        tmp___57 = unset_nonblock(newsock);
        }
        }
#line 1443
        if (tmp___57 == -1) {
          {
          {
#line 1444
          close(newsock);
          }
          }
#line 1445
          goto __Cont___2;
        }
        {
        {
#line 1447
        tmp___58 = drop_connection(startups);
        }
        }
#line 1447
        if (tmp___58 == 1) {
          {
          {
#line 1448
          debug("drop connection #%d", startups);
          }
          {
#line 1449
          close(newsock);
          }
          }
#line 1450
          goto __Cont___2;
        }
        {
        {
#line 1452
        tmp___59 = pipe((int *)(startup_p));
        }
        }
#line 1452
        if (tmp___59 == -1) {
          {
          {
#line 1453
          close(newsock);
          }
          }
#line 1454
          goto __Cont___2;
        }
#line 1457
        if (rexec_flag) {
          {
          {
#line 1457
          tmp___62 = socketpair(1, 1, 0, (int *)(config_s));
          }
          }
#line 1457
          if (tmp___62 == -1) {
            {
            {
#line 1459
            tmp___60 = __errno_location();
            }
            {
#line 1459
            tmp___61 = strerror(*tmp___60);
            }
            {
#line 1459
            error("reexec socketpair: %s", tmp___61);
            }
            {
#line 1461
            close(newsock);
            }
            {
#line 1462
            close(startup_p[0]);
            }
            {
#line 1463
            close(startup_p[1]);
            }
            }
#line 1464
            goto __Cont___2;
          }
        }
#line 1467
        j = 0;
        {
        {
#line 1467
        while (1) {
          while_continue___26: /* CIL Label */ ;
          while_continue___12: /* CIL Label */ ;
#line 1467
          if (! (j < options.max_startups)) {
#line 1467
            goto while_break___12;
          }
#line 1468
          if (*(startup_pipes + j) == -1) {
#line 1469
            *(startup_pipes + j) = startup_p[0];
#line 1470
            if (maxfd < startup_p[0]) {
#line 1471
              maxfd = startup_p[0];
            }
#line 1472
            startups ++;
#line 1473
            goto while_break___12;
          }
#line 1467
          j ++;
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1480
        if (debug_flag) {
          {
          {
#line 1486
          debug("Server will not fork when running in debugging mode.");
          }
          {
#line 1487
          close_listen_socks();
          }
#line 1488
          sock_in = newsock;
#line 1489
          sock_out = newsock;
          {
#line 1490
          close(startup_p[0]);
          }
          {
#line 1491
          close(startup_p[1]);
          }
#line 1492
          startup_pipe = -1;
          {
#line 1493
          pid = getpid();
          }
          }
#line 1494
          if (rexec_flag) {
            {
            {
#line 1495
            send_rexec_state(config_s[0], & cfg);
            }
            {
#line 1497
            close(config_s[0]);
            }
            }
          }
#line 1499
          goto while_break___11;
        } else {
          {
          {
#line 1506
          pid = fork();
          }
          }
#line 1506
          if (pid == 0) {
            {
#line 1514
            startup_pipe = startup_p[1];
            {
#line 1515
            close_startup_pipes();
            }
            {
#line 1516
            close_listen_socks();
            }
#line 1517
            sock_in = newsock;
#line 1518
            sock_out = newsock;
            {
#line 1519
            log_init(__progname, options.log_level, options.log_facility, log_stderr);
            }
            }
#line 1520
            if (rexec_flag) {
              {
              {
#line 1521
              close(config_s[0]);
              }
              }
            }
#line 1522
            goto while_break___11;
          }
        }
#line 1527
        if (pid < 0) {
          {
          {
#line 1528
          tmp___63 = __errno_location();
          }
          {
#line 1528
          tmp___64 = strerror(*tmp___63);
          }
          {
#line 1528
          error("fork: %.100s", tmp___64);
          }
          }
        } else {
          {
          {
#line 1530
          debug("Forked child %ld.", (long )pid);
          }
          }
        }
        {
        {
#line 1532
        close(startup_p[1]);
        }
        }
#line 1534
        if (rexec_flag) {
          {
          {
#line 1535
          send_rexec_state(config_s[0], & cfg);
          }
          {
#line 1536
          close(config_s[0]);
          }
          {
#line 1537
          close(config_s[1]);
          }
          }
        }
#line 1541
        if (options.protocol & 1) {
#line 1541
          if (key_used == 0) {
            {
            {
#line 1544
            mysignal(14, & key_regeneration_alarm);
            }
            {
#line 1545
            alarm((unsigned int )options.key_regeneration_time);
            }
#line 1546
            key_used = 1;
            }
          }
        }
        {
        {
#line 1549
        arc4random_stir();
        }
        {
#line 1552
        close(newsock);
        }
        }
        __Cont___2: /* CIL Label */ 
#line 1432
        i ++;
      }
      while_break___25: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1555
      if (num_listen_socks < 0) {
#line 1556
        goto while_break___7;
      }
      __Cont___1: /* CIL Label */ ;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
  {
#line 1561
  setproctitle("%s", "[accepted]");
  }
  }
#line 1574
  if (! debug_flag) {
#line 1574
    if (! inetd_flag) {
      {
      {
#line 1574
      tmp___67 = setsid();
      }
      }
#line 1574
      if (tmp___67 < 0) {
        {
        {
#line 1575
        tmp___65 = __errno_location();
        }
        {
#line 1575
        tmp___66 = strerror(*tmp___65);
        }
        {
#line 1575
        error("setsid: %.100s", tmp___66);
        }
        }
      }
    }
  }
#line 1578
  if (rexec_flag) {
    {
    {
#line 1581
    debug("rexec start in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
    }
    {
#line 1583
    dup2(newsock, 0);
    }
    {
#line 1584
    dup2(0, 1);
    }
    }
#line 1585
    if (startup_pipe == -1) {
      {
      {
#line 1586
      close(4);
      }
      }
    } else {
      {
      {
#line 1588
      dup2(startup_pipe, 4);
      }
      }
    }
    {
    {
#line 1590
    dup2(config_s[1], 5);
    }
    {
#line 1591
    close(config_s[1]);
    }
    }
#line 1592
    if (startup_pipe != -1) {
      {
      {
#line 1593
      close(startup_pipe);
      }
      }
    }
    {
    {
#line 1595
    execv((char const   *)*(rexec_argv + 0), (char * const  *)rexec_argv);
    }
    {
#line 1598
    tmp___68 = __errno_location();
    }
    {
#line 1598
    tmp___69 = strerror(*tmp___68);
    }
    {
#line 1598
    error("rexec of %s failed: %s", *(rexec_argv + 0), tmp___69);
    }
    {
#line 1599
    recv_rexec_state(5, (Buffer *)((void *)0));
    }
    {
#line 1600
    log_init(__progname, options.log_level, options.log_facility, log_stderr);
    }
#line 1604
    startup_pipe = 4;
    {
#line 1605
    close(config_s[1]);
    }
    {
#line 1606
    close(5);
    }
    {
#line 1607
    sock_in = dup(0);
    }
#line 1607
    sock_out = sock_in;
#line 1607
    newsock = sock_out;
    {
#line 1608
    fd___1 = open("/dev/null", 2, 0);
    }
    }
#line 1608
    if (fd___1 != -1) {
      {
      {
#line 1609
      dup2(fd___1, 0);
      }
      {
#line 1610
      dup2(fd___1, 1);
      }
      }
#line 1611
      if (fd___1 > 2) {
        {
        {
#line 1612
        close(fd___1);
        }
        }
      }
    }
    {
    {
#line 1614
    debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d", sock_in, sock_out,
          newsock, startup_pipe, config_s[0]);
    }
    }
  }
  {
  {
#line 1623
  alarm(0U);
  }
  {
#line 1624
  mysignal(14, (void (*)(int  ))0);
  }
  {
#line 1625
  mysignal(1, (void (*)(int  ))0);
  }
  {
#line 1626
  mysignal(15, (void (*)(int  ))0);
  }
  {
#line 1627
  mysignal(3, (void (*)(int  ))0);
  }
  {
#line 1628
  mysignal(17, (void (*)(int  ))0);
  }
  {
#line 1629
  mysignal(2, (void (*)(int  ))0);
  }
  {
#line 1635
  packet_set_connection(sock_in, sock_out);
  }
  {
#line 1636
  packet_set_server();
  }
  }
#line 1639
  if (options.tcp_keep_alive) {
    {
    {
#line 1639
    tmp___72 = packet_connection_is_on_socket();
    }
    }
#line 1639
    if (tmp___72) {
      {
      {
#line 1639
      tmp___73 = setsockopt(sock_in, 1, 9, (void const   *)(& on), (socklen_t )sizeof(on));
      }
      }
#line 1639
      if (tmp___73 < 0) {
        {
        {
#line 1641
        tmp___70 = __errno_location();
        }
        {
#line 1641
        tmp___71 = strerror(*tmp___70);
        }
        {
#line 1641
        error("setsockopt SO_KEEPALIVE: %.100s", tmp___71);
        }
        }
      }
    }
  }
  {
  {
#line 1643
  remote_port = get_remote_port();
  }
  }
#line 1643
  if (remote_port < 0) {
    {
    {
#line 1644
    debug("get_remote_port failed");
    }
    {
#line 1645
    cleanup_exit(255);
    }
    }
  }
  {
  {
#line 1652
  remote_ip = get_canonical_hostname(0);
  }
  {
#line 1675
  verbose("Connection from %.500s port %d", remote_ip, remote_port);
  }
  {
#line 1685
  mysignal(14, & grace_alarm_handler);
  }
  }
#line 1686
  if (! debug_flag) {
    {
    {
#line 1687
    alarm((unsigned int )options.login_grace_time);
    }
    }
  }
  {
  {
#line 1689
  sshd_exchange_identification(sock_in, sock_out);
  }
  {
#line 1691
  packet_set_nonblocking();
  }
  {
#line 1694
  tmp___74 = xmalloc((size_t )sizeof(*authctxt___0));
  }
#line 1694
  authctxt___0 = (Authctxt *)tmp___74;
  {
#line 1695
  memset((void *)authctxt___0, 0, (size_t )sizeof(*authctxt___0));
  }
#line 1697
  authctxt___0->loginmsg = & loginmsg;
#line 1700
  the_authctxt = authctxt___0;
  {
#line 1703
  buffer_init(& loginmsg);
  }
  }
#line 1705
  if (use_privsep) {
    {
    {
#line 1706
    tmp___75 = privsep_preauth(authctxt___0);
    }
    }
#line 1706
    if (tmp___75 == 1) {
#line 1707
      goto authenticated;
    }
  }
#line 1711
  if (compat20) {
    {
    {
#line 1712
    do_ssh2_kex();
    }
    {
#line 1713
    do_authentication2(authctxt___0);
    }
    }
  } else {
    {
    {
#line 1715
    do_ssh1_kex();
    }
    {
#line 1716
    do_authentication(authctxt___0);
    }
    }
  }
#line 1722
  if (use_privsep) {
    {
    {
#line 1723
    mm_send_keystate(pmonitor);
    }
    {
#line 1724
    exit(0);
    }
    }
  }
  authenticated: 
  {
  {
#line 1732
  alarm(0U);
  }
  {
#line 1733
  mysignal(14, (void (*)(int  ))0);
  }
  }
#line 1734
  if (startup_pipe != -1) {
    {
    {
#line 1735
    close(startup_pipe);
    }
#line 1736
    startup_pipe = -1;
    }
  }
#line 1747
  if (use_privsep) {
    {
    {
#line 1748
    privsep_postauth(authctxt___0);
    }
    }
#line 1750
    if (! compat20) {
      {
      {
#line 1751
      destroy_sensitive_data();
      }
      }
    }
  }
  {
  {
#line 1755
  do_authenticated(authctxt___0);
  }
  {
#line 1758
  verbose("Closing connection to %.100s", remote_ip);
  }
  {
#line 1769
  packet_close();
  }
  }
#line 1771
  if (use_privsep) {
    {
    {
#line 1772
    mm_terminate();
    }
    }
  }
  {
  {
#line 1774
  exit(0);
  }
  }
}
}
#line 1781 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
int ssh1_session_key(BIGNUM *session_key_int ) 
{ 
  int rsafail ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 1784
  rsafail = 0;
  {
#line 1786
  tmp___13 = BN_cmp((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n, (BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
  }
  }
#line 1786
  if (tmp___13 > 0) {
    {
    {
#line 1788
    tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
    }
    {
#line 1788
    tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
    }
    }
#line 1788
    if (tmp___2 < tmp___3 + 128) {
      {
      {
#line 1790
      tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
      }
      {
#line 1790
      tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
      }
      {
#line 1790
      tmp___1 = get_remote_ipaddr();
      }
      {
#line 1790
      fatal("do_connection: %s: server_key %d < host_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___1, tmp___0, tmp, 128);
      }
      }
    }
    {
    {
#line 1796
    tmp___4 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
    }
    }
#line 1796
    if (tmp___4 <= 0) {
#line 1798
      rsafail ++;
    }
    {
    {
#line 1799
    tmp___5 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
    }
    }
#line 1799
    if (tmp___5 <= 0) {
#line 1801
      rsafail ++;
    }
  } else {
    {
    {
#line 1804
    tmp___9 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
    }
    {
#line 1804
    tmp___10 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
    }
    }
#line 1804
    if (tmp___9 < tmp___10 + 128) {
      {
      {
#line 1806
      tmp___6 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
      }
      {
#line 1806
      tmp___7 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
      }
      {
#line 1806
      tmp___8 = get_remote_ipaddr();
      }
      {
#line 1806
      fatal("do_connection: %s: host_key %d < server_key %d + SSH_KEY_BITS_RESERVED %d",
            tmp___8, tmp___7, tmp___6, 128);
      }
      }
    }
    {
    {
#line 1812
    tmp___11 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.ssh1_host_key)->rsa);
    }
    }
#line 1812
    if (tmp___11 < 0) {
#line 1814
      rsafail ++;
    }
    {
    {
#line 1815
    tmp___12 = rsa_private_decrypt(session_key_int, session_key_int, (sensitive_data.server_key)->rsa);
    }
    }
#line 1815
    if (tmp___12 < 0) {
#line 1817
      rsafail ++;
    }
  }
#line 1819
  return (rsafail);
}
}
#line 1824 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void do_ssh1_kex(void) 
{ 
  int i ;
  int len ;
  int rsafail ;
  BIGNUM *session_key_int ;
  u_char session_key[32] ;
  u_char cookie[8] ;
  u_int cipher_type ;
  u_int auth_mask ;
  u_int protocol_flags ;
  u_int32_t rnd ;
  int tmp ;
  int tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  u_int tmp___4 ;
  u_int tmp___5 ;
  char *tmp___6 ;
  int _len ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int bytes ;
  int tmp___12 ;
  u_char *buf___1 ;
  void *tmp___13 ;
  MD5_CTX md ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 1828
  rsafail = 0;
#line 1833
  rnd = (u_int32_t )0;
#line 1844
  i = 0;
  {
  {
#line 1844
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1844
    if (! (i < 8)) {
#line 1844
      goto while_break;
    }
#line 1845
    if (i % 4 == 0) {
      {
      {
#line 1846
      rnd = arc4random();
      }
      }
    }
#line 1847
    cookie[i] = (u_char )(rnd & 255U);
#line 1848
    rnd >>= 8;
#line 1844
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1856
  packet_start((u_char )2);
  }
#line 1857
  i = 0;
  }
  {
  {
#line 1857
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1857
    if (! (i < 8)) {
#line 1857
      goto while_break___0;
    }
    {
    {
#line 1858
    packet_put_char((int )cookie[i]);
    }
#line 1857
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1861
  tmp = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
  }
  {
#line 1861
  packet_put_int((u_int )tmp);
  }
  {
#line 1862
  packet_put_bignum(((sensitive_data.server_key)->rsa)->e);
  }
  {
#line 1863
  packet_put_bignum(((sensitive_data.server_key)->rsa)->n);
  }
  {
#line 1866
  tmp___0 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
  }
  {
#line 1866
  packet_put_int((u_int )tmp___0);
  }
  {
#line 1867
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->e);
  }
  {
#line 1868
  packet_put_bignum(((sensitive_data.ssh1_host_key)->rsa)->n);
  }
  {
#line 1871
  packet_put_int((u_int )2);
  }
  {
#line 1874
  tmp___1 = cipher_mask_ssh1(0);
  }
  {
#line 1874
  packet_put_int(tmp___1);
  }
#line 1877
  auth_mask = (u_int )0;
  }
#line 1878
  if (options.rhosts_rsa_authentication) {
#line 1879
    auth_mask |= (unsigned int )(1 << 4);
  }
#line 1880
  if (options.rsa_authentication) {
#line 1881
    auth_mask |= (unsigned int )(1 << 2);
  }
#line 1882
  if (options.challenge_response_authentication == 1) {
#line 1883
    auth_mask |= (unsigned int )(1 << 5);
  }
#line 1884
  if (options.password_authentication) {
#line 1885
    auth_mask |= (unsigned int )(1 << 3);
  }
  {
  {
#line 1886
  packet_put_int(auth_mask);
  }
  {
#line 1889
  packet_send();
  }
  {
#line 1890
  packet_write_wait();
  }
  {
#line 1892
  tmp___2 = BN_num_bits((BIGNUM const   *)((sensitive_data.ssh1_host_key)->rsa)->n);
  }
  {
#line 1892
  tmp___3 = BN_num_bits((BIGNUM const   *)((sensitive_data.server_key)->rsa)->n);
  }
  {
#line 1892
  debug("Sent %d bit server key and %d bit host key.", tmp___3, tmp___2);
  }
  {
#line 1897
  packet_read_expect(3);
  }
  {
#line 1900
  cipher_type = packet_get_char();
  }
  {
#line 1902
  tmp___4 = cipher_mask_ssh1(0);
  }
  }
#line 1902
  if (! (tmp___4 & (unsigned int )(1 << cipher_type))) {
    {
    {
#line 1903
    packet_disconnect("Warning: client selects unsupported cipher.");
    }
    }
  }
#line 1907
  i = 0;
  {
  {
#line 1907
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1907
    if (! (i < 8)) {
#line 1907
      goto while_break___1;
    }
    {
    {
#line 1908
    tmp___5 = packet_get_char();
    }
    }
#line 1908
    if ((u_int )cookie[i] != tmp___5) {
      {
      {
#line 1909
      packet_disconnect("IP Spoofing check bytes do not match.");
      }
      }
    }
#line 1907
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 1911
  tmp___6 = cipher_name((int )cipher_type);
  }
  {
#line 1911
  debug("Encryption type: %.200s", tmp___6);
  }
  {
#line 1914
  session_key_int = BN_new();
  }
  }
#line 1914
  if ((unsigned long )session_key_int == (unsigned long )((void *)0)) {
    {
    {
#line 1915
    fatal("do_ssh1_kex: BN_new failed");
    }
    }
  }
  {
  {
#line 1916
  packet_get_bignum(session_key_int);
  }
  {
#line 1918
  protocol_flags = packet_get_int();
  }
  {
#line 1919
  packet_set_protocol_flags(protocol_flags);
  }
  }
  {
  {
#line 1920
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 1920
    tmp___7 = packet_remaining();
    }
#line 1920
    _len = tmp___7;
    }
#line 1920
    if (_len > 0) {
      {
      {
#line 1920
      logit("Packet integrity error (%d bytes remaining) at %s:%d", _len, "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c",
            1920);
      }
      {
#line 1920
      packet_disconnect("Packet integrity error.");
      }
      }
    }
#line 1920
    goto while_break___2;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1923
  if (use_privsep) {
    {
    {
#line 1923
    tmp___8 = mm_ssh1_session_key(session_key_int);
    }
#line 1923
    rsafail = tmp___8;
    }
  } else {
    {
    {
#line 1923
    tmp___9 = ssh1_session_key(session_key_int);
    }
#line 1923
    rsafail = tmp___9;
    }
  }
#line 1930
  if (! rsafail) {
    {
    {
#line 1931
    BN_mask_bits(session_key_int, (int )(sizeof(session_key) * 8UL));
    }
    {
#line 1932
    tmp___10 = BN_num_bits((BIGNUM const   *)session_key_int);
    }
#line 1932
    len = (tmp___10 + 7) / 8;
    }
#line 1933
    if (len < 0) {
      {
      {
#line 1934
      tmp___11 = get_remote_ipaddr();
      }
      {
#line 1934
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, sizeof(session_key));
      }
#line 1937
      rsafail ++;
      }
    } else
#line 1933
    if ((unsigned long )((u_int )len) > sizeof(session_key)) {
      {
      {
#line 1934
      tmp___11 = get_remote_ipaddr();
      }
      {
#line 1934
      error("do_connection: bad session key len from %s: session_key_int %d > sizeof(session_key) %lu",
            tmp___11, len, sizeof(session_key));
      }
#line 1937
      rsafail ++;
      }
    } else {
      {
      {
#line 1939
      memset((void *)(session_key), 0, (size_t )sizeof(session_key));
      }
      {
#line 1940
      BN_bn2bin((BIGNUM const   *)session_key_int, (session_key + sizeof(session_key)) - len);
      }
      {
#line 1943
      derive_ssh1_session_id(((sensitive_data.ssh1_host_key)->rsa)->n, ((sensitive_data.server_key)->rsa)->n,
                             (u_int8_t *)(cookie), (u_int8_t *)(session_id));
      }
#line 1951
      i = 0;
      }
      {
      {
#line 1951
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 1951
        if (! (i < 16)) {
#line 1951
          goto while_break___3;
        }
#line 1952
        session_key[i] = (u_char )((int )session_key[i] ^ (int )session_id[i]);
#line 1951
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 1955
  if (rsafail) {
    {
    {
#line 1956
    tmp___12 = BN_num_bits((BIGNUM const   *)session_key_int);
    }
#line 1956
    bytes = (tmp___12 + 7) / 8;
    {
#line 1957
    tmp___13 = xmalloc((size_t )bytes);
    }
#line 1957
    buf___1 = (u_char *)tmp___13;
    {
#line 1960
    logit("do_connection: generating a fake encryption key");
    }
    {
#line 1961
    BN_bn2bin((BIGNUM const   *)session_key_int, buf___1);
    }
    {
#line 1962
    MD5_Init(& md);
    }
    {
#line 1963
    MD5_Update(& md, (void const   *)buf___1, (size_t )bytes);
    }
    {
#line 1964
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), (size_t )32);
    }
    {
#line 1965
    MD5_Final(session_key, & md);
    }
    {
#line 1966
    MD5_Init(& md);
    }
    {
#line 1967
    MD5_Update(& md, (void const   *)(session_key), (size_t )16);
    }
    {
#line 1968
    MD5_Update(& md, (void const   *)buf___1, (size_t )bytes);
    }
    {
#line 1969
    MD5_Update(& md, (void const   *)(sensitive_data.ssh1_cookie), (size_t )32);
    }
    {
#line 1970
    MD5_Final(session_key + 16, & md);
    }
    {
#line 1971
    memset((void *)buf___1, 0, (size_t )bytes);
    }
    {
#line 1972
    xfree((void *)buf___1);
    }
#line 1973
    i = 0;
    }
    {
    {
#line 1973
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 1973
      if (! (i < 16)) {
#line 1973
        goto while_break___4;
      }
#line 1974
      session_id[i] = (u_char )((int )session_key[i] ^ (int )session_key[i + 16]);
#line 1973
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
  {
#line 1977
  destroy_sensitive_data();
  }
  }
#line 1979
  if (use_privsep) {
    {
    {
#line 1980
    mm_ssh1_session_id(session_id);
    }
    }
  }
  {
  {
#line 1983
  BN_clear_free(session_key_int);
  }
  {
#line 1986
  packet_set_encryption_key((u_char const   *)(session_key), (u_int )32, (int )cipher_type);
  }
  {
#line 1989
  memset((void *)(session_key), 0, (size_t )sizeof(session_key));
  }
  {
#line 1991
  debug("Received session key; encryption turned on.");
  }
  {
#line 1994
  packet_start((u_char )14);
  }
  {
#line 1995
  packet_send();
  }
  {
#line 1996
  packet_write_wait();
  }
  }
#line 1997
  return;
}
}
#line 2002 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
static void do_ssh2_kex(void) 
{ 
  Kex *kex ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 2007
  if ((unsigned long )options.ciphers != (unsigned long )((void *)0)) {
#line 2008
    myproposal[3] = options.ciphers;
#line 2008
    myproposal[2] = myproposal[3];
  }
  {
  {
#line 2011
  myproposal[2] = compat_cipher_proposal(myproposal[2]);
  }
  {
#line 2013
  myproposal[3] = compat_cipher_proposal(myproposal[3]);
  }
  }
#line 2016
  if ((unsigned long )options.macs != (unsigned long )((void *)0)) {
#line 2017
    myproposal[5] = options.macs;
#line 2017
    myproposal[4] = myproposal[5];
  }
#line 2020
  if (options.compression == 0) {
#line 2021
    myproposal[7] = (char *)"none";
#line 2021
    myproposal[6] = myproposal[7];
  } else
#line 2023
  if (options.compression == 2) {
#line 2024
    myproposal[7] = (char *)"none,zlib@openssh.com";
#line 2024
    myproposal[6] = myproposal[7];
  }
  {
  {
#line 2028
  myproposal[1] = list_hostkey_types();
  }
  {
#line 2031
  kex = kex_setup((char **)(myproposal));
  }
#line 2032
  kex->kex[0] = & kexdh_server;
#line 2033
  kex->kex[1] = & kexdh_server;
#line 2034
  kex->kex[2] = & kexgex_server;
#line 2035
  kex->server = 1;
#line 2036
  kex->client_version_string = client_version_string;
#line 2037
  kex->server_version_string = server_version_string;
#line 2038
  kex->load_host_key = & get_hostkey_by_type;
#line 2039
  kex->host_key_index = & get_hostkey_index;
#line 2041
  xxx_kex = kex;
  {
#line 2043
  dispatch_run(0, & kex->done, (void *)kex);
  }
#line 2045
  session_id2 = kex->session_id;
#line 2046
  session_id2_len = kex->session_id_len;
  {
#line 2055
  debug("KEX done");
  }
  }
#line 2056
  return;
}
}
#line 2059
 __attribute__((__noreturn__)) void cleanup_exit(int i ) ;
#line 2059 "/home/pronto/abs/test-suite/openssh-4.3p2/sshd.c"
void cleanup_exit(int i ) 
{ 


  {
#line 2062
  if (the_authctxt) {
    {
    {
#line 2063
    do_cleanup(the_authctxt);
    }
    }
  }
  {
  {
#line 2069
  _exit(i);
  }
  }
}
}
