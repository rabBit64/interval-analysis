/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 33 "/abs/pronto/test-suite/barcode-0.96/barcode.h"
struct Barcode_Item {
   int flags ;
   char *ascii ;
   char *partial ;
   char *textinfo ;
   char *encoding ;
   int width ;
   int height ;
   int xoff ;
   int yoff ;
   int margin ;
   double scalef ;
   int error ;
};
#line 99 "/abs/pronto/test-suite/barcode-0.96/library.c"
struct encoding {
   int type ;
   int (*verify)(unsigned char *text ) ;
   int (*encode)(struct Barcode_Item *bc ) ;
};
#line 260 "/abs/pronto/test-suite/barcode-0.96/ean.c"
enum __anonenum_encoding_20 {
    UPCA = 0,
    UPCE = 1,
    EAN13 = 2,
    EAN8 = 3,
    ISBN = 4
} ;
#line 26 "/abs/pronto/test-suite/barcode-0.96/cmdline.h"
enum option_type {
    CMDLINE_NONE = 0,
    CMDLINE_I = 1,
    CMDLINE_D = 2,
    CMDLINE_X = 3,
    CMDLINE_O = 4,
    CMDLINE_S = 5,
    CMDLINE_F = 6,
    CMDLINE_P = 7
} ;
#line 38 "/abs/pronto/test-suite/barcode-0.96/cmdline.h"
struct commandline {
   int option ;
   int type ;
   void *result ;
   int (*fun)(void * ) ;
   char *env ;
   char *default_v ;
   char *descrip ;
};
#line 81 "/abs/pronto/test-suite/barcode-0.96/cmdline.c"
struct type_fmt {
   enum option_type type ;
   char *fmt ;
};
#line 41 "/usr/include/paper.h"
struct paper;
#line 44 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct __anonstruct_encode_tab_19 {
   char *name ;
   int type ;
};
#line 135 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct encode_item {
   char *string ;
   struct encode_item *next ;
};
#line 186 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct __anonstruct_ptr_20 {
   char *str ;
   double unit ;
};
#line 434 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 401
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
#line 162 "/usr/include/string.h"
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 62 "/abs/pronto/test-suite/barcode-0.96/ps.c"
int Barcode_ps_print(struct Barcode_Item *bc , FILE *f ) 
{ 
  int i ;
  int j ;
  int k ;
  int barlen ;
  int printable ;
  double f1 ;
  double f2 ;
  double fsav ;
  int mode ;
  double scalef ;
  double xpos ;
  double x0 ;
  double y0 ;
  double yr ;
  unsigned char *ptr___0 ;
  unsigned char c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  double tmp___1 ;
  int wid ;
  double scaleg ;
  int wid___0 ;
  char const   *tmp___2 ;
  unsigned char c___0 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  int tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  char const   *tmp___25 ;

  {
#line 64
  printable = 1;
#line 65
  fsav = (double )0;
#line 66
  mode = '-';
#line 67
  scalef = (double )1;
#line 71
  if (! bc->partial) {
#line 72
    bc->error = 22;
#line 73
    return (-1);
  } else
#line 71
  if (! bc->textinfo) {
#line 72
    bc->error = 22;
#line 73
    return (-1);
  }
#line 83
  barlen = (int )*(bc->partial + 0) - 48;
#line 84
  ptr___0 = (unsigned char *)(bc->partial + 1);
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! *ptr___0) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp___0 = __ctype_b_loc();
    }
#line 85
    if ((int const   )*(*tmp___0 + (int )*ptr___0) & 2048) {
#line 86
      barlen += (int )*ptr___0 - 48;
    } else {
      {
#line 87
      tmp = __ctype_b_loc();
      }
#line 87
      if ((int const   )*(*tmp + (int )*ptr___0) & 512) {
#line 88
        barlen += ((int )*ptr___0 - 97) + 1;
      }
    }
#line 84
    ptr___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  if (! bc->scalef) {
#line 92
    if (! bc->width) {
#line 92
      bc->width = barlen;
    }
#line 93
    tmp___1 = (double )bc->width / (double )barlen;
#line 93
    bc->scalef = tmp___1;
#line 93
    scalef = tmp___1;
  }
#line 97
  if (! bc->width) {
#line 97
    bc->width = (int )((double )barlen * scalef + (double )1);
  }
#line 100
  if ((double )bc->width < (double )barlen * scalef) {
#line 101
    wid = (int )((double )barlen * scalef + (double )1);
#line 102
    bc->xoff -= (wid - bc->width) / 2;
#line 103
    bc->width = wid;
#line 105
    if (bc->xoff < 0) {
#line 106
      bc->width += - bc->xoff;
#line 107
      bc->xoff = 0;
    }
  }
#line 112
  if (! bc->height) {
#line 112
    bc->height = (int )((double )80 * scalef);
  }
#line 128
  i = 5 + 10 * ((bc->flags & 256) == 0);
#line 129
  if ((double )bc->height < (double )i * scalef) {
#line 130
    scaleg = (double )bc->height / (double )i;
#line 131
    wid___0 = (int )(((double )bc->width * scaleg) / scalef);
#line 132
    bc->xoff += (bc->width - wid___0) / 2;
#line 133
    bc->width = wid___0;
#line 134
    scalef = scaleg;
  }
#line 142
  if (! (bc->flags & 1048576)) {
#line 143
    if (bc->flags & 4096) {
      {
#line 144
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%!PS-Adobe-2.0 EPSF-1.2\n");
      }
    } else {
      {
#line 146
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%!PS-Adobe-2.0\n");
      }
    }
    {
#line 147
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%%%Creator: libbarcode\n");
    }
#line 148
    if (bc->flags & 4096) {
      {
#line 149
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%%%BoundingBox: %i %i %i %i\n",
              bc->xoff, bc->yoff, (bc->xoff + bc->width) + 2 * bc->margin, (bc->yoff + bc->height) + 2 * bc->margin);
      }
    }
    {
#line 155
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%%%EndComments\n");
    }
#line 156
    if (bc->flags & 8192) {
      {
#line 157
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%%%EndProlog\n\n");
#line 158
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%%%Page: 1 1\n\n");
      }
    }
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! *(bc->ascii + i)) {
#line 163
      goto while_break___0;
    }
#line 164
    if ((int )*(bc->ascii + i) < 32) {
#line 165
      printable = 0;
    }
#line 163
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  if (printable) {
#line 167
    tmp___2 = (char const   *)bc->ascii;
  } else {
#line 167
    tmp___2 = "<unprintable string>";
  }
  {
#line 167
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%% Printing barcode for \"%s\", scaled %5.2f",
          tmp___2, scalef);
  }
#line 169
  if (bc->encoding) {
    {
#line 170
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)", encoded using \"%s\"",
            bc->encoding);
    }
  }
  {
#line 171
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 172
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%% The space/bar succession is represented by the following widths (space first):\n%% ");
#line 175
  i = 0;
  }
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 175
    tmp___6 = strlen((char const   *)bc->partial);
    }
#line 175
    if (! ((size_t )i < tmp___6)) {
#line 175
      goto while_break___1;
    }
    {
#line 176
    c___0 = (unsigned char )*(bc->partial + i);
#line 177
    tmp___3 = __ctype_b_loc();
    }
#line 177
    if ((int const   )*(*tmp___3 + (int )c___0) & 2048) {
      {
#line 177
      _IO_putc((int )c___0, f);
      }
    }
    {
#line 178
    tmp___4 = __ctype_b_loc();
    }
#line 178
    if ((int const   )*(*tmp___4 + (int )c___0) & 512) {
      {
#line 178
      _IO_putc(((int )c___0 - 97) + 49, f);
      }
    }
    {
#line 179
    tmp___5 = __ctype_b_loc();
    }
#line 179
    if ((int const   )*(*tmp___5 + (int )c___0) & 256) {
      {
#line 179
      _IO_putc(((int )c___0 - 65) + 49, f);
      }
    }
#line 175
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 182
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n[\n%%  height  xpos   ypos  width       height  xpos   ypos  width\n");
#line 185
  xpos = (double )bc->margin + (double )((int )*(bc->partial + 0) - 48) * scalef;
#line 186
  ptr___0 = (unsigned char *)(bc->partial + 1);
#line 186
  i = 1;
  }
  {
#line 186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 186
    if (! *ptr___0) {
#line 186
      goto while_break___2;
    }
#line 188
    if ((int )*ptr___0 == 43) {
#line 189
      mode = (int )*ptr___0;
#line 189
      i ++;
#line 189
      goto __Cont;
    } else
#line 188
    if ((int )*ptr___0 == 45) {
#line 189
      mode = (int )*ptr___0;
#line 189
      i ++;
#line 189
      goto __Cont;
    }
    {
#line 192
    tmp___7 = __ctype_b_loc();
    }
#line 192
    if ((int const   )*(*tmp___7 + (int )*ptr___0) & 2048) {
#line 192
      j = (int )*ptr___0 - 48;
    } else {
#line 193
      j = ((int )*ptr___0 - 97) + 1;
    }
#line 194
    if (i % 2) {
#line 195
      x0 = ((double )bc->xoff + xpos) + ((double )j * scalef) / (double )2;
#line 196
      y0 = (double )(bc->yoff + bc->margin);
#line 197
      yr = (double )bc->height;
#line 198
      if (! (bc->flags & 256)) {
#line 199
        if (mode == 45) {
          {
#line 201
          tmp___10 = __ctype_b_loc();
          }
#line 201
          if ((int const   )*(*tmp___10 + (int )*ptr___0) & 2048) {
#line 201
            tmp___9 = 10;
          } else {
#line 201
            tmp___9 = 5;
          }
          {
#line 201
          y0 += (double )tmp___9 * scalef;
#line 202
          tmp___13 = __ctype_b_loc();
          }
#line 202
          if ((int const   )*(*tmp___13 + (int )*ptr___0) & 2048) {
#line 202
            tmp___12 = 10;
          } else {
#line 202
            tmp___12 = 5;
          }
#line 202
          yr -= (double )tmp___12 * scalef;
        } else {
          {
#line 205
          tmp___16 = __ctype_b_loc();
          }
#line 205
          if ((int const   )*(*tmp___16 + (int )*ptr___0) & 2048) {
#line 205
            tmp___15 = 10;
          } else {
#line 205
            tmp___15 = 0;
          }
          {
#line 205
          y0 += (double )tmp___15 * scalef;
#line 206
          tmp___19 = __ctype_b_loc();
          }
#line 206
          if ((int const   )*(*tmp___19 + (int )*ptr___0) & 2048) {
#line 206
            tmp___18 = 20;
          } else {
#line 206
            tmp___18 = 10;
          }
#line 206
          yr -= (double )tmp___18 * scalef;
        }
      }
#line 210
      if (i % 4 == 1) {
#line 210
        tmp___20 = "   ";
      } else {
#line 210
        tmp___20 = "\n";
      }
      {
#line 210
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"   [%5.2f %6.2f %6.2f %5.2f]%s",
              yr, x0, y0, (double )j * scalef - 0.15, tmp___20);
      }
    }
#line 214
    xpos += (double )j * scalef;
    __Cont: /* CIL Label */ 
#line 186
    ptr___0 ++;
#line 186
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 216
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n]\t{ {} forall setlinewidth moveto 0 exch rlineto stroke} bind forall\n[\n%%   char    xpos   ypos fontsize\n");
#line 222
  mode = '-';
  }
#line 223
  if (! (bc->flags & 256)) {
#line 224
    k = 0;
#line 225
    ptr___0 = (unsigned char *)bc->textinfo;
    {
#line 225
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 225
      if (! ptr___0) {
#line 225
        goto while_break___3;
      }
      {
#line 226
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 226
        if (! ((int )*ptr___0 == 32)) {
#line 226
          goto while_break___4;
        }
#line 226
        ptr___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 227
      if (! *ptr___0) {
#line 227
        goto while_break___3;
      }
#line 228
      if ((int )*ptr___0 == 43) {
#line 229
        mode = (int )*ptr___0;
#line 229
        goto __Cont___0;
      } else
#line 228
      if ((int )*ptr___0 == 45) {
#line 229
        mode = (int )*ptr___0;
#line 229
        goto __Cont___0;
      }
      {
#line 231
      tmp___22 = sscanf((char const   */* __restrict  */)ptr___0, (char const   */* __restrict  */)"%lf:%lf:%c",
                        & f1, & f2, & c);
      }
#line 231
      if (tmp___22 != 3) {
        {
#line 232
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"barcode: impossible data: %s\n",
                ptr___0);
        }
#line 233
        goto __Cont___0;
      }
      {
#line 236
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"    [(");
      }
#line 238
      if ((int )c == 92) {
        {
#line 239
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\\%c) ",
                (int )c);
        }
      } else
#line 238
      if ((int )c == 41) {
        {
#line 239
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\\%c) ",
                (int )c);
        }
      } else
#line 238
      if ((int )c == 40) {
        {
#line 239
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\\%c) ",
                (int )c);
        }
      } else {
        {
#line 241
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%c)  ",
                (int )c);
        }
      }
#line 242
      if (fsav == f2) {
#line 242
        tmp___23 = 0.0;
      } else {
#line 242
        tmp___23 = f2 * scalef;
      }
#line 242
      if (mode == 45) {
#line 242
        tmp___24 = (double )bc->yoff + (double )bc->margin;
      } else {
#line 242
        tmp___24 = (((double )bc->yoff + (double )bc->margin) + (double )bc->height) - (double )8 * scalef;
      }
      {
#line 242
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%6.2f %6.2f %5.2f]\n",
              ((double )bc->xoff + f1 * scalef) + (double )bc->margin, tmp___24, tmp___23);
#line 248
      fsav = f2;
      }
      __Cont___0: /* CIL Label */ 
      {
#line 225
      tmp___21 = strchr((char const   *)ptr___0, ' ');
#line 225
      ptr___0 = (unsigned char *)tmp___21;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 250
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"]   { {} forall dup 0.00 ne {\n\t/Helvetica findfont exch scalefont setfont\n    } {pop} ifelse\n    moveto show} bind forall\n");
    }
  }
#line 258
  if (printable) {
#line 258
    tmp___25 = (char const   *)bc->ascii;
  } else {
#line 258
    tmp___25 = "<unprintable string>";
  }
  {
#line 258
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%% End barcode for \"%s\"\n\n",
          tmp___25);
  }
#line 261
  if (! (bc->flags & 1048576)) {
    {
#line 262
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"showpage\n");
    }
#line 263
    if (bc->flags & 8192) {
      {
#line 264
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%%%%Trailer\n\n");
      }
    }
  }
#line 267
  return (0);
}
}
#line 329 "/usr/include/stdio.h"
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 477
extern int fputc(int __c , FILE *__stream ) ;
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 558
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 569
extern void free(void *__ptr ) ;
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 126
extern char *strdup(char const   *__s )  __attribute__((__malloc__)) ;
#line 119 "/usr/include/ctype.h"
extern int toupper(int __c ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 29 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char *patterns[2]  = {      (char *)"13",      (char *)"31"};
#line 32 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char alphabet[17]  = 
#line 32
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'\000'};
#line 36 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char *fillers[2]  = {      (char *)"031311331",      (char *)"331311313"};
#line 38 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static int width  =    16;
#line 38 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static int startpos  =    16;
#line 44 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
int Barcode_pls_verify(unsigned char *text___8 ) 
{ 
  int i ;
  int upper ;
  int lower ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 46
  upper = 0;
#line 46
  lower = 0;
#line 48
  tmp = strlen((char const   *)text___8);
  }
#line 48
  if (! tmp) {
#line 49
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! *(text___8 + i)) {
#line 50
      goto while_break;
    }
    {
#line 51
    tmp___0 = toupper((int )*(text___8 + i));
#line 51
    tmp___1 = strchr((char const   *)(alphabet), tmp___0);
    }
#line 51
    if (! tmp___1) {
#line 52
      return (-1);
    }
    {
#line 53
    tmp___2 = __ctype_b_loc();
    }
#line 53
    if ((int const   )*(*tmp___2 + (int )*(text___8 + i)) & 256) {
#line 53
      upper ++;
    }
    {
#line 54
    tmp___3 = __ctype_b_loc();
    }
#line 54
    if ((int const   )*(*tmp___3 + (int )*(text___8 + i)) & 512) {
#line 54
      lower ++;
    }
#line 50
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (upper) {
#line 56
    if (lower) {
#line 57
      return (-1);
    }
  }
#line 58
  return (0);
}
}
#line 61 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static int add_one(char *ptr___0 , int code ) 
{ 


  {
  {
#line 63
  sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"%s%s%s%s",
          patterns[code & 1], patterns[(code >> 1) & 1], patterns[(code >> 2) & 1],
          patterns[(code >> 3) & 1]);
  }
#line 69
  return (0);
}
}
#line 78 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char *text  ;
#line 79 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char *partial  ;
#line 80 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char *textinfo  ;
#line 84
int Barcode_pls_encode(struct Barcode_Item *bc ) ;
#line 84 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
static char check[9]  = 
#line 84
  {      (char)1,      (char)1,      (char)1,      (char)1, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)1};
#line 76 "/abs/pronto/test-suite/barcode-0.96/plessey.c"
int Barcode_pls_encode(struct Barcode_Item *bc ) 
{ 
  char *c ;
  char *ptr___0 ;
  char *textptr ;
  unsigned char *checkptr ;
  int i ;
  int code ;
  int textpos ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int j ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;

  {
#line 85
  if (bc->partial) {
    {
#line 86
    free((void *)bc->partial);
    }
  }
#line 87
  if (bc->textinfo) {
    {
#line 88
    free((void *)bc->textinfo);
    }
  }
#line 89
  tmp = (char *)((void *)0);
#line 89
  bc->textinfo = tmp;
#line 89
  bc->partial = tmp;
#line 91
  if (! bc->encoding) {
    {
#line 92
    bc->encoding = strdup("plessey");
    }
  }
#line 94
  text = bc->ascii;
#line 95
  if (! text) {
#line 96
    bc->error = 22;
#line 97
    return (-1);
  }
  {
#line 100
  tmp___0 = strlen((char const   *)text);
#line 100
  tmp___1 = malloc((tmp___0 + 4U) * 8U + 3U);
#line 100
  partial = (char *)tmp___1;
#line 101
  tmp___2 = strlen((char const   *)text);
#line 101
  tmp___3 = calloc((size_t )1, tmp___2 * 4U + 8U);
#line 101
  checkptr = (unsigned char *)tmp___3;
  }
#line 103
  if (! partial) {
#line 103
    goto _L;
  } else
#line 103
  if (! checkptr) {
    _L: /* CIL Label */ 
#line 104
    if (partial) {
      {
#line 104
      free((void *)partial);
      }
    }
#line 105
    if (checkptr) {
      {
#line 105
      free((void *)checkptr);
      }
    }
    {
#line 106
    tmp___4 = __errno_location();
#line 106
    bc->error = *tmp___4;
    }
#line 107
    return (-1);
  }
  {
#line 111
  tmp___5 = strlen((char const   *)text);
#line 111
  tmp___6 = malloc(10U * tmp___5 + 2U);
#line 111
  textinfo = (char *)tmp___6;
  }
#line 112
  if (! textinfo) {
    {
#line 113
    tmp___7 = __errno_location();
#line 113
    bc->error = *tmp___7;
#line 114
    free((void *)partial);
    }
#line 115
    return (-1);
  }
  {
#line 118
  strcpy((char */* __restrict  */)partial, (char const   */* __restrict  */)fillers[0]);
#line 119
  tmp___8 = strlen((char const   *)partial);
#line 119
  ptr___0 = partial + tmp___8;
#line 120
  textptr = textinfo;
#line 121
  textpos = startpos;
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    tmp___13 = strlen((char const   *)text);
    }
#line 123
    if (! ((size_t )i < tmp___13)) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___9 = toupper((int )*(text + i));
#line 124
    c = strchr((char const   *)(alphabet), tmp___9);
    }
#line 125
    if (! c) {
      {
#line 126
      bc->error = 22;
#line 127
      free((void *)partial);
#line 128
      free((void *)textinfo);
      }
#line 129
      return (-1);
    }
    {
#line 131
    code = (int )(c - alphabet);
#line 132
    add_one(ptr___0, code);
#line 133
    tmp___10 = toupper((int )*(text + i));
#line 133
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c ",
            textpos, tmp___10);
#line 135
    textpos += width;
#line 136
    tmp___11 = strlen((char const   *)textptr);
#line 136
    textptr += tmp___11;
#line 137
    tmp___12 = strlen((char const   *)ptr___0);
#line 137
    ptr___0 += tmp___12;
#line 138
    *(checkptr + 4 * i) = (unsigned char )(code & 1);
#line 139
    *(checkptr + (4 * i + 1)) = (unsigned char )((code >> 1) & 1);
#line 140
    *(checkptr + (4 * i + 2)) = (unsigned char )((code >> 2) & 1);
#line 141
    *(checkptr + (4 * i + 3)) = (unsigned char )((code >> 3) & 1);
#line 123
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 144
    tmp___14 = strlen((char const   *)text);
    }
#line 144
    if (! ((size_t )i < 4U * tmp___14)) {
#line 144
      goto while_break___0;
    }
#line 146
    if (*(checkptr + i)) {
#line 147
      j = 0;
      {
#line 147
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 147
        if (! (j < 9)) {
#line 147
          goto while_break___1;
        }
#line 148
        *(checkptr + (i + j)) = (unsigned char )((int )*(checkptr + (i + j)) ^ (int )check[j]);
#line 147
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 144
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 150
    if (! (i < 8)) {
#line 150
      goto while_break___2;
    }
    {
#line 151
    tmp___15 = strlen((char const   *)text);
#line 151
    sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)patterns[*(checkptr + (tmp___15 * 4U + (size_t )i))]);
#line 152
    ptr___0 += 2;
#line 150
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CRC: ");
#line 155
  i = 0;
  }
  {
#line 155
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 155
    if (! (i < 8)) {
#line 155
      goto while_break___3;
    }
    {
#line 156
    tmp___16 = strlen((char const   *)text);
#line 156
    fputc(48 + (int )*(checkptr + (tmp___16 * 4U + (size_t )i)), stderr);
#line 155
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 158
  fputc('\n', stderr);
#line 159
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)fillers[1]);
#line 160
  bc->partial = partial;
#line 161
  bc->textinfo = textinfo;
  }
#line 163
  return (0);
}
}
#line 31 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static char *patterns___0[2]  = {      (char *)"13",      (char *)"31"};
#line 33 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static char *fillers___0[2]  = {      (char *)"031",      (char *)"131"};
#line 35 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static int width___0  =    16;
#line 35 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static int startpos___0  =    6;
#line 41 "/abs/pronto/test-suite/barcode-0.96/msi.c"
int Barcode_msi_verify(unsigned char *text___8 ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 45
  tmp = strlen((char const   *)text___8);
  }
#line 45
  if (! tmp) {
#line 46
    return (-1);
  }
#line 47
  i = 0;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! *(text___8 + i)) {
#line 47
      goto while_break;
    }
    {
#line 48
    tmp___0 = __ctype_b_loc();
    }
#line 48
    if (! ((int const   )*(*tmp___0 + (int )*(text___8 + i)) & 2048)) {
#line 49
      return (-1);
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (0);
}
}
#line 54 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static int add_one___0(char *ptr___0 , int code ) 
{ 


  {
  {
#line 56
  sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"%s%s%s%s",
          patterns___0[(code >> 3) & 1], patterns___0[(code >> 2) & 1], patterns___0[(code >> 1) & 1],
          patterns___0[code & 1]);
  }
#line 61
  return (0);
}
}
#line 70 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static char *text___0  ;
#line 71 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static char *partial___0  ;
#line 72 "/abs/pronto/test-suite/barcode-0.96/msi.c"
static char *textinfo___0  ;
#line 68 "/abs/pronto/test-suite/barcode-0.96/msi.c"
int Barcode_msi_encode(struct Barcode_Item *bc ) 
{ 
  char *ptr___0 ;
  char *textptr ;
  int i ;
  int code ;
  int textpos ;
  int usesum ;
  int checksum ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
#line 74
  checksum = 0;
#line 76
  if (bc->partial) {
    {
#line 77
    free((void *)bc->partial);
    }
  }
#line 78
  if (bc->textinfo) {
    {
#line 79
    free((void *)bc->textinfo);
    }
  }
#line 80
  tmp = (char *)((void *)0);
#line 80
  bc->textinfo = tmp;
#line 80
  bc->partial = tmp;
#line 82
  if (! bc->encoding) {
    {
#line 83
    bc->encoding = strdup("msi");
    }
  }
#line 85
  if (bc->flags & 512) {
#line 86
    usesum = 0;
  } else {
#line 88
    usesum = 1;
  }
  {
#line 90
  text___0 = bc->ascii;
#line 93
  tmp___0 = strlen((char const   *)text___0);
#line 93
  tmp___1 = malloc(((3U + 8U * (tmp___0 + 1U)) + 3U) + 2U);
#line 93
  partial___0 = (char *)tmp___1;
  }
#line 94
  if (! partial___0) {
    {
#line 95
    tmp___2 = __errno_location();
#line 95
    bc->error = *tmp___2;
    }
#line 96
    return (-1);
  }
  {
#line 100
  tmp___3 = strlen((char const   *)text___0);
#line 100
  tmp___4 = malloc(10U * tmp___3 + 2U);
#line 100
  textinfo___0 = (char *)tmp___4;
  }
#line 101
  if (! textinfo___0) {
    {
#line 102
    tmp___5 = __errno_location();
#line 102
    bc->error = *tmp___5;
#line 103
    free((void *)partial___0);
    }
#line 104
    return (-1);
  }
  {
#line 107
  strcpy((char */* __restrict  */)partial___0, (char const   */* __restrict  */)fillers___0[0]);
#line 108
  tmp___6 = strlen((char const   *)partial___0);
#line 108
  ptr___0 = partial___0 + tmp___6;
#line 109
  textptr = textinfo___0;
#line 110
  textpos = startpos___0;
#line 112
  i = 0;
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 112
    tmp___10 = strlen((char const   *)text___0);
    }
#line 112
    if (! ((size_t )i < tmp___10)) {
#line 112
      goto while_break;
    }
    {
#line 113
    code = (int )*(text___0 + i) - 48;
#line 114
    add_one___0(ptr___0, code);
#line 115
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c ",
            textpos, (int )*(text___0 + i));
#line 117
    textpos += width___0;
#line 118
    tmp___7 = strlen((char const   *)textptr);
#line 118
    textptr += tmp___7;
#line 119
    tmp___8 = strlen((char const   *)ptr___0);
#line 119
    ptr___0 += tmp___8;
    }
#line 120
    if (usesum) {
      {
#line 127
      tmp___9 = strlen((char const   *)text___0);
      }
#line 127
      if (((unsigned int )i ^ tmp___9) & 1U) {
#line 129
        checksum += 2 * code + (2 * code) / 10;
      } else {
#line 131
        checksum += code;
      }
    }
#line 112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (usesum) {
    {
#line 144
    checksum = ((checksum + 9) / 10) * 10 - checksum;
#line 146
    add_one___0(ptr___0, checksum);
#line 147
    tmp___11 = strlen((char const   *)ptr___0);
#line 147
    ptr___0 += tmp___11;
    }
  }
  {
#line 150
  strcpy((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)fillers___0[1]);
#line 151
  bc->partial = partial___0;
#line 152
  bc->textinfo = textinfo___0;
  }
#line 154
  return (0);
}
}
#line 58 "/usr/include/string.h"
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 84 "/abs/pronto/test-suite/barcode-0.96/barcode.h"
struct Barcode_Item *Barcode_Create(char *text___8 ) ;
#line 85
int Barcode_Delete(struct Barcode_Item *bc ) ;
#line 90
int Barcode_Encode(struct Barcode_Item *bc , int flags ) ;
#line 91
int Barcode_Print(struct Barcode_Item *bc , FILE *f , int flags ) ;
#line 96
int Barcode_Position(struct Barcode_Item *bc , int wid , int hei , int xoff , int yoff ,
                     double scalef ) ;
#line 102
int Barcode_Encode_and_Print(char *text___8 , FILE *f , int wid , int hei , int xoff ,
                             int yoff , int flags ) ;
#line 109
int Barcode_Version(char *vptr ) ;
#line 37 "/abs/pronto/test-suite/barcode-0.96/library.c"
struct Barcode_Item *Barcode_Create(char *text___8 ) 
{ 
  struct Barcode_Item *bc ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc((size_t )sizeof(*bc));
#line 41
  bc = (struct Barcode_Item *)tmp;
  }
#line 42
  if (! bc) {
#line 42
    return ((struct Barcode_Item *)((void *)0));
  }
  {
#line 44
  memset((void *)bc, 0, (size_t )sizeof(*bc));
#line 45
  bc->ascii = strdup((char const   *)text___8);
#line 46
  bc->margin = 10;
  }
#line 47
  return (bc);
}
}
#line 54 "/abs/pronto/test-suite/barcode-0.96/library.c"
int Barcode_Delete(struct Barcode_Item *bc ) 
{ 


  {
#line 56
  if (bc->ascii) {
    {
#line 57
    free((void *)bc->ascii);
    }
  }
#line 58
  if (bc->partial) {
    {
#line 59
    free((void *)bc->partial);
    }
  }
#line 60
  if (bc->textinfo) {
    {
#line 61
    free((void *)bc->textinfo);
    }
  }
#line 62
  if (bc->encoding) {
    {
#line 63
    free((void *)bc->encoding);
    }
  }
  {
#line 64
  free((void *)bc);
  }
#line 65
  return (0);
}
}
#line 73
int Barcode_ean_verify(unsigned char *text___8 ) ;
#line 74
int Barcode_ean_encode(struct Barcode_Item *bc ) ;
#line 75
int Barcode_upc_verify(unsigned char *text___8 ) ;
#line 76
int Barcode_upc_encode(struct Barcode_Item *bc ) ;
#line 77
int Barcode_isbn_verify(unsigned char *text___8 ) ;
#line 78
int Barcode_isbn_encode(struct Barcode_Item *bc ) ;
#line 79
int Barcode_39_verify(unsigned char *text___8 ) ;
#line 80
int Barcode_39_encode(struct Barcode_Item *bc ) ;
#line 81
int Barcode_128b_verify(char *text___8 ) ;
#line 82
int Barcode_128b_encode(struct Barcode_Item *bc ) ;
#line 83
int Barcode_128c_verify(unsigned char *text___8 ) ;
#line 84
int Barcode_128c_encode(struct Barcode_Item *bc ) ;
#line 85
int Barcode_128_verify(unsigned char *text___8 ) ;
#line 86
int Barcode_128_encode(struct Barcode_Item *bc ) ;
#line 87
int Barcode_128raw_verify(unsigned char *text___8 ) ;
#line 88
int Barcode_128raw_encode(struct Barcode_Item *bc ) ;
#line 89
int Barcode_i25_verify(unsigned char *text___8 ) ;
#line 90
int Barcode_i25_encode(struct Barcode_Item *bc ) ;
#line 91
int Barcode_cbr_verify(unsigned char *text___8 ) ;
#line 92
int Barcode_cbr_encode(struct Barcode_Item *bc ) ;
#line 105 "/abs/pronto/test-suite/barcode-0.96/library.c"
struct encoding encodings[13]  = 
#line 105
  {      {1, & Barcode_ean_verify, & Barcode_ean_encode}, 
        {2, & Barcode_upc_verify, & Barcode_upc_encode}, 
        {3, & Barcode_isbn_verify, & Barcode_isbn_encode}, 
        {7, (int (*)(unsigned char *text ))(& Barcode_128b_verify), & Barcode_128b_encode}, 
        {6,
      & Barcode_128c_verify, & Barcode_128c_encode}, 
        {9, & Barcode_128raw_verify, & Barcode_128raw_encode}, 
        {4, & Barcode_39_verify, & Barcode_39_encode}, 
        {8, & Barcode_i25_verify, & Barcode_i25_encode}, 
        {5, & Barcode_128_verify, & Barcode_128_encode}, 
        {10, & Barcode_cbr_verify, & Barcode_cbr_encode}, 
        {12, & Barcode_pls_verify, & Barcode_pls_encode}, 
        {11, & Barcode_msi_verify, & Barcode_msi_encode}, 
        {0, (int (*)(unsigned char *text ))((void *)0), (int (*)(struct Barcode_Item *bc ))((void *)0)}};
#line 127 "/abs/pronto/test-suite/barcode-0.96/library.c"
int Barcode_Encode(struct Barcode_Item *bc , int flags ) 
{ 
  int validbits ;
  struct encoding *cptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 129
  validbits = 767;
#line 133
  if (! (flags & 255)) {
#line 134
    flags |= bc->flags & 255;
  }
#line 135
  tmp = (flags & validbits) | (bc->flags & ~ validbits);
#line 135
  bc->flags = tmp;
#line 135
  flags = tmp;
#line 137
  if (! (flags & 255)) {
#line 139
    cptr = encodings;
    {
#line 139
    while (1) {
      while_continue: /* CIL Label */ ;
#line 139
      if (! cptr->verify) {
#line 139
        goto while_break;
      }
      {
#line 140
      tmp___0 = (*(cptr->verify))((unsigned char *)bc->ascii);
      }
#line 140
      if (tmp___0 == 0) {
#line 141
        goto while_break;
      }
#line 139
      cptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 142
    if (! cptr->verify) {
#line 143
      bc->error = 22;
#line 144
      return (-1);
    }
#line 146
    flags |= cptr->type;
#line 147
    bc->flags |= cptr->type;
  }
#line 149
  cptr = encodings;
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if (! cptr->verify) {
#line 149
      goto while_break___0;
    }
#line 150
    if (cptr->type == (flags & 255)) {
#line 151
      goto while_break___0;
    }
#line 149
    cptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 152
  if (! cptr->verify) {
#line 153
    bc->error = 22;
#line 154
    return (-1);
  }
  {
#line 156
  tmp___1 = (*(cptr->verify))((unsigned char *)bc->ascii);
  }
#line 156
  if (tmp___1 != 0) {
#line 157
    bc->error = 22;
#line 158
    return (-1);
  }
  {
#line 160
  tmp___2 = (*(cptr->encode))(bc);
  }
#line 160
  return (tmp___2);
}
}
#line 175 "/abs/pronto/test-suite/barcode-0.96/library.c"
int Barcode_Print(struct Barcode_Item *bc , FILE *f , int flags ) 
{ 
  int validbits ;
  int tmp ;
  int tmp___0 ;

  {
#line 177
  validbits = 2093312;
#line 181
  if (! (flags & 1044480)) {
#line 182
    flags |= bc->flags & 1044480;
  }
#line 183
  if (! (flags & 256)) {
#line 184
    flags |= bc->flags & 256;
  }
#line 185
  if (! (flags & 1048576)) {
#line 186
    flags |= bc->flags & 1048576;
  }
  {
#line 187
  tmp = (flags & validbits) | (bc->flags & ~ validbits);
#line 187
  bc->flags = tmp;
#line 187
  flags = tmp;
#line 189
  tmp___0 = Barcode_ps_print(bc, f);
  }
#line 189
  return (tmp___0);
}
}
#line 195 "/abs/pronto/test-suite/barcode-0.96/library.c"
int Barcode_Position(struct Barcode_Item *bc , int wid , int hei , int xoff , int yoff ,
                     double scalef ) 
{ 


  {
#line 198
  bc->width = wid;
#line 198
  bc->height = hei;
#line 199
  bc->xoff = xoff;
#line 199
  bc->yoff = yoff;
#line 200
  bc->scalef = scalef;
#line 201
  return (0);
}
}
#line 207 "/abs/pronto/test-suite/barcode-0.96/library.c"
int Barcode_Encode_and_Print(char *text___8 , FILE *f , int wid , int hei , int xoff ,
                             int yoff , int flags ) 
{ 
  struct Barcode_Item *bc ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 212
  bc = Barcode_Create(text___8);
  }
#line 212
  if (! bc) {
    {
#line 213
    tmp = __errno_location();
#line 213
    *tmp = -12;
    }
#line 214
    return (-1);
  }
  {
#line 216
  tmp___1 = Barcode_Position(bc, wid, hei, xoff, yoff, 0.0);
  }
#line 216
  if (tmp___1 < 0) {
    {
#line 219
    tmp___0 = __errno_location();
#line 219
    *tmp___0 = bc->error;
#line 220
    Barcode_Delete(bc);
    }
#line 221
    return (-1);
  } else {
    {
#line 216
    tmp___2 = Barcode_Encode(bc, flags);
    }
#line 216
    if (tmp___2 < 0) {
      {
#line 219
      tmp___0 = __errno_location();
#line 219
      *tmp___0 = bc->error;
#line 220
      Barcode_Delete(bc);
      }
#line 221
      return (-1);
    } else {
      {
#line 216
      tmp___3 = Barcode_Print(bc, f, flags);
      }
#line 216
      if (tmp___3 < 0) {
        {
#line 219
        tmp___0 = __errno_location();
#line 219
        *tmp___0 = bc->error;
#line 220
        Barcode_Delete(bc);
        }
#line 221
        return (-1);
      }
    }
  }
  {
#line 223
  Barcode_Delete(bc);
  }
#line 224
  return (0);
}
}
#line 231 "/abs/pronto/test-suite/barcode-0.96/library.c"
int Barcode_Version(char *vptr ) 
{ 


  {
#line 233
  if (vptr) {
    {
#line 234
    strcpy((char */* __restrict  */)vptr, (char const   */* __restrict  */)"0.96");
    }
  }
#line 235
  return (9600);
}
}
#line 89 "/usr/include/string.h"
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 30 "/abs/pronto/test-suite/barcode-0.96/i25.c"
static char *codes[10]  = 
#line 30 "/abs/pronto/test-suite/barcode-0.96/i25.c"
  {      (char *)"11331",      (char *)"31113",      (char *)"13113",      (char *)"33111", 
        (char *)"11313",      (char *)"31311",      (char *)"13311",      (char *)"11133", 
        (char *)"31131",      (char *)"13131"};
#line 35 "/abs/pronto/test-suite/barcode-0.96/i25.c"
static char *guard[2]  = {      (char *)"a1a1",      (char *)"c1a"};
#line 37 "/abs/pronto/test-suite/barcode-0.96/i25.c"
int Barcode_i25_verify(unsigned char *text___8 ) 
{ 
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 39
  tmp = strlen((char const   *)text___8);
  }
#line 39
  if (! tmp) {
#line 40
    return (-1);
  }
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (*text___8) {
      {
#line 41
      tmp___0 = __ctype_b_loc();
      }
#line 41
      if (! ((int const   )*(*tmp___0 + (int )*text___8) & 2048)) {
#line 41
        goto while_break;
      }
    } else {
#line 41
      goto while_break;
    }
#line 42
    text___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  if (*text___8) {
#line 44
    return (-1);
  }
#line 45
  return (0);
}
}
#line 48 "/abs/pronto/test-suite/barcode-0.96/i25.c"
int Barcode_i25_encode(struct Barcode_Item *bc ) 
{ 
  unsigned char *text___8 ;
  unsigned char *partial___8 ;
  unsigned char *textinfo___8 ;
  unsigned char *textptr ;
  unsigned char *p1 ;
  unsigned char *p2 ;
  unsigned char *pd ;
  int i ;
  int sum[2] ;
  int textpos ;
  int usesum ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  size_t tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;

  {
#line 54
  usesum = 0;
#line 56
  if (bc->partial) {
    {
#line 57
    free((void *)bc->partial);
    }
  }
#line 58
  if (bc->textinfo) {
    {
#line 59
    free((void *)bc->textinfo);
    }
  }
#line 60
  tmp = (char *)((void *)0);
#line 60
  bc->textinfo = tmp;
#line 60
  bc->partial = tmp;
#line 62
  if (! bc->encoding) {
    {
#line 63
    bc->encoding = strdup("interleaved 2 of 5");
    }
  }
#line 65
  text___8 = (unsigned char *)bc->ascii;
#line 66
  if (! bc->ascii) {
#line 67
    bc->error = 22;
#line 68
    return (-1);
  }
#line 71
  if (bc->flags & 512) {
#line 71
    usesum = 0;
  } else {
#line 71
    usesum = 1;
  }
  {
#line 74
  tmp___0 = strlen((char const   *)bc->ascii);
#line 74
  tmp___1 = malloc(tmp___0 + 3U);
#line 74
  text___8 = (unsigned char *)tmp___1;
  }
#line 75
  if (! text___8) {
    {
#line 76
    tmp___2 = __errno_location();
#line 76
    bc->error = *tmp___2;
    }
#line 77
    return (-1);
  }
  {
#line 80
  tmp___3 = strlen((char const   *)bc->ascii);
#line 80
  i = (int )(tmp___3 + (size_t )usesum);
  }
#line 81
  if (i % 2) {
    {
#line 83
    *(text___8 + 0) = (unsigned char )'0';
#line 84
    strcpy((char */* __restrict  */)(text___8 + 1), (char const   */* __restrict  */)bc->ascii);
    }
  } else {
    {
#line 86
    strcpy((char */* __restrict  */)text___8, (char const   */* __restrict  */)bc->ascii);
    }
  }
#line 89
  if (usesum) {
#line 90
    sum[1] = 0;
#line 90
    sum[0] = sum[1];
#line 91
    i = 0;
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (! *(text___8 + i)) {
#line 91
        goto while_break;
      }
#line 92
      sum[i % 2] += (int )*(text___8 + i) - 48;
#line 91
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 99
    i = sum[0] * 3 + sum[1];
#line 100
    strcat((char */* __restrict  */)text___8, (char const   */* __restrict  */)"0");
#line 101
    tmp___4 = strlen((char const   *)text___8);
#line 101
    *(text___8 + (tmp___4 - 1U)) = (unsigned char )((int )*(text___8 + (tmp___4 - 1U)) + (10 - i % 10) % 10);
    }
  }
  {
#line 105
  tmp___5 = strlen((char const   *)text___8);
#line 105
  tmp___6 = malloc((tmp___5 + 3U) * 5U + 2U);
#line 105
  partial___8 = (unsigned char *)tmp___6;
  }
#line 106
  if (! partial___8) {
    {
#line 107
    tmp___7 = __errno_location();
#line 107
    bc->error = *tmp___7;
#line 108
    free((void *)text___8);
    }
#line 109
    return (-1);
  }
  {
#line 113
  tmp___8 = strlen((char const   *)text___8);
#line 113
  tmp___9 = malloc(10U * (tmp___8 + 1U) + 2U);
#line 113
  textinfo___8 = (unsigned char *)tmp___9;
  }
#line 114
  if (! textinfo___8) {
    {
#line 115
    tmp___10 = __errno_location();
#line 115
    bc->error = *tmp___10;
#line 116
    free((void *)partial___8);
#line 117
    free((void *)text___8);
    }
#line 118
    return (-1);
  }
  {
#line 122
  strcpy((char */* __restrict  */)partial___8, (char const   */* __restrict  */)"0");
#line 123
  strcat((char */* __restrict  */)partial___8, (char const   */* __restrict  */)guard[0]);
#line 124
  textpos = 4;
#line 125
  textptr = textinfo___8;
#line 127
  i = 0;
  }
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 127
    tmp___20 = strlen((char const   *)text___8);
    }
#line 127
    if (! ((size_t )i < tmp___20)) {
#line 127
      goto while_break___0;
    }
    {
#line 128
    tmp___11 = __ctype_b_loc();
    }
#line 128
    if ((int const   )*(*tmp___11 + (int )*(text___8 + i)) & 2048) {
      {
#line 128
      tmp___12 = __ctype_b_loc();
      }
#line 128
      if (! ((int const   )*(*tmp___12 + (int )*(text___8 + (i + 1))) & 2048)) {
        {
#line 129
        bc->error = 22;
#line 130
        free((void *)partial___8);
#line 131
        free((void *)textinfo___8);
#line 132
        free((void *)text___8);
        }
#line 133
        return (-1);
      }
    } else {
      {
#line 129
      bc->error = 22;
#line 130
      free((void *)partial___8);
#line 131
      free((void *)textinfo___8);
#line 132
      free((void *)text___8);
      }
#line 133
      return (-1);
    }
    {
#line 136
    p1 = (unsigned char *)codes[(int )*(text___8 + i) - 48];
#line 137
    p2 = (unsigned char *)codes[(int )*(text___8 + (i + 1)) - 48];
#line 138
    tmp___13 = strlen((char const   *)partial___8);
#line 138
    pd = partial___8 + tmp___13;
    }
    {
#line 139
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 139
      if (! *p1) {
#line 139
        goto while_break___1;
      }
#line 140
      tmp___14 = pd;
#line 140
      pd ++;
#line 140
      tmp___15 = p1;
#line 140
      p1 ++;
#line 140
      *tmp___14 = *tmp___15;
#line 141
      tmp___16 = pd;
#line 141
      pd ++;
#line 141
      tmp___17 = p2;
#line 141
      p2 ++;
#line 141
      *tmp___16 = *tmp___17;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 143
    *pd = (unsigned char )'\000';
#line 145
    if (usesum) {
      {
#line 145
      tmp___18 = strlen((char const   *)(text___8 + i));
      }
#line 145
      if (tmp___18 == 2U) {
        {
#line 147
        sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c ",
                textpos, (int )*(text___8 + i));
        }
      } else {
        {
#line 149
        sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c %i:12:%c ",
                textpos, (int )*(text___8 + i), textpos + 9, (int )*(text___8 + (i + 1)));
        }
      }
    } else {
      {
#line 149
      sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c %i:12:%c ",
              textpos, (int )*(text___8 + i), textpos + 9, (int )*(text___8 + (i + 1)));
      }
    }
    {
#line 152
    textpos += 18;
#line 153
    tmp___19 = strlen((char const   *)textptr);
#line 153
    textptr += tmp___19;
#line 127
    i += 2;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 155
  strcat((char */* __restrict  */)partial___8, (char const   */* __restrict  */)guard[1]);
#line 157
  bc->partial = (char *)partial___8;
#line 158
  bc->textinfo = (char *)textinfo___8;
#line 159
  free((void *)text___8);
  }
#line 161
  return (0);
}
}
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 47 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *digits[10]  = 
#line 47 "/abs/pronto/test-suite/barcode-0.96/ean.c"
  {      (char *)"3211",      (char *)"2221",      (char *)"2122",      (char *)"1411", 
        (char *)"1132",      (char *)"1231",      (char *)"1114",      (char *)"1312", 
        (char *)"1213",      (char *)"3112"};
#line 56 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *ean_mirrortab[10]  = 
#line 56
  {      (char *)"------",      (char *)"--1-11",      (char *)"--11-1",      (char *)"--111-", 
        (char *)"-1--11",      (char *)"-11--1",      (char *)"-111--",      (char *)"-1-1-1", 
        (char *)"-1-11-",      (char *)"-11-1-"};
#line 67 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *upc_mirrortab[10]  = 
#line 67
  {      (char *)"---111",      (char *)"--1-11",      (char *)"--11-1",      (char *)"--111-", 
        (char *)"-1--11",      (char *)"-11--1",      (char *)"-111--",      (char *)"-1-1-1", 
        (char *)"-1-11-",      (char *)"-11-1-"};
#line 72 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *upc_mirrortab2[4]  = {      (char *)"11",      (char *)"1-",      (char *)"-1",      (char *)"--"};
#line 80 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *guard___0[3]  = {      (char *)"0a1a",      (char *)"1a1a1",      (char *)"a1a"};
#line 83 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *guardE[2]  = {      (char *)"0a1a",      (char *)"1a1a1a"};
#line 86 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *guardS[2]  = {      (char *)"9112",      (char *)"11"};
#line 93 "/abs/pronto/test-suite/barcode-0.96/ean.c"
int Barcode_ean_verify(unsigned char *text___8 ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 95
  tmp = strlen((char const   *)text___8);
#line 95
  len = (int )tmp;
  }
#line 96
  if (len != 12) {
#line 96
    if (len != 7) {
#line 96
      if (len != 15) {
#line 96
        if (len != 18) {
#line 97
          return (-1);
        }
      }
    }
  }
#line 99
  if (len > 12) {
#line 100
    if ((int )*(text___8 + 12) != 32) {
#line 101
      return (-1);
    } else {
      {
#line 100
      tmp___0 = __ctype_b_loc();
      }
#line 100
      if ((int const   )*(*tmp___0 + (int )*(text___8 + 13)) & 2048) {
        {
#line 100
        tmp___1 = __ctype_b_loc();
        }
#line 100
        if (! ((int const   )*(*tmp___1 + (int )*(text___8 + 14)) & 2048)) {
#line 101
          return (-1);
        }
      } else {
#line 101
        return (-1);
      }
    }
#line 102
    if (len == 18) {
      {
#line 103
      tmp___2 = __ctype_b_loc();
      }
#line 103
      if ((int const   )*(*tmp___2 + (int )*(text___8 + 15)) & 2048) {
        {
#line 103
        tmp___3 = __ctype_b_loc();
        }
#line 103
        if ((int const   )*(*tmp___3 + (int )*(text___8 + 16)) & 2048) {
          {
#line 103
          tmp___4 = __ctype_b_loc();
          }
#line 103
          if (! ((int const   )*(*tmp___4 + (int )*(text___8 + 17)) & 2048)) {
#line 104
            return (-1);
          }
        } else {
#line 104
          return (-1);
        }
      } else {
#line 104
        return (-1);
      }
    }
#line 106
    len = 12;
  }
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < len)) {
#line 109
      goto while_break;
    }
    {
#line 110
    tmp___5 = __ctype_b_loc();
    }
#line 110
    if (! ((int const   )*(*tmp___5 + (int )*(text___8 + i)) & 2048)) {
#line 111
      return (-1);
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (0);
}
}
#line 118 "/abs/pronto/test-suite/barcode-0.96/ean.c"
int Barcode_upc_verify(unsigned char *text___8 ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 120
  tmp = strlen((char const   *)text___8);
#line 120
  len = (int )tmp;
  }
#line 121
  if (len != 11) {
#line 121
    if (len != 6) {
#line 121
      if (len != 14) {
#line 121
        if (len != 17) {
#line 122
          return (-1);
        }
      }
    }
  }
#line 124
  if (len > 11) {
#line 125
    if ((int )*(text___8 + 11) != 32) {
#line 126
      return (-1);
    } else {
      {
#line 125
      tmp___0 = __ctype_b_loc();
      }
#line 125
      if ((int const   )*(*tmp___0 + (int )*(text___8 + 12)) & 2048) {
        {
#line 125
        tmp___1 = __ctype_b_loc();
        }
#line 125
        if (! ((int const   )*(*tmp___1 + (int )*(text___8 + 13)) & 2048)) {
#line 126
          return (-1);
        }
      } else {
#line 126
        return (-1);
      }
    }
#line 127
    if (len == 17) {
      {
#line 128
      tmp___2 = __ctype_b_loc();
      }
#line 128
      if ((int const   )*(*tmp___2 + (int )*(text___8 + 14)) & 2048) {
        {
#line 128
        tmp___3 = __ctype_b_loc();
        }
#line 128
        if ((int const   )*(*tmp___3 + (int )*(text___8 + 15)) & 2048) {
          {
#line 128
          tmp___4 = __ctype_b_loc();
          }
#line 128
          if (! ((int const   )*(*tmp___4 + (int )*(text___8 + 16)) & 2048)) {
#line 129
            return (-1);
          }
        } else {
#line 129
          return (-1);
        }
      } else {
#line 129
        return (-1);
      }
    }
#line 131
    len = 11;
  }
#line 134
  i = 0;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < len)) {
#line 134
      goto while_break;
    }
    {
#line 135
    tmp___5 = __ctype_b_loc();
    }
#line 135
    if (! ((int const   )*(*tmp___5 + (int )*(text___8 + i)) & 2048)) {
#line 136
      return (-1);
    }
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return (0);
}
}
#line 145 "/abs/pronto/test-suite/barcode-0.96/ean.c"
int Barcode_isbn_verify(unsigned char *text___8 ) 
{ 
  int i ;
  int ndigit ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 147
  ndigit = 0;
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    tmp___0 = strlen((char const   *)text___8);
    }
#line 149
    if (! ((size_t )i < tmp___0)) {
#line 149
      goto while_break;
    }
#line 150
    if ((int )*(text___8 + i) == 45) {
#line 151
      goto __Cont;
    }
    {
#line 152
    tmp = __ctype_b_loc();
    }
#line 152
    if ((int const   )*(*tmp + (int )*(text___8 + i)) & 2048) {
#line 153
      ndigit ++;
#line 154
      if (ndigit == 9) {
#line 155
        i ++;
#line 155
        goto while_break;
      }
#line 157
      goto __Cont;
    }
#line 159
    return (-1);
    __Cont: /* CIL Label */ 
#line 149
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (ndigit != 9) {
#line 161
    return (-1);
  }
#line 164
  if ((int )*(text___8 + i) == 45) {
#line 165
    i ++;
  }
  {
#line 167
  tmp___1 = __ctype_b_loc();
  }
#line 167
  if ((int const   )*(*tmp___1 + (int )*(text___8 + i)) & 2048) {
#line 168
    i ++;
  } else {
    {
#line 167
    tmp___2 = toupper((int )*(text___8 + i));
    }
#line 167
    if (tmp___2 == 88) {
#line 168
      i ++;
    }
  }
#line 169
  if ((int )*(text___8 + i) == 0) {
#line 170
    return (0);
  }
  {
#line 173
  tmp___3 = strlen((char const   *)(text___8 + i));
  }
#line 173
  if (tmp___3 != 6U) {
#line 174
    return (-1);
  }
#line 175
  if ((int )*(text___8 + i) != 32) {
#line 176
    return (-1);
  }
#line 177
  i ++;
  {
#line 178
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! *(text___8 + i)) {
#line 178
      goto while_break___0;
    }
    {
#line 179
    tmp___4 = __ctype_b_loc();
    }
#line 179
    if (! ((int const   )*(*tmp___4 + (int )*(text___8 + i)) & 2048)) {
#line 180
      return (-1);
    }
#line 181
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  return (0);
}
}
#line 189 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static int ean_make_checksum(char *text___8 , int mode ) 
{ 
  int esum ;
  int osum ;
  int i ;
  int even ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 191
  esum = 0;
#line 191
  osum = 0;
#line 192
  even = 1;
#line 194
  tmp___1 = strchr((char const   *)text___8, ' ');
  }
#line 194
  if (tmp___1) {
    {
#line 195
    tmp = strchr((char const   *)text___8, ' ');
#line 195
    i = (int )(tmp - text___8);
    }
  } else {
    {
#line 197
    tmp___0 = strlen((char const   *)text___8);
#line 197
    i = (int )tmp___0;
    }
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    tmp___2 = i;
#line 199
    i --;
#line 199
    if (! (tmp___2 > 0)) {
#line 199
      goto while_break;
    }
#line 200
    if (even) {
#line 200
      esum += (int )*(text___8 + i) - 48;
    } else {
#line 201
      osum += (int )*(text___8 + i) - 48;
    }
#line 202
    even = ! even;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (! mode) {
#line 205
    i = (3 * esum + osum) % 10;
#line 206
    return ((10 - i) % 10);
  } else {
#line 208
    i = 3 * esum + 9 * osum;
#line 209
    return (i % 10);
  }
}
}
#line 216 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char result[16]  ;
#line 214 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char *upc_e_to_a(char *text___8 ) 
{ 


  {
  {
#line 217
  strcpy((char */* __restrict  */)(result), (char const   */* __restrict  */)"00000000000");
  }
  {
#line 220
  if ((int )*(text___8 + 5) == 50) {
#line 220
    goto case_50;
  }
#line 220
  if ((int )*(text___8 + 5) == 49) {
#line 220
    goto case_50;
  }
#line 220
  if ((int )*(text___8 + 5) == 48) {
#line 220
    goto case_50;
  }
#line 223
  if ((int )*(text___8 + 5) == 51) {
#line 223
    goto case_51;
  }
#line 226
  if ((int )*(text___8 + 5) == 52) {
#line 226
    goto case_52;
  }
#line 229
  goto switch_default;
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 221
  memcpy((void */* __restrict  */)(result + 1), (void const   */* __restrict  */)text___8,
         (size_t )2);
#line 221
  result[3] = *(text___8 + 5);
#line 222
  memcpy((void */* __restrict  */)(result + 8), (void const   */* __restrict  */)(text___8 + 2),
         (size_t )3);
  }
  case_51: /* CIL Label */ 
  {
#line 224
  memcpy((void */* __restrict  */)(result + 1), (void const   */* __restrict  */)text___8,
         (size_t )3);
#line 225
  memcpy((void */* __restrict  */)(result + 9), (void const   */* __restrict  */)(text___8 + 3),
         (size_t )2);
  }
  case_52: /* CIL Label */ 
  {
#line 227
  memcpy((void */* __restrict  */)(result + 1), (void const   */* __restrict  */)text___8,
         (size_t )4);
#line 228
  memcpy((void */* __restrict  */)(result + 10), (void const   */* __restrict  */)(text___8 + 4),
         (size_t )1);
  }
  switch_default: /* CIL Label */ 
  {
#line 230
  memcpy((void */* __restrict  */)(result + 1), (void const   */* __restrict  */)text___8,
         (size_t )5);
#line 231
  memcpy((void */* __restrict  */)(result + 10), (void const   */* __restrict  */)(text___8 + 5),
         (size_t )1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 233
  return (result);
}
}
#line 236 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static int width_of_partial(unsigned char *partial___8 ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 238
  i = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! *partial___8) {
#line 239
      goto while_break;
    }
    {
#line 240
    tmp___0 = __ctype_b_loc();
    }
#line 240
    if ((int const   )*(*tmp___0 + (int )*partial___8) & 2048) {
#line 241
      i += (int )*partial___8 - 48;
    } else {
      {
#line 242
      tmp = __ctype_b_loc();
      }
#line 242
      if ((int const   )*(*tmp + (int )*partial___8) & 512) {
#line 243
        i += ((int )*partial___8 - 97) + 1;
      }
    }
#line 244
    partial___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (i);
}
}
#line 255 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char text___1[24]  ;
#line 256 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char partial___1[256]  ;
#line 257 "/abs/pronto/test-suite/barcode-0.96/ean.c"
static char textinfo___1[256]  ;
#line 253 "/abs/pronto/test-suite/barcode-0.96/ean.c"
int Barcode_ean_encode(struct Barcode_Item *bc ) 
{ 
  char *mirror ;
  char *ptr1 ;
  char *ptr2 ;
  char *tptr ;
  enum __anonenum_encoding_20 encoding ;
  int i ;
  int xpos ;
  int checksum ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 258
  tptr = textinfo___1;
#line 260
  encoding = (enum __anonenum_encoding_20 )4;
#line 263
  if (! bc->ascii) {
#line 264
    bc->error = 22;
#line 265
    return (-1);
  }
#line 267
  if (! bc->encoding) {
    {
#line 269
    tmp = strlen((char const   *)bc->ascii);
    }
    {
#line 270
    if (tmp == 12U) {
#line 270
      goto case_12;
    }
#line 274
    if (tmp == 11U) {
#line 274
      goto case_11;
    }
#line 278
    if (tmp == 7U) {
#line 278
      goto case_7;
    }
#line 282
    if (tmp == 6U) {
#line 282
      goto case_6;
    }
#line 286
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 271
    bc->encoding = strdup("EAN-13");
#line 272
    encoding = (enum __anonenum_encoding_20 )2;
    }
#line 273
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 275
    bc->encoding = strdup("UPC-A");
#line 276
    encoding = (enum __anonenum_encoding_20 )0;
    }
#line 277
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 279
    bc->encoding = strdup("EAN-8");
#line 280
    encoding = (enum __anonenum_encoding_20 )3;
    }
#line 281
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 283
    bc->encoding = strdup("UPC-E");
#line 284
    encoding = (enum __anonenum_encoding_20 )1;
    }
#line 285
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 288
    tmp___0 = strlen((char const   *)bc->ascii);
    }
#line 288
    if (tmp___0 > 13U) {
#line 289
      if ((int )*(bc->ascii + 12) == 32) {
        {
#line 290
        bc->encoding = strdup("EAN-13");
#line 291
        encoding = (enum __anonenum_encoding_20 )2;
        }
#line 291
        goto switch_break;
      }
#line 293
      if ((int )*(bc->ascii + 11) == 32) {
        {
#line 294
        bc->encoding = strdup("UPC-A");
#line 295
        encoding = (enum __anonenum_encoding_20 )0;
        }
#line 295
        goto switch_break;
      }
    }
#line 299
    bc->error = -22;
#line 300
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 305
  if (bc->partial) {
    {
#line 305
    free((void *)bc->partial);
    }
  }
#line 305
  bc->partial = (char *)((void *)0);
#line 306
  if (bc->textinfo) {
    {
#line 306
    free((void *)bc->textinfo);
    }
  }
#line 306
  bc->textinfo = (char *)((void *)0);
#line 308
  if ((unsigned int )encoding == 0U) {
    {
#line 309
    text___1[0] = (char )'0';
#line 310
    strcpy((char */* __restrict  */)(text___1 + 1), (char const   */* __restrict  */)bc->ascii);
    }
  } else {
    {
#line 312
    strcpy((char */* __restrict  */)(text___1), (char const   */* __restrict  */)bc->ascii);
    }
  }
#line 318
  if ((unsigned int )encoding == 0U) {
#line 318
    goto _L;
  } else
#line 318
  if ((unsigned int )encoding == 2U) {
#line 318
    goto _L;
  } else
#line 318
  if ((unsigned int )encoding == 4U) {
    _L: /* CIL Label */ 
    {
#line 320
    checksum = ean_make_checksum(text___1, 0);
#line 321
    text___1[12] = (char )(48 + checksum);
#line 322
    text___1[13] = (char )'\000';
#line 324
    strcpy((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guard___0[0]);
    }
#line 325
    if ((unsigned int )encoding == 2U) {
      {
#line 326
      sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"0:12:%c ",
              (int )text___1[0]);
#line 327
      tmp___1 = strlen((char const   *)tptr);
#line 327
      tptr += tmp___1;
#line 328
      partial___1[0] = (char )'9';
      }
    } else
#line 325
    if ((unsigned int )encoding == 4U) {
      {
#line 326
      sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"0:12:%c ",
              (int )text___1[0]);
#line 327
      tmp___1 = strlen((char const   *)tptr);
#line 327
      tptr += tmp___1;
#line 328
      partial___1[0] = (char )'9';
      }
    } else
#line 329
    if ((unsigned int )encoding == 0U) {
#line 330
      partial___1[0] = (char )'9';
    }
    {
#line 331
    xpos = width_of_partial((unsigned char *)(partial___1));
#line 332
    mirror = ean_mirrortab[(int )text___1[0] - 48];
#line 335
    i = 1;
    }
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
#line 335
      if (! (i < 7)) {
#line 335
        goto while_break;
      }
      {
#line 336
      tmp___2 = strlen((char const   *)(partial___1));
#line 336
      ptr1 = partial___1 + tmp___2;
#line 337
      ptr2 = digits[(int )text___1[i] - 48];
#line 338
      strcpy((char */* __restrict  */)ptr1, (char const   */* __restrict  */)ptr2);
      }
#line 339
      if ((int )*(mirror + (i - 1)) == 49) {
#line 341
        *(ptr1 + 0) = *(ptr2 + 3);
#line 342
        *(ptr1 + 1) = *(ptr2 + 2);
#line 343
        *(ptr1 + 2) = *(ptr2 + 1);
#line 344
        *(ptr1 + 3) = *(ptr2 + 0);
      }
#line 350
      if ((unsigned int )encoding == 0U) {
#line 350
        if (i == 1) {
          {
#line 351
          sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"0:10:%c ",
                  (int )text___1[i]);
#line 352
          tmp___3 = strlen((char const   *)tptr);
#line 352
          tptr += tmp___3;
#line 353
          *(ptr1 + 1) = (char )((int )*(ptr1 + 1) + 48);
#line 354
          *(ptr1 + 3) = (char )((int )*(ptr1 + 3) + 48);
          }
        } else {
          {
#line 356
          sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
                  xpos, (int )text___1[i]);
#line 357
          tmp___4 = strlen((char const   *)tptr);
#line 357
          tptr += tmp___4;
          }
        }
      } else {
        {
#line 356
        sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
                xpos, (int )text___1[i]);
#line 357
        tmp___4 = strlen((char const   *)tptr);
#line 357
        tptr += tmp___4;
        }
      }
#line 360
      xpos += 7;
#line 335
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 363
    strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guard___0[1]);
#line 364
    tmp___5 = width_of_partial((unsigned char *)guard___0[1]);
#line 364
    xpos += tmp___5;
#line 367
    i = 7;
    }
    {
#line 367
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 367
      if (! (i < 13)) {
#line 367
        goto while_break___0;
      }
      {
#line 368
      tmp___6 = strlen((char const   *)(partial___1));
#line 368
      ptr1 = partial___1 + tmp___6;
#line 369
      ptr2 = digits[(int )text___1[i] - 48];
#line 370
      strcpy((char */* __restrict  */)ptr1, (char const   */* __restrict  */)ptr2);
      }
#line 375
      if ((unsigned int )encoding == 0U) {
#line 375
        if (i == 12) {
          {
#line 376
          sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:10:%c ",
                  xpos + 13, (int )text___1[i]);
#line 377
          tmp___7 = strlen((char const   *)tptr);
#line 377
          tptr += tmp___7;
#line 378
          *(ptr1 + 0) = (char )((int )*(ptr1 + 0) + 48);
#line 379
          *(ptr1 + 2) = (char )((int )*(ptr1 + 2) + 48);
          }
        } else {
          {
#line 381
          sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
                  xpos, (int )text___1[i]);
#line 382
          tmp___8 = strlen((char const   *)tptr);
#line 382
          tptr += tmp___8;
          }
        }
      } else {
        {
#line 381
        sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
                xpos, (int )text___1[i]);
#line 382
        tmp___8 = strlen((char const   *)tptr);
#line 382
        tptr += tmp___8;
        }
      }
#line 384
      xpos += 7;
#line 367
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 386
    *(tptr + -1) = (char )'\000';
#line 387
    strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guard___0[2]);
#line 388
    tmp___9 = width_of_partial((unsigned char *)guard___0[2]);
#line 388
    xpos += tmp___9;
#line 394
    ptr1 = strchr((char const   *)bc->ascii, ' ');
    }
#line 394
    if (ptr1) {
      {
#line 395
      ptr1 ++;
#line 396
      tmp___10 = strlen((char const   *)ptr1);
      }
#line 396
      if (tmp___10 != 2U) {
        {
#line 396
        tmp___11 = strlen((char const   *)ptr1);
        }
#line 396
        if (tmp___11 != 5U) {
#line 397
          bc->error = 22;
#line 398
          return (-1);
        }
      }
      {
#line 400
      strcpy((char */* __restrict  */)(text___1), (char const   */* __restrict  */)ptr1);
#line 401
      tmp___13 = strlen((char const   *)ptr1);
      }
#line 401
      if (tmp___13 == 5U) {
        {
#line 402
        checksum = ean_make_checksum(text___1, 1);
#line 403
        mirror = upc_mirrortab[checksum] + 1;
        }
      } else {
        {
#line 405
        tmp___12 = atoi((char const   *)(text___1));
#line 405
        checksum = tmp___12 % 4;
#line 406
        mirror = upc_mirrortab2[checksum];
        }
      }
      {
#line 408
      strcat((char */* __restrict  */)(textinfo___1), (char const   */* __restrict  */)" +");
#line 408
      strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)"+");
#line 409
      tmp___14 = strlen((char const   *)(textinfo___1));
#line 409
      tptr = textinfo___1 + tmp___14;
#line 410
      i = 0;
      }
      {
#line 410
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 410
        tmp___19 = strlen((char const   *)(text___1));
        }
#line 410
        if (! ((size_t )i < tmp___19)) {
#line 410
          goto while_break___1;
        }
#line 411
        if (! i) {
          {
#line 412
          strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guardS[0]);
#line 413
          tmp___15 = width_of_partial((unsigned char *)guardS[0]);
#line 413
          xpos += tmp___15;
          }
        } else {
          {
#line 415
          strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guardS[1]);
#line 416
          tmp___16 = width_of_partial((unsigned char *)guardS[1]);
#line 416
          xpos += tmp___16;
          }
        }
        {
#line 418
        tmp___17 = strlen((char const   *)(partial___1));
#line 418
        ptr1 = partial___1 + tmp___17;
#line 419
        ptr2 = digits[(int )text___1[i] - 48];
#line 420
        strcpy((char */* __restrict  */)ptr1, (char const   */* __restrict  */)ptr2);
        }
#line 421
        if ((int )*(mirror + i) != 49) {
#line 423
          *(ptr1 + 0) = *(ptr2 + 3);
#line 424
          *(ptr1 + 1) = *(ptr2 + 2);
#line 425
          *(ptr1 + 2) = *(ptr2 + 1);
#line 426
          *(ptr1 + 3) = *(ptr2 + 0);
        }
        {
#line 429
        sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)" %i:12:%c",
                xpos, (int )text___1[i]);
#line 430
        tmp___18 = strlen((char const   *)tptr);
#line 430
        tptr += tmp___18;
#line 431
        xpos += 7;
#line 410
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else
#line 435
  if ((unsigned int )encoding == 1U) {
    {
#line 437
    tmp___20 = upc_e_to_a(text___1);
#line 437
    checksum = ean_make_checksum(tmp___20, 0);
#line 439
    strcpy((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guardE[0]);
#line 440
    xpos = width_of_partial((unsigned char *)(partial___1));
#line 441
    mirror = upc_mirrortab[checksum];
#line 443
    i = 0;
    }
    {
#line 443
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 443
      if (! (i < 6)) {
#line 443
        goto while_break___2;
      }
      {
#line 444
      tmp___21 = strlen((char const   *)(partial___1));
#line 444
      ptr1 = partial___1 + tmp___21;
#line 445
      ptr2 = digits[(int )text___1[i] - 48];
#line 446
      strcpy((char */* __restrict  */)ptr1, (char const   */* __restrict  */)ptr2);
      }
#line 447
      if ((int )*(mirror + i) != 49) {
#line 449
        *(ptr1 + 0) = *(ptr2 + 3);
#line 450
        *(ptr1 + 1) = *(ptr2 + 2);
#line 451
        *(ptr1 + 2) = *(ptr2 + 1);
#line 452
        *(ptr1 + 3) = *(ptr2 + 0);
      }
      {
#line 454
      sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
              xpos, (int )text___1[i]);
#line 455
      tmp___22 = strlen((char const   *)tptr);
#line 455
      tptr += tmp___22;
#line 456
      xpos += 7;
#line 443
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 458
    *(tptr + -1) = (char )'\000';
#line 459
    strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guardE[1]);
    }
  } else {
    {
#line 463
    checksum = ean_make_checksum(text___1, 0);
#line 464
    text___1[7] = (char )(48 + checksum);
#line 465
    text___1[8] = (char )'\000';
#line 467
    strcpy((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guard___0[0]);
#line 468
    xpos = width_of_partial((unsigned char *)(partial___1));
#line 471
    i = 0;
    }
    {
#line 471
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 471
      if (! (i < 4)) {
#line 471
        goto while_break___3;
      }
      {
#line 472
      tmp___23 = strlen((char const   *)(partial___1));
#line 472
      strcpy((char */* __restrict  */)(partial___1 + tmp___23), (char const   */* __restrict  */)digits[(int )text___1[i] - 48]);
#line 473
      sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
              xpos, (int )text___1[i]);
#line 474
      tmp___24 = strlen((char const   *)tptr);
#line 474
      tptr += tmp___24;
#line 475
      xpos += 7;
#line 471
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 477
    strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guard___0[1]);
#line 478
    tmp___25 = width_of_partial((unsigned char *)guard___0[1]);
#line 478
    xpos += tmp___25;
#line 481
    i = 4;
    }
    {
#line 481
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 481
      if (! (i < 8)) {
#line 481
        goto while_break___4;
      }
      {
#line 482
      tmp___26 = strlen((char const   *)(partial___1));
#line 482
      strcpy((char */* __restrict  */)(partial___1 + tmp___26), (char const   */* __restrict  */)digits[(int )text___1[i] - 48]);
#line 483
      sprintf((char */* __restrict  */)tptr, (char const   */* __restrict  */)"%i:12:%c ",
              xpos, (int )text___1[i]);
#line 484
      tmp___27 = strlen((char const   *)tptr);
#line 484
      tptr += tmp___27;
#line 485
      xpos += 7;
#line 481
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 487
    *(tptr + -1) = (char )'\000';
#line 488
    strcat((char */* __restrict  */)(partial___1), (char const   */* __restrict  */)guard___0[2]);
    }
  }
  {
#line 492
  bc->partial = strdup((char const   *)(partial___1));
  }
#line 493
  if (! bc->partial) {
    {
#line 494
    tmp___28 = __errno_location();
#line 494
    bc->error = *tmp___28;
    }
#line 495
    return (-1);
  }
  {
#line 497
  bc->textinfo = strdup((char const   *)(textinfo___1));
  }
#line 498
  if (! bc->textinfo) {
    {
#line 499
    tmp___29 = __errno_location();
#line 499
    bc->error = *tmp___29;
#line 500
    free((void *)bc->partial);
#line 501
    bc->partial = (char *)((void *)0);
    }
#line 502
    return (-1);
  }
#line 504
  if (! bc->width) {
    {
#line 505
    bc->width = width_of_partial((unsigned char *)(partial___1));
    }
  }
#line 507
  return (0);
}
}
#line 510 "/abs/pronto/test-suite/barcode-0.96/ean.c"
int Barcode_upc_encode(struct Barcode_Item *bc ) 
{ 
  int tmp ;

  {
  {
#line 512
  tmp = Barcode_ean_encode(bc);
  }
#line 512
  return (tmp);
}
}
#line 515 "/abs/pronto/test-suite/barcode-0.96/ean.c"
int Barcode_isbn_encode(struct Barcode_Item *bc ) 
{ 
  unsigned char *text___8 ;
  void *tmp ;
  unsigned char *otext ;
  int i ;
  int j ;
  int retval ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 518
  tmp = malloc((size_t )24);
#line 518
  text___8 = (unsigned char *)tmp;
  }
#line 522
  if (! text___8) {
#line 523
    bc->error = 12;
#line 524
    return (-1);
  }
  {
#line 526
  strcpy((char */* __restrict  */)text___8, (char const   */* __restrict  */)"978");
#line 526
  j = 3;
#line 528
  otext = (unsigned char *)bc->ascii;
#line 529
  i = 0;
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! *(otext + i)) {
#line 529
      goto while_break;
    }
    {
#line 530
    tmp___1 = __ctype_b_loc();
    }
#line 530
    if ((int const   )*(*tmp___1 + (int )*(otext + i)) & 2048) {
#line 531
      tmp___0 = j;
#line 531
      j ++;
#line 531
      *(text___8 + tmp___0) = *(otext + i);
    }
#line 532
    if (j == 12) {
#line 533
      goto while_break;
    }
#line 529
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  *(text___8 + j) = (unsigned char )'\000';
#line 536
  tmp___3 = strchr((char const   *)otext, ' ');
  }
#line 536
  if (tmp___3) {
    {
#line 537
    tmp___2 = strchr((char const   *)otext, ' ');
#line 537
    strcat((char */* __restrict  */)text___8, (char const   */* __restrict  */)tmp___2);
    }
  }
  {
#line 538
  bc->ascii = (char *)text___8;
#line 539
  bc->encoding = strdup("ISBN");
#line 540
  retval = Barcode_ean_encode(bc);
#line 541
  bc->ascii = (char *)otext;
#line 542
  free((void *)text___8);
  }
#line 543
  return (retval);
}
}
#line 32 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char alphabet___0[45]  = 
#line 32 "/abs/pronto/test-suite/barcode-0.96/code39.c"
  {      (char )'1',      (char )'2',      (char )'3',      (char )'4', 
        (char )'5',      (char )'6',      (char )'7',      (char )'8', 
        (char )'9',      (char )'0',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'G',      (char )'H',      (char )'I',      (char )'J', 
        (char )'K',      (char )'L',      (char )'M',      (char )'N', 
        (char )'O',      (char )'P',      (char )'Q',      (char )'R', 
        (char )'S',      (char )'T',      (char )'U',      (char )'V', 
        (char )'W',      (char )'X',      (char )'Y',      (char )'Z', 
        (char )'-',      (char )'.',      (char )' ',      (char )'*', 
        (char )'$',      (char )'/',      (char )'+',      (char )'%', 
        (char )'\000'};
#line 36 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char checkbet[44]  = 
#line 36
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'A',      (char )'B', 
        (char )'C',      (char )'D',      (char )'E',      (char )'F', 
        (char )'G',      (char )'H',      (char )'I',      (char )'J', 
        (char )'K',      (char )'L',      (char )'M',      (char )'N', 
        (char )'O',      (char )'P',      (char )'Q',      (char )'R', 
        (char )'S',      (char )'T',      (char )'U',      (char )'V', 
        (char )'W',      (char )'X',      (char )'Y',      (char )'Z', 
        (char )'-',      (char )'.',      (char )' ',      (char )'$', 
        (char )'/',      (char )'+',      (char )'%',      (char )'\000'};
#line 40 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *bars[10]  = 
#line 40
  {      (char *)"31113",      (char *)"13113",      (char *)"33111",      (char *)"11313", 
        (char *)"31311",      (char *)"13311",      (char *)"11133",      (char *)"31131", 
        (char *)"13131",      (char *)"11331"};
#line 45 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *spaces[4]  = {      (char *)"1311",      (char *)"1131",      (char *)"1113",      (char *)"3111"};
#line 48 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *specialbars[4]  = {      (char *)"11111",      (char *)"11111",      (char *)"11111",      (char *)"11111"};
#line 51 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *specialspaces[4]  = {      (char *)"3331",      (char *)"3313",      (char *)"3133",      (char *)"1333"};
#line 54 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *fillers___1[2]  = {      (char *)"0a3a1c1c1a",      (char *)"1a3a1c1c1a"};
#line 64 "/abs/pronto/test-suite/barcode-0.96/code39.c"
int Barcode_39_verify(unsigned char *text___8 ) 
{ 
  int i ;
  int lower ;
  int upper ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 66
  lower = 0;
#line 66
  upper = 0;
#line 68
  tmp = strlen((char const   *)text___8);
  }
#line 68
  if (! tmp) {
#line 69
    return (-1);
  }
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *(text___8 + i)) {
#line 70
      goto while_break;
    }
    {
#line 71
    tmp___0 = __ctype_b_loc();
    }
#line 71
    if ((int const   )*(*tmp___0 + (int )*(text___8 + i)) & 256) {
#line 71
      upper ++;
    }
    {
#line 72
    tmp___1 = __ctype_b_loc();
    }
#line 72
    if ((int const   )*(*tmp___1 + (int )*(text___8 + i)) & 512) {
#line 72
      lower ++;
    }
    {
#line 73
    tmp___2 = toupper((int )*(text___8 + i));
#line 73
    tmp___3 = strchr((char const   *)(alphabet___0), tmp___2);
    }
#line 73
    if (! tmp___3) {
#line 74
      return (-1);
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if (lower) {
#line 76
    if (upper) {
#line 77
      return (-1);
    }
  }
#line 78
  return (0);
}
}
#line 81 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static int add_one___1(char *ptr___0 , int code ) 
{ 
  char *b ;
  char *s ;

  {
#line 85
  if (code < 40) {
#line 86
    b = bars[code % 10];
#line 87
    s = spaces[code / 10];
  } else {
#line 89
    b = specialbars[code - 40];
#line 90
    s = specialspaces[code - 40];
  }
  {
#line 92
  sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"1%c%c%c%c%c%c%c%c%c",
          (int )*(b + 0), (int )*(s + 0), (int )*(b + 1), (int )*(s + 1), (int )*(b + 2),
          (int )*(s + 2), (int )*(b + 3), (int )*(s + 3), (int )*(b + 4));
  }
#line 95
  return (0);
}
}
#line 104 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *text___2  ;
#line 105 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *partial___2  ;
#line 106 "/abs/pronto/test-suite/barcode-0.96/code39.c"
static char *textinfo___2  ;
#line 102 "/abs/pronto/test-suite/barcode-0.96/code39.c"
int Barcode_39_encode(struct Barcode_Item *bc ) 
{ 
  char *c ;
  char *ptr___0 ;
  char *textptr ;
  int i ;
  int code ;
  int textpos ;
  int checksum ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;

  {
#line 108
  checksum = 0;
#line 110
  if (bc->partial) {
    {
#line 111
    free((void *)bc->partial);
    }
  }
#line 112
  if (bc->textinfo) {
    {
#line 113
    free((void *)bc->textinfo);
    }
  }
#line 114
  tmp = (char *)((void *)0);
#line 114
  bc->textinfo = tmp;
#line 114
  bc->partial = tmp;
#line 116
  if (! bc->encoding) {
    {
#line 117
    bc->encoding = strdup("code 39");
    }
  }
#line 119
  text___2 = bc->ascii;
#line 120
  if (! text___2) {
#line 121
    bc->error = 22;
#line 122
    return (-1);
  }
  {
#line 125
  tmp___0 = strlen((char const   *)text___2);
#line 125
  tmp___1 = malloc((tmp___0 + 3U) * 10U + 2U);
#line 125
  partial___2 = (char *)tmp___1;
  }
#line 126
  if (! partial___2) {
    {
#line 127
    tmp___2 = __errno_location();
#line 127
    bc->error = *tmp___2;
    }
#line 128
    return (-1);
  }
  {
#line 132
  tmp___3 = strlen((char const   *)text___2);
#line 132
  tmp___4 = malloc(10U * tmp___3 + 2U);
#line 132
  textinfo___2 = (char *)tmp___4;
  }
#line 133
  if (! textinfo___2) {
    {
#line 134
    tmp___5 = __errno_location();
#line 134
    bc->error = *tmp___5;
#line 135
    free((void *)partial___2);
    }
#line 136
    return (-1);
  }
  {
#line 139
  strcpy((char */* __restrict  */)partial___2, (char const   */* __restrict  */)fillers___1[0]);
#line 140
  tmp___6 = strlen((char const   *)partial___2);
#line 140
  ptr___0 = partial___2 + tmp___6;
#line 141
  textptr = textinfo___2;
#line 142
  textpos = 22;
#line 144
  i = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    tmp___11 = strlen((char const   *)text___2);
    }
#line 144
    if (! ((size_t )i < tmp___11)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp___7 = toupper((int )*(text___2 + i));
#line 145
    c = strchr((char const   *)(alphabet___0), tmp___7);
    }
#line 146
    if (! c) {
      {
#line 147
      bc->error = 22;
#line 148
      free((void *)partial___2);
#line 149
      free((void *)textinfo___2);
      }
#line 150
      return (-1);
    }
    {
#line 152
    code = (int )(c - alphabet___0);
#line 153
    add_one___1(ptr___0, code);
#line 154
    c = strchr((char const   *)(checkbet), (int )*c);
    }
#line 155
    if (c) {
#line 156
      checksum = (int )((long )checksum + (c - checkbet));
    }
    {
#line 157
    tmp___8 = toupper((int )*(text___2 + i));
#line 157
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c ",
            textpos, tmp___8);
#line 159
    textpos += 16;
#line 160
    tmp___9 = strlen((char const   *)textptr);
#line 160
    textptr += tmp___9;
#line 161
    tmp___10 = strlen((char const   *)ptr___0);
#line 161
    ptr___0 += tmp___10;
#line 144
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((bc->flags & 512) == 0) {
    {
#line 165
    tmp___12 = strchr((char const   *)(alphabet___0), (int )checkbet[checksum % 43]);
#line 165
    code = (int )(tmp___12 - alphabet___0);
#line 166
    add_one___1(ptr___0, code);
    }
  }
  {
#line 168
  strcat((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)fillers___1[1]);
#line 169
  bc->partial = partial___2;
#line 170
  bc->textinfo = textinfo___2;
  }
#line 172
  return (0);
}
}
#line 31 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *codeset[107]  = 
#line 31 "/abs/pronto/test-suite/barcode-0.96/code128.c"
  {      (char *)"212222",      (char *)"222122",      (char *)"222221",      (char *)"121223", 
        (char *)"121322",      (char *)"131222",      (char *)"122213",      (char *)"122312", 
        (char *)"132212",      (char *)"221213",      (char *)"221312",      (char *)"231212", 
        (char *)"112232",      (char *)"122132",      (char *)"122231",      (char *)"113222", 
        (char *)"123122",      (char *)"123221",      (char *)"223211",      (char *)"221132", 
        (char *)"221231",      (char *)"213212",      (char *)"223112",      (char *)"312131", 
        (char *)"311222",      (char *)"321122",      (char *)"321221",      (char *)"312212", 
        (char *)"322112",      (char *)"322211",      (char *)"212123",      (char *)"212321", 
        (char *)"232121",      (char *)"111323",      (char *)"131123",      (char *)"131321", 
        (char *)"112313",      (char *)"132113",      (char *)"132311",      (char *)"211313", 
        (char *)"231113",      (char *)"231311",      (char *)"112133",      (char *)"112331", 
        (char *)"132131",      (char *)"113123",      (char *)"113321",      (char *)"133121", 
        (char *)"313121",      (char *)"211331",      (char *)"231131",      (char *)"213113", 
        (char *)"213311",      (char *)"213131",      (char *)"311123",      (char *)"311321", 
        (char *)"331121",      (char *)"312113",      (char *)"312311",      (char *)"332111", 
        (char *)"314111",      (char *)"221411",      (char *)"431111",      (char *)"111224", 
        (char *)"111422",      (char *)"121124",      (char *)"121421",      (char *)"141122", 
        (char *)"141221",      (char *)"112214",      (char *)"112412",      (char *)"122114", 
        (char *)"122411",      (char *)"142112",      (char *)"142211",      (char *)"241211", 
        (char *)"221114",      (char *)"413111",      (char *)"241112",      (char *)"134111", 
        (char *)"111242",      (char *)"121142",      (char *)"121241",      (char *)"114212", 
        (char *)"124112",      (char *)"124211",      (char *)"411212",      (char *)"421112", 
        (char *)"421211",      (char *)"212141",      (char *)"214121",      (char *)"412121", 
        (char *)"111143",      (char *)"111341",      (char *)"131141",      (char *)"114113", 
        (char *)"114311",      (char *)"411113",      (char *)"411311",      (char *)"113141", 
        (char *)"114131",      (char *)"311141",      (char *)"411131",      (char *)"b1a4a2", 
        (char *)"b1a2a4",      (char *)"b1a2c2",      (char *)"b3c1a1b"};
#line 75 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128b_verify(char *text___8 ) 
{ 
  size_t tmp ;

  {
  {
#line 77
  tmp = strlen((char const   *)text___8);
  }
#line 77
  if (! tmp) {
#line 78
    return (-1);
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (*text___8) {
#line 79
      if ((int )*text___8 >= 32) {
#line 79
        if (! (! ((int )*text___8 & 128))) {
#line 79
          goto while_break;
        }
      } else {
#line 79
        goto while_break;
      }
    } else {
#line 79
      goto while_break;
    }
#line 80
    text___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (*text___8) {
#line 82
    return (-1);
  }
#line 83
  return (0);
}
}
#line 88 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *text___3  ;
#line 89 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *partial___3  ;
#line 90 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *textinfo___3  ;
#line 86 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128b_encode(struct Barcode_Item *bc ) 
{ 
  char *textptr ;
  int i ;
  int code ;
  int textpos ;
  int checksum ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
#line 92
  checksum = 0;
#line 94
  if (bc->partial) {
    {
#line 95
    free((void *)bc->partial);
    }
  }
#line 96
  if (bc->textinfo) {
    {
#line 97
    free((void *)bc->textinfo);
    }
  }
#line 98
  tmp = (char *)((void *)0);
#line 98
  bc->textinfo = tmp;
#line 98
  bc->partial = tmp;
#line 100
  if (! bc->encoding) {
    {
#line 101
    bc->encoding = strdup("code 128-B");
    }
  }
#line 103
  text___3 = bc->ascii;
#line 104
  if (! text___3) {
#line 105
    bc->error = 22;
#line 106
    return (-1);
  }
  {
#line 109
  tmp___0 = strlen((char const   *)text___3);
#line 109
  tmp___1 = malloc((tmp___0 + 4U) * 6U + 2U);
#line 109
  partial___3 = (char *)tmp___1;
  }
#line 110
  if (! partial___3) {
    {
#line 111
    tmp___2 = __errno_location();
#line 111
    bc->error = *tmp___2;
    }
#line 112
    return (-1);
  }
  {
#line 116
  tmp___3 = strlen((char const   *)text___3);
#line 116
  tmp___4 = malloc(10U * tmp___3 + 2U);
#line 116
  textinfo___3 = (char *)tmp___4;
  }
#line 117
  if (! textinfo___3) {
    {
#line 118
    tmp___5 = __errno_location();
#line 118
    bc->error = *tmp___5;
#line 119
    free((void *)partial___3);
    }
#line 120
    return (-1);
  }
  {
#line 125
  strcpy((char */* __restrict  */)partial___3, (char const   */* __restrict  */)"0");
#line 126
  strcat((char */* __restrict  */)partial___3, (char const   */* __restrict  */)codeset[104]);
#line 127
  checksum += 104;
#line 128
  textptr = textinfo___3;
#line 129
  textpos = 11;
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp___7 = strlen((char const   *)text___3);
    }
#line 131
    if (! ((size_t )i < tmp___7)) {
#line 131
      goto while_break;
    }
#line 132
    if ((int )*(text___3 + i) < 32) {
      {
#line 133
      bc->error = 22;
#line 134
      free((void *)partial___3);
#line 135
      free((void *)textinfo___3);
      }
#line 136
      return (-1);
    } else
#line 132
    if ((int )*(text___3 + i) & 128) {
      {
#line 133
      bc->error = 22;
#line 134
      free((void *)partial___3);
#line 135
      free((void *)textinfo___3);
      }
#line 136
      return (-1);
    }
    {
#line 138
    code = (int )*(text___3 + i) - 32;
#line 139
    strcat((char */* __restrict  */)partial___3, (char const   */* __restrict  */)codeset[code]);
#line 140
    checksum += code * (i + 1);
#line 141
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c ",
            textpos, (int )*(text___3 + i));
#line 142
    tmp___6 = strlen((char const   *)textptr);
#line 142
    textptr += tmp___6;
#line 143
    textpos += 11;
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  checksum %= 103;
#line 147
  strcat((char */* __restrict  */)partial___3, (char const   */* __restrict  */)codeset[checksum]);
#line 149
  strcat((char */* __restrict  */)partial___3, (char const   */* __restrict  */)codeset[106]);
#line 151
  bc->partial = partial___3;
#line 152
  bc->textinfo = textinfo___3;
  }
#line 154
  return (0);
}
}
#line 161 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128c_verify(unsigned char *text___8 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 163
  tmp = strlen((char const   *)text___8);
  }
#line 163
  if (! tmp) {
#line 164
    return (-1);
  }
  {
#line 166
  tmp___0 = strlen((char const   *)text___8);
  }
#line 166
  if (tmp___0 % 2U) {
#line 167
    return (-1);
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! *text___8) {
#line 169
      goto while_break;
    }
    {
#line 170
    tmp___1 = __ctype_b_loc();
    }
#line 170
    if (! ((int const   )*(*tmp___1 + (int )*text___8) & 2048)) {
#line 171
      return (-1);
    }
#line 169
    text___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return (0);
}
}
#line 177 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *text___4  ;
#line 178 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *partial___4  ;
#line 179 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *textinfo___4  ;
#line 175 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128c_encode(struct Barcode_Item *bc ) 
{ 
  char *textptr ;
  int i ;
  int code ;
  int textpos ;
  int checksum ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
#line 181
  checksum = 0;
#line 183
  if (bc->partial) {
    {
#line 184
    free((void *)bc->partial);
    }
  }
#line 185
  if (bc->textinfo) {
    {
#line 186
    free((void *)bc->textinfo);
    }
  }
#line 187
  tmp = (char *)((void *)0);
#line 187
  bc->textinfo = tmp;
#line 187
  bc->partial = tmp;
#line 189
  if (! bc->encoding) {
    {
#line 190
    bc->encoding = strdup("code 128-C");
    }
  }
#line 192
  text___4 = bc->ascii;
#line 193
  if (! text___4) {
#line 194
    bc->error = 22;
#line 195
    return (-1);
  }
  {
#line 198
  tmp___0 = strlen((char const   *)text___4);
#line 198
  tmp___1 = malloc((tmp___0 + 3U) * 6U + 2U);
#line 198
  partial___4 = (char *)tmp___1;
  }
#line 199
  if (! partial___4) {
    {
#line 200
    tmp___2 = __errno_location();
#line 200
    bc->error = *tmp___2;
    }
#line 201
    return (-1);
  }
  {
#line 205
  tmp___3 = strlen((char const   *)text___4);
#line 205
  tmp___4 = malloc(12U * tmp___3 + 2U);
#line 205
  textinfo___4 = (char *)tmp___4;
  }
#line 206
  if (! textinfo___4) {
    {
#line 207
    tmp___5 = __errno_location();
#line 207
    bc->error = *tmp___5;
#line 208
    free((void *)partial___4);
    }
#line 209
    return (-1);
  }
  {
#line 212
  strcpy((char */* __restrict  */)partial___4, (char const   */* __restrict  */)"0");
#line 213
  strcat((char */* __restrict  */)partial___4, (char const   */* __restrict  */)codeset[105]);
#line 214
  checksum += 105;
#line 215
  textptr = textinfo___4;
#line 216
  textpos = 11;
#line 218
  i = 0;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 218
    tmp___9 = strlen((char const   *)text___4);
    }
#line 218
    if (! ((size_t )i < tmp___9)) {
#line 218
      goto while_break;
    }
    {
#line 219
    tmp___6 = __ctype_b_loc();
    }
#line 219
    if ((int const   )*(*tmp___6 + (int )*(text___4 + i)) & 2048) {
      {
#line 219
      tmp___7 = __ctype_b_loc();
      }
#line 219
      if (! ((int const   )*(*tmp___7 + (int )*(text___4 + (i + 1))) & 2048)) {
        {
#line 220
        bc->error = 22;
#line 221
        free((void *)partial___4);
#line 222
        free((void *)textinfo___4);
        }
#line 223
        return (-1);
      }
    } else {
      {
#line 220
      bc->error = 22;
#line 221
      free((void *)partial___4);
#line 222
      free((void *)textinfo___4);
      }
#line 223
      return (-1);
    }
    {
#line 225
    code = (((int )*(text___4 + i) - 48) * 10 + (int )*(text___4 + (i + 1))) - 48;
#line 226
    strcat((char */* __restrict  */)partial___4, (char const   */* __restrict  */)codeset[code]);
#line 227
    checksum += code * (i / 2 + 1);
#line 230
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%g:9:%c %g:9:%c ",
            (double )textpos, (int )*(text___4 + i), (double )textpos + (double )11 / (double )2,
            (int )*(text___4 + (i + 1)));
#line 232
    tmp___8 = strlen((char const   *)textptr);
#line 232
    textptr += tmp___8;
#line 233
    textpos += 11;
#line 218
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  checksum %= 103;
#line 237
  strcat((char */* __restrict  */)partial___4, (char const   */* __restrict  */)codeset[checksum]);
#line 239
  strcat((char */* __restrict  */)partial___4, (char const   */* __restrict  */)codeset[106]);
#line 241
  bc->partial = partial___4;
#line 242
  bc->textinfo = textinfo___4;
  }
#line 244
  return (0);
}
}
#line 254 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128_verify(unsigned char *text___8 ) 
{ 
  size_t tmp ;

  {
  {
#line 256
  tmp = strlen((char const   *)text___8);
  }
#line 256
  if (! tmp) {
#line 257
    return (-1);
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (*text___8) {
#line 258
      if (! ((int )*text___8 <= 128)) {
#line 258
        if ((int )*text___8 >= 193) {
#line 258
          if (! ((int )*text___8 <= 196)) {
#line 258
            goto while_break;
          }
        } else {
#line 258
          goto while_break;
        }
      }
    } else {
#line 258
      goto while_break;
    }
#line 259
    text___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  if (*text___8) {
#line 261
    return (-1);
  }
#line 262
  return (0);
}
}
#line 280 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static int Barcode_a_or_b(unsigned char *text___8 ) 
{ 


  {
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! *text___8) {
#line 282
      goto while_break;
    }
#line 283
    if ((int )*text___8 < 32) {
#line 284
      return ('A');
    } else
#line 283
    if ((int )*text___8 == 128) {
#line 284
      return ('A');
    }
#line 285
    if ((int )*text___8 >= 96) {
#line 285
      if ((int )*text___8 < 128) {
#line 286
        return ('B');
      }
    }
#line 282
    text___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (0);
}
}
#line 292 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static int Barcode_encode_as(int code , int value ) 
{ 


  {
#line 296
  if (value == 193) {
#line 296
    return (102);
  }
#line 297
  if (value == 194) {
#line 297
    return (97);
  }
#line 298
  if (value == 195) {
#line 298
    return (96);
  }
#line 299
  if (value == 196) {
#line 300
    if (code == 65) {
#line 300
      return (101);
    }
#line 301
    return (100);
  }
#line 305
  if (value >= 32) {
#line 305
    if (value <= 95) {
#line 306
      return (value - 32);
    }
  }
#line 307
  if (value == 128) {
#line 307
    return (64);
  }
#line 308
  if (value < 32) {
#line 308
    return (value + 64);
  }
#line 309
  if (value >= 96) {
#line 309
    return (value - 32);
  }
#line 311
  return (-1);
}
}
#line 314 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static int *Barcode_128_make_array(struct Barcode_Item *bc , int *lptr ) 
{ 
  int len ;
  int *codes___0 ;
  unsigned char *s ;
  int i ;
  int j ;
  int code ;
  int checksum ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___14 ;
  unsigned char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
#line 318
  i = 0;
#line 321
  tmp = strlen((char const   *)bc->ascii);
#line 321
  len = (int )(2U * tmp + 5U);
#line 322
  tmp___0 = malloc((size_t )((unsigned long )len * sizeof(int )));
#line 322
  codes___0 = (int *)tmp___0;
#line 323
  s = (unsigned char *)bc->ascii;
  }
#line 326
  if ((int )*(s + 2) == 0) {
    {
#line 326
    tmp___5 = __ctype_b_loc();
    }
#line 326
    if ((int const   )*(*tmp___5 + (int )*(s + 0)) & 2048) {
      {
#line 326
      tmp___6 = __ctype_b_loc();
      }
#line 326
      if ((int const   )*(*tmp___6 + (int )*(s + 1)) & 2048) {
#line 327
        code = 'C';
      } else {
#line 326
        goto _L___3;
      }
    } else {
#line 326
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 328
    tmp___1 = __ctype_b_loc();
    }
#line 328
    if ((int const   )*(*tmp___1 + (int )*(s + 0)) & 2048) {
      {
#line 328
      tmp___2 = __ctype_b_loc();
      }
#line 328
      if ((int const   )*(*tmp___2 + (int )*(s + 1)) & 2048) {
        {
#line 328
        tmp___3 = __ctype_b_loc();
        }
#line 328
        if ((int const   )*(*tmp___3 + (int )*(s + 2)) & 2048) {
          {
#line 328
          tmp___4 = __ctype_b_loc();
          }
#line 328
          if ((int const   )*(*tmp___4 + (int )*(s + 3)) & 2048) {
#line 329
            code = 'C';
          } else {
#line 328
            goto _L___1;
          }
        } else {
#line 328
          goto _L___1;
        }
      } else {
#line 328
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 331
      code = Barcode_a_or_b(s);
      }
#line 332
      if (! code) {
#line 332
        code = 'B';
      }
    }
  }
#line 334
  tmp___7 = i;
#line 334
  i ++;
#line 334
  *(codes___0 + tmp___7) = (103 + code) - 65;
#line 336
  s = (unsigned char *)bc->ascii;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! *s) {
#line 336
      goto while_break;
    }
    {
#line 339
    if (code == 67) {
#line 339
      goto case_67;
    }
#line 356
    if (code == 65) {
#line 356
      goto case_65;
    }
#line 356
    if (code == 66) {
#line 356
      goto case_65;
    }
#line 337
    goto switch_break;
    case_67: /* CIL Label */ 
#line 340
    if ((int )*(s + 0) == 193) {
#line 341
      tmp___8 = i;
#line 341
      i ++;
#line 341
      *(codes___0 + tmp___8) = 102;
#line 342
      s ++;
    } else {
      {
#line 343
      tmp___11 = __ctype_b_loc();
      }
#line 343
      if ((int const   )*(*tmp___11 + (int )*(s + 0)) & 2048) {
        {
#line 343
        tmp___12 = __ctype_b_loc();
        }
#line 343
        if ((int const   )*(*tmp___12 + (int )*(s + 1)) & 2048) {
#line 345
          tmp___9 = i;
#line 345
          i ++;
#line 345
          *(codes___0 + tmp___9) = (((int )*(s + 0) - 48) * 10 + (int )*(s + 1)) - 48;
#line 346
          s += 2;
        } else {
#line 343
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        {
#line 349
        code = Barcode_a_or_b(s);
        }
#line 350
        if (! code) {
#line 350
          code = 'B';
        }
#line 351
        tmp___10 = i;
#line 351
        i ++;
#line 351
        if (code == 65) {
#line 351
          *(codes___0 + tmp___10) = 101;
        } else {
#line 351
          *(codes___0 + tmp___10) = 100;
        }
      }
    }
#line 353
    goto switch_break;
    case_65: /* CIL Label */ 
    case_66: /* CIL Label */ 
#line 357
    j = 0;
    {
#line 357
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 357
      tmp___13 = __ctype_b_loc();
      }
#line 357
      if (! ((int const   )*(*tmp___13 + (int )*(s + j)) & 2048)) {
#line 357
        goto while_break___0;
      }
#line 357
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    if (j >= 4) {
#line 360
      if (j & 1) {
#line 362
        tmp___14 = i;
#line 362
        i ++;
#line 362
        tmp___15 = s;
#line 362
        s ++;
#line 362
        *(codes___0 + tmp___14) = (int )*tmp___15 - 32;
      }
#line 364
      tmp___16 = i;
#line 364
      i ++;
#line 364
      *(codes___0 + tmp___16) = 99;
#line 365
      code = 'C';
    } else
#line 366
    if (code == 65) {
#line 366
      if ((int )*s >= 96) {
#line 366
        if ((int )*s < 128) {
          {
#line 368
          j = Barcode_a_or_b(s + 1);
          }
#line 369
          if (j == 66) {
#line 370
            tmp___17 = i;
#line 370
            i ++;
#line 370
            *(codes___0 + tmp___17) = 100;
#line 371
            code = 'B';
          } else {
            {
#line 373
            tmp___18 = i;
#line 373
            i ++;
#line 373
            *(codes___0 + tmp___18) = 98;
#line 374
            tmp___19 = i;
#line 374
            i ++;
#line 374
            *(codes___0 + tmp___19) = Barcode_encode_as('B', (int )*s);
#line 375
            s ++;
            }
          }
        } else {
#line 366
          goto _L___6;
        }
      } else {
#line 366
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 377
    if (code == 66) {
#line 377
      if ((int )*s < 32) {
#line 377
        goto _L___5;
      } else
#line 377
      if ((int )*s == 128) {
        _L___5: /* CIL Label */ 
        {
#line 379
        j = Barcode_a_or_b(s + 1);
        }
#line 380
        if (j == 65) {
#line 381
          tmp___20 = i;
#line 381
          i ++;
#line 381
          *(codes___0 + tmp___20) = 101;
#line 382
          code = 'A';
        } else {
          {
#line 384
          tmp___21 = i;
#line 384
          i ++;
#line 384
          *(codes___0 + tmp___21) = 98;
#line 385
          tmp___22 = i;
#line 385
          i ++;
#line 385
          *(codes___0 + tmp___22) = Barcode_encode_as('A', (int )*s);
#line 386
          s ++;
          }
        }
      } else {
        {
#line 389
        tmp___23 = i;
#line 389
        i ++;
#line 389
        *(codes___0 + tmp___23) = Barcode_encode_as(code, (int )*s);
#line 390
        s ++;
        }
      }
    } else {
      {
#line 389
      tmp___23 = i;
#line 389
      i ++;
#line 389
      *(codes___0 + tmp___23) = Barcode_encode_as(code, (int )*s);
#line 390
      s ++;
      }
    }
#line 392
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  checksum = *(codes___0 + 0);
#line 397
  j = 1;
  {
#line 397
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 397
    if (! (j < i)) {
#line 397
      goto while_break___1;
    }
#line 398
    checksum += j * *(codes___0 + j);
#line 397
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 399
  checksum %= 103;
#line 400
  tmp___24 = i;
#line 400
  i ++;
#line 400
  *(codes___0 + tmp___24) = checksum;
#line 401
  tmp___25 = i;
#line 401
  i ++;
#line 401
  *(codes___0 + tmp___25) = 106;
#line 402
  if (i > len) {
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"impossible: length is > allocated len\n");
    }
  }
#line 405
  *lptr = i;
#line 406
  return (codes___0);
}
}
#line 416 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *text___5  ;
#line 417 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *partial___5  ;
#line 418 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *textinfo___5  ;
#line 414 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128_encode(struct Barcode_Item *bc ) 
{ 
  char *textptr ;
  int *codes___0 ;
  int i ;
  int c ;
  int len ;
  double textpos ;
  double size ;
  double step ;
  char *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 424
  if (bc->partial) {
    {
#line 425
    free((void *)bc->partial);
    }
  }
#line 426
  if (bc->textinfo) {
    {
#line 427
    free((void *)bc->textinfo);
    }
  }
#line 428
  tmp = (char *)((void *)0);
#line 428
  bc->textinfo = tmp;
#line 428
  bc->partial = tmp;
#line 430
  if (! bc->encoding) {
    {
#line 431
    bc->encoding = strdup("code 128");
    }
  }
#line 433
  text___5 = bc->ascii;
#line 434
  if (! text___5) {
#line 435
    bc->error = 22;
#line 436
    return (-1);
  }
  {
#line 439
  codes___0 = Barcode_128_make_array(bc, & len);
  }
#line 440
  if (! codes___0) {
#line 440
    return (-1);
  }
  {
#line 443
  tmp___0 = malloc((size_t )(6 * len + 4));
#line 443
  partial___5 = (char *)tmp___0;
  }
#line 444
  if (! partial___5) {
    {
#line 445
    tmp___1 = __errno_location();
#line 445
    bc->error = *tmp___1;
#line 446
    free((void *)codes___0);
    }
#line 447
    return (-1);
  }
  {
#line 451
  tmp___2 = strlen((char const   *)text___5);
#line 451
  tmp___3 = malloc(13U * tmp___2 + 2U);
#line 451
  textinfo___5 = (char *)tmp___3;
#line 451
  textptr = textinfo___5;
  }
#line 452
  if (! textinfo___5) {
    {
#line 453
    tmp___4 = __errno_location();
#line 453
    bc->error = *tmp___4;
#line 454
    free((void *)partial___5);
#line 455
    free((void *)codes___0);
    }
#line 456
    return (-1);
  }
  {
#line 461
  strcpy((char */* __restrict  */)partial___5, (char const   */* __restrict  */)"0");
#line 462
  i = 0;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (i < len)) {
#line 462
      goto while_break;
    }
    {
#line 463
    strcat((char */* __restrict  */)partial___5, (char const   */* __restrict  */)codeset[*(codes___0 + i)]);
#line 462
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  i = 0;
  {
#line 466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 466
    if (! *(partial___5 + i)) {
#line 466
      goto while_break___0;
    }
    {
#line 467
    tmp___5 = __ctype_b_loc();
    }
#line 467
    if ((int const   )*(*tmp___5 + (int )*(partial___5 + i)) & 1024) {
#line 468
      *(partial___5 + i) = (char )((int )*(partial___5 + i) + -48);
    }
#line 466
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 480
  tmp___6 = strlen((char const   *)text___5);
#line 480
  size = (double )((int )((180.0 * (double )(len - 3)) / (double )tmp___6 + .5)) / 10.0;
  }
#line 481
  if (size > 12.0) {
#line 481
    size = 12.0;
  }
#line 484
  step = (double )((int )((double )10 * ((size / 18.0) * (double )11) + .5)) / 10.0;
#line 485
  textpos = (double )11;
#line 487
  i = 0;
  {
#line 487
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 487
    tmp___8 = strlen((char const   *)text___5);
    }
#line 487
    if (! ((size_t )i < tmp___8)) {
#line 487
      goto while_break___1;
    }
#line 488
    c = (int )*(text___5 + i);
#line 489
    if (c < 32) {
#line 489
      c = '_';
    } else
#line 489
    if (c == 128) {
#line 489
      c = '_';
    }
#line 490
    if (c > 192) {
#line 490
      c = ' ';
    }
    {
#line 491
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%g:%g:%c ",
            textpos, size, c);
#line 492
    tmp___7 = strlen((char const   *)textptr);
#line 492
    textptr += tmp___7;
#line 493
    textpos += step;
#line 487
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 496
  bc->partial = partial___5;
#line 497
  bc->textinfo = textinfo___5;
#line 498
  free((void *)codes___0);
  }
#line 499
  return (0);
}
}
#line 507 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128raw_verify(unsigned char *text___8 ) 
{ 
  int n ;
  unsigned int val ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 512
  tmp = strlen((char const   *)text___8);
  }
#line 512
  if (! tmp) {
#line 513
    return (-1);
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! *text___8) {
#line 514
      goto while_break;
    }
    {
#line 515
    tmp___0 = sscanf((char const   */* __restrict  */)text___8, (char const   */* __restrict  */)"%u%n",
                     & val, & n);
    }
#line 515
    if (tmp___0 < 1) {
#line 516
      return (-1);
    }
#line 517
    if (val > 105U) {
#line 518
      return (-1);
    }
#line 519
    text___8 += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 526 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *text___6  ;
#line 527 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *partial___6  ;
#line 528 "/abs/pronto/test-suite/barcode-0.96/code128.c"
static char *textinfo___6  ;
#line 524 "/abs/pronto/test-suite/barcode-0.96/code128.c"
int Barcode_128raw_encode(struct Barcode_Item *bc ) 
{ 
  char *textptr ;
  int i ;
  int n ;
  int count ;
  int code ;
  int textpos ;
  int checksum ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
#line 530
  checksum = 0;
#line 532
  if (bc->partial) {
    {
#line 533
    free((void *)bc->partial);
    }
  }
#line 534
  if (bc->textinfo) {
    {
#line 535
    free((void *)bc->textinfo);
    }
  }
#line 536
  tmp = (char *)((void *)0);
#line 536
  bc->textinfo = tmp;
#line 536
  bc->partial = tmp;
#line 538
  if (! bc->encoding) {
    {
#line 539
    bc->encoding = strdup("128raw");
    }
  }
#line 541
  text___6 = bc->ascii;
#line 542
  if (! text___6) {
#line 543
    bc->error = 22;
#line 544
    return (-1);
  }
  {
#line 550
  tmp___0 = strlen((char const   *)text___6);
#line 550
  tmp___1 = malloc((3U + tmp___0 / 2U) * 6U + 2U);
#line 550
  partial___6 = (char *)tmp___1;
  }
#line 551
  if (! partial___6) {
    {
#line 552
    tmp___2 = __errno_location();
#line 552
    bc->error = *tmp___2;
    }
#line 553
    return (-1);
  }
  {
#line 557
  tmp___3 = strlen((char const   *)text___6);
#line 557
  tmp___4 = malloc(12U * (1U + tmp___3 / 2U) + 2U);
#line 557
  textinfo___6 = (char *)tmp___4;
  }
#line 558
  if (! textinfo___6) {
    {
#line 559
    tmp___5 = __errno_location();
#line 559
    bc->error = *tmp___5;
#line 560
    free((void *)partial___6);
    }
#line 561
    return (-1);
  }
  {
#line 564
  strcpy((char */* __restrict  */)partial___6, (char const   */* __restrict  */)"0");
#line 565
  textptr = textinfo___6;
#line 566
  textpos = 0;
#line 568
  i = 0;
#line 568
  count = 0;
  }
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 568
    tmp___9 = strlen((char const   *)text___6);
    }
#line 568
    if (! ((size_t )i < tmp___9)) {
#line 568
      goto while_break;
    }
    {
#line 569
    tmp___6 = sscanf((char const   */* __restrict  */)(text___6 + i), (char const   */* __restrict  */)"%u%n",
                     & code, & n);
    }
#line 569
    if (tmp___6 < 1) {
      {
#line 570
      bc->error = 22;
#line 571
      free((void *)partial___6);
#line 572
      free((void *)textinfo___6);
      }
#line 573
      return (-1);
    }
    {
#line 575
    strcat((char */* __restrict  */)partial___6, (char const   */* __restrict  */)codeset[code]);
    }
#line 581
    if (! count) {
#line 581
      checksum += code;
    } else {
#line 582
      checksum += code * count;
    }
#line 589
    if (code >= 100) {
#line 589
      tmp___7 = 'A';
    } else {
#line 589
      tmp___7 = code / 10 + 48;
    }
    {
#line 589
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%g:9:%c %g:9:%c ",
            (double )textpos, tmp___7, (double )textpos + (double )11 / (double )2,
            code % 10 + 48);
#line 592
    tmp___8 = strlen((char const   *)textptr);
#line 592
    textptr += tmp___8;
#line 593
    textpos += 11;
#line 594
    i += n;
#line 568
    count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 597
  checksum %= 103;
#line 598
  strcat((char */* __restrict  */)partial___6, (char const   */* __restrict  */)codeset[checksum]);
#line 600
  strcat((char */* __restrict  */)partial___6, (char const   */* __restrict  */)codeset[106]);
#line 602
  bc->partial = partial___6;
#line 603
  bc->textinfo = textinfo___6;
  }
#line 605
  return (0);
}
}
#line 31 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
static char alphabet___1[21]  = 
#line 31 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'-',      (char )'$', 
        (char )':',      (char )'/',      (char )'.',      (char )'+', 
        (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'\000'};
#line 41 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
static char *patterns___1[20]  = 
#line 41
  {      (char *)"1111133",      (char *)"1111331",      (char *)"1113113",      (char *)"3311111", 
        (char *)"1131131",      (char *)"3111131",      (char *)"1311113",      (char *)"1311311", 
        (char *)"1331111",      (char *)"3113111",      (char *)"1113311",      (char *)"1133111", 
        (char *)"3111313",      (char *)"3131113",      (char *)"3131311",      (char *)"1131313", 
        (char *)"1133131",      (char *)"1313113",      (char *)"1113133",      (char *)"1113331"};
#line 53 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
int Barcode_cbr_verify(unsigned char *text___8 ) 
{ 
  int i ;
  int lower ;
  int upper ;
  int startpresent ;
  size_t tmp ;
  char *pos ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 55
  lower = 0;
#line 55
  upper = 0;
#line 56
  startpresent = 0;
#line 58
  tmp = strlen((char const   *)text___8);
  }
#line 58
  if (! tmp) {
#line 59
    return (-1);
  }
#line 60
  i = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! *(text___8 + i)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp___0 = __ctype_b_loc();
    }
#line 62
    if ((int const   )*(*tmp___0 + (int )*(text___8 + i)) & 256) {
#line 62
      upper ++;
    }
    {
#line 63
    tmp___1 = __ctype_b_loc();
    }
#line 63
    if ((int const   )*(*tmp___1 + (int )*(text___8 + i)) & 512) {
#line 63
      lower ++;
    }
    {
#line 64
    tmp___2 = toupper((int )*(text___8 + i));
#line 64
    pos = strchr((char const   *)(alphabet___1), tmp___2);
    }
#line 65
    if (! pos) {
#line 66
      return (-1);
    }
#line 67
    if (i == 0) {
#line 67
      if (pos - alphabet___1 >= 16L) {
#line 68
        startpresent = 1;
      } else {
#line 67
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 69
    if (pos - alphabet___1 >= 16L) {
#line 69
      if (! startpresent) {
#line 71
        return (-1);
      } else {
        {
#line 69
        tmp___3 = strlen((char const   *)text___8);
        }
#line 69
        if ((size_t )i != tmp___3 - 1U) {
#line 71
          return (-1);
        }
      }
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (lower) {
#line 73
    if (upper) {
#line 74
      return (-1);
    }
  }
#line 75
  return (0);
}
}
#line 78 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
static int add_one___2(char *ptr___0 , int code ) 
{ 


  {
  {
#line 80
  sprintf((char */* __restrict  */)ptr___0, (char const   */* __restrict  */)"1%s",
          patterns___1[code]);
  }
#line 81
  return (0);
}
}
#line 90 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
static char *text___7  ;
#line 91 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
static char *partial___7  ;
#line 92 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
static char *textinfo___7  ;
#line 88 "/abs/pronto/test-suite/barcode-0.96/codabar.c"
int Barcode_cbr_encode(struct Barcode_Item *bc ) 
{ 
  char *c ;
  char *ptr___0 ;
  char *textptr ;
  int i ;
  int code ;
  int textpos ;
  int usesum ;
  int checksum ;
  int startpresent ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;

  {
#line 94
  checksum = 0;
#line 96
  if (bc->partial) {
    {
#line 97
    free((void *)bc->partial);
    }
  }
#line 98
  if (bc->textinfo) {
    {
#line 99
    free((void *)bc->textinfo);
    }
  }
#line 100
  tmp = (char *)((void *)0);
#line 100
  bc->textinfo = tmp;
#line 100
  bc->partial = tmp;
#line 102
  if (! bc->encoding) {
    {
#line 103
    bc->encoding = strdup("codabar");
    }
  }
#line 105
  text___7 = bc->ascii;
#line 106
  if (! text___7) {
#line 107
    bc->error = 22;
#line 108
    return (-1);
  }
  {
#line 111
  tmp___0 = strlen((char const   *)text___7);
#line 111
  tmp___1 = malloc((tmp___0 + 3U) * 8U + 2U);
#line 111
  partial___7 = (char *)tmp___1;
  }
#line 112
  if (! partial___7) {
    {
#line 113
    tmp___2 = __errno_location();
#line 113
    bc->error = *tmp___2;
    }
#line 114
    return (-1);
  }
  {
#line 118
  tmp___3 = strlen((char const   *)text___7);
#line 118
  tmp___4 = malloc(10U * (tmp___3 + 1U) + 2U);
#line 118
  textinfo___7 = (char *)tmp___4;
  }
#line 119
  if (! textinfo___7) {
    {
#line 120
    tmp___5 = __errno_location();
#line 120
    bc->error = *tmp___5;
#line 121
    free((void *)partial___7);
    }
#line 122
    return (-1);
  }
#line 125
  ptr___0 = partial___7;
#line 126
  textptr = textinfo___7;
#line 127
  textpos = 0;
#line 128
  if (bc->flags & 512) {
#line 128
    usesum = 0;
  } else {
#line 128
    usesum = 1;
  }
  {
#line 130
  tmp___7 = __ctype_b_loc();
  }
#line 130
  if ((int const   )*(*tmp___7 + (int )*(text___7 + 0)) & 1024) {
#line 137
    startpresent = 1;
  } else {
    {
#line 131
    add_one___2(ptr___0, 16);
#line 132
    tmp___6 = strlen((char const   *)ptr___0);
#line 132
    ptr___0 += tmp___6;
#line 133
    textpos = 14;
#line 134
    checksum = 16;
#line 135
    startpresent = 0;
    }
  }
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    tmp___16 = strlen((char const   *)text___7);
    }
#line 139
    if (! ((size_t )i < tmp___16)) {
#line 139
      goto while_break;
    }
    {
#line 140
    tmp___8 = toupper((int )*(text___7 + i));
#line 140
    c = strchr((char const   *)(alphabet___1), tmp___8);
    }
#line 141
    if (! c) {
      {
#line 142
      bc->error = 22;
#line 143
      free((void *)partial___7);
#line 144
      free((void *)textinfo___7);
      }
#line 145
      return (-1);
    }
    {
#line 147
    code = (int )(c - alphabet___1);
#line 148
    add_one___2(ptr___0, code);
#line 149
    tmp___9 = toupper((int )*(text___7 + i));
#line 149
    sprintf((char */* __restrict  */)textptr, (char const   */* __restrict  */)"%i:12:%c ",
            textpos, tmp___9);
    }
#line 150
    if (code < 12) {
#line 150
      tmp___10 = 12;
    } else {
#line 150
      tmp___10 = 14;
    }
    {
#line 150
    textpos += tmp___10;
#line 151
    tmp___11 = strlen((char const   *)textptr);
#line 151
    textptr += tmp___11;
#line 152
    tmp___12 = strlen((char const   *)ptr___0);
#line 152
    ptr___0 += tmp___12;
#line 153
    checksum += code;
    }
#line 154
    if (startpresent) {
#line 154
      if (usesum) {
        {
#line 154
        tmp___15 = strlen((char const   *)text___7);
        }
#line 154
        if ((size_t )i == tmp___15 - 2U) {
          {
#line 156
          tmp___13 = toupper((int )*(text___7 + (i + 1)));
#line 156
          c = strchr((char const   *)(alphabet___1), tmp___13);
          }
#line 157
          if (! c) {
#line 158
            goto __Cont;
          }
          {
#line 159
          code = (int )(c - alphabet___1);
#line 160
          checksum += code;
#line 163
          checksum = ((checksum + 15) / 16) * 16 - checksum;
#line 164
          add_one___2(ptr___0, checksum);
#line 165
          tmp___14 = strlen((char const   *)ptr___0);
#line 165
          ptr___0 += tmp___14;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  if (! startpresent) {
#line 169
    if (usesum) {
      {
#line 171
      checksum += 17;
#line 172
      checksum = ((checksum + 15) / 16) * 16 - checksum;
#line 173
      add_one___2(ptr___0, checksum);
#line 174
      tmp___17 = strlen((char const   *)ptr___0);
#line 174
      ptr___0 += tmp___17;
      }
    }
    {
#line 176
    add_one___2(ptr___0, 17);
    }
  }
#line 178
  bc->partial = partial___7;
#line 179
  bc->textinfo = textinfo___7;
#line 181
  return (0);
}
}
#line 626 "/usr/include/stdlib.h"
extern char *getenv(char const   *__name ) ;
#line 55 "/usr/include/getopt.h"
extern char *optarg ;
#line 153
extern int getopt(int ___argc , char * const  *___argv , char const   *__shortopts ) ;
#line 49 "/abs/pronto/test-suite/barcode-0.96/cmdline.h"
int commandline(struct commandline *args , int argc , char **argv , char *errorhead ) ;
#line 53
int commandline_errormsg(FILE *f , struct commandline *args , char *prgname___0 ,
                         char *messagehead ) ;
#line 39 "/abs/pronto/test-suite/barcode-0.96/cmdline.c"
int commandline_errormsg(FILE *f , struct commandline *args , char *prgname___0 ,
                         char *messagehead ) 
{ 
  char *buffer ;
  char *buffer2 ;
  int len ;
  struct commandline *ptr___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;

  {
#line 47
  if (! messagehead) {
    {
#line 48
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s: Error in cmdline\nPossible options:\n",
            prgname___0);
    }
  } else {
    {
#line 50
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s: %s",
            prgname___0, messagehead);
    }
  }
#line 53
  ptr___0 = args;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! ptr___0->option) {
#line 53
      goto while_break;
    }
#line 54
    if (ptr___0->descrip) {
      {
#line 55
      tmp = strlen((char const   *)ptr___0->descrip);
#line 55
      len = (int )tmp;
      }
#line 56
      if (ptr___0->default_v) {
        {
#line 56
        tmp___0 = strlen((char const   *)ptr___0->default_v);
#line 56
        tmp___1 = tmp___0;
        }
      } else {
#line 56
        tmp___1 = (size_t )6;
      }
#line 56
      len = (int )((size_t )len + tmp___1);
#line 57
      if (ptr___0->env) {
        {
#line 57
        tmp___2 = strlen((char const   *)ptr___0->env);
#line 57
        tmp___3 = tmp___2;
        }
      } else {
#line 57
        tmp___3 = (size_t )6;
      }
      {
#line 57
      len = (int )((size_t )len + tmp___3);
#line 58
      tmp___4 = malloc((size_t )(len + 3));
#line 58
      buffer2 = (char *)tmp___4;
#line 59
      len += 32;
      }
#line 60
      if (buffer2) {
        {
#line 61
        tmp___5 = malloc((size_t )len);
#line 61
        buffer = (char *)tmp___5;
        }
#line 62
        if (buffer) {
#line 63
          if (ptr___0->env) {
#line 63
            tmp___6 = (char const   *)ptr___0->env;
          } else {
#line 63
            tmp___6 = "(none)";
          }
#line 63
          if (ptr___0->default_v) {
#line 63
            tmp___7 = (char const   *)ptr___0->default_v;
          } else {
#line 63
            tmp___7 = "(none)";
          }
          {
#line 63
          sprintf((char */* __restrict  */)buffer2, (char const   */* __restrict  */)ptr___0->descrip,
                  tmp___7, tmp___6);
          }
#line 66
          if (ptr___0->type) {
#line 66
            tmp___8 = "<arg>";
          } else {
#line 66
            tmp___8 = "     ";
          }
          {
#line 66
          sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"   -%c %s     %s",
                  ptr___0->option, tmp___8, buffer2);
#line 68
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s\n",
                  buffer);
#line 69
          free((void *)buffer);
          }
        }
        {
#line 71
        free((void *)buffer2);
        }
      }
    }
#line 53
    ptr___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (-1);
}
}
#line 85 "/abs/pronto/test-suite/barcode-0.96/cmdline.c"
static struct type_fmt formats[7]  = {      {(enum option_type )1, (char *)"%i%s"}, 
        {(enum option_type )2, (char *)"%d%s"}, 
        {(enum option_type )3, (char *)"%x%s"}, 
        {(enum option_type )4, (char *)"%o%s"}, 
        {(enum option_type )6, (char *)"%lf%s"}, 
        {(enum option_type )7, (char *)"%p%s"}, 
        {(enum option_type )0, (char *)((void *)0)}};
#line 97 "/abs/pronto/test-suite/barcode-0.96/cmdline.c"
static int commandline_oneopt(struct commandline *ptr___0 , char *value ) 
{ 
  struct type_fmt *tptr ;
  char *trash ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 100
  if (value) {
    {
#line 100
    tmp = strdup((char const   *)value);
#line 100
    tmp___0 = tmp;
    }
  } else {
#line 100
    tmp___0 = (char *)((void *)0);
  }
#line 100
  trash = tmp___0;
#line 103
  if (ptr___0->type != 0) {
#line 103
    if (ptr___0->result) {
#line 104
      tptr = formats;
      {
#line 104
      while (1) {
        while_continue: /* CIL Label */ ;
#line 104
        if (! tptr->type) {
#line 104
          goto while_break;
        }
#line 105
        if ((unsigned int )tptr->type == (unsigned int )ptr___0->type) {
#line 106
          goto while_break;
        }
#line 104
        tptr ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 107
      if (! tptr->type) {
#line 108
        *((char **)ptr___0->result) = value;
      } else {
        {
#line 110
        tmp___1 = sscanf((char const   */* __restrict  */)value, (char const   */* __restrict  */)tptr->fmt,
                         ptr___0->result, trash);
        }
#line 110
        if (tmp___1 != 1) {
          {
#line 111
          free((void *)trash);
          }
#line 112
          return (-1);
        }
      }
    }
  }
#line 115
  if (trash) {
    {
#line 116
    free((void *)trash);
    }
  }
#line 118
  if (ptr___0->type == 0) {
#line 118
    if (ptr___0->result) {
#line 119
      (*((int *)ptr___0->result)) ++;
    }
  }
#line 122
  if (ptr___0->fun) {
#line 123
    if (ptr___0->type) {
#line 124
      if (ptr___0->result) {
        {
#line 124
        tmp___2 = (*(ptr___0->fun))(ptr___0->result);
        }
#line 124
        return (tmp___2);
      }
      {
#line 125
      tmp___3 = (*(ptr___0->fun))((void *)value);
      }
#line 125
      return (tmp___3);
    }
    {
#line 127
    tmp___4 = (*(ptr___0->fun))((void *)0);
    }
#line 127
    return (tmp___4);
  }
#line 129
  return (0);
}
}
#line 133 "/abs/pronto/test-suite/barcode-0.96/cmdline.c"
int commandline(struct commandline *args , int argc , char **argv , char *errorhead ) 
{ 
  struct commandline *ptr___0 ;
  char *getopt_desc ;
  void *tmp ;
  int desc_offset ;
  int opt ;
  int retval ;
  char *value ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 137
  tmp = calloc((size_t )512, (size_t )1);
#line 137
  getopt_desc = (char *)tmp;
#line 138
  desc_offset = 0;
#line 143
  ptr___0 = args;
  }
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ptr___0->option) {
#line 143
      goto while_break;
    }
#line 144
    tmp___0 = desc_offset;
#line 144
    desc_offset ++;
#line 144
    *(getopt_desc + tmp___0) = (char )ptr___0->option;
#line 145
    if (ptr___0->type) {
#line 145
      tmp___1 = desc_offset;
#line 145
      desc_offset ++;
#line 145
      *(getopt_desc + tmp___1) = (char )':';
    }
#line 147
    value = (char *)((void *)0);
#line 148
    if (ptr___0->env) {
      {
#line 149
      value = getenv((char const   *)ptr___0->env);
      }
    }
#line 150
    if (! value) {
#line 151
      value = ptr___0->default_v;
    }
#line 152
    if (value) {
      {
#line 152
      retval = commandline_oneopt(ptr___0, value);
      }
#line 152
      if (retval) {
#line 157
        if (retval == -1) {
          {
#line 158
          commandline_errormsg(stderr, args, *(argv + 0), errorhead);
          }
        }
#line 159
        return (retval);
      }
    }
#line 143
    ptr___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 164
    opt = getopt(argc, (char * const  *)argv, (char const   *)getopt_desc);
    }
#line 164
    if (! (opt != -1)) {
#line 164
      goto while_break___0;
    }
#line 165
    ptr___0 = args;
    {
#line 165
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 165
      if (! ptr___0->option) {
#line 165
        goto while_break___1;
      }
#line 166
      if (opt == ptr___0->option) {
#line 167
        goto while_break___1;
      }
#line 165
      ptr___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 168
    if (! ptr___0->option) {
      {
#line 169
      tmp___2 = commandline_errormsg(stderr, args, *(argv + 0), errorhead);
      }
#line 169
      return (tmp___2);
    }
    {
#line 170
    retval = commandline_oneopt(ptr___0, optarg);
    }
#line 170
    if (retval) {
#line 171
      if (retval == -1) {
        {
#line 172
        commandline_errormsg(stderr, args, *(argv + 0), errorhead);
        }
      }
#line 173
      return (retval);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 176
  return (0);
}
}
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 526
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 612 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 96 "/usr/include/string.h"
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 243
extern char *strerror(int __errnum ) ;
#line 287
extern int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 43 "/usr/include/paper.h"
extern int paperinit(void) ;
#line 44
extern int paperdone(void) ;
#line 47
extern double paperpswidth(struct paper  const  * ) ;
#line 48
extern double paperpsheight(struct paper  const  * ) ;
#line 53
extern char *systempapername(void) ;
#line 54
extern struct paper  const  *paperinfo(char const   * ) ;
#line 44 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct __anonstruct_encode_tab_19 encode_tab[26]  = 
#line 44 "/abs/pronto/test-suite/barcode-0.96/main.c"
  {      {(char *)"ean", 1}, 
        {(char *)"ean13", 1}, 
        {(char *)"ean-13", 1}, 
        {(char *)"ean8", 1}, 
        {(char *)"ean-8", 1}, 
        {(char *)"upc", 2}, 
        {(char *)"upc-a", 2}, 
        {(char *)"upc-e", 2}, 
        {(char *)"isbn", 3}, 
        {(char *)"39", 4}, 
        {(char *)"code39", 4}, 
        {(char *)"128c", 6}, 
        {(char *)"code128c", 6}, 
        {(char *)"128b", 7}, 
        {(char *)"code128b", 7}, 
        {(char *)"128", 5}, 
        {(char *)"code128", 5}, 
        {(char *)"128raw", 9}, 
        {(char *)"i25", 8}, 
        {(char *)"interleaved 2 of 5", 8}, 
        {(char *)"cbr", 10}, 
        {(char *)"codabar", 10}, 
        {(char *)"msi", 11}, 
        {(char *)"pls", 12}, 
        {(char *)"plessey", 12}, 
        {(char *)((void *)0), 0}};
#line 85 "/abs/pronto/test-suite/barcode-0.96/main.c"
int encode_id(char *encode_name ) 
{ 
  int i ;
  int tmp ;

  {
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! encode_tab[i].name) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp = strcasecmp((char const   *)encode_tab[i].name, (char const   *)encode_name);
    }
#line 89
    if (! tmp) {
#line 90
      return (encode_tab[i].type);
    }
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return (-1);
}
}
#line 94 "/abs/pronto/test-suite/barcode-0.96/main.c"
int list_encodes(FILE *f ) 
{ 
  int prev ;
  int i ;

  {
  {
#line 96
  prev = -1;
#line 99
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Known encodings are (synonyms appear on the same line):");
#line 100
  i = 0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! encode_tab[i].name) {
#line 100
      goto while_break;
    }
#line 101
    if (encode_tab[i].type != prev) {
      {
#line 102
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n\t");
      }
    } else {
      {
#line 104
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)", ");
      }
    }
    {
#line 105
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\"%s\"",
            encode_tab[i].name);
#line 106
    prev = encode_tab[i].type;
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 109
  return (0);
}
}
#line 117 "/abs/pronto/test-suite/barcode-0.96/main.c"
char *ifilename  ;
#line 117 "/abs/pronto/test-suite/barcode-0.96/main.c"
char *ofilename  ;
#line 118 "/abs/pronto/test-suite/barcode-0.96/main.c"
int encoding_type  ;
#line 119 "/abs/pronto/test-suite/barcode-0.96/main.c"
int code_width  ;
#line 119 "/abs/pronto/test-suite/barcode-0.96/main.c"
int code_height  ;
#line 120 "/abs/pronto/test-suite/barcode-0.96/main.c"
int lines  ;
#line 120 "/abs/pronto/test-suite/barcode-0.96/main.c"
int columns  ;
#line 121 "/abs/pronto/test-suite/barcode-0.96/main.c"
int xmargin0  ;
#line 121 "/abs/pronto/test-suite/barcode-0.96/main.c"
int ymargin0  ;
#line 122 "/abs/pronto/test-suite/barcode-0.96/main.c"
int xmargin1  ;
#line 122 "/abs/pronto/test-suite/barcode-0.96/main.c"
int ymargin1  ;
#line 123 "/abs/pronto/test-suite/barcode-0.96/main.c"
int ximargin  ;
#line 123 "/abs/pronto/test-suite/barcode-0.96/main.c"
int yimargin  ;
#line 124 "/abs/pronto/test-suite/barcode-0.96/main.c"
int eps  ;
#line 124 "/abs/pronto/test-suite/barcode-0.96/main.c"
int ps  ;
#line 124 "/abs/pronto/test-suite/barcode-0.96/main.c"
int noascii  ;
#line 124 "/abs/pronto/test-suite/barcode-0.96/main.c"
int nochecksum  ;
#line 125 "/abs/pronto/test-suite/barcode-0.96/main.c"
int page_wid  ;
#line 125 "/abs/pronto/test-suite/barcode-0.96/main.c"
int page_hei  ;
#line 126 "/abs/pronto/test-suite/barcode-0.96/main.c"
char *page_name  ;
#line 127 "/abs/pronto/test-suite/barcode-0.96/main.c"
double unit  =    1.0;
#line 129 "/abs/pronto/test-suite/barcode-0.96/main.c"
char *prgname  ;
#line 135 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct encode_item *list_head  ;
#line 135 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct encode_item *list_tail  ;
#line 141 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_input_string(void *arg ) 
{ 
  struct encode_item *item ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 143
  tmp = malloc((size_t )sizeof(*item));
#line 143
  item = (struct encode_item *)tmp;
  }
#line 144
  if (! item) {
    {
#line 145
    tmp___0 = __errno_location();
#line 145
    tmp___1 = strerror(*tmp___0);
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: malloc: %s\n",
            prgname, tmp___1);
    }
#line 146
    return (-2);
  }
  {
#line 148
  item->string = strdup((char const   *)arg);
  }
#line 149
  if (! list_head) {
#line 150
    list_tail = item;
#line 150
    list_head = list_tail;
  } else {
#line 152
    list_tail->next = item;
#line 153
    list_tail = item;
  }
#line 155
  item->next = (struct encode_item *)((void *)0);
#line 156
  return (0);
}
}
#line 163 "/abs/pronto/test-suite/barcode-0.96/main.c"
static char fileline[128]  ;
#line 160 "/abs/pronto/test-suite/barcode-0.96/main.c"
unsigned char *retrieve_input_string(FILE *ifile ) 
{ 
  char *string ;
  struct encode_item *item ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 165
  item = list_head;
#line 166
  if (list_tail) {
#line 167
    if (! item) {
#line 168
      return ((unsigned char *)((void *)0));
    }
    {
#line 169
    string = item->string;
#line 170
    list_head = item->next;
#line 171
    free((void *)item);
    }
#line 172
    return ((unsigned char *)string);
  }
  {
#line 176
  tmp = fgets((char */* __restrict  */)(fileline), 128, (FILE */* __restrict  */)ifile);
  }
#line 176
  if (! tmp) {
#line 177
    return ((unsigned char *)((void *)0));
  }
  {
#line 178
  tmp___1 = strlen((char const   *)(fileline));
  }
#line 178
  if ((int )fileline[tmp___1 - 1U] == 10) {
    {
#line 179
    tmp___0 = strlen((char const   *)(fileline));
#line 179
    fileline[tmp___0 - 1U] = (char )'\000';
    }
  }
  {
#line 180
  tmp___2 = strdup((char const   *)(fileline));
  }
#line 180
  return ((unsigned char *)tmp___2);
}
}
#line 186 "/abs/pronto/test-suite/barcode-0.96/main.c"
static struct __anonstruct_ptr_20 *ptr  ;
#line 186
int get_unit(void *arg ) ;
#line 186 "/abs/pronto/test-suite/barcode-0.96/main.c"
static struct __anonstruct_ptr_20 unittab[5]  = {      {(char *)"pt", 1.0}, 
        {(char *)"in", 72.0}, 
        {(char *)"cm", 72.0 / 2.54}, 
        {(char *)"mm", 72.0 / 25.4}, 
        {(char *)((void *)0), 0.0}};
#line 184 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_unit(void *arg ) 
{ 
  int tmp ;

  {
#line 197
  ptr = unittab;
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (ptr->str) {
      {
#line 197
      tmp = strcmp((char const   *)((char *)arg), (char const   *)ptr->str);
      }
#line 197
      if (! tmp) {
#line 197
        goto while_break;
      }
    } else {
#line 197
      goto while_break;
    }
#line 197
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  unit = ptr->unit;
#line 200
  if (ptr->str) {
#line 200
    return (0);
  }
  {
#line 202
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect unit \"%s\" (use one of",
          prgname, (char *)arg);
#line 204
  ptr = unittab;
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! ptr->str) {
#line 204
      goto while_break___0;
    }
    {
#line 205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \"%s\"",
            ptr->str);
#line 204
    ptr ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 206
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
  }
#line 207
  return (-2);
}
}
#line 211 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_encoding(void *arg ) 
{ 


  {
  {
#line 213
  encoding_type = encode_id((char *)arg);
  }
#line 214
  if (encoding_type >= 0) {
#line 214
    return (0);
  }
  {
#line 215
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong encoding \"%s\"\n",
          prgname, (char *)arg);
  }
#line 217
  return (-2);
}
}
#line 221 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_geometry(void *arg ) 
{ 
  double w ;
  double h ;
  double x ;
  double y ;
  int n ;

  {
#line 223
  w = 0.0;
#line 223
  h = 0.0;
#line 224
  x = 0.0;
#line 224
  y = 0.0;
#line 227
  if ((int )*((char *)arg + 0) == 43) {
    {
#line 228
    n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"+%lf+%lf%s",
               & x, & y, (char *)arg);
    }
  } else {
    {
#line 230
    n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lfx%lf+%lf+%lf%s",
               & w, & h, & x, & y, (char *)arg);
    }
  }
#line 233
  if (n != 4) {
#line 233
    if (n != 2) {
      {
#line 234
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong geometry \"%s\"\n",
              prgname, (char *)arg);
      }
#line 235
      return (-2);
    }
  }
#line 238
  code_width = (int )(w * unit);
#line 239
  code_height = (int )(h * unit);
#line 240
  xmargin0 = (int )(x * unit);
#line 241
  ymargin0 = (int )(y * unit);
#line 242
  return (0);
}
}
#line 246 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_table(void *arg ) 
{ 
  double x0 ;
  double y0 ;
  double x1 ;
  double y1 ;
  int n ;

  {
  {
#line 248
  x0 = 0.0;
#line 248
  y0 = 0.0;
#line 248
  x1 = 0.0;
#line 248
  y1 = 0.0;
#line 251
  n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%dx%d+%lf+%lf-%lf-%lf",
             & columns, & lines, & x0, & y0, & x1, & y1);
  }
#line 254
  if (n == 1) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong table specification \"%s\"\n",
            prgname, (char *)arg);
    }
#line 257
    return (-2);
  } else
#line 254
  if (n == 3) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong table specification \"%s\"\n",
            prgname, (char *)arg);
    }
#line 257
    return (-2);
  }
#line 259
  if (n < 6) {
#line 259
    y1 = y0;
  }
#line 260
  if (n < 5) {
#line 260
    x1 = x0;
  }
#line 263
  xmargin0 = (int )(x0 * unit);
#line 264
  ymargin0 = (int )(y0 * unit);
#line 265
  xmargin1 = (int )(x1 * unit);
#line 266
  ymargin1 = (int )(y1 * unit);
#line 267
  return (0);
}
}
#line 271 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_margin(void *arg ) 
{ 
  char separator ;
  double x ;
  double y ;
  int n ;

  {
  {
#line 278
  n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lf%c%lf",
             & x, & separator, & y);
  }
#line 280
  if (n == 1) {
#line 281
    n = 3;
#line 281
    y = x;
  }
#line 283
  if (n == 3) {
#line 284
    ximargin = (int )(x * unit);
#line 285
    yimargin = (int )(y * unit);
#line 286
    return (0);
  }
  {
#line 288
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong margin specification \"%s\"\n",
          prgname, (char *)arg);
  }
#line 290
  return (-2);
#line 291
  return (0);
}
}
#line 299 "/abs/pronto/test-suite/barcode-0.96/main.c"
static char tmpstr[20]  ;
#line 295 "/abs/pronto/test-suite/barcode-0.96/main.c"
int get_page_geometry(void *arg ) 
{ 
  int n ;
  double dpw ;
  double dph ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  struct paper  const  *paptr ;
  double tmp___4 ;
  double tmp___5 ;

  {
  {
#line 300
  page_name = (char *)arg;
#line 304
  n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lfmmx%lf",
             & dpw, & dph);
  }
#line 305
  if (n != 2) {
    {
#line 305
    tmp___0 = strlen((char const   *)arg);
    }
#line 305
    if (tmp___0 < 20U) {
      {
#line 306
      n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lfx%lf%s",
                 & dpw, & dph, tmpstr);
      }
#line 307
      if (n == 3) {
        {
#line 307
        tmp = strcmp((char const   *)(tmpstr), "mm");
        }
#line 307
        if (! tmp) {
#line 309
          page_wid = (int )((dpw / 25.4) * 72.0 + 0.5);
#line 310
          page_hei = (int )((dph / 25.4) * 72.0 + 0.5);
#line 311
          return (0);
        }
      }
    }
  }
  {
#line 318
  n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lfinx%lf",
             & dpw, & dph);
  }
#line 319
  if (n != 2) {
    {
#line 319
    tmp___2 = strlen((char const   *)arg);
    }
#line 319
    if (tmp___2 < 20U) {
      {
#line 320
      n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lfx%lf%s",
                 & dpw, & dph, tmpstr);
      }
#line 321
      if (n == 3) {
        {
#line 321
        tmp___1 = strcmp((char const   *)(tmpstr), "in");
        }
#line 321
        if (! tmp___1) {
#line 322
          page_wid = (int )(dpw * 72.0 + 0.5);
#line 323
          page_hei = (int )(dph * 72.0 + 0.5);
#line 324
          return (0);
        }
      }
    }
  }
  {
#line 331
  n = sscanf((char const   */* __restrict  */)((char *)arg), (char const   */* __restrict  */)"%lfx%lf",
             & dpw, & dph);
  }
#line 332
  if (n == 2) {
#line 333
    page_wid = (int )(dpw * unit);
#line 334
    page_hei = (int )(dph * unit);
#line 335
    if (unit != 1.0) {
      {
#line 336
      tmp___3 = malloc((size_t )32);
#line 336
      page_name = (char *)tmp___3;
      }
#line 337
      if (page_name) {
        {
#line 338
        sprintf((char */* __restrict  */)page_name, (char const   */* __restrict  */)"%dx%d\n",
                page_wid, page_hei);
        }
      }
    }
#line 340
    return (0);
  }
  {
#line 350
  paperinit();
#line 351
  paptr = paperinfo((char const   *)arg);
  }
#line 352
  if (! paptr) {
    {
#line 353
    paperdone();
    }
#line 354
    return (-1);
  }
  {
#line 356
  tmp___4 = paperpswidth(paptr);
#line 356
  page_wid = (int )(tmp___4 + 0.5);
#line 357
  tmp___5 = paperpsheight(paptr);
#line 357
  page_hei = (int )(tmp___5 + 0.5);
#line 358
  paperdone();
  }
#line 359
  return (0);
  {
#line 363
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wrong page size specification \"%s\"\n",
          prgname, (char *)arg);
  }
#line 365
  return (-2);
}
}
#line 371 "/abs/pronto/test-suite/barcode-0.96/main.c"
struct commandline option_table[13]  = 
#line 371
  {      {'i', 5, (void *)(& ifilename), (int (*)(void * ))((void *)0), (char *)((void *)0),
      (char *)((void *)0), (char *)"input file (strings to encode), default is stdin"}, 
        {'o',
      5, (void *)(& ofilename), (int (*)(void * ))((void *)0), (char *)((void *)0),
      (char *)((void *)0), (char *)"output file, default is stdout"}, 
        {'b', 5, (void *)0, & get_input_string, (char *)((void *)0), (char *)((void *)0),
      (char *)"string to encode (use input file if missing)"}, 
        {'e', 5, (void *)0, & get_encoding, (char *)"BARCODE_ENCODING", (char *)((void *)0),
      (char *)"encoding type (default is best fit for first string)"}, 
        {'u', 5, (void *)0, & get_unit, (char *)"BARCODE_UNIT", (char *)((void *)0),
      (char *)"unit (\"mm\", \"in\", ...) used to decode -g, -t, -p"}, 
        {'g', 5, (void *)0, & get_geometry, (char *)"BARCODE_GEOMETRY", (char *)((void *)0),
      (char *)"geometry on the page: [<wid>x<hei>][+<margin>+<margin>]"}, 
        {'t', 5, (void *)0, & get_table, (char *)"BARCODE_TABLE", (char *)((void *)0),
      (char *)"table geometry: <cols>x<lines>[+<margin>+<margin>]"}, 
        {'m', 5, (void *)0, & get_margin, (char *)"BARCODE_MARGIN", (char *)"10", (char *)"internal margin for each item in a table: <xm>[,<ym>]"}, 
        {'n',
      0, (void *)(& noascii), (int (*)(void * ))((void *)0), (char *)((void *)0),
      (char *)((void *)0), (char *)"\"numeric\": avoid printing text along with the bars"}, 
        {'c',
      0, (void *)(& nochecksum), (int (*)(void * ))((void *)0), (char *)((void *)0),
      (char *)((void *)0), (char *)"no Checksum character, if the chosen encoding allows it"}, 
        {'E',
      0, (void *)(& eps), (int (*)(void * ))((void *)0), (char *)((void *)0), (char *)((void *)0),
      (char *)"print one code as eps file (default: multi-page ps)"}, 
        {'p', 5, (void *)0, & get_page_geometry, (char *)((void *)0), (char *)((void *)0),
      (char *)"page size (refer to the man page)"}, 
        {0, 0, (void *)0, (int (*)(void * ))0, (char *)0, (char *)0, (char *)0}};
#line 416 "/abs/pronto/test-suite/barcode-0.96/main.c"
int main(int argc , char **argv ) 
{ 
  FILE *ifile ;
  FILE *ofile ;
  char *line ;
  int flags ;
  int page ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  unsigned char *tmp___8 ;
  int xstep ;
  int ystep ;
  int x ;
  int y ;
  int tmp___9 ;
  unsigned char *tmp___10 ;

  {
#line 418
  ifile = stdin;
#line 419
  ofile = stdout;
#line 421
  flags = 0;
#line 424
  prgname = *(argv + 0);
#line 427
  if (argc == 2) {
    {
#line 427
    tmp = strcmp((char const   *)*(argv + 1), "--help");
    }
#line 427
    if (tmp) {
      {
#line 427
      tmp___0 = strcmp((char const   *)*(argv + 1), "-h");
      }
#line 427
      if (! tmp___0) {
        {
#line 428
        commandline_errormsg(stderr, option_table, *(argv + 0), (char *)"Options:\n");
#line 429
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 430
        list_encodes(stderr);
#line 431
        exit(1);
        }
      }
    } else {
      {
#line 428
      commandline_errormsg(stderr, option_table, *(argv + 0), (char *)"Options:\n");
#line 429
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 430
      list_encodes(stderr);
#line 431
      exit(1);
      }
    }
  }
#line 434
  if (argc == 2) {
    {
#line 434
    tmp___1 = strcmp((char const   *)*(argv + 1), "--version");
    }
#line 434
    if (! tmp___1) {
      {
#line 435
      printf((char const   */* __restrict  */)"barcode frontend (GNU barcode) 0.96\n");
#line 436
      exit(0);
      }
    }
  }
  {
#line 440
  retval = commandline(option_table, argc, argv, (char *)"Use: %s [options]\n");
  }
#line 441
  if (retval) {
#line 442
    if (retval == -1) {
      {
#line 443
      list_encodes(stderr);
      }
    } else {
      {
#line 445
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: try \"%s --help\"\n",
              prgname, prgname);
      }
    }
    {
#line 446
    exit(1);
    }
  }
#line 450
  if (! page_name) {
    {
#line 451
    page_wid = 595;
#line 451
    page_hei = 842;
#line 452
    page_name = (char *)"A4";
#line 454
    tmp___2 = systempapername();
#line 454
    get_page_geometry((void *)tmp___2);
    }
  }
#line 461
  if (ifilename) {
    {
#line 462
    ifile = fopen((char const   */* __restrict  */)ifilename, (char const   */* __restrict  */)"r");
    }
  }
#line 463
  if (! ifile) {
    {
#line 464
    tmp___3 = __errno_location();
#line 464
    tmp___4 = strerror(*tmp___3);
#line 464
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            *(argv + 0), ifilename, tmp___4);
#line 466
    exit(1);
    }
  }
#line 470
  if (ofilename) {
    {
#line 471
    ofile = fopen((char const   */* __restrict  */)ofilename, (char const   */* __restrict  */)"w");
    }
  }
#line 472
  if (! ofile) {
    {
#line 473
    tmp___5 = __errno_location();
#line 473
    tmp___6 = strerror(*tmp___5);
#line 473
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            *(argv + 0), ofilename, tmp___6);
#line 475
    exit(1);
    }
  }
#line 478
  if (encoding_type < 0) {
    {
#line 479
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown endoding. Try \"%s --help\"\n",
            *(argv + 0), *(argv + 0));
#line 481
    exit(1);
    }
  }
#line 483
  flags |= encoding_type;
#line 484
  ps = ! eps;
#line 485
  if (eps) {
#line 486
    flags |= 4096;
  } else {
#line 488
    flags |= 1056768;
  }
#line 489
  if (noascii) {
#line 490
    flags |= 256;
  }
#line 491
  if (nochecksum) {
#line 492
    flags |= 512;
  }
#line 495
  if (eps) {
#line 495
    if (lines > 1) {
      {
#line 496
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t print tables in EPS format\n",
              *(argv + 0));
#line 497
      exit(1);
      }
    } else
#line 495
    if (columns > 1) {
      {
#line 496
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t print tables in EPS format\n",
              *(argv + 0));
#line 497
      exit(1);
      }
    }
  }
#line 500
  if (ps) {
    {
#line 502
    fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%!PS-Adobe-2.0\n");
#line 504
    fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%Creator: \"barcode\", libbarcode sample frontend\n");
    }
#line 506
    if (page_name) {
      {
#line 507
      fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%DocumentPaperSizes: %s\n",
              page_name);
      }
    }
    {
#line 508
    fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%EndComments\n");
#line 509
    fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%EndProlog\n\n");
    }
  }
#line 516
  if (! lines) {
#line 516
    if (! columns) {
#line 517
      page = 0;
      {
#line 518
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 518
        tmp___8 = retrieve_input_string(ifile);
#line 518
        line = (char *)tmp___8;
        }
#line 518
        if (! line) {
#line 518
          goto while_break;
        }
#line 519
        page ++;
#line 520
        if (ps) {
          {
#line 521
          fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%Page: %i %i\n\n",
                  page, page);
          }
        }
        {
#line 523
        tmp___7 = Barcode_Encode_and_Print(line, ofile, code_width, code_height, xmargin0,
                                           ymargin0, flags);
        }
#line 523
        if (tmp___7 < 0) {
          {
#line 525
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t encode \"%s\"\n",
                  *(argv + 0), line);
          }
        }
#line 527
        if (eps) {
#line 527
          goto while_break;
        }
        {
#line 528
        fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"showpage\n");
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 531
      if (ps) {
        {
#line 532
        fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%Trailer\n\n");
        }
      }
    } else {
#line 516
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 538
    xstep = ((page_wid - xmargin0) - xmargin1) / columns;
#line 539
    ystep = ((page_hei - ymargin0) - ymargin1) / lines;
#line 540
    x = columns;
#line 540
    y = -1;
#line 542
    page = 0;
    {
#line 545
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 545
      tmp___10 = retrieve_input_string(ifile);
#line 545
      line = (char *)tmp___10;
      }
#line 545
      if (! line) {
#line 545
        goto while_break___0;
      }
#line 546
      x ++;
#line 547
      if (x >= columns) {
#line 548
        x = 0;
#line 548
        y --;
#line 549
        if (y < 0) {
#line 550
          y = lines - 1;
#line 550
          page ++;
#line 551
          if (page > 1) {
            {
#line 551
            fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"showpage\n");
            }
          }
          {
#line 552
          fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"%%%%Page: %i %i\n\n",
                  page, page);
          }
        }
      }
      {
#line 561
      tmp___9 = Barcode_Encode_and_Print(line, ofile, xstep - 2 * ximargin, ystep - 2 * yimargin,
                                         ((xmargin0 + ximargin) + x * xstep) - 10,
                                         ((ymargin0 + yimargin) + y * ystep) - 10,
                                         flags);
      }
#line 561
      if (tmp___9 < 0) {
        {
#line 566
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t encode \"%s\"\n",
                *(argv + 0), line);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 569
    fprintf((FILE */* __restrict  */)ofile, (char const   */* __restrict  */)"showpage\n\n%%%%Trailer\n\n");
    }
  }
#line 571
  return (0);
}
}
