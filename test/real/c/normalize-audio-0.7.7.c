/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 195 "/usr/include/sys/types.h"
typedef signed char int8_t;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   unsigned long st_atimensec ;
   __time_t st_mtime ;
   unsigned long st_mtimensec ;
   __time_t st_ctime ;
   unsigned long st_ctimensec ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 44 "/usr/include/audiofile.h"
struct _AFfilesetup;
#line 44 "/usr/include/audiofile.h"
typedef struct _AFfilesetup *AFfilesetup;
#line 45
struct _AFfilehandle;
#line 45 "/usr/include/audiofile.h"
typedef struct _AFfilehandle *AFfilehandle;
#line 48 "/usr/include/audiofile.h"
typedef off_t AFframecount;
#line 49 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/common.h"
struct signal_info {
   double level ;
   double peak ;
   long max_sample ;
   long min_sample ;
   int channels ;
   int bits_per_sample ;
   unsigned int samples_per_sec ;
   off_t file_size ;
   int orig_index ;
};
#line 111 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/volume.c"
struct __anonstruct_datasmooth_t_27 {
   double *buf ;
   int buflen ;
   int start ;
   int n ;
};
#line 111 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/volume.c"
typedef struct __anonstruct_datasmooth_t_27 datasmooth_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 79 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 66 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/common.h"
struct progress_struct {
   time_t file_start ;
   time_t batch_start ;
   off_t *file_sizes ;
   off_t batch_size ;
   off_t finished_size ;
   int on_file ;
};
#line 21 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
struct id3_struct;
#line 21 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
typedef struct id3_struct *id3_t;
#line 22
struct id3_frame_struct;
#line 22 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
typedef struct id3_frame_struct *id3_frame_t;
#line 30
enum id3_text_encoding {
    ID3_TEXT_ISO = 0,
    ID3_TEXT_UTF16 = 1,
    ID3_TEXT_UTF16BE = 2,
    ID3_TEXT_UTF8 = 3
} ;
#line 38
enum id3_version {
    ID3_VERSION_NONE = 0,
    ID3_VERSION_1 = 1,
    ID3_VERSION_2_2 = 2,
    ID3_VERSION_2_3 = 3,
    ID3_VERSION_2_4 = 4
} ;
#line 47
enum id3_pad_policy {
    ID3_PADDING_DEFAULT = 0,
    ID3_PADDING_NONE = 1,
    ID3_PADDING_CUSTOM = 2
} ;
#line 33 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3P.h"
struct id3v1_struct {
   unsigned int exists : 1 ;
   unsigned int requested : 1 ;
   char title[31] ;
   char artist[31] ;
   char album[31] ;
   char year[5] ;
   char comment[31] ;
   unsigned char track ;
   char trackstr[4] ;
   unsigned char genre ;
   char genrestr[4] ;
};
#line 47 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3P.h"
struct id3_struct {
   FILE *fp ;
   off_t offset ;
   off_t curr_off ;
   char *fname ;
   unsigned char version ;
   unsigned char revision ;
   int tagsz ;
   int nframes ;
   int mode ;
   enum id3_pad_policy pad_policy ;
   int requested_sz ;
   id3_frame_t frame_hd ;
   id3_frame_t frame_tl ;
   unsigned int unsync : 1 ;
   unsigned int has_ext_hdr : 1 ;
   unsigned int experimental : 1 ;
   unsigned int has_footer : 1 ;
   unsigned int is_update : 1 ;
   unsigned int has_crc : 1 ;
   unsigned int has_restrict : 1 ;
   unsigned int seekable : 1 ;
   unsigned int append : 1 ;
   unsigned int append_req : 1 ;
   struct id3v1_struct v1 ;
};
#line 81 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3P.h"
struct id3_frame_struct {
   char id[5] ;
   int sz ;
   unsigned short flags ;
   unsigned char groupid ;
   int datalen ;
   unsigned char *data ;
   char *curr_txt ;
   off_t offset ;
   id3_t id3 ;
   struct id3_frame_struct *next ;
};
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
enum id3_rva_channel {
    ID3_CHANNEL_OTHER = 0,
    ID3_CHANNEL_MASTER = 1,
    ID3_CHANNEL_FRIGHT = 2,
    ID3_CHANNEL_FLEFT = 3,
    ID3_CHANNEL_BRIGHT = 4,
    ID3_CHANNEL_BLEFT = 5,
    ID3_CHANNEL_FCENTER = 6,
    ID3_CHANNEL_BCENTER = 7,
    ID3_CHANNEL_SUB = 8,
    ID3_CHANNEL_ANY = 255
} ;
#line 83 "/usr/include/wchar.h"
union __anonunion___value_3 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_2 {
   int __count ;
   union __anonunion___value_3 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_2 __mbstate_t;
#line 22 "/usr/include/_G_config.h"
struct __anonstruct__G_fpos_t_4 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 22 "/usr/include/_G_config.h"
typedef struct __anonstruct__G_fpos_t_4 _G_fpos_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 91 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 57 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
enum id3_fflag {
    ID3_FFLAG_TAGALTER_PRESERVE = 0,
    ID3_FFLAG_FILEALTER_PRESERVE = 1,
    ID3_FFLAG_READONLY = 2,
    ID3_FFLAG_HAS_GROUPID = 3,
    ID3_FFLAG_IS_COMPRESSED = 4,
    ID3_FFLAG_IS_ENCRYPTED = 5,
    ID3_FFLAG_IS_UNSYNCED = 6,
    ID3_FFLAG_HAS_DATALEN = 7
} ;
#line 35 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
struct fid_desc {
   char const   *id ;
   char const   *desc ;
};
#line 55 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
struct frame_convert {
   char const   *from ;
   char const   *to ;
   int (*converter)(id3_frame_t  , char const   * , char const   * , int  ) ;
};
#line 188 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
struct imgtype_mimetype_struct {
   char const   *imgtype ;
   char const   *mimetype ;
};
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 157
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 513
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 77 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 182
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 406 "/usr/include/audiofile.h"
extern AFfilesetup afNewFileSetup(void) ;
#line 407
extern void afFreeFileSetup(AFfilesetup  ) ;
#line 415
extern AFfilehandle afOpenFD(int fd , char const   *mode , AFfilesetup setup ) ;
#line 421
extern int afSyncFile(AFfilehandle file ) ;
#line 422
extern int afCloseFile(AFfilehandle file ) ;
#line 424
extern void afInitFileFormat(AFfilesetup  , int format ) ;
#line 425
extern int afGetFileFormat(AFfilehandle  , int *version ) ;
#line 432
extern int afReadFrames(AFfilehandle  , int track , void *buffer , int frameCount ) ;
#line 433
extern int afWriteFrames(AFfilehandle  , int track , void const   *buffer , int frameCount ) ;
#line 437
extern float afGetFrameSize(AFfilehandle  , int track , int expand3to4 ) ;
#line 463
extern void afInitByteOrder(AFfilesetup  , int track , int byteOrder ) ;
#line 464
extern int afGetByteOrder(AFfilehandle  , int track ) ;
#line 469
extern void afInitChannels(AFfilesetup  , int track , int nchannels ) ;
#line 470
extern int afGetChannels(AFfilehandle  , int track ) ;
#line 476
extern void afInitSampleFormat(AFfilesetup  , int track , int sampleFormat , int sampleWidth ) ;
#line 478
extern void afGetSampleFormat(AFfilehandle file , int track , int *sampfmt , int *sampwidth ) ;
#line 482
extern int afSetVirtualSampleFormat(AFfilehandle  , int track , int sampleFormat ,
                                    int sampleWidth ) ;
#line 488
extern void afInitRate(AFfilesetup  , int track , double rate ) ;
#line 489
extern double afGetRate(AFfilehandle  , int track ) ;
#line 540
extern AFframecount afGetFrameCount(AFfilehandle file , int track ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 84 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
int apply_gain_mp3(char *filename , double gain , struct signal_info *si ) ;
#line 85
int strncaseeq(char const   *s1 , char const   *s2 , size_t n ) ;
#line 86
void progress_callback(char *prefix , float fraction_completed ) ;
#line 87
char *basename(char *path ) ;
#line 88
void *xmalloc(size_t size ) ;
#line 90
char *progname ;
#line 91
int verbose ;
#line 92
int do_compute_levels ;
#line 93
int use_limiter ;
#line 94
int output_bitwidth ;
#line 95
double lmtr_lvl ;
#line 96
double adjust_thresh ;
#line 97
int batch_mode ;
#line 100
int xmkstemp(char *template ) ;
#line 101
int xrename(char const   *oldpath , char const   *newpath ) ;
#line 104 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
__inline static long get_sample(unsigned char *pdata , int bytes_per_sample ) 
{ 
  long sample ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 110
  if (bytes_per_sample == 1) {
#line 110
    goto case_1;
  }
#line 113
  if (bytes_per_sample == 2) {
#line 113
    goto case_2;
  }
#line 120
  if (bytes_per_sample == 4) {
#line 120
    goto case_4;
  }
#line 120
  if (bytes_per_sample == 3) {
#line 120
    goto case_4;
  }
#line 124
  goto switch_default;
  case_1: /* CIL Label */ 
#line 111
  sample = (long )*((int8_t *)pdata);
#line 112
  goto switch_break;
  case_2: /* CIL Label */ 
#line 115
  sample = (long )*((int16_t *)pdata);
#line 116
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 122
  sample = (long )*((int32_t *)pdata);
#line 123
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 127
  tmp = gettext("%s: I don\'t know what to do with %d bytes per sample\n");
  }
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, progname,
          bytes_per_sample);
  }
  {
#line 130
  abort();
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 133
  return (sample);
}
}
#line 137 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
__inline static void put_sample(long sample , unsigned char *pdata , int bytes_per_sample ) 
{ 
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 141
  if (bytes_per_sample == 1) {
#line 141
    goto case_1;
  }
#line 144
  if (bytes_per_sample == 2) {
#line 144
    goto case_2;
  }
#line 149
  if (bytes_per_sample == 4) {
#line 149
    goto case_4;
  }
#line 149
  if (bytes_per_sample == 3) {
#line 149
    goto case_4;
  }
#line 153
  goto switch_default;
  case_1: /* CIL Label */ 
#line 142
  *((int8_t *)pdata) = (int8_t )sample;
#line 143
  goto switch_break;
  case_2: /* CIL Label */ 
#line 146
  *((int16_t *)pdata) = (int16_t )sample;
#line 147
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 151
  *((int32_t *)pdata) = (int32_t )sample;
#line 152
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 156
  tmp = gettext("%s: I don\'t know what to do with %d bytes per sample\n");
  }
  {
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, progname,
          bytes_per_sample);
  }
  {
#line 159
  abort();
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
static double limiter(double x ) 
{ 
  double xp ;
  double tmp ;
  double tmp___0 ;

  {
#line 181
  if (x < - lmtr_lvl) {
    {
    {
#line 182
    tmp = tanh((x + lmtr_lvl) / ((double )1 - lmtr_lvl));
    }
#line 182
    xp = tmp * ((double )1 - lmtr_lvl) - lmtr_lvl;
    }
  } else
#line 183
  if (x <= lmtr_lvl) {
#line 184
    xp = x;
  } else {
    {
    {
#line 186
    tmp___0 = tanh((x - lmtr_lvl) / ((double )1 - lmtr_lvl));
    }
#line 186
    xp = tmp___0 * ((double )1 - lmtr_lvl) + lmtr_lvl;
    }
  }
#line 188
  return (xp);
}
}
#line 200 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
static int _do_apply_gain(int read_fd , int write_fd , char *filename , double gain ,
                          struct signal_info *si ) 
{ 
  AFfilehandle fhin ;
  AFfilehandle fhout ;
  AFframecount framecount ;
  AFfilesetup setup ;
  int i ;
  int c ;
  int af_fmt ;
  int src_bytes_per_samp ;
  int dst_bytes_per_samp ;
  int src_framesz ;
  int dst_framesz ;
  int channels ;
  int samp_fmt ;
  int src_samp_width ;
  int dst_samp_width ;
  int fmt_vers ;
  unsigned int samp_rate ;
  unsigned int frames_done ;
  unsigned int nclippings ;
  long sample ;
  long src_samplemax ;
  long src_samplemin ;
  long dst_samplemax ;
  long dst_samplemin ;
  double sample_d ;
  float clip_loss ;
  float last_progress ;
  float progress ;
  char prefix_buf[18] ;
  unsigned char *src_buf ;
  unsigned char *dst_buf ;
  unsigned char *src_pos ;
  unsigned char *dst_pos ;
  int frames_in_buf ;
  int frames_recvd ;
  int use_limiter_this_file ;
  int min_pos_clipped ;
  int max_neg_clipped ;
  int32_t *lut ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;
  void *tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
  {
#line 215
  last_progress = (float )0;
#line 218
  src_buf = (unsigned char *)((void *)0);
#line 218
  dst_buf = (unsigned char *)((void *)0);
#line 222
  min_pos_clipped = 0;
#line 223
  max_neg_clipped = 0;
#line 224
  lut = (int32_t *)((void *)0);
  {
#line 229
  setup = afNewFileSetup();
  }
  }
#line 230
  if ((unsigned long )setup == (unsigned long )((struct _AFfilesetup *)0)) {
    {
    {
#line 231
    tmp = gettext("%s: afNewFileSetup failed\n");
    }
    {
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            progname);
    }
    }
#line 232
    goto error1;
  }
  {
  {
#line 235
  fhin = afOpenFD(read_fd, "r", (AFfilesetup )((void *)0));
  }
  }
#line 236
  if ((unsigned long )fhin == (unsigned long )((struct _AFfilehandle *)0)) {
    {
    {
#line 237
    tmp___0 = gettext("%s: afOpenFD failed\n");
    }
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            progname);
    }
    }
#line 238
    goto error2;
  }
  {
  {
#line 242
  af_fmt = afGetFileFormat(fhin, & fmt_vers);
  }
  {
#line 243
  afInitFileFormat(setup, af_fmt);
  }
  {
#line 244
  tmp___1 = afGetByteOrder(fhin, 1001);
  }
  {
#line 244
  afInitByteOrder(setup, 1001, tmp___1);
  }
  {
#line 245
  channels = afGetChannels(fhin, 1001);
  }
  {
#line 246
  afInitChannels(setup, 1001, channels);
  }
  {
#line 247
  afGetSampleFormat(fhin, 1001, & samp_fmt, & src_samp_width);
  }
#line 248
  dst_samp_width = src_samp_width;
  }
#line 249
  if (output_bitwidth) {
#line 250
    dst_samp_width = output_bitwidth;
#line 251
    if (af_fmt == 4) {
#line 252
      if (dst_samp_width > 8) {
#line 252
        samp_fmt = 401;
      } else {
#line 252
        samp_fmt = 402;
      }
    }
  }
  {
  {
#line 254
  afInitSampleFormat(setup, 1001, samp_fmt, dst_samp_width);
  }
  {
#line 255
  tmp___2 = afGetRate(fhin, 1001);
  }
  {
#line 255
  afInitRate(setup, 1001, tmp___2);
  }
  {
#line 256
  tmp___3 = afGetRate(fhin, 1001);
  }
#line 256
  samp_rate = (unsigned int )tmp___3;
  {
#line 258
  fhout = afOpenFD(write_fd, "w", setup);
  }
  }
#line 259
  if ((unsigned long )fhout == (unsigned long )((struct _AFfilehandle *)0)) {
    {
    {
#line 260
    tmp___4 = gettext("%s: afOpenFD failed\n");
    }
    {
#line 260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
            progname);
    }
    }
#line 261
    goto error3;
  }
  {
  {
#line 265
  afSetVirtualSampleFormat(fhin, 1001, 401, src_samp_width);
  }
  {
#line 266
  afSetVirtualSampleFormat(fhout, 1001, 401, dst_samp_width);
  }
#line 268
  src_bytes_per_samp = (src_samp_width - 1) / 8 + 1;
#line 269
  src_samplemax = (long )((1 << (src_bytes_per_samp * 8 - 1)) - 1);
#line 270
  src_samplemin = - src_samplemax - 1L;
#line 271
  dst_bytes_per_samp = (dst_samp_width - 1) / 8 + 1;
#line 272
  dst_samplemax = (long )((1 << (dst_bytes_per_samp * 8 - 1)) - 1);
#line 273
  dst_samplemin = - dst_samplemax - 1L;
  {
#line 276
  framecount = afGetFrameCount(fhin, 1001);
  }
#line 279
  frames_in_buf = (int )(samp_rate / 100U);
  {
#line 280
  tmp___5 = afGetFrameSize(fhin, 1001, 1);
  }
#line 280
  src_framesz = (int )tmp___5;
  {
#line 281
  tmp___6 = afGetFrameSize(fhout, 1001, 1);
  }
#line 281
  dst_framesz = (int )tmp___6;
  {
#line 282
  tmp___7 = xmalloc((size_t )(frames_in_buf * src_framesz));
  }
#line 282
  src_buf = (unsigned char *)tmp___7;
  {
#line 283
  tmp___8 = xmalloc((size_t )(frames_in_buf * dst_framesz));
  }
#line 283
  dst_buf = (unsigned char *)tmp___8;
  }
#line 290
  if (use_limiter) {
#line 290
    if (gain > 1.0) {
#line 290
      tmp___9 = 1;
    } else {
#line 290
      tmp___9 = 0;
    }
  } else {
#line 290
    tmp___9 = 0;
  }
#line 290
  use_limiter_this_file = tmp___9;
#line 291
  if (use_limiter_this_file) {
#line 291
    if (si) {
#line 292
      if ((double )si->max_sample * gain <= (double )src_samplemax) {
#line 292
        if ((double )si->min_sample * gain >= (double )src_samplemin) {
#line 294
          use_limiter_this_file = 0;
        }
      }
    }
  }
#line 300
  if (dst_bytes_per_samp != src_bytes_per_samp) {
    {
    {
#line 301
    tmp___10 = pow(256.0, (double )(dst_bytes_per_samp - src_bytes_per_samp));
    }
#line 301
    gain *= tmp___10;
    }
  }
#line 309
  if (src_bytes_per_samp <= 2) {
    {
    {
#line 310
    tmp___11 = xmalloc((size_t )((unsigned long )((src_samplemax - src_samplemin) + 1L) * sizeof(int32_t )));
    }
#line 310
    lut = (int32_t *)tmp___11;
#line 311
    lut -= src_samplemin;
#line 312
    min_pos_clipped = (int )(src_samplemax + 1L);
#line 313
    max_neg_clipped = (int )(src_samplemin - 1L);
    }
#line 314
    if (gain > 1.0) {
#line 315
      if (use_limiter_this_file) {
#line 317
        i = (int )src_samplemin;
        {
        {
#line 317
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 317
          if (! (i < 0)) {
#line 317
            goto while_break;
          }
          {
          {
#line 318
          tmp___12 = limiter(((double )i * gain) / (double )(- dst_samplemin));
          }
          {
#line 318
          tmp___13 = floor((double )(- dst_samplemin) * tmp___12 + 0.5);
          }
#line 318
          *(lut + i) = (int32_t )tmp___13;
#line 317
          i ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
        {
#line 319
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 319
          if (! ((long )i <= src_samplemax)) {
#line 319
            goto while_break___0;
          }
          {
          {
#line 320
          tmp___14 = limiter(((double )i * gain) / (double )dst_samplemax);
          }
          {
#line 320
          tmp___15 = floor((double )dst_samplemax * tmp___14 + 0.5);
          }
#line 320
          *(lut + i) = (int32_t )tmp___15;
#line 319
          i ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 323
        i = (int )src_samplemin;
        {
        {
#line 323
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 323
          if (! ((long )i <= src_samplemax)) {
#line 323
            goto while_break___1;
          }
          {
          {
#line 324
          tmp___16 = floor((double )i * gain + 0.5);
          }
#line 324
          sample = (long )tmp___16;
          }
#line 325
          if (sample > dst_samplemax) {
#line 326
            sample = dst_samplemax;
#line 327
            if (i < min_pos_clipped) {
#line 328
              min_pos_clipped = i;
            }
          } else
#line 329
          if (sample < dst_samplemin) {
#line 330
            sample = dst_samplemin;
#line 331
            if (i > max_neg_clipped) {
#line 332
              max_neg_clipped = i;
            }
          }
#line 334
          *(lut + i) = (int32_t )sample;
#line 323
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 339
      i = (int )src_samplemin;
      {
      {
#line 339
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 339
        if (! ((long )i <= src_samplemax)) {
#line 339
          goto while_break___2;
        }
        {
        {
#line 340
        tmp___17 = floor((double )i * gain + 0.5);
        }
#line 340
        *(lut + i) = (int32_t )tmp___17;
#line 339
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 355
  if (verbose >= 1) {
    {
    {
#line 356
    tmp___18 = basename(filename);
    }
    {
#line 356
    strncpy((char */* __restrict  */)(prefix_buf), (char const   */* __restrict  */)tmp___18,
            (size_t )17);
    }
#line 357
    prefix_buf[17] = (char)0;
    {
#line 358
    progress_callback(prefix_buf, (float )0.0);
    }
#line 359
    last_progress = (float )0.0;
    }
  }
#line 363
  frames_done = 0U;
#line 363
  nclippings = frames_done;
  {
  {
#line 364
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 364
    frames_recvd = afReadFrames(fhin, 1001, (void *)src_buf, frames_in_buf);
    }
    }
#line 364
    if (! (frames_recvd > 0)) {
#line 364
      goto while_break___3;
    }
#line 366
    if (lut) {
#line 370
      c = 0;
      {
      {
#line 370
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 370
        if (! (c < channels)) {
#line 370
          goto while_break___4;
        }
#line 371
        src_pos = src_buf + c * (src_framesz / channels);
#line 372
        dst_pos = dst_buf + c * (dst_framesz / channels);
#line 373
        i = 0;
        {
        {
#line 373
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 373
          if (! (i < frames_recvd)) {
#line 373
            goto while_break___5;
          }
          {
          {
#line 375
          sample = get_sample(src_pos, src_bytes_per_samp);
          }
          }
#line 377
          if (! use_limiter) {
#line 377
            if (sample >= (long )min_pos_clipped) {
#line 379
              nclippings ++;
            } else
#line 377
            if (sample <= (long )max_neg_clipped) {
#line 379
              nclippings ++;
            }
          }
          {
#line 381
          sample = (long )*(lut + sample);
          {
#line 383
          put_sample(sample, dst_pos, dst_bytes_per_samp);
          }
#line 385
          src_pos += src_framesz;
#line 386
          dst_pos += dst_framesz;
#line 373
          i ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 370
        c ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 394
      if (use_limiter_this_file) {
#line 394
        if (verbose >= 2) {
          {
          {
#line 395
          tmp___19 = gettext("%s: Warning: no lookup table available; this may be slow...\n");
          }
          {
#line 395
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
                  progname);
          }
          }
        }
      }
#line 399
      c = 0;
      {
      {
#line 399
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 399
        if (! (c < channels)) {
#line 399
          goto while_break___6;
        }
#line 400
        src_pos = src_buf + c * (src_framesz / channels);
#line 401
        dst_pos = dst_buf + c * (dst_framesz / channels);
#line 402
        i = 0;
        {
        {
#line 402
        while (1) {
          while_continue___16: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 402
          if (! (i < frames_recvd)) {
#line 402
            goto while_break___7;
          }
          {
          {
#line 404
          sample = get_sample(src_pos, src_bytes_per_samp);
          }
#line 407
          sample_d = (double )sample * gain;
          }
#line 409
          if (gain > 1.0) {
#line 410
            if (use_limiter_this_file) {
              {
              {
#line 412
              tmp___20 = limiter(sample_d / (double )dst_samplemax);
              }
              {
#line 412
              tmp___21 = floor((double )dst_samplemax * tmp___20 + 0.5);
              }
#line 412
              sample = (long )tmp___21;
              }
            } else {
              {
              {
#line 414
              tmp___22 = floor(sample_d + 0.5);
              }
#line 414
              sample = (long )tmp___22;
              }
#line 416
              if (sample_d > (double )dst_samplemax) {
#line 417
                sample = dst_samplemax;
#line 418
                nclippings ++;
              } else
#line 419
              if (sample_d < (double )dst_samplemin) {
#line 420
                sample = dst_samplemin;
#line 421
                nclippings ++;
              }
            }
          } else {
            {
            {
#line 425
            tmp___23 = floor(sample_d + 0.5);
            }
#line 425
            sample = (long )tmp___23;
            }
          }
          {
          {
#line 428
          put_sample(sample, dst_pos, dst_bytes_per_samp);
          }
#line 430
          src_pos += src_framesz;
#line 431
          dst_pos += dst_framesz;
#line 402
          i ++;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 399
        c ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
    {
#line 438
    tmp___25 = afWriteFrames(fhout, 1001, (void const   *)dst_buf, frames_recvd);
    }
    }
#line 438
    if (tmp___25 == -1) {
      {
      {
#line 439
      tmp___24 = gettext("%s: afWriteFrames failed\n");
      }
      {
#line 439
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              progname);
      }
      }
#line 440
      goto error4;
    }
#line 443
    frames_done += (unsigned int )frames_recvd;
#line 446
    if (verbose >= 1) {
#line 447
      progress = (float )frames_done / (float )framecount;
#line 448
      if ((double )progress >= (double )last_progress + 0.01) {
        {
        {
#line 449
        progress_callback(prefix_buf, progress);
        }
#line 450
        last_progress = (float )((double )last_progress + 0.01);
        }
      }
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 456
  if (verbose >= 1) {
    {
    {
#line 457
    progress_callback(prefix_buf, (float )1.0);
    }
    }
  }
#line 459
  if (! use_limiter_this_file) {
#line 460
    clip_loss = (float )nclippings / ((float )framecount * (float )channels);
#line 462
    if (verbose >= 2) {
#line 463
      if (nclippings) {
        {
        {
#line 464
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
        {
#line 465
        tmp___26 = gettext("%s: %d clippings performed, %.4f%% loss\n");
        }
        {
#line 465
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___26,
                progname, nclippings, (double )(clip_loss * (float )100));
        }
        }
      }
    } else
#line 468
    if (verbose >= 1) {
#line 469
      if ((double )clip_loss > 0.001) {
        {
        {
#line 470
        tmp___27 = gettext("%s: Warning: lost %0.2f%% of data due to clipping              \n");
        }
        {
#line 470
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___27,
                progname, (double )(clip_loss * (float )100));
        }
        }
      }
    }
  }
#line 477
  if (lut) {
    {
#line 479
    lut += src_samplemin;
    {
#line 480
    free((void *)lut);
    }
    }
  }
  {
  {
#line 483
  tmp___29 = afSyncFile(fhout);
  }
  }
#line 483
  if (tmp___29 < 0) {
    {
    {
#line 484
    tmp___28 = gettext("%s: afSyncFile failed\n");
    }
    {
#line 484
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
            progname);
    }
    }
  }
  {
  {
#line 485
  afCloseFile(fhin);
  }
  {
#line 486
  afCloseFile(fhout);
  }
  {
#line 487
  afFreeFileSetup(setup);
  }
  {
#line 488
  free((void *)src_buf);
  }
  {
#line 489
  free((void *)dst_buf);
  }
  }
#line 491
  return (0);
  error4: 
  {
  {
#line 496
  free((void *)src_buf);
  }
  {
#line 497
  free((void *)dst_buf);
  }
  {
#line 498
  afCloseFile(fhout);
  }
  }
  error3: 
  {
  {
#line 500
  afCloseFile(fhin);
  }
  }
  error2: 
  {
  {
#line 502
  afFreeFileSetup(setup);
  }
  }
  error1: 
#line 504
  return (-1);
}
}
#line 518 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
int apply_gain(char *filename , double gain , struct signal_info *si ) 
{ 
  int i ;
  int read_fd ;
  int write_fd ;
  char *suffix ;
  double dBdiff ;
  struct stat stbuf ;
  char *tmpfile___0 ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
  {
#line 531
  tmp = strlen((char const   *)filename);
  }
#line 531
  i = (int )tmp;
  }
#line 532
  if (i >= 4) {
    {
#line 533
    suffix = (filename + i) - 4;
    {
#line 534
    tmp___1 = strncaseeq((char const   *)suffix, ".mp3", (size_t )4);
    }
    }
#line 534
    if (tmp___1) {
      {
      {
#line 536
      tmp___0 = apply_gain_mp3(filename, gain, si);
      }
      }
#line 536
      return (tmp___0);
    } else {
      {
      {
#line 534
      tmp___2 = strncaseeq((char const   *)suffix, ".mp2", (size_t )4);
      }
      }
#line 534
      if (tmp___2) {
        {
        {
#line 536
        tmp___0 = apply_gain_mp3(filename, gain, si);
        }
        }
#line 536
        return (tmp___0);
      }
    }
  }
  {
  {
#line 539
  tmp___3 = log10(gain);
  }
#line 539
  dBdiff = (double )20 * tmp___3;
  }
#line 542
  if (do_compute_levels) {
    {
    {
#line 543
    tmp___4 = fabs(dBdiff);
    }
    }
#line 543
    if (tmp___4 < adjust_thresh) {
#line 545
      return (0);
    }
  }
#line 549
  if (! batch_mode) {
#line 549
    if (verbose >= 1) {
      {
      {
#line 550
      tmp___5 = gettext("Applying adjustment of %0.2fdB to %s...\n");
      }
      {
#line 550
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              dBdiff, filename);
      }
      }
    }
  }
  {
  {
#line 554
  read_fd = open((char const   *)filename, 0);
  }
  }
#line 555
  if (read_fd == -1) {
    {
    {
#line 556
    tmp___6 = __errno_location();
    }
    {
#line 556
    tmp___7 = strerror(*tmp___6);
    }
    {
#line 556
    tmp___8 = gettext("%s: error opening %s: %s\n");
    }
    {
#line 556
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
            progname, filename, tmp___7);
    }
    }
#line 558
    return (-1);
  }
  {
  {
#line 565
  tmp___9 = strlen((char const   *)filename);
  }
  {
#line 565
  tmp___10 = xmalloc(tmp___9 + 16U);
  }
#line 565
  tmpfile___0 = (char *)tmp___10;
  {
#line 566
  strcpy((char */* __restrict  */)tmpfile___0, (char const   */* __restrict  */)filename);
  }
  {
#line 567
  p = basename(tmpfile___0);
  }
  {
#line 568
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"_normXXXXXX");
  }
  {
#line 569
  write_fd = xmkstemp(tmpfile___0);
  }
  }
#line 570
  if (write_fd == -1) {
    {
    {
#line 571
    tmp___11 = __errno_location();
    }
    {
#line 571
    tmp___12 = strerror(*tmp___11);
    }
    {
#line 571
    tmp___13 = gettext("%s: error opening temp file: %s\n");
    }
    {
#line 571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
            progname, tmp___12);
    }
    {
#line 573
    close(read_fd);
    }
    {
#line 574
    free((void *)tmpfile___0);
    }
    }
#line 575
    return (-1);
  }
  {
  {
#line 579
  fstat(read_fd, & stbuf);
  }
  {
#line 580
  chmod((char const   *)tmpfile___0, stbuf.st_mode);
  }
  {
#line 596
  tmp___14 = _do_apply_gain(read_fd, write_fd, filename, gain, si);
  }
  }
#line 596
  if (tmp___14 == -1) {
    {
    {
#line 598
    free((void *)tmpfile___0);
    }
    }
#line 600
    return (-1);
  }
  {
  {
#line 605
  tmp___18 = xrename((char const   *)tmpfile___0, (char const   *)filename);
  }
  }
#line 605
  if (tmp___18 == -1) {
    {
    {
#line 606
    tmp___15 = __errno_location();
    }
    {
#line 606
    tmp___16 = strerror(*tmp___15);
    }
    {
#line 606
    tmp___17 = gettext("%s: error moving %s to %s: %s\n");
    }
    {
#line 606
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
            progname, tmpfile___0, filename, tmp___16);
    }
    {
#line 608
    free((void *)tmpfile___0);
    }
    }
#line 609
    return (-1);
  }
  {
  {
#line 611
  free((void *)tmpfile___0);
  }
  }
#line 614
  return (1);
}
}
#line 626 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
static char sfx[7]  = {      (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'A',      (char )'A',      (char )'\000'};
#line 623 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
int xmkstemp(char *template ) 
{ 
  char *p ;
  int fd ;
  int i ;
  int done ;
  size_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 630
  tmp = strlen((char const   *)template);
  }
#line 630
  p = (template + tmp) - 6;
  {
#line 631
  tmp___1 = strcmp((char const   *)p, "XXXXXX");
  }
  }
#line 631
  if (tmp___1 != 0) {
    {
    {
#line 632
    tmp___0 = __errno_location();
    }
#line 632
    *tmp___0 = 22;
    }
#line 633
    return (-1);
  }
  {
  {
#line 636
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 637
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(sfx));
    }
#line 640
    done = 0;
#line 640
    i = 5;
    }
    {
    {
#line 641
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 641
      if (! done) {
#line 641
        if (! (i >= 0)) {
#line 641
          goto while_break___0;
        }
      } else {
#line 641
        goto while_break___0;
      }
#line 642
      sfx[i] = (char )((int )sfx[i] + 1);
#line 643
      if ((int )sfx[i] > 90) {
#line 644
        sfx[i] = (char )'A';
#line 645
        i --;
      } else {
#line 647
        done = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 650
    if (! done) {
      {
      {
#line 651
      tmp___2 = __errno_location();
      }
#line 651
      *tmp___2 = 17;
      }
#line 652
      return (-1);
    }
    {
    {
#line 656
    fd = open((char const   *)template, 194, 384);
    }
    }
#line 636
    if (fd == -1) {
      {
      {
#line 636
      tmp___3 = __errno_location();
      }
      }
#line 636
      if (! (*tmp___3 == 17)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return (fd);
}
}
#line 668 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
int xrename(char const   *oldpath , char const   *newpath ) 
{ 
  FILE *in ;
  FILE *out ;
  char buf[4096] ;
  size_t sz ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 675
  tmp = strcmp(oldpath, newpath);
  }
  }
#line 675
  if (tmp == 0) {
#line 676
    return (0);
  }
  {
  {
#line 683
  tmp___8 = rename(oldpath, newpath);
  }
  }
#line 683
  if (tmp___8 == -1) {
    {
    {
#line 684
    tmp___7 = __errno_location();
    }
    }
#line 684
    if (*tmp___7 == 18) {
      {
      {
#line 686
      tmp___0 = unlink(newpath);
      }
      }
#line 686
      if (tmp___0 == -1) {
        {
        {
#line 686
        tmp___1 = __errno_location();
        }
        }
#line 686
        if (*tmp___1 != 2) {
#line 687
          return (-1);
        }
      }
      {
      {
#line 689
      in = fopen((char const   */* __restrict  */)oldpath, (char const   */* __restrict  */)"rb");
      }
      }
#line 690
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 691
        return (-1);
      }
      {
      {
#line 692
      out = fopen((char const   */* __restrict  */)newpath, (char const   */* __restrict  */)"wb");
      }
      }
#line 693
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        {
        {
#line 694
        fclose(in);
        }
        }
#line 695
        return (-1);
      }
      {
      {
#line 698
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 698
        sz = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )4096, (FILE */* __restrict  */)in);
        }
        }
#line 698
        if (! (sz > 0U)) {
#line 698
          goto while_break;
        }
        {
        {
#line 699
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, sz, (FILE */* __restrict  */)out);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 701
      tmp___2 = ferror(in);
      }
      }
#line 701
      if (tmp___2) {
        {
        {
#line 702
        fclose(in);
        }
        {
#line 703
        fclose(out);
        }
        }
#line 704
        return (-1);
      } else {
        {
        {
#line 701
        tmp___3 = ferror(out);
        }
        }
#line 701
        if (tmp___3) {
          {
          {
#line 702
          fclose(in);
          }
          {
#line 703
          fclose(out);
          }
          }
#line 704
          return (-1);
        }
      }
      {
      {
#line 706
      tmp___4 = fclose(in);
      }
      }
#line 706
      if (tmp___4 == -1) {
        {
        {
#line 707
        fclose(out);
        }
        }
#line 708
        return (-1);
      }
      {
      {
#line 710
      tmp___5 = fclose(out);
      }
      }
#line 710
      if (tmp___5 == -1) {
#line 711
        return (-1);
      }
      {
      {
#line 713
      tmp___6 = unlink(oldpath);
      }
      }
#line 713
      if (tmp___6 == -1) {
#line 714
        return (-1);
      }
    } else {
#line 716
      return (-1);
    }
  }
#line 720
  return (0);
}
}
#line 3 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/version.c"
char version[6]  = {      (char )'0',      (char )'.',      (char )'7',      (char )'.', 
        (char )'7',      (char )'\000'};
#line 157 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 411 "/usr/include/audiofile.h"
extern AFfilehandle afOpenFile(char const   *filename , char const   *mode , AFfilesetup setup ) ;
#line 123 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/volume.c"
__inline static double get_smoothed_data(datasmooth_t *s ) 
{ 
  int i ;
  double smoothed ;

  {
#line 130
  smoothed = (double )0;
#line 131
  i = 0;
  {
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < s->n)) {
#line 131
      goto while_break;
    }
#line 132
    smoothed += *(s->buf + i);
#line 131
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  smoothed /= (double )s->n;
#line 135
  return (smoothed);
}
}
#line 143 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/volume.c"
double signal_max_power(char *filename , struct signal_info *si ) 
{ 
  AFfilehandle fhin ;
  AFframecount framecount ;
  int samp_fmt ;
  int samp_width ;
  int bytes_per_sample ;
  int framesz ;
  int frames_recvd ;
  int last_window ;
  unsigned int windowsz ;
  unsigned int win_start ;
  unsigned int old_start ;
  unsigned int win_end ;
  unsigned int old_end ;
  int i ;
  int c ;
  int end ;
  int offset ;
  long sample ;
  long samplemax ;
  long samplemin ;
  double *sums ;
  double pow___0 ;
  double maxpow ;
  datasmooth_t *powsmooth ;
  unsigned char *data_buf ;
  float progress ;
  float last_progress ;
  char prefix_buf[18] ;
  double tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 160
  data_buf = (unsigned char *)((void *)0);
#line 162
  last_progress = (float )0.0;
  {
#line 178
  fhin = afOpenFile((char const   *)filename, "r", (AFfilesetup )((void *)0));
  }
  }
#line 179
  if ((unsigned long )fhin == (unsigned long )((struct _AFfilehandle *)0)) {
#line 180
    goto error1;
  }
  {
  {
#line 183
  afGetSampleFormat(fhin, 1001, & samp_fmt, & samp_width);
  }
  {
#line 184
  si->channels = afGetChannels(fhin, 1001);
  }
#line 185
  si->bits_per_sample = samp_width;
  {
#line 186
  tmp = afGetRate(fhin, 1001);
  }
#line 186
  si->samples_per_sec = (unsigned int )tmp;
  {
#line 189
  afSetVirtualSampleFormat(fhin, 1001, 401, samp_width);
  }
#line 191
  bytes_per_sample = (si->bits_per_sample - 1) / 8 + 1;
#line 192
  samplemax = (long )((1 << (bytes_per_sample * 8 - 1)) - 1);
#line 193
  samplemin = - samplemax - 1L;
  {
#line 194
  framecount = afGetFrameCount(fhin, 1001);
  }
#line 197
  si->max_sample = samplemin;
#line 198
  si->min_sample = samplemax;
  {
#line 208
  tmp___0 = xmalloc((size_t )((unsigned long )si->channels * sizeof(double )));
  }
#line 208
  sums = (double *)tmp___0;
#line 209
  c = 0;
  }
  {
  {
#line 209
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 209
    if (! (c < si->channels)) {
#line 209
      goto while_break;
    }
#line 210
    *(sums + c) = (double )0;
#line 209
    c ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  windowsz = si->samples_per_sec / 100U;
#line 217
  framesz = si->channels * bytes_per_sample;
#line 219
  if (bytes_per_sample == 3) {
#line 220
    framesz += si->channels;
  }
  {
  {
#line 221
  tmp___1 = xmalloc(windowsz * (unsigned int )framesz);
  }
#line 221
  data_buf = (unsigned char *)tmp___1;
  {
#line 224
  tmp___2 = xmalloc((size_t )((unsigned long )si->channels * sizeof(datasmooth_t )));
  }
#line 224
  powsmooth = (datasmooth_t *)tmp___2;
#line 225
  c = 0;
  }
  {
  {
#line 225
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 225
    if (! (c < si->channels)) {
#line 225
      goto while_break___0;
    }
    {
#line 226
    (powsmooth + c)->buflen = 100;
    {
#line 227
    tmp___3 = xmalloc((size_t )((unsigned long )(powsmooth + c)->buflen * sizeof(double )));
    }
#line 227
    (powsmooth + c)->buf = (double *)tmp___3;
#line 228
    tmp___4 = 0;
#line 228
    (powsmooth + c)->n = tmp___4;
#line 228
    (powsmooth + c)->start = tmp___4;
#line 225
    c ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  if (verbose >= 1) {
    {
    {
#line 233
    tmp___5 = basename(filename);
    }
    {
#line 233
    strncpy((char */* __restrict  */)(prefix_buf), (char const   */* __restrict  */)tmp___5,
            (size_t )17);
    }
#line 234
    prefix_buf[17] = (char )'\000';
    {
#line 235
    progress_callback(prefix_buf, (float )0.0);
    }
#line 236
    last_progress = (float )0.0;
    }
  }
#line 246
  win_start = 0U;
#line 246
  old_start = win_start;
#line 247
  win_end = 0U;
#line 248
  last_window = 0;
#line 249
  maxpow = 0.0;
  {
  {
#line 251
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 254
    old_end = win_end;
#line 255
    win_end = win_start + windowsz;
#line 256
    if ((AFframecount )win_end >= framecount) {
#line 257
      win_end = (unsigned int )framecount;
#line 258
      last_window = 1;
    }
    {
    {
#line 262
    frames_recvd = afReadFrames(fhin, 1001, (void *)data_buf, (int )windowsz);
    }
    }
#line 266
    if (frames_recvd == -1) {
#line 267
      goto error2;
    }
#line 268
    if (frames_recvd == 0) {
#line 269
      goto while_break___1;
    }
#line 275
    c = 0;
    {
    {
#line 275
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 275
      if (! (c < si->channels)) {
#line 275
        goto while_break___2;
      }
#line 276
      *(sums + c) = (double )0;
#line 277
      offset = c * (framesz / si->channels);
#line 278
      i = 0;
      {
      {
#line 278
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 278
        if (! ((unsigned int )i < win_end - win_start)) {
#line 278
          goto while_break___3;
        }
        {
        {
#line 279
        sample = get_sample(data_buf + offset, bytes_per_sample);
        }
#line 280
        offset += framesz;
#line 281
        *(sums + c) += (double )sample * (double )sample;
        }
#line 283
        if (sample > si->max_sample) {
#line 284
          si->max_sample = sample;
        }
#line 285
        if (sample < si->min_sample) {
#line 286
          si->min_sample = sample;
        }
#line 278
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 275
      c ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 291
    c = 0;
    {
    {
#line 291
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 291
      if (! (c < si->channels)) {
#line 291
        goto while_break___4;
      }
#line 292
      pow___0 = *(sums + c) / (double )(win_end - win_start);
#line 294
      end = ((powsmooth + c)->start + (powsmooth + c)->n) % (powsmooth + c)->buflen;
#line 295
      *((powsmooth + c)->buf + end) = pow___0;
#line 296
      if ((powsmooth + c)->n == (powsmooth + c)->buflen) {
        {
#line 297
        (powsmooth + c)->start = ((powsmooth + c)->start + 1) % (powsmooth + c)->buflen;
        {
#line 298
        pow___0 = get_smoothed_data(powsmooth + c);
        }
        }
#line 299
        if (pow___0 > maxpow) {
#line 300
          maxpow = pow___0;
        }
      } else {
#line 302
        ((powsmooth + c)->n) ++;
      }
#line 291
      c ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 307
    if (verbose >= 1) {
#line 308
      if (framecount - (AFframecount )windowsz == 0L) {
#line 309
        progress = (float )0;
      } else {
#line 311
        progress = (float )(win_end - windowsz) / (float )(framecount - (AFframecount )windowsz);
      }
#line 312
      if ((double )progress >= (double )last_progress + 0.01) {
        {
        {
#line 313
        progress_callback(prefix_buf, progress);
        }
#line 314
        last_progress = (float )((double )last_progress + 0.01);
        }
      }
    }
#line 319
    old_start = win_start;
#line 320
    win_start += windowsz;
#line 251
    if (! (! last_window)) {
#line 251
      goto while_break___1;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 328
  if (maxpow < 0.00000000001) {
#line 334
    c = 0;
    {
    {
#line 334
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 334
      if (! (c < si->channels)) {
#line 334
        goto while_break___5;
      }
      {
      {
#line 335
      pow___0 = get_smoothed_data(powsmooth + c);
      }
      }
#line 336
      if (pow___0 > maxpow) {
#line 337
        maxpow = pow___0;
      }
#line 334
      c ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 341
  c = 0;
  {
  {
#line 341
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 341
    if (! (c < si->channels)) {
#line 341
      goto while_break___6;
    }
    {
    {
#line 342
    free((void *)(powsmooth + c)->buf);
    }
#line 341
    c ++;
    }
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  {
#line 343
  free((void *)powsmooth);
  }
  {
#line 344
  free((void *)data_buf);
  }
  {
#line 345
  free((void *)sums);
  }
#line 348
  maxpow /= (double )samplemin * (double )samplemin;
  {
#line 351
  si->level = sqrt(maxpow);
  }
  }
#line 352
  if (- si->min_sample > si->max_sample) {
#line 353
    si->peak = (double )si->min_sample / (double )samplemin;
  } else {
#line 355
    si->peak = (double )si->max_sample / (double )samplemax;
  }
  {
  {
#line 357
  afCloseFile(fhin);
  }
  }
#line 359
  return (maxpow);
  error2: 
#line 363
  c = 0;
  {
  {
#line 363
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 363
    if (! (c < si->channels)) {
#line 363
      goto while_break___7;
    }
    {
    {
#line 364
    free((void *)(powsmooth + c)->buf);
    }
#line 363
    c ++;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
  {
#line 365
  free((void *)powsmooth);
  }
  {
#line 366
  free((void *)data_buf);
  }
  {
#line 367
  free((void *)sums);
  }
  {
#line 368
  afCloseFile(fhin);
  }
  }
  error1: 
#line 370
  return (- 1.0);
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 184
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 471
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 116
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 33 "./getopt.h"
extern char *optarg ;
#line 47
extern int optind ;
#line 108
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 87 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
void compute_levels(struct signal_info *sis , char **fnames , int nfiles ) ;
#line 88
double average_levels(struct signal_info *sis , int nlevels , double threshold___0 ) ;
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
char *progname  ;
#line 95 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
struct progress_struct progress_info  ;
#line 97 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
void usage_short(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 100
  tmp = gettext("Usage: %s [OPTION]... [FILE]...\n");
  }
  {
#line 100
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, progname);
  }
  {
#line 101
  tmp___0 = gettext("Try `%s --help\' for more information.\n");
  }
  {
#line 101
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          progname);
  }
  }
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
void usage(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 107
  tmp = gettext("Usage: %s [OPTION]... [FILE]...\nNormalize volume of multiple audio files\n\n  -a, --amplitude=AMP          normalize the volume to the target amplitude\n                                 AMP [default -12dBFS]\n  -b, --batch                  batch mode: get average of all levels, and\n                                 use one adjustment, based on the average\n                                 level, for all files\n      --clipping               turn off limiter; do clipping instead\n      --fractions              display levels as fractions of maximum\n                                 amplitude instead of decibels\n  -g, --gain=ADJ               don\'t compute levels, just apply adjustment\n                                 ADJ to the files.  Use the suffix \"dB\"\n                                 to indicate a gain in decibels.\n  -l, --limiter=LEV            limit all samples above LEV [default -6dBFS]\n  -m, --mix                    mix mode: get average of all levels, and\n                                 normalize volume of each file to the\n                                 average\n  -n, --no-adjust              compute and display the volume adjustment,\n                                 but don\'t apply it to any of the files\n      --peak                   adjust by peak level instead of using\n                                 loudness analysis\n  -q, --quiet                  quiet (decrease verbosity to zero)\n  -t, --average-threshold=T    when computing average level, ignore any\n                                 levels more than T decibels from average\n  -T, --adjust-threshold=T     don\'t bother applying any adjustment smaller\n                                 than T decibels\n  -v, --verbose                increase verbosity\n  -w, --output-bitwidth=W      force adjusted files to have W-bit samples\n\n  -V, --version                display version information and exit\n  -h, --help                   display this help and exit\n\nReport bugs to <chrisvaill@gmail.com>.\n");
  }
  {
#line 107
  printf((char const   */* __restrict  */)tmp, progname);
  }
  }
#line 142
  return;
}
}
#line 156 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int verbose  =    1;
#line 157 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int do_print_only  =    0;
#line 158 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int do_apply_gain  =    1;
#line 159 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
double target  =    0.2511886431509580;
#line 160 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
double threshold  =    - 1.0;
#line 161 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int do_compute_levels  =    1;
#line 162 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int output_bitwidth  =    0;
#line 163 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int gain_in_decibels  =    0;
#line 164 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int batch_mode  =    0;
#line 165 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int mix_mode  =    0;
#line 166 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int use_limiter  =    1;
#line 167 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int use_peak  =    0;
#line 168 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int use_fractions  =    0;
#line 169 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int show_progress  =    1;
#line 170 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int do_query  =    0;
#line 171 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int frontend  =    0;
#line 172 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
double lmtr_lvl  =    0.5;
#line 173 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
double adjust_thresh  =    0.125;
#line 174 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int id3_compat  =    0;
#line 175 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int id3_unsync  =    0;
#line 177 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int i ;
  int nfiles ;
  int ret ;
  struct signal_info *sis ;
  struct signal_info *psi ;
  double level ;
  double gain ;
  double dBdiff ;
  char **fnames ;
  char *p ;
  char cbuf[32] ;
  struct stat st ;
  int file_needs_adjust ;
  struct option longopts[25] ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  void *tmp___23 ;
  double tmp___24 ;
  char *tmp___25 ;
  double tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  double tmp___29 ;
  char *tmp___30 ;
  double tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  double tmp___36 ;
  double tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  double tmp___43 ;
  char *tmp___44 ;
  double tmp___45 ;
  double tmp___46 ;
  double tmp___47 ;
  char *tmp___48 ;
  double tmp___49 ;
  char *tmp___50 ;
  double tmp___51 ;
  double tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  void *__cil_tmp74 ;
  void *__cil_tmp75 ;
  int __cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;

  {
  {
#line 182
  level = 0.0;
#line 182
  gain = 1.0;
#line 182
  dBdiff = 0.0;
#line 186
  file_needs_adjust = 0;
#line 188
  longopts[0].name = "help";
#line 188
  longopts[0].has_arg = 0;
#line 188
  longopts[0].flag = (int *)((void *)0);
#line 188
  longopts[0].val = 'h';
#line 188
  longopts[1].name = "version";
#line 188
  longopts[1].has_arg = 0;
#line 188
  longopts[1].flag = (int *)((void *)0);
#line 188
  longopts[1].val = 'V';
#line 188
  longopts[2].name = "no-adjust";
#line 188
  longopts[2].has_arg = 0;
#line 188
  longopts[2].flag = (int *)((void *)0);
#line 188
  longopts[2].val = 'n';
#line 188
  longopts[3].name = "quiet";
#line 188
  longopts[3].has_arg = 0;
#line 188
  longopts[3].flag = (int *)((void *)0);
#line 188
  longopts[3].val = 'q';
#line 188
  longopts[4].name = "verbose";
#line 188
  longopts[4].has_arg = 0;
#line 188
  longopts[4].flag = (int *)((void *)0);
#line 188
  longopts[4].val = 'v';
#line 188
  longopts[5].name = "batch";
#line 188
  longopts[5].has_arg = 0;
#line 188
  longopts[5].flag = (int *)((void *)0);
#line 188
  longopts[5].val = 'b';
#line 188
  longopts[6].name = "amplitude";
#line 188
  longopts[6].has_arg = 1;
#line 188
  longopts[6].flag = (int *)((void *)0);
#line 188
  longopts[6].val = 'a';
#line 188
  longopts[7].name = "average-threshold";
#line 188
  longopts[7].has_arg = 1;
#line 188
  longopts[7].flag = (int *)((void *)0);
#line 188
  longopts[7].val = 't';
#line 188
  longopts[8].name = "threshold";
#line 188
  longopts[8].has_arg = 1;
#line 188
  longopts[8].flag = (int *)((void *)0);
#line 188
  longopts[8].val = 't';
#line 188
  longopts[9].name = "gain";
#line 188
  longopts[9].has_arg = 1;
#line 188
  longopts[9].flag = (int *)((void *)0);
#line 188
  longopts[9].val = 'g';
#line 188
  longopts[10].name = "limiter";
#line 188
  longopts[10].has_arg = 1;
#line 188
  longopts[10].flag = (int *)((void *)0);
#line 188
  longopts[10].val = 'l';
#line 188
  longopts[11].name = "adjust-threshold";
#line 188
  longopts[11].has_arg = 1;
#line 188
  longopts[11].flag = (int *)((void *)0);
#line 188
  longopts[11].val = 'T';
#line 188
  longopts[12].name = "mix";
#line 188
  longopts[12].has_arg = 0;
#line 188
  longopts[12].flag = (int *)((void *)0);
#line 188
  longopts[12].val = 'm';
#line 188
  longopts[13].name = "compression";
#line 188
  longopts[13].has_arg = 0;
#line 188
  longopts[13].flag = (int *)((void *)0);
#line 188
  longopts[13].val = 'c';
#line 188
  longopts[14].name = "limit";
#line 188
  longopts[14].has_arg = 0;
#line 188
  longopts[14].flag = (int *)((void *)0);
#line 188
  longopts[14].val = 'c';
#line 188
  longopts[15].name = "output-bitwidth";
#line 188
  longopts[15].has_arg = 1;
#line 188
  longopts[15].flag = (int *)((void *)0);
#line 188
  longopts[15].val = 'w';
#line 188
  longopts[16].name = "clipping";
#line 188
  longopts[16].has_arg = 0;
#line 188
  longopts[16].flag = (int *)((void *)0);
#line 188
  longopts[16].val = 257;
#line 188
  longopts[17].name = "peak";
#line 188
  longopts[17].has_arg = 0;
#line 188
  longopts[17].flag = (int *)((void *)0);
#line 188
  longopts[17].val = 258;
#line 188
  longopts[18].name = "fractions";
#line 188
  longopts[18].has_arg = 0;
#line 188
  longopts[18].flag = (int *)((void *)0);
#line 188
  longopts[18].val = 259;
#line 188
  longopts[19].name = "id3-compat";
#line 188
  longopts[19].has_arg = 0;
#line 188
  longopts[19].flag = (int *)((void *)0);
#line 188
  longopts[19].val = 260;
#line 188
  longopts[20].name = "id3-unsync";
#line 188
  longopts[20].has_arg = 0;
#line 188
  longopts[20].flag = (int *)((void *)0);
#line 188
  longopts[20].val = 261;
#line 188
  longopts[21].name = "no-progress";
#line 188
  longopts[21].has_arg = 0;
#line 188
  longopts[21].flag = (int *)((void *)0);
#line 188
  longopts[21].val = 262;
#line 188
  longopts[22].name = "query";
#line 188
  longopts[22].has_arg = 0;
#line 188
  longopts[22].flag = (int *)((void *)0);
#line 188
  longopts[22].val = 263;
#line 188
  longopts[23].name = "frontend";
#line 188
  longopts[23].has_arg = 0;
#line 188
  longopts[23].flag = (int *)((void *)0);
#line 188
  longopts[23].val = 264;
#line 188
  longopts[24].name = (char const   *)((void *)0);
#line 188
  longopts[24].has_arg = 0;
#line 188
  longopts[24].flag = (int *)((void *)0);
#line 188
  longopts[24].val = 0;
  {
#line 222
  progname = basename(*(argv + 0));
  }
  {
#line 223
  tmp = strlen((char const   *)progname);
  }
  }
#line 223
  if (tmp > 16U) {
#line 224
    *(progname + 16) = (char )'\000';
  }
  {
  {
#line 227
  setlocale(6, "");
  }
  {
#line 228
  bindtextdomain("normalize", "/usr/local/share/locale");
  }
  {
#line 229
  textdomain("normalize");
  }
  }
  {
  {
#line 233
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 233
    c = getopt_long(argc, (char * const  *)argv, "hVnvqbmcT:l:g:a:t:w:", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
    }
#line 233
    if (! (c != -1)) {
#line 233
      goto while_break;
    }
    {
#line 235
    if (c == 97) {
#line 235
      goto case_97;
    }
#line 262
    if (c == 116) {
#line 262
      goto case_116;
    }
#line 266
    if (c == 103) {
#line 266
      goto case_103;
    }
#line 286
    if (c == 110) {
#line 286
      goto case_110;
    }
#line 290
    if (c == 98) {
#line 290
      goto case_98;
    }
#line 293
    if (c == 109) {
#line 293
      goto case_109;
    }
#line 296
    if (c == 99) {
#line 296
      goto case_99;
    }
#line 300
    if (c == 108) {
#line 300
      goto case_108;
    }
#line 319
    if (c == 84) {
#line 319
      goto case_84;
    }
#line 328
    if (c == 119) {
#line 328
      goto case_119;
    }
#line 331
    if (c == 257) {
#line 331
      goto case_257;
    }
#line 334
    if (c == 258) {
#line 334
      goto case_258;
    }
#line 338
    if (c == 259) {
#line 338
      goto case_259;
    }
#line 341
    if (c == 260) {
#line 341
      goto case_260;
    }
#line 344
    if (c == 261) {
#line 344
      goto case_261;
    }
#line 347
    if (c == 262) {
#line 347
      goto case_262;
    }
#line 350
    if (c == 263) {
#line 350
      goto case_263;
    }
#line 355
    if (c == 264) {
#line 355
      goto case_264;
    }
#line 359
    if (c == 118) {
#line 359
      goto case_118;
    }
#line 362
    if (c == 113) {
#line 362
      goto case_113;
    }
#line 365
    if (c == 86) {
#line 365
      goto case_86;
    }
#line 381
    if (c == 104) {
#line 381
      goto case_104;
    }
#line 384
    goto switch_default;
    case_97: /* CIL Label */ 
    {
    {
#line 236
    target = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p));
    }
    }
    {
    {
#line 239
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 239
      tmp___0 = __ctype_b_loc();
      }
      }
#line 239
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 239
        goto while_break___0;
      }
#line 240
      p ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 241
    tmp___3 = strncaseeq((char const   *)p, "db", (size_t )2);
    }
    }
#line 241
    if (tmp___3) {
#line 244
      if (target > (double )0) {
        {
#line 245
        target = - target;
        {
#line 246
        tmp___1 = gettext("%s: normalizing to %f dBFS\n");
        }
        {
#line 246
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                progname, target);
        }
        }
      }
      {
      {
#line 250
      target = pow((double )10, target / 20.0);
      }
      }
    } else
#line 255
    if (target < (double )0) {
      {
      {
#line 256
      tmp___2 = gettext("%s: error: bad target amplitude %f\n");
      }
      {
#line 256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              progname, target);
      }
      {
#line 258
      exit(1);
      }
      }
    } else
#line 255
    if (target > 1.0) {
      {
      {
#line 256
      tmp___2 = gettext("%s: error: bad target amplitude %f\n");
      }
      {
#line 256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
              progname, target);
      }
      {
#line 258
      exit(1);
      }
      }
    }
#line 261
    goto switch_break;
    case_116: /* CIL Label */ 
    {
    {
#line 264
    threshold = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0));
    }
    }
#line 265
    goto switch_break;
    case_103: /* CIL Label */ 
    {
    {
#line 267
    gain = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p));
    }
    }
    {
    {
#line 270
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 270
      tmp___4 = __ctype_b_loc();
      }
      }
#line 270
      if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 270
        goto while_break___1;
      }
#line 271
      p ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 272
    tmp___5 = strncaseeq((char const   *)p, "db", (size_t )2);
    }
    }
#line 272
    if (tmp___5) {
      {
#line 273
      dBdiff = gain;
      {
#line 274
      gain = pow((double )10, dBdiff / 20.0);
      }
#line 275
      gain_in_decibels = 1;
      }
    }
#line 278
    do_compute_levels = 0;
#line 279
    batch_mode = 1;
#line 280
    if (gain < (double )0) {
      {
      {
#line 281
      tmp___6 = gettext("%s: invalid argument to -g option\n");
      }
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
              progname);
      }
      {
#line 282
      usage_short();
      }
      {
#line 283
      exit(1);
      }
      }
    }
#line 285
    goto switch_break;
    case_110: /* CIL Label */ 
#line 287
    do_print_only = 1;
#line 288
    do_apply_gain = 0;
#line 289
    goto switch_break;
    case_98: /* CIL Label */ 
#line 291
    batch_mode = 1;
#line 292
    goto switch_break;
    case_109: /* CIL Label */ 
#line 294
    mix_mode = 1;
#line 295
    goto switch_break;
    case_99: /* CIL Label */ 
    {
    {
#line 297
    tmp___7 = gettext("%s: Warning: the -c option is deprecated, and may be removed in v1.0\n");
    }
    {
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            progname);
    }
    }
#line 299
    goto switch_break;
    case_108: /* CIL Label */ 
    {
    {
#line 301
    lmtr_lvl = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p));
    }
    }
    {
    {
#line 303
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 303
      tmp___8 = __ctype_b_loc();
      }
      }
#line 303
      if (! ((int const   )*(*tmp___8 + (int )*p) & 8192)) {
#line 303
        goto while_break___2;
      }
#line 304
      p ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 306
    tmp___9 = strncaseeq((char const   *)p, "db", (size_t )2);
    }
    }
#line 306
    if (tmp___9) {
#line 307
      if (lmtr_lvl > (double )0) {
#line 308
        lmtr_lvl = - lmtr_lvl;
      }
      {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%f dB\n",
              lmtr_lvl);
      }
      {
#line 310
      lmtr_lvl = pow((double )10, lmtr_lvl / 20.0);
      }
      }
    } else {
#line 312
      if (lmtr_lvl < (double )0) {
#line 313
        lmtr_lvl = - lmtr_lvl;
      }
      {
      {
#line 314
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%f\n",
              lmtr_lvl);
      }
      }
    }
#line 317
    use_limiter = 1;
#line 318
    goto switch_break;
    case_84: /* CIL Label */ 
    {
    {
#line 320
    adjust_thresh = strtod((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& p));
    }
    }
#line 321
    if (adjust_thresh < (double )0) {
#line 322
      adjust_thresh = - adjust_thresh;
    }
#line 327
    goto switch_break;
    case_119: /* CIL Label */ 
    {
    {
#line 329
    tmp___10 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
    }
#line 329
    output_bitwidth = (int )tmp___10;
    }
#line 330
    goto switch_break;
    case_257: /* CIL Label */ 
#line 332
    use_limiter = 0;
#line 333
    goto switch_break;
    case_258: /* CIL Label */ 
#line 335
    use_peak = 1;
#line 336
    use_limiter = 0;
#line 337
    goto switch_break;
    case_259: /* CIL Label */ 
#line 339
    use_fractions = 1;
#line 340
    goto switch_break;
    case_260: /* CIL Label */ 
#line 342
    id3_compat = 1;
#line 343
    goto switch_break;
    case_261: /* CIL Label */ 
#line 345
    id3_unsync = 1;
#line 346
    goto switch_break;
    case_262: /* CIL Label */ 
#line 348
    show_progress = 0;
#line 349
    goto switch_break;
    case_263: /* CIL Label */ 
#line 353
    do_query = 1;
#line 354
    goto switch_break;
    case_264: /* CIL Label */ 
#line 356
    frontend = 1;
#line 357
    verbose = 0;
#line 358
    goto switch_break;
    case_118: /* CIL Label */ 
#line 360
    verbose ++;
#line 361
    goto switch_break;
    case_113: /* CIL Label */ 
#line 363
    verbose = 0;
#line 364
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 366
    printf((char const   */* __restrict  */)"normalize %s\n", version);
    }
    {
#line 367
    tmp___11 = gettext("Copyright (C) 2005 Chris Vaill\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
    }
    {
#line 367
    printf((char const   */* __restrict  */)tmp___11);
    }
    {
#line 372
    tmp___12 = gettext("This copy of normalize is compiled with the following libraries:\n");
    }
    {
#line 372
    printf((char const   */* __restrict  */)tmp___12);
    }
    {
#line 377
    printf((char const   */* __restrict  */)"  audiofile");
    }
    {
#line 379
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 380
    exit(0);
    }
    }
    case_104: /* CIL Label */ 
    {
    {
#line 382
    usage();
    }
    {
#line 383
    exit(0);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 385
    usage_short();
    }
    {
#line 386
    exit(1);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (output_bitwidth < 0) {
    {
    {
#line 390
    tmp___13 = gettext("%s: error: output bitwidth must be between 1 and 32\n");
    }
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
            progname);
    }
    {
#line 392
    exit(1);
    }
    }
  } else
#line 389
  if (output_bitwidth > 32) {
    {
    {
#line 390
    tmp___13 = gettext("%s: error: output bitwidth must be between 1 and 32\n");
    }
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13,
            progname);
    }
    {
#line 392
    exit(1);
    }
    }
  }
#line 394
  if (mix_mode) {
#line 394
    if (batch_mode) {
      {
      {
#line 395
      tmp___14 = gettext("%s: error: the -m and -b options are mutually exclusive\n");
      }
      {
#line 395
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
              progname);
      }
      {
#line 398
      exit(1);
      }
      }
    }
  }
#line 400
  if (use_peak) {
#line 400
    if (mix_mode) {
      {
      {
#line 401
      tmp___15 = gettext("%s: error: -m and -b can\'t be used with the --peak option\n");
      }
      {
#line 401
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              progname);
      }
      {
#line 404
      exit(1);
      }
      }
    } else
#line 400
    if (batch_mode) {
      {
      {
#line 401
      tmp___15 = gettext("%s: error: -m and -b can\'t be used with the --peak option\n");
      }
      {
#line 401
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
              progname);
      }
      {
#line 404
      exit(1);
      }
      }
    }
  }
#line 406
  if (optind >= argc) {
    {
    {
#line 407
    usage_short();
    }
    {
#line 408
    exit(1);
    }
    }
  }
  {
#line 415
  nfiles = 0;
#line 416
  progress_info.batch_size = (off_t )0;
  {
#line 417
  tmp___16 = xmalloc((size_t )((unsigned long )(argc - optind) * sizeof(char *)));
  }
#line 417
  fnames = (char **)tmp___16;
  {
#line 418
  tmp___17 = xmalloc((size_t )((unsigned long )(argc - optind) * sizeof(off_t )));
  }
#line 418
  progress_info.file_sizes = (off_t *)tmp___17;
#line 419
  i = optind;
  }
  {
  {
#line 419
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 419
    if (! (i < argc)) {
#line 419
      goto while_break___3;
    }
    {
    {
#line 430
    tmp___21 = stat((char const   */* __restrict  */)*(argv + i), (struct stat */* __restrict  */)(& st));
    }
    }
#line 430
    if (tmp___21 == -1) {
      {
      {
#line 431
      tmp___18 = __errno_location();
      }
      {
#line 431
      tmp___19 = strerror(*tmp___18);
      }
      {
#line 431
      tmp___20 = gettext("%s: file %s: %s\n");
      }
      {
#line 431
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
              progname, *(argv + i), tmp___19);
      }
      }
    } else {
#line 435
      *(progress_info.file_sizes + nfiles) = (st.st_size + 1023L) / 1024L;
#line 437
      progress_info.batch_size += *(progress_info.file_sizes + nfiles);
#line 438
      *(fnames + nfiles) = *(argv + i);
#line 439
      nfiles ++;
    }
#line 419
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 442
  if (nfiles == 0) {
    {
    {
#line 443
    tmp___22 = gettext("%s: no files!\n");
    }
    {
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
            progname);
    }
    }
#line 444
    return (1);
  }
  {
  {
#line 448
  tmp___23 = xmalloc((size_t )((unsigned long )nfiles * sizeof(struct signal_info )));
  }
#line 448
  sis = (struct signal_info *)tmp___23;
#line 449
  i = 0;
  }
  {
  {
#line 449
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 449
    if (! (i < nfiles)) {
#line 449
      goto while_break___4;
    }
#line 450
    (sis + i)->file_size = *(progress_info.file_sizes + i);
#line 451
    (sis + i)->orig_index = i;
#line 449
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 454
  if (frontend) {
    {
    {
#line 456
    printf((char const   */* __restrict  */)"NUMFILES %d\n", nfiles);
    }
#line 458
    i = 0;
    }
    {
    {
#line 458
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 458
      if (! (i < nfiles)) {
#line 458
        goto while_break___5;
      }
      {
      {
#line 459
      printf((char const   */* __restrict  */)"FILE %d %s\n", i, *(fnames + i));
      }
#line 458
      i ++;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 465
  if (do_compute_levels) {
    {
    {
#line 466
    compute_levels(sis, fnames, nfiles);
    }
#line 469
    i = 0;
    }
    {
    {
#line 469
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 469
      if (! (i < nfiles)) {
#line 469
        goto while_break___6;
      }
#line 470
      if ((sis + i)->level < (double )0) {
        {
#line 471
        nfiles --;
        {
#line 472
        memmove((void *)(sis + i), (void const   *)((sis + i) + 1), (size_t )((unsigned long )(nfiles - i) * sizeof(struct signal_info )));
        }
        {
#line 474
        memmove((void *)(fnames + i), (void const   *)((fnames + i) + 1), (size_t )((unsigned long )(nfiles - i) * sizeof(char *)));
        }
        {
#line 476
        memmove((void *)(progress_info.file_sizes + i), (void const   *)((progress_info.file_sizes + i) + 1),
                (size_t )((unsigned long )(nfiles - i) * sizeof(off_t )));
        }
        }
      }
#line 469
      i ++;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 481
    if (batch_mode) {
#line 481
      goto _L;
    } else
#line 481
    if (mix_mode) {
      _L: /* CIL Label */ 
      {
      {
#line 482
      level = average_levels(sis, nfiles, threshold);
      }
      }
#line 485
      if (mix_mode) {
#line 486
        target = level;
      }
#line 489
      if (batch_mode) {
#line 490
        gain = target / level;
      }
#line 493
      if (frontend) {
        {
        {
#line 494
        tmp___24 = log10(level);
        }
        {
#line 494
        printf((char const   */* __restrict  */)"AVERAGE_LEVEL %f\n", (double )20 * tmp___24);
        }
        }
      }
#line 496
      if (do_print_only) {
#line 497
        if (! mix_mode) {
#line 498
          if (use_fractions) {
            {
            {
#line 499
            tmp___25 = gettext("%-12.6f average level\n");
            }
            {
#line 499
            printf((char const   */* __restrict  */)tmp___25, level);
            }
            }
          } else {
            {
            {
#line 501
            tmp___26 = log10(level);
            }
            {
#line 501
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdBFS",
                    (double )20 * tmp___26);
            }
            {
#line 502
            tmp___27 = gettext("%-12s average level\n");
            }
            {
#line 502
            printf((char const   */* __restrict  */)tmp___27, cbuf);
            }
            }
          }
        }
      } else
#line 505
      if (verbose >= 2) {
#line 506
        if (use_fractions) {
          {
          {
#line 507
          tmp___28 = gettext("Average level: %0.4f\n");
          }
          {
#line 507
          printf((char const   */* __restrict  */)tmp___28, level);
          }
          }
        } else {
          {
          {
#line 509
          tmp___29 = log10(level);
          }
          {
#line 509
          tmp___30 = gettext("Average level: %0.4fdBFS\n");
          }
          {
#line 509
          printf((char const   */* __restrict  */)tmp___30, (double )20 * tmp___29);
          }
          }
        }
      }
    }
  }
#line 537
  if (batch_mode) {
#line 539
    if (! gain_in_decibels) {
      {
      {
#line 540
      tmp___31 = log10(gain);
      }
#line 540
      dBdiff = (double )20 * tmp___31;
      }
    }
  }
#line 547
  if (do_apply_gain) {
#line 550
    if (batch_mode) {
#line 550
      if (verbose >= 1) {
#line 552
        if (do_compute_levels) {
          {
          {
#line 552
          tmp___36 = fabs(dBdiff);
          }
          }
#line 552
          if (tmp___36 < adjust_thresh) {
            {
            {
#line 553
            tmp___32 = gettext("Files are already normalized, not adjusting...");
            }
            {
#line 553
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___32);
            }
            }
          } else {
#line 552
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 555
        if (! do_compute_levels) {
#line 556
          if (gain_in_decibels) {
            {
            {
#line 557
            tmp___33 = gettext("Applying adjustment of %fdB...\n");
            }
            {
#line 557
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___33,
                    dBdiff);
            }
            }
          } else {
            {
            {
#line 559
            tmp___34 = gettext("Applying adjustment of %f...\n");
            }
            {
#line 559
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___34,
                    gain);
            }
            }
          }
        } else
#line 560
        if (do_apply_gain) {
          {
          {
#line 561
          tmp___35 = gettext("Applying adjustment of %0.2fdB...\n");
          }
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___35,
                  dBdiff);
          }
          }
        }
      }
    }
    {
    {
#line 566
    progress_info.batch_start = time((time_t *)((void *)0));
    }
#line 567
    progress_info.finished_size = (off_t )0;
#line 569
    i = 0;
    }
    {
    {
#line 569
    while (1) {
      while_continue___18: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 569
      if (! (i < nfiles)) {
#line 569
        goto while_break___7;
      }
#line 571
      if (! batch_mode) {
#line 572
        if (use_peak) {
#line 573
          gain = 1.0 / (sis + i)->peak;
        } else {
#line 575
          gain = target / (sis + i)->level;
        }
      }
#line 579
      if (frontend) {
        {
        {
#line 580
        tmp___37 = log10(gain);
        }
        {
#line 580
        printf((char const   */* __restrict  */)"ADJUSTING %d %f\n", (sis + i)->orig_index,
               (double )20 * tmp___37);
        }
        }
      }
      {
      {
#line 582
      progress_info.file_start = time((time_t *)((void *)0));
      }
#line 583
      progress_info.on_file = i;
      }
#line 585
      if (do_compute_levels) {
#line 585
        psi = sis + i;
      } else {
#line 585
        psi = (struct signal_info *)((void *)0);
      }
      {
      {
#line 586
      ret = apply_gain(*(fnames + i), gain, psi);
      }
      }
#line 587
      if (ret == -1) {
        {
        {
#line 588
        tmp___38 = __errno_location();
        }
        {
#line 588
        tmp___39 = strerror(*tmp___38);
        }
        {
#line 588
        tmp___40 = gettext("%s: error applying adjustment to %s: %s\n");
        }
        {
#line 588
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___40,
                progname, *(fnames + i), tmp___39);
        }
        }
      } else {
#line 591
        if (ret == 0) {
#line 593
          if (! batch_mode) {
#line 594
            if (verbose >= 1) {
              {
              {
#line 595
              tmp___41 = gettext("%s already normalized, not adjusting...");
              }
              {
#line 595
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___41,
                      *(fnames + i));
              }
              }
            }
          }
        } else {
#line 600
          file_needs_adjust = 1;
        }
#line 603
        if (frontend) {
          {
          {
#line 604
          printf((char const   */* __restrict  */)"ADJUSTED %d %d\n", (sis + i)->orig_index,
                 ret);
          }
          }
        }
      }
#line 607
      progress_info.finished_size += *(progress_info.file_sizes + i);
#line 609
      if (verbose >= 1) {
#line 609
        if (! batch_mode) {
          {
          {
#line 610
          fputc('\n', stderr);
          }
          }
        }
      }
#line 569
      i ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 614
    if (verbose >= 1) {
#line 614
      if (batch_mode) {
        {
        {
#line 615
        fputc('\n', stderr);
        }
        }
      }
    }
  } else {
#line 619
    if (batch_mode) {
#line 619
      if (do_print_only) {
#line 622
        if (use_fractions) {
          {
          {
#line 623
          tmp___42 = gettext("%-12f volume adjustment\n");
          }
          {
#line 623
          printf((char const   */* __restrict  */)tmp___42, gain);
          }
          }
        } else {
          {
          {
#line 625
          tmp___43 = log10(gain);
          }
          {
#line 625
          sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%fdB",
                  (double )20 * tmp___43);
          }
          {
#line 626
          tmp___44 = gettext("%-12s volume adjustment\n");
          }
          {
#line 626
          printf((char const   */* __restrict  */)tmp___44, cbuf);
          }
          }
        }
      } else {
#line 619
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 629
    if (mix_mode) {
#line 629
      if (do_print_only) {
#line 636
        if (verbose >= 1) {
#line 636
          if (show_progress) {
            {
            {
#line 637
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r");
            }
            }
          }
        }
#line 640
        i = 0;
        {
        {
#line 640
        while (1) {
          while_continue___19: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
#line 640
          if (! (i < nfiles)) {
#line 640
            goto while_break___8;
          }
#line 641
          if (use_fractions) {
            {
            {
#line 642
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.6f",
                    (sis + i)->level);
            }
            {
#line 643
            printf((char const   */* __restrict  */)"%-12s ", cbuf);
            }
            {
#line 644
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.6f",
                    (sis + i)->peak);
            }
            {
#line 645
            printf((char const   */* __restrict  */)"%-12s ", cbuf);
            }
            {
#line 646
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.6f",
                    target / (sis + i)->level);
            }
            {
#line 647
            printf((char const   */* __restrict  */)"%-10s ", cbuf);
            }
            }
          } else {
            {
            {
#line 649
            tmp___45 = log10((sis + i)->level);
            }
            {
#line 649
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdBFS",
                    (double )20 * tmp___45);
            }
            {
#line 650
            printf((char const   */* __restrict  */)"%-12s ", cbuf);
            }
            {
#line 651
            tmp___46 = log10((sis + i)->peak);
            }
            {
#line 651
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdBFS",
                    (double )20 * tmp___46);
            }
            {
#line 652
            printf((char const   */* __restrict  */)"%-12s ", cbuf);
            }
            {
#line 653
            tmp___47 = log10(target / (sis + i)->level);
            }
            {
#line 653
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdB",
                    (double )20 * tmp___47);
            }
            {
#line 654
            printf((char const   */* __restrict  */)"%-10s ", cbuf);
            }
            }
          }
          {
          {
#line 656
          printf((char const   */* __restrict  */)"%s\n", *(fnames + i));
          }
#line 640
          i ++;
          }
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 658
        if (use_fractions) {
          {
          {
#line 659
          tmp___48 = gettext("%-12.6f average level\n");
          }
          {
#line 659
          printf((char const   */* __restrict  */)tmp___48, level);
          }
          }
        } else {
          {
          {
#line 661
          tmp___49 = log10(level);
          }
          {
#line 661
          sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdBFS",
                  (double )20 * tmp___49);
          }
          {
#line 662
          tmp___50 = gettext("%-12s average level\n");
          }
          {
#line 662
          printf((char const   */* __restrict  */)tmp___50, cbuf);
          }
          }
        }
      }
    }
#line 671
    i = 0;
    {
    {
#line 671
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 671
      if (! (i < nfiles)) {
#line 671
        goto while_break___9;
      }
#line 672
      if (use_peak) {
#line 673
        gain = 1.0 / (sis + i)->peak;
      } else {
#line 675
        gain = target / (sis + i)->level;
      }
      {
      {
#line 676
      tmp___51 = log10(gain);
      }
#line 676
      dBdiff = (double )20 * tmp___51;
      {
#line 678
      tmp___52 = fabs(dBdiff);
      }
      }
#line 678
      if (tmp___52 >= adjust_thresh) {
#line 679
        file_needs_adjust = 1;
#line 680
        goto while_break___9;
      }
#line 671
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
  {
#line 686
  free((void *)sis);
  }
  {
#line 687
  free((void *)progress_info.file_sizes);
  }
  {
#line 688
  free((void *)fnames);
  }
  }
#line 700
  if (frontend) {
#line 701
    if (file_needs_adjust) {
#line 701
      tmp___53 = 1;
    } else {
#line 701
      tmp___53 = 0;
    }
    {
    {
#line 701
    printf((char const   */* __restrict  */)"ADJUST_NEEDED %d\n", tmp___53);
    }
    }
  }
#line 705
  if (do_query) {
#line 706
    if (file_needs_adjust) {
#line 706
      tmp___54 = 0;
    } else {
#line 706
      tmp___54 = 2;
    }
#line 706
    return (tmp___54);
  }
#line 708
  return (0);
}
}
#line 714 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
void compute_levels(struct signal_info *sis , char **fnames , int nfiles ) 
{ 
  double power ;
  int i ;
  char cbuf[32] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  double tmp___7 ;
  char *tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  char *tmp___15 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
#line 722
  if (verbose >= 1) {
    {
    {
#line 723
    tmp = gettext("Computing levels...\n");
    }
    {
#line 723
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
    }
#line 725
    if (do_print_only) {
#line 726
      if (batch_mode) {
        {
        {
#line 727
        tmp___0 = gettext("  level        peak\n");
        }
        {
#line 727
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
        }
        }
      } else {
        {
        {
#line 729
        tmp___1 = gettext("  level        peak         gain\n");
        }
        {
#line 729
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
        }
        }
      }
    }
  }
  {
  {
#line 733
  progress_info.batch_start = time((time_t *)((void *)0));
  }
#line 734
  progress_info.finished_size = (off_t )0;
#line 736
  i = 0;
  }
  {
  {
#line 736
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 736
    if (! (i < nfiles)) {
#line 736
      goto while_break;
    }
#line 739
    if (frontend) {
      {
      {
#line 740
      printf((char const   */* __restrict  */)"ANALYZING %d\n", i);
      }
      }
    }
    {
#line 742
    (sis + i)->level = (double )0;
    {
#line 760
    progress_info.file_start = time((time_t *)((void *)0));
    }
#line 761
    progress_info.on_file = i;
    {
#line 762
    tmp___2 = __errno_location();
    }
#line 762
    *tmp___2 = 0;
    {
#line 764
    power = signal_max_power(*(fnames + i), sis + i);
    }
    }
#line 769
    if (power < (double )0) {
      {
      {
#line 770
      tmp___3 = gettext("%s: error reading %s");
      }
      {
#line 770
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              progname, *(fnames + i));
      }
      {
#line 771
      tmp___6 = __errno_location();
      }
      }
#line 771
      if (*tmp___6) {
        {
        {
#line 772
        tmp___4 = __errno_location();
        }
        {
#line 772
        tmp___5 = strerror(*tmp___4);
        }
        {
#line 772
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
                tmp___5);
        }
        }
      } else {
        {
        {
#line 774
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
        }
      }
#line 775
      (sis + i)->level = (double )-1;
#line 776
      goto error_update_progress;
    }
#line 779
    if (frontend) {
      {
      {
#line 780
      tmp___7 = log10((sis + i)->level);
      }
      {
#line 780
      printf((char const   */* __restrict  */)"LEVEL %d %f\n", i, (double )20 * tmp___7);
      }
      }
    }
#line 781
    if (power < 0.00000000001) {
#line 782
      if (verbose >= 1) {
#line 783
        if (show_progress) {
          {
          {
#line 784
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r");
          }
          }
        }
        {
        {
#line 787
        tmp___8 = gettext("File %s has zero power, ignoring...\n");
        }
        {
#line 787
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
                *(fnames + i));
        }
        }
      }
#line 790
      (sis + i)->level = (double )-1;
#line 791
      goto error_update_progress;
    }
#line 794
    if (do_print_only) {
#line 797
      if (! mix_mode) {
#line 800
        if (verbose >= 1) {
#line 800
          if (show_progress) {
            {
            {
#line 801
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r");
            }
            }
          }
        }
#line 805
        if (use_fractions) {
          {
          {
#line 806
          sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.6f",
                  (sis + i)->level);
          }
          {
#line 807
          printf((char const   */* __restrict  */)"%-12s ", cbuf);
          }
          {
#line 808
          sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.6f",
                  (sis + i)->peak);
          }
          {
#line 809
          printf((char const   */* __restrict  */)"%-12s ", cbuf);
          }
          }
        } else {
          {
          {
#line 811
          tmp___9 = log10((sis + i)->level);
          }
          {
#line 811
          sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdBFS",
                  (double )20 * tmp___9);
          }
          {
#line 812
          printf((char const   */* __restrict  */)"%-12s ", cbuf);
          }
          {
#line 813
          tmp___10 = log10((sis + i)->peak);
          }
          {
#line 813
          sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdBFS",
                  (double )20 * tmp___10);
          }
          {
#line 814
          printf((char const   */* __restrict  */)"%-12s ", cbuf);
          }
          }
        }
#line 816
        if (! batch_mode) {
#line 817
          if (use_fractions) {
            {
            {
#line 818
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.6f",
                    target / (sis + i)->level);
            }
            }
          } else {
            {
            {
#line 820
            tmp___11 = log10(target / (sis + i)->level);
            }
            {
#line 820
            sprintf((char */* __restrict  */)(cbuf), (char const   */* __restrict  */)"%0.4fdB",
                    (double )20 * tmp___11);
            }
            }
          }
          {
          {
#line 821
          printf((char const   */* __restrict  */)"%-10s ", cbuf);
          }
          }
        }
        {
        {
#line 823
        printf((char const   */* __restrict  */)"%s\n", *(fnames + i));
        }
        }
      }
    } else
#line 826
    if (verbose >= 2) {
#line 827
      if (show_progress) {
        {
        {
#line 828
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                                                                          \r");
        }
        }
      }
#line 831
      if (use_fractions) {
        {
        {
#line 832
        tmp___12 = gettext("Level for %s: %0.4f (%0.4f peak)\n");
        }
        {
#line 832
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                *(fnames + i), (sis + i)->level, (sis + i)->peak);
        }
        }
      } else {
        {
        {
#line 835
        tmp___13 = log10((sis + i)->peak);
        }
        {
#line 835
        tmp___14 = log10((sis + i)->level);
        }
        {
#line 835
        tmp___15 = gettext("Level for %s: %0.4fdBFS (%0.4fdBFS peak)\n");
        }
        {
#line 835
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
                *(fnames + i), (double )20 * tmp___14, (double )20 * tmp___13);
        }
        }
      }
    }
    error_update_progress: 
#line 840
    progress_info.finished_size += *(progress_info.file_sizes + i);
#line 736
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (verbose == 1) {
#line 845
    if (! do_print_only) {
      {
      {
#line 846
      fputc('\n', stderr);
      }
      }
    }
  }
#line 847
  return;
}
}
#line 854 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
double average_levels(struct signal_info *sis , int nlevels , double threshold___0 ) 
{ 
  int i ;
  int files_to_avg ;
  double sum ;
  double level_difference ;
  double std_dev ;
  double variance ;
  double level ;
  double mean_level ;
  char *badlevels ;
  void *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  double tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 863
  tmp = xmalloc((size_t )((unsigned long )nlevels * sizeof(char )));
  }
#line 863
  badlevels = (char *)tmp;
  {
#line 864
  memset((void *)badlevels, 0, (size_t )((unsigned long )nlevels * sizeof(char )));
  }
#line 867
  sum = (double )0;
#line 868
  i = 0;
  }
  {
  {
#line 868
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 868
    if (! (i < nlevels)) {
#line 868
      goto while_break;
    }
#line 869
    sum += (sis + i)->level;
#line 868
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 870
  mean_level = sum / (double )nlevels;
#line 873
  if (threshold___0 < 0.0) {
#line 884
    sum = (double )0;
#line 885
    i = 0;
    {
    {
#line 885
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 885
      if (! (i < nlevels)) {
#line 885
        goto while_break___0;
      }
      {
      {
#line 886
      tmp___1 = log10((sis + i)->level / mean_level);
      }
#line 886
      tmp___0 = (double )20 * tmp___1;
#line 887
      sum += tmp___0 * tmp___0;
#line 885
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 889
    variance = sum / (double )nlevels;
#line 892
    if (variance < 0.00000000001) {
#line 893
      std_dev = 0.0;
    } else {
      {
      {
#line 895
      std_dev = sqrt(variance);
      }
      }
    }
#line 896
    if (verbose >= 2) {
      {
      {
#line 897
      tmp___2 = gettext("Standard deviation is %0.2f dB\n");
      }
      {
#line 897
      printf((char const   */* __restrict  */)tmp___2, std_dev);
      }
      }
    }
#line 899
    threshold___0 = (double )2 * std_dev;
  }
#line 907
  if (threshold___0 > 0.00000000001) {
#line 907
    if (nlevels > 1) {
#line 908
      i = 0;
      {
      {
#line 908
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 908
        if (! (i < nlevels)) {
#line 908
          goto while_break___1;
        }
        {
        {
#line 913
        tmp___3 = log10(mean_level / (sis + i)->level);
        }
        {
#line 913
        level_difference = fabs((double )20 * tmp___3);
        }
        }
#line 916
        if (level_difference > threshold___0) {
#line 919
          if (frontend) {
            {
            {
#line 920
            printf((char const   */* __restrict  */)"AVERAGE_EXCLUDES %d %f\n", (sis + i)->orig_index,
                   level_difference);
            }
            }
          }
#line 923
          if (verbose >= 2) {
#line 924
            if (use_fractions) {
              {
              {
#line 925
              tmp___4 = gettext("Throwing out level of %0.4f (different by %0.2fdB)\n");
              }
              {
#line 925
              printf((char const   */* __restrict  */)tmp___4, (sis + i)->level, level_difference);
              }
              }
            } else {
              {
              {
#line 928
              tmp___5 = log10((sis + i)->level);
              }
              {
#line 928
              tmp___6 = gettext("Throwing out level of %0.4fdBFS (different by %0.2fdB)\n");
              }
              {
#line 928
              printf((char const   */* __restrict  */)tmp___6, (double )20 * tmp___5,
                     level_difference);
              }
              }
            }
          }
#line 932
          *(badlevels + i) = (char)1;
        }
#line 908
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 938
  files_to_avg = 0;
#line 939
  sum = (double )0;
#line 940
  i = 0;
  {
  {
#line 940
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 940
    if (! (i < nlevels)) {
#line 940
      goto while_break___2;
    }
#line 941
    if (! *(badlevels + i)) {
#line 942
      sum += (sis + i)->level;
#line 943
      files_to_avg ++;
    }
#line 940
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 946
  if (files_to_avg == 0) {
    {
    {
#line 947
    tmp___7 = gettext("%s: all files ignored, try using -t 100\n");
    }
    {
#line 947
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            progname);
    }
    {
#line 948
    exit(1);
    }
    }
  }
  {
  {
#line 951
  free((void *)badlevels);
  }
#line 953
  level = sum / (double )files_to_avg;
  }
#line 955
  return (level);
}
}
#line 959 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
void progress_callback(char *prefix , float fraction_completed ) 
{ 
  char buf[128] ;
  time_t now ;
  time_t time_spent ;
  unsigned int file_eta_hr ;
  unsigned int file_eta_min ;
  unsigned int file_eta_sec ;
  off_t kb_done ;
  float batch_fraction ;
  unsigned int batch_eta_hr ;
  unsigned int batch_eta_min ;
  unsigned int batch_eta_sec ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 968
  batch_fraction = (float )0;
#line 971
  if (! show_progress) {
#line 972
    return;
  }
  {
  {
#line 974
  now = time((time_t *)((void *)0));
  }
  }
#line 976
  if ((double )fraction_completed > 1.0) {
#line 977
    fraction_completed = (float )1.0;
  }
#line 980
  file_eta_min = 0U;
#line 980
  file_eta_sec = file_eta_min;
#line 980
  file_eta_hr = file_eta_sec;
#line 981
  if ((double )fraction_completed > 0.0) {
#line 982
    time_spent = now - progress_info.file_start;
#line 983
    if ((double )fraction_completed == 0.0) {
#line 984
      file_eta_sec = 0U;
    } else {
#line 986
      file_eta_sec = (unsigned int )((double )((float )time_spent / fraction_completed - (float )time_spent) + 0.5);
    }
#line 989
    file_eta_min = file_eta_sec / 60U;
#line 990
    file_eta_sec %= 60U;
#line 991
    file_eta_hr = file_eta_min / 60U;
#line 992
    file_eta_min %= 60U;
#line 993
    if (file_eta_hr > 99U) {
#line 994
      file_eta_hr = 99U;
    }
  }
#line 999
  batch_eta_sec = 0U;
#line 999
  batch_eta_min = batch_eta_sec;
#line 999
  batch_eta_hr = batch_eta_min;
#line 1000
  if (progress_info.batch_size != 0L) {
#line 1001
    kb_done = (off_t )((float )progress_info.finished_size + fraction_completed * (float )*(progress_info.file_sizes + progress_info.on_file));
#line 1003
    batch_fraction = (float )kb_done / (float )progress_info.batch_size;
#line 1004
    time_spent = now - progress_info.batch_start;
#line 1005
    if (kb_done == 0L) {
#line 1006
      batch_eta_sec = 0U;
    } else {
#line 1008
      batch_eta_sec = (unsigned int )((double )((float )time_spent / batch_fraction - (float )time_spent) + 0.5);
    }
#line 1011
    batch_eta_min = batch_eta_sec / 60U;
#line 1012
    batch_eta_sec %= 60U;
#line 1013
    batch_eta_hr = batch_eta_min / 60U;
#line 1014
    batch_eta_min %= 60U;
#line 1015
    if (batch_eta_hr > 99U) {
#line 1016
      batch_eta_hr = 99U;
#line 1017
      batch_eta_min = 59U;
#line 1018
      batch_eta_sec = 59U;
    }
  }
#line 1024
  if ((double )fraction_completed <= 0.0) {
#line 1025
    if (progress_info.batch_size == 0L) {
      {
      {
#line 1027
      tmp = gettext(" %-17s  --%% done, ETA --:--:-- (batch  --%% done, ETA --:--:--)");
      }
      {
#line 1027
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp,
              prefix);
      }
      }
    } else {
      {
      {
#line 1030
      tmp___0 = gettext(" %-17s  --%% done, ETA --:--:-- (batch %3.0f%% done, ETA %02d:%02d:%02d)");
      }
      {
#line 1030
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___0,
              prefix, (double )(batch_fraction * (float )100), batch_eta_hr, batch_eta_min,
              batch_eta_sec);
      }
      }
    }
  } else {
    {
    {
#line 1037
    tmp___1 = gettext(" %-17s %3.0f%% done, ETA %02d:%02d:%02d (batch %3.0f%% done, ETA %02d:%02d:%02d)");
    }
    {
#line 1037
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___1,
            prefix, (double )(fraction_completed * (float )100), file_eta_hr, file_eta_min,
            file_eta_sec, (double )(batch_fraction * (float )100), batch_eta_hr, batch_eta_min,
            batch_eta_sec);
    }
    }
  }
  {
  {
#line 1045
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s \r",
          buf);
  }
  }
#line 1046
  return;
}
}
#line 1052 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
int strncaseeq(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 1055
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1055
    if (! (n > 0U)) {
#line 1055
      goto while_break;
    }
    {
#line 1056
    tmp = s1;
#line 1056
    s1 ++;
    {
#line 1056
    tmp___0 = tolower((int )*tmp);
    }
#line 1056
    tmp___1 = s2;
#line 1056
    s2 ++;
    {
#line 1056
    tmp___2 = tolower((int )*tmp___1);
    }
    }
#line 1056
    if (tmp___0 != tmp___2) {
#line 1057
      return (0);
    }
#line 1055
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  return (1);
}
}
#line 1067 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
char *basename(char *path ) 
{ 
  char *p ;

  {
  {
  {
#line 1071
  p = strrchr((char const   *)path, '/');
  }
  }
#line 1072
  if (p) {
#line 1073
    p ++;
  } else {
#line 1075
    p = path;
  }
#line 1076
  return (p);
}
}
#line 1079 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/normalize.c"
void *xmalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1082
  tmp = malloc(size);
  }
#line 1082
  ptr = tmp;
  }
#line 1083
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
    {
#line 1084
    tmp___0 = gettext("%s: unable to malloc\n");
    }
    {
#line 1084
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            progname);
    }
    {
#line 1085
    exit(1);
    }
    }
  }
#line 1087
  return (ptr);
}
}
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 67
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 103 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
enum id3_version id3_get_version(id3_t tag ) ;
#line 106
int id3_frame_count(id3_t tag ) ;
#line 115
void *id3_frame_get_raw(id3_frame_t f ) ;
#line 121
id3_frame_t id3_frame_add(id3_t tag , char const   *id ) ;
#line 144
char *id3_comment_get(id3_t tag , char const   *desc , char const   *lang ) ;
#line 145
int id3_comment_set(id3_t tag , char const   *text , char const   *desc , char const   *lang ,
                    enum id3_text_encoding enc ) ;
#line 48 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static char const   *_comment_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 51
  tmp = id3_get_version(tag);
  }
  }
  {
#line 52
  if ((unsigned int )tmp == 2U) {
#line 52
    goto case_2;
  }
#line 55
  if ((unsigned int )tmp == 4U) {
#line 55
    goto case_4;
  }
#line 55
  if ((unsigned int )tmp == 3U) {
#line 55
    goto case_4;
  }
#line 57
  goto switch_default;
  case_2: /* CIL Label */ 
#line 53
  return ("COM");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 56
  return ("COMM");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return ((char const   *)((void *)0));
}
}
#line 64 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static int _desc_eq(char const   *a , char const   *b , int size , enum id3_text_encoding enc ) 
{ 
  int i ;

  {
#line 67
  i = 0;
  {
#line 70
  if ((unsigned int )enc == 2U) {
#line 70
    goto case_2;
  }
#line 70
  if ((unsigned int )enc == 1U) {
#line 70
    goto case_2;
  }
#line 80
  if ((unsigned int )enc == 0U) {
#line 80
    goto case_0;
  }
#line 80
  if ((unsigned int )enc == 3U) {
#line 80
    goto case_0;
  }
#line 68
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < size)) {
#line 71
      goto while_break;
    }
#line 72
    if ((int const   )*(a + i) != (int const   )*(b + i)) {
#line 73
      return (0);
    } else
#line 72
    if ((int const   )*(a + (i + 1)) != (int const   )*(b + (i + 1))) {
#line 73
      return (0);
    }
#line 74
    if ((int const   )*(a + i) == 0) {
#line 74
      if ((int const   )*(a + (i + 1)) == 0) {
#line 75
        goto while_break;
      }
    }
#line 76
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (i < size)) {
#line 81
      goto while_break___0;
    }
#line 82
    if ((int const   )*(a + i) != (int const   )*(b + i)) {
#line 83
      return (0);
    }
#line 84
    if ((int const   )*(a + i) == 0) {
#line 85
      goto while_break___0;
    }
#line 86
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  return (1);
}
}
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static char *_get_comment_text(id3_frame_t f ) 
{ 
  unsigned char *s ;
  void *tmp ;

  {
  {
  {
#line 97
  tmp = id3_frame_get_raw(f);
  }
#line 97
  s = (unsigned char *)tmp;
  }
#line 99
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 100
    return ((char *)((void *)0));
  }
  {
#line 103
  if ((int )*(s + 0) == 2) {
#line 103
    goto case_2;
  }
#line 103
  if ((int )*(s + 0) == 1) {
#line 103
    goto case_2;
  }
#line 112
  if ((int )*(s + 0) == 0) {
#line 112
    goto case_0;
  }
#line 112
  if ((int )*(s + 0) == 3) {
#line 112
    goto case_0;
  }
#line 101
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 104
  s += 4;
  {
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 105
    if (s - f->data <= (long )f->sz) {
#line 105
      if ((int )*(s + 0) == 0) {
#line 105
        if ((int )*(s + 1) == 0) {
#line 105
          goto while_break;
        }
      }
    } else {
#line 105
      goto while_break;
    }
#line 106
    s += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(s + 0) == 0) {
#line 107
    if (! ((int )*(s + 1) == 0)) {
#line 108
      return ((char *)((void *)0));
    }
  } else {
#line 108
    return ((char *)((void *)0));
  }
#line 109
  s += 2;
#line 110
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 113
  s += 4;
  {
  {
#line 114
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 114
    if (s - f->data <= (long )f->sz) {
#line 114
      if (! ((int )*(s + 0) != 0)) {
#line 114
        goto while_break___0;
      }
    } else {
#line 114
      goto while_break___0;
    }
#line 115
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  if ((int )*(s + 0) != 0) {
#line 117
    return ((char *)((void *)0));
  }
#line 118
  s ++;
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 121
  return ((char *)s);
}
}
#line 129 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static id3_frame_t _get_comment_frame(id3_t tag , char const   *desc , char const   *lang ) 
{ 
  char const   *id ;
  char const   *tmp ;
  char *s ;
  id3_frame_t f ;
  int nframes ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 132
  tmp = _comment_id(tag);
  }
#line 132
  id = tmp;
  {
#line 137
  nframes = id3_frame_count(tag);
  }
  }
#line 138
  if (nframes == -1) {
#line 139
    return ((id3_frame_t )((void *)0));
  }
#line 140
  f = tag->frame_hd;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! f) {
#line 140
      goto while_break;
    }
    {
    {
#line 141
    tmp___3 = strcmp((char const   *)(f->id), id);
    }
    }
#line 141
    if (tmp___3 == 0) {
      {
      {
#line 142
      tmp___0 = id3_frame_get_raw(f);
      }
#line 142
      s = (char *)tmp___0;
      }
#line 143
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 144
        goto __Cont;
      }
#line 145
      if (desc) {
        {
        {
#line 145
        tmp___1 = _desc_eq(desc, (char const   *)(s + 4), f->sz - 4, (enum id3_text_encoding )*(s + 0));
        }
        }
#line 145
        if (! tmp___1) {
#line 146
          goto __Cont;
        }
      }
#line 147
      if (lang) {
        {
        {
#line 147
        tmp___2 = memcmp((void const   *)lang, (void const   *)(s + 1), (size_t )3);
        }
        }
#line 147
        if (tmp___2 != 0) {
#line 148
          goto __Cont;
        }
      }
#line 149
      return (f);
    }
    __Cont: /* CIL Label */ 
#line 140
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((id3_frame_t )((void *)0));
}
}
#line 156 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
char *id3_comment_get(id3_t tag , char const   *desc , char const   *lang ) 
{ 
  char *s ;
  id3_frame_t f ;
  id3_frame_t tmp ;

  {
  {
#line 159
  s = (char *)((void *)0);
  {
#line 160
  tmp = _get_comment_frame(tag, desc, lang);
  }
#line 160
  f = tmp;
  }
#line 162
  if (f) {
    {
    {
#line 163
    s = _get_comment_text(f);
    }
    }
  } else
#line 164
  if (tag->v1.exists) {
#line 164
    if ((int )tag->v1.comment[0] != 0) {
#line 165
      s = tag->v1.comment;
    }
  }
#line 167
  return (s);
}
}
#line 170 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
int id3_comment_set(id3_t tag , char const   *text , char const   *desc , char const   *lang ,
                    enum id3_text_encoding enc ) 
{ 
  id3_frame_t f ;
  unsigned char *data ;
  char const   *id ;
  int desclen ;
  int textoffset ;
  int textlen ;
  int sz ;
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 179
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
#line 180
    desc = "\000\000";
  }
#line 181
  if ((unsigned long )lang == (unsigned long )((void *)0)) {
#line 182
    lang = "XXX";
  }
#line 185
  textlen = 0;
#line 185
  desclen = textlen;
  {
#line 188
  if ((unsigned int )enc == 2U) {
#line 188
    goto case_2;
  }
#line 188
  if ((unsigned int )enc == 1U) {
#line 188
    goto case_2;
  }
#line 197
  if ((unsigned int )enc == 0U) {
#line 197
    goto case_0;
  }
#line 197
  if ((unsigned int )enc == 3U) {
#line 197
    goto case_0;
  }
#line 205
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 189
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 189
    if ((int const   )*(desc + desclen) == 0) {
#line 189
      if ((int const   )*(desc + (desclen + 1)) == 0) {
#line 189
        goto while_break;
      }
    }
#line 190
    desclen += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 191
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 191
    if ((int const   )*(text + textlen) == 0) {
#line 191
      if ((int const   )*(text + (textlen + 1)) == 0) {
#line 191
        goto while_break___0;
      }
    }
#line 192
    textlen += 2;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 193
  textoffset = (4 + desclen) + 2;
#line 194
  sz = (((4 + desclen) + 2) + textlen) + 2;
#line 195
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  {
#line 198
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 198
    if (! ((int const   )*(desc + desclen) != 0)) {
#line 198
      goto while_break___1;
    }
#line 199
    desclen ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 200
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 200
    if (! ((int const   )*(text + textlen) != 0)) {
#line 200
      goto while_break___2;
    }
#line 201
    textlen ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 202
  textoffset = (4 + desclen) + 1;
#line 203
  sz = (((4 + desclen) + 1) + textlen) + 2;
#line 204
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 206
  tmp = __errno_location();
  }
#line 206
  *tmp = 22;
  }
#line 207
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 211
  f = _get_comment_frame(tag, desc, lang);
  }
  }
#line 212
  if (f) {
#line 213
    if (f->data) {
#line 214
      if (f->sz < sz - 2) {
        {
#line 215
        data = f->data;
        {
#line 216
        tmp___0 = calloc((size_t )sz, (size_t )1);
        }
#line 216
        f->data = (unsigned char *)tmp___0;
        }
#line 217
        if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 218
          f->data = data;
#line 219
          return (-1);
        }
      } else {
        {
        {
#line 222
        memset((void *)f->data, 0, (size_t )f->sz);
        }
        }
      }
    } else {
      {
      {
#line 225
      tmp___1 = calloc((size_t )sz, (size_t )1);
      }
#line 225
      f->data = (unsigned char *)tmp___1;
      }
#line 226
      if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 227
        return (-1);
      }
    }
  } else {
    {
    {
#line 230
    id = _comment_id(tag);
    }
    {
#line 231
    f = id3_frame_add(tag, id);
    }
    }
#line 232
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 233
      return (-1);
    }
    {
    {
#line 234
    tmp___2 = calloc((size_t )sz, (size_t )1);
    }
#line 234
    f->data = (unsigned char *)tmp___2;
    }
#line 235
    if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 236
      return (-1);
    }
  }
  {
#line 239
  f->sz = sz - 2;
#line 240
  *(f->data + 0) = (unsigned char )enc;
  {
#line 241
  memcpy((void */* __restrict  */)(f->data + 1), (void const   */* __restrict  */)lang,
         (size_t )3);
  }
  {
#line 242
  memcpy((void */* __restrict  */)(f->data + 4), (void const   */* __restrict  */)desc,
         (size_t )desclen);
  }
  {
#line 243
  memcpy((void */* __restrict  */)(f->data + textoffset), (void const   */* __restrict  */)text,
         (size_t )textlen);
  }
  }
#line 245
  if ((unsigned int )enc == 0U) {
    {
    {
#line 246
    strncpy((char */* __restrict  */)(tag->v1.comment), (char const   */* __restrict  */)text,
            (size_t )30);
    }
    }
  }
#line 248
  return (0);
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 147 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
float id3_rva_get(id3_t tag , char const   *ident , enum id3_rva_channel channel ) ;
#line 148
int id3_rva_set(id3_t tag , char const   *ident , enum id3_rva_channel channel , float adjust ) ;
#line 119 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3P.h"
id3_frame_t _id3_frame_new(void) ;
#line 121
void _id3_frame_add(id3_t tag , id3_frame_t f ) ;
#line 50 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static char const   *_rva_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 53
  tmp = id3_get_version(tag);
  }
  }
  {
#line 54
  if ((unsigned int )tmp == 2U) {
#line 54
    goto case_2;
  }
#line 58
  if ((unsigned int )tmp == 3U) {
#line 58
    goto case_3;
  }
#line 61
  if ((unsigned int )tmp == 4U) {
#line 61
    goto case_4;
  }
#line 63
  goto switch_default;
  case_2: /* CIL Label */ 
#line 57
  return ("XRV");
  case_3: /* CIL Label */ 
#line 60
  return ("XRVA");
  case_4: /* CIL Label */ 
#line 62
  return ("RVA2");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return ((char const   *)((void *)0));
}
}
#line 82 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static id3_frame_t id3_rva_get_frame(id3_t tag , char const   *ident ) 
{ 
  char const   *id ;
  char const   *tmp ;
  char *s ;
  id3_frame_t f ;
  int nframes ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 85
  tmp = _rva_id(tag);
  }
#line 85
  id = tmp;
  {
#line 90
  nframes = id3_frame_count(tag);
  }
  }
#line 91
  if (nframes == -1) {
#line 92
    return ((id3_frame_t )((void *)0));
  }
#line 93
  f = tag->frame_hd;
  {
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 93
    if (! f) {
#line 93
      goto while_break;
    }
    {
    {
#line 94
    tmp___2 = strcmp((char const   *)(f->id), id);
    }
    }
#line 94
    if (tmp___2 == 0) {
      {
      {
#line 96
      tmp___0 = id3_frame_get_raw(f);
      }
#line 96
      s = (char *)tmp___0;
      }
#line 97
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 98
        goto __Cont;
      }
#line 99
      if (ident) {
        {
        {
#line 99
        tmp___1 = strncmp(ident, (char const   *)s, (size_t )f->sz);
        }
        }
#line 99
        if (tmp___1 != 0) {
#line 100
          goto __Cont;
        }
      }
#line 101
      return (f);
    }
    __Cont: /* CIL Label */ 
#line 93
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return ((id3_frame_t )((void *)0));
}
}
#line 119 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static float id3_rva_get_adjust(id3_frame_t f , enum id3_rva_channel channel ) 
{ 
  unsigned char *data ;
  float adj ;
  int i ;
  int peakbytes ;
  int adj_fp ;
  void *tmp ;

  {
  {
#line 123
  adj = (float )0.0;
  {
#line 126
  tmp = id3_frame_get_raw(f);
  }
#line 126
  data = (unsigned char *)tmp;
#line 129
  i = 0;
  }
  {
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < f->sz)) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )*(data + i) == 0) {
#line 131
      goto while_break;
    }
#line 129
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if ((int )*(data + i) != 0) {
#line 133
    return ((float )0.0);
  }
#line 136
  i ++;
  {
  {
#line 137
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! (i + 3 < f->sz)) {
#line 137
      goto while_break___0;
    }
#line 139
    if ((int )*(data + i) == (int )((unsigned char )channel)) {
#line 141
      adj_fp = (int )*((signed char *)((data + i) + 1)) << 8;
#line 142
      adj_fp |= (int )*((data + i) + 2);
#line 143
      adj = (float )((double )adj_fp / 512.0);
#line 144
      goto while_break___0;
    }
#line 148
    i += 3;
#line 149
    peakbytes = ((int )*(data + i) + 7) / 8;
#line 150
    i += 1 + peakbytes;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  return (adj);
}
}
#line 171 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
float id3_rva_get(id3_t tag , char const   *ident , enum id3_rva_channel channel ) 
{ 
  id3_frame_t f ;
  id3_frame_t tmp ;
  float adj ;

  {
  {
  {
#line 174
  tmp = id3_rva_get_frame(tag, ident);
  }
#line 174
  f = tmp;
#line 175
  adj = (float )0.0;
  }
#line 177
  if (f) {
    {
    {
#line 178
    adj = id3_rva_get_adjust(f, channel);
    }
    }
  }
#line 180
  return (adj);
}
}
#line 205 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
int id3_rva_set(id3_t tag , char const   *ident , enum id3_rva_channel channel , float adjust ) 
{ 
  char const   *id ;
  unsigned char *data ;
  id3_frame_t f ;
  id3_frame_t tmp ;
  int i ;
  int idlen ;
  int peakbytes ;
  int adjust_fp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 211
  tmp = id3_rva_get_frame(tag, ident);
  }
#line 211
  f = tmp;
  {
#line 214
  tmp___0 = strlen(ident);
  }
#line 214
  idlen = (int )tmp___0;
  }
#line 216
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
    {
#line 222
    id = _rva_id(tag);
    }
    }
#line 223
    if ((unsigned long )ident == (unsigned long )((void *)0)) {
#line 224
      ident = "";
    }
    {
    {
#line 225
    f = _id3_frame_new();
    }
    }
#line 226
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 227
      return (-1);
    }
    {
#line 228
    f->sz = (idlen + 1) + 4;
    {
#line 229
    tmp___1 = malloc((size_t )f->sz);
    }
#line 229
    f->data = (unsigned char *)tmp___1;
    }
#line 230
    if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 231
      return (-1);
    }
    {
    {
#line 232
    _id3_frame_add(tag, f);
    }
#line 234
    f->id3 = tag;
    {
#line 235
    strncpy((char */* __restrict  */)(f->id), (char const   */* __restrict  */)id,
            (size_t )4);
    }
    {
#line 236
    strcpy((char */* __restrict  */)((char *)f->data), (char const   */* __restrict  */)ident);
    }
#line 238
    i = idlen + 1;
    }
  } else {
    {
    {
#line 247
    tmp___2 = id3_frame_get_raw(f);
    }
#line 247
    data = (unsigned char *)tmp___2;
#line 250
    i = 0;
    }
    {
    {
#line 250
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 250
      if (! (i < f->sz)) {
#line 250
        goto while_break;
      }
#line 251
      if ((int )*(data + i) == 0) {
#line 252
        goto while_break;
      }
#line 250
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 253
    if ((int )*(data + i) != 0) {
#line 254
      return (-1);
    }
    {
    {
#line 257
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 258
      i ++;
#line 259
      if (i >= f->sz) {
#line 260
        goto while_break___0;
      } else
#line 259
      if ((int )*(data + i) == (int )((unsigned char )channel)) {
#line 260
        goto while_break___0;
      }
#line 263
      i += 3;
#line 264
      if (i >= f->sz) {
#line 266
        i -= 3;
#line 267
        goto while_break___0;
      }
#line 269
      peakbytes = (int )*(data + i) / 8;
#line 270
      i += peakbytes;
#line 271
      if (i >= f->sz) {
#line 273
        i -= peakbytes + 3;
#line 274
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 278
    if (i + 3 >= f->sz) {
      {
      {
#line 280
      tmp___3 = realloc((void *)f->data, (size_t )(i + 3));
      }
#line 280
      f->data = (unsigned char *)tmp___3;
      }
#line 281
      if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 282
        f->data = data;
#line 283
        return (-1);
      }
#line 285
      f->sz = i + 3;
    }
  }
#line 293
  *(f->data + i) = (unsigned char )channel;
#line 295
  if ((double )adjust < 0.0) {
#line 296
    adjust_fp = (int )((double )adjust * 512.0 - 0.5);
  } else {
#line 298
    adjust_fp = (int )((double )adjust * 512.0 + 0.5);
  }
#line 299
  *(f->data + (i + 1)) = (unsigned char )((adjust_fp >> 8) & 255);
#line 300
  *(f->data + (i + 2)) = (unsigned char )(adjust_fp & 255);
#line 302
  *(f->data + (i + 3)) = (unsigned char)0;
#line 304
  return (0);
}
}
#line 37 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
static char const   *_genre_map[149]  = 
#line 37 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
  {      "Blues",      "Classic Rock",      "Country",      "Dance", 
        "Disco",      "Funk",      "Grunge",      "Hip-Hop", 
        "Jazz",      "Metal",      "New Age",      "Oldies", 
        "Other",      "Pop",      "R&B",      "Rap", 
        "Reggae",      "Rock",      "Techno",      "Industrial", 
        "Alternative",      "Ska",      "Death Metal",      "Pranks", 
        "Soundtrack",      "Euro-Techno",      "Ambient",      "Trip-Hop", 
        "Vocal",      "Jazz+Funk",      "Fusion",      "Trance", 
        "Classical",      "Instrumental",      "Acid",      "House", 
        "Game",      "Sound Clip",      "Gospel",      "Noise", 
        "Alternative Rock",      "Bass",      "Soul",      "Punk", 
        "Space",      "Meditative",      "Instrumental Pop",      "Instrumental Rock", 
        "Ethnic",      "Gothic",      "Darkwave",      "Techno-Industrial", 
        "Electronic",      "Pop-Folk",      "Eurodance",      "Dream", 
        "Southern Rock",      "Comedy",      "Cult",      "Gangsta", 
        "Top 40",      "Christian Rap",      "Pop/Funk",      "Jungle", 
        "Native US",      "Cabaret",      "New Wave",      "Psychedelic", 
        "Rave",      "Showtunes",      "Trailer",      "Lo-Fi", 
        "Tribal",      "Acid Punk",      "Acid Jazz",      "Polka", 
        "Retro",      "Musical",      "Rock & Roll",      "Hard Rock", 
        "Folk",      "Folk-Rock",      "National Folk",      "Swing", 
        "Fast Fusion",      "Bebob",      "Latin",      "Revival", 
        "Celtic",      "Bluegrass",      "Avant-garde",      "Gothic Rock", 
        "Progressive Rock",      "Psychedelic Rock",      "Symphonic Rock",      "Slow Rock", 
        "Big Band",      "Chorus",      "Easy Listening",      "Acoustic ", 
        "Humour",      "Speech",      "Chanson",      "Opera", 
        "Chamber Music",      "Sonata",      "Symphony",      "Booty Bass", 
        "Primus",      "Porn Groove",      "Satire",      "Slow Jam", 
        "Club",      "Tango",      "Samba",      "Folklore", 
        "Ballad",      "Power Ballad",      "Rhythmic Soul",      "Freestyle", 
        "Duet",      "Punk Rock",      "Drum Solo",      "A Cappella", 
        "Euro-House",      "Dance Hall",      "Goa",      "Drum & Bass", 
        "Club-House",      "Hardcore",      "Terror",      "Indie", 
        "BritPop",      "Negerpunk",      "Polsk Punk",      "Beat", 
        "Christian Gangsta",      "Heavy Metal",      "Black Metal",      "Crossover", 
        "Contemporary Christian",      "Christian Rock",      "Merengue",      "Salsa", 
        "Thrash Metal",      "Anime",      "JPop",      "SynthPop", 
        (char const   *)((void *)0)};
#line 190 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
static int xstrcaseeq(char const   *a , char const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 193
    if (*a) {
#line 193
      if (! *b) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
    {
    {
#line 194
    tmp = tolower((int )*a);
    }
    {
#line 194
    tmp___0 = tolower((int )*b);
    }
    }
#line 194
    if (tmp != tmp___0) {
#line 195
      return (0);
    }
#line 196
    a ++;
#line 196
    b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (1);
}
}
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
char const   *id3_genre_name(int genre ) 
{ 


  {
#line 212
  if (genre < 0) {
#line 213
    return ((char const   *)((void *)0));
  } else
#line 212
  if (genre > 147) {
#line 213
    return ((char const   *)((void *)0));
  }
#line 214
  return (_genre_map[genre]);
}
}
#line 226 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
int id3_genre_number(char const   *desc ) 
{ 
  int i ;
  int tmp ;

  {
#line 230
  i = 0;
  {
  {
#line 230
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 230
    if (! _genre_map[i]) {
#line 230
      goto while_break;
    }
    {
    {
#line 231
    tmp = xstrcaseeq(desc, _genre_map[i]);
    }
    }
#line 231
    if (tmp) {
#line 232
      return (i);
    }
#line 230
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (255);
}
}
#line 125 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
int id3_frame_save_image(id3_frame_t f , char const   *fname ) ;
#line 49 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/image.c"
int id3_frame_save_image(id3_frame_t f , char const   *fname ) 
{ 
  id3_t tag ;
  unsigned char *data ;
  FILE *out ;
  char *fullname ;
  char *mimetype ;
  int i ;
  int err_save ;
  void *tmp ;
  enum id3_version tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 52
  tag = f->id3;
#line 55
  fullname = (char *)((void *)0);
  {
#line 58
  tmp = id3_frame_get_raw(f);
  }
#line 58
  data = (unsigned char *)tmp;
  }
#line 59
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 60
    return (-1);
  }
  {
  {
#line 62
  tmp___0 = id3_get_version(tag);
  }
  }
  {
#line 63
  if ((unsigned int )tmp___0 == 2U) {
#line 63
    goto case_2;
  }
#line 76
  if ((unsigned int )tmp___0 == 4U) {
#line 76
    goto case_4;
  }
#line 76
  if ((unsigned int )tmp___0 == 3U) {
#line 76
    goto case_4;
  }
#line 91
  goto switch_default;
  case_2: /* CIL Label */ 
  {
  {
#line 64
  tmp___1 = strcmp((char const   *)(f->id), "PIC");
  }
  }
#line 64
  if (tmp___1 != 0) {
#line 65
    return (-1);
  }
#line 66
  if (f->sz < 4) {
#line 67
    return (-1);
  }
  {
  {
#line 68
  tmp___2 = strlen(fname);
  }
  {
#line 68
  tmp___3 = malloc((tmp___2 + 4U) + 1U);
  }
#line 68
  fullname = (char *)tmp___3;
  }
#line 69
  if ((unsigned long )fullname == (unsigned long )((void *)0)) {
#line 70
    return (-1);
  }
  {
  {
#line 71
  sprintf((char */* __restrict  */)fullname, (char const   */* __restrict  */)"%s.%c%c%c",
          fname, (int )*(data + 1), (int )*(data + 2), (int )*(data + 3));
  }
#line 72
  data += 5;
  }
#line 73
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  {
#line 77
  tmp___4 = strcmp((char const   *)(f->id), "APIC");
  }
  }
#line 77
  if (tmp___4 != 0) {
#line 78
    return (-1);
  }
#line 80
  i = 1;
  {
  {
#line 80
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < f->sz)) {
#line 80
      goto while_break;
    }
#line 81
    if ((int )*(data + i) == 0) {
#line 82
      goto while_break;
    }
#line 80
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  if ((int )*(data + i) != 0) {
#line 84
    return (-1);
  } else
#line 83
  if (i < 8) {
#line 84
    return (-1);
  }
  {
#line 85
  mimetype = (char *)data + 7;
  {
#line 86
  tmp___5 = strlen(fname);
  }
  {
#line 86
  tmp___6 = strlen((char const   *)mimetype);
  }
  {
#line 86
  tmp___7 = malloc((tmp___5 + tmp___6) + 2U);
  }
#line 86
  fullname = (char *)tmp___7;
  }
#line 87
  if ((unsigned long )fullname == (unsigned long )((void *)0)) {
#line 88
    return (-1);
  }
  {
  {
#line 89
  sprintf((char */* __restrict  */)fullname, (char const   */* __restrict  */)"%s.%s",
          fname, mimetype);
  }
  {
#line 90
  tmp___8 = strlen((char const   *)mimetype);
  }
#line 90
  data = ((data + tmp___8) + 6) + 3;
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 98
  if ((int )*(f->data + 0) == 2) {
#line 98
    goto case_2___0;
  }
#line 98
  if ((int )*(f->data + 0) == 1) {
#line 98
    goto case_2___0;
  }
#line 106
  if ((int )*(f->data + 0) == 0) {
#line 106
    goto case_0;
  }
#line 106
  if ((int )*(f->data + 0) == 3) {
#line 106
    goto case_0;
  }
#line 96
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 99
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 99
    if ((int )*(data + 0) == 0) {
#line 99
      if ((int )*(data + 1) == 0) {
#line 99
        goto while_break___0;
      } else {
#line 99
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 99
    if (! (data - f->data < (long )f->sz)) {
#line 99
      goto while_break___0;
    }
#line 100
    data += 2;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  if ((int )*(data + 0) == 0) {
#line 101
    if (! ((int )*(data + 1) == 0)) {
#line 102
      goto error_free;
    }
  } else {
#line 102
    goto error_free;
  }
#line 103
  data += 2;
#line 104
  goto switch_break___0;
  case_0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
  {
#line 107
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 107
    if ((int )*(data + 0) != 0) {
#line 107
      if (! (data - f->data < (long )f->sz)) {
#line 107
        goto while_break___1;
      }
    } else {
#line 107
      goto while_break___1;
    }
#line 108
    data ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 109
  if ((int )*(data + 0) != 0) {
#line 110
    goto error_free;
  }
#line 111
  data ++;
#line 112
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 115
  if (data - f->data >= (long )f->sz) {
#line 116
    goto error_free;
  }
  {
  {
#line 118
  out = fopen((char const   */* __restrict  */)fullname, (char const   */* __restrict  */)"wb");
  }
  }
#line 119
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 120
    goto error_close;
  }
  {
  {
#line 121
  tmp___9 = fwrite((void const   */* __restrict  */)data, (size_t )((long )f->sz - (data - f->data)),
                   (size_t )1, (FILE */* __restrict  */)out);
  }
  }
#line 121
  if (tmp___9 < 1U) {
#line 122
    goto error_close;
  }
  {
  {
#line 123
  fclose(out);
  }
  {
#line 124
  free((void *)fullname);
  }
  }
#line 126
  return (0);
  error_close: 
  {
  {
#line 129
  tmp___10 = __errno_location();
  }
#line 129
  err_save = *tmp___10;
  {
#line 130
  fclose(out);
  }
  {
#line 131
  free((void *)fullname);
  }
  {
#line 132
  tmp___11 = __errno_location();
  }
#line 132
  *tmp___11 = err_save;
  }
#line 133
  return (-1);
  error_free: 
  {
  {
#line 136
  free((void *)fullname);
  }
  {
#line 137
  tmp___12 = __errno_location();
  }
#line 137
  *tmp___12 = 22;
  }
#line 138
  return (-1);
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 108 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
id3_frame_t id3_get_frame_by_id(id3_t tag , char const   *id ) ;
#line 130
id3_frame_t id3_add_text_frame(id3_t tag , char const   *id , char const   *text ,
                               int encoding ) ;
#line 132
char *id3_title_get(id3_t tag ) ;
#line 133
int id3_title_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) ;
#line 134
char *id3_artist_get(id3_t tag ) ;
#line 135
int id3_artist_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) ;
#line 136
char *id3_album_get(id3_t tag ) ;
#line 137
int id3_album_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) ;
#line 138
char *id3_genre_get(id3_t tag ) ;
#line 139
int id3_genre_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) ;
#line 140
char *id3_date_get(id3_t tag ) ;
#line 141
int id3_date_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) ;
#line 142
char *id3_tracknum_get(id3_t tag ) ;
#line 143
int id3_tracknum_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) ;
#line 41 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_title_id(id3_t tag ) ;
#line 42
static char const   *_artist_id(id3_t tag ) ;
#line 43
static char const   *_album_id(id3_t tag ) ;
#line 44
static char const   *_genre_id(id3_t tag ) ;
#line 45
static char const   *_date_id(id3_t tag ) ;
#line 46
static char const   *_tracknum_id(id3_t tag ) ;
#line 47
static char *_do_get(id3_t tag , char const   *id ) ;
#line 48
static int _do_set(id3_t tag , char const   *id , char const   *s , enum id3_text_encoding enc ) ;
#line 56 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
char *id3_title_get(id3_t tag ) 
{ 
  char *s ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 59
  tmp = _title_id(tag);
  }
  {
#line 59
  tmp___0 = _do_get(tag, tmp);
  }
#line 59
  s = tmp___0;
  }
#line 60
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 60
    if (tag->v1.exists) {
#line 60
      if ((int )tag->v1.title[0] != 0) {
#line 61
        s = tag->v1.title;
      }
    }
  }
#line 62
  return (s);
}
}
#line 65 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
int id3_title_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) 
{ 
  int ret ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 68
  tmp = _title_id(tag);
  }
  {
#line 68
  tmp___0 = _do_set(tag, tmp, s, enc);
  }
#line 68
  ret = tmp___0;
  }
#line 69
  if ((unsigned int )enc == 0U) {
    {
    {
#line 70
    strncpy((char */* __restrict  */)(tag->v1.title), (char const   */* __restrict  */)s,
            (size_t )30);
    }
    }
  }
#line 71
  return (ret);
}
}
#line 74 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
char *id3_artist_get(id3_t tag ) 
{ 
  char *s ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 77
  tmp = _artist_id(tag);
  }
  {
#line 77
  tmp___0 = _do_get(tag, tmp);
  }
#line 77
  s = tmp___0;
  }
#line 78
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 78
    if (tag->v1.exists) {
#line 78
      if ((int )tag->v1.artist[0] != 0) {
#line 79
        s = tag->v1.artist;
      }
    }
  }
#line 80
  return (s);
}
}
#line 83 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
int id3_artist_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) 
{ 
  int ret ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 86
  tmp = _artist_id(tag);
  }
  {
#line 86
  tmp___0 = _do_set(tag, tmp, s, enc);
  }
#line 86
  ret = tmp___0;
  }
#line 87
  if ((unsigned int )enc == 0U) {
    {
    {
#line 88
    strncpy((char */* __restrict  */)(tag->v1.artist), (char const   */* __restrict  */)s,
            (size_t )30);
    }
    }
  }
#line 89
  return (ret);
}
}
#line 92 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
char *id3_album_get(id3_t tag ) 
{ 
  char *s ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 95
  tmp = _album_id(tag);
  }
  {
#line 95
  tmp___0 = _do_get(tag, tmp);
  }
#line 95
  s = tmp___0;
  }
#line 96
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 96
    if (tag->v1.exists) {
#line 96
      if ((int )tag->v1.album[0] != 0) {
#line 97
        s = tag->v1.album;
      }
    }
  }
#line 98
  return (s);
}
}
#line 101 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
int id3_album_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) 
{ 
  int ret ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 104
  tmp = _album_id(tag);
  }
  {
#line 104
  tmp___0 = _do_set(tag, tmp, s, enc);
  }
#line 104
  ret = tmp___0;
  }
#line 105
  if ((unsigned int )enc == 0U) {
    {
    {
#line 106
    strncpy((char */* __restrict  */)(tag->v1.album), (char const   */* __restrict  */)s,
            (size_t )30);
    }
    }
  }
#line 107
  return (ret);
}
}
#line 110 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
char *id3_genre_get(id3_t tag ) 
{ 
  char *s ;
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 113
  tmp = _genre_id(tag);
  }
  {
#line 113
  tmp___0 = _do_get(tag, tmp);
  }
#line 113
  s = tmp___0;
  }
#line 114
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 114
    if (tag->v1.exists) {
#line 114
      if ((int )tag->v1.genre != 255) {
        {
        {
#line 115
        sprintf((char */* __restrict  */)(tag->v1.genrestr), (char const   */* __restrict  */)"%d",
                (int )tag->v1.genre);
        }
#line 116
        s = tag->v1.genrestr;
        }
      }
    }
  }
#line 118
  return (s);
}
}
#line 121 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
int id3_genre_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) 
{ 
  int ret ;
  char const   *tmp ;
  int tmp___0 ;
  int is_numeric ;
  char const   *p ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 124
  tmp = _genre_id(tag);
  }
  {
#line 124
  tmp___0 = _do_set(tag, tmp, s, enc);
  }
#line 124
  ret = tmp___0;
#line 125
  is_numeric = 0;
  }
#line 127
  if ((unsigned int )enc == 0U) {
#line 129
    if ((int const   )*(s + 0) >= 48) {
#line 129
      if ((int const   )*(s + 0) <= 57) {
        {
#line 130
        is_numeric = 1;
        {
#line 131
        tmp___1 = atoi(s);
        }
#line 131
        tag->v1.genre = (unsigned char )(tmp___1 & 255);
        }
      } else {
#line 129
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 132
    if ((int const   )*(s + 0) == 40) {
#line 133
      p = s;
      {
      {
#line 133
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 133
        if (*p) {
#line 133
          if (! ((int const   )*p != 41)) {
#line 133
            goto while_break;
          }
        } else {
#line 133
          goto while_break;
        }
#line 134
        if ((int const   )*p < 48) {
#line 135
          goto while_break;
        } else
#line 134
        if ((int const   )*p > 57) {
#line 135
          goto while_break;
        }
#line 133
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 136
      if ((int const   )*p == 41) {
        {
#line 137
        is_numeric = 1;
        {
#line 138
        tmp___2 = atoi(s + 1);
        }
#line 138
        tag->v1.genre = (unsigned char )(tmp___2 & 255);
        }
      }
    }
#line 142
    if (! is_numeric) {
      {
      {
#line 143
      tmp___3 = id3_genre_number(s);
      }
#line 143
      tag->v1.genre = (unsigned char )tmp___3;
      }
    }
  } else {
#line 145
    tag->v1.genre = (unsigned char)255;
  }
#line 147
  return (ret);
}
}
#line 150 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
char *id3_date_get(id3_t tag ) 
{ 
  char *s ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 153
  tmp = _date_id(tag);
  }
  {
#line 153
  tmp___0 = _do_get(tag, tmp);
  }
#line 153
  s = tmp___0;
  }
#line 154
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 154
    if (tag->v1.exists) {
#line 154
      if ((int )tag->v1.year[0] != 0) {
#line 155
        s = tag->v1.year;
      }
    }
  }
#line 156
  return (s);
}
}
#line 159 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
int id3_date_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) 
{ 
  int ret ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 162
  tmp = _date_id(tag);
  }
  {
#line 162
  tmp___0 = _do_set(tag, tmp, s, enc);
  }
#line 162
  ret = tmp___0;
  }
#line 163
  if ((unsigned int )enc == 0U) {
    {
    {
#line 164
    strncpy((char */* __restrict  */)(tag->v1.year), (char const   */* __restrict  */)s,
            (size_t )4);
    }
    }
  }
#line 165
  return (ret);
}
}
#line 168 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
char *id3_tracknum_get(id3_t tag ) 
{ 
  char *s ;
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 171
  tmp = _tracknum_id(tag);
  }
  {
#line 171
  tmp___0 = _do_get(tag, tmp);
  }
#line 171
  s = tmp___0;
  }
#line 172
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 172
    if (tag->v1.exists) {
#line 173
      if ((int )tag->v1.track != 0) {
        {
        {
#line 174
        sprintf((char */* __restrict  */)(tag->v1.trackstr), (char const   */* __restrict  */)"%d",
                (int )tag->v1.track);
        }
#line 175
        s = tag->v1.trackstr;
        }
      }
    }
  }
#line 178
  return (s);
}
}
#line 181 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
int id3_tracknum_set(id3_t tag , char const   *s , enum id3_text_encoding enc ) 
{ 
  int ret ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 184
  tmp = _tracknum_id(tag);
  }
  {
#line 184
  tmp___0 = _do_set(tag, tmp, s, enc);
  }
#line 184
  ret = tmp___0;
  {
#line 185
  tmp___1 = atoi(s);
  }
#line 185
  tag->v1.track = (unsigned char )(tmp___1 & 255);
  }
#line 186
  return (ret);
}
}
#line 194 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_title_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 197
  tmp = id3_get_version(tag);
  }
  }
  {
#line 198
  if ((unsigned int )tmp == 2U) {
#line 198
    goto case_2;
  }
#line 201
  if ((unsigned int )tmp == 4U) {
#line 201
    goto case_4;
  }
#line 201
  if ((unsigned int )tmp == 3U) {
#line 201
    goto case_4;
  }
#line 203
  goto switch_default;
  case_2: /* CIL Label */ 
#line 199
  return ("TT2");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 202
  return ("TIT2");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 206
  return ((char const   *)((void *)0));
}
}
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_artist_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 212
  tmp = id3_get_version(tag);
  }
  }
  {
#line 213
  if ((unsigned int )tmp == 2U) {
#line 213
    goto case_2;
  }
#line 216
  if ((unsigned int )tmp == 4U) {
#line 216
    goto case_4;
  }
#line 216
  if ((unsigned int )tmp == 3U) {
#line 216
    goto case_4;
  }
#line 218
  goto switch_default;
  case_2: /* CIL Label */ 
#line 214
  return ("TP1");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 217
  return ("TPE1");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 221
  return ((char const   *)((void *)0));
}
}
#line 224 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_album_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 227
  tmp = id3_get_version(tag);
  }
  }
  {
#line 228
  if ((unsigned int )tmp == 2U) {
#line 228
    goto case_2;
  }
#line 231
  if ((unsigned int )tmp == 4U) {
#line 231
    goto case_4;
  }
#line 231
  if ((unsigned int )tmp == 3U) {
#line 231
    goto case_4;
  }
#line 233
  goto switch_default;
  case_2: /* CIL Label */ 
#line 229
  return ("TAL");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 232
  return ("TALB");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 236
  return ((char const   *)((void *)0));
}
}
#line 239 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_genre_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 242
  tmp = id3_get_version(tag);
  }
  }
  {
#line 243
  if ((unsigned int )tmp == 2U) {
#line 243
    goto case_2;
  }
#line 246
  if ((unsigned int )tmp == 4U) {
#line 246
    goto case_4;
  }
#line 246
  if ((unsigned int )tmp == 3U) {
#line 246
    goto case_4;
  }
#line 248
  goto switch_default;
  case_2: /* CIL Label */ 
#line 244
  return ("TCO");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 247
  return ("TCON");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 251
  return ((char const   *)((void *)0));
}
}
#line 254 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_date_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 257
  tmp = id3_get_version(tag);
  }
  }
  {
#line 258
  if ((unsigned int )tmp == 2U) {
#line 258
    goto case_2;
  }
#line 260
  if ((unsigned int )tmp == 3U) {
#line 260
    goto case_3;
  }
#line 262
  if ((unsigned int )tmp == 4U) {
#line 262
    goto case_4;
  }
#line 264
  goto switch_default;
  case_2: /* CIL Label */ 
#line 259
  return ("TYE");
  case_3: /* CIL Label */ 
#line 261
  return ("TYER");
  case_4: /* CIL Label */ 
#line 263
  return ("TDRC");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 267
  return ((char const   *)((void *)0));
}
}
#line 270 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_tracknum_id(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 273
  tmp = id3_get_version(tag);
  }
  }
  {
#line 274
  if ((unsigned int )tmp == 2U) {
#line 274
    goto case_2;
  }
#line 277
  if ((unsigned int )tmp == 4U) {
#line 277
    goto case_4;
  }
#line 277
  if ((unsigned int )tmp == 3U) {
#line 277
    goto case_4;
  }
#line 279
  goto switch_default;
  case_2: /* CIL Label */ 
#line 275
  return ("TRK");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 278
  return ("TRCK");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 282
  return ((char const   *)((void *)0));
}
}
#line 285 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char *_do_get(id3_t tag , char const   *id ) 
{ 
  id3_frame_t f ;
  char *s ;
  void *tmp ;

  {
  {
  {
#line 292
  id3_frame_count(tag);
  }
  }
#line 294
  if (id) {
    {
    {
#line 295
    f = id3_get_frame_by_id(tag, id);
    }
    }
#line 296
    if (f) {
      {
      {
#line 296
      tmp = id3_frame_get_raw(f);
      }
#line 296
      s = (char *)tmp;
      }
#line 296
      if (s) {
#line 297
        return (s + 1);
      }
    }
  }
#line 299
  return ((char *)((void *)0));
}
}
#line 302 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static int _do_set(id3_t tag , char const   *id , char const   *s , enum id3_text_encoding enc ) 
{ 
  id3_frame_t tmp ;

  {
#line 305
  if ((unsigned long )id == (unsigned long )((void *)0)) {
#line 306
    return (-1);
  }
  {
  {
#line 307
  tmp = id3_add_text_frame(tag, id, s, (int )enc);
  }
  }
#line 307
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 308
    return (-1);
  }
#line 309
  return (0);
}
}
#line 123 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
int id3_frame_text_enc(id3_frame_t f ) ;
#line 124
char *id3_frame_text(id3_frame_t f ) ;
#line 120 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3P.h"
void _id3_frame_destroy(id3_frame_t f ) ;
#line 46 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/text.c"
int id3_frame_text_enc(id3_frame_t f ) 
{ 
  unsigned char *buf ;
  void *tmp ;

  {
  {
  {
#line 49
  tmp = id3_frame_get_raw(f);
  }
#line 49
  buf = (unsigned char *)tmp;
  }
#line 51
  if (buf) {
    {
#line 56
    if ((int )*(buf + 0) == 3) {
#line 56
      goto case_3;
    }
#line 56
    if ((int )*(buf + 0) == 2) {
#line 56
      goto case_3;
    }
#line 56
    if ((int )*(buf + 0) == 1) {
#line 56
      goto case_3;
    }
#line 56
    if ((int )*(buf + 0) == 0) {
#line 56
      goto case_3;
    }
#line 52
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 57
    return ((int )*(buf + 0));
    switch_break: /* CIL Label */ ;
    }
  }
#line 61
  return (-1);
}
}
#line 67 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/text.c"
char *id3_frame_text(id3_frame_t f ) 
{ 
  unsigned char *buf ;
  void *tmp ;
  char *retval ;
  int i ;

  {
  {
  {
#line 70
  tmp = id3_frame_get_raw(f);
  }
#line 70
  buf = (unsigned char *)tmp;
#line 71
  retval = (char *)((void *)0);
  }
#line 74
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
#line 77
  return ((char *)buf + 1);
#line 79
  retval = f->curr_txt;
#line 82
  if ((unsigned long )f->curr_txt == (unsigned long )((void *)0)) {
#line 83
    f->curr_txt = (char *)buf + 1;
  } else {
#line 85
    i = (int )(f->curr_txt - (char *)buf);
    {
#line 88
    if ((int )*(buf + 0) == 2) {
#line 88
      goto case_2;
    }
#line 88
    if ((int )*(buf + 0) == 1) {
#line 88
      goto case_2;
    }
#line 94
    if ((int )*(buf + 0) == 0) {
#line 94
      goto case_0;
    }
#line 94
    if ((int )*(buf + 0) == 3) {
#line 94
      goto case_0;
    }
#line 86
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
    {
#line 89
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 89
      if (i <= f->sz) {
#line 89
        if ((int )*(buf + i) == 0) {
#line 89
          if ((int )*(buf + (i + 1)) == 0) {
#line 89
            goto while_break;
          }
        }
      } else {
#line 89
        goto while_break;
      }
#line 90
      i += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 91
    i += 2;
#line 92
    goto switch_break;
    case_0: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
    {
#line 95
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 95
      if (i <= f->sz) {
#line 95
        if (! ((int )*(buf + i) != 0)) {
#line 95
          goto while_break___0;
        }
      } else {
#line 95
        goto while_break___0;
      }
#line 96
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    i ++;
#line 98
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 100
    if (i > f->sz) {
#line 101
      f->curr_txt = (char *)((void *)0);
    } else {
#line 103
      f->curr_txt = (char *)buf + i;
    }
  }
#line 106
  return (retval);
}
}
#line 110 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/text.c"
id3_frame_t id3_add_text_frame(id3_t tag , char const   *id , char const   *text ,
                               int encoding ) 
{ 
  id3_frame_t fr ;
  int len ;
  void *tmp ;

  {
  {
  {
#line 116
  fr = id3_frame_add(tag, id);
  }
  }
#line 117
  if ((unsigned long )fr == (unsigned long )((void *)0)) {
#line 118
    return ((id3_frame_t )((void *)0));
  }
#line 120
  len = 0;
  {
#line 123
  if (encoding == 2) {
#line 123
    goto case_2;
  }
#line 123
  if (encoding == 1) {
#line 123
    goto case_2;
  }
#line 128
  if (encoding == 0) {
#line 128
    goto case_0;
  }
#line 128
  if (encoding == 3) {
#line 128
    goto case_0;
  }
#line 132
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 124
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 124
    if ((int const   )*(text + len) == 0) {
#line 124
      if ((int const   )*(text + (len + 1)) == 0) {
#line 124
        goto while_break;
      }
    }
#line 125
    len += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  {
#line 129
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 129
    if (! ((int const   )*(text + len) != 0)) {
#line 129
      goto while_break___0;
    }
#line 130
    len ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 131
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 133
  _id3_frame_destroy(fr);
  }
  }
#line 134
  return ((id3_frame_t )((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 137
  if (fr->data) {
    {
    {
#line 138
    free((void *)fr->data);
    }
    }
  }
  {
#line 139
  fr->sz = len + 1;
  {
#line 140
  tmp = calloc((size_t )(fr->sz + 2), (size_t )1);
  }
#line 140
  fr->data = (unsigned char *)tmp;
  }
#line 141
  if ((unsigned long )fr->data == (unsigned long )((void *)0)) {
    {
    {
#line 142
    _id3_frame_destroy(fr);
    }
    }
#line 143
    return ((id3_frame_t )((void *)0));
  }
  {
#line 145
  *(fr->data + 0) = (unsigned char )encoding;
  {
#line 146
  memcpy((void */* __restrict  */)(fr->data + 1), (void const   */* __restrict  */)text,
         (size_t )len);
  }
  }
#line 148
  return (fr);
}
}
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 172 "/usr/include/stdio.h"
extern FILE *tmpfile(void) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 732
extern void rewind(FILE *__stream ) ;
#line 771
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 776
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 68 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
extern int ftruncate() ;
#line 100 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
int id3_get_size(id3_t tag ) ;
#line 102
int id3_set_version(id3_t tag , enum id3_version ver ) ;
#line 112
int id3_frame_get_size(id3_frame_t f ) ;
#line 117
int id3_frame_get_flag(id3_frame_t f , enum id3_fflag flg ) ;
#line 118
void id3_frame_set_flag(id3_frame_t f , enum id3_fflag flg ) ;
#line 119
void id3_frame_clear_flag(id3_frame_t f , enum id3_fflag flg ) ;
#line 127
int id3_write(id3_t tag ) ;
#line 81 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xrename___0(char const   *oldpath , char const   *newpath ) ;
#line 82
static int xmkstemp___0(char *template ) ;
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static size_t unsync_fwrite(void *buf , size_t size , FILE *stream , int *state ,
                            size_t *written ) 
{ 
  unsigned char *p ;
  unsigned char *p_save ;
  size_t writ ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 98
  p = (unsigned char *)buf;
#line 103
  writ = (size_t )0;
#line 104
  p_save = p;
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! (size > 0U)) {
#line 106
      goto while_break;
    }
#line 107
    c = (int )*p;
#line 109
    if (*state) {
#line 109
      if (c == 0) {
#line 109
        goto _L;
      } else
#line 109
      if ((c & 224) == 224) {
        _L: /* CIL Label */ 
        {
        {
#line 111
        tmp = _IO_putc(0, stream);
        }
        }
#line 111
        if (tmp == -1) {
#line 112
          goto while_break;
        }
#line 113
        writ ++;
      }
    }
    {
#line 115
    *state = c == 255;
    {
#line 116
    tmp___0 = _IO_putc(c, stream);
    }
    }
#line 116
    if (tmp___0 == -1) {
#line 117
      goto while_break;
    }
#line 118
    p ++;
#line 118
    size --;
#line 118
    writ ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (written) {
#line 122
    *written = writ;
  }
#line 124
  return ((size_t )(p - p_save));
}
}
#line 132 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int encode_unsync(unsigned char *dest , unsigned char *src , int sz ) 
{ 
  unsigned char *dest_save ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 135
  dest_save = dest;
  {
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (sz > 0)) {
#line 137
      goto while_break;
    }
#line 138
    if ((int )*src != 255) {
#line 139
      tmp = dest;
#line 139
      dest ++;
#line 139
      tmp___0 = src;
#line 139
      src ++;
#line 139
      *tmp = *tmp___0;
#line 140
      sz --;
    } else {
#line 142
      tmp___1 = dest;
#line 142
      dest ++;
#line 142
      tmp___2 = src;
#line 142
      src ++;
#line 142
      *tmp___1 = *tmp___2;
#line 143
      sz --;
#line 144
      if (sz <= 0) {
#line 145
        goto while_break;
      }
#line 146
      if ((int )*src == 0) {
#line 147
        tmp___3 = dest;
#line 147
        dest ++;
#line 147
        *tmp___3 = (unsigned char)0;
      } else
#line 146
      if (((int )*src & 224) == 224) {
#line 147
        tmp___3 = dest;
#line 147
        dest ++;
#line 147
        *tmp___3 = (unsigned char)0;
      }
#line 148
      tmp___4 = dest;
#line 148
      dest ++;
#line 148
      tmp___5 = src;
#line 148
      src ++;
#line 148
      *tmp___4 = *tmp___5;
#line 149
      sz --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((int )(dest - dest_save));
}
}
#line 156 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
__inline static void put_be_int(unsigned char *buf , unsigned int x ) 
{ 


  {
#line 159
  *(buf + 3) = (unsigned char )(x & 255U);
#line 160
  x >>= 8;
#line 161
  *(buf + 2) = (unsigned char )(x & 255U);
#line 162
  x >>= 8;
#line 163
  *(buf + 1) = (unsigned char )(x & 255U);
#line 164
  x >>= 8;
#line 165
  *(buf + 0) = (unsigned char )(x & 255U);
#line 166
  return;
}
}
#line 169 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void syncsafe_int(unsigned char *buf , unsigned int x ) 
{ 


  {
#line 172
  *(buf + 3) = (unsigned char )(x & 127U);
#line 173
  x >>= 7;
#line 174
  *(buf + 2) = (unsigned char )(x & 127U);
#line 175
  x >>= 7;
#line 176
  *(buf + 1) = (unsigned char )(x & 127U);
#line 177
  x >>= 7;
#line 178
  *(buf + 0) = (unsigned char )(x & 127U);
#line 179
  return;
}
}
#line 182 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_frame_data_sizes(id3_t tag ) 
{ 
  int sz ;
  id3_frame_t f ;
  int tmp ;

  {
#line 185
  sz = 0;
#line 188
  f = tag->frame_hd;
  {
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 188
    if (! f) {
#line 188
      goto while_break;
    }
    {
    {
#line 189
    tmp = id3_frame_get_size(f);
    }
#line 189
    sz += tmp;
#line 188
    f = f->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (sz);
}
}
#line 195 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_v4_frame_sizes(id3_t tag ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 198
  tmp = id3_frame_count(tag);
  }
#line 198
  nframes = tmp;
  {
#line 199
  tmp___0 = _sum_frame_data_sizes(tag);
  }
  }
#line 199
  return (nframes * 10 + tmp___0);
}
}
#line 203 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_v3_frame_sizes(id3_t tag ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 206
  tmp = id3_frame_count(tag);
  }
#line 206
  nframes = tmp;
  {
#line 207
  tmp___0 = _sum_frame_data_sizes(tag);
  }
  }
#line 207
  return (nframes * 10 + tmp___0);
}
}
#line 225 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _form_v4_header(id3_t tag , unsigned char *hdr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 228
  memcpy((void */* __restrict  */)hdr, (void const   */* __restrict  */)"ID3", (size_t )3);
  }
#line 229
  *(hdr + 3) = tag->version;
#line 230
  *(hdr + 4) = tag->revision;
#line 231
  *(hdr + 5) = (unsigned char)0;
  }
#line 232
  if (tag->unsync) {
#line 233
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 128);
  }
#line 235
  if (tag->experimental) {
#line 236
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 32);
  }
#line 238
  if (tag->append_req) {
#line 239
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 16);
  }
  {
  {
#line 240
  syncsafe_int(hdr + 6, (unsigned int )tag->tagsz);
  }
  }
#line 241
  return;
}
}
#line 243 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_header(id3_t tag , FILE *out ) 
{ 
  unsigned char buf[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;

  {
  {
  {
#line 248
  _form_v4_header(tag, buf);
  }
  {
#line 250
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 250
  if (tmp < 10U) {
#line 251
    return (-1);
  }
#line 252
  tag->curr_off += 10L;
#line 254
  return (0);
}
}
#line 257 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_footer(id3_t tag , FILE *out ) 
{ 
  unsigned char buf[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 262
  _form_v4_header(tag, buf);
  }
  {
#line 265
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)"3DI", (size_t )3);
  }
  {
#line 267
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 267
  if (tmp < 10U) {
#line 268
    return (-1);
  }
#line 269
  tag->curr_off += 10L;
#line 271
  return (0);
}
}
#line 274 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_frames(id3_t tag , FILE *out ) 
{ 
  id3_frame_t f ;
  int sz ;
  int unsync_bufsz ;
  unsigned char hdr[10] ;
  unsigned char *buf ;
  unsigned char *unsync_buf ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;

  {
#line 278
  unsync_bufsz = 512;
#line 280
  unsync_buf = (unsigned char *)((void *)0);
#line 282
  f = tag->frame_hd;
  {
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 282
    if (! f) {
#line 282
      goto while_break;
    }
#line 284
    if (tag->unsync) {
      {
      {
#line 285
      id3_frame_set_flag(f, (enum id3_fflag )6);
      }
      }
    }
    {
    {
#line 288
    memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)(f->id),
           (size_t )4);
    }
    {
#line 289
    syncsafe_int(hdr + 4, (unsigned int )f->sz);
    }
#line 290
    hdr[8] = (unsigned char )(((int )f->flags >> 8) & 255);
#line 291
    hdr[9] = (unsigned char )((int )f->flags & 255);
    {
#line 293
    tmp = id3_frame_get_raw(f);
    }
#line 293
    buf = (unsigned char *)tmp;
    }
#line 294
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 295
      goto __Cont;
    }
    {
#line 298
    f->offset = tag->curr_off + 10L;
    {
#line 300
    tmp___5 = id3_frame_get_flag(f, (enum id3_fflag )6);
    }
    }
#line 300
    if (tmp___5) {
#line 301
      if ((unsigned long )unsync_buf == (unsigned long )((void *)0)) {
#line 301
        goto _L;
      } else
#line 301
      if (unsync_bufsz < (f->sz * 3) / 2) {
        _L: /* CIL Label */ 
#line 302
        unsync_bufsz = (f->sz * 3) / 2;
#line 303
        if (unsync_buf) {
          {
          {
#line 304
          free((void *)unsync_buf);
          }
          }
        }
        {
        {
#line 305
        tmp___0 = malloc((size_t )unsync_bufsz);
        }
#line 305
        unsync_buf = (unsigned char *)tmp___0;
        }
#line 306
        if ((unsigned long )unsync_buf == (unsigned long )((void *)0)) {
#line 307
          return (-1);
        }
      }
      {
      {
#line 309
      sz = encode_unsync(unsync_buf, buf, f->sz);
      }
      {
#line 312
      syncsafe_int(hdr + 4, (unsigned int )sz);
      }
      }
#line 315
      if (! tag->unsync) {
#line 315
        if (sz == f->sz) {
          {
          {
#line 316
          id3_frame_clear_flag(f, (enum id3_fflag )6);
          }
          }
        }
      }
      {
      {
#line 319
      tmp___1 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 319
      if (tmp___1 < 10U) {
#line 320
        return (-1);
      }
      {
      {
#line 322
      tmp___2 = fwrite((void const   */* __restrict  */)unsync_buf, (size_t )1, (size_t )sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 322
      if (tmp___2 < (size_t )sz) {
#line 323
        return (-1);
      }
#line 324
      tag->curr_off += (off_t )(10 + sz);
    } else {
      {
      {
#line 329
      tmp___3 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 329
      if (tmp___3 < 10U) {
#line 330
        return (-1);
      }
      {
      {
#line 332
      tmp___4 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )f->sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 332
      if (tmp___4 < (size_t )f->sz) {
#line 333
        return (-1);
      }
#line 334
      tag->curr_off += (off_t )(10 + f->sz);
    }
    {
    {
#line 338
    free((void *)f->data);
    }
#line 339
    f->data = (unsigned char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 282
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (unsync_buf) {
    {
    {
#line 343
    free((void *)unsync_buf);
    }
    }
  }
#line 345
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v3_header(id3_t tag , FILE *out ) 
{ 
  unsigned char hdr[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 358
  memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)"ID3", (size_t )3);
  }
#line 359
  hdr[3] = tag->version;
#line 360
  hdr[4] = tag->revision;
#line 361
  hdr[5] = (unsigned char)0;
  }
#line 362
  if (tag->unsync) {
#line 363
    hdr[5] = (unsigned char )((int )hdr[5] | 128);
  }
#line 365
  if (tag->experimental) {
#line 366
    hdr[5] = (unsigned char )((int )hdr[5] | 32);
  }
  {
  {
#line 367
  syncsafe_int(hdr + 6, (unsigned int )tag->tagsz);
  }
  {
#line 368
  tmp = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 368
  if (tmp < 10U) {
#line 369
    return (-1);
  }
#line 370
  tag->curr_off += 10L;
#line 372
  return (0);
}
}
#line 375 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v3_frames(id3_t tag , FILE *out ) 
{ 
  id3_frame_t f ;
  int fwrite_state ;
  size_t consumed ;
  unsigned char hdr[10] ;
  unsigned char *buf ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp13 ;

  {
#line 379
  fwrite_state = 0;
#line 384
  f = tag->frame_hd;
  {
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 384
    if (! f) {
#line 384
      goto while_break;
    }
    {
    {
#line 387
    memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)(f->id),
           (size_t )4);
    }
    {
#line 388
    put_be_int(hdr + 4, (unsigned int )f->sz);
    }
#line 389
    hdr[8] = (unsigned char )(((int )f->flags >> 8) & 255);
#line 390
    hdr[9] = (unsigned char )((int )f->flags & 255);
    {
#line 392
    tmp = id3_frame_get_raw(f);
    }
#line 392
    buf = (unsigned char *)tmp;
    }
#line 393
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 394
      goto __Cont;
    }
#line 397
    f->offset = tag->curr_off + 10L;
#line 399
    if (tag->unsync) {
      {
      {
#line 401
      tmp___0 = unsync_fwrite((void *)(hdr), (size_t )10, out, & fwrite_state, & consumed);
      }
      }
#line 401
      if (tmp___0 < 10U) {
#line 402
        return (-1);
      }
      {
#line 403
      tag->curr_off += (off_t )consumed;
      {
#line 405
      tmp___1 = unsync_fwrite((void *)buf, (size_t )f->sz, out, & fwrite_state, & consumed);
      }
      }
#line 405
      if (tmp___1 < (size_t )f->sz) {
#line 406
        return (-1);
      }
#line 407
      tag->curr_off += (off_t )consumed;
    } else {
      {
      {
#line 410
      tmp___2 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 410
      if (tmp___2 < 10U) {
#line 411
        return (-1);
      }
      {
      {
#line 413
      tmp___3 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )f->sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 413
      if (tmp___3 < (size_t )f->sz) {
#line 414
        return (-1);
      }
#line 415
      tag->curr_off += (off_t )(10 + f->sz);
    }
    {
    {
#line 419
    free((void *)f->data);
    }
#line 420
    f->data = (unsigned char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 384
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return (0);
}
}
#line 428 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _build_v1_tag(char *buf , id3_t tag ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 432
  memset((void *)buf, 0, (size_t )128);
  }
  {
#line 433
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"TAG");
  }
  {
#line 434
  strncpy((char */* __restrict  */)(buf + 3), (char const   */* __restrict  */)(tag->v1.title),
          (size_t )30);
  }
  {
#line 435
  strncpy((char */* __restrict  */)(buf + 33), (char const   */* __restrict  */)(tag->v1.artist),
          (size_t )30);
  }
  {
#line 436
  strncpy((char */* __restrict  */)(buf + 63), (char const   */* __restrict  */)(tag->v1.album),
          (size_t )30);
  }
  {
#line 437
  strncpy((char */* __restrict  */)(buf + 93), (char const   */* __restrict  */)(tag->v1.year),
          (size_t )4);
  }
  {
#line 438
  strncpy((char */* __restrict  */)(buf + 97), (char const   */* __restrict  */)(tag->v1.comment),
          (size_t )30);
  }
  }
#line 439
  if ((int )*(buf + 125) == 0) {
#line 440
    *(buf + 126) = (char )tag->v1.track;
  }
#line 441
  *(buf + 127) = (char )tag->v1.genre;
#line 442
  return;
}
}
#line 446 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _calculate_tag_sizes(id3_t tag , int *pold_sz , int *pnew_sz ) 
{ 
  int old_tagsz ;
  int new_tagsz ;
  int frames_sz ;
  int padded_sz ;

  {
  {
  {
#line 455
  old_tagsz = id3_get_size(tag);
  }
  }
#line 456
  if (old_tagsz > 0) {
#line 457
    old_tagsz += 10;
  }
#line 458
  if (tag->has_footer) {
#line 459
    old_tagsz += 10;
  }
  {
#line 462
  if ((int )tag->version == 4) {
#line 462
    goto case_4;
  }
#line 465
  if ((int )tag->version == 3) {
#line 465
    goto case_3;
  }
#line 468
  goto switch_default;
  case_4: /* CIL Label */ 
  {
  {
#line 463
  frames_sz = _sum_v4_frame_sizes(tag);
  }
  }
#line 464
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 466
  frames_sz = _sum_v3_frame_sizes(tag);
  }
  }
#line 467
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 469
  abort();
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 501
  if ((unsigned int )tag->pad_policy == 1U) {
#line 501
    goto case_1;
  }
#line 504
  if ((unsigned int )tag->pad_policy == 2U) {
#line 504
    goto case_2;
  }
#line 474
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 476
  new_tagsz = frames_sz + 10;
#line 477
  if (old_tagsz >= new_tagsz) {
#line 478
    new_tagsz = old_tagsz;
  } else {
#line 481
    new_tagsz += 32;
#line 482
    if (new_tagsz <= 256) {
#line 484
      new_tagsz = 256;
    } else
#line 485
    if (new_tagsz <= 32768) {
#line 487
      padded_sz = 1;
#line 488
      new_tagsz --;
      {
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 489
        if (! (new_tagsz > 0)) {
#line 489
          goto while_break;
        }
#line 490
        padded_sz <<= 1;
#line 491
        new_tagsz >>= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 493
      new_tagsz = padded_sz;
    } else {
#line 496
      new_tagsz --;
#line 497
      new_tagsz = ((new_tagsz >> 14) + 1) << 14;
    }
  }
#line 500
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 502
  new_tagsz = frames_sz + 10;
#line 503
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 505
  new_tagsz = frames_sz + 10;
#line 506
  if (tag->requested_sz > new_tagsz) {
#line 507
    new_tagsz = tag->requested_sz;
  }
#line 508
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 513
  if (tag->append_req) {
#line 514
    new_tagsz = frames_sz + 20;
  }
#line 517
  if (frames_sz == 0) {
#line 518
    new_tagsz = 0;
  }
#line 521
  tag->tagsz = new_tagsz;
#line 522
  if (tag->tagsz) {
#line 523
    tag->tagsz -= 10;
  }
#line 524
  if (tag->append_req) {
#line 525
    tag->tagsz -= 10;
  }
#line 528
  *pold_sz = old_tagsz;
#line 529
  *pnew_sz = new_tagsz;
#line 530
  return;
}
}
#line 533 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_tag(id3_t tag , FILE *out ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 536
  tmp = id3_frame_count(tag);
  }
#line 536
  nframes = tmp;
  }
#line 538
  if (nframes > 0) {
    {
#line 540
    if ((int )tag->version == 4) {
#line 540
      goto case_4;
    }
#line 550
    if ((int )tag->version == 3) {
#line 550
      goto case_3;
    }
#line 556
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 541
    tag->has_footer = tag->append_req;
    {
#line 542
    tmp___0 = _write_v4_header(tag, out);
    }
    }
#line 542
    if (tmp___0 == -1) {
#line 543
      return (-1);
    }
    {
    {
#line 544
    tmp___1 = _write_v4_frames(tag, out);
    }
    }
#line 544
    if (tmp___1 == -1) {
#line 545
      return (-1);
    }
#line 546
    if (tag->append_req) {
      {
      {
#line 547
      tmp___2 = _write_v4_footer(tag, out);
      }
      }
#line 547
      if (tmp___2 == -1) {
#line 548
        return (-1);
      }
    }
#line 549
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 551
    tmp___3 = _write_v3_header(tag, out);
    }
    }
#line 551
    if (tmp___3 == -1) {
#line 552
      return (-1);
    }
    {
    {
#line 553
    tmp___4 = _write_v3_frames(tag, out);
    }
    }
#line 553
    if (tmp___4 == -1) {
#line 554
      return (-1);
    }
#line 555
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 557
    abort();
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 561
  return (0);
}
}
#line 568 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
int id3_write(id3_t tag ) 
{ 
  int old_tagsz ;
  int new_tagsz ;
  int sz ;
  int written ;
  int nframes ;
  char copybuf[4096] ;
  char v1buf[128] ;
  off_t new_offset ;
  char *tmpfname ;
  char *p ;
  int fd ;
  int err ;
  int write_in_place ;
  struct stat stbuf ;
  fpos_t pos_save ;
  FILE *out ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  int *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  int *tmp___46 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
#line 578
  tmpfname = (char *)((void *)0);
#line 582
  out = (FILE *)((void *)0);
#line 585
  if (! tag->seekable) {
    {
    {
#line 586
    tmp = __errno_location();
    }
#line 586
    *tmp = 22;
    }
#line 587
    return (-1);
  }
#line 589
  if (tag->mode == 0) {
    {
    {
#line 590
    tmp___0 = __errno_location();
    }
#line 590
    *tmp___0 = 13;
    }
#line 591
    return (-1);
  }
  {
  {
#line 595
  nframes = id3_frame_count(tag);
  }
  }
#line 598
  if ((int )tag->version < 2) {
    {
    {
#line 599
    tmp___1 = __errno_location();
    }
#line 599
    *tmp___1 = 22;
    }
#line 600
    return (-1);
  } else
#line 598
  if ((int )tag->version > 4) {
    {
    {
#line 599
    tmp___1 = __errno_location();
    }
#line 599
    *tmp___1 = 22;
    }
#line 600
    return (-1);
  }
#line 604
  if ((int )tag->version == 2) {
    {
    {
#line 605
    tmp___3 = id3_set_version(tag, (enum id3_version )3);
    }
    }
#line 605
    if (tmp___3 == -1) {
      {
      {
#line 606
      tmp___2 = __errno_location();
      }
#line 606
      *tmp___2 = 22;
      }
#line 607
      return (-1);
    }
  }
#line 612
  if (tag->v1.requested) {
    {
    {
#line 613
    _build_v1_tag(v1buf, tag);
    }
    }
  }
  {
  {
#line 619
  _calculate_tag_sizes(tag, & old_tagsz, & new_tagsz);
  }
  }
#line 625
  if (tag->append == tag->append_req) {
#line 625
    if (tag->append) {
#line 625
      tmp___4 = 1;
    } else
#line 625
    if (new_tagsz == old_tagsz) {
#line 625
      tmp___4 = 1;
    } else {
#line 625
      tmp___4 = 0;
    }
  } else {
#line 625
    tmp___4 = 0;
  }
#line 625
  write_in_place = tmp___4;
#line 637
  if (write_in_place) {
    {
    {
#line 644
    out = tmpfile();
    }
    }
#line 645
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 646
      goto error_free;
    }
    {
    {
#line 651
    _write_tag(tag, out);
    }
    {
#line 654
    tmp___7 = ftell(out);
    }
    }
#line 654
    if (tmp___7 < (long )new_tagsz) {
#line 655
      if (tag->append_req) {
        {
        {
#line 656
        abort();
        }
        }
      } else {
        {
        {
#line 658
        tmp___5 = ftell(out);
        }
#line 658
        sz = (int )((long )new_tagsz - tmp___5);
        }
        {
        {
#line 659
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 659
          if (! (sz > 0)) {
#line 659
            goto while_break;
          }
          {
          {
#line 660
          tmp___6 = _IO_putc(0, out);
          }
          }
#line 660
          if (tmp___6 == -1) {
#line 661
            goto error_free;
          }
#line 662
          sz --;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 668
    if (tag->v1.requested) {
#line 668
      if (tag->append_req) {
        {
        {
#line 669
        tmp___8 = fwrite((void const   */* __restrict  */)(v1buf), (size_t )1, (size_t )128,
                         (FILE */* __restrict  */)out);
        }
        }
#line 669
        if (tmp___8 < 128U) {
#line 670
          goto error_free;
        }
      }
    }
    {
    {
#line 674
    rewind(out);
    }
    {
#line 675
    tmp___9 = fseek(tag->fp, tag->offset, 0);
    }
    }
#line 675
    if (tmp___9 == -1) {
#line 676
      goto error_free;
    }
    {
    {
#line 677
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 677
      tmp___11 = fread((void */* __restrict  */)(copybuf), (size_t )1, (size_t )4096,
                       (FILE */* __restrict  */)out);
      }
#line 677
      sz = (int )tmp___11;
      }
#line 677
      if (! (sz > 0)) {
#line 677
        goto while_break___0;
      }
      {
      {
#line 678
      tmp___10 = fwrite((void const   */* __restrict  */)(copybuf), (size_t )1, (size_t )sz,
                        (FILE */* __restrict  */)tag->fp);
      }
      }
#line 678
      if (tmp___10 < (size_t )sz) {
#line 679
        goto error_free;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 683
    fclose(out);
    }
#line 683
    out = (FILE *)((void *)0);
    }
#line 687
    if (tag->v1.requested) {
#line 687
      if (! tag->append_req) {
#line 688
        if (tag->v1.exists) {
#line 688
          tmp___12 = -128;
        } else {
#line 688
          tmp___12 = 0;
        }
        {
        {
#line 688
        tmp___13 = fseek(tag->fp, (long )tmp___12, 2);
        }
        }
#line 688
        if (tmp___13 == -1) {
#line 689
          goto error_free;
        }
        {
        {
#line 690
        tmp___14 = fwrite((void const   */* __restrict  */)(v1buf), (size_t )1, (size_t )128,
                          (FILE */* __restrict  */)tag->fp);
        }
        }
#line 690
        if (tmp___14 < 128U) {
#line 691
          goto error_free;
        }
      }
    }
#line 696
    if (new_tagsz < old_tagsz) {
#line 698
      if (tag->v1.requested) {
#line 698
        tmp___15 = 128;
      } else {
#line 698
        tmp___15 = 0;
      }
      {
      {
#line 698
      tmp___16 = fileno(tag->fp);
      }
      {
#line 698
      tmp___17 = ftruncate(tmp___16, (tag->offset + (off_t )new_tagsz) + (off_t )tmp___15);
      }
      }
#line 698
      if (tmp___17 == -1) {
#line 700
        goto error_free;
      }
    } else
#line 701
    if (tag->v1.exists) {
#line 701
      if (! tag->v1.requested) {
        {
        {
#line 703
        tmp___18 = fseek(tag->fp, -128L, 2);
        }
        }
#line 703
        if (tmp___18 == -1) {
#line 704
          goto error_free;
        }
        {
        {
#line 705
        tmp___19 = ftell(tag->fp);
        }
        {
#line 705
        tmp___20 = fileno(tag->fp);
        }
        {
#line 705
        tmp___21 = ftruncate(tmp___20, (size_t )tmp___19);
        }
        }
#line 705
        if (tmp___21 == -1) {
#line 706
          goto error_free;
        }
      }
    }
  } else {
#line 721
    if (tag->fname) {
      {
      {
#line 722
      tmp___22 = strlen((char const   *)tag->fname);
      }
      {
#line 722
      tmp___23 = malloc(tmp___22 + 16U);
      }
#line 722
      tmpfname = (char *)tmp___23;
      }
#line 723
      if ((unsigned long )tmpfname == (unsigned long )((void *)0)) {
#line 724
        return (-1);
      }
      {
      {
#line 725
      strcpy((char */* __restrict  */)tmpfname, (char const   */* __restrict  */)tag->fname);
      }
      {
#line 726
      p = strrchr((char const   *)tmpfname, '/');
      }
      }
#line 726
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 727
        p = tmpfname;
      } else {
#line 729
        p ++;
      }
      {
      {
#line 730
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"_id3XXXXXX");
      }
      }
    } else {
      {
      {
#line 732
      tmp___24 = malloc((size_t )20);
      }
#line 732
      tmpfname = (char *)tmp___24;
      }
#line 733
      if ((unsigned long )tmpfname == (unsigned long )((void *)0)) {
#line 734
        return (-1);
      }
      {
      {
#line 739
      strcpy((char */* __restrict  */)tmpfname, (char const   */* __restrict  */)"/tmp/_id3XXXXXX");
      }
      }
    }
    {
    {
#line 743
    fd = xmkstemp___0(tmpfname);
    }
    }
#line 744
    if (fd == -1) {
      {
      {
#line 745
      tmp___25 = __errno_location();
      }
      {
#line 745
      tmp___26 = strerror(*tmp___25);
      }
      {
#line 745
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"id3: error opening temp file: %s\n",
              tmp___26);
      }
      }
#line 746
      goto error_free;
    }
    {
    {
#line 748
    out = fdopen(fd, "wb");
    }
    }
#line 749
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
      {
#line 750
      tmp___27 = __errno_location();
      }
      {
#line 750
      tmp___28 = strerror(*tmp___27);
      }
      {
#line 750
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"id3: error in fdopen: %s\n",
              tmp___28);
      }
      }
#line 751
      goto error_free;
    }
    {
    {
#line 755
    tmp___29 = fileno(tag->fp);
    }
    {
#line 755
    fstat(tmp___29, & stbuf);
    }
    {
#line 756
    chmod((char const   *)tmpfname, stbuf.st_mode);
    }
#line 759
    tag->curr_off = (off_t )0;
    }
#line 764
    if (tag->append_req) {
#line 765
      if (tag->append) {
        {
        {
#line 767
        tmp___30 = fseek(tag->fp, 0L, 0);
        }
        }
#line 767
        if (tmp___30 == -1) {
#line 768
          goto error_free;
        }
#line 769
        tag->curr_off = (off_t )0;
        {
        {
#line 770
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 771
          if (tag->curr_off >= tag->offset) {
#line 772
            goto while_break___1;
          }
#line 773
          sz = (int )(tag->offset - tag->curr_off);
#line 774
          if (sz > 4096) {
#line 775
            sz = 4096;
          }
          {
          {
#line 776
          tmp___31 = fread((void */* __restrict  */)(copybuf), (size_t )1, (size_t )sz,
                           (FILE */* __restrict  */)tag->fp);
          }
#line 776
          written = (int )tmp___31;
          }
#line 777
          if (written < sz) {
#line 778
            goto error_free;
          }
#line 779
          tag->curr_off += (off_t )written;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 783
        tmp___32 = fseek(tag->fp, (long )old_tagsz, 0);
        }
        }
#line 783
        if (tmp___32 == -1) {
#line 784
          goto error_free;
        }
#line 785
        tag->curr_off = (off_t )old_tagsz;
        {
        {
#line 786
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
          {
          {
#line 786
          tmp___34 = fread((void */* __restrict  */)(copybuf), (size_t )1, (size_t )4096,
                           (FILE */* __restrict  */)tag->fp);
          }
#line 786
          sz = (int )tmp___34;
          }
#line 786
          if (! (sz > 0)) {
#line 786
            goto while_break___2;
          }
          {
          {
#line 787
          tmp___33 = fwrite((void const   */* __restrict  */)(copybuf), (size_t )1,
                            (size_t )sz, (FILE */* __restrict  */)out);
          }
          }
#line 787
          if (tmp___33 < (size_t )sz) {
#line 788
            goto error_free;
          }
#line 789
          tag->curr_off += (off_t )sz;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 793
      if (tag->v1.exists) {
        {
        {
#line 795
        tmp___35 = fseek(tag->fp, -128L, 1);
        }
        }
#line 795
        if (tmp___35 == -1) {
#line 796
          goto error_free;
        }
#line 797
        tag->curr_off -= 128L;
      }
    }
    {
#line 801
    new_offset = tag->curr_off;
    {
#line 806
    _write_tag(tag, out);
    }
    }
#line 811
    if (! tag->append_req) {
#line 813
      if (tag->curr_off != (off_t )new_tagsz) {
#line 814
        if (new_tagsz > 0) {
          {
          {
#line 816
          fseek(out, (long )(new_tagsz - 1), 0);
          }
          {
#line 817
          _IO_putc(0, out);
          }
          }
        } else {
          {
          {
#line 819
          rewind(out);
          }
          }
        }
      }
    }
#line 830
    if (! tag->append_req) {
      {
      {
#line 834
      fseek(tag->fp, tag->offset + (off_t )old_tagsz, 0);
      }
      }
      {
      {
#line 835
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 835
        tmp___37 = fread((void */* __restrict  */)(copybuf), (size_t )1, (size_t )4096,
                         (FILE */* __restrict  */)tag->fp);
        }
#line 835
        sz = (int )tmp___37;
        }
#line 835
        if (! (sz > 0)) {
#line 835
          goto while_break___3;
        }
        {
        {
#line 836
        tmp___36 = fwrite((void const   */* __restrict  */)(copybuf), (size_t )1,
                          (size_t )sz, (FILE */* __restrict  */)out);
        }
        }
#line 836
        if (tmp___36 < (size_t )sz) {
#line 837
          goto error_free;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 842
      if (tag->v1.requested) {
#line 843
        if (tag->v1.exists) {
#line 843
          tmp___38 = -128;
        } else {
#line 843
          tmp___38 = 0;
        }
        {
        {
#line 843
        tmp___39 = fseek(out, (long )tmp___38, 2);
        }
        }
#line 843
        if (tmp___39 == -1) {
#line 844
          goto error_free;
        }
        {
        {
#line 845
        tmp___40 = fwrite((void const   */* __restrict  */)(v1buf), (size_t )1, (size_t )128,
                          (FILE */* __restrict  */)out);
        }
        }
#line 845
        if (tmp___40 < 128U) {
#line 846
          goto error_free;
        }
      }
    } else
#line 853
    if (tag->v1.requested) {
      {
      {
#line 854
      tmp___41 = fwrite((void const   */* __restrict  */)(v1buf), (size_t )1, (size_t )128,
                        (FILE */* __restrict  */)out);
      }
      }
#line 854
      if (tmp___41 < 128U) {
#line 855
        goto error_free;
      }
    }
    {
#line 858
    tag->append = tag->append_req;
#line 859
    tag->offset = new_offset;
    {
#line 862
    fclose(out);
    }
#line 862
    out = (FILE *)((void *)0);
    }
#line 867
    if ((unsigned long )tag->fname == (unsigned long )((void *)0)) {
      {
      {
#line 868
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"id3: no filename, leaving output in %s\n",
              tmpfname);
      }
      }
#line 869
      goto error_free;
    }
    {
    {
#line 872
    fgetpos((FILE */* __restrict  */)tag->fp, (fpos_t */* __restrict  */)(& pos_save));
    }
    {
#line 873
    fclose(tag->fp);
    }
#line 873
    tag->fp = (FILE *)((void *)0);
    {
#line 874
    tmp___44 = xrename___0((char const   *)tmpfname, (char const   *)tag->fname);
    }
    }
#line 874
    if (tmp___44 == -1) {
      {
      {
#line 875
      tmp___42 = __errno_location();
      }
      {
#line 875
      tmp___43 = strerror(*tmp___42);
      }
      {
#line 875
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"id3: error moving %s to %s: %s\n",
              tmpfname, tag->fname, tmp___43);
      }
      }
#line 877
      goto error_free;
    }
    {
    {
#line 879
    free((void *)tmpfname);
    }
#line 879
    tmpfname = (char *)((void *)0);
    {
#line 882
    tag->fp = fopen((char const   */* __restrict  */)tag->fname, (char const   */* __restrict  */)"rb+");
    }
    }
#line 883
    if ((unsigned long )tag->fp == (unsigned long )((void *)0)) {
#line 884
      goto error_free;
    }
    {
    {
#line 885
    fsetpos(tag->fp, (fpos_t const   *)(& pos_save));
    }
    }
  }
#line 889
  return (0);
  error_free: 
  {
  {
#line 892
  tmp___45 = __errno_location();
  }
#line 892
  err = *tmp___45;
  }
#line 894
  if (tmpfname) {
    {
    {
#line 895
    free((void *)tmpfname);
    }
    }
  }
#line 896
  if (out) {
    {
    {
#line 897
    fclose(out);
    }
    }
  }
  {
  {
#line 899
  tmp___46 = __errno_location();
  }
#line 899
  *tmp___46 = err;
  }
#line 900
  return (-1);
}
}
#line 910 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static char sfx___0[7]  = {      (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'A',      (char )'A',      (char )'\000'};
#line 907 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xmkstemp___0(char *template ) 
{ 
  char *p ;
  int fd ;
  int i ;
  int done ;
  size_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 914
  tmp = strlen((char const   *)template);
  }
#line 914
  p = (template + tmp) - 6;
  {
#line 915
  tmp___1 = strcmp((char const   *)p, "XXXXXX");
  }
  }
#line 915
  if (tmp___1 != 0) {
    {
    {
#line 916
    tmp___0 = __errno_location();
    }
#line 916
    *tmp___0 = 22;
    }
#line 917
    return (-1);
  }
  {
  {
#line 920
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 921
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(sfx___0));
    }
#line 924
    done = 0;
#line 924
    i = 5;
    }
    {
    {
#line 925
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 925
      if (! done) {
#line 925
        if (! (i >= 0)) {
#line 925
          goto while_break___0;
        }
      } else {
#line 925
        goto while_break___0;
      }
#line 926
      sfx___0[i] = (char )((int )sfx___0[i] + 1);
#line 927
      if ((int )sfx___0[i] > 90) {
#line 928
        sfx___0[i] = (char )'A';
#line 929
        i --;
      } else {
#line 931
        done = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 934
    if (! done) {
      {
      {
#line 935
      tmp___2 = __errno_location();
      }
#line 935
      *tmp___2 = 17;
      }
#line 936
      return (-1);
    }
    {
    {
#line 940
    fd = open((char const   *)template, 194, 384);
    }
    }
#line 920
    if (fd == -1) {
      {
      {
#line 920
      tmp___3 = __errno_location();
      }
      }
#line 920
      if (! (*tmp___3 == 17)) {
#line 920
        goto while_break;
      }
    } else {
#line 920
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return (fd);
}
}
#line 952 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xrename___0(char const   *oldpath , char const   *newpath ) 
{ 
  FILE *in ;
  FILE *out ;
  char buf[4096] ;
  size_t sz ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 959
  tmp = strcmp(oldpath, newpath);
  }
  }
#line 959
  if (tmp == 0) {
#line 960
    return (0);
  }
  {
  {
#line 967
  tmp___8 = rename(oldpath, newpath);
  }
  }
#line 967
  if (tmp___8 == -1) {
    {
    {
#line 968
    tmp___7 = __errno_location();
    }
    }
#line 968
    if (*tmp___7 == 18) {
      {
      {
#line 970
      tmp___0 = unlink(newpath);
      }
      }
#line 970
      if (tmp___0 == -1) {
        {
        {
#line 970
        tmp___1 = __errno_location();
        }
        }
#line 970
        if (*tmp___1 != 2) {
#line 971
          return (-1);
        }
      }
      {
      {
#line 973
      in = fopen((char const   */* __restrict  */)oldpath, (char const   */* __restrict  */)"rb");
      }
      }
#line 974
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 975
        return (-1);
      }
      {
      {
#line 976
      out = fopen((char const   */* __restrict  */)newpath, (char const   */* __restrict  */)"wb");
      }
      }
#line 977
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        {
        {
#line 978
        fclose(in);
        }
        }
#line 979
        return (-1);
      }
      {
      {
#line 982
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 982
        sz = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )4096, (FILE */* __restrict  */)in);
        }
        }
#line 982
        if (! (sz > 0U)) {
#line 982
          goto while_break;
        }
        {
        {
#line 983
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, sz, (FILE */* __restrict  */)out);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 985
      tmp___2 = ferror(in);
      }
      }
#line 985
      if (tmp___2) {
        {
        {
#line 986
        fclose(in);
        }
        {
#line 987
        fclose(out);
        }
        }
#line 988
        return (-1);
      } else {
        {
        {
#line 985
        tmp___3 = ferror(out);
        }
        }
#line 985
        if (tmp___3) {
          {
          {
#line 986
          fclose(in);
          }
          {
#line 987
          fclose(out);
          }
          }
#line 988
          return (-1);
        }
      }
      {
      {
#line 990
      tmp___4 = fclose(in);
      }
      }
#line 990
      if (tmp___4 == -1) {
        {
        {
#line 991
        fclose(out);
        }
        }
#line 992
        return (-1);
      }
      {
      {
#line 994
      tmp___5 = fclose(out);
      }
      }
#line 994
      if (tmp___5 == -1) {
#line 995
        return (-1);
      }
      {
      {
#line 997
      tmp___6 = unlink(oldpath);
      }
      }
#line 997
      if (tmp___6 == -1) {
#line 998
        return (-1);
      }
    } else {
#line 1000
      return (-1);
    }
  }
#line 1004
  return (0);
}
}
#line 176 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
static double limiter___0(double x ) 
{ 
  double xp ;
  double tmp ;
  double tmp___0 ;

  {
#line 181
  if (x < - lmtr_lvl) {
    {
    {
#line 182
    tmp = tanh((x + lmtr_lvl) / ((double )1 - lmtr_lvl));
    }
#line 182
    xp = tmp * ((double )1 - lmtr_lvl) - lmtr_lvl;
    }
  } else
#line 183
  if (x <= lmtr_lvl) {
#line 184
    xp = x;
  } else {
    {
    {
#line 186
    tmp___0 = tanh((x - lmtr_lvl) / ((double )1 - lmtr_lvl));
    }
#line 186
    xp = tmp___0 * ((double )1 - lmtr_lvl) + lmtr_lvl;
    }
  }
#line 188
  return (xp);
}
}
#line 200 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
static int _do_apply_gain___0(int read_fd , int write_fd , char *filename , double gain ,
                              struct signal_info *si ) 
{ 
  AFfilehandle fhin ;
  AFfilehandle fhout ;
  AFframecount framecount ;
  AFfilesetup setup ;
  int i ;
  int c ;
  int af_fmt ;
  int src_bytes_per_samp ;
  int dst_bytes_per_samp ;
  int src_framesz ;
  int dst_framesz ;
  int channels ;
  int samp_fmt ;
  int src_samp_width ;
  int dst_samp_width ;
  int fmt_vers ;
  unsigned int samp_rate ;
  unsigned int frames_done ;
  unsigned int nclippings ;
  long sample ;
  long src_samplemax ;
  long src_samplemin ;
  long dst_samplemax ;
  long dst_samplemin ;
  double sample_d ;
  float clip_loss ;
  float last_progress ;
  float progress ;
  char prefix_buf[18] ;
  unsigned char *src_buf ;
  unsigned char *dst_buf ;
  unsigned char *src_pos ;
  unsigned char *dst_pos ;
  int frames_in_buf ;
  int frames_recvd ;
  int use_limiter_this_file ;
  int min_pos_clipped ;
  int max_neg_clipped ;
  int32_t *lut ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char *tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;
  void *tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  void *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;

  {
  {
#line 215
  last_progress = (float )0;
#line 218
  src_buf = (unsigned char *)((void *)0);
#line 218
  dst_buf = (unsigned char *)((void *)0);
#line 222
  min_pos_clipped = 0;
#line 223
  max_neg_clipped = 0;
#line 224
  lut = (int32_t *)((void *)0);
  {
#line 229
  setup = afNewFileSetup();
  }
  }
#line 230
  if ((unsigned long )setup == (unsigned long )((struct _AFfilesetup *)0)) {
    {
    {
#line 231
    tmp = gettext("%s: afNewFileSetup failed\n");
    }
    {
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            progname);
    }
    }
#line 232
    goto error1;
  }
  {
  {
#line 235
  fhin = afOpenFD(read_fd, "r", (AFfilesetup )((void *)0));
  }
  }
#line 236
  if ((unsigned long )fhin == (unsigned long )((struct _AFfilehandle *)0)) {
    {
    {
#line 237
    tmp___0 = gettext("%s: afOpenFD failed\n");
    }
    {
#line 237
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            progname);
    }
    }
#line 238
    goto error2;
  }
  {
  {
#line 242
  af_fmt = afGetFileFormat(fhin, & fmt_vers);
  }
  {
#line 243
  afInitFileFormat(setup, af_fmt);
  }
  {
#line 244
  tmp___1 = afGetByteOrder(fhin, 1001);
  }
  {
#line 244
  afInitByteOrder(setup, 1001, tmp___1);
  }
  {
#line 245
  channels = afGetChannels(fhin, 1001);
  }
  {
#line 246
  afInitChannels(setup, 1001, channels);
  }
  {
#line 247
  afGetSampleFormat(fhin, 1001, & samp_fmt, & src_samp_width);
  }
#line 248
  dst_samp_width = src_samp_width;
  }
#line 249
  if (output_bitwidth) {
#line 250
    dst_samp_width = output_bitwidth;
#line 251
    if (af_fmt == 4) {
#line 252
      if (dst_samp_width > 8) {
#line 252
        samp_fmt = 401;
      } else {
#line 252
        samp_fmt = 402;
      }
    }
  }
  {
  {
#line 254
  afInitSampleFormat(setup, 1001, samp_fmt, dst_samp_width);
  }
  {
#line 255
  tmp___2 = afGetRate(fhin, 1001);
  }
  {
#line 255
  afInitRate(setup, 1001, tmp___2);
  }
  {
#line 256
  tmp___3 = afGetRate(fhin, 1001);
  }
#line 256
  samp_rate = (unsigned int )tmp___3;
  {
#line 258
  fhout = afOpenFD(write_fd, "w", setup);
  }
  }
#line 259
  if ((unsigned long )fhout == (unsigned long )((struct _AFfilehandle *)0)) {
    {
    {
#line 260
    tmp___4 = gettext("%s: afOpenFD failed\n");
    }
    {
#line 260
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
            progname);
    }
    }
#line 261
    goto error3;
  }
  {
  {
#line 265
  afSetVirtualSampleFormat(fhin, 1001, 401, src_samp_width);
  }
  {
#line 266
  afSetVirtualSampleFormat(fhout, 1001, 401, dst_samp_width);
  }
#line 268
  src_bytes_per_samp = (src_samp_width - 1) / 8 + 1;
#line 269
  src_samplemax = (long )((1 << (src_bytes_per_samp * 8 - 1)) - 1);
#line 270
  src_samplemin = - src_samplemax - 1L;
#line 271
  dst_bytes_per_samp = (dst_samp_width - 1) / 8 + 1;
#line 272
  dst_samplemax = (long )((1 << (dst_bytes_per_samp * 8 - 1)) - 1);
#line 273
  dst_samplemin = - dst_samplemax - 1L;
  {
#line 276
  framecount = afGetFrameCount(fhin, 1001);
  }
#line 279
  frames_in_buf = (int )(samp_rate / 100U);
  {
#line 280
  tmp___5 = afGetFrameSize(fhin, 1001, 1);
  }
#line 280
  src_framesz = (int )tmp___5;
  {
#line 281
  tmp___6 = afGetFrameSize(fhout, 1001, 1);
  }
#line 281
  dst_framesz = (int )tmp___6;
  {
#line 282
  tmp___7 = xmalloc((size_t )(frames_in_buf * src_framesz));
  }
#line 282
  src_buf = (unsigned char *)tmp___7;
  {
#line 283
  tmp___8 = xmalloc((size_t )(frames_in_buf * dst_framesz));
  }
#line 283
  dst_buf = (unsigned char *)tmp___8;
  }
#line 290
  if (use_limiter) {
#line 290
    if (gain > 1.0) {
#line 290
      tmp___9 = 1;
    } else {
#line 290
      tmp___9 = 0;
    }
  } else {
#line 290
    tmp___9 = 0;
  }
#line 290
  use_limiter_this_file = tmp___9;
#line 291
  if (use_limiter_this_file) {
#line 291
    if (si) {
#line 292
      if ((double )si->max_sample * gain <= (double )src_samplemax) {
#line 292
        if ((double )si->min_sample * gain >= (double )src_samplemin) {
#line 294
          use_limiter_this_file = 0;
        }
      }
    }
  }
#line 300
  if (dst_bytes_per_samp != src_bytes_per_samp) {
    {
    {
#line 301
    tmp___10 = pow(256.0, (double )(dst_bytes_per_samp - src_bytes_per_samp));
    }
#line 301
    gain *= tmp___10;
    }
  }
#line 309
  if (src_bytes_per_samp <= 2) {
    {
    {
#line 310
    tmp___11 = xmalloc((size_t )((unsigned long )((src_samplemax - src_samplemin) + 1L) * sizeof(int32_t )));
    }
#line 310
    lut = (int32_t *)tmp___11;
#line 311
    lut -= src_samplemin;
#line 312
    min_pos_clipped = (int )(src_samplemax + 1L);
#line 313
    max_neg_clipped = (int )(src_samplemin - 1L);
    }
#line 314
    if (gain > 1.0) {
#line 315
      if (use_limiter_this_file) {
#line 317
        i = (int )src_samplemin;
        {
        {
#line 317
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 317
          if (! (i < 0)) {
#line 317
            goto while_break;
          }
          {
          {
#line 318
          tmp___12 = limiter___0(((double )i * gain) / (double )(- dst_samplemin));
          }
          {
#line 318
          tmp___13 = floor((double )(- dst_samplemin) * tmp___12 + 0.5);
          }
#line 318
          *(lut + i) = (int32_t )tmp___13;
#line 317
          i ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
        {
#line 319
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 319
          if (! ((long )i <= src_samplemax)) {
#line 319
            goto while_break___0;
          }
          {
          {
#line 320
          tmp___14 = limiter___0(((double )i * gain) / (double )dst_samplemax);
          }
          {
#line 320
          tmp___15 = floor((double )dst_samplemax * tmp___14 + 0.5);
          }
#line 320
          *(lut + i) = (int32_t )tmp___15;
#line 319
          i ++;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 323
        i = (int )src_samplemin;
        {
        {
#line 323
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 323
          if (! ((long )i <= src_samplemax)) {
#line 323
            goto while_break___1;
          }
          {
          {
#line 324
          tmp___16 = floor((double )i * gain + 0.5);
          }
#line 324
          sample = (long )tmp___16;
          }
#line 325
          if (sample > dst_samplemax) {
#line 326
            sample = dst_samplemax;
#line 327
            if (i < min_pos_clipped) {
#line 328
              min_pos_clipped = i;
            }
          } else
#line 329
          if (sample < dst_samplemin) {
#line 330
            sample = dst_samplemin;
#line 331
            if (i > max_neg_clipped) {
#line 332
              max_neg_clipped = i;
            }
          }
#line 334
          *(lut + i) = (int32_t )sample;
#line 323
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 339
      i = (int )src_samplemin;
      {
      {
#line 339
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 339
        if (! ((long )i <= src_samplemax)) {
#line 339
          goto while_break___2;
        }
        {
        {
#line 340
        tmp___17 = floor((double )i * gain + 0.5);
        }
#line 340
        *(lut + i) = (int32_t )tmp___17;
#line 339
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 355
  if (verbose >= 1) {
    {
    {
#line 356
    tmp___18 = basename(filename);
    }
    {
#line 356
    strncpy((char */* __restrict  */)(prefix_buf), (char const   */* __restrict  */)tmp___18,
            (size_t )17);
    }
#line 357
    prefix_buf[17] = (char)0;
    {
#line 358
    progress_callback(prefix_buf, (float )0.0);
    }
#line 359
    last_progress = (float )0.0;
    }
  }
#line 363
  frames_done = 0U;
#line 363
  nclippings = frames_done;
  {
  {
#line 364
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 364
    frames_recvd = afReadFrames(fhin, 1001, (void *)src_buf, frames_in_buf);
    }
    }
#line 364
    if (! (frames_recvd > 0)) {
#line 364
      goto while_break___3;
    }
#line 366
    if (lut) {
#line 370
      c = 0;
      {
      {
#line 370
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 370
        if (! (c < channels)) {
#line 370
          goto while_break___4;
        }
#line 371
        src_pos = src_buf + c * (src_framesz / channels);
#line 372
        dst_pos = dst_buf + c * (dst_framesz / channels);
#line 373
        i = 0;
        {
        {
#line 373
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 373
          if (! (i < frames_recvd)) {
#line 373
            goto while_break___5;
          }
          {
          {
#line 375
          sample = get_sample(src_pos, src_bytes_per_samp);
          }
          }
#line 377
          if (! use_limiter) {
#line 377
            if (sample >= (long )min_pos_clipped) {
#line 379
              nclippings ++;
            } else
#line 377
            if (sample <= (long )max_neg_clipped) {
#line 379
              nclippings ++;
            }
          }
          {
#line 381
          sample = (long )*(lut + sample);
          {
#line 383
          put_sample(sample, dst_pos, dst_bytes_per_samp);
          }
#line 385
          src_pos += src_framesz;
#line 386
          dst_pos += dst_framesz;
#line 373
          i ++;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 370
        c ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 394
      if (use_limiter_this_file) {
#line 394
        if (verbose >= 2) {
          {
          {
#line 395
          tmp___19 = gettext("%s: Warning: no lookup table available; this may be slow...\n");
          }
          {
#line 395
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19,
                  progname);
          }
          }
        }
      }
#line 399
      c = 0;
      {
      {
#line 399
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 399
        if (! (c < channels)) {
#line 399
          goto while_break___6;
        }
#line 400
        src_pos = src_buf + c * (src_framesz / channels);
#line 401
        dst_pos = dst_buf + c * (dst_framesz / channels);
#line 402
        i = 0;
        {
        {
#line 402
        while (1) {
          while_continue___16: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 402
          if (! (i < frames_recvd)) {
#line 402
            goto while_break___7;
          }
          {
          {
#line 404
          sample = get_sample(src_pos, src_bytes_per_samp);
          }
#line 407
          sample_d = (double )sample * gain;
          }
#line 409
          if (gain > 1.0) {
#line 410
            if (use_limiter_this_file) {
              {
              {
#line 412
              tmp___20 = limiter___0(sample_d / (double )dst_samplemax);
              }
              {
#line 412
              tmp___21 = floor((double )dst_samplemax * tmp___20 + 0.5);
              }
#line 412
              sample = (long )tmp___21;
              }
            } else {
              {
              {
#line 414
              tmp___22 = floor(sample_d + 0.5);
              }
#line 414
              sample = (long )tmp___22;
              }
#line 416
              if (sample_d > (double )dst_samplemax) {
#line 417
                sample = dst_samplemax;
#line 418
                nclippings ++;
              } else
#line 419
              if (sample_d < (double )dst_samplemin) {
#line 420
                sample = dst_samplemin;
#line 421
                nclippings ++;
              }
            }
          } else {
            {
            {
#line 425
            tmp___23 = floor(sample_d + 0.5);
            }
#line 425
            sample = (long )tmp___23;
            }
          }
          {
          {
#line 428
          put_sample(sample, dst_pos, dst_bytes_per_samp);
          }
#line 430
          src_pos += src_framesz;
#line 431
          dst_pos += dst_framesz;
#line 402
          i ++;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 399
        c ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
    {
#line 438
    tmp___25 = afWriteFrames(fhout, 1001, (void const   *)dst_buf, frames_recvd);
    }
    }
#line 438
    if (tmp___25 == -1) {
      {
      {
#line 439
      tmp___24 = gettext("%s: afWriteFrames failed\n");
      }
      {
#line 439
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              progname);
      }
      }
#line 440
      goto error4;
    }
#line 443
    frames_done += (unsigned int )frames_recvd;
#line 446
    if (verbose >= 1) {
#line 447
      progress = (float )frames_done / (float )framecount;
#line 448
      if ((double )progress >= (double )last_progress + 0.01) {
        {
        {
#line 449
        progress_callback(prefix_buf, progress);
        }
#line 450
        last_progress = (float )((double )last_progress + 0.01);
        }
      }
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 456
  if (verbose >= 1) {
    {
    {
#line 457
    progress_callback(prefix_buf, (float )1.0);
    }
    }
  }
#line 459
  if (! use_limiter_this_file) {
#line 460
    clip_loss = (float )nclippings / ((float )framecount * (float )channels);
#line 462
    if (verbose >= 2) {
#line 463
      if (nclippings) {
        {
        {
#line 464
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
        {
#line 465
        tmp___26 = gettext("%s: %d clippings performed, %.4f%% loss\n");
        }
        {
#line 465
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___26,
                progname, nclippings, (double )(clip_loss * (float )100));
        }
        }
      }
    } else
#line 468
    if (verbose >= 1) {
#line 469
      if ((double )clip_loss > 0.001) {
        {
        {
#line 470
        tmp___27 = gettext("%s: Warning: lost %0.2f%% of data due to clipping              \n");
        }
        {
#line 470
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___27,
                progname, (double )(clip_loss * (float )100));
        }
        }
      }
    }
  }
#line 477
  if (lut) {
    {
#line 479
    lut += src_samplemin;
    {
#line 480
    free((void *)lut);
    }
    }
  }
  {
  {
#line 483
  tmp___29 = afSyncFile(fhout);
  }
  }
#line 483
  if (tmp___29 < 0) {
    {
    {
#line 484
    tmp___28 = gettext("%s: afSyncFile failed\n");
    }
    {
#line 484
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___28,
            progname);
    }
    }
  }
  {
  {
#line 485
  afCloseFile(fhin);
  }
  {
#line 486
  afCloseFile(fhout);
  }
  {
#line 487
  afFreeFileSetup(setup);
  }
  {
#line 488
  free((void *)src_buf);
  }
  {
#line 489
  free((void *)dst_buf);
  }
  }
#line 491
  return (0);
  error4: 
  {
  {
#line 496
  free((void *)src_buf);
  }
  {
#line 497
  free((void *)dst_buf);
  }
  {
#line 498
  afCloseFile(fhout);
  }
  }
  error3: 
  {
  {
#line 500
  afCloseFile(fhin);
  }
  }
  error2: 
  {
  {
#line 502
  afFreeFileSetup(setup);
  }
  }
  error1: 
#line 504
  return (-1);
}
}
#line 626 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/adjust.c"
static char sfx___1[7]  = {      (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'A',      (char )'A',      (char )'\000'};
#line 98 "../nid3lib/nid3.h"
id3_t id3_open(char const   *fname , int mode ) ;
#line 99
int id3_close(id3_t tag ) ;
#line 110
int id3_set_unsync(id3_t tag , int unsync ) ;
#line 120
void id3_frame_delete(id3_frame_t f ) ;
#line 74 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/mpegadjust.c"
static int adjust_id3(char *fname , double gain ) 
{ 
  id3_t tag ;
  id3_frame_t fr ;
  int ret ;
  char prefix_buf[18] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 79
  ret = 1;
#line 83
  if (verbose >= 1) {
    {
    {
#line 84
    tmp = basename(fname);
    }
    {
#line 84
    strncpy((char */* __restrict  */)(prefix_buf), (char const   */* __restrict  */)tmp,
            (size_t )17);
    }
#line 85
    prefix_buf[17] = (char )'\000';
    {
#line 86
    progress_callback(prefix_buf, (float )0.0);
    }
    }
  }
  {
  {
#line 89
  tag = id3_open((char const   *)fname, 1);
  }
  }
#line 90
  if ((unsigned long )tag == (unsigned long )((void *)0)) {
#line 91
    return (-1);
  }
  {
  {
#line 93
  tmp___2 = fabs(gain);
  }
  }
#line 93
  if (tmp___2 < adjust_thresh) {
    {
    {
#line 95
    fr = id3_get_frame_by_id(tag, "RVA2");
    }
    }
#line 96
    if (fr) {
      {
      {
#line 97
      id3_frame_delete(fr);
      }
      }
    }
    {
    {
#line 98
    fr = id3_get_frame_by_id(tag, "XRVA");
    }
    }
#line 99
    if (fr) {
      {
      {
#line 100
      id3_frame_delete(fr);
      }
      }
    }
  } else {
    {
    {
#line 101
    tmp___1 = id3_rva_set(tag, "normalize", (enum id3_rva_channel )1, (float )gain);
    }
    }
#line 101
    if (tmp___1 == -1) {
      {
      {
#line 102
      tmp___0 = gettext("%s: error reading ID3 tag\n");
      }
      {
#line 102
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              progname);
      }
#line 103
      ret = -1;
      }
#line 104
      goto error_close;
    }
  }
#line 107
  if (id3_compat) {
    {
    {
#line 108
    tmp___4 = id3_set_version(tag, (enum id3_version )3);
    }
    }
#line 108
    if (tmp___4 == -1) {
      {
      {
#line 109
      tmp___3 = gettext("%s: error converting tag\n");
      }
      {
#line 109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              progname);
      }
#line 110
      ret = -1;
      }
    }
  } else {
    {
    {
#line 113
    tmp___6 = id3_set_version(tag, (enum id3_version )4);
    }
    }
#line 113
    if (tmp___6 == -1) {
      {
      {
#line 114
      tmp___5 = gettext("%s: error converting tag\n");
      }
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              progname);
      }
#line 115
      ret = -1;
      }
    }
  }
#line 118
  if (id3_unsync) {
    {
    {
#line 119
    id3_set_unsync(tag, 1);
    }
    }
  }
  {
  {
#line 120
  tmp___8 = id3_write(tag);
  }
  }
#line 120
  if (tmp___8 == -1) {
    {
    {
#line 121
    tmp___7 = gettext("%s: error writing ID3 tag\n");
    }
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            progname);
    }
#line 122
    ret = -1;
    }
  }
  error_close: 
  {
  {
#line 126
  id3_close(tag);
  }
  }
#line 129
  if (verbose >= 1) {
    {
    {
#line 130
    progress_callback(prefix_buf, (float )1.0);
    }
    }
  }
#line 132
  return (ret);
}
}
#line 144 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/mpegadjust.c"
int apply_gain_mp3(char *filename , double gain , struct signal_info *si ) 
{ 
  int ret ;
  double tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 147
  ret = 0;
  {
#line 149
  tmp = log10(gain);
  }
#line 149
  gain = (double )20 * tmp;
  }
#line 151
  if (! batch_mode) {
#line 151
    if (verbose >= 1) {
      {
      {
#line 152
      tmp___0 = gettext("Applying adjustment of %0.2fdB to %s...\n");
      }
      {
#line 152
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              gain, filename);
      }
      }
    }
  }
  {
  {
#line 159
  ret = adjust_id3(filename, gain);
  }
  }
#line 162
  return (ret);
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 675 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 101 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
void id3_set_size(id3_t tag , int size ) ;
#line 104
void id3_set_pad_policy(id3_t tag , enum id3_pad_policy policy ) ;
#line 105
enum id3_pad_policy id3_get_pad_policy(id3_t tag ) ;
#line 107
id3_frame_t id3_get_frame(id3_t tag , int n ) ;
#line 109
int id3_set_append(id3_t tag , int append ) ;
#line 113
char *id3_frame_get_id(id3_frame_t f ) ;
#line 114
int id3_frame_set_id(id3_frame_t f , char const   *id ) ;
#line 116
int id3_frame_set_raw(id3_frame_t f , void *buf , int size ) ;
#line 128
void id3_strip(id3_t tag ) ;
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned short v3_fflag_masks[8]  = 
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
  {      (unsigned short)32768,      (unsigned short)16384,      (unsigned short)8192,      (unsigned short)32, 
        (unsigned short)128,      (unsigned short)64,      (unsigned short)0,      (unsigned short)0};
#line 77 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned short v4_fflag_masks[8]  = 
#line 77
  {      (unsigned short)16384,      (unsigned short)8192,      (unsigned short)4096,      (unsigned short)64, 
        (unsigned short)8,      (unsigned short)4,      (unsigned short)2,      (unsigned short)1};
#line 81 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
__inline static unsigned int get_be_int(unsigned char *buf ) 
{ 
  unsigned int retval ;

  {
#line 85
  retval = (unsigned int )*(buf + 0);
#line 86
  retval <<= 8;
#line 87
  retval += (unsigned int )*(buf + 1);
#line 88
  retval <<= 8;
#line 89
  retval += (unsigned int )*(buf + 2);
#line 90
  retval <<= 8;
#line 91
  retval += (unsigned int )*(buf + 3);
#line 92
  return (retval);
}
}
#line 96 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned int unsyncsafe_int(unsigned char *buf ) 
{ 
  unsigned int retval ;

  {
#line 99
  retval = 0U;
#line 100
  retval = (unsigned int )*(buf + 0);
#line 101
  retval <<= 7;
#line 102
  retval |= (unsigned int )*(buf + 1);
#line 103
  retval <<= 7;
#line 104
  retval |= (unsigned int )*(buf + 2);
#line 105
  retval <<= 7;
#line 106
  retval |= (unsigned int )*(buf + 3);
#line 107
  return (retval);
}
}
#line 114 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int decode_unsync(unsigned char *dest , unsigned char *src , int sz ) 
{ 
  unsigned char *dest_save ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 117
  dest_save = dest;
  {
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (sz > 0)) {
#line 119
      goto while_break;
    }
#line 120
    if ((int )*src != 255) {
#line 121
      tmp = dest;
#line 121
      dest ++;
#line 121
      tmp___0 = src;
#line 121
      src ++;
#line 121
      *tmp = *tmp___0;
#line 122
      sz --;
    } else {
#line 124
      tmp___1 = dest;
#line 124
      dest ++;
#line 124
      tmp___2 = src;
#line 124
      src ++;
#line 124
      *tmp___1 = *tmp___2;
#line 125
      sz --;
#line 126
      if (sz <= 0) {
#line 127
        goto while_break;
      }
#line 128
      if ((int )*src == 0) {
#line 129
        src ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return ((int )(dest - dest_save));
}
}
#line 136 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
id3_frame_t _id3_frame_new(void) 
{ 
  id3_frame_t f ;
  void *tmp ;

  {
  {
  {
#line 141
  tmp = calloc((size_t )1, (size_t )sizeof(struct id3_frame_struct ));
  }
#line 141
  f = (id3_frame_t )tmp;
  }
#line 142
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 143
    return ((id3_frame_t )((void *)0));
  }
#line 144
  f->offset = (off_t )-1;
#line 146
  return (f);
}
}
#line 149 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void _id3_frame_destroy(id3_frame_t f ) 
{ 


  {
#line 152
  if (f->data) {
    {
    {
#line 153
    free((void *)f->data);
    }
    }
  }
  {
  {
#line 154
  free((void *)f);
  }
  }
#line 155
  return;
}
}
#line 157 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void _id3_frame_add(id3_t tag , id3_frame_t f ) 
{ 
  id3_frame_t tmp ;

  {
#line 160
  f->next = (struct id3_frame_struct *)((void *)0);
#line 161
  if ((unsigned long )tag->frame_tl == (unsigned long )((void *)0)) {
#line 162
    tmp = f;
#line 162
    tag->frame_tl = tmp;
#line 162
    tag->frame_hd = tmp;
  } else {
#line 164
    (tag->frame_tl)->next = f;
#line 165
    tag->frame_tl = f;
  }
#line 167
  (tag->nframes) ++;
#line 168
  return;
}
}
#line 180 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
id3_t id3_open(char const   *fname , int mode ) 
{ 
  int fd ;
  int omode ;
  int err ;
  char *fmode ;
  id3_t newtag ;
  int *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 185
  newtag = (id3_t )((void *)0);
  {
#line 193
  if (mode == 0) {
#line 193
    goto case_0;
  }
#line 197
  if (mode == 1) {
#line 197
    goto case_1;
  }
#line 201
  goto switch_default;
  case_0: /* CIL Label */ 
#line 194
  omode = 0;
#line 195
  fmode = (char *)"rb";
#line 196
  goto switch_break;
  case_1: /* CIL Label */ 
#line 198
  omode = 66;
#line 199
  fmode = (char *)"rb+";
#line 200
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 202
  tmp = __errno_location();
  }
#line 202
  *tmp = 22;
  }
#line 203
  return ((id3_t )((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 205
  fd = open(fname, omode, 438);
  }
  }
#line 206
  if (fd == -1) {
#line 207
    return ((id3_t )((void *)0));
  }
  {
  {
#line 209
  tmp___0 = calloc((size_t )1, (size_t )sizeof(struct id3_struct ));
  }
#line 209
  newtag = (id3_t )tmp___0;
  }
#line 210
  if ((unsigned long )newtag == (unsigned long )((void *)0)) {
#line 211
    goto error_close;
  }
  {
  {
#line 213
  newtag->fp = fdopen(fd, (char const   *)fmode);
  }
  }
#line 214
  if ((unsigned long )newtag->fp == (unsigned long )((void *)0)) {
#line 215
    goto error_free;
  }
  {
  {
#line 217
  tmp___1 = strlen(fname);
  }
  {
#line 217
  tmp___2 = malloc(tmp___1 + 1U);
  }
#line 217
  newtag->fname = (char *)tmp___2;
  }
#line 218
  if ((unsigned long )newtag->fname == (unsigned long )((void *)0)) {
#line 219
    goto error_fclose;
  }
  {
  {
#line 220
  strcpy((char */* __restrict  */)newtag->fname, (char const   */* __restrict  */)fname);
  }
#line 221
  newtag->mode = mode;
#line 222
  newtag->pad_policy = (enum id3_pad_policy )0;
#line 223
  newtag->nframes = -1;
#line 224
  newtag->tagsz = -1;
#line 225
  newtag->seekable = 1U;
#line 226
  newtag->version = (unsigned char)3;
#line 227
  newtag->v1.requested = 1U;
#line 228
  newtag->v1.genre = (unsigned char)255;
  }
#line 230
  return (newtag);
  error_fclose: 
  {
  {
#line 233
  tmp___3 = __errno_location();
  }
#line 233
  err = *tmp___3;
  {
#line 234
  fclose(newtag->fp);
  }
  {
#line 235
  free((void *)newtag);
  }
  {
#line 236
  tmp___4 = __errno_location();
  }
#line 236
  *tmp___4 = err;
  }
#line 237
  return ((id3_t )((void *)0));
  error_free: 
  {
  {
#line 240
  tmp___5 = __errno_location();
  }
#line 240
  err = *tmp___5;
  {
#line 241
  free((void *)newtag);
  }
  {
#line 242
  tmp___6 = __errno_location();
  }
#line 242
  *tmp___6 = err;
  }
  error_close: 
  {
  {
#line 244
  tmp___7 = __errno_location();
  }
#line 244
  err = *tmp___7;
  {
#line 245
  close(fd);
  }
  {
#line 246
  tmp___8 = __errno_location();
  }
#line 246
  *tmp___8 = err;
  }
#line 247
  return ((id3_t )((void *)0));
}
}
#line 257 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static size_t unsync_fread(void *buf , size_t size , FILE *stream , size_t consume_limit ,
                           size_t *consumed ) 
{ 
  unsigned char *p ;
  unsigned char *p_save ;
  size_t cons ;
  int c ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
#line 261
  p = (unsigned char *)buf;
#line 266
  cons = (size_t )0;
#line 267
  p_save = p;
  {
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 269
    if (size > 0U) {
#line 269
      if (! (cons < consume_limit)) {
#line 269
        goto while_break;
      }
    } else {
#line 269
      goto while_break;
    }
    {
    {
#line 270
    c = _IO_getc(stream);
    }
    }
#line 271
    if (c == -1) {
#line 272
      goto while_break;
    }
#line 273
    tmp = p;
#line 273
    p ++;
#line 273
    *tmp = (unsigned char )c;
#line 273
    size --;
#line 273
    cons ++;
#line 274
    if (c == 255) {
      {
      {
#line 275
      c = _IO_getc(stream);
      }
      }
#line 276
      if (c == -1) {
#line 277
        goto while_break;
      }
#line 278
      if (c == 0) {
#line 278
        if (cons < consume_limit) {
#line 280
          cons ++;
        } else {
#line 278
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 281
      if (size > 0U) {
#line 281
        if (cons < consume_limit) {
#line 282
          tmp___0 = p;
#line 282
          p ++;
#line 282
          *tmp___0 = (unsigned char )c;
#line 282
          size --;
#line 282
          cons ++;
        } else {
#line 281
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 288
        tmp___1 = ungetc(c, stream);
        }
        }
#line 288
        if (tmp___1 == -1) {
#line 289
          goto while_break;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if (consumed) {
#line 295
    *consumed = cons;
  }
#line 297
  return ((size_t )(p - p_save));
}
}
#line 304 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int unsync_fseek(FILE *stream , long offset , int whence , long *real_offset ) 
{ 
  long roff ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 307
  roff = 0L;
#line 310
  if (whence != 1) {
    {
    {
#line 311
    tmp = fseek(stream, 0L, whence);
    }
    }
#line 311
    if (tmp == -1) {
#line 312
      return (-1);
    }
  }
#line 314
  if (offset > 0L) {
    {
    {
#line 317
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 317
      if (! (offset > 0L)) {
#line 317
        goto while_break;
      }
      {
      {
#line 318
      c = _IO_getc(stream);
      }
      }
#line 319
      if (c == -1) {
#line 320
        goto while_break;
      }
#line 321
      offset --;
#line 322
      roff ++;
#line 323
      if (c == 255) {
        {
        {
#line 324
        c = _IO_getc(stream);
        }
        }
#line 325
        if (c == -1) {
#line 326
          goto while_break;
        }
#line 327
        roff ++;
#line 328
        if (! (c == 0)) {
#line 330
          if (offset > 0L) {
#line 331
            offset --;
          } else {
            {
            {
#line 333
            tmp___0 = ungetc(c, stream);
            }
            }
#line 333
            if (tmp___0 == -1) {
#line 334
              goto while_break;
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 339
  if (offset < 0L) {
    {
    {
#line 342
    _IO_getc(stream);
    }
    }
    {
    {
#line 343
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 343
      if (! (offset < 0L)) {
#line 343
        goto while_break___0;
      }
      {
      {
#line 345
      tmp___1 = fseek(stream, -2L, 1);
      }
      }
#line 345
      if (tmp___1 == -1) {
#line 346
        return (-1);
      }
      {
      {
#line 347
      c = _IO_getc(stream);
      }
      }
#line 348
      if (c == -1) {
#line 349
        goto while_break___0;
      }
#line 350
      roff --;
#line 351
      if (c == 0) {
        {
        {
#line 351
        tmp___3 = ftell(stream);
        }
        }
#line 351
        if (tmp___3 >= 2L) {
          {
          {
#line 352
          tmp___2 = fseek(stream, -2L, 1);
          }
          }
#line 352
          if (tmp___2 == -1) {
#line 353
            return (-1);
          }
          {
          {
#line 354
          c = _IO_getc(stream);
          }
          }
#line 355
          if (c == -1) {
#line 356
            goto while_break___0;
          }
#line 357
          roff --;
#line 358
          if (! (c == 255)) {
#line 360
            if (offset < 0L) {
#line 361
              offset ++;
            } else {
              {
              {
#line 363
              _IO_getc(stream);
              }
              }
            }
          }
        } else {
#line 365
          offset ++;
        }
      } else {
#line 365
        offset ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 368
    tmp___4 = fseek(stream, -1L, 1);
    }
    }
#line 368
    if (tmp___4 == -1) {
#line 369
      return (-1);
    }
  }
#line 373
  if (real_offset) {
#line 374
    *real_offset = roff;
  }
  {
  {
#line 376
  tmp___5 = ferror(stream);
  }
  }
#line 376
  if (tmp___5) {
#line 377
    return (-1);
  }
#line 379
  return (0);
}
}
#line 382 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_header(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned int tmp ;

  {
  {
#line 385
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
  {
#line 386
  tmp = unsyncsafe_int(hdr + 6);
  }
#line 386
  tag->tagsz = (int )tmp;
  }
#line 387
  return (0);
}
}
#line 390 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_header(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned char xhdr[10] ;
  size_t consumed ;
  long offset ;
  int sz ;
  unsigned int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;

  {
  {
#line 398
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
#line 399
  tag->has_ext_hdr = (unsigned int )(((int )*(hdr + 5) >> 6) & 1);
#line 400
  tag->experimental = (unsigned int )(((int )*(hdr + 5) >> 5) & 1);
  {
#line 401
  tmp = unsyncsafe_int(hdr + 6);
  }
#line 401
  tag->tagsz = (int )tmp;
  }
#line 404
  if (tag->has_ext_hdr) {
#line 405
    if (tag->unsync) {
      {
      {
#line 406
      tmp___0 = unsync_fread((void *)(xhdr), (size_t )10, tag->fp, (size_t )20, & consumed);
      }
      }
#line 406
      if (tmp___0 < 10U) {
#line 407
        return (-1);
      }
    } else {
      {
      {
#line 409
      tmp___1 = fread((void */* __restrict  */)(xhdr), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 409
      if (tmp___1 < 10U) {
#line 410
        return (-1);
      }
    }
    {
    {
#line 412
    tmp___2 = get_be_int(xhdr);
    }
#line 412
    sz = (int )tmp___2;
    }
#line 413
    if ((int )xhdr[4] & 128) {
#line 413
      tag->has_crc = 1U;
    } else {
#line 413
      tag->has_crc = 0U;
    }
#line 417
    if (tag->unsync) {
      {
      {
#line 418
      tmp___3 = unsync_fseek(tag->fp, (long )(sz - 6), 1, & offset);
      }
      }
#line 418
      if (tmp___3 == -1) {
#line 419
        return (-1);
      }
#line 420
      tag->curr_off += (off_t )consumed;
#line 421
      tag->curr_off += offset;
    } else {
#line 423
      if (tag->seekable) {
        {
        {
#line 424
        tmp___4 = fseek(tag->fp, (long )(sz - 6), 1);
        }
        }
#line 424
        if (tmp___4 == -1) {
#line 425
          tag->seekable = 0U;
        }
      }
#line 427
      if (! tag->seekable) {
#line 428
        sz -= 6;
        {
        {
#line 429
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 429
          tmp___6 = sz;
#line 429
          sz --;
#line 429
          if (! (tmp___6 > 0)) {
#line 429
            goto while_break;
          }
          {
          {
#line 430
          tmp___5 = _IO_getc(tag->fp);
          }
          }
#line 430
          if (tmp___5 == -1) {
#line 431
            return (-1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 433
      tag->curr_off += (off_t )sz;
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_header(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned char xhdr[6] ;
  int sz ;
  unsigned int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp11 ;

  {
  {
#line 446
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
#line 447
  tag->has_ext_hdr = (unsigned int )(((int )*(hdr + 5) >> 6) & 1);
#line 448
  tag->experimental = (unsigned int )(((int )*(hdr + 5) >> 5) & 1);
#line 449
  tag->has_footer = (unsigned int )(((int )*(hdr + 5) >> 4) & 1);
  {
#line 450
  tmp = unsyncsafe_int(hdr + 6);
  }
#line 450
  tag->tagsz = (int )tmp;
  }
#line 453
  if (tag->has_ext_hdr) {
    {
    {
#line 454
    tmp___0 = fread((void */* __restrict  */)(xhdr), (size_t )1, (size_t )6, (FILE */* __restrict  */)tag->fp);
    }
    }
#line 454
    if (tmp___0 < 6U) {
#line 455
      return (-1);
    }
    {
    {
#line 456
    tmp___1 = unsyncsafe_int(xhdr);
    }
#line 456
    sz = (int )tmp___1;
    }
#line 457
    if ((int )xhdr[5] & 64) {
#line 457
      tag->is_update = 1U;
    } else {
#line 457
      tag->is_update = 0U;
    }
#line 458
    if ((int )xhdr[5] & 32) {
#line 458
      tag->has_crc = 1U;
    } else {
#line 458
      tag->has_crc = 0U;
    }
#line 459
    if ((int )xhdr[5] & 16) {
#line 459
      tag->has_restrict = 1U;
    } else {
#line 459
      tag->has_restrict = 0U;
    }
#line 463
    tag->curr_off += (off_t )sz;
#line 464
    if (tag->seekable) {
      {
      {
#line 465
      tmp___2 = fseek(tag->fp, (long )(sz - 6), 1);
      }
      }
#line 465
      if (tmp___2 == -1) {
#line 466
        tag->seekable = 0U;
      }
    }
#line 468
    if (! tag->seekable) {
#line 469
      sz -= 6;
      {
      {
#line 470
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 470
        tmp___4 = sz;
#line 470
        sz --;
#line 470
        if (! (tmp___4 > 0)) {
#line 470
          goto while_break;
        }
        {
        {
#line 471
        tmp___3 = _IO_getc(tag->fp);
        }
        }
#line 471
        if (tmp___3 == -1) {
#line 472
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 476
  return (0);
}
}
#line 479 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _look_for_v1tag(id3_t tag ) 
{ 
  int sz ;
  char buf[128] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 484
  tmp = fseek(tag->fp, -128L, 2);
  }
  }
#line 484
  if (tmp == -1) {
#line 485
    return (0);
  }
  {
  {
#line 486
  tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )128, (FILE */* __restrict  */)tag->fp);
  }
#line 486
  sz = (int )tmp___0;
  }
#line 487
  if (sz == 128) {
    {
    {
#line 487
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"TAG", (size_t )3);
    }
    }
#line 487
    if (tmp___1 == 0) {
      {
#line 488
      tag->v1.exists = 1U;
      {
#line 489
      strncpy((char */* __restrict  */)(tag->v1.title), (char const   */* __restrict  */)(buf + 3),
              (size_t )30);
      }
      {
#line 490
      strncpy((char */* __restrict  */)(tag->v1.artist), (char const   */* __restrict  */)(buf + 33),
              (size_t )30);
      }
      {
#line 491
      strncpy((char */* __restrict  */)(tag->v1.album), (char const   */* __restrict  */)(buf + 63),
              (size_t )30);
      }
      {
#line 492
      strncpy((char */* __restrict  */)(tag->v1.year), (char const   */* __restrict  */)(buf + 93),
              (size_t )4);
      }
      {
#line 493
      strncpy((char */* __restrict  */)(tag->v1.comment), (char const   */* __restrict  */)(buf + 97),
              (size_t )30);
      }
      }
#line 495
      if ((int )buf[125] == 0) {
#line 495
        tag->v1.track = (unsigned char )buf[126];
      } else {
#line 495
        tag->v1.track = (unsigned char)0;
      }
#line 496
      tag->v1.genre = (unsigned char )buf[127];
    }
  }
#line 498
  return ((int )tag->v1.exists);
}
}
#line 501 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _is_id3_header(unsigned char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 504
  tmp = strncmp((char const   *)((char *)buf), "ID3", (size_t )3);
  }
  }
#line 504
  if (tmp != 0) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 3) == 255) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 4) == 255) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 6) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 7) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 8) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 9) >= 128) {
#line 509
    return (0);
  }
#line 510
  return (1);
}
}
#line 513 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _is_id3_footer(unsigned char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 516
  tmp = strncmp((char const   *)((char *)buf), "3DI", (size_t )3);
  }
  }
#line 516
  if (tmp != 0) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 3) == 255) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 4) == 255) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 6) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 7) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 8) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 9) >= 128) {
#line 521
    return (0);
  }
#line 522
  return (1);
}
}
#line 525 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _look_for_footer(id3_t tag , unsigned char *hdr , long offset_from_end ) 
{ 
  int sz ;
  int tag_found ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 528
  tag_found = 0;
  {
#line 529
  tmp = fseek(tag->fp, offset_from_end, 2);
  }
  }
#line 529
  if (tmp == -1) {
#line 530
    return (0);
  }
  {
  {
#line 531
  tmp___0 = fread((void */* __restrict  */)hdr, (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
  }
#line 531
  sz = (int )tmp___0;
  }
#line 532
  if (sz == 10) {
    {
    {
#line 532
    tmp___5 = _is_id3_footer(hdr);
    }
    }
#line 532
    if (tmp___5) {
      {
      {
#line 534
      tmp___1 = unsyncsafe_int(hdr + 6);
      }
#line 534
      tag->tagsz = (int )tmp___1;
      {
#line 535
      tmp___2 = fseek(tag->fp, (long )(- tag->tagsz - 10), 1);
      }
      }
#line 535
      if (tmp___2 == -1) {
#line 536
        return (-1);
      }
      {
      {
#line 537
      tag->curr_off = ftell(tag->fp);
      }
#line 538
      tag->offset = tag->curr_off - 10L;
#line 539
      tag->version = *(hdr + 3);
#line 540
      tag->revision = *(hdr + 4);
#line 541
      tmp___4 = 1U;
#line 541
      tag->has_footer = tmp___4;
#line 541
      tmp___3 = tmp___4;
#line 541
      tag->append = tmp___3;
#line 541
      tag->append_req = tmp___3;
#line 542
      tag_found = 1;
      }
    }
  }
#line 544
  return (tag_found);
}
}
#line 559 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_get_size(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  int tag_found ;
  int sz ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  void *__cil_tmp17 ;

  {
#line 563
  tag_found = 0;
#line 566
  if (tag->tagsz == -1) {
#line 571
    if (tag->seekable) {
      {
      {
#line 572
      tmp = fseek(tag->fp, 0L, 0);
      }
      }
#line 572
      if (tmp == -1) {
#line 573
        tag->seekable = 0U;
      }
    }
    {
#line 575
    tag->offset = (off_t )0;
#line 576
    tag->curr_off = (off_t )0;
#line 578
    tag->tagsz = 0;
    {
#line 580
    tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
    }
#line 580
    sz = (int )tmp___0;
#line 581
    tag->curr_off += (off_t )sz;
    }
#line 582
    if (sz < 10) {
      {
      {
#line 583
      tmp___1 = ferror(tag->fp);
      }
      }
#line 583
      if (tmp___1) {
#line 584
        return (-1);
      }
    } else {
      {
      {
#line 587
      tmp___2 = _is_id3_header(buf);
      }
      }
#line 587
      if (tmp___2) {
#line 591
        tag->version = buf[3];
#line 592
        tag->revision = buf[4];
#line 593
        tag_found = 1;
      }
    }
#line 597
    if (tag->seekable) {
      {
      {
#line 599
      tmp___3 = _look_for_v1tag(tag);
      }
      }
#line 599
      if (tmp___3 == -1) {
#line 600
        return (-1);
      }
#line 602
      if (! tag_found) {
#line 603
        if (tag->v1.exists) {
          {
          {
#line 605
          tag_found = _look_for_footer(tag, buf, -138L);
          }
          }
#line 606
          if (tag_found == -1) {
#line 607
            return (-1);
          }
        } else {
          {
          {
#line 610
          tag_found = _look_for_footer(tag, buf, -10L);
          }
          }
#line 611
          if (tag_found == -1) {
#line 612
            return (-1);
          }
        }
      }
      {
      {
#line 616
      fseek(tag->fp, tag->offset + 10L, 0);
      }
      }
    }
#line 619
    if (tag_found) {
      {
#line 621
      if ((int )tag->version == 2) {
#line 621
        goto case_2;
      }
#line 627
      if ((int )tag->version == 3) {
#line 627
        goto case_3;
      }
#line 633
      if ((int )tag->version == 4) {
#line 633
        goto case_4;
      }
#line 639
      goto switch_default;
      case_2: /* CIL Label */ 
      {
      {
#line 622
      tmp___5 = _read_v2_header(tag, buf);
      }
      }
#line 622
      if (tmp___5 == -1) {
        {
        {
#line 623
        tmp___4 = __errno_location();
        }
#line 623
        *tmp___4 = 22;
        }
#line 624
        return (-1);
      }
#line 626
      goto switch_break;
      case_3: /* CIL Label */ 
      {
      {
#line 628
      tmp___7 = _read_v3_header(tag, buf);
      }
      }
#line 628
      if (tmp___7 == -1) {
        {
        {
#line 629
        tmp___6 = __errno_location();
        }
#line 629
        *tmp___6 = 22;
        }
#line 630
        return (-1);
      }
#line 632
      goto switch_break;
      case_4: /* CIL Label */ 
      {
      {
#line 634
      tmp___9 = _read_v4_header(tag, buf);
      }
      }
#line 634
      if (tmp___9 == -1) {
        {
        {
#line 635
        tmp___8 = __errno_location();
        }
#line 635
        *tmp___8 = 22;
        }
#line 636
        return (-1);
      }
#line 638
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 641
      tag->tagsz = 0;
      {
#line 642
      tmp___10 = __errno_location();
      }
#line 642
      *tmp___10 = 38;
      }
#line 643
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 652
  return (tag->tagsz);
}
}
#line 660 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_frame_data(id3_frame_t f ) 
{ 
  int err ;
  id3_t tag ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 664
  tag = f->id3;
#line 666
  if (tag->seekable) {
    {
    {
#line 667
    tmp = fseek(tag->fp, f->offset, 0);
    }
    }
#line 667
    if (tmp == -1) {
#line 668
      tag->seekable = 0U;
    }
  }
  {
  {
#line 671
  tmp___0 = calloc((size_t )(f->sz + 2), (size_t )1);
  }
#line 671
  f->data = (unsigned char *)tmp___0;
  }
#line 672
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 673
    goto error;
  }
  {
  {
#line 674
  tmp___1 = fread((void */* __restrict  */)f->data, (size_t )1, (size_t )f->sz, (FILE */* __restrict  */)tag->fp);
  }
  }
#line 674
  if (tmp___1 < (size_t )f->sz) {
#line 675
    goto error_free;
  }
  {
  {
#line 676
  tmp___2 = id3_frame_get_flag(f, (enum id3_fflag )6);
  }
  }
#line 676
  if (tmp___2) {
    {
    {
#line 677
    f->sz = decode_unsync(f->data, f->data, f->sz);
    }
    }
  }
#line 679
  if ((int )f->id[0] == 84) {
#line 681
    f->curr_txt = (char *)f->data + 1;
  }
#line 684
  return (f->sz);
  error_free: 
  {
  {
#line 686
  tmp___3 = __errno_location();
  }
#line 686
  err = *tmp___3;
  {
#line 687
  free((void *)f->data);
  }
#line 688
  f->data = (unsigned char *)((void *)0);
  {
#line 689
  tmp___4 = __errno_location();
  }
#line 689
  *tmp___4 = err;
  }
  error: 
#line 691
  return (-1);
}
}
#line 694 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_frame_headers(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  id3_frame_t newframe ;
  int tagsz ;
  size_t tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 701
  tag->nframes = 0;
  {
#line 702
  tagsz = id3_get_size(tag);
  }
  }
#line 703
  if (tagsz < 1) {
#line 704
    return (tagsz);
  }
  {
  {
#line 707
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 708
    if (tag->curr_off + 10L > (tag->offset + (off_t )tagsz) + 10L) {
#line 709
      goto while_break;
    }
    {
    {
#line 711
    tmp = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
    }
    }
#line 711
    if (tmp < 10U) {
#line 712
      goto error;
    }
    {
#line 713
    tag->curr_off += 10L;
    {
#line 716
    tmp___0 = memcmp((void const   *)(buf), (void const   *)"\000\000\000\000", (size_t )4);
    }
    }
#line 716
    if (tmp___0 == 0) {
#line 717
      goto while_break;
    }
    {
    {
#line 719
    newframe = _id3_frame_new();
    }
    }
#line 720
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 721
      goto error;
    }
    {
    {
#line 722
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )4);
    }
    {
#line 723
    tmp___1 = unsyncsafe_int(buf + 4);
    }
#line 723
    newframe->sz = (int )tmp___1;
#line 724
    newframe->flags = (unsigned short )(((unsigned int )buf[8] << 8) | (unsigned int )buf[9]);
#line 725
    newframe->offset = tag->curr_off;
    }
#line 727
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 728
      _id3_frame_destroy(newframe);
      }
      }
#line 729
      goto while_break;
    }
    {
#line 731
    newframe->id3 = tag;
    {
#line 732
    _id3_frame_add(tag, newframe);
    }
    }
#line 742
    if (tag->seekable) {
      {
      {
#line 743
      tmp___2 = fseek(tag->fp, (long )newframe->sz, 1);
      }
      }
#line 743
      if (tmp___2 == -1) {
#line 744
        tag->seekable = 0U;
      }
    }
#line 746
    if (! tag->seekable) {
      {
      {
#line 748
      tmp___3 = _read_v4_frame_data(newframe);
      }
      }
#line 748
      if (tmp___3 == -1) {
#line 749
        goto error;
      }
    }
#line 751
    tag->curr_off += (off_t )newframe->sz;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return (tag->nframes);
  error: 
#line 757
  return (-1);
}
}
#line 765 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_frame_data(id3_frame_t f ) 
{ 
  int err ;
  size_t consumed ;
  id3_t tag ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 770
  tag = f->id3;
#line 772
  if (tag->seekable) {
    {
    {
#line 773
    tmp = fseek(tag->fp, f->offset, 0);
    }
    }
#line 773
    if (tmp == -1) {
#line 774
      tag->seekable = 0U;
    }
  }
  {
  {
#line 777
  tmp___0 = calloc((size_t )(f->sz + 2), (size_t )1);
  }
#line 777
  f->data = (unsigned char *)tmp___0;
  }
#line 778
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 779
    goto error;
  }
#line 780
  if (tag->unsync) {
    {
    {
#line 781
    tmp___1 = unsync_fread((void *)f->data, (size_t )f->sz, tag->fp, (size_t )(f->offset - (off_t )tag->tagsz),
                           & consumed);
    }
    }
#line 781
    if (tmp___1 < (size_t )f->sz) {
#line 783
      goto error_free;
    }
  } else {
    {
    {
#line 785
    tmp___2 = fread((void */* __restrict  */)f->data, (size_t )1, (size_t )f->sz,
                    (FILE */* __restrict  */)tag->fp);
    }
    }
#line 785
    if (tmp___2 < (size_t )f->sz) {
#line 786
      goto error_free;
    }
#line 787
    consumed = (size_t )f->sz;
  }
#line 790
  if ((int )f->id[0] == 84) {
#line 792
    f->curr_txt = (char *)f->data + 1;
  }
#line 795
  return ((int )consumed);
  error_free: 
  {
  {
#line 797
  tmp___3 = __errno_location();
  }
#line 797
  err = *tmp___3;
  {
#line 798
  free((void *)f->data);
  }
#line 799
  f->data = (unsigned char *)((void *)0);
  {
#line 800
  tmp___4 = __errno_location();
  }
#line 800
  *tmp___4 = err;
  }
  error: 
#line 802
  return (-1);
}
}
#line 805 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_frame_headers(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  id3_frame_t newframe ;
  size_t consumed ;
  size_t limit ;
  long offset ;
  int tagsz ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 814
  tag->nframes = 0;
  {
#line 815
  tagsz = id3_get_size(tag);
  }
  }
#line 816
  if (tagsz < 1) {
#line 817
    return (tagsz);
  }
  {
  {
#line 820
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 821
    if (tag->unsync) {
      {
#line 828
      limit = (size_t )(((tag->offset + (off_t )tagsz) + 10L) - tag->curr_off);
      {
#line 829
      tmp = unsync_fread((void *)(buf), (size_t )10, tag->fp, limit, & consumed);
      }
      }
#line 829
      if (tmp < 10U) {
#line 830
        goto while_break;
      }
#line 831
      tag->curr_off += (off_t )consumed;
    } else {
#line 843
      if (tag->curr_off > (off_t )tagsz) {
#line 844
        goto while_break;
      }
      {
      {
#line 845
      tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 845
      if (tmp___0 < 10U) {
#line 846
        goto error;
      }
#line 847
      tag->curr_off += 10L;
    }
    {
    {
#line 851
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"\000\000\000\000", (size_t )4);
    }
    }
#line 851
    if (tmp___1 == 0) {
#line 852
      goto while_break;
    }
    {
    {
#line 854
    newframe = _id3_frame_new();
    }
    }
#line 855
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 856
      goto error;
    }
    {
    {
#line 857
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )4);
    }
    {
#line 858
    tmp___2 = get_be_int(buf + 4);
    }
#line 858
    newframe->sz = (int )tmp___2;
#line 859
    newframe->flags = (unsigned short )(((unsigned int )buf[8] << 8) | (unsigned int )buf[9]);
#line 860
    newframe->offset = tag->curr_off;
    }
#line 862
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 863
      _id3_frame_destroy(newframe);
      }
      }
#line 864
      goto while_break;
    }
    {
#line 866
    newframe->id3 = tag;
    {
#line 867
    _id3_frame_add(tag, newframe);
    }
    }
#line 877
    if (tag->seekable) {
#line 878
      if (tag->unsync) {
        {
        {
#line 879
        tmp___3 = unsync_fseek(tag->fp, (long )newframe->sz, 1, & offset);
        }
        }
#line 879
        if (tmp___3 == -1) {
#line 880
          return (-1);
        }
#line 881
        tag->curr_off += offset;
      } else {
        {
        {
#line 883
        tmp___4 = fseek(tag->fp, (long )newframe->sz, 1);
        }
        }
#line 883
        if (tmp___4 == -1) {
#line 884
          tag->seekable = 0U;
        } else {
#line 886
          tag->curr_off += (off_t )newframe->sz;
        }
      }
    }
#line 889
    if (! tag->seekable) {
      {
      {
#line 891
      tmp___5 = _read_v3_frame_data(newframe);
      }
#line 891
      offset = (long )tmp___5;
      }
#line 892
      if (offset == -1L) {
#line 893
        goto error;
      }
#line 894
      tag->curr_off += offset;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (tag->nframes);
  error: 
#line 901
  return (-1);
}
}
#line 909 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_frame_data(id3_frame_t f ) 
{ 
  int tmp ;

  {
  {
  {
#line 913
  tmp = _read_v3_frame_data(f);
  }
  }
#line 913
  return (tmp);
}
}
#line 916 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_frame_headers(id3_t tag ) 
{ 
  unsigned char buf[6] ;
  id3_frame_t newframe ;
  size_t consumed ;
  long offset ;
  int tagsz ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 925
  tag->nframes = 0;
  {
#line 926
  tagsz = id3_get_size(tag);
  }
  }
#line 927
  if (tagsz < 1) {
#line 928
    return (tagsz);
  }
  {
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 932
    if (tag->unsync) {
      {
      {
#line 939
      tmp = unsync_fread((void *)(buf), (size_t )6, tag->fp, (size_t )((off_t )(tagsz + 10) - tag->curr_off),
                         & consumed);
      }
      }
#line 939
      if (tmp < 6U) {
#line 941
        goto while_break;
      }
#line 942
      tag->curr_off += (off_t )consumed;
    } else {
#line 949
      if (tag->curr_off + 6L > (off_t )(tagsz + 10)) {
#line 950
        goto while_break;
      }
      {
      {
#line 951
      tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )6, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 951
      if (tmp___0 < 6U) {
#line 952
        goto error;
      }
#line 953
      tag->curr_off += 6L;
    }
    {
    {
#line 957
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"\000\000\000", (size_t )3);
    }
    }
#line 957
    if (tmp___1 == 0) {
#line 958
      goto while_break;
    }
    {
    {
#line 960
    newframe = _id3_frame_new();
    }
    }
#line 961
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 962
      goto error;
    }
    {
    {
#line 963
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )3);
    }
    {
#line 964
    tmp___2 = get_be_int(buf + 2);
    }
#line 964
    newframe->sz = (int )(tmp___2 & 16777215U);
#line 965
    newframe->offset = tag->curr_off;
    }
#line 967
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 968
      _id3_frame_destroy(newframe);
      }
      }
#line 969
      goto while_break;
    }
    {
#line 971
    newframe->id3 = tag;
    {
#line 972
    _id3_frame_add(tag, newframe);
    }
    }
#line 982
    if (tag->seekable) {
#line 983
      if (tag->unsync) {
        {
        {
#line 984
        tmp___3 = unsync_fseek(tag->fp, (long )newframe->sz, 1, & offset);
        }
        }
#line 984
        if (tmp___3 == -1) {
#line 985
          return (-1);
        }
#line 986
        tag->curr_off += offset;
      } else {
        {
        {
#line 988
        tmp___4 = fseek(tag->fp, (long )newframe->sz, 1);
        }
        }
#line 988
        if (tmp___4 == -1) {
#line 989
          tag->seekable = 0U;
        } else {
#line 991
          tag->curr_off += (off_t )newframe->sz;
        }
      }
    }
#line 994
    if (! tag->seekable) {
      {
      {
#line 996
      tmp___5 = _read_v2_frame_data(newframe);
      }
#line 996
      offset = (long )tmp___5;
      }
#line 997
      if (offset == -1L) {
#line 998
        goto error;
      }
#line 999
      tag->curr_off += offset;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  return (tag->nframes);
  error: 
#line 1006
  return (-1);
}
}
#line 1021 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_frame_count(id3_t tag ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 1024
  tmp = id3_get_size(tag);
  }
  }
#line 1024
  if (tmp == -1) {
#line 1025
    return (-1);
  }
#line 1027
  if (tag->nframes == -1) {
    {
#line 1034
    if ((int )tag->version == 4) {
#line 1034
      goto case_4;
    }
#line 1038
    if ((int )tag->version == 3) {
#line 1038
      goto case_3;
    }
#line 1042
    if ((int )tag->version == 2) {
#line 1042
      goto case_2;
    }
#line 1046
    goto switch_default;
    case_4: /* CIL Label */ 
    {
    {
#line 1035
    tmp___0 = _read_v4_frame_headers(tag);
    }
    }
#line 1035
    if (tmp___0 == -1) {
#line 1036
      return (-1);
    }
#line 1037
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 1039
    tmp___1 = _read_v3_frame_headers(tag);
    }
    }
#line 1039
    if (tmp___1 == -1) {
#line 1040
      return (-1);
    }
#line 1041
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 1043
    tmp___2 = _read_v2_frame_headers(tag);
    }
    }
#line 1043
    if (tmp___2 == -1) {
#line 1044
      return (-1);
    }
#line 1045
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1047
    tag->nframes = 0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1051
  return (tag->nframes);
}
}
#line 1062 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_close(id3_t tag ) 
{ 
  id3_frame_t f ;
  id3_frame_t tmp ;

  {
#line 1067
  f = tag->frame_hd;
  {
  {
#line 1068
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1068
    if (! f) {
#line 1068
      goto while_break;
    }
    {
#line 1069
    tmp = f;
#line 1070
    f = f->next;
    {
#line 1071
    _id3_frame_destroy(tmp);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1074
  if (tag->fname) {
    {
    {
#line 1075
    free((void *)tag->fname);
    }
    }
  }
  {
  {
#line 1076
  fclose(tag->fp);
  }
  {
#line 1077
  free((void *)tag);
  }
  }
#line 1079
  return (0);
}
}
#line 1091 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void id3_set_size(id3_t tag , int size ) 
{ 


  {
#line 1094
  tag->requested_sz = size;
#line 1095
  tag->pad_policy = (enum id3_pad_policy )2;
#line 1096
  return;
}
}
#line 1120 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void id3_set_pad_policy(id3_t tag , enum id3_pad_policy policy ) 
{ 


  {
  {
#line 1126
  if ((unsigned int )policy == 0U) {
#line 1126
    goto case_0;
  }
#line 1126
  if ((unsigned int )policy == 2U) {
#line 1126
    goto case_0;
  }
#line 1126
  if ((unsigned int )policy == 1U) {
#line 1126
    goto case_0;
  }
#line 1123
  goto switch_break;
  case_0: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1127
  tag->pad_policy = policy;
#line 1128
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1130
  return;
}
}
#line 1138 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
enum id3_pad_policy id3_get_pad_policy(id3_t tag ) 
{ 


  {
#line 1141
  return (tag->pad_policy);
}
}
#line 1154 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_set_append(id3_t tag , int append ) 
{ 
  int tmp ;

  {
#line 1158
  if (append) {
    {
    {
#line 1159
    tmp = id3_set_version(tag, (enum id3_version )4);
    }
    }
#line 1159
    if (tmp == -1) {
#line 1160
      return (-1);
    }
  }
#line 1161
  tag->append_req = (unsigned int )append;
#line 1162
  return (0);
}
}
#line 1172 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_set_unsync(id3_t tag , int unsync ) 
{ 


  {
#line 1175
  tag->unsync = (unsigned int )unsync;
#line 1176
  return (0);
}
}
#line 1187 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
id3_frame_t id3_get_frame(id3_t tag , int n ) 
{ 
  id3_frame_t f ;

  {
  {
  {
#line 1193
  id3_frame_count(tag);
  }
#line 1195
  f = tag->frame_hd;
  }
  {
  {
#line 1195
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1195
    if (f) {
#line 1195
      if (! (n > 0)) {
#line 1195
        goto while_break;
      }
    } else {
#line 1195
      goto while_break;
    }
#line 1196
    f = f->next;
#line 1195
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  return (f);
}
}
#line 1206 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
id3_frame_t id3_get_frame_by_id(id3_t tag , char const   *id ) 
{ 
  id3_frame_t f ;
  int tmp ;

  {
  {
  {
#line 1212
  id3_frame_count(tag);
  }
#line 1214
  f = tag->frame_hd;
  }
  {
  {
#line 1214
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1214
    if (! f) {
#line 1214
      goto while_break;
    }
    {
    {
#line 1215
    tmp = strcmp(id, (char const   *)(f->id));
    }
    }
#line 1215
    if (tmp == 0) {
#line 1216
      goto while_break;
    }
#line 1214
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1218
  return (f);
}
}
#line 1222 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void id3_frame_delete(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t prev ;

  {
  {
#line 1225
  tag = f->id3;
  {
#line 1229
  id3_frame_count(tag);
  }
  }
#line 1231
  if ((unsigned long )tag->frame_hd == (unsigned long )f) {
#line 1232
    tag->frame_hd = f->next;
#line 1233
    if ((unsigned long )tag->frame_hd == (unsigned long )((void *)0)) {
#line 1234
      tag->frame_tl = (id3_frame_t )((void *)0);
    }
  } else {
#line 1237
    prev = tag->frame_hd;
    {
    {
#line 1237
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1237
      if (! prev) {
#line 1237
        goto while_break;
      }
#line 1238
      if ((unsigned long )prev->next == (unsigned long )f) {
#line 1239
        goto while_break;
      }
#line 1237
      prev = prev->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1240
    if (prev) {
#line 1241
      prev->next = f->next;
    }
  }
  {
  {
#line 1243
  _id3_frame_destroy(f);
  }
#line 1245
  (tag->nframes) --;
  }
#line 1246
  return;
}
}
#line 1255 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
char *id3_frame_get_id(id3_frame_t f ) 
{ 


  {
#line 1258
  return (f->id);
}
}
#line 1261 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_frame_set_id(id3_frame_t f , char const   *id ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 1264
  tmp = strlen(id);
  }
  }
#line 1264
  if (tmp > 4U) {
#line 1265
    return (-1);
  }
  {
  {
#line 1266
  strcpy((char */* __restrict  */)(f->id), (char const   */* __restrict  */)id);
  }
  }
#line 1267
  return (0);
}
}
#line 1276 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_frame_get_size(id3_frame_t f ) 
{ 


  {
#line 1279
  return (f->sz);
}
}
#line 1290 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void *id3_frame_get_raw(id3_frame_t f ) 
{ 
  id3_t tag ;
  int tmp ;
  int tmp___0 ;

  {
#line 1293
  tag = f->id3;
#line 1295
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
    {
    {
#line 1295
    tmp = id3_frame_get_flag(f, (enum id3_fflag )4);
    }
    }
#line 1295
    if (! tmp) {
      {
      {
#line 1295
      tmp___0 = id3_frame_get_flag(f, (enum id3_fflag )5);
      }
      }
#line 1295
      if (! tmp___0) {
#line 1297
        if (tag->seekable) {
          {
#line 1299
          if ((int )tag->version == 4) {
#line 1299
            goto case_4;
          }
#line 1302
          if ((int )tag->version == 3) {
#line 1302
            goto case_3;
          }
#line 1305
          if ((int )tag->version == 2) {
#line 1305
            goto case_2;
          }
#line 1298
          goto switch_break;
          case_4: /* CIL Label */ 
          {
          {
#line 1300
          _read_v4_frame_data(f);
          }
          }
#line 1301
          goto switch_break;
          case_3: /* CIL Label */ 
          {
          {
#line 1303
          _read_v3_frame_data(f);
          }
          }
#line 1304
          goto switch_break;
          case_2: /* CIL Label */ 
          {
          {
#line 1306
          _read_v2_frame_data(f);
          }
          }
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1311
  return ((void *)f->data);
}
}
#line 1314 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_frame_set_raw(id3_frame_t f , void *buf , int size ) 
{ 
  void *tmp ;

  {
#line 1317
  if (f->data) {
    {
    {
#line 1318
    free((void *)f->data);
    }
    }
  }
  {
  {
#line 1319
  tmp = malloc((size_t )size);
  }
#line 1319
  f->data = (unsigned char *)tmp;
  }
#line 1320
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 1321
    return (-1);
  }
  {
  {
#line 1322
  memcpy((void */* __restrict  */)f->data, (void const   */* __restrict  */)buf, (size_t )size);
  }
#line 1323
  f->sz = size;
  }
#line 1324
  return (0);
}
}
#line 1328 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
id3_frame_t id3_frame_add(id3_t tag , char const   *id ) 
{ 
  id3_frame_t fr ;

  {
  {
  {
#line 1333
  fr = id3_get_frame_by_id(tag, id);
  }
  }
#line 1335
  if ((unsigned long )fr == (unsigned long )((void *)0)) {
    {
    {
#line 1336
    fr = _id3_frame_new();
    }
    }
#line 1337
    if ((unsigned long )fr == (unsigned long )((void *)0)) {
#line 1338
      return ((id3_frame_t )((void *)0));
    }
    {
    {
#line 1340
    strncpy((char */* __restrict  */)(fr->id), (char const   */* __restrict  */)id,
            (size_t )4);
    }
#line 1342
    fr->id3 = tag;
    {
#line 1343
    _id3_frame_add(tag, fr);
    }
    }
  }
#line 1346
  return (fr);
}
}
#line 1349 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
int id3_frame_get_flag(id3_frame_t f , enum id3_fflag flg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1353
  if ((int )(f->id3)->version == 4) {
#line 1353
    goto case_4;
  }
#line 1355
  if ((int )(f->id3)->version == 3) {
#line 1355
    goto case_3;
  }
#line 1352
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1354
  if ((int )f->flags & (int )v4_fflag_masks[flg]) {
#line 1354
    tmp = 1;
  } else {
#line 1354
    tmp = 0;
  }
#line 1354
  return (tmp);
  case_3: /* CIL Label */ 
#line 1356
  if ((int )f->flags & (int )v3_fflag_masks[flg]) {
#line 1356
    tmp___0 = 1;
  } else {
#line 1356
    tmp___0 = 0;
  }
#line 1356
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
#line 1358
  return (0);
}
}
#line 1361 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void id3_frame_set_flag(id3_frame_t f , enum id3_fflag flg ) 
{ 


  {
  {
#line 1365
  if ((int )(f->id3)->version == 4) {
#line 1365
    goto case_4;
  }
#line 1368
  if ((int )(f->id3)->version == 3) {
#line 1368
    goto case_3;
  }
#line 1372
  goto switch_default;
  case_4: /* CIL Label */ 
#line 1366
  f->flags = (unsigned short )((int )f->flags | (int )v4_fflag_masks[flg]);
#line 1367
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1369
  f->flags = (unsigned short )((int )f->flags | (int )v3_fflag_masks[flg]);
#line 1370
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1373
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1375
  return;
}
}
#line 1377 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void id3_frame_clear_flag(id3_frame_t f , enum id3_fflag flg ) 
{ 


  {
  {
#line 1381
  if ((int )(f->id3)->version == 4) {
#line 1381
    goto case_4;
  }
#line 1384
  if ((int )(f->id3)->version == 3) {
#line 1384
    goto case_3;
  }
#line 1388
  goto switch_default;
  case_4: /* CIL Label */ 
#line 1382
  f->flags = (unsigned short )((int )f->flags & ~ ((int )v4_fflag_masks[flg]));
#line 1383
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1385
  f->flags = (unsigned short )((int )f->flags & ~ ((int )v3_fflag_masks[flg]));
#line 1386
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1389
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1391
  return;
}
}
#line 1393 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
void id3_strip(id3_t tag ) 
{ 
  id3_frame_t f ;
  id3_frame_t tmp ;
  id3_frame_t tmp___0 ;

  {
#line 1398
  f = tag->frame_hd;
  {
  {
#line 1399
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1399
    if (! f) {
#line 1399
      goto while_break;
    }
    {
#line 1400
    tmp = f;
#line 1401
    f = f->next;
    {
#line 1402
    _id3_frame_destroy(tmp);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1405
  tmp___0 = (id3_frame_t )((void *)0);
#line 1405
  tag->frame_tl = tmp___0;
#line 1405
  tag->frame_hd = tmp___0;
#line 1406
  tag->nframes = 0;
#line 1407
  tag->v1.requested = 0U;
#line 1408
  return;
}
}
#line 151 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.h"
char const   *id3_id_description(char const   *id ) ;
#line 40 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
static struct fid_desc  const  fid_desc_map[156]  = 
#line 40 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
  {      {"BUF", "Recommended buffer size"}, 
        {"CNT", "Play counter"}, 
        {"COM", "Comments"}, 
        {"CRA", "Audio encryption"}, 
        {"CRM", "Encrypted meta frame"}, 
        {"ETC", "Event timing codes"}, 
        {"EQU", "Equalization"}, 
        {"GEO", "General encapsulated object"}, 
        {"IPL", "Involved people list"}, 
        {"LNK", "Linked information"}, 
        {"MCI", "Music CD Identifier"}, 
        {"MLL", "MPEG location lookup table"}, 
        {"PIC", "Attached picture"}, 
        {"POP", "Popularimeter"}, 
        {"REV", "Reverb"}, 
        {"RVA", "Relative volume adjustment"}, 
        {"SLT", "Synchronized lyric/text"}, 
        {"STC", "Synced tempo codes"}, 
        {"TAL", "Album/Movie/Show title"}, 
        {"TBP", "BPM (Beats Per Minute)"}, 
        {"TCM", "Composer"}, 
        {"TCO", "Content type"}, 
        {"TCR", "Copyright message"}, 
        {"TDA", "Date"}, 
        {"TDY", "Playlist delay"}, 
        {"TEN", "Encoded by"}, 
        {"TFT", "File type"}, 
        {"TIM", "Time"}, 
        {"TKE", "Initial key"}, 
        {"TLA", "Language(s)"}, 
        {"TLE", "Length"}, 
        {"TMT", "Media type"}, 
        {"TOA", "Original artist(s)/performer(s)"}, 
        {"TOF", "Original filename"}, 
        {"TOL", "Original Lyricist(s)/text writer(s)"}, 
        {"TOR", "Original release year"}, 
        {"TOT", "Original album/Movie/Show title"}, 
        {"TP1", "Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group"}, 
        {"TP2", "Band/Orchestra/Accompaniment"}, 
        {"TP3", "Conductor/Performer refinement"}, 
        {"TP4", "Interpreted, remixed, or otherwise modified by"}, 
        {"TPA", "Part of a set"}, 
        {"TPB", "Publisher"}, 
        {"TRC", "ISRC (International Standard Recording Code)"}, 
        {"TRD", "Recording dates"}, 
        {"TRK", "Track number/Position in set"}, 
        {"TSI", "Size"}, 
        {"TSS", "Software/hardware and settings used for encoding"}, 
        {"TT1", "Content group description"}, 
        {"TT2", "Title/Songname/Content description"}, 
        {"TT3", "Subtitle/Description refinement"}, 
        {"TXT", "Lyricist/text writer"}, 
        {"TXX", "User defined text information frame"}, 
        {"TYE", "Year"}, 
        {"UFI", "Unique file identifier"}, 
        {"ULT", "Unsychronized lyric/text transcription"}, 
        {"WAF", "Official audio file webpage"}, 
        {"WAR", "Official artist/performer webpage"}, 
        {"WAS", "Official audio source webpage"}, 
        {"WCM", "Commercial information"}, 
        {"WCP", "Copyright/Legal information"}, 
        {"WPB", "Publishers official webpage"}, 
        {"WXX", "User defined URL link frame"}, 
        {"AENC", "Audio encryption"}, 
        {"APIC", "Attached picture"}, 
        {"COMM", "Comments"}, 
        {"COMR", "Commercial frame"}, 
        {"ENCR", "Encryption method registration"}, 
        {"EQUA", "Equalisation"}, 
        {"ETCO", "Event timing codes"}, 
        {"GEOB", "General encapsulated object"}, 
        {"GRID", "Group identification registration"}, 
        {"IPLS", "Involved people list"}, 
        {"LINK", "Linked information"}, 
        {"MCDI", "Music CD identifier"}, 
        {"MLLT", "MPEG location lookup table"}, 
        {"OWNE", "Ownership frame"}, 
        {"PRIV", "Private frame"}, 
        {"PCNT", "Play counter"}, 
        {"POPM", "Popularimeter"}, 
        {"POSS", "Position synchronisation frame"}, 
        {"RBUF", "Recommended buffer size"}, 
        {"RVAD", "Relative volume adjustment"}, 
        {"RVRB", "Reverb"}, 
        {"SYLT", "Synchronised lyric/text"}, 
        {"SYTC", "Synchronised tempo codes"}, 
        {"TALB", "Album/Movie/Show title"}, 
        {"TBPM", "BPM (beats per minute)"}, 
        {"TCOM", "Composer"}, 
        {"TCON", "Content type"}, 
        {"TCOP", "Copyright message"}, 
        {"TDAT", "Date"}, 
        {"TDLY", "Playlist delay"}, 
        {"TENC", "Encoded by"}, 
        {"TEXT", "Lyricist/Text writer"}, 
        {"TFLT", "File type"}, 
        {"TIME", "Time"}, 
        {"TIT1", "Content group description"}, 
        {"TIT2", "Title/songname/content description"}, 
        {"TIT3", "Subtitle/Description refinement"}, 
        {"TKEY", "Initial key"}, 
        {"TLAN", "Language(s)"}, 
        {"TLEN", "Length"}, 
        {"TMED", "Media type"}, 
        {"TOAL", "Original album/movie/show title"}, 
        {"TOFN", "Original filename"}, 
        {"TOLY", "Original lyricist(s)/text writer(s)"}, 
        {"TOPE", "Original artist(s)/performer(s)"}, 
        {"TORY", "Original release year"}, 
        {"TOWN", "File owner/licensee"}, 
        {"TPE1", "Lead performer(s)/Soloist(s)"}, 
        {"TPE2", "Band/orchestra/accompaniment"}, 
        {"TPE3", "Conductor/performer refinement"}, 
        {"TPE4", "Interpreted, remixed, or otherwise modified by"}, 
        {"TPOS", "Part of a set"}, 
        {"TPUB", "Publisher"}, 
        {"TRCK", "Track number/Position in set"}, 
        {"TRDA", "Recording dates"}, 
        {"TRSN", "Internet radio station name"}, 
        {"TRSO", "Internet radio station owner"}, 
        {"TSIZ", "Size"}, 
        {"TSRC", "ISRC (international standard recording code)"}, 
        {"TSSE", "Software/Hardware and settings used for encoding"}, 
        {"TYER", "Year"}, 
        {"TXXX", "User defined text information frame"}, 
        {"UFID", "Unique file identifier"}, 
        {"USER", "Terms of use"}, 
        {"USLT", "Unsynchronised lyric/text transcription"}, 
        {"WCOM", "Commercial information"}, 
        {"WCOP", "Copyright/Legal information"}, 
        {"WOAF", "Official audio file webpage"}, 
        {"WOAR", "Official artist/performer webpage"}, 
        {"WOAS", "Official audio source webpage"}, 
        {"WORS", "Official Internet radio station homepage"}, 
        {"WPAY", "Payment"}, 
        {"WPUB", "Publishers official webpage"}, 
        {"WXXX", "User defined URL link frame"}, 
        {"ASPI", "Audio seek point index"}, 
        {"EQU2", "Equalisation (2)"}, 
        {"RVA2", "Relative volume adjustment (2)"}, 
        {"SEEK", "Seek frame"}, 
        {"SIGN", "Signature frame"}, 
        {"TDEN", "Encoding time"}, 
        {"TDOR", "Original release time"}, 
        {"TDRC", "Recording time"}, 
        {"TDRL", "Release time"}, 
        {"TDTG", "Tagging time"}, 
        {"TIPL", "Involved people list"}, 
        {"TMCL", "Musician credits list"}, 
        {"TMOO", "Mood"}, 
        {"TPRO", "Produced notice"}, 
        {"TSOA", "Album sort order"}, 
        {"TSOP", "Performer sort order"}, 
        {"TSOT", "Title sort order"}, 
        {"TSST", "Set subtitle"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 207 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
char const   *id3_id_description(char const   *id ) 
{ 
  struct fid_desc  const  *d ;
  int tmp ;

  {
#line 212
  d = fid_desc_map;
  {
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 212
    if (! d->id) {
#line 212
      goto while_break;
    }
    {
    {
#line 213
    tmp = strcmp(id, (char const   *)d->id);
    }
    }
#line 213
    if (tmp == 0) {
#line 214
      goto while_break;
    }
#line 212
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return ((char const   *)d->desc);
}
}
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 61 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_link(id3_frame_t f , char const   *from , char const   *to , int backward ) ;
#line 62
static int convert_apic(id3_frame_t f , char const   *from , char const   *to , int backward ) ;
#line 63
static int convert_time(id3_frame_t f , char const   *from , char const   *to , int backward ) ;
#line 64
static int convert_tcon(id3_frame_t f , char const   *from , char const   *to , int backward ) ;
#line 65
static int convert_rva(id3_frame_t f , char const   *from , char const   *to , int backward ) ;
#line 67 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  _convert_map_v2to3[65]  = 
#line 67
  {      {"BUF", "RBUF", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CNT",
      "PCNT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"COM",
      "COMM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CRA",
      "AENC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CRM",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"ETC", "ETCO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"EQU",
      "EQUA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"GEO",
      "GEOB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"IPL",
      "IPLS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"LNK",
      "LINK", & convert_link}, 
        {"MCI", "MCDI", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"MLL",
      "MLLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"PIC",
      "APIC", & convert_apic}, 
        {"POP", "POPM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"REV",
      "RVRB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"RVA",
      "RVAD", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"SLT",
      "SYLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"STC",
      "SYTC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TAL",
      "TALB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TBP",
      "TBPM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCM",
      "TCOM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCO",
      "TCON", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCR",
      "TCOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TDA",
      "TDAT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TDY",
      "TDLY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TEN",
      "TENC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TFT",
      "TFLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TIM",
      "TIME", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TKE",
      "TKEY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TLA",
      "TLAN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TLE",
      "TLEN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TMT",
      "TMED", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOA",
      "TOPE", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOF",
      "TOFN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOL",
      "TOLY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOR",
      "TORY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOT",
      "TOAL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP1",
      "TPE1", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP2",
      "TPE2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP3",
      "TPE3", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP4",
      "TPE4", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TPA",
      "TPOS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TPB",
      "TPUB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRC",
      "TSRC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRD",
      "TRDA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRK",
      "TRCK", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TSI",
      "TSIZ", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TSS",
      "TSSE", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT1",
      "TIT1", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT2",
      "TIT2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT3",
      "TIT3", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TXT",
      "TEXT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TXX",
      "TXXX", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TYE",
      "TYER", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"UFI",
      "UFID", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"ULT",
      "USLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAF",
      "WOAF", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAR",
      "WOAR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAS",
      "WOAS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WCM",
      "WCOM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WCP",
      "WCOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WPB",
      "WPUB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WXX",
      "WXXX", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"XRV",
      "XRVA", & convert_rva}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(id3_frame_t  ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         int  ))((void *)0)}};
#line 137 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  _convert_map_v3to4[30]  = 
#line 137
  {      {"EQUA", (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {"IPLS",
      "TIPL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"RVAD",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"TDAT", "TDRC", & convert_time}, 
        {"TIME", "TDRC", & convert_time}, 
        {"TORY", "TDOR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRDA",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"TSIZ", (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {"TYER",
      "TDRC", & convert_time}, 
        {"XRVA", "RVA2", & convert_rva}, 
        {(char const   *)((void *)0), "ASPI", (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "EQU2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "RVA2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "SEEK", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "SIGN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDEN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDOR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDRC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDRL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDTG", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TIPL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TMCL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TMOO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TPRO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSST", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCON",
      "TCON", & convert_tcon}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(id3_frame_t  ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         int  ))((void *)0)}};
#line 181 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_link(id3_frame_t f , char const   *from , char const   *to , int backward ) 
{ 


  {
#line 185
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct imgtype_mimetype_struct  const  imgtype_mimetype_map[11]  = 
#line 193
  {      {"jpg", "jpeg"}, 
        {"tif", "tiff"}, 
        {"xbm", "x-xbitmap"}, 
        {"xpm", "x-xpixmap"}, 
        {"xwd", "x-xwindowdump"}, 
        {"ras", "x-cmu-raster"}, 
        {"pnm", "x-portable-anymap"}, 
        {"pbm", "x-portable-bitmap"}, 
        {"pgm", "x-portable-graymap"}, 
        {"rgb", "x-rgb"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_apic_forward(id3_frame_t f ) 
{ 
  char imgtype[4] ;
  char mimetype[32] ;
  struct imgtype_mimetype_struct  const  *im_map ;
  unsigned char *data ;
  int i ;
  int newsz ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 218
  tmp = id3_frame_get_raw(f);
  }
#line 218
  data = (unsigned char *)tmp;
  }
#line 219
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 220
    return (0);
  }
  {
  {
#line 221
  memcpy((void */* __restrict  */)(imgtype), (void const   */* __restrict  */)(data + 1),
         (size_t )3);
  }
#line 222
  imgtype[3] = (char )'\000';
#line 223
  i = 0;
  }
  {
  {
#line 223
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < 3)) {
#line 223
      goto while_break;
    }
    {
    {
#line 224
    tmp___0 = tolower((int )imgtype[i]);
    }
#line 224
    imgtype[i] = (char )tmp___0;
#line 223
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 227
  strcpy((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)"image/");
  }
#line 228
  im_map = imgtype_mimetype_map;
  }
  {
  {
#line 229
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! im_map->imgtype) {
#line 229
      goto while_break___0;
    }
    {
    {
#line 230
    tmp___1 = strcmp((char const   *)(imgtype), (char const   *)im_map->imgtype);
    }
    }
#line 230
    if (tmp___1 == 0) {
      {
      {
#line 231
      strcat((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)im_map->mimetype);
      }
      }
#line 232
      goto while_break___0;
    }
#line 234
    im_map ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 238
  if ((unsigned long )im_map->imgtype == (unsigned long )((void *)0)) {
    {
    {
#line 239
    strcat((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)(imgtype));
    }
    }
  }
  {
  {
#line 241
  tmp___2 = strlen((char const   *)(mimetype));
  }
#line 241
  i = (int )tmp___2;
#line 242
  newsz = ((f->sz - 3) + i) + 1;
  {
#line 243
  tmp___3 = malloc((size_t )newsz);
  }
#line 243
  f->data = (unsigned char *)tmp___3;
  }
#line 244
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 245
    f->data = data;
#line 246
    return (-1);
  }
  {
#line 248
  *(f->data + 0) = *(data + 0);
  {
#line 249
  strcpy((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)(mimetype));
  }
  {
#line 250
  memcpy((void */* __restrict  */)(((f->data + 1) + i) + 1), (void const   */* __restrict  */)(data + 4),
         (size_t )(f->sz - 4));
  }
#line 251
  f->sz = newsz;
  {
#line 252
  free((void *)data);
  }
  }
#line 254
  return (0);
}
}
#line 258 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_apic_backward(id3_frame_t f ) 
{ 
  char imgtype[4] ;
  char *mimetype ;
  struct imgtype_mimetype_struct  const  *im_map ;
  unsigned char *data ;
  int i ;
  int newsz ;
  int len ;
  int bad_mimetype ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 261
  mimetype = (char *)((void *)0);
#line 264
  bad_mimetype = 0;
  {
#line 266
  tmp = id3_frame_get_raw(f);
  }
#line 266
  data = (unsigned char *)tmp;
  }
#line 267
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 268
    return (0);
  }
#line 271
  i = 1;
  {
  {
#line 271
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < f->sz)) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )*(data + i) == 0) {
#line 273
      goto while_break;
    }
#line 271
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  if ((int )*(data + i) != 0) {
#line 276
    bad_mimetype = 1;
  } else
#line 275
  if (i < 8) {
#line 276
    bad_mimetype = 1;
  }
#line 278
  if (! bad_mimetype) {
    {
#line 279
    mimetype = (char *)data + 1;
    {
#line 280
    tmp___0 = strlen((char const   *)mimetype);
    }
#line 280
    len = (int )tmp___0;
#line 281
    i = 0;
    }
    {
    {
#line 281
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! (i < len)) {
#line 281
        goto while_break___0;
      }
      {
      {
#line 282
      tmp___1 = tolower((int )*(mimetype + i));
      }
#line 282
      *(mimetype + i) = (char )tmp___1;
#line 281
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 283
    tmp___2 = strncmp((char const   *)mimetype, "image/", (size_t )6);
    }
    }
#line 283
    if (tmp___2 != 0) {
#line 284
      bad_mimetype = 1;
    }
  }
#line 287
  if (! bad_mimetype) {
#line 288
    mimetype += 6;
#line 290
    im_map = imgtype_mimetype_map;
    {
    {
#line 291
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 291
      if (! im_map->mimetype) {
#line 291
        goto while_break___1;
      }
      {
      {
#line 292
      tmp___3 = strcmp((char const   *)mimetype, (char const   *)im_map->mimetype);
      }
      }
#line 292
      if (tmp___3 == 0) {
        {
        {
#line 293
        strcpy((char */* __restrict  */)(imgtype), (char const   */* __restrict  */)im_map->imgtype);
        }
        }
#line 294
        goto while_break___1;
      }
#line 296
      im_map ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 301
    if ((unsigned long )im_map->mimetype == (unsigned long )((void *)0)) {
      {
      {
#line 302
      strncpy((char */* __restrict  */)(imgtype), (char const   */* __restrict  */)mimetype,
              (size_t )3);
      }
      }
    }
#line 303
    imgtype[3] = (char )'\000';
  } else {
#line 307
    return (0);
  }
  {
#line 310
  newsz = ((f->sz - len) - 1) + 3;
  {
#line 311
  memcpy((void */* __restrict  */)(f->data + 1), (void const   */* __restrict  */)(imgtype),
         (size_t )3);
  }
  {
#line 312
  memmove((void *)(f->data + 4), (void const   *)(((f->data + 4) + len) + 1), (size_t )(((f->sz - 4) - len) - 1));
  }
#line 313
  f->sz = newsz;
  }
#line 315
  return (0);
}
}
#line 318 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_apic(id3_frame_t f , char const   *from , char const   *to , int backward ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 321
  if (backward) {
    {
    {
#line 322
    tmp = _convert_apic_backward(f);
    }
    }
#line 322
    return (tmp);
  } else {
    {
    {
#line 324
    tmp___0 = _convert_apic_forward(f);
    }
    }
#line 324
    return (tmp___0);
  }
}
}
#line 328 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_time_backward(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t f2 ;
  unsigned char *old_data ;
  unsigned char buf[32] ;
  int len ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 331
  tag = f->id3;
  {
#line 338
  tmp = id3_frame_get_raw(f);
  }
#line 338
  old_data = (unsigned char *)tmp;
  }
#line 339
  if ((unsigned long )old_data == (unsigned long )((void *)0)) {
#line 340
    return (0);
  }
  {
  {
#line 341
  tmp___0 = strlen((char const   *)((char *)old_data + 1));
  }
#line 341
  len = (int )tmp___0;
  }
#line 343
  if (len >= 4) {
    {
    {
#line 345
    f2 = id3_frame_add(tag, "TYER");
    }
    }
#line 346
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 347
      return (-1);
    }
    {
    {
#line 348
    tmp___1 = id3_frame_set_raw(f2, (void *)old_data, 5);
    }
    }
#line 348
    if (tmp___1 == -1) {
#line 349
      return (-1);
    }
  }
#line 352
  if (len >= 10) {
    {
    {
#line 354
    f2 = id3_frame_add(tag, "TDAT");
    }
    }
#line 355
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 356
      return (-1);
    }
    {
#line 357
    buf[0] = (unsigned char )'\000';
#line 358
    buf[1] = *(old_data + 9);
#line 359
    buf[2] = *(old_data + 10);
#line 360
    buf[3] = *(old_data + 6);
#line 361
    buf[4] = *(old_data + 7);
    {
#line 362
    tmp___2 = id3_frame_set_raw(f2, (void *)(buf), 5);
    }
    }
#line 362
    if (tmp___2 == -1) {
#line 363
      return (-1);
    }
  }
#line 366
  if (len >= 16) {
    {
    {
#line 368
    f2 = id3_frame_add(tag, "TIME");
    }
    }
#line 369
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 370
      return (-1);
    }
    {
#line 371
    buf[0] = (unsigned char )'\000';
#line 372
    buf[1] = *(old_data + 12);
#line 373
    buf[2] = *(old_data + 13);
#line 374
    buf[3] = *(old_data + 15);
#line 375
    buf[4] = *(old_data + 16);
    {
#line 376
    tmp___3 = id3_frame_set_raw(f2, (void *)(buf), 5);
    }
    }
#line 376
    if (tmp___3 == -1) {
#line 377
      return (-1);
    }
  }
#line 380
  return (1);
}
}
#line 384 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_time_forward(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t tdrc_f ;
  unsigned char *old_data ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  unsigned char tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  unsigned char tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  unsigned char tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 387
  tag = f->id3;
  {
#line 391
  tdrc_f = id3_get_frame_by_id(tag, "TDRC");
  }
  }
#line 392
  if ((unsigned long )tdrc_f == (unsigned long )((void *)0)) {
    {
    {
#line 394
    tmp = id3_frame_get_raw(f);
    }
#line 394
    old_data = (unsigned char *)tmp;
    {
#line 395
    tmp___6 = strcmp((char const   *)(f->id), "TDAT");
    }
    }
#line 395
    if (tmp___6 == 0) {
      {
      {
#line 398
      tmp___0 = strlen((char const   *)((char *)old_data + 1));
      }
      }
#line 398
      if (tmp___0 != 4U) {
#line 400
        return (1);
      }
      {
#line 402
      f->sz = 11;
      {
#line 403
      tmp___1 = calloc((size_t )(f->sz + 2), (size_t )1);
      }
#line 403
      f->data = (unsigned char *)tmp___1;
      {
#line 406
      sprintf((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)"????-%c%c-%c%c",
              (int )*(old_data + 3), (int )*(old_data + 4), (int )*(old_data + 1),
              (int )*(old_data + 2));
      }
      {
#line 408
      free((void *)old_data);
      }
      }
    } else {
      {
      {
#line 410
      tmp___5 = strcmp((char const   *)(f->id), "TIME");
      }
      }
#line 410
      if (tmp___5 == 0) {
        {
        {
#line 413
        tmp___2 = strlen((char const   *)((char *)old_data + 1));
        }
        }
#line 413
        if (tmp___2 != 4U) {
#line 415
          return (1);
        }
        {
#line 417
        f->sz = 17;
        {
#line 418
        tmp___3 = calloc((size_t )(f->sz + 2), (size_t )1);
        }
#line 418
        f->data = (unsigned char *)tmp___3;
        {
#line 421
        sprintf((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)"????-??-??T%c%c:%c%c",
                (int )*(old_data + 1), (int )*(old_data + 2), (int )*(old_data + 3),
                (int )*(old_data + 4));
        }
        {
#line 423
        free((void *)old_data);
        }
        }
      } else {
        {
        {
#line 425
        tmp___4 = strcmp((char const   *)(f->id), "TYER");
        }
        }
#line 425
        if (! (tmp___4 == 0)) {
#line 429
          return (-1);
        }
      }
    }
  } else {
    {
    {
#line 435
    id3_frame_get_raw(f);
    }
    {
#line 436
    tmp___21 = strcmp((char const   *)(f->id), "TDAT");
    }
    }
#line 436
    if (tmp___21 == 0) {
      {
      {
#line 439
      tmp___7 = strlen((char const   *)((char *)f->data + 1));
      }
      }
#line 439
      if (tmp___7 != 4U) {
#line 441
        return (1);
      }
#line 444
      if (tdrc_f->sz < 11) {
        {
        {
#line 446
        tmp___8 = id3_frame_get_raw(tdrc_f);
        }
#line 446
        old_data = (unsigned char *)tmp___8;
#line 447
        tdrc_f->sz = 11;
        {
#line 448
        tmp___9 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
        }
#line 448
        tdrc_f->data = (unsigned char *)tmp___9;
        }
#line 449
        if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 450
          tdrc_f->data = old_data;
#line 451
          return (-1);
        }
#line 453
        tmp___10 = (unsigned char )'\000';
#line 453
        *(tdrc_f->data + 12) = tmp___10;
#line 453
        *(tdrc_f->data + 11) = tmp___10;
      }
      {
      {
#line 456
      sprintf((char */* __restrict  */)((char *)tdrc_f->data + 5), (char const   */* __restrict  */)"-%c%c-%c%c",
              (int )*(f->data + 3), (int )*(f->data + 4), (int )*(f->data + 1), (int )*(f->data + 2));
      }
      }
    } else {
      {
      {
#line 459
      tmp___20 = strcmp((char const   *)(f->id), "TIME");
      }
      }
#line 459
      if (tmp___20 == 0) {
        {
        {
#line 462
        tmp___11 = strlen((char const   *)((char *)f->data + 1));
        }
        }
#line 462
        if (tmp___11 != 4U) {
#line 464
          return (1);
        }
#line 467
        if (tdrc_f->sz < 17) {
          {
          {
#line 469
          tmp___12 = id3_frame_get_raw(tdrc_f);
          }
#line 469
          old_data = (unsigned char *)tmp___12;
#line 470
          tdrc_f->sz = 17;
          {
#line 471
          tmp___13 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
          }
#line 471
          tdrc_f->data = (unsigned char *)tmp___13;
          }
#line 472
          if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 473
            tdrc_f->data = old_data;
#line 474
            return (-1);
          }
#line 476
          tmp___14 = (unsigned char )'\000';
#line 476
          *(tdrc_f->data + 18) = tmp___14;
#line 476
          *(tdrc_f->data + 17) = tmp___14;
        }
        {
        {
#line 479
        sprintf((char */* __restrict  */)((char *)tdrc_f->data + 11), (char const   */* __restrict  */)"T%c%c:%c%c",
                (int )*(f->data + 1), (int )*(f->data + 2), (int )*(f->data + 3),
                (int )*(f->data + 4));
        }
        }
      } else {
        {
        {
#line 482
        tmp___19 = strcmp((char const   *)(f->id), "TYER");
        }
        }
#line 482
        if (tmp___19 == 0) {
          {
          {
#line 485
          tmp___15 = strlen((char const   *)((char *)f->data + 1));
          }
          }
#line 485
          if (tmp___15 != 4U) {
#line 487
            return (1);
          }
#line 490
          if (tdrc_f->sz < 5) {
            {
            {
#line 492
            tmp___16 = id3_frame_get_raw(tdrc_f);
            }
#line 492
            old_data = (unsigned char *)tmp___16;
#line 493
            tdrc_f->sz = 5;
            {
#line 494
            tmp___17 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
            }
#line 494
            tdrc_f->data = (unsigned char *)tmp___17;
            }
#line 495
            if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 496
              tdrc_f->data = old_data;
#line 497
              return (-1);
            }
#line 499
            tmp___18 = (unsigned char )'\000';
#line 499
            *(tdrc_f->data + 6) = tmp___18;
#line 499
            *(tdrc_f->data + 5) = tmp___18;
          }
          {
          {
#line 502
          memcpy((void */* __restrict  */)(tdrc_f->data + 1), (void const   */* __restrict  */)(f->data + 1),
                 (size_t )4);
          }
          }
        } else {
#line 506
          return (-1);
        }
      }
    }
#line 509
    return (1);
  }
#line 512
  return (0);
}
}
#line 517 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_time(id3_frame_t f , char const   *from , char const   *to , int backward ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 520
  if (backward) {
    {
    {
#line 521
    tmp = _convert_time_backward(f);
    }
    }
#line 521
    return (tmp);
  } else {
    {
    {
#line 523
    tmp___0 = _convert_time_forward(f);
    }
    }
#line 523
    return (tmp___0);
  }
}
}
#line 527 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_tcon(id3_frame_t f , char const   *from , char const   *to , int backward ) 
{ 
  char *src ;
  char *dest ;
  char *rparen ;
  unsigned char *data ;
  char *endptr ;
  int i ;
  int newsz ;
  int len ;
  int last_was_nonnumeric ;
  long gnum ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 536
  tmp = id3_frame_get_raw(f);
  }
#line 536
  data = (unsigned char *)tmp;
  }
#line 538
  if (f->sz < 1) {
#line 539
    return (0);
  }
#line 542
  if (backward) {
#line 548
    newsz = f->sz + 2;
#line 549
    i = 0;
    {
    {
#line 549
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 549
      if (! (i < f->sz)) {
#line 549
        goto while_break;
      }
#line 550
      if ((int )*(data + i) == 40) {
#line 551
        newsz ++;
      } else
#line 550
      if ((int )*(data + i) == 0) {
#line 551
        newsz ++;
      }
#line 549
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 553
    tmp___0 = calloc((size_t )newsz, (size_t )1);
    }
#line 553
    f->data = (unsigned char *)tmp___0;
    }
#line 554
    if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 555
      f->data = data;
#line 556
      return (-1);
    }
#line 559
    src = (char *)data;
#line 560
    dest = (char *)f->data;
#line 561
    tmp___1 = dest;
#line 561
    dest ++;
#line 561
    tmp___2 = src;
#line 561
    src ++;
#line 561
    *tmp___1 = *tmp___2;
#line 562
    last_was_nonnumeric = 0;
    {
    {
#line 563
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 563
      if (! (src - (char *)data < (long )f->sz)) {
#line 563
        goto while_break___0;
      }
#line 566
      if ((int )*(src + 0) >= 48) {
#line 566
        if ((int )*(src + 0) <= 57) {
          {
          {
#line 567
          gnum = strtol((char const   */* __restrict  */)src, (char **/* __restrict  */)(& endptr),
                        10);
          }
          }
#line 568
          if ((int )*endptr == 0) {
#line 568
            if (gnum >= 0L) {
#line 568
              if (gnum <= 255L) {
                {
                {
#line 569
                tmp___3 = sprintf((char */* __restrict  */)dest, (char const   */* __restrict  */)"(%d)",
                                  (int )gnum);
                }
#line 569
                dest += tmp___3;
#line 570
                src = endptr + 1;
#line 571
                last_was_nonnumeric = 0;
                }
#line 572
                goto while_continue___0;
              }
            }
          }
        }
      }
#line 577
      if (last_was_nonnumeric) {
#line 579
        tmp___4 = dest;
#line 579
        dest ++;
#line 579
        *tmp___4 = (char )'/';
      }
      {
      {
#line 581
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 581
        if (! ((int )*src != 0)) {
#line 581
          goto while_break___1;
        }
#line 582
        if ((int )*src == 40) {
#line 583
          tmp___5 = dest;
#line 583
          dest ++;
#line 583
          *tmp___5 = (char )'(';
        }
#line 584
        tmp___6 = dest;
#line 584
        dest ++;
#line 584
        tmp___7 = src;
#line 584
        src ++;
#line 584
        *tmp___6 = *tmp___7;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 586
      src ++;
#line 587
      last_was_nonnumeric = 1;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 589
    newsz = (int )(dest - (char *)f->data);
    {
#line 590
    free((void *)data);
    }
    }
  } else {
#line 597
    dest = (char *)data + 1;
#line 597
    src = dest;
    {
    {
#line 598
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 598
      if (! (src - (char *)data < (long )f->sz)) {
#line 598
        goto while_break___2;
      }
#line 600
      if ((int )*(src + 0) == 40) {
        {
        {
#line 602
        rparen = strchr((char const   *)src, ')');
        }
        }
#line 603
        if ((int )*(src + 1) == 40) {
#line 605
          src ++;
#line 606
          if (rparen) {
#line 607
            len = (int )((rparen - src) + 1L);
          } else {
#line 609
            len = (int )((long )f->sz - (src - (char *)data));
          }
          {
          {
#line 610
          memmove((void *)dest, (void const   *)src, (size_t )len);
          }
#line 611
          src += len;
#line 612
          dest += len;
          }
        } else {
#line 615
          if ((unsigned long )rparen == (unsigned long )((void *)0)) {
#line 616
            goto while_break___2;
          }
#line 617
          *rparen = (char )'\000';
#line 618
          if ((int )*(dest + -1) == 0) {
#line 619
            src ++;
          } else {
#line 621
            *src = (char )'\000';
          }
          {
#line 622
          len = (int )(rparen - src);
          {
#line 623
          memmove((void *)dest, (void const   *)src, (size_t )len);
          }
#line 624
          src += len;
#line 625
          dest += len;
          }
        }
      } else {
#line 629
        tmp___8 = dest;
#line 629
        dest ++;
#line 629
        tmp___9 = src;
#line 629
        src ++;
#line 629
        *tmp___8 = *tmp___9;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 633
    newsz = (int )(dest - (char *)data);
  }
#line 636
  f->sz = newsz;
#line 637
  *(f->data + f->sz) = (unsigned char )'\000';
#line 639
  return (0);
}
}
#line 651 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_rva(id3_frame_t f , char const   *from , char const   *to , int backward ) 
{ 
  int i ;
  int peakbytes ;
  unsigned char *data ;
  void *tmp ;

  {
  {
  {
#line 657
  tmp = id3_frame_get_raw(f);
  }
#line 657
  data = (unsigned char *)tmp;
#line 660
  i = 0;
  }
  {
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 660
    if (! (i < f->sz)) {
#line 660
      goto while_break;
    }
#line 661
    if ((int )*(data + i) == 0) {
#line 662
      goto while_break;
    }
#line 660
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  if ((int )*(data + i) != 0) {
#line 664
    return (1);
  }
#line 666
  i ++;
  {
  {
#line 667
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 669
    if (i >= f->sz) {
#line 670
      return (1);
    } else
#line 669
    if ((int )*(data + i) > 8) {
#line 670
      return (1);
    }
#line 673
    i += 3;
#line 674
    if (i >= f->sz) {
#line 675
      return (1);
    }
#line 676
    peakbytes = (int )*(data + i) / 8;
#line 677
    i += peakbytes;
#line 678
    if (i >= f->sz) {
#line 679
      return (1);
    }
#line 682
    i ++;
#line 683
    if (i >= f->sz) {
#line 684
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 692 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  *find_converter(struct frame_convert  const  *map ,
                                                    char const   *from , int backw ) 
{ 
  char const   *s ;
  int tmp ;

  {
  {
  {
#line 697
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 697
    if (! map->from) {
#line 697
      if (! map->to) {
#line 697
        goto while_break;
      }
    }
#line 698
    if (backw) {
#line 698
      s = (char const   *)map->to;
    } else {
#line 698
      s = (char const   *)map->from;
    }
#line 699
    if (s) {
      {
      {
#line 699
      tmp = memcmp((void const   *)from, (void const   *)s, (size_t )4);
      }
      }
#line 699
      if (tmp == 0) {
#line 700
        return (map);
      }
    }
#line 701
    map ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return ((struct frame_convert  const  *)((void *)0));
}
}
#line 706 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_frame(id3_frame_t f , int from_vers , int to_vers ) 
{ 
  struct frame_convert  const  *fc_map ;
  int ret ;
  int backward ;
  char const   *newid ;

  {
#line 709
  fc_map = (struct frame_convert  const  *)((void *)0);
#line 710
  backward = 0;
#line 713
  if (from_vers == to_vers) {
#line 714
    return (0);
  }
#line 716
  if (from_vers - to_vers > 1) {
    {
    {
#line 717
    ret = convert_frame(f, from_vers, to_vers + 1);
    }
    }
#line 718
    if (ret == -1) {
#line 719
      return (-1);
    }
#line 720
    from_vers = to_vers + 1;
  } else
#line 721
  if (to_vers - from_vers > 1) {
    {
    {
#line 722
    ret = convert_frame(f, from_vers, to_vers - 1);
    }
    }
#line 723
    if (ret == -1) {
#line 724
      return (-1);
    }
#line 725
    from_vers = to_vers - 1;
  }
  {
#line 730
  if (from_vers == 2) {
#line 730
    goto case_2;
  }
#line 735
  if (from_vers == 3) {
#line 735
    goto case_3;
  }
#line 747
  if (from_vers == 4) {
#line 747
    goto case_4___0;
  }
#line 729
  goto switch_break;
  case_2: /* CIL Label */ 
#line 732
  fc_map = _convert_map_v2to3;
#line 733
  backward = 0;
#line 734
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 737
  if (to_vers == 2) {
#line 737
    goto case_2___0;
  }
#line 741
  if (to_vers == 4) {
#line 741
    goto case_4;
  }
#line 736
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 738
  fc_map = _convert_map_v2to3;
#line 739
  backward = 1;
#line 740
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 742
  fc_map = _convert_map_v3to4;
#line 743
  backward = 0;
#line 744
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 746
  goto switch_break;
  case_4___0: /* CIL Label */ 
#line 749
  fc_map = _convert_map_v3to4;
#line 750
  backward = 1;
#line 751
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 754
  fc_map = find_converter(fc_map, (char const   *)(f->id), backward);
  }
  }
#line 755
  if (fc_map) {
#line 756
    if (fc_map->converter) {
      {
      {
#line 757
      ret = (*(fc_map->converter))(f, (char const   *)fc_map->from, (char const   *)fc_map->to,
                                   backward);
      }
      }
#line 758
      if (ret == -1) {
#line 759
        return (-1);
      }
#line 760
      if (ret == 1) {
        {
        {
#line 761
        id3_frame_delete(f);
        }
        }
#line 762
        return (0);
      }
    }
#line 765
    if (backward) {
#line 765
      newid = (char const   *)fc_map->from;
    } else {
#line 765
      newid = (char const   *)fc_map->to;
    }
#line 766
    if (newid) {
      {
      {
#line 767
      strcpy((char */* __restrict  */)(f->id), (char const   */* __restrict  */)newid);
      }
      }
    } else {
      {
      {
#line 770
      id3_frame_delete(f);
      }
      }
    }
  }
#line 774
  return (0);
}
}
#line 777 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
int id3_set_version(id3_t tag , enum id3_version ver ) 
{ 
  int oldversion ;
  id3_frame_t fr ;
  id3_frame_t nextfr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 784
  tmp = id3_frame_count(tag);
  }
  }
#line 784
  if (tmp == -1) {
#line 785
    return (-1);
  }
#line 788
  oldversion = (int )tag->version;
  {
#line 790
  if ((unsigned int )ver == 3U) {
#line 790
    goto case_3;
  }
#line 791
  if ((unsigned int )ver == 4U) {
#line 791
    goto case_4;
  }
#line 794
  goto switch_default;
  case_3: /* CIL Label */ 
#line 790
  tag->version = (unsigned char)3;
#line 790
  goto switch_break;
  case_4: /* CIL Label */ 
#line 791
  tag->version = (unsigned char)4;
#line 791
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 795
  tmp___0 = __errno_location();
  }
#line 795
  *tmp___0 = 22;
  }
#line 796
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 799
  if ((int )tag->version == oldversion) {
#line 800
    return (0);
  }
#line 801
  if (oldversion < 2) {
    {
    {
#line 803
    tmp___1 = __errno_location();
    }
#line 803
    *tmp___1 = 22;
    }
#line 804
    return (-1);
  } else
#line 801
  if (oldversion > 4) {
    {
    {
#line 803
    tmp___1 = __errno_location();
    }
#line 803
    *tmp___1 = 22;
    }
#line 804
    return (-1);
  }
#line 808
  fr = tag->frame_hd;
  {
  {
#line 809
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 809
    if (! fr) {
#line 809
      goto while_break;
    }
    {
#line 812
    nextfr = fr->next;
    {
#line 813
    tmp___2 = convert_frame(fr, oldversion, (int )tag->version);
    }
    }
#line 813
    if (tmp___2 == -1) {
#line 814
      return (-1);
    }
#line 815
    fr = nextfr;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  return (0);
}
}
#line 821 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
enum id3_version id3_get_version(id3_t tag ) 
{ 
  int tmp ;

  {
  {
  {
#line 824
  tmp = id3_get_size(tag);
  }
  }
#line 824
  if (tmp == -1) {
#line 825
    return ((enum id3_version )0);
  }
  {
#line 827
  if ((int )tag->version == 2) {
#line 827
    goto case_2;
  }
#line 828
  if ((int )tag->version == 3) {
#line 828
    goto case_3;
  }
#line 829
  if ((int )tag->version == 4) {
#line 829
    goto case_4;
  }
#line 826
  goto switch_break;
  case_2: /* CIL Label */ 
#line 827
  return ((enum id3_version )2);
  case_3: /* CIL Label */ 
#line 828
  return ((enum id3_version )3);
  case_4: /* CIL Label */ 
#line 829
  return ((enum id3_version )4);
  switch_break: /* CIL Label */ ;
  }
#line 831
  return ((enum id3_version )0);
}
}
#line 74 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/src/mpegadjust.c"
static int adjust_id3___0(char *fname , double gain ) 
{ 
  id3_t tag ;
  id3_frame_t fr ;
  int ret ;
  char prefix_buf[18] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 79
  ret = 1;
#line 83
  if (verbose >= 1) {
    {
    {
#line 84
    tmp = basename(fname);
    }
    {
#line 84
    strncpy((char */* __restrict  */)(prefix_buf), (char const   */* __restrict  */)tmp,
            (size_t )17);
    }
#line 85
    prefix_buf[17] = (char )'\000';
    {
#line 86
    progress_callback(prefix_buf, (float )0.0);
    }
    }
  }
  {
  {
#line 89
  tag = id3_open((char const   *)fname, 1);
  }
  }
#line 90
  if ((unsigned long )tag == (unsigned long )((void *)0)) {
#line 91
    return (-1);
  }
  {
  {
#line 93
  tmp___2 = fabs(gain);
  }
  }
#line 93
  if (tmp___2 < adjust_thresh) {
    {
    {
#line 95
    fr = id3_get_frame_by_id(tag, "RVA2");
    }
    }
#line 96
    if (fr) {
      {
      {
#line 97
      id3_frame_delete(fr);
      }
      }
    }
    {
    {
#line 98
    fr = id3_get_frame_by_id(tag, "XRVA");
    }
    }
#line 99
    if (fr) {
      {
      {
#line 100
      id3_frame_delete(fr);
      }
      }
    }
  } else {
    {
    {
#line 101
    tmp___1 = id3_rva_set(tag, "normalize", (enum id3_rva_channel )1, (float )gain);
    }
    }
#line 101
    if (tmp___1 == -1) {
      {
      {
#line 102
      tmp___0 = gettext("%s: error reading ID3 tag\n");
      }
      {
#line 102
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
              progname);
      }
#line 103
      ret = -1;
      }
#line 104
      goto error_close;
    }
  }
#line 107
  if (id3_compat) {
    {
    {
#line 108
    tmp___4 = id3_set_version(tag, (enum id3_version )3);
    }
    }
#line 108
    if (tmp___4 == -1) {
      {
      {
#line 109
      tmp___3 = gettext("%s: error converting tag\n");
      }
      {
#line 109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              progname);
      }
#line 110
      ret = -1;
      }
    }
  } else {
    {
    {
#line 113
    tmp___6 = id3_set_version(tag, (enum id3_version )4);
    }
    }
#line 113
    if (tmp___6 == -1) {
      {
      {
#line 114
      tmp___5 = gettext("%s: error converting tag\n");
      }
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
              progname);
      }
#line 115
      ret = -1;
      }
    }
  }
#line 118
  if (id3_unsync) {
    {
    {
#line 119
    id3_set_unsync(tag, 1);
    }
    }
  }
  {
  {
#line 120
  tmp___8 = id3_write(tag);
  }
  }
#line 120
  if (tmp___8 == -1) {
    {
    {
#line 121
    tmp___7 = gettext("%s: error writing ID3 tag\n");
    }
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            progname);
    }
#line 122
    ret = -1;
    }
  }
  error_close: 
  {
  {
#line 126
  id3_close(tag);
  }
  }
#line 129
  if (verbose >= 1) {
    {
    {
#line 130
    progress_callback(prefix_buf, (float )1.0);
    }
    }
  }
#line 132
  return (ret);
}
}
#line 50 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static char const   *_rva_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 53
  tmp = id3_get_version(tag);
  }
  }
  {
#line 54
  if ((unsigned int )tmp == 2U) {
#line 54
    goto case_2;
  }
#line 58
  if ((unsigned int )tmp == 3U) {
#line 58
    goto case_3;
  }
#line 61
  if ((unsigned int )tmp == 4U) {
#line 61
    goto case_4;
  }
#line 63
  goto switch_default;
  case_2: /* CIL Label */ 
#line 57
  return ("XRV");
  case_3: /* CIL Label */ 
#line 60
  return ("XRVA");
  case_4: /* CIL Label */ 
#line 62
  return ("RVA2");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return ((char const   *)((void *)0));
}
}
#line 82 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static id3_frame_t id3_rva_get_frame___0(id3_t tag , char const   *ident ) 
{ 
  char const   *id ;
  char const   *tmp ;
  char *s ;
  id3_frame_t f ;
  int nframes ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 85
  tmp = _rva_id___0(tag);
  }
#line 85
  id = tmp;
  {
#line 90
  nframes = id3_frame_count(tag);
  }
  }
#line 91
  if (nframes == -1) {
#line 92
    return ((id3_frame_t )((void *)0));
  }
#line 93
  f = tag->frame_hd;
  {
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 93
    if (! f) {
#line 93
      goto while_break;
    }
    {
    {
#line 94
    tmp___2 = strcmp((char const   *)(f->id), id);
    }
    }
#line 94
    if (tmp___2 == 0) {
      {
      {
#line 96
      tmp___0 = id3_frame_get_raw(f);
      }
#line 96
      s = (char *)tmp___0;
      }
#line 97
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 98
        goto __Cont;
      }
#line 99
      if (ident) {
        {
        {
#line 99
        tmp___1 = strncmp(ident, (char const   *)s, (size_t )f->sz);
        }
        }
#line 99
        if (tmp___1 != 0) {
#line 100
          goto __Cont;
        }
      }
#line 101
      return (f);
    }
    __Cont: /* CIL Label */ 
#line 93
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return ((id3_frame_t )((void *)0));
}
}
#line 119 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static float id3_rva_get_adjust___0(id3_frame_t f , enum id3_rva_channel channel ) 
{ 
  unsigned char *data ;
  float adj ;
  int i ;
  int peakbytes ;
  int adj_fp ;
  void *tmp ;

  {
  {
#line 123
  adj = (float )0.0;
  {
#line 126
  tmp = id3_frame_get_raw(f);
  }
#line 126
  data = (unsigned char *)tmp;
#line 129
  i = 0;
  }
  {
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < f->sz)) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )*(data + i) == 0) {
#line 131
      goto while_break;
    }
#line 129
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if ((int )*(data + i) != 0) {
#line 133
    return ((float )0.0);
  }
#line 136
  i ++;
  {
  {
#line 137
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! (i + 3 < f->sz)) {
#line 137
      goto while_break___0;
    }
#line 139
    if ((int )*(data + i) == (int )((unsigned char )channel)) {
#line 141
      adj_fp = (int )*((signed char *)((data + i) + 1)) << 8;
#line 142
      adj_fp |= (int )*((data + i) + 2);
#line 143
      adj = (float )((double )adj_fp / 512.0);
#line 144
      goto while_break___0;
    }
#line 148
    i += 3;
#line 149
    peakbytes = ((int )*(data + i) + 7) / 8;
#line 150
    i += 1 + peakbytes;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  return (adj);
}
}
#line 37 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
static char const   *_genre_map___0[149]  = 
#line 37 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
  {      "Blues",      "Classic Rock",      "Country",      "Dance", 
        "Disco",      "Funk",      "Grunge",      "Hip-Hop", 
        "Jazz",      "Metal",      "New Age",      "Oldies", 
        "Other",      "Pop",      "R&B",      "Rap", 
        "Reggae",      "Rock",      "Techno",      "Industrial", 
        "Alternative",      "Ska",      "Death Metal",      "Pranks", 
        "Soundtrack",      "Euro-Techno",      "Ambient",      "Trip-Hop", 
        "Vocal",      "Jazz+Funk",      "Fusion",      "Trance", 
        "Classical",      "Instrumental",      "Acid",      "House", 
        "Game",      "Sound Clip",      "Gospel",      "Noise", 
        "Alternative Rock",      "Bass",      "Soul",      "Punk", 
        "Space",      "Meditative",      "Instrumental Pop",      "Instrumental Rock", 
        "Ethnic",      "Gothic",      "Darkwave",      "Techno-Industrial", 
        "Electronic",      "Pop-Folk",      "Eurodance",      "Dream", 
        "Southern Rock",      "Comedy",      "Cult",      "Gangsta", 
        "Top 40",      "Christian Rap",      "Pop/Funk",      "Jungle", 
        "Native US",      "Cabaret",      "New Wave",      "Psychedelic", 
        "Rave",      "Showtunes",      "Trailer",      "Lo-Fi", 
        "Tribal",      "Acid Punk",      "Acid Jazz",      "Polka", 
        "Retro",      "Musical",      "Rock & Roll",      "Hard Rock", 
        "Folk",      "Folk-Rock",      "National Folk",      "Swing", 
        "Fast Fusion",      "Bebob",      "Latin",      "Revival", 
        "Celtic",      "Bluegrass",      "Avant-garde",      "Gothic Rock", 
        "Progressive Rock",      "Psychedelic Rock",      "Symphonic Rock",      "Slow Rock", 
        "Big Band",      "Chorus",      "Easy Listening",      "Acoustic ", 
        "Humour",      "Speech",      "Chanson",      "Opera", 
        "Chamber Music",      "Sonata",      "Symphony",      "Booty Bass", 
        "Primus",      "Porn Groove",      "Satire",      "Slow Jam", 
        "Club",      "Tango",      "Samba",      "Folklore", 
        "Ballad",      "Power Ballad",      "Rhythmic Soul",      "Freestyle", 
        "Duet",      "Punk Rock",      "Drum Solo",      "A Cappella", 
        "Euro-House",      "Dance Hall",      "Goa",      "Drum & Bass", 
        "Club-House",      "Hardcore",      "Terror",      "Indie", 
        "BritPop",      "Negerpunk",      "Polsk Punk",      "Beat", 
        "Christian Gangsta",      "Heavy Metal",      "Black Metal",      "Crossover", 
        "Contemporary Christian",      "Christian Rock",      "Merengue",      "Salsa", 
        "Thrash Metal",      "Anime",      "JPop",      "SynthPop", 
        (char const   *)((void *)0)};
#line 190 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
static int xstrcaseeq___0(char const   *a , char const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 193
    if (*a) {
#line 193
      if (! *b) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
    {
    {
#line 194
    tmp = tolower((int )*a);
    }
    {
#line 194
    tmp___0 = tolower((int )*b);
    }
    }
#line 194
    if (tmp != tmp___0) {
#line 195
      return (0);
    }
#line 196
    a ++;
#line 196
    b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (1);
}
}
#line 50 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static char const   *_rva_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 53
  tmp = id3_get_version(tag);
  }
  }
  {
#line 54
  if ((unsigned int )tmp == 2U) {
#line 54
    goto case_2;
  }
#line 58
  if ((unsigned int )tmp == 3U) {
#line 58
    goto case_3;
  }
#line 61
  if ((unsigned int )tmp == 4U) {
#line 61
    goto case_4;
  }
#line 63
  goto switch_default;
  case_2: /* CIL Label */ 
#line 57
  return ("XRV");
  case_3: /* CIL Label */ 
#line 60
  return ("XRVA");
  case_4: /* CIL Label */ 
#line 62
  return ("RVA2");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return ((char const   *)((void *)0));
}
}
#line 82 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static id3_frame_t id3_rva_get_frame___1(id3_t tag , char const   *ident ) 
{ 
  char const   *id ;
  char const   *tmp ;
  char *s ;
  id3_frame_t f ;
  int nframes ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 85
  tmp = _rva_id___1(tag);
  }
#line 85
  id = tmp;
  {
#line 90
  nframes = id3_frame_count(tag);
  }
  }
#line 91
  if (nframes == -1) {
#line 92
    return ((id3_frame_t )((void *)0));
  }
#line 93
  f = tag->frame_hd;
  {
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 93
    if (! f) {
#line 93
      goto while_break;
    }
    {
    {
#line 94
    tmp___2 = strcmp((char const   *)(f->id), id);
    }
    }
#line 94
    if (tmp___2 == 0) {
      {
      {
#line 96
      tmp___0 = id3_frame_get_raw(f);
      }
#line 96
      s = (char *)tmp___0;
      }
#line 97
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 98
        goto __Cont;
      }
#line 99
      if (ident) {
        {
        {
#line 99
        tmp___1 = strncmp(ident, (char const   *)s, (size_t )f->sz);
        }
        }
#line 99
        if (tmp___1 != 0) {
#line 100
          goto __Cont;
        }
      }
#line 101
      return (f);
    }
    __Cont: /* CIL Label */ 
#line 93
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return ((id3_frame_t )((void *)0));
}
}
#line 119 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/rva.c"
static float id3_rva_get_adjust___1(id3_frame_t f , enum id3_rva_channel channel ) 
{ 
  unsigned char *data ;
  float adj ;
  int i ;
  int peakbytes ;
  int adj_fp ;
  void *tmp ;

  {
  {
#line 123
  adj = (float )0.0;
  {
#line 126
  tmp = id3_frame_get_raw(f);
  }
#line 126
  data = (unsigned char *)tmp;
#line 129
  i = 0;
  }
  {
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < f->sz)) {
#line 129
      goto while_break;
    }
#line 130
    if ((int )*(data + i) == 0) {
#line 131
      goto while_break;
    }
#line 129
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if ((int )*(data + i) != 0) {
#line 133
    return ((float )0.0);
  }
#line 136
  i ++;
  {
  {
#line 137
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! (i + 3 < f->sz)) {
#line 137
      goto while_break___0;
    }
#line 139
    if ((int )*(data + i) == (int )((unsigned char )channel)) {
#line 141
      adj_fp = (int )*((signed char *)((data + i) + 1)) << 8;
#line 142
      adj_fp |= (int )*((data + i) + 2);
#line 143
      adj = (float )((double )adj_fp / 512.0);
#line 144
      goto while_break___0;
    }
#line 148
    i += 3;
#line 149
    peakbytes = ((int )*(data + i) + 7) / 8;
#line 150
    i += 1 + peakbytes;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  return (adj);
}
}
#line 37 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
static char const   *_genre_map___1[149]  = 
#line 37 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
  {      "Blues",      "Classic Rock",      "Country",      "Dance", 
        "Disco",      "Funk",      "Grunge",      "Hip-Hop", 
        "Jazz",      "Metal",      "New Age",      "Oldies", 
        "Other",      "Pop",      "R&B",      "Rap", 
        "Reggae",      "Rock",      "Techno",      "Industrial", 
        "Alternative",      "Ska",      "Death Metal",      "Pranks", 
        "Soundtrack",      "Euro-Techno",      "Ambient",      "Trip-Hop", 
        "Vocal",      "Jazz+Funk",      "Fusion",      "Trance", 
        "Classical",      "Instrumental",      "Acid",      "House", 
        "Game",      "Sound Clip",      "Gospel",      "Noise", 
        "Alternative Rock",      "Bass",      "Soul",      "Punk", 
        "Space",      "Meditative",      "Instrumental Pop",      "Instrumental Rock", 
        "Ethnic",      "Gothic",      "Darkwave",      "Techno-Industrial", 
        "Electronic",      "Pop-Folk",      "Eurodance",      "Dream", 
        "Southern Rock",      "Comedy",      "Cult",      "Gangsta", 
        "Top 40",      "Christian Rap",      "Pop/Funk",      "Jungle", 
        "Native US",      "Cabaret",      "New Wave",      "Psychedelic", 
        "Rave",      "Showtunes",      "Trailer",      "Lo-Fi", 
        "Tribal",      "Acid Punk",      "Acid Jazz",      "Polka", 
        "Retro",      "Musical",      "Rock & Roll",      "Hard Rock", 
        "Folk",      "Folk-Rock",      "National Folk",      "Swing", 
        "Fast Fusion",      "Bebob",      "Latin",      "Revival", 
        "Celtic",      "Bluegrass",      "Avant-garde",      "Gothic Rock", 
        "Progressive Rock",      "Psychedelic Rock",      "Symphonic Rock",      "Slow Rock", 
        "Big Band",      "Chorus",      "Easy Listening",      "Acoustic ", 
        "Humour",      "Speech",      "Chanson",      "Opera", 
        "Chamber Music",      "Sonata",      "Symphony",      "Booty Bass", 
        "Primus",      "Porn Groove",      "Satire",      "Slow Jam", 
        "Club",      "Tango",      "Samba",      "Folklore", 
        "Ballad",      "Power Ballad",      "Rhythmic Soul",      "Freestyle", 
        "Duet",      "Punk Rock",      "Drum Solo",      "A Cappella", 
        "Euro-House",      "Dance Hall",      "Goa",      "Drum & Bass", 
        "Club-House",      "Hardcore",      "Terror",      "Indie", 
        "BritPop",      "Negerpunk",      "Polsk Punk",      "Beat", 
        "Christian Gangsta",      "Heavy Metal",      "Black Metal",      "Crossover", 
        "Contemporary Christian",      "Christian Rock",      "Merengue",      "Salsa", 
        "Thrash Metal",      "Anime",      "JPop",      "SynthPop", 
        (char const   *)((void *)0)};
#line 190 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/genre.c"
static int xstrcaseeq___1(char const   *a , char const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 193
    if (*a) {
#line 193
      if (! *b) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
    {
    {
#line 194
    tmp = tolower((int )*a);
    }
    {
#line 194
    tmp___0 = tolower((int )*b);
    }
    }
#line 194
    if (tmp != tmp___0) {
#line 195
      return (0);
    }
#line 196
    a ++;
#line 196
    b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (1);
}
}
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned short v3_fflag_masks___0[8]  = 
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
  {      (unsigned short)32768,      (unsigned short)16384,      (unsigned short)8192,      (unsigned short)32, 
        (unsigned short)128,      (unsigned short)64,      (unsigned short)0,      (unsigned short)0};
#line 77 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned short v4_fflag_masks___0[8]  = 
#line 77
  {      (unsigned short)16384,      (unsigned short)8192,      (unsigned short)4096,      (unsigned short)64, 
        (unsigned short)8,      (unsigned short)4,      (unsigned short)2,      (unsigned short)1};
#line 96 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned int unsyncsafe_int___0(unsigned char *buf ) 
{ 
  unsigned int retval ;

  {
#line 99
  retval = 0U;
#line 100
  retval = (unsigned int )*(buf + 0);
#line 101
  retval <<= 7;
#line 102
  retval |= (unsigned int )*(buf + 1);
#line 103
  retval <<= 7;
#line 104
  retval |= (unsigned int )*(buf + 2);
#line 105
  retval <<= 7;
#line 106
  retval |= (unsigned int )*(buf + 3);
#line 107
  return (retval);
}
}
#line 114 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int decode_unsync___0(unsigned char *dest , unsigned char *src , int sz ) 
{ 
  unsigned char *dest_save ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 117
  dest_save = dest;
  {
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (sz > 0)) {
#line 119
      goto while_break;
    }
#line 120
    if ((int )*src != 255) {
#line 121
      tmp = dest;
#line 121
      dest ++;
#line 121
      tmp___0 = src;
#line 121
      src ++;
#line 121
      *tmp = *tmp___0;
#line 122
      sz --;
    } else {
#line 124
      tmp___1 = dest;
#line 124
      dest ++;
#line 124
      tmp___2 = src;
#line 124
      src ++;
#line 124
      *tmp___1 = *tmp___2;
#line 125
      sz --;
#line 126
      if (sz <= 0) {
#line 127
        goto while_break;
      }
#line 128
      if ((int )*src == 0) {
#line 129
        src ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return ((int )(dest - dest_save));
}
}
#line 257 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static size_t unsync_fread___0(void *buf , size_t size , FILE *stream , size_t consume_limit ,
                               size_t *consumed ) 
{ 
  unsigned char *p ;
  unsigned char *p_save ;
  size_t cons ;
  int c ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
#line 261
  p = (unsigned char *)buf;
#line 266
  cons = (size_t )0;
#line 267
  p_save = p;
  {
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 269
    if (size > 0U) {
#line 269
      if (! (cons < consume_limit)) {
#line 269
        goto while_break;
      }
    } else {
#line 269
      goto while_break;
    }
    {
    {
#line 270
    c = _IO_getc(stream);
    }
    }
#line 271
    if (c == -1) {
#line 272
      goto while_break;
    }
#line 273
    tmp = p;
#line 273
    p ++;
#line 273
    *tmp = (unsigned char )c;
#line 273
    size --;
#line 273
    cons ++;
#line 274
    if (c == 255) {
      {
      {
#line 275
      c = _IO_getc(stream);
      }
      }
#line 276
      if (c == -1) {
#line 277
        goto while_break;
      }
#line 278
      if (c == 0) {
#line 278
        if (cons < consume_limit) {
#line 280
          cons ++;
        } else {
#line 278
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 281
      if (size > 0U) {
#line 281
        if (cons < consume_limit) {
#line 282
          tmp___0 = p;
#line 282
          p ++;
#line 282
          *tmp___0 = (unsigned char )c;
#line 282
          size --;
#line 282
          cons ++;
        } else {
#line 281
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 288
        tmp___1 = ungetc(c, stream);
        }
        }
#line 288
        if (tmp___1 == -1) {
#line 289
          goto while_break;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if (consumed) {
#line 295
    *consumed = cons;
  }
#line 297
  return ((size_t )(p - p_save));
}
}
#line 304 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int unsync_fseek___0(FILE *stream , long offset , int whence , long *real_offset ) 
{ 
  long roff ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 307
  roff = 0L;
#line 310
  if (whence != 1) {
    {
    {
#line 311
    tmp = fseek(stream, 0L, whence);
    }
    }
#line 311
    if (tmp == -1) {
#line 312
      return (-1);
    }
  }
#line 314
  if (offset > 0L) {
    {
    {
#line 317
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 317
      if (! (offset > 0L)) {
#line 317
        goto while_break;
      }
      {
      {
#line 318
      c = _IO_getc(stream);
      }
      }
#line 319
      if (c == -1) {
#line 320
        goto while_break;
      }
#line 321
      offset --;
#line 322
      roff ++;
#line 323
      if (c == 255) {
        {
        {
#line 324
        c = _IO_getc(stream);
        }
        }
#line 325
        if (c == -1) {
#line 326
          goto while_break;
        }
#line 327
        roff ++;
#line 328
        if (! (c == 0)) {
#line 330
          if (offset > 0L) {
#line 331
            offset --;
          } else {
            {
            {
#line 333
            tmp___0 = ungetc(c, stream);
            }
            }
#line 333
            if (tmp___0 == -1) {
#line 334
              goto while_break;
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 339
  if (offset < 0L) {
    {
    {
#line 342
    _IO_getc(stream);
    }
    }
    {
    {
#line 343
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 343
      if (! (offset < 0L)) {
#line 343
        goto while_break___0;
      }
      {
      {
#line 345
      tmp___1 = fseek(stream, -2L, 1);
      }
      }
#line 345
      if (tmp___1 == -1) {
#line 346
        return (-1);
      }
      {
      {
#line 347
      c = _IO_getc(stream);
      }
      }
#line 348
      if (c == -1) {
#line 349
        goto while_break___0;
      }
#line 350
      roff --;
#line 351
      if (c == 0) {
        {
        {
#line 351
        tmp___3 = ftell(stream);
        }
        }
#line 351
        if (tmp___3 >= 2L) {
          {
          {
#line 352
          tmp___2 = fseek(stream, -2L, 1);
          }
          }
#line 352
          if (tmp___2 == -1) {
#line 353
            return (-1);
          }
          {
          {
#line 354
          c = _IO_getc(stream);
          }
          }
#line 355
          if (c == -1) {
#line 356
            goto while_break___0;
          }
#line 357
          roff --;
#line 358
          if (! (c == 255)) {
#line 360
            if (offset < 0L) {
#line 361
              offset ++;
            } else {
              {
              {
#line 363
              _IO_getc(stream);
              }
              }
            }
          }
        } else {
#line 365
          offset ++;
        }
      } else {
#line 365
        offset ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 368
    tmp___4 = fseek(stream, -1L, 1);
    }
    }
#line 368
    if (tmp___4 == -1) {
#line 369
      return (-1);
    }
  }
#line 373
  if (real_offset) {
#line 374
    *real_offset = roff;
  }
  {
  {
#line 376
  tmp___5 = ferror(stream);
  }
  }
#line 376
  if (tmp___5) {
#line 377
    return (-1);
  }
#line 379
  return (0);
}
}
#line 382 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_header___0(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned int tmp ;

  {
  {
#line 385
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
  {
#line 386
  tmp = unsyncsafe_int___0(hdr + 6);
  }
#line 386
  tag->tagsz = (int )tmp;
  }
#line 387
  return (0);
}
}
#line 390 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_header___0(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned char xhdr[10] ;
  size_t consumed ;
  long offset ;
  int sz ;
  unsigned int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;

  {
  {
#line 398
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
#line 399
  tag->has_ext_hdr = (unsigned int )(((int )*(hdr + 5) >> 6) & 1);
#line 400
  tag->experimental = (unsigned int )(((int )*(hdr + 5) >> 5) & 1);
  {
#line 401
  tmp = unsyncsafe_int___0(hdr + 6);
  }
#line 401
  tag->tagsz = (int )tmp;
  }
#line 404
  if (tag->has_ext_hdr) {
#line 405
    if (tag->unsync) {
      {
      {
#line 406
      tmp___0 = unsync_fread___0((void *)(xhdr), (size_t )10, tag->fp, (size_t )20,
                                 & consumed);
      }
      }
#line 406
      if (tmp___0 < 10U) {
#line 407
        return (-1);
      }
    } else {
      {
      {
#line 409
      tmp___1 = fread((void */* __restrict  */)(xhdr), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 409
      if (tmp___1 < 10U) {
#line 410
        return (-1);
      }
    }
    {
    {
#line 412
    tmp___2 = get_be_int(xhdr);
    }
#line 412
    sz = (int )tmp___2;
    }
#line 413
    if ((int )xhdr[4] & 128) {
#line 413
      tag->has_crc = 1U;
    } else {
#line 413
      tag->has_crc = 0U;
    }
#line 417
    if (tag->unsync) {
      {
      {
#line 418
      tmp___3 = unsync_fseek___0(tag->fp, (long )(sz - 6), 1, & offset);
      }
      }
#line 418
      if (tmp___3 == -1) {
#line 419
        return (-1);
      }
#line 420
      tag->curr_off += (off_t )consumed;
#line 421
      tag->curr_off += offset;
    } else {
#line 423
      if (tag->seekable) {
        {
        {
#line 424
        tmp___4 = fseek(tag->fp, (long )(sz - 6), 1);
        }
        }
#line 424
        if (tmp___4 == -1) {
#line 425
          tag->seekable = 0U;
        }
      }
#line 427
      if (! tag->seekable) {
#line 428
        sz -= 6;
        {
        {
#line 429
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 429
          tmp___6 = sz;
#line 429
          sz --;
#line 429
          if (! (tmp___6 > 0)) {
#line 429
            goto while_break;
          }
          {
          {
#line 430
          tmp___5 = _IO_getc(tag->fp);
          }
          }
#line 430
          if (tmp___5 == -1) {
#line 431
            return (-1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 433
      tag->curr_off += (off_t )sz;
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_header___0(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned char xhdr[6] ;
  int sz ;
  unsigned int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp11 ;

  {
  {
#line 446
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
#line 447
  tag->has_ext_hdr = (unsigned int )(((int )*(hdr + 5) >> 6) & 1);
#line 448
  tag->experimental = (unsigned int )(((int )*(hdr + 5) >> 5) & 1);
#line 449
  tag->has_footer = (unsigned int )(((int )*(hdr + 5) >> 4) & 1);
  {
#line 450
  tmp = unsyncsafe_int___0(hdr + 6);
  }
#line 450
  tag->tagsz = (int )tmp;
  }
#line 453
  if (tag->has_ext_hdr) {
    {
    {
#line 454
    tmp___0 = fread((void */* __restrict  */)(xhdr), (size_t )1, (size_t )6, (FILE */* __restrict  */)tag->fp);
    }
    }
#line 454
    if (tmp___0 < 6U) {
#line 455
      return (-1);
    }
    {
    {
#line 456
    tmp___1 = unsyncsafe_int___0(xhdr);
    }
#line 456
    sz = (int )tmp___1;
    }
#line 457
    if ((int )xhdr[5] & 64) {
#line 457
      tag->is_update = 1U;
    } else {
#line 457
      tag->is_update = 0U;
    }
#line 458
    if ((int )xhdr[5] & 32) {
#line 458
      tag->has_crc = 1U;
    } else {
#line 458
      tag->has_crc = 0U;
    }
#line 459
    if ((int )xhdr[5] & 16) {
#line 459
      tag->has_restrict = 1U;
    } else {
#line 459
      tag->has_restrict = 0U;
    }
#line 463
    tag->curr_off += (off_t )sz;
#line 464
    if (tag->seekable) {
      {
      {
#line 465
      tmp___2 = fseek(tag->fp, (long )(sz - 6), 1);
      }
      }
#line 465
      if (tmp___2 == -1) {
#line 466
        tag->seekable = 0U;
      }
    }
#line 468
    if (! tag->seekable) {
#line 469
      sz -= 6;
      {
      {
#line 470
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 470
        tmp___4 = sz;
#line 470
        sz --;
#line 470
        if (! (tmp___4 > 0)) {
#line 470
          goto while_break;
        }
        {
        {
#line 471
        tmp___3 = _IO_getc(tag->fp);
        }
        }
#line 471
        if (tmp___3 == -1) {
#line 472
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 476
  return (0);
}
}
#line 479 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _look_for_v1tag___0(id3_t tag ) 
{ 
  int sz ;
  char buf[128] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 484
  tmp = fseek(tag->fp, -128L, 2);
  }
  }
#line 484
  if (tmp == -1) {
#line 485
    return (0);
  }
  {
  {
#line 486
  tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )128, (FILE */* __restrict  */)tag->fp);
  }
#line 486
  sz = (int )tmp___0;
  }
#line 487
  if (sz == 128) {
    {
    {
#line 487
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"TAG", (size_t )3);
    }
    }
#line 487
    if (tmp___1 == 0) {
      {
#line 488
      tag->v1.exists = 1U;
      {
#line 489
      strncpy((char */* __restrict  */)(tag->v1.title), (char const   */* __restrict  */)(buf + 3),
              (size_t )30);
      }
      {
#line 490
      strncpy((char */* __restrict  */)(tag->v1.artist), (char const   */* __restrict  */)(buf + 33),
              (size_t )30);
      }
      {
#line 491
      strncpy((char */* __restrict  */)(tag->v1.album), (char const   */* __restrict  */)(buf + 63),
              (size_t )30);
      }
      {
#line 492
      strncpy((char */* __restrict  */)(tag->v1.year), (char const   */* __restrict  */)(buf + 93),
              (size_t )4);
      }
      {
#line 493
      strncpy((char */* __restrict  */)(tag->v1.comment), (char const   */* __restrict  */)(buf + 97),
              (size_t )30);
      }
      }
#line 495
      if ((int )buf[125] == 0) {
#line 495
        tag->v1.track = (unsigned char )buf[126];
      } else {
#line 495
        tag->v1.track = (unsigned char)0;
      }
#line 496
      tag->v1.genre = (unsigned char )buf[127];
    }
  }
#line 498
  return ((int )tag->v1.exists);
}
}
#line 501 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _is_id3_header___0(unsigned char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 504
  tmp = strncmp((char const   *)((char *)buf), "ID3", (size_t )3);
  }
  }
#line 504
  if (tmp != 0) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 3) == 255) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 4) == 255) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 6) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 7) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 8) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 9) >= 128) {
#line 509
    return (0);
  }
#line 510
  return (1);
}
}
#line 513 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _is_id3_footer___0(unsigned char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 516
  tmp = strncmp((char const   *)((char *)buf), "3DI", (size_t )3);
  }
  }
#line 516
  if (tmp != 0) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 3) == 255) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 4) == 255) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 6) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 7) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 8) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 9) >= 128) {
#line 521
    return (0);
  }
#line 522
  return (1);
}
}
#line 525 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _look_for_footer___0(id3_t tag , unsigned char *hdr , long offset_from_end ) 
{ 
  int sz ;
  int tag_found ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 528
  tag_found = 0;
  {
#line 529
  tmp = fseek(tag->fp, offset_from_end, 2);
  }
  }
#line 529
  if (tmp == -1) {
#line 530
    return (0);
  }
  {
  {
#line 531
  tmp___0 = fread((void */* __restrict  */)hdr, (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
  }
#line 531
  sz = (int )tmp___0;
  }
#line 532
  if (sz == 10) {
    {
    {
#line 532
    tmp___5 = _is_id3_footer___0(hdr);
    }
    }
#line 532
    if (tmp___5) {
      {
      {
#line 534
      tmp___1 = unsyncsafe_int___0(hdr + 6);
      }
#line 534
      tag->tagsz = (int )tmp___1;
      {
#line 535
      tmp___2 = fseek(tag->fp, (long )(- tag->tagsz - 10), 1);
      }
      }
#line 535
      if (tmp___2 == -1) {
#line 536
        return (-1);
      }
      {
      {
#line 537
      tag->curr_off = ftell(tag->fp);
      }
#line 538
      tag->offset = tag->curr_off - 10L;
#line 539
      tag->version = *(hdr + 3);
#line 540
      tag->revision = *(hdr + 4);
#line 541
      tmp___4 = 1U;
#line 541
      tag->has_footer = tmp___4;
#line 541
      tmp___3 = tmp___4;
#line 541
      tag->append = tmp___3;
#line 541
      tag->append_req = tmp___3;
#line 542
      tag_found = 1;
      }
    }
  }
#line 544
  return (tag_found);
}
}
#line 660 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_frame_data___0(id3_frame_t f ) 
{ 
  int err ;
  id3_t tag ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 664
  tag = f->id3;
#line 666
  if (tag->seekable) {
    {
    {
#line 667
    tmp = fseek(tag->fp, f->offset, 0);
    }
    }
#line 667
    if (tmp == -1) {
#line 668
      tag->seekable = 0U;
    }
  }
  {
  {
#line 671
  tmp___0 = calloc((size_t )(f->sz + 2), (size_t )1);
  }
#line 671
  f->data = (unsigned char *)tmp___0;
  }
#line 672
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 673
    goto error;
  }
  {
  {
#line 674
  tmp___1 = fread((void */* __restrict  */)f->data, (size_t )1, (size_t )f->sz, (FILE */* __restrict  */)tag->fp);
  }
  }
#line 674
  if (tmp___1 < (size_t )f->sz) {
#line 675
    goto error_free;
  }
  {
  {
#line 676
  tmp___2 = id3_frame_get_flag(f, (enum id3_fflag )6);
  }
  }
#line 676
  if (tmp___2) {
    {
    {
#line 677
    f->sz = decode_unsync___0(f->data, f->data, f->sz);
    }
    }
  }
#line 679
  if ((int )f->id[0] == 84) {
#line 681
    f->curr_txt = (char *)f->data + 1;
  }
#line 684
  return (f->sz);
  error_free: 
  {
  {
#line 686
  tmp___3 = __errno_location();
  }
#line 686
  err = *tmp___3;
  {
#line 687
  free((void *)f->data);
  }
#line 688
  f->data = (unsigned char *)((void *)0);
  {
#line 689
  tmp___4 = __errno_location();
  }
#line 689
  *tmp___4 = err;
  }
  error: 
#line 691
  return (-1);
}
}
#line 694 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_frame_headers___0(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  id3_frame_t newframe ;
  int tagsz ;
  size_t tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 701
  tag->nframes = 0;
  {
#line 702
  tagsz = id3_get_size(tag);
  }
  }
#line 703
  if (tagsz < 1) {
#line 704
    return (tagsz);
  }
  {
  {
#line 707
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 708
    if (tag->curr_off + 10L > (tag->offset + (off_t )tagsz) + 10L) {
#line 709
      goto while_break;
    }
    {
    {
#line 711
    tmp = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
    }
    }
#line 711
    if (tmp < 10U) {
#line 712
      goto error;
    }
    {
#line 713
    tag->curr_off += 10L;
    {
#line 716
    tmp___0 = memcmp((void const   *)(buf), (void const   *)"\000\000\000\000", (size_t )4);
    }
    }
#line 716
    if (tmp___0 == 0) {
#line 717
      goto while_break;
    }
    {
    {
#line 719
    newframe = _id3_frame_new();
    }
    }
#line 720
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 721
      goto error;
    }
    {
    {
#line 722
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )4);
    }
    {
#line 723
    tmp___1 = unsyncsafe_int___0(buf + 4);
    }
#line 723
    newframe->sz = (int )tmp___1;
#line 724
    newframe->flags = (unsigned short )(((unsigned int )buf[8] << 8) | (unsigned int )buf[9]);
#line 725
    newframe->offset = tag->curr_off;
    }
#line 727
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 728
      _id3_frame_destroy(newframe);
      }
      }
#line 729
      goto while_break;
    }
    {
#line 731
    newframe->id3 = tag;
    {
#line 732
    _id3_frame_add(tag, newframe);
    }
    }
#line 742
    if (tag->seekable) {
      {
      {
#line 743
      tmp___2 = fseek(tag->fp, (long )newframe->sz, 1);
      }
      }
#line 743
      if (tmp___2 == -1) {
#line 744
        tag->seekable = 0U;
      }
    }
#line 746
    if (! tag->seekable) {
      {
      {
#line 748
      tmp___3 = _read_v4_frame_data___0(newframe);
      }
      }
#line 748
      if (tmp___3 == -1) {
#line 749
        goto error;
      }
    }
#line 751
    tag->curr_off += (off_t )newframe->sz;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return (tag->nframes);
  error: 
#line 757
  return (-1);
}
}
#line 765 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_frame_data___0(id3_frame_t f ) 
{ 
  int err ;
  size_t consumed ;
  id3_t tag ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 770
  tag = f->id3;
#line 772
  if (tag->seekable) {
    {
    {
#line 773
    tmp = fseek(tag->fp, f->offset, 0);
    }
    }
#line 773
    if (tmp == -1) {
#line 774
      tag->seekable = 0U;
    }
  }
  {
  {
#line 777
  tmp___0 = calloc((size_t )(f->sz + 2), (size_t )1);
  }
#line 777
  f->data = (unsigned char *)tmp___0;
  }
#line 778
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 779
    goto error;
  }
#line 780
  if (tag->unsync) {
    {
    {
#line 781
    tmp___1 = unsync_fread___0((void *)f->data, (size_t )f->sz, tag->fp, (size_t )(f->offset - (off_t )tag->tagsz),
                               & consumed);
    }
    }
#line 781
    if (tmp___1 < (size_t )f->sz) {
#line 783
      goto error_free;
    }
  } else {
    {
    {
#line 785
    tmp___2 = fread((void */* __restrict  */)f->data, (size_t )1, (size_t )f->sz,
                    (FILE */* __restrict  */)tag->fp);
    }
    }
#line 785
    if (tmp___2 < (size_t )f->sz) {
#line 786
      goto error_free;
    }
#line 787
    consumed = (size_t )f->sz;
  }
#line 790
  if ((int )f->id[0] == 84) {
#line 792
    f->curr_txt = (char *)f->data + 1;
  }
#line 795
  return ((int )consumed);
  error_free: 
  {
  {
#line 797
  tmp___3 = __errno_location();
  }
#line 797
  err = *tmp___3;
  {
#line 798
  free((void *)f->data);
  }
#line 799
  f->data = (unsigned char *)((void *)0);
  {
#line 800
  tmp___4 = __errno_location();
  }
#line 800
  *tmp___4 = err;
  }
  error: 
#line 802
  return (-1);
}
}
#line 805 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_frame_headers___0(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  id3_frame_t newframe ;
  size_t consumed ;
  size_t limit ;
  long offset ;
  int tagsz ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 814
  tag->nframes = 0;
  {
#line 815
  tagsz = id3_get_size(tag);
  }
  }
#line 816
  if (tagsz < 1) {
#line 817
    return (tagsz);
  }
  {
  {
#line 820
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 821
    if (tag->unsync) {
      {
#line 828
      limit = (size_t )(((tag->offset + (off_t )tagsz) + 10L) - tag->curr_off);
      {
#line 829
      tmp = unsync_fread___0((void *)(buf), (size_t )10, tag->fp, limit, & consumed);
      }
      }
#line 829
      if (tmp < 10U) {
#line 830
        goto while_break;
      }
#line 831
      tag->curr_off += (off_t )consumed;
    } else {
#line 843
      if (tag->curr_off > (off_t )tagsz) {
#line 844
        goto while_break;
      }
      {
      {
#line 845
      tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 845
      if (tmp___0 < 10U) {
#line 846
        goto error;
      }
#line 847
      tag->curr_off += 10L;
    }
    {
    {
#line 851
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"\000\000\000\000", (size_t )4);
    }
    }
#line 851
    if (tmp___1 == 0) {
#line 852
      goto while_break;
    }
    {
    {
#line 854
    newframe = _id3_frame_new();
    }
    }
#line 855
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 856
      goto error;
    }
    {
    {
#line 857
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )4);
    }
    {
#line 858
    tmp___2 = get_be_int(buf + 4);
    }
#line 858
    newframe->sz = (int )tmp___2;
#line 859
    newframe->flags = (unsigned short )(((unsigned int )buf[8] << 8) | (unsigned int )buf[9]);
#line 860
    newframe->offset = tag->curr_off;
    }
#line 862
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 863
      _id3_frame_destroy(newframe);
      }
      }
#line 864
      goto while_break;
    }
    {
#line 866
    newframe->id3 = tag;
    {
#line 867
    _id3_frame_add(tag, newframe);
    }
    }
#line 877
    if (tag->seekable) {
#line 878
      if (tag->unsync) {
        {
        {
#line 879
        tmp___3 = unsync_fseek___0(tag->fp, (long )newframe->sz, 1, & offset);
        }
        }
#line 879
        if (tmp___3 == -1) {
#line 880
          return (-1);
        }
#line 881
        tag->curr_off += offset;
      } else {
        {
        {
#line 883
        tmp___4 = fseek(tag->fp, (long )newframe->sz, 1);
        }
        }
#line 883
        if (tmp___4 == -1) {
#line 884
          tag->seekable = 0U;
        } else {
#line 886
          tag->curr_off += (off_t )newframe->sz;
        }
      }
    }
#line 889
    if (! tag->seekable) {
      {
      {
#line 891
      tmp___5 = _read_v3_frame_data___0(newframe);
      }
#line 891
      offset = (long )tmp___5;
      }
#line 892
      if (offset == -1L) {
#line 893
        goto error;
      }
#line 894
      tag->curr_off += offset;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (tag->nframes);
  error: 
#line 901
  return (-1);
}
}
#line 909 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_frame_data___0(id3_frame_t f ) 
{ 
  int tmp ;

  {
  {
  {
#line 913
  tmp = _read_v3_frame_data___0(f);
  }
  }
#line 913
  return (tmp);
}
}
#line 916 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_frame_headers___0(id3_t tag ) 
{ 
  unsigned char buf[6] ;
  id3_frame_t newframe ;
  size_t consumed ;
  long offset ;
  int tagsz ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 925
  tag->nframes = 0;
  {
#line 926
  tagsz = id3_get_size(tag);
  }
  }
#line 927
  if (tagsz < 1) {
#line 928
    return (tagsz);
  }
  {
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 932
    if (tag->unsync) {
      {
      {
#line 939
      tmp = unsync_fread___0((void *)(buf), (size_t )6, tag->fp, (size_t )((off_t )(tagsz + 10) - tag->curr_off),
                             & consumed);
      }
      }
#line 939
      if (tmp < 6U) {
#line 941
        goto while_break;
      }
#line 942
      tag->curr_off += (off_t )consumed;
    } else {
#line 949
      if (tag->curr_off + 6L > (off_t )(tagsz + 10)) {
#line 950
        goto while_break;
      }
      {
      {
#line 951
      tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )6, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 951
      if (tmp___0 < 6U) {
#line 952
        goto error;
      }
#line 953
      tag->curr_off += 6L;
    }
    {
    {
#line 957
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"\000\000\000", (size_t )3);
    }
    }
#line 957
    if (tmp___1 == 0) {
#line 958
      goto while_break;
    }
    {
    {
#line 960
    newframe = _id3_frame_new();
    }
    }
#line 961
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 962
      goto error;
    }
    {
    {
#line 963
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )3);
    }
    {
#line 964
    tmp___2 = get_be_int(buf + 2);
    }
#line 964
    newframe->sz = (int )(tmp___2 & 16777215U);
#line 965
    newframe->offset = tag->curr_off;
    }
#line 967
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 968
      _id3_frame_destroy(newframe);
      }
      }
#line 969
      goto while_break;
    }
    {
#line 971
    newframe->id3 = tag;
    {
#line 972
    _id3_frame_add(tag, newframe);
    }
    }
#line 982
    if (tag->seekable) {
#line 983
      if (tag->unsync) {
        {
        {
#line 984
        tmp___3 = unsync_fseek___0(tag->fp, (long )newframe->sz, 1, & offset);
        }
        }
#line 984
        if (tmp___3 == -1) {
#line 985
          return (-1);
        }
#line 986
        tag->curr_off += offset;
      } else {
        {
        {
#line 988
        tmp___4 = fseek(tag->fp, (long )newframe->sz, 1);
        }
        }
#line 988
        if (tmp___4 == -1) {
#line 989
          tag->seekable = 0U;
        } else {
#line 991
          tag->curr_off += (off_t )newframe->sz;
        }
      }
    }
#line 994
    if (! tag->seekable) {
      {
      {
#line 996
      tmp___5 = _read_v2_frame_data___0(newframe);
      }
#line 996
      offset = (long )tmp___5;
      }
#line 997
      if (offset == -1L) {
#line 998
        goto error;
      }
#line 999
      tag->curr_off += offset;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  return (tag->nframes);
  error: 
#line 1006
  return (-1);
}
}
#line 40 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
static struct fid_desc  const  fid_desc_map___0[156]  = 
#line 40 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
  {      {"BUF", "Recommended buffer size"}, 
        {"CNT", "Play counter"}, 
        {"COM", "Comments"}, 
        {"CRA", "Audio encryption"}, 
        {"CRM", "Encrypted meta frame"}, 
        {"ETC", "Event timing codes"}, 
        {"EQU", "Equalization"}, 
        {"GEO", "General encapsulated object"}, 
        {"IPL", "Involved people list"}, 
        {"LNK", "Linked information"}, 
        {"MCI", "Music CD Identifier"}, 
        {"MLL", "MPEG location lookup table"}, 
        {"PIC", "Attached picture"}, 
        {"POP", "Popularimeter"}, 
        {"REV", "Reverb"}, 
        {"RVA", "Relative volume adjustment"}, 
        {"SLT", "Synchronized lyric/text"}, 
        {"STC", "Synced tempo codes"}, 
        {"TAL", "Album/Movie/Show title"}, 
        {"TBP", "BPM (Beats Per Minute)"}, 
        {"TCM", "Composer"}, 
        {"TCO", "Content type"}, 
        {"TCR", "Copyright message"}, 
        {"TDA", "Date"}, 
        {"TDY", "Playlist delay"}, 
        {"TEN", "Encoded by"}, 
        {"TFT", "File type"}, 
        {"TIM", "Time"}, 
        {"TKE", "Initial key"}, 
        {"TLA", "Language(s)"}, 
        {"TLE", "Length"}, 
        {"TMT", "Media type"}, 
        {"TOA", "Original artist(s)/performer(s)"}, 
        {"TOF", "Original filename"}, 
        {"TOL", "Original Lyricist(s)/text writer(s)"}, 
        {"TOR", "Original release year"}, 
        {"TOT", "Original album/Movie/Show title"}, 
        {"TP1", "Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group"}, 
        {"TP2", "Band/Orchestra/Accompaniment"}, 
        {"TP3", "Conductor/Performer refinement"}, 
        {"TP4", "Interpreted, remixed, or otherwise modified by"}, 
        {"TPA", "Part of a set"}, 
        {"TPB", "Publisher"}, 
        {"TRC", "ISRC (International Standard Recording Code)"}, 
        {"TRD", "Recording dates"}, 
        {"TRK", "Track number/Position in set"}, 
        {"TSI", "Size"}, 
        {"TSS", "Software/hardware and settings used for encoding"}, 
        {"TT1", "Content group description"}, 
        {"TT2", "Title/Songname/Content description"}, 
        {"TT3", "Subtitle/Description refinement"}, 
        {"TXT", "Lyricist/text writer"}, 
        {"TXX", "User defined text information frame"}, 
        {"TYE", "Year"}, 
        {"UFI", "Unique file identifier"}, 
        {"ULT", "Unsychronized lyric/text transcription"}, 
        {"WAF", "Official audio file webpage"}, 
        {"WAR", "Official artist/performer webpage"}, 
        {"WAS", "Official audio source webpage"}, 
        {"WCM", "Commercial information"}, 
        {"WCP", "Copyright/Legal information"}, 
        {"WPB", "Publishers official webpage"}, 
        {"WXX", "User defined URL link frame"}, 
        {"AENC", "Audio encryption"}, 
        {"APIC", "Attached picture"}, 
        {"COMM", "Comments"}, 
        {"COMR", "Commercial frame"}, 
        {"ENCR", "Encryption method registration"}, 
        {"EQUA", "Equalisation"}, 
        {"ETCO", "Event timing codes"}, 
        {"GEOB", "General encapsulated object"}, 
        {"GRID", "Group identification registration"}, 
        {"IPLS", "Involved people list"}, 
        {"LINK", "Linked information"}, 
        {"MCDI", "Music CD identifier"}, 
        {"MLLT", "MPEG location lookup table"}, 
        {"OWNE", "Ownership frame"}, 
        {"PRIV", "Private frame"}, 
        {"PCNT", "Play counter"}, 
        {"POPM", "Popularimeter"}, 
        {"POSS", "Position synchronisation frame"}, 
        {"RBUF", "Recommended buffer size"}, 
        {"RVAD", "Relative volume adjustment"}, 
        {"RVRB", "Reverb"}, 
        {"SYLT", "Synchronised lyric/text"}, 
        {"SYTC", "Synchronised tempo codes"}, 
        {"TALB", "Album/Movie/Show title"}, 
        {"TBPM", "BPM (beats per minute)"}, 
        {"TCOM", "Composer"}, 
        {"TCON", "Content type"}, 
        {"TCOP", "Copyright message"}, 
        {"TDAT", "Date"}, 
        {"TDLY", "Playlist delay"}, 
        {"TENC", "Encoded by"}, 
        {"TEXT", "Lyricist/Text writer"}, 
        {"TFLT", "File type"}, 
        {"TIME", "Time"}, 
        {"TIT1", "Content group description"}, 
        {"TIT2", "Title/songname/content description"}, 
        {"TIT3", "Subtitle/Description refinement"}, 
        {"TKEY", "Initial key"}, 
        {"TLAN", "Language(s)"}, 
        {"TLEN", "Length"}, 
        {"TMED", "Media type"}, 
        {"TOAL", "Original album/movie/show title"}, 
        {"TOFN", "Original filename"}, 
        {"TOLY", "Original lyricist(s)/text writer(s)"}, 
        {"TOPE", "Original artist(s)/performer(s)"}, 
        {"TORY", "Original release year"}, 
        {"TOWN", "File owner/licensee"}, 
        {"TPE1", "Lead performer(s)/Soloist(s)"}, 
        {"TPE2", "Band/orchestra/accompaniment"}, 
        {"TPE3", "Conductor/performer refinement"}, 
        {"TPE4", "Interpreted, remixed, or otherwise modified by"}, 
        {"TPOS", "Part of a set"}, 
        {"TPUB", "Publisher"}, 
        {"TRCK", "Track number/Position in set"}, 
        {"TRDA", "Recording dates"}, 
        {"TRSN", "Internet radio station name"}, 
        {"TRSO", "Internet radio station owner"}, 
        {"TSIZ", "Size"}, 
        {"TSRC", "ISRC (international standard recording code)"}, 
        {"TSSE", "Software/Hardware and settings used for encoding"}, 
        {"TYER", "Year"}, 
        {"TXXX", "User defined text information frame"}, 
        {"UFID", "Unique file identifier"}, 
        {"USER", "Terms of use"}, 
        {"USLT", "Unsynchronised lyric/text transcription"}, 
        {"WCOM", "Commercial information"}, 
        {"WCOP", "Copyright/Legal information"}, 
        {"WOAF", "Official audio file webpage"}, 
        {"WOAR", "Official artist/performer webpage"}, 
        {"WOAS", "Official audio source webpage"}, 
        {"WORS", "Official Internet radio station homepage"}, 
        {"WPAY", "Payment"}, 
        {"WPUB", "Publishers official webpage"}, 
        {"WXXX", "User defined URL link frame"}, 
        {"ASPI", "Audio seek point index"}, 
        {"EQU2", "Equalisation (2)"}, 
        {"RVA2", "Relative volume adjustment (2)"}, 
        {"SEEK", "Seek frame"}, 
        {"SIGN", "Signature frame"}, 
        {"TDEN", "Encoding time"}, 
        {"TDOR", "Original release time"}, 
        {"TDRC", "Recording time"}, 
        {"TDRL", "Release time"}, 
        {"TDTG", "Tagging time"}, 
        {"TIPL", "Involved people list"}, 
        {"TMCL", "Musician credits list"}, 
        {"TMOO", "Mood"}, 
        {"TPRO", "Produced notice"}, 
        {"TSOA", "Album sort order"}, 
        {"TSOP", "Performer sort order"}, 
        {"TSOT", "Title sort order"}, 
        {"TSST", "Set subtitle"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 81 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xrename___1(char const   *oldpath , char const   *newpath ) ;
#line 82
static int xmkstemp___1(char *template ) ;
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static size_t unsync_fwrite___0(void *buf , size_t size , FILE *stream , int *state ,
                                size_t *written ) 
{ 
  unsigned char *p ;
  unsigned char *p_save ;
  size_t writ ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 98
  p = (unsigned char *)buf;
#line 103
  writ = (size_t )0;
#line 104
  p_save = p;
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! (size > 0U)) {
#line 106
      goto while_break;
    }
#line 107
    c = (int )*p;
#line 109
    if (*state) {
#line 109
      if (c == 0) {
#line 109
        goto _L;
      } else
#line 109
      if ((c & 224) == 224) {
        _L: /* CIL Label */ 
        {
        {
#line 111
        tmp = _IO_putc(0, stream);
        }
        }
#line 111
        if (tmp == -1) {
#line 112
          goto while_break;
        }
#line 113
        writ ++;
      }
    }
    {
#line 115
    *state = c == 255;
    {
#line 116
    tmp___0 = _IO_putc(c, stream);
    }
    }
#line 116
    if (tmp___0 == -1) {
#line 117
      goto while_break;
    }
#line 118
    p ++;
#line 118
    size --;
#line 118
    writ ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (written) {
#line 122
    *written = writ;
  }
#line 124
  return ((size_t )(p - p_save));
}
}
#line 132 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int encode_unsync___0(unsigned char *dest , unsigned char *src , int sz ) 
{ 
  unsigned char *dest_save ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 135
  dest_save = dest;
  {
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (sz > 0)) {
#line 137
      goto while_break;
    }
#line 138
    if ((int )*src != 255) {
#line 139
      tmp = dest;
#line 139
      dest ++;
#line 139
      tmp___0 = src;
#line 139
      src ++;
#line 139
      *tmp = *tmp___0;
#line 140
      sz --;
    } else {
#line 142
      tmp___1 = dest;
#line 142
      dest ++;
#line 142
      tmp___2 = src;
#line 142
      src ++;
#line 142
      *tmp___1 = *tmp___2;
#line 143
      sz --;
#line 144
      if (sz <= 0) {
#line 145
        goto while_break;
      }
#line 146
      if ((int )*src == 0) {
#line 147
        tmp___3 = dest;
#line 147
        dest ++;
#line 147
        *tmp___3 = (unsigned char)0;
      } else
#line 146
      if (((int )*src & 224) == 224) {
#line 147
        tmp___3 = dest;
#line 147
        dest ++;
#line 147
        *tmp___3 = (unsigned char)0;
      }
#line 148
      tmp___4 = dest;
#line 148
      dest ++;
#line 148
      tmp___5 = src;
#line 148
      src ++;
#line 148
      *tmp___4 = *tmp___5;
#line 149
      sz --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((int )(dest - dest_save));
}
}
#line 169 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void syncsafe_int___0(unsigned char *buf , unsigned int x ) 
{ 


  {
#line 172
  *(buf + 3) = (unsigned char )(x & 127U);
#line 173
  x >>= 7;
#line 174
  *(buf + 2) = (unsigned char )(x & 127U);
#line 175
  x >>= 7;
#line 176
  *(buf + 1) = (unsigned char )(x & 127U);
#line 177
  x >>= 7;
#line 178
  *(buf + 0) = (unsigned char )(x & 127U);
#line 179
  return;
}
}
#line 182 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_frame_data_sizes___0(id3_t tag ) 
{ 
  int sz ;
  id3_frame_t f ;
  int tmp ;

  {
#line 185
  sz = 0;
#line 188
  f = tag->frame_hd;
  {
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 188
    if (! f) {
#line 188
      goto while_break;
    }
    {
    {
#line 189
    tmp = id3_frame_get_size(f);
    }
#line 189
    sz += tmp;
#line 188
    f = f->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (sz);
}
}
#line 195 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_v4_frame_sizes___0(id3_t tag ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 198
  tmp = id3_frame_count(tag);
  }
#line 198
  nframes = tmp;
  {
#line 199
  tmp___0 = _sum_frame_data_sizes___0(tag);
  }
  }
#line 199
  return (nframes * 10 + tmp___0);
}
}
#line 203 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_v3_frame_sizes___0(id3_t tag ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 206
  tmp = id3_frame_count(tag);
  }
#line 206
  nframes = tmp;
  {
#line 207
  tmp___0 = _sum_frame_data_sizes___0(tag);
  }
  }
#line 207
  return (nframes * 10 + tmp___0);
}
}
#line 225 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _form_v4_header___0(id3_t tag , unsigned char *hdr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 228
  memcpy((void */* __restrict  */)hdr, (void const   */* __restrict  */)"ID3", (size_t )3);
  }
#line 229
  *(hdr + 3) = tag->version;
#line 230
  *(hdr + 4) = tag->revision;
#line 231
  *(hdr + 5) = (unsigned char)0;
  }
#line 232
  if (tag->unsync) {
#line 233
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 128);
  }
#line 235
  if (tag->experimental) {
#line 236
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 32);
  }
#line 238
  if (tag->append_req) {
#line 239
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 16);
  }
  {
  {
#line 240
  syncsafe_int___0(hdr + 6, (unsigned int )tag->tagsz);
  }
  }
#line 241
  return;
}
}
#line 243 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_header___0(id3_t tag , FILE *out ) 
{ 
  unsigned char buf[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;

  {
  {
  {
#line 248
  _form_v4_header___0(tag, buf);
  }
  {
#line 250
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 250
  if (tmp < 10U) {
#line 251
    return (-1);
  }
#line 252
  tag->curr_off += 10L;
#line 254
  return (0);
}
}
#line 257 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_footer___0(id3_t tag , FILE *out ) 
{ 
  unsigned char buf[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 262
  _form_v4_header___0(tag, buf);
  }
  {
#line 265
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)"3DI", (size_t )3);
  }
  {
#line 267
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 267
  if (tmp < 10U) {
#line 268
    return (-1);
  }
#line 269
  tag->curr_off += 10L;
#line 271
  return (0);
}
}
#line 274 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_frames___0(id3_t tag , FILE *out ) 
{ 
  id3_frame_t f ;
  int sz ;
  int unsync_bufsz ;
  unsigned char hdr[10] ;
  unsigned char *buf ;
  unsigned char *unsync_buf ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;

  {
#line 278
  unsync_bufsz = 512;
#line 280
  unsync_buf = (unsigned char *)((void *)0);
#line 282
  f = tag->frame_hd;
  {
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 282
    if (! f) {
#line 282
      goto while_break;
    }
#line 284
    if (tag->unsync) {
      {
      {
#line 285
      id3_frame_set_flag(f, (enum id3_fflag )6);
      }
      }
    }
    {
    {
#line 288
    memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)(f->id),
           (size_t )4);
    }
    {
#line 289
    syncsafe_int___0(hdr + 4, (unsigned int )f->sz);
    }
#line 290
    hdr[8] = (unsigned char )(((int )f->flags >> 8) & 255);
#line 291
    hdr[9] = (unsigned char )((int )f->flags & 255);
    {
#line 293
    tmp = id3_frame_get_raw(f);
    }
#line 293
    buf = (unsigned char *)tmp;
    }
#line 294
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 295
      goto __Cont;
    }
    {
#line 298
    f->offset = tag->curr_off + 10L;
    {
#line 300
    tmp___5 = id3_frame_get_flag(f, (enum id3_fflag )6);
    }
    }
#line 300
    if (tmp___5) {
#line 301
      if ((unsigned long )unsync_buf == (unsigned long )((void *)0)) {
#line 301
        goto _L;
      } else
#line 301
      if (unsync_bufsz < (f->sz * 3) / 2) {
        _L: /* CIL Label */ 
#line 302
        unsync_bufsz = (f->sz * 3) / 2;
#line 303
        if (unsync_buf) {
          {
          {
#line 304
          free((void *)unsync_buf);
          }
          }
        }
        {
        {
#line 305
        tmp___0 = malloc((size_t )unsync_bufsz);
        }
#line 305
        unsync_buf = (unsigned char *)tmp___0;
        }
#line 306
        if ((unsigned long )unsync_buf == (unsigned long )((void *)0)) {
#line 307
          return (-1);
        }
      }
      {
      {
#line 309
      sz = encode_unsync___0(unsync_buf, buf, f->sz);
      }
      {
#line 312
      syncsafe_int___0(hdr + 4, (unsigned int )sz);
      }
      }
#line 315
      if (! tag->unsync) {
#line 315
        if (sz == f->sz) {
          {
          {
#line 316
          id3_frame_clear_flag(f, (enum id3_fflag )6);
          }
          }
        }
      }
      {
      {
#line 319
      tmp___1 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 319
      if (tmp___1 < 10U) {
#line 320
        return (-1);
      }
      {
      {
#line 322
      tmp___2 = fwrite((void const   */* __restrict  */)unsync_buf, (size_t )1, (size_t )sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 322
      if (tmp___2 < (size_t )sz) {
#line 323
        return (-1);
      }
#line 324
      tag->curr_off += (off_t )(10 + sz);
    } else {
      {
      {
#line 329
      tmp___3 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 329
      if (tmp___3 < 10U) {
#line 330
        return (-1);
      }
      {
      {
#line 332
      tmp___4 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )f->sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 332
      if (tmp___4 < (size_t )f->sz) {
#line 333
        return (-1);
      }
#line 334
      tag->curr_off += (off_t )(10 + f->sz);
    }
    {
    {
#line 338
    free((void *)f->data);
    }
#line 339
    f->data = (unsigned char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 282
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (unsync_buf) {
    {
    {
#line 343
    free((void *)unsync_buf);
    }
    }
  }
#line 345
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v3_header___0(id3_t tag , FILE *out ) 
{ 
  unsigned char hdr[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 358
  memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)"ID3", (size_t )3);
  }
#line 359
  hdr[3] = tag->version;
#line 360
  hdr[4] = tag->revision;
#line 361
  hdr[5] = (unsigned char)0;
  }
#line 362
  if (tag->unsync) {
#line 363
    hdr[5] = (unsigned char )((int )hdr[5] | 128);
  }
#line 365
  if (tag->experimental) {
#line 366
    hdr[5] = (unsigned char )((int )hdr[5] | 32);
  }
  {
  {
#line 367
  syncsafe_int___0(hdr + 6, (unsigned int )tag->tagsz);
  }
  {
#line 368
  tmp = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 368
  if (tmp < 10U) {
#line 369
    return (-1);
  }
#line 370
  tag->curr_off += 10L;
#line 372
  return (0);
}
}
#line 375 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v3_frames___0(id3_t tag , FILE *out ) 
{ 
  id3_frame_t f ;
  int fwrite_state ;
  size_t consumed ;
  unsigned char hdr[10] ;
  unsigned char *buf ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp13 ;

  {
#line 379
  fwrite_state = 0;
#line 384
  f = tag->frame_hd;
  {
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 384
    if (! f) {
#line 384
      goto while_break;
    }
    {
    {
#line 387
    memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)(f->id),
           (size_t )4);
    }
    {
#line 388
    put_be_int(hdr + 4, (unsigned int )f->sz);
    }
#line 389
    hdr[8] = (unsigned char )(((int )f->flags >> 8) & 255);
#line 390
    hdr[9] = (unsigned char )((int )f->flags & 255);
    {
#line 392
    tmp = id3_frame_get_raw(f);
    }
#line 392
    buf = (unsigned char *)tmp;
    }
#line 393
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 394
      goto __Cont;
    }
#line 397
    f->offset = tag->curr_off + 10L;
#line 399
    if (tag->unsync) {
      {
      {
#line 401
      tmp___0 = unsync_fwrite___0((void *)(hdr), (size_t )10, out, & fwrite_state,
                                  & consumed);
      }
      }
#line 401
      if (tmp___0 < 10U) {
#line 402
        return (-1);
      }
      {
#line 403
      tag->curr_off += (off_t )consumed;
      {
#line 405
      tmp___1 = unsync_fwrite___0((void *)buf, (size_t )f->sz, out, & fwrite_state,
                                  & consumed);
      }
      }
#line 405
      if (tmp___1 < (size_t )f->sz) {
#line 406
        return (-1);
      }
#line 407
      tag->curr_off += (off_t )consumed;
    } else {
      {
      {
#line 410
      tmp___2 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 410
      if (tmp___2 < 10U) {
#line 411
        return (-1);
      }
      {
      {
#line 413
      tmp___3 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )f->sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 413
      if (tmp___3 < (size_t )f->sz) {
#line 414
        return (-1);
      }
#line 415
      tag->curr_off += (off_t )(10 + f->sz);
    }
    {
    {
#line 419
    free((void *)f->data);
    }
#line 420
    f->data = (unsigned char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 384
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return (0);
}
}
#line 428 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _build_v1_tag___0(char *buf , id3_t tag ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 432
  memset((void *)buf, 0, (size_t )128);
  }
  {
#line 433
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"TAG");
  }
  {
#line 434
  strncpy((char */* __restrict  */)(buf + 3), (char const   */* __restrict  */)(tag->v1.title),
          (size_t )30);
  }
  {
#line 435
  strncpy((char */* __restrict  */)(buf + 33), (char const   */* __restrict  */)(tag->v1.artist),
          (size_t )30);
  }
  {
#line 436
  strncpy((char */* __restrict  */)(buf + 63), (char const   */* __restrict  */)(tag->v1.album),
          (size_t )30);
  }
  {
#line 437
  strncpy((char */* __restrict  */)(buf + 93), (char const   */* __restrict  */)(tag->v1.year),
          (size_t )4);
  }
  {
#line 438
  strncpy((char */* __restrict  */)(buf + 97), (char const   */* __restrict  */)(tag->v1.comment),
          (size_t )30);
  }
  }
#line 439
  if ((int )*(buf + 125) == 0) {
#line 440
    *(buf + 126) = (char )tag->v1.track;
  }
#line 441
  *(buf + 127) = (char )tag->v1.genre;
#line 442
  return;
}
}
#line 446 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _calculate_tag_sizes___0(id3_t tag , int *pold_sz , int *pnew_sz ) 
{ 
  int old_tagsz ;
  int new_tagsz ;
  int frames_sz ;
  int padded_sz ;

  {
  {
  {
#line 455
  old_tagsz = id3_get_size(tag);
  }
  }
#line 456
  if (old_tagsz > 0) {
#line 457
    old_tagsz += 10;
  }
#line 458
  if (tag->has_footer) {
#line 459
    old_tagsz += 10;
  }
  {
#line 462
  if ((int )tag->version == 4) {
#line 462
    goto case_4;
  }
#line 465
  if ((int )tag->version == 3) {
#line 465
    goto case_3;
  }
#line 468
  goto switch_default;
  case_4: /* CIL Label */ 
  {
  {
#line 463
  frames_sz = _sum_v4_frame_sizes___0(tag);
  }
  }
#line 464
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 466
  frames_sz = _sum_v3_frame_sizes___0(tag);
  }
  }
#line 467
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 469
  abort();
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 501
  if ((unsigned int )tag->pad_policy == 1U) {
#line 501
    goto case_1;
  }
#line 504
  if ((unsigned int )tag->pad_policy == 2U) {
#line 504
    goto case_2;
  }
#line 474
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 476
  new_tagsz = frames_sz + 10;
#line 477
  if (old_tagsz >= new_tagsz) {
#line 478
    new_tagsz = old_tagsz;
  } else {
#line 481
    new_tagsz += 32;
#line 482
    if (new_tagsz <= 256) {
#line 484
      new_tagsz = 256;
    } else
#line 485
    if (new_tagsz <= 32768) {
#line 487
      padded_sz = 1;
#line 488
      new_tagsz --;
      {
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 489
        if (! (new_tagsz > 0)) {
#line 489
          goto while_break;
        }
#line 490
        padded_sz <<= 1;
#line 491
        new_tagsz >>= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 493
      new_tagsz = padded_sz;
    } else {
#line 496
      new_tagsz --;
#line 497
      new_tagsz = ((new_tagsz >> 14) + 1) << 14;
    }
  }
#line 500
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 502
  new_tagsz = frames_sz + 10;
#line 503
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 505
  new_tagsz = frames_sz + 10;
#line 506
  if (tag->requested_sz > new_tagsz) {
#line 507
    new_tagsz = tag->requested_sz;
  }
#line 508
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 513
  if (tag->append_req) {
#line 514
    new_tagsz = frames_sz + 20;
  }
#line 517
  if (frames_sz == 0) {
#line 518
    new_tagsz = 0;
  }
#line 521
  tag->tagsz = new_tagsz;
#line 522
  if (tag->tagsz) {
#line 523
    tag->tagsz -= 10;
  }
#line 524
  if (tag->append_req) {
#line 525
    tag->tagsz -= 10;
  }
#line 528
  *pold_sz = old_tagsz;
#line 529
  *pnew_sz = new_tagsz;
#line 530
  return;
}
}
#line 533 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_tag___0(id3_t tag , FILE *out ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 536
  tmp = id3_frame_count(tag);
  }
#line 536
  nframes = tmp;
  }
#line 538
  if (nframes > 0) {
    {
#line 540
    if ((int )tag->version == 4) {
#line 540
      goto case_4;
    }
#line 550
    if ((int )tag->version == 3) {
#line 550
      goto case_3;
    }
#line 556
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 541
    tag->has_footer = tag->append_req;
    {
#line 542
    tmp___0 = _write_v4_header___0(tag, out);
    }
    }
#line 542
    if (tmp___0 == -1) {
#line 543
      return (-1);
    }
    {
    {
#line 544
    tmp___1 = _write_v4_frames___0(tag, out);
    }
    }
#line 544
    if (tmp___1 == -1) {
#line 545
      return (-1);
    }
#line 546
    if (tag->append_req) {
      {
      {
#line 547
      tmp___2 = _write_v4_footer___0(tag, out);
      }
      }
#line 547
      if (tmp___2 == -1) {
#line 548
        return (-1);
      }
    }
#line 549
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 551
    tmp___3 = _write_v3_header___0(tag, out);
    }
    }
#line 551
    if (tmp___3 == -1) {
#line 552
      return (-1);
    }
    {
    {
#line 553
    tmp___4 = _write_v3_frames___0(tag, out);
    }
    }
#line 553
    if (tmp___4 == -1) {
#line 554
      return (-1);
    }
#line 555
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 557
    abort();
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 561
  return (0);
}
}
#line 910 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static char sfx___2[7]  = {      (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'A',      (char )'A',      (char )'\000'};
#line 907 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xmkstemp___1(char *template ) 
{ 
  char *p ;
  int fd ;
  int i ;
  int done ;
  size_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 914
  tmp = strlen((char const   *)template);
  }
#line 914
  p = (template + tmp) - 6;
  {
#line 915
  tmp___1 = strcmp((char const   *)p, "XXXXXX");
  }
  }
#line 915
  if (tmp___1 != 0) {
    {
    {
#line 916
    tmp___0 = __errno_location();
    }
#line 916
    *tmp___0 = 22;
    }
#line 917
    return (-1);
  }
  {
  {
#line 920
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 921
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(sfx___2));
    }
#line 924
    done = 0;
#line 924
    i = 5;
    }
    {
    {
#line 925
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 925
      if (! done) {
#line 925
        if (! (i >= 0)) {
#line 925
          goto while_break___0;
        }
      } else {
#line 925
        goto while_break___0;
      }
#line 926
      sfx___2[i] = (char )((int )sfx___2[i] + 1);
#line 927
      if ((int )sfx___2[i] > 90) {
#line 928
        sfx___2[i] = (char )'A';
#line 929
        i --;
      } else {
#line 931
        done = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 934
    if (! done) {
      {
      {
#line 935
      tmp___2 = __errno_location();
      }
#line 935
      *tmp___2 = 17;
      }
#line 936
      return (-1);
    }
    {
    {
#line 940
    fd = open((char const   *)template, 194, 384);
    }
    }
#line 920
    if (fd == -1) {
      {
      {
#line 920
      tmp___3 = __errno_location();
      }
      }
#line 920
      if (! (*tmp___3 == 17)) {
#line 920
        goto while_break;
      }
    } else {
#line 920
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return (fd);
}
}
#line 952 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xrename___1(char const   *oldpath , char const   *newpath ) 
{ 
  FILE *in ;
  FILE *out ;
  char buf[4096] ;
  size_t sz ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 959
  tmp = strcmp(oldpath, newpath);
  }
  }
#line 959
  if (tmp == 0) {
#line 960
    return (0);
  }
  {
  {
#line 967
  tmp___8 = rename(oldpath, newpath);
  }
  }
#line 967
  if (tmp___8 == -1) {
    {
    {
#line 968
    tmp___7 = __errno_location();
    }
    }
#line 968
    if (*tmp___7 == 18) {
      {
      {
#line 970
      tmp___0 = unlink(newpath);
      }
      }
#line 970
      if (tmp___0 == -1) {
        {
        {
#line 970
        tmp___1 = __errno_location();
        }
        }
#line 970
        if (*tmp___1 != 2) {
#line 971
          return (-1);
        }
      }
      {
      {
#line 973
      in = fopen((char const   */* __restrict  */)oldpath, (char const   */* __restrict  */)"rb");
      }
      }
#line 974
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 975
        return (-1);
      }
      {
      {
#line 976
      out = fopen((char const   */* __restrict  */)newpath, (char const   */* __restrict  */)"wb");
      }
      }
#line 977
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        {
        {
#line 978
        fclose(in);
        }
        }
#line 979
        return (-1);
      }
      {
      {
#line 982
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 982
        sz = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )4096, (FILE */* __restrict  */)in);
        }
        }
#line 982
        if (! (sz > 0U)) {
#line 982
          goto while_break;
        }
        {
        {
#line 983
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, sz, (FILE */* __restrict  */)out);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 985
      tmp___2 = ferror(in);
      }
      }
#line 985
      if (tmp___2) {
        {
        {
#line 986
        fclose(in);
        }
        {
#line 987
        fclose(out);
        }
        }
#line 988
        return (-1);
      } else {
        {
        {
#line 985
        tmp___3 = ferror(out);
        }
        }
#line 985
        if (tmp___3) {
          {
          {
#line 986
          fclose(in);
          }
          {
#line 987
          fclose(out);
          }
          }
#line 988
          return (-1);
        }
      }
      {
      {
#line 990
      tmp___4 = fclose(in);
      }
      }
#line 990
      if (tmp___4 == -1) {
        {
        {
#line 991
        fclose(out);
        }
        }
#line 992
        return (-1);
      }
      {
      {
#line 994
      tmp___5 = fclose(out);
      }
      }
#line 994
      if (tmp___5 == -1) {
#line 995
        return (-1);
      }
      {
      {
#line 997
      tmp___6 = unlink(oldpath);
      }
      }
#line 997
      if (tmp___6 == -1) {
#line 998
        return (-1);
      }
    } else {
#line 1000
      return (-1);
    }
  }
#line 1004
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_link___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 62
static int convert_apic___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 63
static int convert_time___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 64
static int convert_tcon___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 65
static int convert_rva___0(id3_frame_t f , char const   *from , char const   *to ,
                           int backward ) ;
#line 67 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  _convert_map_v2to3___0[65]  = 
#line 67
  {      {"BUF", "RBUF", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CNT",
      "PCNT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"COM",
      "COMM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CRA",
      "AENC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CRM",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"ETC", "ETCO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"EQU",
      "EQUA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"GEO",
      "GEOB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"IPL",
      "IPLS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"LNK",
      "LINK", & convert_link___0}, 
        {"MCI", "MCDI", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"MLL",
      "MLLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"PIC",
      "APIC", & convert_apic___0}, 
        {"POP", "POPM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"REV",
      "RVRB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"RVA",
      "RVAD", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"SLT",
      "SYLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"STC",
      "SYTC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TAL",
      "TALB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TBP",
      "TBPM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCM",
      "TCOM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCO",
      "TCON", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCR",
      "TCOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TDA",
      "TDAT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TDY",
      "TDLY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TEN",
      "TENC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TFT",
      "TFLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TIM",
      "TIME", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TKE",
      "TKEY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TLA",
      "TLAN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TLE",
      "TLEN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TMT",
      "TMED", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOA",
      "TOPE", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOF",
      "TOFN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOL",
      "TOLY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOR",
      "TORY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOT",
      "TOAL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP1",
      "TPE1", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP2",
      "TPE2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP3",
      "TPE3", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP4",
      "TPE4", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TPA",
      "TPOS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TPB",
      "TPUB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRC",
      "TSRC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRD",
      "TRDA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRK",
      "TRCK", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TSI",
      "TSIZ", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TSS",
      "TSSE", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT1",
      "TIT1", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT2",
      "TIT2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT3",
      "TIT3", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TXT",
      "TEXT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TXX",
      "TXXX", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TYE",
      "TYER", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"UFI",
      "UFID", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"ULT",
      "USLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAF",
      "WOAF", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAR",
      "WOAR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAS",
      "WOAS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WCM",
      "WCOM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WCP",
      "WCOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WPB",
      "WPUB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WXX",
      "WXXX", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"XRV",
      "XRVA", & convert_rva___0}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(id3_frame_t  ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         int  ))((void *)0)}};
#line 137 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  _convert_map_v3to4___0[30]  = 
#line 137
  {      {"EQUA", (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {"IPLS",
      "TIPL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"RVAD",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"TDAT", "TDRC", & convert_time___0}, 
        {"TIME", "TDRC", & convert_time___0}, 
        {"TORY", "TDOR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRDA",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"TSIZ", (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {"TYER",
      "TDRC", & convert_time___0}, 
        {"XRVA", "RVA2", & convert_rva___0}, 
        {(char const   *)((void *)0), "ASPI", (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "EQU2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "RVA2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "SEEK", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "SIGN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDEN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDOR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDRC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDRL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDTG", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TIPL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TMCL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TMOO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TPRO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSST", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCON",
      "TCON", & convert_tcon___0}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(id3_frame_t  ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         int  ))((void *)0)}};
#line 181 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_link___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 


  {
#line 185
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct imgtype_mimetype_struct  const  imgtype_mimetype_map___0[11]  = 
#line 193
  {      {"jpg", "jpeg"}, 
        {"tif", "tiff"}, 
        {"xbm", "x-xbitmap"}, 
        {"xpm", "x-xpixmap"}, 
        {"xwd", "x-xwindowdump"}, 
        {"ras", "x-cmu-raster"}, 
        {"pnm", "x-portable-anymap"}, 
        {"pbm", "x-portable-bitmap"}, 
        {"pgm", "x-portable-graymap"}, 
        {"rgb", "x-rgb"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_apic_forward___0(id3_frame_t f ) 
{ 
  char imgtype[4] ;
  char mimetype[32] ;
  struct imgtype_mimetype_struct  const  *im_map ;
  unsigned char *data ;
  int i ;
  int newsz ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 218
  tmp = id3_frame_get_raw(f);
  }
#line 218
  data = (unsigned char *)tmp;
  }
#line 219
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 220
    return (0);
  }
  {
  {
#line 221
  memcpy((void */* __restrict  */)(imgtype), (void const   */* __restrict  */)(data + 1),
         (size_t )3);
  }
#line 222
  imgtype[3] = (char )'\000';
#line 223
  i = 0;
  }
  {
  {
#line 223
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < 3)) {
#line 223
      goto while_break;
    }
    {
    {
#line 224
    tmp___0 = tolower((int )imgtype[i]);
    }
#line 224
    imgtype[i] = (char )tmp___0;
#line 223
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 227
  strcpy((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)"image/");
  }
#line 228
  im_map = imgtype_mimetype_map___0;
  }
  {
  {
#line 229
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! im_map->imgtype) {
#line 229
      goto while_break___0;
    }
    {
    {
#line 230
    tmp___1 = strcmp((char const   *)(imgtype), (char const   *)im_map->imgtype);
    }
    }
#line 230
    if (tmp___1 == 0) {
      {
      {
#line 231
      strcat((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)im_map->mimetype);
      }
      }
#line 232
      goto while_break___0;
    }
#line 234
    im_map ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 238
  if ((unsigned long )im_map->imgtype == (unsigned long )((void *)0)) {
    {
    {
#line 239
    strcat((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)(imgtype));
    }
    }
  }
  {
  {
#line 241
  tmp___2 = strlen((char const   *)(mimetype));
  }
#line 241
  i = (int )tmp___2;
#line 242
  newsz = ((f->sz - 3) + i) + 1;
  {
#line 243
  tmp___3 = malloc((size_t )newsz);
  }
#line 243
  f->data = (unsigned char *)tmp___3;
  }
#line 244
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 245
    f->data = data;
#line 246
    return (-1);
  }
  {
#line 248
  *(f->data + 0) = *(data + 0);
  {
#line 249
  strcpy((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)(mimetype));
  }
  {
#line 250
  memcpy((void */* __restrict  */)(((f->data + 1) + i) + 1), (void const   */* __restrict  */)(data + 4),
         (size_t )(f->sz - 4));
  }
#line 251
  f->sz = newsz;
  {
#line 252
  free((void *)data);
  }
  }
#line 254
  return (0);
}
}
#line 258 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_apic_backward___0(id3_frame_t f ) 
{ 
  char imgtype[4] ;
  char *mimetype ;
  struct imgtype_mimetype_struct  const  *im_map ;
  unsigned char *data ;
  int i ;
  int newsz ;
  int len ;
  int bad_mimetype ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 261
  mimetype = (char *)((void *)0);
#line 264
  bad_mimetype = 0;
  {
#line 266
  tmp = id3_frame_get_raw(f);
  }
#line 266
  data = (unsigned char *)tmp;
  }
#line 267
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 268
    return (0);
  }
#line 271
  i = 1;
  {
  {
#line 271
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < f->sz)) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )*(data + i) == 0) {
#line 273
      goto while_break;
    }
#line 271
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  if ((int )*(data + i) != 0) {
#line 276
    bad_mimetype = 1;
  } else
#line 275
  if (i < 8) {
#line 276
    bad_mimetype = 1;
  }
#line 278
  if (! bad_mimetype) {
    {
#line 279
    mimetype = (char *)data + 1;
    {
#line 280
    tmp___0 = strlen((char const   *)mimetype);
    }
#line 280
    len = (int )tmp___0;
#line 281
    i = 0;
    }
    {
    {
#line 281
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! (i < len)) {
#line 281
        goto while_break___0;
      }
      {
      {
#line 282
      tmp___1 = tolower((int )*(mimetype + i));
      }
#line 282
      *(mimetype + i) = (char )tmp___1;
#line 281
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 283
    tmp___2 = strncmp((char const   *)mimetype, "image/", (size_t )6);
    }
    }
#line 283
    if (tmp___2 != 0) {
#line 284
      bad_mimetype = 1;
    }
  }
#line 287
  if (! bad_mimetype) {
#line 288
    mimetype += 6;
#line 290
    im_map = imgtype_mimetype_map___0;
    {
    {
#line 291
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 291
      if (! im_map->mimetype) {
#line 291
        goto while_break___1;
      }
      {
      {
#line 292
      tmp___3 = strcmp((char const   *)mimetype, (char const   *)im_map->mimetype);
      }
      }
#line 292
      if (tmp___3 == 0) {
        {
        {
#line 293
        strcpy((char */* __restrict  */)(imgtype), (char const   */* __restrict  */)im_map->imgtype);
        }
        }
#line 294
        goto while_break___1;
      }
#line 296
      im_map ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 301
    if ((unsigned long )im_map->mimetype == (unsigned long )((void *)0)) {
      {
      {
#line 302
      strncpy((char */* __restrict  */)(imgtype), (char const   */* __restrict  */)mimetype,
              (size_t )3);
      }
      }
    }
#line 303
    imgtype[3] = (char )'\000';
  } else {
#line 307
    return (0);
  }
  {
#line 310
  newsz = ((f->sz - len) - 1) + 3;
  {
#line 311
  memcpy((void */* __restrict  */)(f->data + 1), (void const   */* __restrict  */)(imgtype),
         (size_t )3);
  }
  {
#line 312
  memmove((void *)(f->data + 4), (void const   *)(((f->data + 4) + len) + 1), (size_t )(((f->sz - 4) - len) - 1));
  }
#line 313
  f->sz = newsz;
  }
#line 315
  return (0);
}
}
#line 318 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_apic___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 321
  if (backward) {
    {
    {
#line 322
    tmp = _convert_apic_backward___0(f);
    }
    }
#line 322
    return (tmp);
  } else {
    {
    {
#line 324
    tmp___0 = _convert_apic_forward___0(f);
    }
    }
#line 324
    return (tmp___0);
  }
}
}
#line 328 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_time_backward___0(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t f2 ;
  unsigned char *old_data ;
  unsigned char buf[32] ;
  int len ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 331
  tag = f->id3;
  {
#line 338
  tmp = id3_frame_get_raw(f);
  }
#line 338
  old_data = (unsigned char *)tmp;
  }
#line 339
  if ((unsigned long )old_data == (unsigned long )((void *)0)) {
#line 340
    return (0);
  }
  {
  {
#line 341
  tmp___0 = strlen((char const   *)((char *)old_data + 1));
  }
#line 341
  len = (int )tmp___0;
  }
#line 343
  if (len >= 4) {
    {
    {
#line 345
    f2 = id3_frame_add(tag, "TYER");
    }
    }
#line 346
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 347
      return (-1);
    }
    {
    {
#line 348
    tmp___1 = id3_frame_set_raw(f2, (void *)old_data, 5);
    }
    }
#line 348
    if (tmp___1 == -1) {
#line 349
      return (-1);
    }
  }
#line 352
  if (len >= 10) {
    {
    {
#line 354
    f2 = id3_frame_add(tag, "TDAT");
    }
    }
#line 355
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 356
      return (-1);
    }
    {
#line 357
    buf[0] = (unsigned char )'\000';
#line 358
    buf[1] = *(old_data + 9);
#line 359
    buf[2] = *(old_data + 10);
#line 360
    buf[3] = *(old_data + 6);
#line 361
    buf[4] = *(old_data + 7);
    {
#line 362
    tmp___2 = id3_frame_set_raw(f2, (void *)(buf), 5);
    }
    }
#line 362
    if (tmp___2 == -1) {
#line 363
      return (-1);
    }
  }
#line 366
  if (len >= 16) {
    {
    {
#line 368
    f2 = id3_frame_add(tag, "TIME");
    }
    }
#line 369
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 370
      return (-1);
    }
    {
#line 371
    buf[0] = (unsigned char )'\000';
#line 372
    buf[1] = *(old_data + 12);
#line 373
    buf[2] = *(old_data + 13);
#line 374
    buf[3] = *(old_data + 15);
#line 375
    buf[4] = *(old_data + 16);
    {
#line 376
    tmp___3 = id3_frame_set_raw(f2, (void *)(buf), 5);
    }
    }
#line 376
    if (tmp___3 == -1) {
#line 377
      return (-1);
    }
  }
#line 380
  return (1);
}
}
#line 384 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_time_forward___0(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t tdrc_f ;
  unsigned char *old_data ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  unsigned char tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  unsigned char tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  unsigned char tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 387
  tag = f->id3;
  {
#line 391
  tdrc_f = id3_get_frame_by_id(tag, "TDRC");
  }
  }
#line 392
  if ((unsigned long )tdrc_f == (unsigned long )((void *)0)) {
    {
    {
#line 394
    tmp = id3_frame_get_raw(f);
    }
#line 394
    old_data = (unsigned char *)tmp;
    {
#line 395
    tmp___6 = strcmp((char const   *)(f->id), "TDAT");
    }
    }
#line 395
    if (tmp___6 == 0) {
      {
      {
#line 398
      tmp___0 = strlen((char const   *)((char *)old_data + 1));
      }
      }
#line 398
      if (tmp___0 != 4U) {
#line 400
        return (1);
      }
      {
#line 402
      f->sz = 11;
      {
#line 403
      tmp___1 = calloc((size_t )(f->sz + 2), (size_t )1);
      }
#line 403
      f->data = (unsigned char *)tmp___1;
      {
#line 406
      sprintf((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)"????-%c%c-%c%c",
              (int )*(old_data + 3), (int )*(old_data + 4), (int )*(old_data + 1),
              (int )*(old_data + 2));
      }
      {
#line 408
      free((void *)old_data);
      }
      }
    } else {
      {
      {
#line 410
      tmp___5 = strcmp((char const   *)(f->id), "TIME");
      }
      }
#line 410
      if (tmp___5 == 0) {
        {
        {
#line 413
        tmp___2 = strlen((char const   *)((char *)old_data + 1));
        }
        }
#line 413
        if (tmp___2 != 4U) {
#line 415
          return (1);
        }
        {
#line 417
        f->sz = 17;
        {
#line 418
        tmp___3 = calloc((size_t )(f->sz + 2), (size_t )1);
        }
#line 418
        f->data = (unsigned char *)tmp___3;
        {
#line 421
        sprintf((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)"????-??-??T%c%c:%c%c",
                (int )*(old_data + 1), (int )*(old_data + 2), (int )*(old_data + 3),
                (int )*(old_data + 4));
        }
        {
#line 423
        free((void *)old_data);
        }
        }
      } else {
        {
        {
#line 425
        tmp___4 = strcmp((char const   *)(f->id), "TYER");
        }
        }
#line 425
        if (! (tmp___4 == 0)) {
#line 429
          return (-1);
        }
      }
    }
  } else {
    {
    {
#line 435
    id3_frame_get_raw(f);
    }
    {
#line 436
    tmp___21 = strcmp((char const   *)(f->id), "TDAT");
    }
    }
#line 436
    if (tmp___21 == 0) {
      {
      {
#line 439
      tmp___7 = strlen((char const   *)((char *)f->data + 1));
      }
      }
#line 439
      if (tmp___7 != 4U) {
#line 441
        return (1);
      }
#line 444
      if (tdrc_f->sz < 11) {
        {
        {
#line 446
        tmp___8 = id3_frame_get_raw(tdrc_f);
        }
#line 446
        old_data = (unsigned char *)tmp___8;
#line 447
        tdrc_f->sz = 11;
        {
#line 448
        tmp___9 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
        }
#line 448
        tdrc_f->data = (unsigned char *)tmp___9;
        }
#line 449
        if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 450
          tdrc_f->data = old_data;
#line 451
          return (-1);
        }
#line 453
        tmp___10 = (unsigned char )'\000';
#line 453
        *(tdrc_f->data + 12) = tmp___10;
#line 453
        *(tdrc_f->data + 11) = tmp___10;
      }
      {
      {
#line 456
      sprintf((char */* __restrict  */)((char *)tdrc_f->data + 5), (char const   */* __restrict  */)"-%c%c-%c%c",
              (int )*(f->data + 3), (int )*(f->data + 4), (int )*(f->data + 1), (int )*(f->data + 2));
      }
      }
    } else {
      {
      {
#line 459
      tmp___20 = strcmp((char const   *)(f->id), "TIME");
      }
      }
#line 459
      if (tmp___20 == 0) {
        {
        {
#line 462
        tmp___11 = strlen((char const   *)((char *)f->data + 1));
        }
        }
#line 462
        if (tmp___11 != 4U) {
#line 464
          return (1);
        }
#line 467
        if (tdrc_f->sz < 17) {
          {
          {
#line 469
          tmp___12 = id3_frame_get_raw(tdrc_f);
          }
#line 469
          old_data = (unsigned char *)tmp___12;
#line 470
          tdrc_f->sz = 17;
          {
#line 471
          tmp___13 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
          }
#line 471
          tdrc_f->data = (unsigned char *)tmp___13;
          }
#line 472
          if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 473
            tdrc_f->data = old_data;
#line 474
            return (-1);
          }
#line 476
          tmp___14 = (unsigned char )'\000';
#line 476
          *(tdrc_f->data + 18) = tmp___14;
#line 476
          *(tdrc_f->data + 17) = tmp___14;
        }
        {
        {
#line 479
        sprintf((char */* __restrict  */)((char *)tdrc_f->data + 11), (char const   */* __restrict  */)"T%c%c:%c%c",
                (int )*(f->data + 1), (int )*(f->data + 2), (int )*(f->data + 3),
                (int )*(f->data + 4));
        }
        }
      } else {
        {
        {
#line 482
        tmp___19 = strcmp((char const   *)(f->id), "TYER");
        }
        }
#line 482
        if (tmp___19 == 0) {
          {
          {
#line 485
          tmp___15 = strlen((char const   *)((char *)f->data + 1));
          }
          }
#line 485
          if (tmp___15 != 4U) {
#line 487
            return (1);
          }
#line 490
          if (tdrc_f->sz < 5) {
            {
            {
#line 492
            tmp___16 = id3_frame_get_raw(tdrc_f);
            }
#line 492
            old_data = (unsigned char *)tmp___16;
#line 493
            tdrc_f->sz = 5;
            {
#line 494
            tmp___17 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
            }
#line 494
            tdrc_f->data = (unsigned char *)tmp___17;
            }
#line 495
            if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 496
              tdrc_f->data = old_data;
#line 497
              return (-1);
            }
#line 499
            tmp___18 = (unsigned char )'\000';
#line 499
            *(tdrc_f->data + 6) = tmp___18;
#line 499
            *(tdrc_f->data + 5) = tmp___18;
          }
          {
          {
#line 502
          memcpy((void */* __restrict  */)(tdrc_f->data + 1), (void const   */* __restrict  */)(f->data + 1),
                 (size_t )4);
          }
          }
        } else {
#line 506
          return (-1);
        }
      }
    }
#line 509
    return (1);
  }
#line 512
  return (0);
}
}
#line 517 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_time___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 520
  if (backward) {
    {
    {
#line 521
    tmp = _convert_time_backward___0(f);
    }
    }
#line 521
    return (tmp);
  } else {
    {
    {
#line 523
    tmp___0 = _convert_time_forward___0(f);
    }
    }
#line 523
    return (tmp___0);
  }
}
}
#line 527 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_tcon___0(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 
  char *src ;
  char *dest ;
  char *rparen ;
  unsigned char *data ;
  char *endptr ;
  int i ;
  int newsz ;
  int len ;
  int last_was_nonnumeric ;
  long gnum ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 536
  tmp = id3_frame_get_raw(f);
  }
#line 536
  data = (unsigned char *)tmp;
  }
#line 538
  if (f->sz < 1) {
#line 539
    return (0);
  }
#line 542
  if (backward) {
#line 548
    newsz = f->sz + 2;
#line 549
    i = 0;
    {
    {
#line 549
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 549
      if (! (i < f->sz)) {
#line 549
        goto while_break;
      }
#line 550
      if ((int )*(data + i) == 40) {
#line 551
        newsz ++;
      } else
#line 550
      if ((int )*(data + i) == 0) {
#line 551
        newsz ++;
      }
#line 549
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 553
    tmp___0 = calloc((size_t )newsz, (size_t )1);
    }
#line 553
    f->data = (unsigned char *)tmp___0;
    }
#line 554
    if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 555
      f->data = data;
#line 556
      return (-1);
    }
#line 559
    src = (char *)data;
#line 560
    dest = (char *)f->data;
#line 561
    tmp___1 = dest;
#line 561
    dest ++;
#line 561
    tmp___2 = src;
#line 561
    src ++;
#line 561
    *tmp___1 = *tmp___2;
#line 562
    last_was_nonnumeric = 0;
    {
    {
#line 563
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 563
      if (! (src - (char *)data < (long )f->sz)) {
#line 563
        goto while_break___0;
      }
#line 566
      if ((int )*(src + 0) >= 48) {
#line 566
        if ((int )*(src + 0) <= 57) {
          {
          {
#line 567
          gnum = strtol((char const   */* __restrict  */)src, (char **/* __restrict  */)(& endptr),
                        10);
          }
          }
#line 568
          if ((int )*endptr == 0) {
#line 568
            if (gnum >= 0L) {
#line 568
              if (gnum <= 255L) {
                {
                {
#line 569
                tmp___3 = sprintf((char */* __restrict  */)dest, (char const   */* __restrict  */)"(%d)",
                                  (int )gnum);
                }
#line 569
                dest += tmp___3;
#line 570
                src = endptr + 1;
#line 571
                last_was_nonnumeric = 0;
                }
#line 572
                goto while_continue___0;
              }
            }
          }
        }
      }
#line 577
      if (last_was_nonnumeric) {
#line 579
        tmp___4 = dest;
#line 579
        dest ++;
#line 579
        *tmp___4 = (char )'/';
      }
      {
      {
#line 581
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 581
        if (! ((int )*src != 0)) {
#line 581
          goto while_break___1;
        }
#line 582
        if ((int )*src == 40) {
#line 583
          tmp___5 = dest;
#line 583
          dest ++;
#line 583
          *tmp___5 = (char )'(';
        }
#line 584
        tmp___6 = dest;
#line 584
        dest ++;
#line 584
        tmp___7 = src;
#line 584
        src ++;
#line 584
        *tmp___6 = *tmp___7;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 586
      src ++;
#line 587
      last_was_nonnumeric = 1;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 589
    newsz = (int )(dest - (char *)f->data);
    {
#line 590
    free((void *)data);
    }
    }
  } else {
#line 597
    dest = (char *)data + 1;
#line 597
    src = dest;
    {
    {
#line 598
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 598
      if (! (src - (char *)data < (long )f->sz)) {
#line 598
        goto while_break___2;
      }
#line 600
      if ((int )*(src + 0) == 40) {
        {
        {
#line 602
        rparen = strchr((char const   *)src, ')');
        }
        }
#line 603
        if ((int )*(src + 1) == 40) {
#line 605
          src ++;
#line 606
          if (rparen) {
#line 607
            len = (int )((rparen - src) + 1L);
          } else {
#line 609
            len = (int )((long )f->sz - (src - (char *)data));
          }
          {
          {
#line 610
          memmove((void *)dest, (void const   *)src, (size_t )len);
          }
#line 611
          src += len;
#line 612
          dest += len;
          }
        } else {
#line 615
          if ((unsigned long )rparen == (unsigned long )((void *)0)) {
#line 616
            goto while_break___2;
          }
#line 617
          *rparen = (char )'\000';
#line 618
          if ((int )*(dest + -1) == 0) {
#line 619
            src ++;
          } else {
#line 621
            *src = (char )'\000';
          }
          {
#line 622
          len = (int )(rparen - src);
          {
#line 623
          memmove((void *)dest, (void const   *)src, (size_t )len);
          }
#line 624
          src += len;
#line 625
          dest += len;
          }
        }
      } else {
#line 629
        tmp___8 = dest;
#line 629
        dest ++;
#line 629
        tmp___9 = src;
#line 629
        src ++;
#line 629
        *tmp___8 = *tmp___9;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 633
    newsz = (int )(dest - (char *)data);
  }
#line 636
  f->sz = newsz;
#line 637
  *(f->data + f->sz) = (unsigned char )'\000';
#line 639
  return (0);
}
}
#line 651 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_rva___0(id3_frame_t f , char const   *from , char const   *to ,
                           int backward ) 
{ 
  int i ;
  int peakbytes ;
  unsigned char *data ;
  void *tmp ;

  {
  {
  {
#line 657
  tmp = id3_frame_get_raw(f);
  }
#line 657
  data = (unsigned char *)tmp;
#line 660
  i = 0;
  }
  {
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 660
    if (! (i < f->sz)) {
#line 660
      goto while_break;
    }
#line 661
    if ((int )*(data + i) == 0) {
#line 662
      goto while_break;
    }
#line 660
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  if ((int )*(data + i) != 0) {
#line 664
    return (1);
  }
#line 666
  i ++;
  {
  {
#line 667
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 669
    if (i >= f->sz) {
#line 670
      return (1);
    } else
#line 669
    if ((int )*(data + i) > 8) {
#line 670
      return (1);
    }
#line 673
    i += 3;
#line 674
    if (i >= f->sz) {
#line 675
      return (1);
    }
#line 676
    peakbytes = (int )*(data + i) / 8;
#line 677
    i += peakbytes;
#line 678
    if (i >= f->sz) {
#line 679
      return (1);
    }
#line 682
    i ++;
#line 683
    if (i >= f->sz) {
#line 684
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 692 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  *find_converter___0(struct frame_convert  const  *map ,
                                                        char const   *from , int backw ) 
{ 
  char const   *s ;
  int tmp ;

  {
  {
  {
#line 697
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 697
    if (! map->from) {
#line 697
      if (! map->to) {
#line 697
        goto while_break;
      }
    }
#line 698
    if (backw) {
#line 698
      s = (char const   *)map->to;
    } else {
#line 698
      s = (char const   *)map->from;
    }
#line 699
    if (s) {
      {
      {
#line 699
      tmp = memcmp((void const   *)from, (void const   *)s, (size_t )4);
      }
      }
#line 699
      if (tmp == 0) {
#line 700
        return (map);
      }
    }
#line 701
    map ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return ((struct frame_convert  const  *)((void *)0));
}
}
#line 706 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_frame___0(id3_frame_t f , int from_vers , int to_vers ) 
{ 
  struct frame_convert  const  *fc_map ;
  int ret ;
  int backward ;
  char const   *newid ;

  {
#line 709
  fc_map = (struct frame_convert  const  *)((void *)0);
#line 710
  backward = 0;
#line 713
  if (from_vers == to_vers) {
#line 714
    return (0);
  }
#line 716
  if (from_vers - to_vers > 1) {
    {
    {
#line 717
    ret = convert_frame___0(f, from_vers, to_vers + 1);
    }
    }
#line 718
    if (ret == -1) {
#line 719
      return (-1);
    }
#line 720
    from_vers = to_vers + 1;
  } else
#line 721
  if (to_vers - from_vers > 1) {
    {
    {
#line 722
    ret = convert_frame___0(f, from_vers, to_vers - 1);
    }
    }
#line 723
    if (ret == -1) {
#line 724
      return (-1);
    }
#line 725
    from_vers = to_vers - 1;
  }
  {
#line 730
  if (from_vers == 2) {
#line 730
    goto case_2;
  }
#line 735
  if (from_vers == 3) {
#line 735
    goto case_3;
  }
#line 747
  if (from_vers == 4) {
#line 747
    goto case_4___0;
  }
#line 729
  goto switch_break;
  case_2: /* CIL Label */ 
#line 732
  fc_map = _convert_map_v2to3___0;
#line 733
  backward = 0;
#line 734
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 737
  if (to_vers == 2) {
#line 737
    goto case_2___0;
  }
#line 741
  if (to_vers == 4) {
#line 741
    goto case_4;
  }
#line 736
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 738
  fc_map = _convert_map_v2to3___0;
#line 739
  backward = 1;
#line 740
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 742
  fc_map = _convert_map_v3to4___0;
#line 743
  backward = 0;
#line 744
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 746
  goto switch_break;
  case_4___0: /* CIL Label */ 
#line 749
  fc_map = _convert_map_v3to4___0;
#line 750
  backward = 1;
#line 751
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 754
  fc_map = find_converter___0(fc_map, (char const   *)(f->id), backward);
  }
  }
#line 755
  if (fc_map) {
#line 756
    if (fc_map->converter) {
      {
      {
#line 757
      ret = (*(fc_map->converter))(f, (char const   *)fc_map->from, (char const   *)fc_map->to,
                                   backward);
      }
      }
#line 758
      if (ret == -1) {
#line 759
        return (-1);
      }
#line 760
      if (ret == 1) {
        {
        {
#line 761
        id3_frame_delete(f);
        }
        }
#line 762
        return (0);
      }
    }
#line 765
    if (backward) {
#line 765
      newid = (char const   *)fc_map->from;
    } else {
#line 765
      newid = (char const   *)fc_map->to;
    }
#line 766
    if (newid) {
      {
      {
#line 767
      strcpy((char */* __restrict  */)(f->id), (char const   */* __restrict  */)newid);
      }
      }
    } else {
      {
      {
#line 770
      id3_frame_delete(f);
      }
      }
    }
  }
#line 774
  return (0);
}
}
#line 41 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_title_id___0(id3_t tag ) ;
#line 42
static char const   *_artist_id___0(id3_t tag ) ;
#line 43
static char const   *_album_id___0(id3_t tag ) ;
#line 44
static char const   *_genre_id___0(id3_t tag ) ;
#line 45
static char const   *_date_id___0(id3_t tag ) ;
#line 46
static char const   *_tracknum_id___0(id3_t tag ) ;
#line 47
static char *_do_get___0(id3_t tag , char const   *id ) ;
#line 48
static int _do_set___0(id3_t tag , char const   *id , char const   *s , enum id3_text_encoding enc ) ;
#line 194 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_title_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 197
  tmp = id3_get_version(tag);
  }
  }
  {
#line 198
  if ((unsigned int )tmp == 2U) {
#line 198
    goto case_2;
  }
#line 201
  if ((unsigned int )tmp == 4U) {
#line 201
    goto case_4;
  }
#line 201
  if ((unsigned int )tmp == 3U) {
#line 201
    goto case_4;
  }
#line 203
  goto switch_default;
  case_2: /* CIL Label */ 
#line 199
  return ("TT2");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 202
  return ("TIT2");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 206
  return ((char const   *)((void *)0));
}
}
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_artist_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 212
  tmp = id3_get_version(tag);
  }
  }
  {
#line 213
  if ((unsigned int )tmp == 2U) {
#line 213
    goto case_2;
  }
#line 216
  if ((unsigned int )tmp == 4U) {
#line 216
    goto case_4;
  }
#line 216
  if ((unsigned int )tmp == 3U) {
#line 216
    goto case_4;
  }
#line 218
  goto switch_default;
  case_2: /* CIL Label */ 
#line 214
  return ("TP1");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 217
  return ("TPE1");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 221
  return ((char const   *)((void *)0));
}
}
#line 224 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_album_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 227
  tmp = id3_get_version(tag);
  }
  }
  {
#line 228
  if ((unsigned int )tmp == 2U) {
#line 228
    goto case_2;
  }
#line 231
  if ((unsigned int )tmp == 4U) {
#line 231
    goto case_4;
  }
#line 231
  if ((unsigned int )tmp == 3U) {
#line 231
    goto case_4;
  }
#line 233
  goto switch_default;
  case_2: /* CIL Label */ 
#line 229
  return ("TAL");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 232
  return ("TALB");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 236
  return ((char const   *)((void *)0));
}
}
#line 239 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_genre_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 242
  tmp = id3_get_version(tag);
  }
  }
  {
#line 243
  if ((unsigned int )tmp == 2U) {
#line 243
    goto case_2;
  }
#line 246
  if ((unsigned int )tmp == 4U) {
#line 246
    goto case_4;
  }
#line 246
  if ((unsigned int )tmp == 3U) {
#line 246
    goto case_4;
  }
#line 248
  goto switch_default;
  case_2: /* CIL Label */ 
#line 244
  return ("TCO");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 247
  return ("TCON");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 251
  return ((char const   *)((void *)0));
}
}
#line 254 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_date_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 257
  tmp = id3_get_version(tag);
  }
  }
  {
#line 258
  if ((unsigned int )tmp == 2U) {
#line 258
    goto case_2;
  }
#line 260
  if ((unsigned int )tmp == 3U) {
#line 260
    goto case_3;
  }
#line 262
  if ((unsigned int )tmp == 4U) {
#line 262
    goto case_4;
  }
#line 264
  goto switch_default;
  case_2: /* CIL Label */ 
#line 259
  return ("TYE");
  case_3: /* CIL Label */ 
#line 261
  return ("TYER");
  case_4: /* CIL Label */ 
#line 263
  return ("TDRC");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 267
  return ((char const   *)((void *)0));
}
}
#line 270 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_tracknum_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 273
  tmp = id3_get_version(tag);
  }
  }
  {
#line 274
  if ((unsigned int )tmp == 2U) {
#line 274
    goto case_2;
  }
#line 277
  if ((unsigned int )tmp == 4U) {
#line 277
    goto case_4;
  }
#line 277
  if ((unsigned int )tmp == 3U) {
#line 277
    goto case_4;
  }
#line 279
  goto switch_default;
  case_2: /* CIL Label */ 
#line 275
  return ("TRK");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 278
  return ("TRCK");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 282
  return ((char const   *)((void *)0));
}
}
#line 285 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char *_do_get___0(id3_t tag , char const   *id ) 
{ 
  id3_frame_t f ;
  char *s ;
  void *tmp ;

  {
  {
  {
#line 292
  id3_frame_count(tag);
  }
  }
#line 294
  if (id) {
    {
    {
#line 295
    f = id3_get_frame_by_id(tag, id);
    }
    }
#line 296
    if (f) {
      {
      {
#line 296
      tmp = id3_frame_get_raw(f);
      }
#line 296
      s = (char *)tmp;
      }
#line 296
      if (s) {
#line 297
        return (s + 1);
      }
    }
  }
#line 299
  return ((char *)((void *)0));
}
}
#line 302 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static int _do_set___0(id3_t tag , char const   *id , char const   *s , enum id3_text_encoding enc ) 
{ 
  id3_frame_t tmp ;

  {
#line 305
  if ((unsigned long )id == (unsigned long )((void *)0)) {
#line 306
    return (-1);
  }
  {
  {
#line 307
  tmp = id3_add_text_frame(tag, id, s, (int )enc);
  }
  }
#line 307
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 308
    return (-1);
  }
#line 309
  return (0);
}
}
#line 48 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static char const   *_comment_id___0(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 51
  tmp = id3_get_version(tag);
  }
  }
  {
#line 52
  if ((unsigned int )tmp == 2U) {
#line 52
    goto case_2;
  }
#line 55
  if ((unsigned int )tmp == 4U) {
#line 55
    goto case_4;
  }
#line 55
  if ((unsigned int )tmp == 3U) {
#line 55
    goto case_4;
  }
#line 57
  goto switch_default;
  case_2: /* CIL Label */ 
#line 53
  return ("COM");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 56
  return ("COMM");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return ((char const   *)((void *)0));
}
}
#line 64 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static int _desc_eq___0(char const   *a , char const   *b , int size , enum id3_text_encoding enc ) 
{ 
  int i ;

  {
#line 67
  i = 0;
  {
#line 70
  if ((unsigned int )enc == 2U) {
#line 70
    goto case_2;
  }
#line 70
  if ((unsigned int )enc == 1U) {
#line 70
    goto case_2;
  }
#line 80
  if ((unsigned int )enc == 0U) {
#line 80
    goto case_0;
  }
#line 80
  if ((unsigned int )enc == 3U) {
#line 80
    goto case_0;
  }
#line 68
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < size)) {
#line 71
      goto while_break;
    }
#line 72
    if ((int const   )*(a + i) != (int const   )*(b + i)) {
#line 73
      return (0);
    } else
#line 72
    if ((int const   )*(a + (i + 1)) != (int const   )*(b + (i + 1))) {
#line 73
      return (0);
    }
#line 74
    if ((int const   )*(a + i) == 0) {
#line 74
      if ((int const   )*(a + (i + 1)) == 0) {
#line 75
        goto while_break;
      }
    }
#line 76
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (i < size)) {
#line 81
      goto while_break___0;
    }
#line 82
    if ((int const   )*(a + i) != (int const   )*(b + i)) {
#line 83
      return (0);
    }
#line 84
    if ((int const   )*(a + i) == 0) {
#line 85
      goto while_break___0;
    }
#line 86
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  return (1);
}
}
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static char *_get_comment_text___0(id3_frame_t f ) 
{ 
  unsigned char *s ;
  void *tmp ;

  {
  {
  {
#line 97
  tmp = id3_frame_get_raw(f);
  }
#line 97
  s = (unsigned char *)tmp;
  }
#line 99
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 100
    return ((char *)((void *)0));
  }
  {
#line 103
  if ((int )*(s + 0) == 2) {
#line 103
    goto case_2;
  }
#line 103
  if ((int )*(s + 0) == 1) {
#line 103
    goto case_2;
  }
#line 112
  if ((int )*(s + 0) == 0) {
#line 112
    goto case_0;
  }
#line 112
  if ((int )*(s + 0) == 3) {
#line 112
    goto case_0;
  }
#line 101
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 104
  s += 4;
  {
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 105
    if (s - f->data <= (long )f->sz) {
#line 105
      if ((int )*(s + 0) == 0) {
#line 105
        if ((int )*(s + 1) == 0) {
#line 105
          goto while_break;
        }
      }
    } else {
#line 105
      goto while_break;
    }
#line 106
    s += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(s + 0) == 0) {
#line 107
    if (! ((int )*(s + 1) == 0)) {
#line 108
      return ((char *)((void *)0));
    }
  } else {
#line 108
    return ((char *)((void *)0));
  }
#line 109
  s += 2;
#line 110
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 113
  s += 4;
  {
  {
#line 114
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 114
    if (s - f->data <= (long )f->sz) {
#line 114
      if (! ((int )*(s + 0) != 0)) {
#line 114
        goto while_break___0;
      }
    } else {
#line 114
      goto while_break___0;
    }
#line 115
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  if ((int )*(s + 0) != 0) {
#line 117
    return ((char *)((void *)0));
  }
#line 118
  s ++;
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 121
  return ((char *)s);
}
}
#line 129 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static id3_frame_t _get_comment_frame___0(id3_t tag , char const   *desc , char const   *lang ) 
{ 
  char const   *id ;
  char const   *tmp ;
  char *s ;
  id3_frame_t f ;
  int nframes ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 132
  tmp = _comment_id___0(tag);
  }
#line 132
  id = tmp;
  {
#line 137
  nframes = id3_frame_count(tag);
  }
  }
#line 138
  if (nframes == -1) {
#line 139
    return ((id3_frame_t )((void *)0));
  }
#line 140
  f = tag->frame_hd;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! f) {
#line 140
      goto while_break;
    }
    {
    {
#line 141
    tmp___3 = strcmp((char const   *)(f->id), id);
    }
    }
#line 141
    if (tmp___3 == 0) {
      {
      {
#line 142
      tmp___0 = id3_frame_get_raw(f);
      }
#line 142
      s = (char *)tmp___0;
      }
#line 143
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 144
        goto __Cont;
      }
#line 145
      if (desc) {
        {
        {
#line 145
        tmp___1 = _desc_eq___0(desc, (char const   *)(s + 4), f->sz - 4, (enum id3_text_encoding )*(s + 0));
        }
        }
#line 145
        if (! tmp___1) {
#line 146
          goto __Cont;
        }
      }
#line 147
      if (lang) {
        {
        {
#line 147
        tmp___2 = memcmp((void const   *)lang, (void const   *)(s + 1), (size_t )3);
        }
        }
#line 147
        if (tmp___2 != 0) {
#line 148
          goto __Cont;
        }
      }
#line 149
      return (f);
    }
    __Cont: /* CIL Label */ 
#line 140
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((id3_frame_t )((void *)0));
}
}
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned short v3_fflag_masks___1[8]  = 
#line 73 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
  {      (unsigned short)32768,      (unsigned short)16384,      (unsigned short)8192,      (unsigned short)32, 
        (unsigned short)128,      (unsigned short)64,      (unsigned short)0,      (unsigned short)0};
#line 77 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned short v4_fflag_masks___1[8]  = 
#line 77
  {      (unsigned short)16384,      (unsigned short)8192,      (unsigned short)4096,      (unsigned short)64, 
        (unsigned short)8,      (unsigned short)4,      (unsigned short)2,      (unsigned short)1};
#line 96 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static unsigned int unsyncsafe_int___1(unsigned char *buf ) 
{ 
  unsigned int retval ;

  {
#line 99
  retval = 0U;
#line 100
  retval = (unsigned int )*(buf + 0);
#line 101
  retval <<= 7;
#line 102
  retval |= (unsigned int )*(buf + 1);
#line 103
  retval <<= 7;
#line 104
  retval |= (unsigned int )*(buf + 2);
#line 105
  retval <<= 7;
#line 106
  retval |= (unsigned int )*(buf + 3);
#line 107
  return (retval);
}
}
#line 114 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int decode_unsync___1(unsigned char *dest , unsigned char *src , int sz ) 
{ 
  unsigned char *dest_save ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 117
  dest_save = dest;
  {
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (sz > 0)) {
#line 119
      goto while_break;
    }
#line 120
    if ((int )*src != 255) {
#line 121
      tmp = dest;
#line 121
      dest ++;
#line 121
      tmp___0 = src;
#line 121
      src ++;
#line 121
      *tmp = *tmp___0;
#line 122
      sz --;
    } else {
#line 124
      tmp___1 = dest;
#line 124
      dest ++;
#line 124
      tmp___2 = src;
#line 124
      src ++;
#line 124
      *tmp___1 = *tmp___2;
#line 125
      sz --;
#line 126
      if (sz <= 0) {
#line 127
        goto while_break;
      }
#line 128
      if ((int )*src == 0) {
#line 129
        src ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return ((int )(dest - dest_save));
}
}
#line 257 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static size_t unsync_fread___1(void *buf , size_t size , FILE *stream , size_t consume_limit ,
                               size_t *consumed ) 
{ 
  unsigned char *p ;
  unsigned char *p_save ;
  size_t cons ;
  int c ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
#line 261
  p = (unsigned char *)buf;
#line 266
  cons = (size_t )0;
#line 267
  p_save = p;
  {
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 269
    if (size > 0U) {
#line 269
      if (! (cons < consume_limit)) {
#line 269
        goto while_break;
      }
    } else {
#line 269
      goto while_break;
    }
    {
    {
#line 270
    c = _IO_getc(stream);
    }
    }
#line 271
    if (c == -1) {
#line 272
      goto while_break;
    }
#line 273
    tmp = p;
#line 273
    p ++;
#line 273
    *tmp = (unsigned char )c;
#line 273
    size --;
#line 273
    cons ++;
#line 274
    if (c == 255) {
      {
      {
#line 275
      c = _IO_getc(stream);
      }
      }
#line 276
      if (c == -1) {
#line 277
        goto while_break;
      }
#line 278
      if (c == 0) {
#line 278
        if (cons < consume_limit) {
#line 280
          cons ++;
        } else {
#line 278
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 281
      if (size > 0U) {
#line 281
        if (cons < consume_limit) {
#line 282
          tmp___0 = p;
#line 282
          p ++;
#line 282
          *tmp___0 = (unsigned char )c;
#line 282
          size --;
#line 282
          cons ++;
        } else {
#line 281
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 288
        tmp___1 = ungetc(c, stream);
        }
        }
#line 288
        if (tmp___1 == -1) {
#line 289
          goto while_break;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if (consumed) {
#line 295
    *consumed = cons;
  }
#line 297
  return ((size_t )(p - p_save));
}
}
#line 304 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int unsync_fseek___1(FILE *stream , long offset , int whence , long *real_offset ) 
{ 
  long roff ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 307
  roff = 0L;
#line 310
  if (whence != 1) {
    {
    {
#line 311
    tmp = fseek(stream, 0L, whence);
    }
    }
#line 311
    if (tmp == -1) {
#line 312
      return (-1);
    }
  }
#line 314
  if (offset > 0L) {
    {
    {
#line 317
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 317
      if (! (offset > 0L)) {
#line 317
        goto while_break;
      }
      {
      {
#line 318
      c = _IO_getc(stream);
      }
      }
#line 319
      if (c == -1) {
#line 320
        goto while_break;
      }
#line 321
      offset --;
#line 322
      roff ++;
#line 323
      if (c == 255) {
        {
        {
#line 324
        c = _IO_getc(stream);
        }
        }
#line 325
        if (c == -1) {
#line 326
          goto while_break;
        }
#line 327
        roff ++;
#line 328
        if (! (c == 0)) {
#line 330
          if (offset > 0L) {
#line 331
            offset --;
          } else {
            {
            {
#line 333
            tmp___0 = ungetc(c, stream);
            }
            }
#line 333
            if (tmp___0 == -1) {
#line 334
              goto while_break;
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 339
  if (offset < 0L) {
    {
    {
#line 342
    _IO_getc(stream);
    }
    }
    {
    {
#line 343
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 343
      if (! (offset < 0L)) {
#line 343
        goto while_break___0;
      }
      {
      {
#line 345
      tmp___1 = fseek(stream, -2L, 1);
      }
      }
#line 345
      if (tmp___1 == -1) {
#line 346
        return (-1);
      }
      {
      {
#line 347
      c = _IO_getc(stream);
      }
      }
#line 348
      if (c == -1) {
#line 349
        goto while_break___0;
      }
#line 350
      roff --;
#line 351
      if (c == 0) {
        {
        {
#line 351
        tmp___3 = ftell(stream);
        }
        }
#line 351
        if (tmp___3 >= 2L) {
          {
          {
#line 352
          tmp___2 = fseek(stream, -2L, 1);
          }
          }
#line 352
          if (tmp___2 == -1) {
#line 353
            return (-1);
          }
          {
          {
#line 354
          c = _IO_getc(stream);
          }
          }
#line 355
          if (c == -1) {
#line 356
            goto while_break___0;
          }
#line 357
          roff --;
#line 358
          if (! (c == 255)) {
#line 360
            if (offset < 0L) {
#line 361
              offset ++;
            } else {
              {
              {
#line 363
              _IO_getc(stream);
              }
              }
            }
          }
        } else {
#line 365
          offset ++;
        }
      } else {
#line 365
        offset ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 368
    tmp___4 = fseek(stream, -1L, 1);
    }
    }
#line 368
    if (tmp___4 == -1) {
#line 369
      return (-1);
    }
  }
#line 373
  if (real_offset) {
#line 374
    *real_offset = roff;
  }
  {
  {
#line 376
  tmp___5 = ferror(stream);
  }
  }
#line 376
  if (tmp___5) {
#line 377
    return (-1);
  }
#line 379
  return (0);
}
}
#line 382 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_header___1(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned int tmp ;

  {
  {
#line 385
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
  {
#line 386
  tmp = unsyncsafe_int___1(hdr + 6);
  }
#line 386
  tag->tagsz = (int )tmp;
  }
#line 387
  return (0);
}
}
#line 390 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_header___1(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned char xhdr[10] ;
  size_t consumed ;
  long offset ;
  int sz ;
  unsigned int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;

  {
  {
#line 398
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
#line 399
  tag->has_ext_hdr = (unsigned int )(((int )*(hdr + 5) >> 6) & 1);
#line 400
  tag->experimental = (unsigned int )(((int )*(hdr + 5) >> 5) & 1);
  {
#line 401
  tmp = unsyncsafe_int___1(hdr + 6);
  }
#line 401
  tag->tagsz = (int )tmp;
  }
#line 404
  if (tag->has_ext_hdr) {
#line 405
    if (tag->unsync) {
      {
      {
#line 406
      tmp___0 = unsync_fread___1((void *)(xhdr), (size_t )10, tag->fp, (size_t )20,
                                 & consumed);
      }
      }
#line 406
      if (tmp___0 < 10U) {
#line 407
        return (-1);
      }
    } else {
      {
      {
#line 409
      tmp___1 = fread((void */* __restrict  */)(xhdr), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 409
      if (tmp___1 < 10U) {
#line 410
        return (-1);
      }
    }
    {
    {
#line 412
    tmp___2 = get_be_int(xhdr);
    }
#line 412
    sz = (int )tmp___2;
    }
#line 413
    if ((int )xhdr[4] & 128) {
#line 413
      tag->has_crc = 1U;
    } else {
#line 413
      tag->has_crc = 0U;
    }
#line 417
    if (tag->unsync) {
      {
      {
#line 418
      tmp___3 = unsync_fseek___1(tag->fp, (long )(sz - 6), 1, & offset);
      }
      }
#line 418
      if (tmp___3 == -1) {
#line 419
        return (-1);
      }
#line 420
      tag->curr_off += (off_t )consumed;
#line 421
      tag->curr_off += offset;
    } else {
#line 423
      if (tag->seekable) {
        {
        {
#line 424
        tmp___4 = fseek(tag->fp, (long )(sz - 6), 1);
        }
        }
#line 424
        if (tmp___4 == -1) {
#line 425
          tag->seekable = 0U;
        }
      }
#line 427
      if (! tag->seekable) {
#line 428
        sz -= 6;
        {
        {
#line 429
        while (1) {
          while_continue___0: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 429
          tmp___6 = sz;
#line 429
          sz --;
#line 429
          if (! (tmp___6 > 0)) {
#line 429
            goto while_break;
          }
          {
          {
#line 430
          tmp___5 = _IO_getc(tag->fp);
          }
          }
#line 430
          if (tmp___5 == -1) {
#line 431
            return (-1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 433
      tag->curr_off += (off_t )sz;
    }
  }
#line 437
  return (0);
}
}
#line 440 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_header___1(id3_t tag , unsigned char *hdr ) 
{ 
  unsigned char xhdr[6] ;
  int sz ;
  unsigned int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp11 ;

  {
  {
#line 446
  tag->unsync = (unsigned int )(((int )*(hdr + 5) >> 7) & 1);
#line 447
  tag->has_ext_hdr = (unsigned int )(((int )*(hdr + 5) >> 6) & 1);
#line 448
  tag->experimental = (unsigned int )(((int )*(hdr + 5) >> 5) & 1);
#line 449
  tag->has_footer = (unsigned int )(((int )*(hdr + 5) >> 4) & 1);
  {
#line 450
  tmp = unsyncsafe_int___1(hdr + 6);
  }
#line 450
  tag->tagsz = (int )tmp;
  }
#line 453
  if (tag->has_ext_hdr) {
    {
    {
#line 454
    tmp___0 = fread((void */* __restrict  */)(xhdr), (size_t )1, (size_t )6, (FILE */* __restrict  */)tag->fp);
    }
    }
#line 454
    if (tmp___0 < 6U) {
#line 455
      return (-1);
    }
    {
    {
#line 456
    tmp___1 = unsyncsafe_int___1(xhdr);
    }
#line 456
    sz = (int )tmp___1;
    }
#line 457
    if ((int )xhdr[5] & 64) {
#line 457
      tag->is_update = 1U;
    } else {
#line 457
      tag->is_update = 0U;
    }
#line 458
    if ((int )xhdr[5] & 32) {
#line 458
      tag->has_crc = 1U;
    } else {
#line 458
      tag->has_crc = 0U;
    }
#line 459
    if ((int )xhdr[5] & 16) {
#line 459
      tag->has_restrict = 1U;
    } else {
#line 459
      tag->has_restrict = 0U;
    }
#line 463
    tag->curr_off += (off_t )sz;
#line 464
    if (tag->seekable) {
      {
      {
#line 465
      tmp___2 = fseek(tag->fp, (long )(sz - 6), 1);
      }
      }
#line 465
      if (tmp___2 == -1) {
#line 466
        tag->seekable = 0U;
      }
    }
#line 468
    if (! tag->seekable) {
#line 469
      sz -= 6;
      {
      {
#line 470
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 470
        tmp___4 = sz;
#line 470
        sz --;
#line 470
        if (! (tmp___4 > 0)) {
#line 470
          goto while_break;
        }
        {
        {
#line 471
        tmp___3 = _IO_getc(tag->fp);
        }
        }
#line 471
        if (tmp___3 == -1) {
#line 472
          return (-1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 476
  return (0);
}
}
#line 479 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _look_for_v1tag___1(id3_t tag ) 
{ 
  int sz ;
  char buf[128] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 484
  tmp = fseek(tag->fp, -128L, 2);
  }
  }
#line 484
  if (tmp == -1) {
#line 485
    return (0);
  }
  {
  {
#line 486
  tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )128, (FILE */* __restrict  */)tag->fp);
  }
#line 486
  sz = (int )tmp___0;
  }
#line 487
  if (sz == 128) {
    {
    {
#line 487
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"TAG", (size_t )3);
    }
    }
#line 487
    if (tmp___1 == 0) {
      {
#line 488
      tag->v1.exists = 1U;
      {
#line 489
      strncpy((char */* __restrict  */)(tag->v1.title), (char const   */* __restrict  */)(buf + 3),
              (size_t )30);
      }
      {
#line 490
      strncpy((char */* __restrict  */)(tag->v1.artist), (char const   */* __restrict  */)(buf + 33),
              (size_t )30);
      }
      {
#line 491
      strncpy((char */* __restrict  */)(tag->v1.album), (char const   */* __restrict  */)(buf + 63),
              (size_t )30);
      }
      {
#line 492
      strncpy((char */* __restrict  */)(tag->v1.year), (char const   */* __restrict  */)(buf + 93),
              (size_t )4);
      }
      {
#line 493
      strncpy((char */* __restrict  */)(tag->v1.comment), (char const   */* __restrict  */)(buf + 97),
              (size_t )30);
      }
      }
#line 495
      if ((int )buf[125] == 0) {
#line 495
        tag->v1.track = (unsigned char )buf[126];
      } else {
#line 495
        tag->v1.track = (unsigned char)0;
      }
#line 496
      tag->v1.genre = (unsigned char )buf[127];
    }
  }
#line 498
  return ((int )tag->v1.exists);
}
}
#line 501 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _is_id3_header___1(unsigned char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 504
  tmp = strncmp((char const   *)((char *)buf), "ID3", (size_t )3);
  }
  }
#line 504
  if (tmp != 0) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 3) == 255) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 4) == 255) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 6) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 7) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 8) >= 128) {
#line 509
    return (0);
  } else
#line 504
  if ((int )*(buf + 9) >= 128) {
#line 509
    return (0);
  }
#line 510
  return (1);
}
}
#line 513 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _is_id3_footer___1(unsigned char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 516
  tmp = strncmp((char const   *)((char *)buf), "3DI", (size_t )3);
  }
  }
#line 516
  if (tmp != 0) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 3) == 255) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 4) == 255) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 6) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 7) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 8) >= 128) {
#line 521
    return (0);
  } else
#line 516
  if ((int )*(buf + 9) >= 128) {
#line 521
    return (0);
  }
#line 522
  return (1);
}
}
#line 525 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _look_for_footer___1(id3_t tag , unsigned char *hdr , long offset_from_end ) 
{ 
  int sz ;
  int tag_found ;
  int tmp ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 528
  tag_found = 0;
  {
#line 529
  tmp = fseek(tag->fp, offset_from_end, 2);
  }
  }
#line 529
  if (tmp == -1) {
#line 530
    return (0);
  }
  {
  {
#line 531
  tmp___0 = fread((void */* __restrict  */)hdr, (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
  }
#line 531
  sz = (int )tmp___0;
  }
#line 532
  if (sz == 10) {
    {
    {
#line 532
    tmp___5 = _is_id3_footer___1(hdr);
    }
    }
#line 532
    if (tmp___5) {
      {
      {
#line 534
      tmp___1 = unsyncsafe_int___1(hdr + 6);
      }
#line 534
      tag->tagsz = (int )tmp___1;
      {
#line 535
      tmp___2 = fseek(tag->fp, (long )(- tag->tagsz - 10), 1);
      }
      }
#line 535
      if (tmp___2 == -1) {
#line 536
        return (-1);
      }
      {
      {
#line 537
      tag->curr_off = ftell(tag->fp);
      }
#line 538
      tag->offset = tag->curr_off - 10L;
#line 539
      tag->version = *(hdr + 3);
#line 540
      tag->revision = *(hdr + 4);
#line 541
      tmp___4 = 1U;
#line 541
      tag->has_footer = tmp___4;
#line 541
      tmp___3 = tmp___4;
#line 541
      tag->append = tmp___3;
#line 541
      tag->append_req = tmp___3;
#line 542
      tag_found = 1;
      }
    }
  }
#line 544
  return (tag_found);
}
}
#line 660 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_frame_data___1(id3_frame_t f ) 
{ 
  int err ;
  id3_t tag ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 664
  tag = f->id3;
#line 666
  if (tag->seekable) {
    {
    {
#line 667
    tmp = fseek(tag->fp, f->offset, 0);
    }
    }
#line 667
    if (tmp == -1) {
#line 668
      tag->seekable = 0U;
    }
  }
  {
  {
#line 671
  tmp___0 = calloc((size_t )(f->sz + 2), (size_t )1);
  }
#line 671
  f->data = (unsigned char *)tmp___0;
  }
#line 672
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 673
    goto error;
  }
  {
  {
#line 674
  tmp___1 = fread((void */* __restrict  */)f->data, (size_t )1, (size_t )f->sz, (FILE */* __restrict  */)tag->fp);
  }
  }
#line 674
  if (tmp___1 < (size_t )f->sz) {
#line 675
    goto error_free;
  }
  {
  {
#line 676
  tmp___2 = id3_frame_get_flag(f, (enum id3_fflag )6);
  }
  }
#line 676
  if (tmp___2) {
    {
    {
#line 677
    f->sz = decode_unsync___1(f->data, f->data, f->sz);
    }
    }
  }
#line 679
  if ((int )f->id[0] == 84) {
#line 681
    f->curr_txt = (char *)f->data + 1;
  }
#line 684
  return (f->sz);
  error_free: 
  {
  {
#line 686
  tmp___3 = __errno_location();
  }
#line 686
  err = *tmp___3;
  {
#line 687
  free((void *)f->data);
  }
#line 688
  f->data = (unsigned char *)((void *)0);
  {
#line 689
  tmp___4 = __errno_location();
  }
#line 689
  *tmp___4 = err;
  }
  error: 
#line 691
  return (-1);
}
}
#line 694 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v4_frame_headers___1(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  id3_frame_t newframe ;
  int tagsz ;
  size_t tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 701
  tag->nframes = 0;
  {
#line 702
  tagsz = id3_get_size(tag);
  }
  }
#line 703
  if (tagsz < 1) {
#line 704
    return (tagsz);
  }
  {
  {
#line 707
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 708
    if (tag->curr_off + 10L > (tag->offset + (off_t )tagsz) + 10L) {
#line 709
      goto while_break;
    }
    {
    {
#line 711
    tmp = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
    }
    }
#line 711
    if (tmp < 10U) {
#line 712
      goto error;
    }
    {
#line 713
    tag->curr_off += 10L;
    {
#line 716
    tmp___0 = memcmp((void const   *)(buf), (void const   *)"\000\000\000\000", (size_t )4);
    }
    }
#line 716
    if (tmp___0 == 0) {
#line 717
      goto while_break;
    }
    {
    {
#line 719
    newframe = _id3_frame_new();
    }
    }
#line 720
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 721
      goto error;
    }
    {
    {
#line 722
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )4);
    }
    {
#line 723
    tmp___1 = unsyncsafe_int___1(buf + 4);
    }
#line 723
    newframe->sz = (int )tmp___1;
#line 724
    newframe->flags = (unsigned short )(((unsigned int )buf[8] << 8) | (unsigned int )buf[9]);
#line 725
    newframe->offset = tag->curr_off;
    }
#line 727
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 728
      _id3_frame_destroy(newframe);
      }
      }
#line 729
      goto while_break;
    }
    {
#line 731
    newframe->id3 = tag;
    {
#line 732
    _id3_frame_add(tag, newframe);
    }
    }
#line 742
    if (tag->seekable) {
      {
      {
#line 743
      tmp___2 = fseek(tag->fp, (long )newframe->sz, 1);
      }
      }
#line 743
      if (tmp___2 == -1) {
#line 744
        tag->seekable = 0U;
      }
    }
#line 746
    if (! tag->seekable) {
      {
      {
#line 748
      tmp___3 = _read_v4_frame_data___1(newframe);
      }
      }
#line 748
      if (tmp___3 == -1) {
#line 749
        goto error;
      }
    }
#line 751
    tag->curr_off += (off_t )newframe->sz;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return (tag->nframes);
  error: 
#line 757
  return (-1);
}
}
#line 765 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_frame_data___1(id3_frame_t f ) 
{ 
  int err ;
  size_t consumed ;
  id3_t tag ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 770
  tag = f->id3;
#line 772
  if (tag->seekable) {
    {
    {
#line 773
    tmp = fseek(tag->fp, f->offset, 0);
    }
    }
#line 773
    if (tmp == -1) {
#line 774
      tag->seekable = 0U;
    }
  }
  {
  {
#line 777
  tmp___0 = calloc((size_t )(f->sz + 2), (size_t )1);
  }
#line 777
  f->data = (unsigned char *)tmp___0;
  }
#line 778
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 779
    goto error;
  }
#line 780
  if (tag->unsync) {
    {
    {
#line 781
    tmp___1 = unsync_fread___1((void *)f->data, (size_t )f->sz, tag->fp, (size_t )(f->offset - (off_t )tag->tagsz),
                               & consumed);
    }
    }
#line 781
    if (tmp___1 < (size_t )f->sz) {
#line 783
      goto error_free;
    }
  } else {
    {
    {
#line 785
    tmp___2 = fread((void */* __restrict  */)f->data, (size_t )1, (size_t )f->sz,
                    (FILE */* __restrict  */)tag->fp);
    }
    }
#line 785
    if (tmp___2 < (size_t )f->sz) {
#line 786
      goto error_free;
    }
#line 787
    consumed = (size_t )f->sz;
  }
#line 790
  if ((int )f->id[0] == 84) {
#line 792
    f->curr_txt = (char *)f->data + 1;
  }
#line 795
  return ((int )consumed);
  error_free: 
  {
  {
#line 797
  tmp___3 = __errno_location();
  }
#line 797
  err = *tmp___3;
  {
#line 798
  free((void *)f->data);
  }
#line 799
  f->data = (unsigned char *)((void *)0);
  {
#line 800
  tmp___4 = __errno_location();
  }
#line 800
  *tmp___4 = err;
  }
  error: 
#line 802
  return (-1);
}
}
#line 805 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v3_frame_headers___1(id3_t tag ) 
{ 
  unsigned char buf[10] ;
  id3_frame_t newframe ;
  size_t consumed ;
  size_t limit ;
  long offset ;
  int tagsz ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 814
  tag->nframes = 0;
  {
#line 815
  tagsz = id3_get_size(tag);
  }
  }
#line 816
  if (tagsz < 1) {
#line 817
    return (tagsz);
  }
  {
  {
#line 820
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 821
    if (tag->unsync) {
      {
#line 828
      limit = (size_t )(((tag->offset + (off_t )tagsz) + 10L) - tag->curr_off);
      {
#line 829
      tmp = unsync_fread___1((void *)(buf), (size_t )10, tag->fp, limit, & consumed);
      }
      }
#line 829
      if (tmp < 10U) {
#line 830
        goto while_break;
      }
#line 831
      tag->curr_off += (off_t )consumed;
    } else {
#line 843
      if (tag->curr_off > (off_t )tagsz) {
#line 844
        goto while_break;
      }
      {
      {
#line 845
      tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 845
      if (tmp___0 < 10U) {
#line 846
        goto error;
      }
#line 847
      tag->curr_off += 10L;
    }
    {
    {
#line 851
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"\000\000\000\000", (size_t )4);
    }
    }
#line 851
    if (tmp___1 == 0) {
#line 852
      goto while_break;
    }
    {
    {
#line 854
    newframe = _id3_frame_new();
    }
    }
#line 855
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 856
      goto error;
    }
    {
    {
#line 857
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )4);
    }
    {
#line 858
    tmp___2 = get_be_int(buf + 4);
    }
#line 858
    newframe->sz = (int )tmp___2;
#line 859
    newframe->flags = (unsigned short )(((unsigned int )buf[8] << 8) | (unsigned int )buf[9]);
#line 860
    newframe->offset = tag->curr_off;
    }
#line 862
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 863
      _id3_frame_destroy(newframe);
      }
      }
#line 864
      goto while_break;
    }
    {
#line 866
    newframe->id3 = tag;
    {
#line 867
    _id3_frame_add(tag, newframe);
    }
    }
#line 877
    if (tag->seekable) {
#line 878
      if (tag->unsync) {
        {
        {
#line 879
        tmp___3 = unsync_fseek___1(tag->fp, (long )newframe->sz, 1, & offset);
        }
        }
#line 879
        if (tmp___3 == -1) {
#line 880
          return (-1);
        }
#line 881
        tag->curr_off += offset;
      } else {
        {
        {
#line 883
        tmp___4 = fseek(tag->fp, (long )newframe->sz, 1);
        }
        }
#line 883
        if (tmp___4 == -1) {
#line 884
          tag->seekable = 0U;
        } else {
#line 886
          tag->curr_off += (off_t )newframe->sz;
        }
      }
    }
#line 889
    if (! tag->seekable) {
      {
      {
#line 891
      tmp___5 = _read_v3_frame_data___1(newframe);
      }
#line 891
      offset = (long )tmp___5;
      }
#line 892
      if (offset == -1L) {
#line 893
        goto error;
      }
#line 894
      tag->curr_off += offset;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  return (tag->nframes);
  error: 
#line 901
  return (-1);
}
}
#line 909 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_frame_data___1(id3_frame_t f ) 
{ 
  int tmp ;

  {
  {
  {
#line 913
  tmp = _read_v3_frame_data___1(f);
  }
  }
#line 913
  return (tmp);
}
}
#line 916 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/nid3.c"
static int _read_v2_frame_headers___1(id3_t tag ) 
{ 
  unsigned char buf[6] ;
  id3_frame_t newframe ;
  size_t consumed ;
  long offset ;
  int tagsz ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 925
  tag->nframes = 0;
  {
#line 926
  tagsz = id3_get_size(tag);
  }
  }
#line 927
  if (tagsz < 1) {
#line 928
    return (tagsz);
  }
  {
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 932
    if (tag->unsync) {
      {
      {
#line 939
      tmp = unsync_fread___1((void *)(buf), (size_t )6, tag->fp, (size_t )((off_t )(tagsz + 10) - tag->curr_off),
                             & consumed);
      }
      }
#line 939
      if (tmp < 6U) {
#line 941
        goto while_break;
      }
#line 942
      tag->curr_off += (off_t )consumed;
    } else {
#line 949
      if (tag->curr_off + 6L > (off_t )(tagsz + 10)) {
#line 950
        goto while_break;
      }
      {
      {
#line 951
      tmp___0 = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )6, (FILE */* __restrict  */)tag->fp);
      }
      }
#line 951
      if (tmp___0 < 6U) {
#line 952
        goto error;
      }
#line 953
      tag->curr_off += 6L;
    }
    {
    {
#line 957
    tmp___1 = memcmp((void const   *)(buf), (void const   *)"\000\000\000", (size_t )3);
    }
    }
#line 957
    if (tmp___1 == 0) {
#line 958
      goto while_break;
    }
    {
    {
#line 960
    newframe = _id3_frame_new();
    }
    }
#line 961
    if ((unsigned long )newframe == (unsigned long )((void *)0)) {
#line 962
      goto error;
    }
    {
    {
#line 963
    memcpy((void */* __restrict  */)(newframe->id), (void const   */* __restrict  */)(buf),
           (size_t )3);
    }
    {
#line 964
    tmp___2 = get_be_int(buf + 2);
    }
#line 964
    newframe->sz = (int )(tmp___2 & 16777215U);
#line 965
    newframe->offset = tag->curr_off;
    }
#line 967
    if (newframe->offset + (off_t )newframe->sz > (tag->offset + 10L) + (off_t )tag->tagsz) {
      {
      {
#line 968
      _id3_frame_destroy(newframe);
      }
      }
#line 969
      goto while_break;
    }
    {
#line 971
    newframe->id3 = tag;
    {
#line 972
    _id3_frame_add(tag, newframe);
    }
    }
#line 982
    if (tag->seekable) {
#line 983
      if (tag->unsync) {
        {
        {
#line 984
        tmp___3 = unsync_fseek___1(tag->fp, (long )newframe->sz, 1, & offset);
        }
        }
#line 984
        if (tmp___3 == -1) {
#line 985
          return (-1);
        }
#line 986
        tag->curr_off += offset;
      } else {
        {
        {
#line 988
        tmp___4 = fseek(tag->fp, (long )newframe->sz, 1);
        }
        }
#line 988
        if (tmp___4 == -1) {
#line 989
          tag->seekable = 0U;
        } else {
#line 991
          tag->curr_off += (off_t )newframe->sz;
        }
      }
    }
#line 994
    if (! tag->seekable) {
      {
      {
#line 996
      tmp___5 = _read_v2_frame_data___1(newframe);
      }
#line 996
      offset = (long )tmp___5;
      }
#line 997
      if (offset == -1L) {
#line 998
        goto error;
      }
#line 999
      tag->curr_off += offset;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1003
  return (tag->nframes);
  error: 
#line 1006
  return (-1);
}
}
#line 40 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
static struct fid_desc  const  fid_desc_map___1[156]  = 
#line 40 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/frame_desc.c"
  {      {"BUF", "Recommended buffer size"}, 
        {"CNT", "Play counter"}, 
        {"COM", "Comments"}, 
        {"CRA", "Audio encryption"}, 
        {"CRM", "Encrypted meta frame"}, 
        {"ETC", "Event timing codes"}, 
        {"EQU", "Equalization"}, 
        {"GEO", "General encapsulated object"}, 
        {"IPL", "Involved people list"}, 
        {"LNK", "Linked information"}, 
        {"MCI", "Music CD Identifier"}, 
        {"MLL", "MPEG location lookup table"}, 
        {"PIC", "Attached picture"}, 
        {"POP", "Popularimeter"}, 
        {"REV", "Reverb"}, 
        {"RVA", "Relative volume adjustment"}, 
        {"SLT", "Synchronized lyric/text"}, 
        {"STC", "Synced tempo codes"}, 
        {"TAL", "Album/Movie/Show title"}, 
        {"TBP", "BPM (Beats Per Minute)"}, 
        {"TCM", "Composer"}, 
        {"TCO", "Content type"}, 
        {"TCR", "Copyright message"}, 
        {"TDA", "Date"}, 
        {"TDY", "Playlist delay"}, 
        {"TEN", "Encoded by"}, 
        {"TFT", "File type"}, 
        {"TIM", "Time"}, 
        {"TKE", "Initial key"}, 
        {"TLA", "Language(s)"}, 
        {"TLE", "Length"}, 
        {"TMT", "Media type"}, 
        {"TOA", "Original artist(s)/performer(s)"}, 
        {"TOF", "Original filename"}, 
        {"TOL", "Original Lyricist(s)/text writer(s)"}, 
        {"TOR", "Original release year"}, 
        {"TOT", "Original album/Movie/Show title"}, 
        {"TP1", "Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group"}, 
        {"TP2", "Band/Orchestra/Accompaniment"}, 
        {"TP3", "Conductor/Performer refinement"}, 
        {"TP4", "Interpreted, remixed, or otherwise modified by"}, 
        {"TPA", "Part of a set"}, 
        {"TPB", "Publisher"}, 
        {"TRC", "ISRC (International Standard Recording Code)"}, 
        {"TRD", "Recording dates"}, 
        {"TRK", "Track number/Position in set"}, 
        {"TSI", "Size"}, 
        {"TSS", "Software/hardware and settings used for encoding"}, 
        {"TT1", "Content group description"}, 
        {"TT2", "Title/Songname/Content description"}, 
        {"TT3", "Subtitle/Description refinement"}, 
        {"TXT", "Lyricist/text writer"}, 
        {"TXX", "User defined text information frame"}, 
        {"TYE", "Year"}, 
        {"UFI", "Unique file identifier"}, 
        {"ULT", "Unsychronized lyric/text transcription"}, 
        {"WAF", "Official audio file webpage"}, 
        {"WAR", "Official artist/performer webpage"}, 
        {"WAS", "Official audio source webpage"}, 
        {"WCM", "Commercial information"}, 
        {"WCP", "Copyright/Legal information"}, 
        {"WPB", "Publishers official webpage"}, 
        {"WXX", "User defined URL link frame"}, 
        {"AENC", "Audio encryption"}, 
        {"APIC", "Attached picture"}, 
        {"COMM", "Comments"}, 
        {"COMR", "Commercial frame"}, 
        {"ENCR", "Encryption method registration"}, 
        {"EQUA", "Equalisation"}, 
        {"ETCO", "Event timing codes"}, 
        {"GEOB", "General encapsulated object"}, 
        {"GRID", "Group identification registration"}, 
        {"IPLS", "Involved people list"}, 
        {"LINK", "Linked information"}, 
        {"MCDI", "Music CD identifier"}, 
        {"MLLT", "MPEG location lookup table"}, 
        {"OWNE", "Ownership frame"}, 
        {"PRIV", "Private frame"}, 
        {"PCNT", "Play counter"}, 
        {"POPM", "Popularimeter"}, 
        {"POSS", "Position synchronisation frame"}, 
        {"RBUF", "Recommended buffer size"}, 
        {"RVAD", "Relative volume adjustment"}, 
        {"RVRB", "Reverb"}, 
        {"SYLT", "Synchronised lyric/text"}, 
        {"SYTC", "Synchronised tempo codes"}, 
        {"TALB", "Album/Movie/Show title"}, 
        {"TBPM", "BPM (beats per minute)"}, 
        {"TCOM", "Composer"}, 
        {"TCON", "Content type"}, 
        {"TCOP", "Copyright message"}, 
        {"TDAT", "Date"}, 
        {"TDLY", "Playlist delay"}, 
        {"TENC", "Encoded by"}, 
        {"TEXT", "Lyricist/Text writer"}, 
        {"TFLT", "File type"}, 
        {"TIME", "Time"}, 
        {"TIT1", "Content group description"}, 
        {"TIT2", "Title/songname/content description"}, 
        {"TIT3", "Subtitle/Description refinement"}, 
        {"TKEY", "Initial key"}, 
        {"TLAN", "Language(s)"}, 
        {"TLEN", "Length"}, 
        {"TMED", "Media type"}, 
        {"TOAL", "Original album/movie/show title"}, 
        {"TOFN", "Original filename"}, 
        {"TOLY", "Original lyricist(s)/text writer(s)"}, 
        {"TOPE", "Original artist(s)/performer(s)"}, 
        {"TORY", "Original release year"}, 
        {"TOWN", "File owner/licensee"}, 
        {"TPE1", "Lead performer(s)/Soloist(s)"}, 
        {"TPE2", "Band/orchestra/accompaniment"}, 
        {"TPE3", "Conductor/performer refinement"}, 
        {"TPE4", "Interpreted, remixed, or otherwise modified by"}, 
        {"TPOS", "Part of a set"}, 
        {"TPUB", "Publisher"}, 
        {"TRCK", "Track number/Position in set"}, 
        {"TRDA", "Recording dates"}, 
        {"TRSN", "Internet radio station name"}, 
        {"TRSO", "Internet radio station owner"}, 
        {"TSIZ", "Size"}, 
        {"TSRC", "ISRC (international standard recording code)"}, 
        {"TSSE", "Software/Hardware and settings used for encoding"}, 
        {"TYER", "Year"}, 
        {"TXXX", "User defined text information frame"}, 
        {"UFID", "Unique file identifier"}, 
        {"USER", "Terms of use"}, 
        {"USLT", "Unsynchronised lyric/text transcription"}, 
        {"WCOM", "Commercial information"}, 
        {"WCOP", "Copyright/Legal information"}, 
        {"WOAF", "Official audio file webpage"}, 
        {"WOAR", "Official artist/performer webpage"}, 
        {"WOAS", "Official audio source webpage"}, 
        {"WORS", "Official Internet radio station homepage"}, 
        {"WPAY", "Payment"}, 
        {"WPUB", "Publishers official webpage"}, 
        {"WXXX", "User defined URL link frame"}, 
        {"ASPI", "Audio seek point index"}, 
        {"EQU2", "Equalisation (2)"}, 
        {"RVA2", "Relative volume adjustment (2)"}, 
        {"SEEK", "Seek frame"}, 
        {"SIGN", "Signature frame"}, 
        {"TDEN", "Encoding time"}, 
        {"TDOR", "Original release time"}, 
        {"TDRC", "Recording time"}, 
        {"TDRL", "Release time"}, 
        {"TDTG", "Tagging time"}, 
        {"TIPL", "Involved people list"}, 
        {"TMCL", "Musician credits list"}, 
        {"TMOO", "Mood"}, 
        {"TPRO", "Produced notice"}, 
        {"TSOA", "Album sort order"}, 
        {"TSOP", "Performer sort order"}, 
        {"TSOT", "Title sort order"}, 
        {"TSST", "Set subtitle"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 81 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xrename___2(char const   *oldpath , char const   *newpath ) ;
#line 82
static int xmkstemp___2(char *template ) ;
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static size_t unsync_fwrite___1(void *buf , size_t size , FILE *stream , int *state ,
                                size_t *written ) 
{ 
  unsigned char *p ;
  unsigned char *p_save ;
  size_t writ ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 98
  p = (unsigned char *)buf;
#line 103
  writ = (size_t )0;
#line 104
  p_save = p;
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! (size > 0U)) {
#line 106
      goto while_break;
    }
#line 107
    c = (int )*p;
#line 109
    if (*state) {
#line 109
      if (c == 0) {
#line 109
        goto _L;
      } else
#line 109
      if ((c & 224) == 224) {
        _L: /* CIL Label */ 
        {
        {
#line 111
        tmp = _IO_putc(0, stream);
        }
        }
#line 111
        if (tmp == -1) {
#line 112
          goto while_break;
        }
#line 113
        writ ++;
      }
    }
    {
#line 115
    *state = c == 255;
    {
#line 116
    tmp___0 = _IO_putc(c, stream);
    }
    }
#line 116
    if (tmp___0 == -1) {
#line 117
      goto while_break;
    }
#line 118
    p ++;
#line 118
    size --;
#line 118
    writ ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  if (written) {
#line 122
    *written = writ;
  }
#line 124
  return ((size_t )(p - p_save));
}
}
#line 132 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int encode_unsync___1(unsigned char *dest , unsigned char *src , int sz ) 
{ 
  unsigned char *dest_save ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 135
  dest_save = dest;
  {
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (sz > 0)) {
#line 137
      goto while_break;
    }
#line 138
    if ((int )*src != 255) {
#line 139
      tmp = dest;
#line 139
      dest ++;
#line 139
      tmp___0 = src;
#line 139
      src ++;
#line 139
      *tmp = *tmp___0;
#line 140
      sz --;
    } else {
#line 142
      tmp___1 = dest;
#line 142
      dest ++;
#line 142
      tmp___2 = src;
#line 142
      src ++;
#line 142
      *tmp___1 = *tmp___2;
#line 143
      sz --;
#line 144
      if (sz <= 0) {
#line 145
        goto while_break;
      }
#line 146
      if ((int )*src == 0) {
#line 147
        tmp___3 = dest;
#line 147
        dest ++;
#line 147
        *tmp___3 = (unsigned char)0;
      } else
#line 146
      if (((int )*src & 224) == 224) {
#line 147
        tmp___3 = dest;
#line 147
        dest ++;
#line 147
        *tmp___3 = (unsigned char)0;
      }
#line 148
      tmp___4 = dest;
#line 148
      dest ++;
#line 148
      tmp___5 = src;
#line 148
      src ++;
#line 148
      *tmp___4 = *tmp___5;
#line 149
      sz --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((int )(dest - dest_save));
}
}
#line 169 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void syncsafe_int___1(unsigned char *buf , unsigned int x ) 
{ 


  {
#line 172
  *(buf + 3) = (unsigned char )(x & 127U);
#line 173
  x >>= 7;
#line 174
  *(buf + 2) = (unsigned char )(x & 127U);
#line 175
  x >>= 7;
#line 176
  *(buf + 1) = (unsigned char )(x & 127U);
#line 177
  x >>= 7;
#line 178
  *(buf + 0) = (unsigned char )(x & 127U);
#line 179
  return;
}
}
#line 182 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_frame_data_sizes___1(id3_t tag ) 
{ 
  int sz ;
  id3_frame_t f ;
  int tmp ;

  {
#line 185
  sz = 0;
#line 188
  f = tag->frame_hd;
  {
  {
#line 188
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 188
    if (! f) {
#line 188
      goto while_break;
    }
    {
    {
#line 189
    tmp = id3_frame_get_size(f);
    }
#line 189
    sz += tmp;
#line 188
    f = f->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (sz);
}
}
#line 195 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_v4_frame_sizes___1(id3_t tag ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 198
  tmp = id3_frame_count(tag);
  }
#line 198
  nframes = tmp;
  {
#line 199
  tmp___0 = _sum_frame_data_sizes___1(tag);
  }
  }
#line 199
  return (nframes * 10 + tmp___0);
}
}
#line 203 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _sum_v3_frame_sizes___1(id3_t tag ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 206
  tmp = id3_frame_count(tag);
  }
#line 206
  nframes = tmp;
  {
#line 207
  tmp___0 = _sum_frame_data_sizes___1(tag);
  }
  }
#line 207
  return (nframes * 10 + tmp___0);
}
}
#line 225 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _form_v4_header___1(id3_t tag , unsigned char *hdr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 228
  memcpy((void */* __restrict  */)hdr, (void const   */* __restrict  */)"ID3", (size_t )3);
  }
#line 229
  *(hdr + 3) = tag->version;
#line 230
  *(hdr + 4) = tag->revision;
#line 231
  *(hdr + 5) = (unsigned char)0;
  }
#line 232
  if (tag->unsync) {
#line 233
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 128);
  }
#line 235
  if (tag->experimental) {
#line 236
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 32);
  }
#line 238
  if (tag->append_req) {
#line 239
    *(hdr + 5) = (unsigned char )((int )*(hdr + 5) | 16);
  }
  {
  {
#line 240
  syncsafe_int___1(hdr + 6, (unsigned int )tag->tagsz);
  }
  }
#line 241
  return;
}
}
#line 243 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_header___1(id3_t tag , FILE *out ) 
{ 
  unsigned char buf[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;

  {
  {
  {
#line 248
  _form_v4_header___1(tag, buf);
  }
  {
#line 250
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 250
  if (tmp < 10U) {
#line 251
    return (-1);
  }
#line 252
  tag->curr_off += 10L;
#line 254
  return (0);
}
}
#line 257 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_footer___1(id3_t tag , FILE *out ) 
{ 
  unsigned char buf[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 262
  _form_v4_header___1(tag, buf);
  }
  {
#line 265
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)"3DI", (size_t )3);
  }
  {
#line 267
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 267
  if (tmp < 10U) {
#line 268
    return (-1);
  }
#line 269
  tag->curr_off += 10L;
#line 271
  return (0);
}
}
#line 274 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v4_frames___1(id3_t tag , FILE *out ) 
{ 
  id3_frame_t f ;
  int sz ;
  int unsync_bufsz ;
  unsigned char hdr[10] ;
  unsigned char *buf ;
  unsigned char *unsync_buf ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;

  {
#line 278
  unsync_bufsz = 512;
#line 280
  unsync_buf = (unsigned char *)((void *)0);
#line 282
  f = tag->frame_hd;
  {
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 282
    if (! f) {
#line 282
      goto while_break;
    }
#line 284
    if (tag->unsync) {
      {
      {
#line 285
      id3_frame_set_flag(f, (enum id3_fflag )6);
      }
      }
    }
    {
    {
#line 288
    memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)(f->id),
           (size_t )4);
    }
    {
#line 289
    syncsafe_int___1(hdr + 4, (unsigned int )f->sz);
    }
#line 290
    hdr[8] = (unsigned char )(((int )f->flags >> 8) & 255);
#line 291
    hdr[9] = (unsigned char )((int )f->flags & 255);
    {
#line 293
    tmp = id3_frame_get_raw(f);
    }
#line 293
    buf = (unsigned char *)tmp;
    }
#line 294
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 295
      goto __Cont;
    }
    {
#line 298
    f->offset = tag->curr_off + 10L;
    {
#line 300
    tmp___5 = id3_frame_get_flag(f, (enum id3_fflag )6);
    }
    }
#line 300
    if (tmp___5) {
#line 301
      if ((unsigned long )unsync_buf == (unsigned long )((void *)0)) {
#line 301
        goto _L;
      } else
#line 301
      if (unsync_bufsz < (f->sz * 3) / 2) {
        _L: /* CIL Label */ 
#line 302
        unsync_bufsz = (f->sz * 3) / 2;
#line 303
        if (unsync_buf) {
          {
          {
#line 304
          free((void *)unsync_buf);
          }
          }
        }
        {
        {
#line 305
        tmp___0 = malloc((size_t )unsync_bufsz);
        }
#line 305
        unsync_buf = (unsigned char *)tmp___0;
        }
#line 306
        if ((unsigned long )unsync_buf == (unsigned long )((void *)0)) {
#line 307
          return (-1);
        }
      }
      {
      {
#line 309
      sz = encode_unsync___1(unsync_buf, buf, f->sz);
      }
      {
#line 312
      syncsafe_int___1(hdr + 4, (unsigned int )sz);
      }
      }
#line 315
      if (! tag->unsync) {
#line 315
        if (sz == f->sz) {
          {
          {
#line 316
          id3_frame_clear_flag(f, (enum id3_fflag )6);
          }
          }
        }
      }
      {
      {
#line 319
      tmp___1 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 319
      if (tmp___1 < 10U) {
#line 320
        return (-1);
      }
      {
      {
#line 322
      tmp___2 = fwrite((void const   */* __restrict  */)unsync_buf, (size_t )1, (size_t )sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 322
      if (tmp___2 < (size_t )sz) {
#line 323
        return (-1);
      }
#line 324
      tag->curr_off += (off_t )(10 + sz);
    } else {
      {
      {
#line 329
      tmp___3 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 329
      if (tmp___3 < 10U) {
#line 330
        return (-1);
      }
      {
      {
#line 332
      tmp___4 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )f->sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 332
      if (tmp___4 < (size_t )f->sz) {
#line 333
        return (-1);
      }
#line 334
      tag->curr_off += (off_t )(10 + f->sz);
    }
    {
    {
#line 338
    free((void *)f->data);
    }
#line 339
    f->data = (unsigned char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 282
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (unsync_buf) {
    {
    {
#line 343
    free((void *)unsync_buf);
    }
    }
  }
#line 345
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v3_header___1(id3_t tag , FILE *out ) 
{ 
  unsigned char hdr[10] ;
  size_t tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 358
  memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)"ID3", (size_t )3);
  }
#line 359
  hdr[3] = tag->version;
#line 360
  hdr[4] = tag->revision;
#line 361
  hdr[5] = (unsigned char)0;
  }
#line 362
  if (tag->unsync) {
#line 363
    hdr[5] = (unsigned char )((int )hdr[5] | 128);
  }
#line 365
  if (tag->experimental) {
#line 366
    hdr[5] = (unsigned char )((int )hdr[5] | 32);
  }
  {
  {
#line 367
  syncsafe_int___1(hdr + 6, (unsigned int )tag->tagsz);
  }
  {
#line 368
  tmp = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10, (FILE */* __restrict  */)out);
  }
  }
#line 368
  if (tmp < 10U) {
#line 369
    return (-1);
  }
#line 370
  tag->curr_off += 10L;
#line 372
  return (0);
}
}
#line 375 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_v3_frames___1(id3_t tag , FILE *out ) 
{ 
  id3_frame_t f ;
  int fwrite_state ;
  size_t consumed ;
  unsigned char hdr[10] ;
  unsigned char *buf ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp13 ;

  {
#line 379
  fwrite_state = 0;
#line 384
  f = tag->frame_hd;
  {
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 384
    if (! f) {
#line 384
      goto while_break;
    }
    {
    {
#line 387
    memcpy((void */* __restrict  */)(hdr), (void const   */* __restrict  */)(f->id),
           (size_t )4);
    }
    {
#line 388
    put_be_int(hdr + 4, (unsigned int )f->sz);
    }
#line 389
    hdr[8] = (unsigned char )(((int )f->flags >> 8) & 255);
#line 390
    hdr[9] = (unsigned char )((int )f->flags & 255);
    {
#line 392
    tmp = id3_frame_get_raw(f);
    }
#line 392
    buf = (unsigned char *)tmp;
    }
#line 393
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 394
      goto __Cont;
    }
#line 397
    f->offset = tag->curr_off + 10L;
#line 399
    if (tag->unsync) {
      {
      {
#line 401
      tmp___0 = unsync_fwrite___1((void *)(hdr), (size_t )10, out, & fwrite_state,
                                  & consumed);
      }
      }
#line 401
      if (tmp___0 < 10U) {
#line 402
        return (-1);
      }
      {
#line 403
      tag->curr_off += (off_t )consumed;
      {
#line 405
      tmp___1 = unsync_fwrite___1((void *)buf, (size_t )f->sz, out, & fwrite_state,
                                  & consumed);
      }
      }
#line 405
      if (tmp___1 < (size_t )f->sz) {
#line 406
        return (-1);
      }
#line 407
      tag->curr_off += (off_t )consumed;
    } else {
      {
      {
#line 410
      tmp___2 = fwrite((void const   */* __restrict  */)(hdr), (size_t )1, (size_t )10,
                       (FILE */* __restrict  */)out);
      }
      }
#line 410
      if (tmp___2 < 10U) {
#line 411
        return (-1);
      }
      {
      {
#line 413
      tmp___3 = fwrite((void const   */* __restrict  */)buf, (size_t )1, (size_t )f->sz,
                       (FILE */* __restrict  */)out);
      }
      }
#line 413
      if (tmp___3 < (size_t )f->sz) {
#line 414
        return (-1);
      }
#line 415
      tag->curr_off += (off_t )(10 + f->sz);
    }
    {
    {
#line 419
    free((void *)f->data);
    }
#line 420
    f->data = (unsigned char *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 384
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return (0);
}
}
#line 428 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _build_v1_tag___1(char *buf , id3_t tag ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 432
  memset((void *)buf, 0, (size_t )128);
  }
  {
#line 433
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"TAG");
  }
  {
#line 434
  strncpy((char */* __restrict  */)(buf + 3), (char const   */* __restrict  */)(tag->v1.title),
          (size_t )30);
  }
  {
#line 435
  strncpy((char */* __restrict  */)(buf + 33), (char const   */* __restrict  */)(tag->v1.artist),
          (size_t )30);
  }
  {
#line 436
  strncpy((char */* __restrict  */)(buf + 63), (char const   */* __restrict  */)(tag->v1.album),
          (size_t )30);
  }
  {
#line 437
  strncpy((char */* __restrict  */)(buf + 93), (char const   */* __restrict  */)(tag->v1.year),
          (size_t )4);
  }
  {
#line 438
  strncpy((char */* __restrict  */)(buf + 97), (char const   */* __restrict  */)(tag->v1.comment),
          (size_t )30);
  }
  }
#line 439
  if ((int )*(buf + 125) == 0) {
#line 440
    *(buf + 126) = (char )tag->v1.track;
  }
#line 441
  *(buf + 127) = (char )tag->v1.genre;
#line 442
  return;
}
}
#line 446 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static void _calculate_tag_sizes___1(id3_t tag , int *pold_sz , int *pnew_sz ) 
{ 
  int old_tagsz ;
  int new_tagsz ;
  int frames_sz ;
  int padded_sz ;

  {
  {
  {
#line 455
  old_tagsz = id3_get_size(tag);
  }
  }
#line 456
  if (old_tagsz > 0) {
#line 457
    old_tagsz += 10;
  }
#line 458
  if (tag->has_footer) {
#line 459
    old_tagsz += 10;
  }
  {
#line 462
  if ((int )tag->version == 4) {
#line 462
    goto case_4;
  }
#line 465
  if ((int )tag->version == 3) {
#line 465
    goto case_3;
  }
#line 468
  goto switch_default;
  case_4: /* CIL Label */ 
  {
  {
#line 463
  frames_sz = _sum_v4_frame_sizes___1(tag);
  }
  }
#line 464
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 466
  frames_sz = _sum_v3_frame_sizes___1(tag);
  }
  }
#line 467
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 469
  abort();
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 501
  if ((unsigned int )tag->pad_policy == 1U) {
#line 501
    goto case_1;
  }
#line 504
  if ((unsigned int )tag->pad_policy == 2U) {
#line 504
    goto case_2;
  }
#line 474
  goto switch_default___0;
  switch_default___0: /* CIL Label */ 
#line 476
  new_tagsz = frames_sz + 10;
#line 477
  if (old_tagsz >= new_tagsz) {
#line 478
    new_tagsz = old_tagsz;
  } else {
#line 481
    new_tagsz += 32;
#line 482
    if (new_tagsz <= 256) {
#line 484
      new_tagsz = 256;
    } else
#line 485
    if (new_tagsz <= 32768) {
#line 487
      padded_sz = 1;
#line 488
      new_tagsz --;
      {
      {
#line 489
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 489
        if (! (new_tagsz > 0)) {
#line 489
          goto while_break;
        }
#line 490
        padded_sz <<= 1;
#line 491
        new_tagsz >>= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 493
      new_tagsz = padded_sz;
    } else {
#line 496
      new_tagsz --;
#line 497
      new_tagsz = ((new_tagsz >> 14) + 1) << 14;
    }
  }
#line 500
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 502
  new_tagsz = frames_sz + 10;
#line 503
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 505
  new_tagsz = frames_sz + 10;
#line 506
  if (tag->requested_sz > new_tagsz) {
#line 507
    new_tagsz = tag->requested_sz;
  }
#line 508
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 513
  if (tag->append_req) {
#line 514
    new_tagsz = frames_sz + 20;
  }
#line 517
  if (frames_sz == 0) {
#line 518
    new_tagsz = 0;
  }
#line 521
  tag->tagsz = new_tagsz;
#line 522
  if (tag->tagsz) {
#line 523
    tag->tagsz -= 10;
  }
#line 524
  if (tag->append_req) {
#line 525
    tag->tagsz -= 10;
  }
#line 528
  *pold_sz = old_tagsz;
#line 529
  *pnew_sz = new_tagsz;
#line 530
  return;
}
}
#line 533 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int _write_tag___1(id3_t tag , FILE *out ) 
{ 
  int nframes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 536
  tmp = id3_frame_count(tag);
  }
#line 536
  nframes = tmp;
  }
#line 538
  if (nframes > 0) {
    {
#line 540
    if ((int )tag->version == 4) {
#line 540
      goto case_4;
    }
#line 550
    if ((int )tag->version == 3) {
#line 550
      goto case_3;
    }
#line 556
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 541
    tag->has_footer = tag->append_req;
    {
#line 542
    tmp___0 = _write_v4_header___1(tag, out);
    }
    }
#line 542
    if (tmp___0 == -1) {
#line 543
      return (-1);
    }
    {
    {
#line 544
    tmp___1 = _write_v4_frames___1(tag, out);
    }
    }
#line 544
    if (tmp___1 == -1) {
#line 545
      return (-1);
    }
#line 546
    if (tag->append_req) {
      {
      {
#line 547
      tmp___2 = _write_v4_footer___1(tag, out);
      }
      }
#line 547
      if (tmp___2 == -1) {
#line 548
        return (-1);
      }
    }
#line 549
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 551
    tmp___3 = _write_v3_header___1(tag, out);
    }
    }
#line 551
    if (tmp___3 == -1) {
#line 552
      return (-1);
    }
    {
    {
#line 553
    tmp___4 = _write_v3_frames___1(tag, out);
    }
    }
#line 553
    if (tmp___4 == -1) {
#line 554
      return (-1);
    }
#line 555
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 557
    abort();
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 561
  return (0);
}
}
#line 910 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static char sfx___3[7]  = {      (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'A',      (char )'A',      (char )'\000'};
#line 907 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xmkstemp___2(char *template ) 
{ 
  char *p ;
  int fd ;
  int i ;
  int done ;
  size_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 914
  tmp = strlen((char const   *)template);
  }
#line 914
  p = (template + tmp) - 6;
  {
#line 915
  tmp___1 = strcmp((char const   *)p, "XXXXXX");
  }
  }
#line 915
  if (tmp___1 != 0) {
    {
    {
#line 916
    tmp___0 = __errno_location();
    }
#line 916
    *tmp___0 = 22;
    }
#line 917
    return (-1);
  }
  {
  {
#line 920
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 921
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)(sfx___3));
    }
#line 924
    done = 0;
#line 924
    i = 5;
    }
    {
    {
#line 925
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 925
      if (! done) {
#line 925
        if (! (i >= 0)) {
#line 925
          goto while_break___0;
        }
      } else {
#line 925
        goto while_break___0;
      }
#line 926
      sfx___3[i] = (char )((int )sfx___3[i] + 1);
#line 927
      if ((int )sfx___3[i] > 90) {
#line 928
        sfx___3[i] = (char )'A';
#line 929
        i --;
      } else {
#line 931
        done = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 934
    if (! done) {
      {
      {
#line 935
      tmp___2 = __errno_location();
      }
#line 935
      *tmp___2 = 17;
      }
#line 936
      return (-1);
    }
    {
    {
#line 940
    fd = open((char const   *)template, 194, 384);
    }
    }
#line 920
    if (fd == -1) {
      {
      {
#line 920
      tmp___3 = __errno_location();
      }
      }
#line 920
      if (! (*tmp___3 == 17)) {
#line 920
        goto while_break;
      }
    } else {
#line 920
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  return (fd);
}
}
#line 952 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/write.c"
static int xrename___2(char const   *oldpath , char const   *newpath ) 
{ 
  FILE *in ;
  FILE *out ;
  char buf[4096] ;
  size_t sz ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 959
  tmp = strcmp(oldpath, newpath);
  }
  }
#line 959
  if (tmp == 0) {
#line 960
    return (0);
  }
  {
  {
#line 967
  tmp___8 = rename(oldpath, newpath);
  }
  }
#line 967
  if (tmp___8 == -1) {
    {
    {
#line 968
    tmp___7 = __errno_location();
    }
    }
#line 968
    if (*tmp___7 == 18) {
      {
      {
#line 970
      tmp___0 = unlink(newpath);
      }
      }
#line 970
      if (tmp___0 == -1) {
        {
        {
#line 970
        tmp___1 = __errno_location();
        }
        }
#line 970
        if (*tmp___1 != 2) {
#line 971
          return (-1);
        }
      }
      {
      {
#line 973
      in = fopen((char const   */* __restrict  */)oldpath, (char const   */* __restrict  */)"rb");
      }
      }
#line 974
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 975
        return (-1);
      }
      {
      {
#line 976
      out = fopen((char const   */* __restrict  */)newpath, (char const   */* __restrict  */)"wb");
      }
      }
#line 977
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        {
        {
#line 978
        fclose(in);
        }
        }
#line 979
        return (-1);
      }
      {
      {
#line 982
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 982
        sz = fread((void */* __restrict  */)(buf), (size_t )1, (size_t )4096, (FILE */* __restrict  */)in);
        }
        }
#line 982
        if (! (sz > 0U)) {
#line 982
          goto while_break;
        }
        {
        {
#line 983
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, sz, (FILE */* __restrict  */)out);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 985
      tmp___2 = ferror(in);
      }
      }
#line 985
      if (tmp___2) {
        {
        {
#line 986
        fclose(in);
        }
        {
#line 987
        fclose(out);
        }
        }
#line 988
        return (-1);
      } else {
        {
        {
#line 985
        tmp___3 = ferror(out);
        }
        }
#line 985
        if (tmp___3) {
          {
          {
#line 986
          fclose(in);
          }
          {
#line 987
          fclose(out);
          }
          }
#line 988
          return (-1);
        }
      }
      {
      {
#line 990
      tmp___4 = fclose(in);
      }
      }
#line 990
      if (tmp___4 == -1) {
        {
        {
#line 991
        fclose(out);
        }
        }
#line 992
        return (-1);
      }
      {
      {
#line 994
      tmp___5 = fclose(out);
      }
      }
#line 994
      if (tmp___5 == -1) {
#line 995
        return (-1);
      }
      {
      {
#line 997
      tmp___6 = unlink(oldpath);
      }
      }
#line 997
      if (tmp___6 == -1) {
#line 998
        return (-1);
      }
    } else {
#line 1000
      return (-1);
    }
  }
#line 1004
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_link___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 62
static int convert_apic___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 63
static int convert_time___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 64
static int convert_tcon___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) ;
#line 65
static int convert_rva___1(id3_frame_t f , char const   *from , char const   *to ,
                           int backward ) ;
#line 67 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  _convert_map_v2to3___1[65]  = 
#line 67
  {      {"BUF", "RBUF", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CNT",
      "PCNT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"COM",
      "COMM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CRA",
      "AENC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"CRM",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"ETC", "ETCO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"EQU",
      "EQUA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"GEO",
      "GEOB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"IPL",
      "IPLS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"LNK",
      "LINK", & convert_link___1}, 
        {"MCI", "MCDI", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"MLL",
      "MLLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"PIC",
      "APIC", & convert_apic___1}, 
        {"POP", "POPM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"REV",
      "RVRB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"RVA",
      "RVAD", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"SLT",
      "SYLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"STC",
      "SYTC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TAL",
      "TALB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TBP",
      "TBPM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCM",
      "TCOM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCO",
      "TCON", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCR",
      "TCOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TDA",
      "TDAT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TDY",
      "TDLY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TEN",
      "TENC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TFT",
      "TFLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TIM",
      "TIME", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TKE",
      "TKEY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TLA",
      "TLAN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TLE",
      "TLEN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TMT",
      "TMED", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOA",
      "TOPE", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOF",
      "TOFN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOL",
      "TOLY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOR",
      "TORY", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TOT",
      "TOAL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP1",
      "TPE1", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP2",
      "TPE2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP3",
      "TPE3", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TP4",
      "TPE4", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TPA",
      "TPOS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TPB",
      "TPUB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRC",
      "TSRC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRD",
      "TRDA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRK",
      "TRCK", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TSI",
      "TSIZ", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TSS",
      "TSSE", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT1",
      "TIT1", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT2",
      "TIT2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TT3",
      "TIT3", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TXT",
      "TEXT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TXX",
      "TXXX", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TYE",
      "TYER", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"UFI",
      "UFID", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"ULT",
      "USLT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAF",
      "WOAF", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAR",
      "WOAR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WAS",
      "WOAS", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WCM",
      "WCOM", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WCP",
      "WCOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WPB",
      "WPUB", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"WXX",
      "WXXX", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"XRV",
      "XRVA", & convert_rva___1}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(id3_frame_t  ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         int  ))((void *)0)}};
#line 137 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  _convert_map_v3to4___1[30]  = 
#line 137
  {      {"EQUA", (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {"IPLS",
      "TIPL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"RVAD",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"TDAT", "TDRC", & convert_time___1}, 
        {"TIME", "TDRC", & convert_time___1}, 
        {"TORY", "TDOR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TRDA",
      (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * , char const   * ,
                                            int  ))((void *)0)}, 
        {"TSIZ", (char const   *)((void *)0), (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {"TYER",
      "TDRC", & convert_time___1}, 
        {"XRVA", "RVA2", & convert_rva___1}, 
        {(char const   *)((void *)0), "ASPI", (int (*)(id3_frame_t  , char const   * ,
                                                    char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "EQU2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "RVA2", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "SEEK", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "SIGN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDEN", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDOR", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDRC", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDRL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TDTG", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TIPL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TMCL", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TMOO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TPRO", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOA", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOP", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSOT", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {(char const   *)((void *)0),
      "TSST", (int (*)(id3_frame_t  , char const   * , char const   * , int  ))((void *)0)}, 
        {"TCON",
      "TCON", & convert_tcon___1}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int (*)(id3_frame_t  ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         int  ))((void *)0)}};
#line 181 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_link___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 


  {
#line 185
  return (0);
}
}
#line 193 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct imgtype_mimetype_struct  const  imgtype_mimetype_map___1[11]  = 
#line 193
  {      {"jpg", "jpeg"}, 
        {"tif", "tiff"}, 
        {"xbm", "x-xbitmap"}, 
        {"xpm", "x-xpixmap"}, 
        {"xwd", "x-xwindowdump"}, 
        {"ras", "x-cmu-raster"}, 
        {"pnm", "x-portable-anymap"}, 
        {"pbm", "x-portable-bitmap"}, 
        {"pgm", "x-portable-graymap"}, 
        {"rgb", "x-rgb"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_apic_forward___1(id3_frame_t f ) 
{ 
  char imgtype[4] ;
  char mimetype[32] ;
  struct imgtype_mimetype_struct  const  *im_map ;
  unsigned char *data ;
  int i ;
  int newsz ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 218
  tmp = id3_frame_get_raw(f);
  }
#line 218
  data = (unsigned char *)tmp;
  }
#line 219
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 220
    return (0);
  }
  {
  {
#line 221
  memcpy((void */* __restrict  */)(imgtype), (void const   */* __restrict  */)(data + 1),
         (size_t )3);
  }
#line 222
  imgtype[3] = (char )'\000';
#line 223
  i = 0;
  }
  {
  {
#line 223
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < 3)) {
#line 223
      goto while_break;
    }
    {
    {
#line 224
    tmp___0 = tolower((int )imgtype[i]);
    }
#line 224
    imgtype[i] = (char )tmp___0;
#line 223
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 227
  strcpy((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)"image/");
  }
#line 228
  im_map = imgtype_mimetype_map___1;
  }
  {
  {
#line 229
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 229
    if (! im_map->imgtype) {
#line 229
      goto while_break___0;
    }
    {
    {
#line 230
    tmp___1 = strcmp((char const   *)(imgtype), (char const   *)im_map->imgtype);
    }
    }
#line 230
    if (tmp___1 == 0) {
      {
      {
#line 231
      strcat((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)im_map->mimetype);
      }
      }
#line 232
      goto while_break___0;
    }
#line 234
    im_map ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 238
  if ((unsigned long )im_map->imgtype == (unsigned long )((void *)0)) {
    {
    {
#line 239
    strcat((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)(imgtype));
    }
    }
  }
  {
  {
#line 241
  tmp___2 = strlen((char const   *)(mimetype));
  }
#line 241
  i = (int )tmp___2;
#line 242
  newsz = ((f->sz - 3) + i) + 1;
  {
#line 243
  tmp___3 = malloc((size_t )newsz);
  }
#line 243
  f->data = (unsigned char *)tmp___3;
  }
#line 244
  if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 245
    f->data = data;
#line 246
    return (-1);
  }
  {
#line 248
  *(f->data + 0) = *(data + 0);
  {
#line 249
  strcpy((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)(mimetype));
  }
  {
#line 250
  memcpy((void */* __restrict  */)(((f->data + 1) + i) + 1), (void const   */* __restrict  */)(data + 4),
         (size_t )(f->sz - 4));
  }
#line 251
  f->sz = newsz;
  {
#line 252
  free((void *)data);
  }
  }
#line 254
  return (0);
}
}
#line 258 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_apic_backward___1(id3_frame_t f ) 
{ 
  char imgtype[4] ;
  char *mimetype ;
  struct imgtype_mimetype_struct  const  *im_map ;
  unsigned char *data ;
  int i ;
  int newsz ;
  int len ;
  int bad_mimetype ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 261
  mimetype = (char *)((void *)0);
#line 264
  bad_mimetype = 0;
  {
#line 266
  tmp = id3_frame_get_raw(f);
  }
#line 266
  data = (unsigned char *)tmp;
  }
#line 267
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 268
    return (0);
  }
#line 271
  i = 1;
  {
  {
#line 271
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 271
    if (! (i < f->sz)) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )*(data + i) == 0) {
#line 273
      goto while_break;
    }
#line 271
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  if ((int )*(data + i) != 0) {
#line 276
    bad_mimetype = 1;
  } else
#line 275
  if (i < 8) {
#line 276
    bad_mimetype = 1;
  }
#line 278
  if (! bad_mimetype) {
    {
#line 279
    mimetype = (char *)data + 1;
    {
#line 280
    tmp___0 = strlen((char const   *)mimetype);
    }
#line 280
    len = (int )tmp___0;
#line 281
    i = 0;
    }
    {
    {
#line 281
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! (i < len)) {
#line 281
        goto while_break___0;
      }
      {
      {
#line 282
      tmp___1 = tolower((int )*(mimetype + i));
      }
#line 282
      *(mimetype + i) = (char )tmp___1;
#line 281
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 283
    tmp___2 = strncmp((char const   *)mimetype, "image/", (size_t )6);
    }
    }
#line 283
    if (tmp___2 != 0) {
#line 284
      bad_mimetype = 1;
    }
  }
#line 287
  if (! bad_mimetype) {
#line 288
    mimetype += 6;
#line 290
    im_map = imgtype_mimetype_map___1;
    {
    {
#line 291
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 291
      if (! im_map->mimetype) {
#line 291
        goto while_break___1;
      }
      {
      {
#line 292
      tmp___3 = strcmp((char const   *)mimetype, (char const   *)im_map->mimetype);
      }
      }
#line 292
      if (tmp___3 == 0) {
        {
        {
#line 293
        strcpy((char */* __restrict  */)(imgtype), (char const   */* __restrict  */)im_map->imgtype);
        }
        }
#line 294
        goto while_break___1;
      }
#line 296
      im_map ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 301
    if ((unsigned long )im_map->mimetype == (unsigned long )((void *)0)) {
      {
      {
#line 302
      strncpy((char */* __restrict  */)(imgtype), (char const   */* __restrict  */)mimetype,
              (size_t )3);
      }
      }
    }
#line 303
    imgtype[3] = (char )'\000';
  } else {
#line 307
    return (0);
  }
  {
#line 310
  newsz = ((f->sz - len) - 1) + 3;
  {
#line 311
  memcpy((void */* __restrict  */)(f->data + 1), (void const   */* __restrict  */)(imgtype),
         (size_t )3);
  }
  {
#line 312
  memmove((void *)(f->data + 4), (void const   *)(((f->data + 4) + len) + 1), (size_t )(((f->sz - 4) - len) - 1));
  }
#line 313
  f->sz = newsz;
  }
#line 315
  return (0);
}
}
#line 318 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_apic___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 321
  if (backward) {
    {
    {
#line 322
    tmp = _convert_apic_backward___1(f);
    }
    }
#line 322
    return (tmp);
  } else {
    {
    {
#line 324
    tmp___0 = _convert_apic_forward___1(f);
    }
    }
#line 324
    return (tmp___0);
  }
}
}
#line 328 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_time_backward___1(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t f2 ;
  unsigned char *old_data ;
  unsigned char buf[32] ;
  int len ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 331
  tag = f->id3;
  {
#line 338
  tmp = id3_frame_get_raw(f);
  }
#line 338
  old_data = (unsigned char *)tmp;
  }
#line 339
  if ((unsigned long )old_data == (unsigned long )((void *)0)) {
#line 340
    return (0);
  }
  {
  {
#line 341
  tmp___0 = strlen((char const   *)((char *)old_data + 1));
  }
#line 341
  len = (int )tmp___0;
  }
#line 343
  if (len >= 4) {
    {
    {
#line 345
    f2 = id3_frame_add(tag, "TYER");
    }
    }
#line 346
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 347
      return (-1);
    }
    {
    {
#line 348
    tmp___1 = id3_frame_set_raw(f2, (void *)old_data, 5);
    }
    }
#line 348
    if (tmp___1 == -1) {
#line 349
      return (-1);
    }
  }
#line 352
  if (len >= 10) {
    {
    {
#line 354
    f2 = id3_frame_add(tag, "TDAT");
    }
    }
#line 355
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 356
      return (-1);
    }
    {
#line 357
    buf[0] = (unsigned char )'\000';
#line 358
    buf[1] = *(old_data + 9);
#line 359
    buf[2] = *(old_data + 10);
#line 360
    buf[3] = *(old_data + 6);
#line 361
    buf[4] = *(old_data + 7);
    {
#line 362
    tmp___2 = id3_frame_set_raw(f2, (void *)(buf), 5);
    }
    }
#line 362
    if (tmp___2 == -1) {
#line 363
      return (-1);
    }
  }
#line 366
  if (len >= 16) {
    {
    {
#line 368
    f2 = id3_frame_add(tag, "TIME");
    }
    }
#line 369
    if ((unsigned long )f2 == (unsigned long )((void *)0)) {
#line 370
      return (-1);
    }
    {
#line 371
    buf[0] = (unsigned char )'\000';
#line 372
    buf[1] = *(old_data + 12);
#line 373
    buf[2] = *(old_data + 13);
#line 374
    buf[3] = *(old_data + 15);
#line 375
    buf[4] = *(old_data + 16);
    {
#line 376
    tmp___3 = id3_frame_set_raw(f2, (void *)(buf), 5);
    }
    }
#line 376
    if (tmp___3 == -1) {
#line 377
      return (-1);
    }
  }
#line 380
  return (1);
}
}
#line 384 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int _convert_time_forward___1(id3_frame_t f ) 
{ 
  id3_t tag ;
  id3_frame_t tdrc_f ;
  unsigned char *old_data ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  unsigned char tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  unsigned char tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  unsigned char tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 387
  tag = f->id3;
  {
#line 391
  tdrc_f = id3_get_frame_by_id(tag, "TDRC");
  }
  }
#line 392
  if ((unsigned long )tdrc_f == (unsigned long )((void *)0)) {
    {
    {
#line 394
    tmp = id3_frame_get_raw(f);
    }
#line 394
    old_data = (unsigned char *)tmp;
    {
#line 395
    tmp___6 = strcmp((char const   *)(f->id), "TDAT");
    }
    }
#line 395
    if (tmp___6 == 0) {
      {
      {
#line 398
      tmp___0 = strlen((char const   *)((char *)old_data + 1));
      }
      }
#line 398
      if (tmp___0 != 4U) {
#line 400
        return (1);
      }
      {
#line 402
      f->sz = 11;
      {
#line 403
      tmp___1 = calloc((size_t )(f->sz + 2), (size_t )1);
      }
#line 403
      f->data = (unsigned char *)tmp___1;
      {
#line 406
      sprintf((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)"????-%c%c-%c%c",
              (int )*(old_data + 3), (int )*(old_data + 4), (int )*(old_data + 1),
              (int )*(old_data + 2));
      }
      {
#line 408
      free((void *)old_data);
      }
      }
    } else {
      {
      {
#line 410
      tmp___5 = strcmp((char const   *)(f->id), "TIME");
      }
      }
#line 410
      if (tmp___5 == 0) {
        {
        {
#line 413
        tmp___2 = strlen((char const   *)((char *)old_data + 1));
        }
        }
#line 413
        if (tmp___2 != 4U) {
#line 415
          return (1);
        }
        {
#line 417
        f->sz = 17;
        {
#line 418
        tmp___3 = calloc((size_t )(f->sz + 2), (size_t )1);
        }
#line 418
        f->data = (unsigned char *)tmp___3;
        {
#line 421
        sprintf((char */* __restrict  */)((char *)f->data + 1), (char const   */* __restrict  */)"????-??-??T%c%c:%c%c",
                (int )*(old_data + 1), (int )*(old_data + 2), (int )*(old_data + 3),
                (int )*(old_data + 4));
        }
        {
#line 423
        free((void *)old_data);
        }
        }
      } else {
        {
        {
#line 425
        tmp___4 = strcmp((char const   *)(f->id), "TYER");
        }
        }
#line 425
        if (! (tmp___4 == 0)) {
#line 429
          return (-1);
        }
      }
    }
  } else {
    {
    {
#line 435
    id3_frame_get_raw(f);
    }
    {
#line 436
    tmp___21 = strcmp((char const   *)(f->id), "TDAT");
    }
    }
#line 436
    if (tmp___21 == 0) {
      {
      {
#line 439
      tmp___7 = strlen((char const   *)((char *)f->data + 1));
      }
      }
#line 439
      if (tmp___7 != 4U) {
#line 441
        return (1);
      }
#line 444
      if (tdrc_f->sz < 11) {
        {
        {
#line 446
        tmp___8 = id3_frame_get_raw(tdrc_f);
        }
#line 446
        old_data = (unsigned char *)tmp___8;
#line 447
        tdrc_f->sz = 11;
        {
#line 448
        tmp___9 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
        }
#line 448
        tdrc_f->data = (unsigned char *)tmp___9;
        }
#line 449
        if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 450
          tdrc_f->data = old_data;
#line 451
          return (-1);
        }
#line 453
        tmp___10 = (unsigned char )'\000';
#line 453
        *(tdrc_f->data + 12) = tmp___10;
#line 453
        *(tdrc_f->data + 11) = tmp___10;
      }
      {
      {
#line 456
      sprintf((char */* __restrict  */)((char *)tdrc_f->data + 5), (char const   */* __restrict  */)"-%c%c-%c%c",
              (int )*(f->data + 3), (int )*(f->data + 4), (int )*(f->data + 1), (int )*(f->data + 2));
      }
      }
    } else {
      {
      {
#line 459
      tmp___20 = strcmp((char const   *)(f->id), "TIME");
      }
      }
#line 459
      if (tmp___20 == 0) {
        {
        {
#line 462
        tmp___11 = strlen((char const   *)((char *)f->data + 1));
        }
        }
#line 462
        if (tmp___11 != 4U) {
#line 464
          return (1);
        }
#line 467
        if (tdrc_f->sz < 17) {
          {
          {
#line 469
          tmp___12 = id3_frame_get_raw(tdrc_f);
          }
#line 469
          old_data = (unsigned char *)tmp___12;
#line 470
          tdrc_f->sz = 17;
          {
#line 471
          tmp___13 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
          }
#line 471
          tdrc_f->data = (unsigned char *)tmp___13;
          }
#line 472
          if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 473
            tdrc_f->data = old_data;
#line 474
            return (-1);
          }
#line 476
          tmp___14 = (unsigned char )'\000';
#line 476
          *(tdrc_f->data + 18) = tmp___14;
#line 476
          *(tdrc_f->data + 17) = tmp___14;
        }
        {
        {
#line 479
        sprintf((char */* __restrict  */)((char *)tdrc_f->data + 11), (char const   */* __restrict  */)"T%c%c:%c%c",
                (int )*(f->data + 1), (int )*(f->data + 2), (int )*(f->data + 3),
                (int )*(f->data + 4));
        }
        }
      } else {
        {
        {
#line 482
        tmp___19 = strcmp((char const   *)(f->id), "TYER");
        }
        }
#line 482
        if (tmp___19 == 0) {
          {
          {
#line 485
          tmp___15 = strlen((char const   *)((char *)f->data + 1));
          }
          }
#line 485
          if (tmp___15 != 4U) {
#line 487
            return (1);
          }
#line 490
          if (tdrc_f->sz < 5) {
            {
            {
#line 492
            tmp___16 = id3_frame_get_raw(tdrc_f);
            }
#line 492
            old_data = (unsigned char *)tmp___16;
#line 493
            tdrc_f->sz = 5;
            {
#line 494
            tmp___17 = realloc((void *)tdrc_f->data, (size_t )(tdrc_f->sz + 2));
            }
#line 494
            tdrc_f->data = (unsigned char *)tmp___17;
            }
#line 495
            if ((unsigned long )tdrc_f->data == (unsigned long )((void *)0)) {
#line 496
              tdrc_f->data = old_data;
#line 497
              return (-1);
            }
#line 499
            tmp___18 = (unsigned char )'\000';
#line 499
            *(tdrc_f->data + 6) = tmp___18;
#line 499
            *(tdrc_f->data + 5) = tmp___18;
          }
          {
          {
#line 502
          memcpy((void */* __restrict  */)(tdrc_f->data + 1), (void const   */* __restrict  */)(f->data + 1),
                 (size_t )4);
          }
          }
        } else {
#line 506
          return (-1);
        }
      }
    }
#line 509
    return (1);
  }
#line 512
  return (0);
}
}
#line 517 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_time___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 520
  if (backward) {
    {
    {
#line 521
    tmp = _convert_time_backward___1(f);
    }
    }
#line 521
    return (tmp);
  } else {
    {
    {
#line 523
    tmp___0 = _convert_time_forward___1(f);
    }
    }
#line 523
    return (tmp___0);
  }
}
}
#line 527 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_tcon___1(id3_frame_t f , char const   *from , char const   *to ,
                            int backward ) 
{ 
  char *src ;
  char *dest ;
  char *rparen ;
  unsigned char *data ;
  char *endptr ;
  int i ;
  int newsz ;
  int len ;
  int last_was_nonnumeric ;
  long gnum ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 536
  tmp = id3_frame_get_raw(f);
  }
#line 536
  data = (unsigned char *)tmp;
  }
#line 538
  if (f->sz < 1) {
#line 539
    return (0);
  }
#line 542
  if (backward) {
#line 548
    newsz = f->sz + 2;
#line 549
    i = 0;
    {
    {
#line 549
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 549
      if (! (i < f->sz)) {
#line 549
        goto while_break;
      }
#line 550
      if ((int )*(data + i) == 40) {
#line 551
        newsz ++;
      } else
#line 550
      if ((int )*(data + i) == 0) {
#line 551
        newsz ++;
      }
#line 549
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 553
    tmp___0 = calloc((size_t )newsz, (size_t )1);
    }
#line 553
    f->data = (unsigned char *)tmp___0;
    }
#line 554
    if ((unsigned long )f->data == (unsigned long )((void *)0)) {
#line 555
      f->data = data;
#line 556
      return (-1);
    }
#line 559
    src = (char *)data;
#line 560
    dest = (char *)f->data;
#line 561
    tmp___1 = dest;
#line 561
    dest ++;
#line 561
    tmp___2 = src;
#line 561
    src ++;
#line 561
    *tmp___1 = *tmp___2;
#line 562
    last_was_nonnumeric = 0;
    {
    {
#line 563
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 563
      if (! (src - (char *)data < (long )f->sz)) {
#line 563
        goto while_break___0;
      }
#line 566
      if ((int )*(src + 0) >= 48) {
#line 566
        if ((int )*(src + 0) <= 57) {
          {
          {
#line 567
          gnum = strtol((char const   */* __restrict  */)src, (char **/* __restrict  */)(& endptr),
                        10);
          }
          }
#line 568
          if ((int )*endptr == 0) {
#line 568
            if (gnum >= 0L) {
#line 568
              if (gnum <= 255L) {
                {
                {
#line 569
                tmp___3 = sprintf((char */* __restrict  */)dest, (char const   */* __restrict  */)"(%d)",
                                  (int )gnum);
                }
#line 569
                dest += tmp___3;
#line 570
                src = endptr + 1;
#line 571
                last_was_nonnumeric = 0;
                }
#line 572
                goto while_continue___0;
              }
            }
          }
        }
      }
#line 577
      if (last_was_nonnumeric) {
#line 579
        tmp___4 = dest;
#line 579
        dest ++;
#line 579
        *tmp___4 = (char )'/';
      }
      {
      {
#line 581
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 581
        if (! ((int )*src != 0)) {
#line 581
          goto while_break___1;
        }
#line 582
        if ((int )*src == 40) {
#line 583
          tmp___5 = dest;
#line 583
          dest ++;
#line 583
          *tmp___5 = (char )'(';
        }
#line 584
        tmp___6 = dest;
#line 584
        dest ++;
#line 584
        tmp___7 = src;
#line 584
        src ++;
#line 584
        *tmp___6 = *tmp___7;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 586
      src ++;
#line 587
      last_was_nonnumeric = 1;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 589
    newsz = (int )(dest - (char *)f->data);
    {
#line 590
    free((void *)data);
    }
    }
  } else {
#line 597
    dest = (char *)data + 1;
#line 597
    src = dest;
    {
    {
#line 598
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 598
      if (! (src - (char *)data < (long )f->sz)) {
#line 598
        goto while_break___2;
      }
#line 600
      if ((int )*(src + 0) == 40) {
        {
        {
#line 602
        rparen = strchr((char const   *)src, ')');
        }
        }
#line 603
        if ((int )*(src + 1) == 40) {
#line 605
          src ++;
#line 606
          if (rparen) {
#line 607
            len = (int )((rparen - src) + 1L);
          } else {
#line 609
            len = (int )((long )f->sz - (src - (char *)data));
          }
          {
          {
#line 610
          memmove((void *)dest, (void const   *)src, (size_t )len);
          }
#line 611
          src += len;
#line 612
          dest += len;
          }
        } else {
#line 615
          if ((unsigned long )rparen == (unsigned long )((void *)0)) {
#line 616
            goto while_break___2;
          }
#line 617
          *rparen = (char )'\000';
#line 618
          if ((int )*(dest + -1) == 0) {
#line 619
            src ++;
          } else {
#line 621
            *src = (char )'\000';
          }
          {
#line 622
          len = (int )(rparen - src);
          {
#line 623
          memmove((void *)dest, (void const   *)src, (size_t )len);
          }
#line 624
          src += len;
#line 625
          dest += len;
          }
        }
      } else {
#line 629
        tmp___8 = dest;
#line 629
        dest ++;
#line 629
        tmp___9 = src;
#line 629
        src ++;
#line 629
        *tmp___8 = *tmp___9;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 633
    newsz = (int )(dest - (char *)data);
  }
#line 636
  f->sz = newsz;
#line 637
  *(f->data + f->sz) = (unsigned char )'\000';
#line 639
  return (0);
}
}
#line 651 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_rva___1(id3_frame_t f , char const   *from , char const   *to ,
                           int backward ) 
{ 
  int i ;
  int peakbytes ;
  unsigned char *data ;
  void *tmp ;

  {
  {
  {
#line 657
  tmp = id3_frame_get_raw(f);
  }
#line 657
  data = (unsigned char *)tmp;
#line 660
  i = 0;
  }
  {
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 660
    if (! (i < f->sz)) {
#line 660
      goto while_break;
    }
#line 661
    if ((int )*(data + i) == 0) {
#line 662
      goto while_break;
    }
#line 660
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 663
  if ((int )*(data + i) != 0) {
#line 664
    return (1);
  }
#line 666
  i ++;
  {
  {
#line 667
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 669
    if (i >= f->sz) {
#line 670
      return (1);
    } else
#line 669
    if ((int )*(data + i) > 8) {
#line 670
      return (1);
    }
#line 673
    i += 3;
#line 674
    if (i >= f->sz) {
#line 675
      return (1);
    }
#line 676
    peakbytes = (int )*(data + i) / 8;
#line 677
    i += peakbytes;
#line 678
    if (i >= f->sz) {
#line 679
      return (1);
    }
#line 682
    i ++;
#line 683
    if (i >= f->sz) {
#line 684
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 687
  return (0);
}
}
#line 692 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static struct frame_convert  const  *find_converter___1(struct frame_convert  const  *map ,
                                                        char const   *from , int backw ) 
{ 
  char const   *s ;
  int tmp ;

  {
  {
  {
#line 697
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 697
    if (! map->from) {
#line 697
      if (! map->to) {
#line 697
        goto while_break;
      }
    }
#line 698
    if (backw) {
#line 698
      s = (char const   *)map->to;
    } else {
#line 698
      s = (char const   *)map->from;
    }
#line 699
    if (s) {
      {
      {
#line 699
      tmp = memcmp((void const   *)from, (void const   *)s, (size_t )4);
      }
      }
#line 699
      if (tmp == 0) {
#line 700
        return (map);
      }
    }
#line 701
    map ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 703
  return ((struct frame_convert  const  *)((void *)0));
}
}
#line 706 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/versions.c"
static int convert_frame___1(id3_frame_t f , int from_vers , int to_vers ) 
{ 
  struct frame_convert  const  *fc_map ;
  int ret ;
  int backward ;
  char const   *newid ;

  {
#line 709
  fc_map = (struct frame_convert  const  *)((void *)0);
#line 710
  backward = 0;
#line 713
  if (from_vers == to_vers) {
#line 714
    return (0);
  }
#line 716
  if (from_vers - to_vers > 1) {
    {
    {
#line 717
    ret = convert_frame___1(f, from_vers, to_vers + 1);
    }
    }
#line 718
    if (ret == -1) {
#line 719
      return (-1);
    }
#line 720
    from_vers = to_vers + 1;
  } else
#line 721
  if (to_vers - from_vers > 1) {
    {
    {
#line 722
    ret = convert_frame___1(f, from_vers, to_vers - 1);
    }
    }
#line 723
    if (ret == -1) {
#line 724
      return (-1);
    }
#line 725
    from_vers = to_vers - 1;
  }
  {
#line 730
  if (from_vers == 2) {
#line 730
    goto case_2;
  }
#line 735
  if (from_vers == 3) {
#line 735
    goto case_3;
  }
#line 747
  if (from_vers == 4) {
#line 747
    goto case_4___0;
  }
#line 729
  goto switch_break;
  case_2: /* CIL Label */ 
#line 732
  fc_map = _convert_map_v2to3___1;
#line 733
  backward = 0;
#line 734
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 737
  if (to_vers == 2) {
#line 737
    goto case_2___0;
  }
#line 741
  if (to_vers == 4) {
#line 741
    goto case_4;
  }
#line 736
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 738
  fc_map = _convert_map_v2to3___1;
#line 739
  backward = 1;
#line 740
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 742
  fc_map = _convert_map_v3to4___1;
#line 743
  backward = 0;
#line 744
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 746
  goto switch_break;
  case_4___0: /* CIL Label */ 
#line 749
  fc_map = _convert_map_v3to4___1;
#line 750
  backward = 1;
#line 751
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 754
  fc_map = find_converter___1(fc_map, (char const   *)(f->id), backward);
  }
  }
#line 755
  if (fc_map) {
#line 756
    if (fc_map->converter) {
      {
      {
#line 757
      ret = (*(fc_map->converter))(f, (char const   *)fc_map->from, (char const   *)fc_map->to,
                                   backward);
      }
      }
#line 758
      if (ret == -1) {
#line 759
        return (-1);
      }
#line 760
      if (ret == 1) {
        {
        {
#line 761
        id3_frame_delete(f);
        }
        }
#line 762
        return (0);
      }
    }
#line 765
    if (backward) {
#line 765
      newid = (char const   *)fc_map->from;
    } else {
#line 765
      newid = (char const   *)fc_map->to;
    }
#line 766
    if (newid) {
      {
      {
#line 767
      strcpy((char */* __restrict  */)(f->id), (char const   */* __restrict  */)newid);
      }
      }
    } else {
      {
      {
#line 770
      id3_frame_delete(f);
      }
      }
    }
  }
#line 774
  return (0);
}
}
#line 41 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_title_id___1(id3_t tag ) ;
#line 42
static char const   *_artist_id___1(id3_t tag ) ;
#line 43
static char const   *_album_id___1(id3_t tag ) ;
#line 44
static char const   *_genre_id___1(id3_t tag ) ;
#line 45
static char const   *_date_id___1(id3_t tag ) ;
#line 46
static char const   *_tracknum_id___1(id3_t tag ) ;
#line 47
static char *_do_get___1(id3_t tag , char const   *id ) ;
#line 48
static int _do_set___1(id3_t tag , char const   *id , char const   *s , enum id3_text_encoding enc ) ;
#line 194 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_title_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 197
  tmp = id3_get_version(tag);
  }
  }
  {
#line 198
  if ((unsigned int )tmp == 2U) {
#line 198
    goto case_2;
  }
#line 201
  if ((unsigned int )tmp == 4U) {
#line 201
    goto case_4;
  }
#line 201
  if ((unsigned int )tmp == 3U) {
#line 201
    goto case_4;
  }
#line 203
  goto switch_default;
  case_2: /* CIL Label */ 
#line 199
  return ("TT2");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 202
  return ("TIT2");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 206
  return ((char const   *)((void *)0));
}
}
#line 209 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_artist_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 212
  tmp = id3_get_version(tag);
  }
  }
  {
#line 213
  if ((unsigned int )tmp == 2U) {
#line 213
    goto case_2;
  }
#line 216
  if ((unsigned int )tmp == 4U) {
#line 216
    goto case_4;
  }
#line 216
  if ((unsigned int )tmp == 3U) {
#line 216
    goto case_4;
  }
#line 218
  goto switch_default;
  case_2: /* CIL Label */ 
#line 214
  return ("TP1");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 217
  return ("TPE1");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 221
  return ((char const   *)((void *)0));
}
}
#line 224 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_album_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 227
  tmp = id3_get_version(tag);
  }
  }
  {
#line 228
  if ((unsigned int )tmp == 2U) {
#line 228
    goto case_2;
  }
#line 231
  if ((unsigned int )tmp == 4U) {
#line 231
    goto case_4;
  }
#line 231
  if ((unsigned int )tmp == 3U) {
#line 231
    goto case_4;
  }
#line 233
  goto switch_default;
  case_2: /* CIL Label */ 
#line 229
  return ("TAL");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 232
  return ("TALB");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 236
  return ((char const   *)((void *)0));
}
}
#line 239 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_genre_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 242
  tmp = id3_get_version(tag);
  }
  }
  {
#line 243
  if ((unsigned int )tmp == 2U) {
#line 243
    goto case_2;
  }
#line 246
  if ((unsigned int )tmp == 4U) {
#line 246
    goto case_4;
  }
#line 246
  if ((unsigned int )tmp == 3U) {
#line 246
    goto case_4;
  }
#line 248
  goto switch_default;
  case_2: /* CIL Label */ 
#line 244
  return ("TCO");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 247
  return ("TCON");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 251
  return ((char const   *)((void *)0));
}
}
#line 254 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_date_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 257
  tmp = id3_get_version(tag);
  }
  }
  {
#line 258
  if ((unsigned int )tmp == 2U) {
#line 258
    goto case_2;
  }
#line 260
  if ((unsigned int )tmp == 3U) {
#line 260
    goto case_3;
  }
#line 262
  if ((unsigned int )tmp == 4U) {
#line 262
    goto case_4;
  }
#line 264
  goto switch_default;
  case_2: /* CIL Label */ 
#line 259
  return ("TYE");
  case_3: /* CIL Label */ 
#line 261
  return ("TYER");
  case_4: /* CIL Label */ 
#line 263
  return ("TDRC");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 267
  return ((char const   *)((void *)0));
}
}
#line 270 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char const   *_tracknum_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 273
  tmp = id3_get_version(tag);
  }
  }
  {
#line 274
  if ((unsigned int )tmp == 2U) {
#line 274
    goto case_2;
  }
#line 277
  if ((unsigned int )tmp == 4U) {
#line 277
    goto case_4;
  }
#line 277
  if ((unsigned int )tmp == 3U) {
#line 277
    goto case_4;
  }
#line 279
  goto switch_default;
  case_2: /* CIL Label */ 
#line 275
  return ("TRK");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 278
  return ("TRCK");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 282
  return ((char const   *)((void *)0));
}
}
#line 285 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static char *_do_get___1(id3_t tag , char const   *id ) 
{ 
  id3_frame_t f ;
  char *s ;
  void *tmp ;

  {
  {
  {
#line 292
  id3_frame_count(tag);
  }
  }
#line 294
  if (id) {
    {
    {
#line 295
    f = id3_get_frame_by_id(tag, id);
    }
    }
#line 296
    if (f) {
      {
      {
#line 296
      tmp = id3_frame_get_raw(f);
      }
#line 296
      s = (char *)tmp;
      }
#line 296
      if (s) {
#line 297
        return (s + 1);
      }
    }
  }
#line 299
  return ((char *)((void *)0));
}
}
#line 302 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/simple.c"
static int _do_set___1(id3_t tag , char const   *id , char const   *s , enum id3_text_encoding enc ) 
{ 
  id3_frame_t tmp ;

  {
#line 305
  if ((unsigned long )id == (unsigned long )((void *)0)) {
#line 306
    return (-1);
  }
  {
  {
#line 307
  tmp = id3_add_text_frame(tag, id, s, (int )enc);
  }
  }
#line 307
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 308
    return (-1);
  }
#line 309
  return (0);
}
}
#line 48 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static char const   *_comment_id___1(id3_t tag ) 
{ 
  enum id3_version tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 51
  tmp = id3_get_version(tag);
  }
  }
  {
#line 52
  if ((unsigned int )tmp == 2U) {
#line 52
    goto case_2;
  }
#line 55
  if ((unsigned int )tmp == 4U) {
#line 55
    goto case_4;
  }
#line 55
  if ((unsigned int )tmp == 3U) {
#line 55
    goto case_4;
  }
#line 57
  goto switch_default;
  case_2: /* CIL Label */ 
#line 53
  return ("COM");
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 56
  return ("COMM");
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return ((char const   *)((void *)0));
}
}
#line 64 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static int _desc_eq___1(char const   *a , char const   *b , int size , enum id3_text_encoding enc ) 
{ 
  int i ;

  {
#line 67
  i = 0;
  {
#line 70
  if ((unsigned int )enc == 2U) {
#line 70
    goto case_2;
  }
#line 70
  if ((unsigned int )enc == 1U) {
#line 70
    goto case_2;
  }
#line 80
  if ((unsigned int )enc == 0U) {
#line 80
    goto case_0;
  }
#line 80
  if ((unsigned int )enc == 3U) {
#line 80
    goto case_0;
  }
#line 68
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < size)) {
#line 71
      goto while_break;
    }
#line 72
    if ((int const   )*(a + i) != (int const   )*(b + i)) {
#line 73
      return (0);
    } else
#line 72
    if ((int const   )*(a + (i + 1)) != (int const   )*(b + (i + 1))) {
#line 73
      return (0);
    }
#line 74
    if ((int const   )*(a + i) == 0) {
#line 74
      if ((int const   )*(a + (i + 1)) == 0) {
#line 75
        goto while_break;
      }
    }
#line 76
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 81
    if (! (i < size)) {
#line 81
      goto while_break___0;
    }
#line 82
    if ((int const   )*(a + i) != (int const   )*(b + i)) {
#line 83
      return (0);
    }
#line 84
    if ((int const   )*(a + i) == 0) {
#line 85
      goto while_break___0;
    }
#line 86
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  return (1);
}
}
#line 94 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static char *_get_comment_text___1(id3_frame_t f ) 
{ 
  unsigned char *s ;
  void *tmp ;

  {
  {
  {
#line 97
  tmp = id3_frame_get_raw(f);
  }
#line 97
  s = (unsigned char *)tmp;
  }
#line 99
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 100
    return ((char *)((void *)0));
  }
  {
#line 103
  if ((int )*(s + 0) == 2) {
#line 103
    goto case_2;
  }
#line 103
  if ((int )*(s + 0) == 1) {
#line 103
    goto case_2;
  }
#line 112
  if ((int )*(s + 0) == 0) {
#line 112
    goto case_0;
  }
#line 112
  if ((int )*(s + 0) == 3) {
#line 112
    goto case_0;
  }
#line 101
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 104
  s += 4;
  {
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 105
    if (s - f->data <= (long )f->sz) {
#line 105
      if ((int )*(s + 0) == 0) {
#line 105
        if ((int )*(s + 1) == 0) {
#line 105
          goto while_break;
        }
      }
    } else {
#line 105
      goto while_break;
    }
#line 106
    s += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if ((int )*(s + 0) == 0) {
#line 107
    if (! ((int )*(s + 1) == 0)) {
#line 108
      return ((char *)((void *)0));
    }
  } else {
#line 108
    return ((char *)((void *)0));
  }
#line 109
  s += 2;
#line 110
  goto switch_break;
  case_0: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 113
  s += 4;
  {
  {
#line 114
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 114
    if (s - f->data <= (long )f->sz) {
#line 114
      if (! ((int )*(s + 0) != 0)) {
#line 114
        goto while_break___0;
      }
    } else {
#line 114
      goto while_break___0;
    }
#line 115
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  if ((int )*(s + 0) != 0) {
#line 117
    return ((char *)((void *)0));
  }
#line 118
  s ++;
#line 119
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 121
  return ((char *)s);
}
}
#line 129 "/home/wslee/benchmarks/sound/normalize-audio-0.7.7/nid3lib/comment.c"
static id3_frame_t _get_comment_frame___1(id3_t tag , char const   *desc , char const   *lang ) 
{ 
  char const   *id ;
  char const   *tmp ;
  char *s ;
  id3_frame_t f ;
  int nframes ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 132
  tmp = _comment_id___1(tag);
  }
#line 132
  id = tmp;
  {
#line 137
  nframes = id3_frame_count(tag);
  }
  }
#line 138
  if (nframes == -1) {
#line 139
    return ((id3_frame_t )((void *)0));
  }
#line 140
  f = tag->frame_hd;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! f) {
#line 140
      goto while_break;
    }
    {
    {
#line 141
    tmp___3 = strcmp((char const   *)(f->id), id);
    }
    }
#line 141
    if (tmp___3 == 0) {
      {
      {
#line 142
      tmp___0 = id3_frame_get_raw(f);
      }
#line 142
      s = (char *)tmp___0;
      }
#line 143
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 144
        goto __Cont;
      }
#line 145
      if (desc) {
        {
        {
#line 145
        tmp___1 = _desc_eq___1(desc, (char const   *)(s + 4), f->sz - 4, (enum id3_text_encoding )*(s + 0));
        }
        }
#line 145
        if (! tmp___1) {
#line 146
          goto __Cont;
        }
      }
#line 147
      if (lang) {
        {
        {
#line 147
        tmp___2 = memcmp((void const   *)lang, (void const   *)(s + 1), (size_t )3);
        }
        }
#line 147
        if (tmp___2 != 0) {
#line 148
          goto __Cont;
        }
      }
#line 149
      return (f);
    }
    __Cont: /* CIL Label */ 
#line 140
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return ((id3_frame_t )((void *)0));
}
}
