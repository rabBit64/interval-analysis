/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 50 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 53 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_9 {
   char __size[36] ;
   long __align ;
};
#line 53 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_9 pthread_attr_t;
#line 67 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 67 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_11 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_11 __annonCompField1 ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_10 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_10 pthread_mutex_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 382
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 413
extern int scanf(char const   * __restrict  __format  , ...) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 189
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 227 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 736
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 747
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 712
extern int system(char const   *__command ) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 30 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
pthread_mutex_t plock  =    {{0, 0U, 0, 0, 0U, {0}}};
#line 31 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
char const   *mozillacmdline  =    (char const   *)((void *)0);
#line 32 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
char *currentfile  =    (char *)((void *)0);
#line 33 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
time_t last_input  ;
#line 34 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
int wait_sleeptime  =    3;
#line 39 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
int loopexec(void) 
{ 
  time_t last_display ;
  time_t tmp ;
  time_t current_time ;
  int doit ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char *buf ;

  {
  {
  {
#line 41
  tmp = time((time_t *)((void *)0));
  }
#line 41
  last_display = tmp;
  }
  {
  {
#line 46
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 48
    sleep(1U);
    }
    {
#line 49
    pthread_mutex_lock(& plock);
    }
    {
#line 51
    current_time = time((time_t *)((void *)0));
    }
#line 52
    doit = 0;
    {
#line 55
    tmp___3 = difftime(last_input, last_display);
    }
    }
#line 55
    if (tmp___3 > (double )0) {
      {
      {
#line 57
      tmp___2 = difftime(current_time, last_input);
      }
      }
#line 57
      if (tmp___2 > (double )wait_sleeptime) {
#line 59
        doit = 1;
      } else {
        {
        {
#line 61
        tmp___0 = difftime(current_time, last_display);
        }
        }
#line 61
        if (tmp___0 > (double )20) {
          {
          {
#line 61
          tmp___1 = difftime(current_time, last_input);
          }
          }
#line 61
          if (tmp___1 > (double )0) {
#line 64
            doit = 1;
          }
        }
      }
    }
#line 68
    if (doit) {
#line 70
      if (currentfile) {
        {
#line 72
        buf = (char *)((void *)0);
        {
#line 73
        asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)mozillacmdline,
                 currentfile);
        }
        {
#line 75
        system((char const   *)buf);
        }
        {
#line 76
        free((void *)buf);
        }
#line 77
        last_display = current_time;
        }
      }
    }
    {
    {
#line 80
    pthread_mutex_unlock(& plock);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 85 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysihtmldaemon.c"
int main(int ac , char **av ) 
{ 
  pthread_t t ;
  int opt ;
  char *tmp ;
  char *instr ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 91
    opt = getopt(ac, (char * const  *)av, "m:s:");
    }
    }
#line 91
    if (! (-1 != opt)) {
#line 91
      goto while_break;
    }
    {
#line 95
    if (opt == 109) {
#line 95
      goto case_109;
    }
#line 98
    if (opt == 115) {
#line 98
      goto case_115;
    }
#line 101
    goto switch_default;
    case_109: /* CIL Label */ 
    {
    {
#line 96
    tmp = strdup((char const   *)optarg);
    }
#line 96
    mozillacmdline = (char const   *)tmp;
    }
#line 97
    goto switch_break;
    case_115: /* CIL Label */ 
    {
    {
#line 99
    wait_sleeptime = atoi((char const   *)optarg);
    }
    }
#line 100
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option -%c\n",
            opt);
    }
    {
#line 103
    exit(1);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 107
  printf((char const   */* __restrict  */)"wysihtmldaemon Version %s, with wait %i seconds\n",
         "0.13", wait_sleeptime);
  }
  }
#line 110
  if (! mozillacmdline) {
    {
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mozilla command-line not specified\n");
    }
    {
#line 113
    exit(1);
    }
    }
  }
  {
  {
#line 116
  pthread_create((pthread_t */* __restrict  */)(& t), (pthread_attr_t const   */* __restrict  */)((void *)0),
                 (void *(*)(void * ))(& loopexec), (void */* __restrict  */)((void *)0));
  }
  }
  {
  {
#line 117
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
#line 119
    instr = (char *)((void *)0);
    {
#line 120
    printf((char const   */* __restrict  */)">");
    }
    {
#line 121
    scanf((char const   */* __restrict  */)"%as", & instr);
    }
    {
#line 122
    pthread_mutex_lock(& plock);
    }
    }
#line 123
    if (currentfile) {
      {
      {
#line 123
      free((void *)currentfile);
      }
      }
    }
    {
#line 124
    currentfile = instr;
    {
#line 125
    last_input = time((time_t *)((void *)0));
    }
    {
#line 126
    pthread_mutex_unlock(& plock);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 615
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 41 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysidocbookdaemon.c"
char *temporary_filename  =    (char *)((void *)0);
#line 44 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysidocbookdaemon.c"
char *xsltstylesheet  =    (char *)"/usr/share/xml/docbook/stylesheet/ldp/html/tldp-one-page.xsl";
#line 47 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysidocbookdaemon.c"
char *optional  =    (char *)((void *)0);
#line 64 "/home/wslee/benchmarks/textformat/wysihtml-0.13/src/wysidocbookdaemon.c"
void new_temporary_filename(void) 
{ 
  int fd ;
  __pid_t tmp ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 67
  if (temporary_filename) {
    {
    {
#line 69
    tmp = fork();
    }
    }
#line 69
    if (! tmp) {
      {
      {
#line 71
      sleep(10U);
      }
      {
#line 82
      unlink((char const   *)temporary_filename);
      }
      {
#line 83
      exit(0);
      }
      }
    }
    {
    {
#line 85
    free((void *)temporary_filename);
    }
#line 86
    temporary_filename = (char *)((void *)0);
    }
  }
  {
  {
#line 89
  tmp___2 = getenv("TMPDIR");
  }
#line 89
  tmp___1 = (char const   *)tmp___2;
  }
#line 89
  if (! tmp___1) {
#line 89
    tmp___1 = "/tmp";
  }
  {
  {
#line 89
  asprintf((char **/* __restrict  */)(& temporary_filename), (char const   */* __restrict  */)"%s/wysidocbookXXXXXX",
           tmp___1);
  }
  {
#line 91
  fd = mkstemp(temporary_filename);
  }
  {
#line 92
  close(fd);
  }
  {
#line 94
  waitpid(-1, (int *)((void *)0), 1);
  }
  }
#line 95
  return;
}
}
