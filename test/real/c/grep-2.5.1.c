/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 139 "/usr/include/stdint.h"
typedef long long intmax_t;
#line 141 "/usr/include/stdint.h"
typedef unsigned long long uintmax_t;
#line 35 "/usr/include/inttypes.h"
typedef long __gwchar_t;
#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 17 "xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_INVALID = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_OVERFLOW = 3
} ;
#line 21 "xstrtol.h"
typedef enum strtol_error strtol_error;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long long __ino64_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 29 "exclude.h"
struct exclude;
#line 325 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef long wchar_t;
#line 41 "/usr/include/bits/types.h"
typedef unsigned char __uint8_t;
#line 21 "quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    escape_quoting_style = 4,
    locale_quoting_style = 5,
    clocale_quoting_style = 6
} ;
#line 41
struct quoting_options;
#line 354 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int wint_t;
#line 76 "/usr/include/wchar.h"
union __anonunion___value_13 {
   wint_t __wch ;
   char __wchb[4] ;
};
#line 76 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_12 {
   int __count ;
   union __anonunion___value_13 __value ;
};
#line 76 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_12 __mbstate_t;
#line 95 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 101 "quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
};
#line 415 "quotearg.c"
union __anonunion___u_15 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 533 "quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 553 "quotearg.c"
union __anonunion___u_16 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 590 "quotearg.c"
union __anonunion___u_17 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long long __blkcnt64_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
#line 39 "exclude.c"
struct exclude {
   char const   **exclude ;
   int exclude_alloc ;
   int exclude_count ;
};
#line 105 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 67 "/usr/include/wctype.h"
typedef unsigned long wctype_t;
#line 23 "system.h"
typedef void *ptr_t;
#line 27 "grep.h"
struct matcher {
   char name[8] ;
   void (*compile)(char const   * , size_t  ) ;
   size_t (*execute)(char const   * , size_t  , size_t * , int  ) ;
};
#line 52 "../lib/posix/regex.h"
typedef unsigned long reg_syntax_t;
#line 329 "../lib/posix/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 400 "../lib/posix/regex.h"
typedef int regoff_t;
#line 405 "../lib/posix/regex.h"
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 63 "dfa.h"
typedef int charclass[(((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))];
#line 69
enum __anonenum_token_20 {
    END = -1,
    EMPTY = 256,
    BACKREF = 257,
    BEGLINE = 258,
    ENDLINE = 259,
    BEGWORD = 260,
    ENDWORD = 261,
    LIMWORD = 262,
    NOTLIMWORD = 263,
    QMARK = 264,
    STAR = 265,
    PLUS = 266,
    REPMN = 267,
    CAT = 268,
    OR = 269,
    ORTOP = 270,
    LPAREN = 271,
    RPAREN = 272,
    CRANGE = 273,
    ANYCHAR = 274,
    MBCSET = 275,
    CSET = 276
} ;
#line 69 "dfa.h"
typedef enum __anonenum_token_20 token;
#line 222 "dfa.h"
struct __anonstruct_position_21 {
   unsigned int index ;
   unsigned int constraint ;
};
#line 222 "dfa.h"
typedef struct __anonstruct_position_21 position;
#line 229 "dfa.h"
struct __anonstruct_position_set_22 {
   position *elems ;
   int nelem ;
};
#line 229 "dfa.h"
typedef struct __anonstruct_position_set_22 position_set;
#line 238 "dfa.h"
struct __anonstruct_dfa_state_23 {
   int hash ;
   position_set elems ;
   char newline ;
   char letter ;
   char backref ;
   unsigned char constraint ;
   int first_end ;
   position_set mbps ;
};
#line 238 "dfa.h"
typedef struct __anonstruct_dfa_state_23 dfa_state;
#line 257 "dfa.h"
struct dfamust {
   int exact ;
   char *must ;
   struct dfamust *next ;
};
#line 267 "dfa.h"
struct mb_char_classes {
   int invert ;
   wchar_t *chars ;
   int nchars ;
   wctype_t *ch_classes ;
   int nch_classes ;
   wchar_t *range_sts ;
   wchar_t *range_ends ;
   int nranges ;
   char **equivs ;
   int nequivs ;
   char **coll_elems ;
   int ncoll_elems ;
};
#line 285 "dfa.h"
struct dfa {
   charclass *charclasses ;
   int cindex ;
   int calloc ;
   token *tokens ;
   int tindex ;
   int talloc ;
   int depth ;
   int nleaves ;
   int nregexps ;
   int nmultibyte_prop ;
   int *multibyte_prop ;
   struct mb_char_classes *mbcsets ;
   int nmbcsets ;
   int mbcsets_alloc ;
   dfa_state *states ;
   int sindex ;
   int salloc ;
   position_set *follows ;
   int searchflag ;
   int tralloc ;
   int trcount ;
   int **trans ;
   int **realtrans ;
   int **fails ;
   int *success ;
   struct dfamust *musts ;
};
#line 23 "kwset.h"
struct kwsmatch {
   int index ;
   size_t offset[1] ;
   size_t size[1] ;
};
#line 30 "kwset.h"
typedef ptr_t kwset_t;
#line 149 "/usr/include/pcre.h"
struct real_pcre;
#line 150 "/usr/include/pcre.h"
typedef struct real_pcre pcre;
#line 156 "/usr/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
};
#line 156 "/usr/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 52 "search.c"
struct patterns {
   struct re_pattern_buffer regexbuf ;
   struct re_registers regs ;
};
#line 155 "search.c"
union __anonunion___u_24 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 156 "search.c"
union __anonunion___u_25 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 154 "../lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 161 "../lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   int temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 50 "kwset.c"
struct trie;
#line 50 "kwset.c"
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
#line 60 "kwset.c"
struct trie {
   unsigned int accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   int depth ;
   int shift ;
   int maxshift ;
};
#line 73 "kwset.c"
struct kwset {
   struct obstack obstack ;
   int words ;
   struct trie *trie ;
   int mind ;
   int maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   int mind2 ;
   char const   *trans ;
};
#line 136
enum __anonenum_dirs_15 {
    L = 0,
    R = 1
} ;
#line 397 "../lib/posix/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 424 "../lib/posix/regex.h"
struct __anonstruct_regmatch_t_22 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 424 "../lib/posix/regex.h"
typedef struct __anonstruct_regmatch_t_22 regmatch_t;
#line 248 "dfa.c"
union __anonunion___u_27 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 677 "dfa.c"
struct __anonstruct_prednames_28 {
   char const   *name ;
   int (*pred)(int  ) ;
};
#line 1373 "dfa.c"
union __anonunion___u_29 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 2364
enum __anonenum_status_transit_state_30 {
    TRANSIT_STATE_IN_PROGRESS = 0,
    TRANSIT_STATE_DONE = 1,
    TRANSIT_STATE_END_BUFFER = 2
} ;
#line 2364 "dfa.c"
typedef enum __anonenum_status_transit_state_30 status_transit_state;
#line 2789 "dfa.c"
union __anonunion___u_31 {
   unsigned int __ui ;
   unsigned short __usi ;
   unsigned char __uc ;
};
#line 3323 "dfa.c"
struct __anonstruct_must_32 {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
};
#line 3323 "dfa.c"
typedef struct __anonstruct_must_32 must;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 188 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 117 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 83 "../lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 48 "grep.c"
struct stats {
   struct stats  const  *parent ;
   struct stat stat ;
};
#line 162
enum __anonenum_directories_25 {
    READ_DIRECTORIES = 0,
    RECURSE_DIRECTORIES = 1,
    SKIP_DIRECTORIES = 2
} ;
#line 170
enum __anonenum_devices_26 {
    READ_DEVICES = 0,
    SKIP_DEVICES = 1
} ;
#line 430
enum __anonenum_binary_files_27 {
    BINARY_BINARY_FILES = 0,
    TEXT_BINARY_FILES = 1,
    WITHOUT_MATCH_BINARY_FILES = 2
} ;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 305 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                   int base ) ;
#line 309
__inline extern uintmax_t strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) ;
#line 313
__inline extern intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                   int base ) ;
#line 318
__inline extern uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                    int base ) ;
#line 391
extern long long __strtoll_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                    int __base , int __group ) ;
#line 396 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                   int base ) 
{ 
  long long tmp ;

  {
  {
  {
#line 400
  tmp = __strtoll_internal(nptr, endptr, base, 0);
  }
  }
#line 400
  return (tmp);
}
}
#line 406
extern unsigned long long __strtoull_internal(char const   * __restrict  __nptr ,
                                              char ** __restrict  __endptr , int __base ,
                                              int __group ) ;
#line 424
extern long long __wcstoll_internal(__gwchar_t const   * __restrict  __nptr , __gwchar_t ** __restrict  __endptr ,
                                    int __base , int __group ) ;
#line 430 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                   int base ) 
{ 
  long long tmp ;

  {
  {
  {
#line 434
  tmp = __wcstoll_internal(nptr, endptr, base, 0);
  }
  }
#line 434
  return (tmp);
}
}
#line 441
extern unsigned long long __wcstoull_internal(__gwchar_t const   * __restrict  __nptr ,
                                              __gwchar_t ** __restrict  __endptr ,
                                              int __base , int __group ) ;
#line 449 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                    int base ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 453
  tmp = __wcstoull_internal(nptr, endptr, base, 0);
  }
  }
#line 453
  return (tmp);
}
}
#line 404 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 405
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 336
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 342
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
#line 442
__inline extern int getchar(void) ;
#line 454
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 455
__inline extern int getchar_unlocked(void) ;
#line 484
__inline extern int putchar(int __c ) ;
#line 498
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 506
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 507
__inline extern int putchar_unlocked(int __c ) ;
#line 730
__inline extern int feof_unlocked(FILE *__stream ) ;
#line 731
__inline extern int ferror_unlocked(FILE *__stream ) ;
#line 33 "/usr/include/bits/stdio.h"
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
  {
#line 36
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
  }
#line 36
  return (tmp);
}
}
#line 40 "/usr/include/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
  {
  {
#line 43
  tmp = _IO_getc(stdin);
  }
  }
#line 43
  return (tmp);
}
}
#line 49 "/usr/include/bits/stdio.h"
__inline extern int getc_unlocked(FILE *__fp ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 52
  if ((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end) {
    {
    {
#line 52
    tmp = __uflow(__fp);
    }
#line 52
    tmp___1 = tmp;
    }
  } else {
#line 52
    tmp___0 = __fp->_IO_read_ptr;
#line 52
    (__fp->_IO_read_ptr) ++;
#line 52
    tmp___1 = (int )*((unsigned char *)tmp___0);
  }
#line 52
  return (tmp___1);
}
}
#line 56 "/usr/include/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 59
  if ((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end) {
    {
    {
#line 59
    tmp = __uflow(stdin);
    }
#line 59
    tmp___1 = tmp;
    }
  } else {
#line 59
    tmp___0 = stdin->_IO_read_ptr;
#line 59
    (stdin->_IO_read_ptr) ++;
#line 59
    tmp___1 = (int )*((unsigned char *)tmp___0);
  }
#line 59
  return (tmp___1);
}
}
#line 65 "/usr/include/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
  {
  {
#line 68
  tmp = _IO_putc(__c, stdout);
  }
  }
#line 68
  return (tmp);
}
}
#line 74 "/usr/include/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 77
  if ((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end) {
    {
    {
#line 77
    tmp = __overflow(__stream, (int )((unsigned char )__c));
    }
#line 77
    tmp___2 = tmp;
    }
  } else {
#line 77
    tmp___0 = __stream->_IO_write_ptr;
#line 77
    (__stream->_IO_write_ptr) ++;
#line 77
    tmp___1 = (char )__c;
#line 77
    *tmp___0 = tmp___1;
#line 77
    tmp___2 = (int )((unsigned char )tmp___1);
  }
#line 77
  return (tmp___2);
}
}
#line 91 "/usr/include/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 94
  if ((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end) {
    {
    {
#line 94
    tmp = __overflow(stdout, (int )((unsigned char )__c));
    }
#line 94
    tmp___2 = tmp;
    }
  } else {
#line 94
    tmp___0 = stdout->_IO_write_ptr;
#line 94
    (stdout->_IO_write_ptr) ++;
#line 94
    tmp___1 = (char )__c;
#line 94
    *tmp___0 = tmp___1;
#line 94
    tmp___2 = (int )((unsigned char )tmp___1);
  }
#line 94
  return (tmp___2);
}
}
#line 111 "/usr/include/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 114
  return ((__stream->_flags & 16) != 0);
}
}
#line 118 "/usr/include/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 121
  return ((__stream->_flags & 32) != 0);
}
}
#line 142 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144
__inline extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 146
__inline extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 152
__inline extern long long atoll(char const   *__nptr )  __attribute__((__pure__)) ;
#line 159
__inline extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) ;
#line 176
__inline extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) ;
#line 187
__inline extern long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) ;
#line 191
__inline extern unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) ;
#line 200
__inline extern long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) ;
#line 204
__inline extern unsigned long long strtoull(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                            int __base ) ;
#line 264
extern double __strtod_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                int __group ) ;
#line 308 "/usr/include/stdlib.h"
__inline extern double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 311
  tmp = __strtod_internal(__nptr, __endptr, 0);
  }
  }
#line 311
  return (tmp);
}
}
#line 343 "/usr/include/stdlib.h"
__inline extern long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) 
{ 
  long long tmp ;

  {
  {
  {
#line 347
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 347
  return (tmp);
}
}
#line 349 "/usr/include/stdlib.h"
__inline extern unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 353
  tmp = __strtoull_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 353
  return (tmp);
}
}
#line 375
__inline extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 375 "/usr/include/stdlib.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 378
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
  }
#line 378
  return (tmp);
}
}
#line 380
__inline extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 380 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
  {
#line 383
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 383
  return ((int )tmp);
}
}
#line 385
__inline extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 385 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
  {
#line 388
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 388
  return (tmp);
}
}
#line 394
__inline extern long long atoll(char const   *__nptr )  __attribute__((__pure__)) ;
#line 394 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
  {
#line 397
  tmp = strtoq((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
  }
#line 397
  return (tmp);
}
}
#line 162 "/usr/include/string.h"
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 919 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 920 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 923
  __result = (size_t )0;
  {
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 924
    if ((int const   )*(__s + __result) != 0) {
#line 924
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 924
        goto while_break;
      }
    } else {
#line 924
      goto while_break;
    }
#line 925
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  return (__result);
}
}
#line 929
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 931 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 934
  __result = (size_t )0;
  {
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 935
    if ((int const   )*(__s + __result) != 0) {
#line 935
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 935
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 935
          goto while_break;
        }
      } else {
#line 935
        goto while_break;
      }
    } else {
#line 935
      goto while_break;
    }
#line 937
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  return (__result);
}
}
#line 941
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 943 "/usr/include/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 947
  __result = (size_t )0;
  {
  {
#line 948
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 948
    if ((int const   )*(__s + __result) != 0) {
#line 948
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 948
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 948
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 948
            goto while_break;
          }
        } else {
#line 948
          goto while_break;
        }
      } else {
#line 948
        goto while_break;
      }
    } else {
#line 948
      goto while_break;
    }
#line 950
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  return (__result);
}
}
#line 976
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 977 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 980
  __result = (size_t )0;
  {
  {
#line 982
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 982
    if (! ((int const   )*(__s + __result) == (int const   )__accept)) {
#line 982
      goto while_break;
    }
#line 983
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 984
  return (__result);
}
}
#line 987
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 989 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 992
  __result = (size_t )0;
  {
  {
#line 994
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 994
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 994
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 994
        goto while_break;
      }
    }
#line 995
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 996
  return (__result);
}
}
#line 999
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1001 "/usr/include/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1004
  __result = (size_t )0;
  {
  {
#line 1006
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1006
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1006
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1006
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1006
          goto while_break;
        }
      }
    }
#line 1008
    __result ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1009
  return (__result);
}
}
#line 1033
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1035 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1039
    if ((int const   )*__s != 0) {
#line 1039
      if ((int const   )*__s != (int const   )__accept1) {
#line 1039
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1039
          goto while_break;
        }
      } else {
#line 1039
        goto while_break;
      }
    } else {
#line 1039
      goto while_break;
    }
#line 1040
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  if ((int const   )*__s == 0) {
#line 1041
    tmp = (char *)((void *)0);
  } else {
#line 1041
    tmp = (char *)((size_t )__s);
  }
#line 1041
  return (tmp);
}
}
#line 1044
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1046 "/usr/include/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1051
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1051
    if ((int const   )*__s != 0) {
#line 1051
      if ((int const   )*__s != (int const   )__accept1) {
#line 1051
        if ((int const   )*__s != (int const   )__accept2) {
#line 1051
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1051
            goto while_break;
          }
        } else {
#line 1051
          goto while_break;
        }
      } else {
#line 1051
        goto while_break;
      }
    } else {
#line 1051
      goto while_break;
    }
#line 1053
    __s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  if ((int const   )*__s == 0) {
#line 1054
    tmp = (char *)((void *)0);
  } else {
#line 1054
    tmp = (char *)((size_t )__s);
  }
#line 1054
  return (tmp);
}
}
#line 1085
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1086 "/usr/include/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1090
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1091
    __s = *__nextp;
  }
  {
  {
#line 1092
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1092
    if (! ((int )*__s == (int )__sep)) {
#line 1092
      goto while_break;
    }
#line 1093
    __s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1094
  __result = (char *)((void *)0);
#line 1095
  if ((int )*__s != 0) {
#line 1097
    tmp = __s;
#line 1097
    __s ++;
#line 1097
    __result = tmp;
    {
    {
#line 1098
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1098
      if (! ((int )*__s != 0)) {
#line 1098
        goto while_break___0;
      }
#line 1099
      tmp___0 = __s;
#line 1099
      __s ++;
#line 1099
      if ((int )*tmp___0 == (int )__sep) {
#line 1101
        *(__s + -1) = (char )'\000';
#line 1102
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1104
    *__nextp = __s;
  }
#line 1106
  return (__result);
}
}
#line 1135
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1136 "/usr/include/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1139
  __retval = *__s;
#line 1140
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
    {
#line 1140
    tmp___2 = strchr((char const   *)__retval, (int )__reject);
    }
#line 1140
    tmp___0 = tmp___2;
#line 1140
    *__s = tmp___0;
    }
#line 1140
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1141
      tmp = *__s;
#line 1141
      (*__s) ++;
#line 1141
      *tmp = (char )'\000';
    }
  }
#line 1142
  return (__retval);
}
}
#line 1145
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1146 "/usr/include/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1149
  __retval = *__s;
#line 1150
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1152
    __cp = __retval;
    {
    {
#line 1153
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1155
      if ((int )*__cp == 0) {
#line 1157
        __cp = (char *)((void *)0);
#line 1158
        goto while_break;
      }
#line 1160
      if ((int )*__cp == (int )__reject1) {
#line 1162
        tmp = __cp;
#line 1162
        __cp ++;
#line 1162
        *tmp = (char )'\000';
#line 1163
        goto while_break;
      } else
#line 1160
      if ((int )*__cp == (int )__reject2) {
#line 1162
        tmp = __cp;
#line 1162
        __cp ++;
#line 1162
        *tmp = (char )'\000';
#line 1163
        goto while_break;
      }
#line 1165
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1167
    *__s = __cp;
  }
#line 1169
  return (__retval);
}
}
#line 1172
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1174 "/usr/include/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1177
  __retval = *__s;
#line 1178
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1180
    __cp = __retval;
    {
    {
#line 1181
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1183
      if ((int )*__cp == 0) {
#line 1185
        __cp = (char *)((void *)0);
#line 1186
        goto while_break;
      }
#line 1188
      if ((int )*__cp == (int )__reject1) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      } else
#line 1188
      if ((int )*__cp == (int )__reject2) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      } else
#line 1188
      if ((int )*__cp == (int )__reject3) {
#line 1190
        tmp = __cp;
#line 1190
        __cp ++;
#line 1190
        *tmp = (char )'\000';
#line 1191
        goto while_break;
      }
#line 1193
      __cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1195
    *__s = __cp;
  }
#line 1197
  return (__retval);
}
}
#line 70 "/usr/include/assert.h"
extern  __attribute__((__noreturn__)) void __assert_fail(char const   *__assertion ,
                                                         char const   *__file , unsigned int __line ,
                                                         char const   *__function ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline extern int tolower(int __c ) ;
#line 119
__inline extern int toupper(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
      {
#line 193
      tmp = __ctype_tolower_loc();
      }
#line 193
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 193
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 193
    tmp___0 = (__int32_t const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
      {
#line 199
      tmp = __ctype_toupper_loc();
      }
#line 199
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 199
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 199
    tmp___0 = (__int32_t const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 30 "xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 93 "xstrtol.c"
static int bkm_scale(uintmax_t *x , int scale_factor ) 
{ 
  uintmax_t product ;

  {
#line 96
  product = *x * (uintmax_t )scale_factor;
#line 97
  if (*x != product / (uintmax_t )scale_factor) {
#line 98
    return (1);
  }
#line 99
  *x = product;
#line 100
  return (0);
}
}
#line 103 "xstrtol.c"
static int bkm_scale_by_power(uintmax_t *x , int base , int power ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    tmp___0 = power;
#line 106
    power --;
#line 106
    if (! tmp___0) {
#line 106
      goto while_break;
    }
    {
    {
#line 107
    tmp = bkm_scale(x, base);
    }
    }
#line 107
    if (tmp) {
#line 108
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 115 "xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  char const   *q ;
  unsigned short const   **tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  int overflow ;
  char *tmp___6 ;
  char *tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 123
  if (0 <= strtol_base) {
#line 123
    if (strtol_base <= 36) {
#line 123
      tmp___0 = 1;
    } else {
#line 123
      tmp___0 = 0;
    }
  } else {
#line 123
    tmp___0 = 0;
  }
  {
  {
#line 123
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
  }
#line 123
  if (! tmp___1) {
    {
    {
#line 123
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 123U, "xstrtoumax");
    }
    }
  }
#line 125
  if (ptr) {
#line 125
    p = ptr;
  } else {
#line 125
    p = & t_ptr;
  }
#line 129
  q = s;
  {
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 130
    tmp___2 = __ctype_b_loc();
    }
    }
#line 130
    if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*q)) & 8192)) {
#line 130
      goto while_break;
    }
#line 131
    q ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if ((int const   )*q == 45) {
#line 133
    return ((strtol_error )1);
  }
  {
  {
#line 136
  tmp___3 = __errno_location();
  }
#line 136
  *tmp___3 = 0;
  {
#line 137
  tmp = strtoumax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
  {
#line 138
  tmp___4 = __errno_location();
  }
  }
#line 138
  if (*tmp___4 != 0) {
#line 139
    return ((strtol_error )3);
  }
#line 140
  if ((unsigned long )*p == (unsigned long )s) {
#line 141
    return ((strtol_error )1);
  }
#line 146
  if (! valid_suffixes) {
#line 148
    *val = tmp;
#line 149
    return ((strtol_error )0);
  }
#line 152
  if ((int )*(*p) != 0) {
    {
#line 154
    base = 1024;
#line 155
    suffixes = 1;
    {
#line 158
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
    }
#line 158
    if (! tmp___6) {
#line 160
      *val = tmp;
#line 161
      return ((strtol_error )2);
    }
    {
    {
#line 164
    tmp___8 = strchr(valid_suffixes, '0');
    }
    }
#line 164
    if (tmp___8) {
      {
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_66;
      }
#line 176
      if ((int )*(*(p + 0) + 1) == 68) {
#line 176
        goto case_68;
      }
#line 170
      goto switch_break;
      case_66: /* CIL Label */ 
#line 173
      suffixes ++;
#line 174
      goto switch_break;
      case_68: /* CIL Label */ 
#line 177
      base = 1000;
#line 178
      suffixes ++;
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 185
    if ((int )*(*p) == 98) {
#line 185
      goto case_98;
    }
#line 189
    if ((int )*(*p) == 66) {
#line 189
      goto case_66___0;
    }
#line 193
    if ((int )*(*p) == 99) {
#line 193
      goto case_99;
    }
#line 197
    if ((int )*(*p) == 69) {
#line 197
      goto case_69;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_71;
    }
#line 205
    if ((int )*(*p) == 107) {
#line 205
      goto case_107;
    }
#line 210
    if ((int )*(*p) == 109) {
#line 210
      goto case_109;
    }
#line 210
    if ((int )*(*p) == 77) {
#line 210
      goto case_109;
    }
#line 214
    if ((int )*(*p) == 80) {
#line 214
      goto case_80;
    }
#line 218
    if ((int )*(*p) == 84) {
#line 218
      goto case_84;
    }
#line 222
    if ((int )*(*p) == 119) {
#line 222
      goto case_119;
    }
#line 226
    if ((int )*(*p) == 89) {
#line 226
      goto case_89;
    }
#line 230
    if ((int )*(*p) == 90) {
#line 230
      goto case_90;
    }
#line 234
    goto switch_default;
    case_98: /* CIL Label */ 
    {
    {
#line 186
    overflow = bkm_scale(& tmp, 512);
    }
    }
#line 187
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
    {
#line 190
    overflow = bkm_scale(& tmp, 1024);
    }
    }
#line 191
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 194
    overflow = 0;
#line 195
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
    {
#line 198
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
    }
#line 199
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
    {
#line 202
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
    }
#line 203
    goto switch_break___0;
    case_107: /* CIL Label */ 
    {
    {
#line 206
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
    }
#line 207
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
    {
#line 211
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
    }
#line 212
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
    {
#line 215
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
    }
#line 216
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
    {
#line 219
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
    }
#line 220
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
    {
#line 223
    overflow = bkm_scale(& tmp, 2);
    }
    }
#line 224
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
    {
#line 227
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
    }
#line 228
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
    {
#line 231
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
    }
#line 232
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 235
    *val = tmp;
#line 236
    return ((strtol_error )2);
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    if (overflow) {
#line 241
      return ((strtol_error )3);
    }
#line 243
    *p += suffixes;
  }
#line 246
  *val = tmp;
#line 247
  return ((strtol_error )0);
}
}
#line 28 "xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 93 "xstrtol.c"
static int bkm_scale___0(long *x , int scale_factor ) 
{ 
  long product ;

  {
#line 96
  product = *x * (long )scale_factor;
#line 97
  if (*x != product / (long )scale_factor) {
#line 98
    return (1);
  }
#line 99
  *x = product;
#line 100
  return (0);
}
}
#line 103 "xstrtol.c"
static int bkm_scale_by_power___0(long *x , int base , int power ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    tmp___0 = power;
#line 106
    power --;
#line 106
    if (! tmp___0) {
#line 106
      goto while_break;
    }
    {
    {
#line 107
    tmp = bkm_scale___0(x, base);
    }
    }
#line 107
    if (tmp) {
#line 108
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 115 "xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  int overflow ;
  char *tmp___6 ;
  char *tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 123
  if (0 <= strtol_base) {
#line 123
    if (strtol_base <= 36) {
#line 123
      tmp___0 = 1;
    } else {
#line 123
      tmp___0 = 0;
    }
  } else {
#line 123
    tmp___0 = 0;
  }
  {
  {
#line 123
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  }
  }
#line 123
  if (! tmp___1) {
    {
    {
#line 123
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 123U, "xstrtol");
    }
    }
  }
#line 125
  if (ptr) {
#line 125
    p = ptr;
  } else {
#line 125
    p = & t_ptr;
  }
  {
  {
#line 136
  tmp___3 = __errno_location();
  }
#line 136
  *tmp___3 = 0;
  {
#line 137
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
  {
#line 138
  tmp___4 = __errno_location();
  }
  }
#line 138
  if (*tmp___4 != 0) {
#line 139
    return ((strtol_error )3);
  }
#line 140
  if ((unsigned long )*p == (unsigned long )s) {
#line 141
    return ((strtol_error )1);
  }
#line 146
  if (! valid_suffixes) {
#line 148
    *val = tmp;
#line 149
    return ((strtol_error )0);
  }
#line 152
  if ((int )*(*p) != 0) {
    {
#line 154
    base = 1024;
#line 155
    suffixes = 1;
    {
#line 158
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
    }
#line 158
    if (! tmp___6) {
#line 160
      *val = tmp;
#line 161
      return ((strtol_error )2);
    }
    {
    {
#line 164
    tmp___8 = strchr(valid_suffixes, '0');
    }
    }
#line 164
    if (tmp___8) {
      {
#line 172
      if ((int )*(*(p + 0) + 1) == 66) {
#line 172
        goto case_66;
      }
#line 176
      if ((int )*(*(p + 0) + 1) == 68) {
#line 176
        goto case_68;
      }
#line 170
      goto switch_break;
      case_66: /* CIL Label */ 
#line 173
      suffixes ++;
#line 174
      goto switch_break;
      case_68: /* CIL Label */ 
#line 177
      base = 1000;
#line 178
      suffixes ++;
#line 179
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 185
    if ((int )*(*p) == 98) {
#line 185
      goto case_98;
    }
#line 189
    if ((int )*(*p) == 66) {
#line 189
      goto case_66___0;
    }
#line 193
    if ((int )*(*p) == 99) {
#line 193
      goto case_99;
    }
#line 197
    if ((int )*(*p) == 69) {
#line 197
      goto case_69;
    }
#line 201
    if ((int )*(*p) == 71) {
#line 201
      goto case_71;
    }
#line 205
    if ((int )*(*p) == 107) {
#line 205
      goto case_107;
    }
#line 210
    if ((int )*(*p) == 109) {
#line 210
      goto case_109;
    }
#line 210
    if ((int )*(*p) == 77) {
#line 210
      goto case_109;
    }
#line 214
    if ((int )*(*p) == 80) {
#line 214
      goto case_80;
    }
#line 218
    if ((int )*(*p) == 84) {
#line 218
      goto case_84;
    }
#line 222
    if ((int )*(*p) == 119) {
#line 222
      goto case_119;
    }
#line 226
    if ((int )*(*p) == 89) {
#line 226
      goto case_89;
    }
#line 230
    if ((int )*(*p) == 90) {
#line 230
      goto case_90;
    }
#line 234
    goto switch_default;
    case_98: /* CIL Label */ 
    {
    {
#line 186
    overflow = bkm_scale___0(& tmp, 512);
    }
    }
#line 187
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
    {
#line 190
    overflow = bkm_scale___0(& tmp, 1024);
    }
    }
#line 191
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 194
    overflow = 0;
#line 195
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
    {
#line 198
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
    }
#line 199
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
    {
#line 202
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
    }
#line 203
    goto switch_break___0;
    case_107: /* CIL Label */ 
    {
    {
#line 206
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
    }
#line 207
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
    {
#line 211
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
    }
#line 212
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
    {
#line 215
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
    }
#line 216
    goto switch_break___0;
    case_84: /* CIL Label */ 
    {
    {
#line 219
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
    }
#line 220
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
    {
#line 223
    overflow = bkm_scale___0(& tmp, 2);
    }
    }
#line 224
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
    {
#line 227
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
    }
#line 228
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
    {
#line 231
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
    }
#line 232
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 235
    *val = tmp;
#line 236
    return ((strtol_error )2);
#line 237
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 240
    if (overflow) {
#line 241
      return ((strtol_error )3);
    }
#line 243
    *p += suffixes;
  }
#line 246
  *val = tmp;
#line 247
  return ((strtol_error )0);
}
}
#line 179 "/usr/include/stdlib.h"
__inline extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) ;
#line 274
extern long __strtol_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                              int __base , int __group ) ;
#line 280
extern unsigned long __strtoul_internal(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                        int __base , int __group ) ;
#line 313 "/usr/include/stdlib.h"
__inline extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ 
  long tmp ;

  {
  {
  {
#line 317
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 317
  return (tmp);
}
}
#line 319 "/usr/include/stdlib.h"
__inline extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 323
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 323
  return (tmp);
}
}
#line 556
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 558
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 567
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 51 "/usr/include/libintl.h"
extern char *dcgettext(char const   *__domainname , char const   *__msgid , int __category ) ;
#line 49 "error.h"
void ( /* format attribute */  error)(int status , int errnum , char const   *message 
                                      , ...) ;
#line 42 "xalloc.h"
int xalloc_exit_failure ;
#line 46
void (*xalloc_fail_func)(void) ;
#line 51
char const   xalloc_msg_memory_exhausted[17] ;
#line 57
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 59
void *xmalloc(size_t n ) ;
#line 60
void *xcalloc(size_t n , size_t s ) ;
#line 61
void *xrealloc(void *p , size_t n ) ;
#line 59 "xmalloc.c"
int xalloc_exit_failure  =    1;
#line 62 "xmalloc.c"
void (*xalloc_fail_func)(void)  =    (void (*)(void))0;
#line 66 "xmalloc.c"
char const   xalloc_msg_memory_exhausted[17]  = 
#line 66
  {      (char const   )'m',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'r',      (char const   )'y',      (char const   )' ',      (char const   )'e', 
        (char const   )'x',      (char const   )'h',      (char const   )'a',      (char const   )'u', 
        (char const   )'s',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )'\000'};
#line 68
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 68 "xmalloc.c"
void xalloc_die(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
#line 71
  if (xalloc_fail_func) {
    {
    {
#line 72
    (*xalloc_fail_func)();
    }
    }
  }
  {
  {
#line 73
  tmp = dcgettext((char const   *)((void *)0), xalloc_msg_memory_exhausted, 5);
  }
  {
#line 73
  error(xalloc_exit_failure, 0, "%s", tmp);
  }
  {
#line 77
  exit(1);
  }
  }
}
}
#line 82 "xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;

  {
  {
  {
#line 87
  p = malloc(n);
  }
  }
#line 88
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 89
    xalloc_die();
    }
    }
  }
#line 90
  return (p);
}
}
#line 96 "xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
  {
  {
#line 99
  p = realloc(p, n);
  }
  }
#line 100
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 101
    xalloc_die();
    }
    }
  }
#line 102
  return (p);
}
}
#line 107 "xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
  {
#line 112
  p = calloc(n, s);
  }
  }
#line 113
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
    {
#line 114
    xalloc_die();
    }
    }
  }
#line 115
  return (p);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 142
extern int closedir(DIR *__dirp ) ;
#line 158
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64")  ;
#line 569 "/usr/include/stdlib.h"
extern void free(void *__ptr ) ;
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 66 "savedir.c"
extern char *stpcpy() ;
#line 35 "exclude.h"
int excluded_filename(struct exclude  const  *ex , char const   *f , int options ) ;
#line 14 "savedir.h"
char *savedir(char const   *dir , off_t name_size , struct exclude *included_patterns___0 ,
              struct exclude *excluded_patterns___0 ) ;
#line 72 "savedir.c"
char *path  ;
#line 73 "savedir.c"
size_t pathlen  ;
#line 91
int isdir(char const   *path___0 ) ;
#line 75 "savedir.c"
static int isdir1(char const   *dir , char const   *file ) 
{ 
  int status ;
  int slash ;
  size_t dirlen ;
  size_t tmp ;
  size_t filelen ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
  {
#line 80
  tmp = strlen(dir);
  }
#line 80
  dirlen = tmp;
  {
#line 81
  tmp___0 = strlen(file);
  }
#line 81
  filelen = tmp___0;
  }
#line 82
  if ((dirlen + filelen) + 2U > pathlen) {
    {
    {
#line 84
    tmp___1 = calloc(((dirlen + 1U) + filelen) + 1U, (size_t )sizeof(*path));
    }
#line 84
    path = (char *)tmp___1;
#line 85
    pathlen = (dirlen + filelen) + 2U;
    }
  }
  {
  {
#line 87
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)dir);
  }
#line 88
  slash = (int )*(path + dirlen) != 47;
#line 89
  *(path + dirlen) = (char )'/';
  {
#line 90
  strcpy((char */* __restrict  */)((path + dirlen) + slash), (char const   */* __restrict  */)file);
  }
  {
#line 91
  status = isdir(path);
  }
  }
#line 92
  return (status);
}
}
#line 101 "savedir.c"
char *savedir(char const   *dir , off_t name_size , struct exclude *included_patterns___0 ,
              struct exclude *excluded_patterns___0 ) 
{ 
  DIR *dirp ;
  struct dirent *dp ;
  char *name_space ;
  char *namep ;
  void *tmp ;
  off_t size_needed ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *new_name_space ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
  {
#line 110
  dirp = opendir(dir);
  }
  }
#line 111
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 112
    return ((char *)((void *)0));
  }
#line 116
  if (name_size <= 0LL) {
#line 117
    name_size = (off_t )1;
  }
  {
  {
#line 119
  tmp = malloc((size_t )name_size);
  }
#line 119
  name_space = (char *)tmp;
  }
#line 120
  if ((unsigned long )name_space == (unsigned long )((void *)0)) {
    {
    {
#line 122
    closedir(dirp);
    }
    }
#line 123
    return ((char *)((void *)0));
  }
#line 125
  namep = name_space;
  {
  {
#line 127
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 127
    dp = readdir(dirp);
    }
    }
#line 127
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 127
      goto while_break;
    }
#line 130
    if ((int )dp->d_name[0] != 46) {
#line 130
      goto _L___1;
    } else
#line 130
    if ((int )dp->d_name[1] != 0) {
#line 130
      if ((int )dp->d_name[1] != 46) {
#line 130
        goto _L___1;
      } else
#line 130
      if ((int )dp->d_name[2] != 0) {
        _L___1: /* CIL Label */ 
        {
        {
#line 134
        tmp___0 = strlen((char const   *)(dp->d_name));
        }
#line 134
        size_needed = (off_t )(((namep - name_space) + (long )tmp___0) + 2L);
        }
#line 136
        if (included_patterns___0) {
#line 136
          goto _L;
        } else
#line 136
        if (excluded_patterns___0) {
          _L: /* CIL Label */ 
          {
          {
#line 136
          tmp___3 = isdir1(dir, (char const   *)(dp->d_name));
          }
          }
#line 136
          if (! tmp___3) {
#line 139
            if (included_patterns___0) {
              {
              {
#line 139
              tmp___1 = excluded_filename((struct exclude  const  *)included_patterns___0,
                                          (char const   *)(dp->d_name), 0);
              }
              }
#line 139
              if (! tmp___1) {
#line 141
                goto while_continue;
              }
            }
#line 142
            if (excluded_patterns___0) {
              {
              {
#line 142
              tmp___2 = excluded_filename((struct exclude  const  *)excluded_patterns___0,
                                          (char const   *)(dp->d_name), 0);
              }
              }
#line 142
              if (tmp___2) {
#line 144
                goto while_continue;
              }
            }
          }
        }
#line 147
        if (size_needed > name_size) {
          {
          {
#line 151
          while (1) {
            while_continue___2: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
#line 151
            if (! (size_needed > name_size)) {
#line 151
              goto while_break___0;
            }
#line 152
            name_size += 1024LL;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
          {
#line 154
          tmp___4 = realloc((void *)name_space, (size_t )name_size);
          }
#line 154
          new_name_space = (char *)tmp___4;
          }
#line 155
          if ((unsigned long )new_name_space == (unsigned long )((void *)0)) {
            {
            {
#line 157
            closedir(dirp);
            }
            }
#line 158
            return ((char *)((void *)0));
          }
#line 160
          namep += new_name_space - name_space;
#line 161
          name_space = new_name_space;
        }
        {
        {
#line 163
        tmp___5 = stpcpy(namep, dp->d_name);
        }
#line 163
        namep = tmp___5 + 1;
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 166
  *namep = (char )'\000';
  {
#line 167
  tmp___6 = closedir(dirp);
  }
  }
#line 167
  if (tmp___6) {
    {
    {
#line 169
    free((void *)name_space);
    }
    }
#line 170
    return ((char *)((void *)0));
  }
#line 172
  if (path) {
    {
    {
#line 174
    free((void *)path);
    }
#line 175
    path = (char *)((void *)0);
#line 176
    pathlen = (size_t )0;
    }
  }
#line 178
  return (name_space);
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 38 "quotearg.h"
char const   * const  quoting_style_args[8] ;
#line 39
enum quoting_style  const  quoting_style_vals[7] ;
#line 57
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 61
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 65
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 73
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 83
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 92
char *quotearg_n(unsigned int n , char const   *arg ) ;
#line 95
char *quotearg(char const   *arg ) ;
#line 100
char *quotearg_n_style(unsigned int n , enum quoting_style s , char const   *arg ) ;
#line 104
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 107
char *quotearg_char(char const   *arg , char ch ) ;
#line 110
char *quotearg_colon(char const   *arg ) ;
#line 137 "/usr/include/stdlib.h"
extern size_t __ctype_get_mb_cur_max(void) ;
#line 594
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 61 "/usr/include/string.h"
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 302 "/usr/include/wchar.h"
extern int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 306
extern size_t mbrtowc(wchar_t * __restrict  __pwc , char const   * __restrict  __s ,
                      size_t __n , mbstate_t *__p ) ;
#line 315
extern size_t __mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) ;
#line 317
__inline extern size_t mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) ;
#line 323 "/usr/include/wchar.h"
__inline extern size_t mbrlen(char const   * __restrict  __s , size_t __n , mbstate_t * __restrict  __ps ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 325
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    {
    {
#line 325
    tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), __s, __n, (mbstate_t *)__ps);
    }
#line 325
    tmp___1 = tmp;
    }
  } else {
    {
    {
#line 325
    tmp___0 = __mbrlen(__s, __n, (mbstate_t */* __restrict  */)((void *)0));
    }
#line 325
    tmp___1 = tmp___0;
    }
  }
#line 325
  return (tmp___1);
}
}
#line 374
__inline extern double wcstod(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) ;
#line 388
__inline extern long wcstol(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                            int __base ) ;
#line 393
__inline extern unsigned long wcstoul(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                      int __base ) ;
#line 483
extern double __wcstod_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                int __group ) ;
#line 494
extern long __wcstol_internal(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                              int __base , int __group ) ;
#line 500
extern unsigned long __wcstoul_internal(wchar_t const   * __restrict  __npt , wchar_t ** __restrict  __endptr ,
                                        int __base , int __group ) ;
#line 528 "/usr/include/wchar.h"
__inline extern double wcstod(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ) 
{ 
  double tmp ;

  {
  {
  {
#line 530
  tmp = __wcstod_internal(__nptr, __endptr, 0);
  }
  }
#line 530
  return (tmp);
}
}
#line 531 "/usr/include/wchar.h"
__inline extern long wcstol(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                            int __base ) 
{ 
  long tmp ;

  {
  {
  {
#line 534
  tmp = __wcstol_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 534
  return (tmp);
}
}
#line 535 "/usr/include/wchar.h"
__inline extern unsigned long wcstoul(wchar_t const   * __restrict  __nptr , wchar_t ** __restrict  __endptr ,
                                      int __base ) 
{ 
  unsigned long tmp ;

  {
  {
  {
#line 538
  tmp = __wcstoul_internal(__nptr, __endptr, __base, 0);
  }
  }
#line 538
  return (tmp);
}
}
#line 112 "quotearg.c"
char const   * const  quoting_style_args[8]  = 
#line 112 "quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",      (char const   */* const  */)0};
#line 125 "quotearg.c"
enum quoting_style  const  quoting_style_vals[7]  = {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6};
#line 137 "quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 142 "quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  struct quoting_options *p ;
  void *tmp ;
  struct quoting_options *tmp___0 ;

  {
  {
  {
#line 145
  tmp = xmalloc((size_t )sizeof(struct quoting_options ));
  }
#line 145
  p = (struct quoting_options *)tmp;
  }
#line 147
  if (o) {
#line 147
    tmp___0 = o;
  } else {
#line 147
    tmp___0 = & default_quoting_options;
  }
#line 147
  *p = *tmp___0;
#line 148
  return (p);
}
}
#line 152 "quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 155
  if (o) {
#line 155
    tmp = o;
  } else {
#line 155
    tmp = & default_quoting_options;
  }
#line 155
  return (tmp->style);
}
}
#line 160 "quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 163
  if (o) {
#line 163
    tmp = o;
  } else {
#line 163
    tmp = & default_quoting_options;
  }
#line 163
  tmp->style = s;
#line 164
  return;
}
}
#line 171 "quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 174
  uc = (unsigned char )c;
#line 175
  if (o) {
#line 175
    tmp = o;
  } else {
#line 175
    tmp = & default_quoting_options;
  }
#line 175
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 176
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 177
  r = (*p >> shift) & 1;
#line 178
  *p ^= ((i & 1) ^ r) << shift;
#line 179
  return (r);
}
}
#line 184 "quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = dcgettext((char const   *)((void *)0), msgid, 5);
  }
#line 187
  translation = (char const   *)tmp;
  }
#line 188
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 188
    if ((unsigned int )s == 6U) {
#line 189
      translation = "\"";
    }
  }
#line 190
  return (translation);
}
}
#line 206 "quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       struct quoting_options  const  *o ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  int backslash_escapes ;
  int unibyte_locale ;
  size_t tmp ;
  char const   *left ;
  char const   *tmp___0 ;
  char const   *right ;
  char const   *tmp___1 ;
  unsigned char c ;
  unsigned char esc ;
  int tmp___2 ;
  size_t m ;
  int printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_15 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 213
  len = (size_t )0;
#line 214
  quote_string = (char const   *)0;
#line 215
  quote_string_len = (size_t )0;
#line 216
  backslash_escapes = 0;
  {
#line 217
  tmp = __ctype_get_mb_cur_max();
  }
#line 217
  unibyte_locale = tmp == 1U;
  }
  {
#line 230
  if ((unsigned int )quoting_style == 3U) {
#line 230
    goto case_3;
  }
#line 237
  if ((unsigned int )quoting_style == 4U) {
#line 237
    goto case_4;
  }
#line 242
  if ((unsigned int )quoting_style == 6U) {
#line 242
    goto case_6;
  }
#line 242
  if ((unsigned int )quoting_style == 5U) {
#line 242
    goto case_6;
  }
#line 269
  if ((unsigned int )quoting_style == 2U) {
#line 269
    goto case_2;
  }
#line 275
  goto switch_default;
  case_3: /* CIL Label */ 
  {
  {
#line 231
  while (1) {
    while_continue___22: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 231
    if (len < buffersize) {
#line 231
      *(buffer___0 + len) = (char )'\"';
    }
#line 231
    len ++;
#line 231
    goto while_break;
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  backslash_escapes = 1;
#line 233
  quote_string = "\"";
#line 234
  quote_string_len = (size_t )1;
#line 235
  goto switch_break;
  case_4: /* CIL Label */ 
#line 238
  backslash_escapes = 1;
#line 239
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
  {
#line 259
  tmp___0 = gettext_quote("`", quoting_style);
  }
#line 259
  left = tmp___0;
  {
#line 260
  tmp___1 = gettext_quote("\'", quoting_style);
  }
#line 260
  right = tmp___1;
#line 261
  quote_string = left;
  }
  {
  {
#line 261
  while (1) {
    while_continue___23: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 261
    if (! *quote_string) {
#line 261
      goto while_break___0;
    }
    {
    {
#line 262
    while (1) {
      while_continue___24: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 262
      if (len < buffersize) {
#line 262
        *(buffer___0 + len) = (char )*quote_string;
      }
#line 262
      len ++;
#line 262
      goto while_break___1;
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 261
    quote_string ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 263
  backslash_escapes = 1;
#line 264
  quote_string = right;
  {
#line 265
  quote_string_len = strlen(quote_string);
  }
  }
#line 267
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 270
  while (1) {
    while_continue___25: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 270
    if (len < buffersize) {
#line 270
      *(buffer___0 + len) = (char )'\'';
    }
#line 270
    len ++;
#line 270
    goto while_break___2;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 271
  quote_string = "\'";
#line 272
  quote_string_len = (size_t )1;
#line 273
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 279
  i = (size_t )0;
  {
  {
#line 279
  while (1) {
    while_continue___26: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 279
    if (argsize == 4294967295U) {
#line 279
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 279
      tmp___6 = i == argsize;
    }
#line 279
    if (tmp___6) {
#line 279
      goto while_break___3;
    }
#line 284
    if (backslash_escapes) {
#line 284
      if (quote_string_len) {
#line 284
        if (i + quote_string_len <= argsize) {
          {
          {
#line 284
          tmp___2 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
          }
          }
#line 284
          if (tmp___2 == 0) {
            {
            {
#line 288
            while (1) {
              while_continue___27: /* CIL Label */ ;
              while_continue___4: /* CIL Label */ ;
#line 288
              if (len < buffersize) {
#line 288
                *(buffer___0 + len) = (char )'\\';
              }
#line 288
              len ++;
#line 288
              goto while_break___4;
            }
            while_break___27: /* CIL Label */ ;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 290
    c = (unsigned char )*(arg + i);
    {
#line 293
    if ((int )c == 63) {
#line 293
      goto case_63;
    }
#line 322
    if ((int )c == 7) {
#line 322
      goto case_7;
    }
#line 323
    if ((int )c == 8) {
#line 323
      goto case_8;
    }
#line 324
    if ((int )c == 12) {
#line 324
      goto case_12;
    }
#line 325
    if ((int )c == 10) {
#line 325
      goto case_10;
    }
#line 326
    if ((int )c == 13) {
#line 326
      goto case_13;
    }
#line 327
    if ((int )c == 9) {
#line 327
      goto case_9;
    }
#line 328
    if ((int )c == 11) {
#line 328
      goto case_11;
    }
#line 329
    if ((int )c == 92) {
#line 329
      goto case_92;
    }
#line 342
    if ((int )c == 126) {
#line 342
      goto case_126;
    }
#line 342
    if ((int )c == 35) {
#line 342
      goto case_126;
    }
#line 352
    if ((int )c == 124) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 96) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 94) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 91) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 62) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 60) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 59) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 42) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 41) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 40) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 38) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 36) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 34) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 33) {
#line 352
      goto case_124;
    }
#line 352
    if ((int )c == 32) {
#line 352
      goto case_124;
    }
#line 361
    if ((int )c == 39) {
#line 361
      goto case_39___0;
    }
#line 390
    if ((int )c == 125) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 123) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 122) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 121) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 120) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 119) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 118) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 117) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 116) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 115) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 114) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 113) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 112) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 111) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 110) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 109) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 108) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 107) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 106) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 105) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 104) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 103) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 102) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 101) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 100) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 99) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 98) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 97) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 95) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 93) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 90) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 89) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 88) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 87) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 86) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 85) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 84) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 83) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 82) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 81) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 80) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 79) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 78) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 77) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 76) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 75) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 74) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 73) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 72) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 71) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 70) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 69) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 68) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 67) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 66) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 65) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 61) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 58) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 57) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 56) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 55) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 54) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 53) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 52) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 51) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 50) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 49) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 48) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 47) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 46) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 45) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 44) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 43) {
#line 390
      goto case_125;
    }
#line 390
    if ((int )c == 37) {
#line 390
      goto case_125;
    }
#line 395
    goto switch_default___2;
    case_63: /* CIL Label */ 
    {
#line 296
    if ((unsigned int )quoting_style == 1U) {
#line 296
      goto case_1;
    }
#line 299
    if ((unsigned int )quoting_style == 3U) {
#line 299
      goto case_3___0;
    }
#line 317
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 297
    goto use_shell_always_quoting_style;
    case_3___0: /* CIL Label */ 
#line 300
    if (i + 2U < argsize) {
#line 300
      if ((int const   )*(arg + (i + 1U)) == 63) {
        {
#line 305
        if ((int const   )*(arg + (i + 2U)) == 62) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 61) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 60) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 47) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 45) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 41) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 40) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 39) {
#line 305
          goto case_62;
        }
#line 305
        if ((int const   )*(arg + (i + 2U)) == 33) {
#line 305
          goto case_62;
        }
#line 301
        goto switch_break___2;
        case_62: /* CIL Label */ 
        case_61: /* CIL Label */ 
        case_60: /* CIL Label */ 
        case_47: /* CIL Label */ 
        case_45: /* CIL Label */ 
        case_41: /* CIL Label */ 
        case_40: /* CIL Label */ 
        case_39: /* CIL Label */ 
        case_33: /* CIL Label */ 
#line 308
        i += 2U;
#line 309
        c = (unsigned char )*(arg + (i + 2U));
        {
        {
#line 310
        while (1) {
          while_continue___28: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 310
          if (len < buffersize) {
#line 310
            *(buffer___0 + len) = (char )'?';
          }
#line 310
          len ++;
#line 310
          goto while_break___5;
        }
        while_break___28: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
        {
#line 311
        while (1) {
          while_continue___29: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 311
          if (len < buffersize) {
#line 311
            *(buffer___0 + len) = (char )'\\';
          }
#line 311
          len ++;
#line 311
          goto while_break___6;
        }
        while_break___29: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
        {
#line 312
        while (1) {
          while_continue___30: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 312
          if (len < buffersize) {
#line 312
            *(buffer___0 + len) = (char )'?';
          }
#line 312
          len ++;
#line 312
          goto while_break___7;
        }
        while_break___30: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 313
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      }
    }
#line 315
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 318
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 320
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 322
    esc = (unsigned char )'a';
#line 322
    goto c_escape;
    case_8: /* CIL Label */ 
#line 323
    esc = (unsigned char )'b';
#line 323
    goto c_escape;
    case_12: /* CIL Label */ 
#line 324
    esc = (unsigned char )'f';
#line 324
    goto c_escape;
    case_10: /* CIL Label */ 
#line 325
    esc = (unsigned char )'n';
#line 325
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 326
    esc = (unsigned char )'r';
#line 326
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 327
    esc = (unsigned char )'t';
#line 327
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 328
    esc = (unsigned char )'v';
#line 328
    goto c_escape;
    case_92: /* CIL Label */ 
#line 329
    esc = c;
#line 329
    goto c_and_shell_escape;
    c_and_shell_escape: 
#line 332
    if ((unsigned int )quoting_style == 1U) {
#line 333
      goto use_shell_always_quoting_style;
    }
    c_escape: 
#line 335
    if (backslash_escapes) {
#line 337
      c = esc;
#line 338
      goto store_escape;
    }
#line 340
    goto switch_break___0;
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 343
    if (i != 0U) {
#line 344
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 357
    if ((unsigned int )quoting_style == 1U) {
#line 358
      goto use_shell_always_quoting_style;
    }
#line 359
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    {
#line 364
    if ((unsigned int )quoting_style == 1U) {
#line 364
      goto case_1___0;
    }
#line 367
    if ((unsigned int )quoting_style == 2U) {
#line 367
      goto case_2___0;
    }
#line 373
    goto switch_default___1;
    case_1___0: /* CIL Label */ 
#line 365
    goto use_shell_always_quoting_style;
    case_2___0: /* CIL Label */ 
    {
    {
#line 368
    while (1) {
      while_continue___31: /* CIL Label */ ;
      while_continue___8: /* CIL Label */ ;
#line 368
      if (len < buffersize) {
#line 368
        *(buffer___0 + len) = (char )'\'';
      }
#line 368
      len ++;
#line 368
      goto while_break___8;
    }
    while_break___31: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
    {
#line 369
    while (1) {
      while_continue___32: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 369
      if (len < buffersize) {
#line 369
        *(buffer___0 + len) = (char )'\\';
      }
#line 369
      len ++;
#line 369
      goto while_break___9;
    }
    while_break___32: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
    {
#line 370
    while (1) {
      while_continue___33: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 370
      if (len < buffersize) {
#line 370
        *(buffer___0 + len) = (char )'\'';
      }
#line 370
      len ++;
#line 370
      goto while_break___10;
    }
    while_break___33: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 371
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
#line 374
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 376
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 393
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 407
    if (unibyte_locale) {
      {
#line 409
      m = (size_t )1;
      {
#line 410
      tmp___3 = __ctype_b_loc();
      }
#line 410
      printable = ((int const   )*(*tmp___3 + (int )c) & 16384) != (int const   )0;
      }
    } else {
#line 415
      if (sizeof(mbstate) <= 16UL) {
#line 415
        if (sizeof(mbstate) == 1UL) {
#line 415
          __s___1 = (void *)(& mbstate);
#line 415
          *((__uint8_t *)__s___1) = (__uint8_t )0;
        } else {
#line 415
          __s___0 = (void *)(& mbstate);
#line 415
          __u = (union __anonunion___u_15 *)__s___0;
#line 415
          __c = (__uint8_t )0;
          {
#line 415
          if ((unsigned int )sizeof(mbstate) == 15U) {
#line 415
            goto case_15;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 11U) {
#line 415
            goto case_11___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 7U) {
#line 415
            goto case_7___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 3U) {
#line 415
            goto case_3___1;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 14U) {
#line 415
            goto case_14;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 10U) {
#line 415
            goto case_10___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 6U) {
#line 415
            goto case_6___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 2U) {
#line 415
            goto case_2___1;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 13U) {
#line 415
            goto case_13___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 9U) {
#line 415
            goto case_9___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 5U) {
#line 415
            goto case_5___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 1U) {
#line 415
            goto case_1___1;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 16U) {
#line 415
            goto case_16;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 12U) {
#line 415
            goto case_12___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 8U) {
#line 415
            goto case_8___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 4U) {
#line 415
            goto case_4___0;
          }
#line 415
          if ((unsigned int )sizeof(mbstate) == 0U) {
#line 415
            goto case_0;
          }
#line 415
          goto switch_break___4;
          case_15: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_11___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_7___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_3___1: /* CIL Label */ 
#line 415
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 2);
#line 415
          __u->__uc = __c;
#line 415
          goto switch_break___4;
          case_14: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_10___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_6___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_2___1: /* CIL Label */ 
#line 415
          __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 415
          goto switch_break___4;
          case_13___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_9___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_5___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_1___1: /* CIL Label */ 
#line 415
          __u->__uc = __c;
#line 415
          goto switch_break___4;
          case_16: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_12___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_8___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
#line 415
          __u = (union __anonunion___u_15 *)((void *)__u + 4);
          case_4___0: /* CIL Label */ 
#line 415
          __u->__ui = (unsigned int )((int )__c * 16843009);
          case_0: /* CIL Label */ 
#line 415
          goto switch_break___4;
          switch_break___4: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 415
        __s = (void *)(& mbstate);
        {
#line 415
        __builtin_memset(__s, '\000', (int )sizeof(mbstate));
        }
        }
      }
#line 417
      m = (size_t )0;
#line 418
      printable = 1;
#line 419
      if (argsize == 4294967295U) {
        {
        {
#line 420
        argsize = strlen(arg);
        }
        }
      }
      {
      {
#line 422
      while (1) {
        while_continue___34: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
        {
        {
#line 425
        tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg + (i + m)),
                          argsize - (i + m), & mbstate);
        }
#line 425
        bytes = tmp___4;
        }
#line 427
        if (bytes == 0U) {
#line 428
          goto while_break___11;
        } else
#line 429
        if (bytes == 4294967295U) {
#line 431
          printable = 0;
#line 432
          goto while_break___11;
        } else
#line 434
        if (bytes == 4294967294U) {
#line 436
          printable = 0;
          {
          {
#line 437
          while (1) {
            while_continue___35: /* CIL Label */ ;
            while_continue___12: /* CIL Label */ ;
#line 437
            if (i + m < argsize) {
#line 437
              if (! *(arg + (i + m))) {
#line 437
                goto while_break___12;
              }
            } else {
#line 437
              goto while_break___12;
            }
#line 438
            m ++;
          }
          while_break___35: /* CIL Label */ ;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 439
          goto while_break___11;
        } else {
#line 445
          m += bytes;
        }
        {
        {
#line 422
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
        }
        }
#line 422
        if (tmp___5) {
#line 422
          goto while_break___11;
        }
      }
      while_break___34: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
#line 451
    if (1U < m) {
#line 451
      goto _L;
    } else
#line 451
    if (backslash_escapes) {
#line 451
      if (! printable) {
        _L: /* CIL Label */ 
#line 455
        ilim = i + m;
        {
        {
#line 457
        while (1) {
          while_continue___36: /* CIL Label */ ;
          while_continue___13: /* CIL Label */ ;
#line 459
          if (backslash_escapes) {
#line 459
            if (! printable) {
              {
              {
#line 461
              while (1) {
                while_continue___37: /* CIL Label */ ;
                while_continue___14: /* CIL Label */ ;
#line 461
                if (len < buffersize) {
#line 461
                  *(buffer___0 + len) = (char )'\\';
                }
#line 461
                len ++;
#line 461
                goto while_break___14;
              }
              while_break___37: /* CIL Label */ ;
              }
              while_break___14: /* CIL Label */ ;
              }
              {
              {
#line 462
              while (1) {
                while_continue___38: /* CIL Label */ ;
                while_continue___15: /* CIL Label */ ;
#line 462
                if (len < buffersize) {
#line 462
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 462
                len ++;
#line 462
                goto while_break___15;
              }
              while_break___38: /* CIL Label */ ;
              }
              while_break___15: /* CIL Label */ ;
              }
              {
              {
#line 463
              while (1) {
                while_continue___39: /* CIL Label */ ;
                while_continue___16: /* CIL Label */ ;
#line 463
                if (len < buffersize) {
#line 463
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 463
                len ++;
#line 463
                goto while_break___16;
              }
              while_break___39: /* CIL Label */ ;
              }
              while_break___16: /* CIL Label */ ;
              }
#line 464
              c = (unsigned char )(48 + ((int )c & 7));
            }
          }
#line 466
          if (ilim <= i + 1U) {
#line 467
            goto while_break___13;
          }
          {
          {
#line 468
          while (1) {
            while_continue___40: /* CIL Label */ ;
            while_continue___17: /* CIL Label */ ;
#line 468
            if (len < buffersize) {
#line 468
              *(buffer___0 + len) = (char )c;
            }
#line 468
            len ++;
#line 468
            goto while_break___17;
          }
          while_break___40: /* CIL Label */ ;
          }
          while_break___17: /* CIL Label */ ;
          }
#line 469
          i ++;
#line 469
          c = (unsigned char )*(arg + i);
        }
        while_break___36: /* CIL Label */ ;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 472
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 477
    if (backslash_escapes) {
#line 477
      if (! (o->quote_these_too[(unsigned long )c / (sizeof(int ) * 8UL)] & (1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 479
        goto store_c;
      }
    } else {
#line 479
      goto store_c;
    }
    store_escape: 
    {
    {
#line 482
    while (1) {
      while_continue___41: /* CIL Label */ ;
      while_continue___18: /* CIL Label */ ;
#line 482
      if (len < buffersize) {
#line 482
        *(buffer___0 + len) = (char )'\\';
      }
#line 482
      len ++;
#line 482
      goto while_break___18;
    }
    while_break___41: /* CIL Label */ ;
    }
    while_break___18: /* CIL Label */ ;
    }
    store_c: 
    {
    {
#line 485
    while (1) {
      while_continue___42: /* CIL Label */ ;
      while_continue___19: /* CIL Label */ ;
#line 485
      if (len < buffersize) {
#line 485
        *(buffer___0 + len) = (char )c;
      }
#line 485
      len ++;
#line 485
      goto while_break___19;
    }
    while_break___42: /* CIL Label */ ;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 279
    i ++;
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 488
  if (quote_string) {
    {
    {
#line 489
    while (1) {
      while_continue___43: /* CIL Label */ ;
      while_continue___20: /* CIL Label */ ;
#line 489
      if (! *quote_string) {
#line 489
        goto while_break___20;
      }
      {
      {
#line 490
      while (1) {
        while_continue___44: /* CIL Label */ ;
        while_continue___21: /* CIL Label */ ;
#line 490
        if (len < buffersize) {
#line 490
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 490
        len ++;
#line 490
        goto while_break___21;
      }
      while_break___44: /* CIL Label */ ;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 489
      quote_string ++;
    }
    while_break___43: /* CIL Label */ ;
    }
    while_break___20: /* CIL Label */ ;
    }
  }
#line 492
  if (len < buffersize) {
#line 493
    *(buffer___0 + len) = (char )'\000';
  }
#line 494
  return (len);
  use_shell_always_quoting_style: 
  {
  {
#line 497
  tmp___7 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )2,
                                     o);
  }
  }
#line 497
  return (tmp___7);
}
}
#line 509 "quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  size_t tmp___0 ;

  {
#line 514
  if (o) {
#line 514
    tmp = o;
  } else {
#line 514
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 514
  p = tmp;
  {
#line 515
  tmp___0 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     p);
  }
  }
#line 515
  return (tmp___0);
}
}
#line 531 "quotearg.c"
static char slot0[256]  ;
#line 532
static char *quotearg_n_options(int n , char const   *arg , struct quoting_options  const  *options ) ;
#line 532 "quotearg.c"
static unsigned int nslots  =    1U;
#line 538 "quotearg.c"
static struct slotvec slotvec0  =    {(size_t )sizeof(slot0), slot0};
#line 539 "quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 525 "quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , struct quoting_options  const  *options ) 
{ 
  int n1 ;
  size_t s ;
  void *tmp ;
  void *tmp___0 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_16 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  size_t size ;
  char *val ;
  size_t qsize ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 541
  if (nslots <= (unsigned int )n) {
#line 543
    n1 = n + 1;
#line 544
    s = (size_t )((unsigned long )n1 * sizeof(struct slotvec ));
#line 545
    if (0 < n1) {
#line 545
      if (! ((unsigned long )n1 == (unsigned long )s / sizeof(struct slotvec ))) {
        {
        {
#line 546
        abort();
        }
        }
      }
    } else {
      {
      {
#line 546
      abort();
      }
      }
    }
#line 547
    if ((unsigned long )slotvec == (unsigned long )(& slotvec0)) {
      {
      {
#line 549
      tmp = xmalloc((size_t )sizeof(struct slotvec ));
      }
#line 549
      slotvec = (struct slotvec *)tmp;
#line 550
      *slotvec = slotvec0;
      }
    }
    {
    {
#line 552
    tmp___0 = xrealloc((void *)slotvec, s);
    }
#line 552
    slotvec = (struct slotvec *)tmp___0;
    }
#line 553
    if (0) {
#line 553
      if ((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec ) == 1UL) {
#line 553
        __s___1 = (void *)(slotvec + nslots);
#line 553
        *((__uint8_t *)__s___1) = (__uint8_t )0;
      } else {
#line 553
        __s___0 = (void *)(slotvec + nslots);
#line 553
        __u = (union __anonunion___u_16 *)__s___0;
#line 553
        __c = (__uint8_t )0;
        {
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 15U) {
#line 553
          goto case_15;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 11U) {
#line 553
          goto case_11;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 7U) {
#line 553
          goto case_7;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 3U) {
#line 553
          goto case_3;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 14U) {
#line 553
          goto case_14;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 10U) {
#line 553
          goto case_10;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 6U) {
#line 553
          goto case_6;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 2U) {
#line 553
          goto case_2;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 13U) {
#line 553
          goto case_13;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 9U) {
#line 553
          goto case_9;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 5U) {
#line 553
          goto case_5;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 1U) {
#line 553
          goto case_1;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 16U) {
#line 553
          goto case_16;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 12U) {
#line 553
          goto case_12;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 8U) {
#line 553
          goto case_8;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 4U) {
#line 553
          goto case_4;
        }
#line 553
        if ((unsigned int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )) == 0U) {
#line 553
          goto case_0;
        }
#line 553
        goto switch_break;
        case_15: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 553
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 2);
#line 553
        __u->__uc = __c;
#line 553
        goto switch_break;
        case_14: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 553
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 553
        goto switch_break;
        case_13: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 553
        __u->__uc = __c;
#line 553
        goto switch_break;
        case_16: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 553
        __u = (union __anonunion___u_16 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 553
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 553
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 553
      __s = (void *)(slotvec + nslots);
      {
#line 553
      __builtin_memset(__s, '\000', (int )((unsigned long )((unsigned int )n1 - nslots) * sizeof(struct slotvec )));
      }
      }
    }
#line 554
    nslots = (unsigned int )n;
  }
  {
#line 558
  size = (slotvec + n)->size;
#line 559
  val = (slotvec + n)->val;
  {
#line 560
  tmp___1 = quotearg_buffer(val, size, arg, (size_t )-1, options);
  }
#line 560
  qsize = tmp___1;
  }
#line 562
  if (size <= qsize) {
#line 564
    size = qsize + 1U;
#line 564
    (slotvec + n)->size = size;
#line 565
    if ((unsigned long )val == (unsigned long )(slot0)) {
#line 565
      tmp___2 = (char *)0;
    } else {
#line 565
      tmp___2 = val;
    }
    {
    {
#line 565
    tmp___3 = xrealloc((void *)tmp___2, size);
    }
#line 565
    val = (char *)tmp___3;
#line 565
    (slotvec + n)->val = val;
    {
#line 566
    quotearg_buffer(val, size, arg, (size_t )-1, options);
    }
    }
  }
#line 569
  return (val);
}
}
#line 573 "quotearg.c"
char *quotearg_n(unsigned int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
  {
#line 576
  tmp = quotearg_n_options((int )n, arg, (struct quoting_options  const  *)(& default_quoting_options));
  }
  }
#line 576
  return (tmp);
}
}
#line 579 "quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
  {
#line 582
  tmp = quotearg_n(0U, arg);
  }
  }
#line 582
  return (tmp);
}
}
#line 585 "quotearg.c"
char *quotearg_n_style(unsigned int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_17 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  char *tmp ;

  {
#line 589
  o.style = s;
#line 590
  if (sizeof(o.quote_these_too) <= 16UL) {
#line 590
    if (sizeof(o.quote_these_too) == 1UL) {
#line 590
      __s___1 = (void *)(o.quote_these_too);
#line 590
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 590
      __s___0 = (void *)(o.quote_these_too);
#line 590
      __u = (union __anonunion___u_17 *)__s___0;
#line 590
      __c = (__uint8_t )0;
      {
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 15U) {
#line 590
        goto case_15;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 11U) {
#line 590
        goto case_11;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 7U) {
#line 590
        goto case_7;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 3U) {
#line 590
        goto case_3;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 14U) {
#line 590
        goto case_14;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 10U) {
#line 590
        goto case_10;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 6U) {
#line 590
        goto case_6;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 2U) {
#line 590
        goto case_2;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 13U) {
#line 590
        goto case_13;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 9U) {
#line 590
        goto case_9;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 5U) {
#line 590
        goto case_5;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 1U) {
#line 590
        goto case_1;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 16U) {
#line 590
        goto case_16;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 12U) {
#line 590
        goto case_12;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 8U) {
#line 590
        goto case_8;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 4U) {
#line 590
        goto case_4;
      }
#line 590
      if ((unsigned int )sizeof(o.quote_these_too) == 0U) {
#line 590
        goto case_0;
      }
#line 590
      goto switch_break;
      case_15: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 590
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 2);
#line 590
      __u->__uc = __c;
#line 590
      goto switch_break;
      case_14: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 590
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 590
      goto switch_break;
      case_13: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 590
      __u->__uc = __c;
#line 590
      goto switch_break;
      case_16: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 590
      __u = (union __anonunion___u_17 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 590
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 590
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 590
    __s = (void *)(o.quote_these_too);
    {
#line 590
    __builtin_memset(__s, '\000', (int )sizeof(o.quote_these_too));
    }
    }
  }
  {
  {
#line 591
  tmp = quotearg_n_options((int )n, arg, (struct quoting_options  const  *)(& o));
  }
  }
#line 591
  return (tmp);
}
}
#line 594 "quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
  {
#line 597
  tmp = quotearg_n_style(0U, s, arg);
  }
  }
#line 597
  return (tmp);
}
}
#line 600 "quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 604
  options = default_quoting_options;
  {
#line 605
  set_char_quoting(& options, ch, 1);
  }
  {
#line 606
  tmp = quotearg_n_options(0, arg, (struct quoting_options  const  *)(& options));
  }
  }
#line 606
  return (tmp);
}
}
#line 609 "quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
  {
#line 612
  tmp = quotearg_char(arg, (char )':');
  }
  }
#line 612
  return (tmp);
}
}
#line 215 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 219
__inline extern int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 239
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 326
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64")  ;
#line 329
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("__xstat64")  ;
#line 331
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __asm__("__lxstat64")  ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 359
  return (tmp);
}
}
#line 363
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
  }
#line 366
  return (tmp);
}
}
#line 370
__inline extern int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
  }
#line 379
  return (tmp);
}
}
#line 36 "isdir.c"
int isdir(char const   *path___0 ) 
{ 
  struct stat stats ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 41
  tmp = stat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& stats));
  }
  }
#line 41
  if (tmp == 0) {
#line 41
    if ((stats.st_mode & 61440U) == 16384U) {
#line 41
      tmp___0 = 1;
    } else {
#line 41
      tmp___0 = 0;
    }
  } else {
#line 41
    tmp___0 = 0;
  }
#line 41
  return (tmp___0);
}
}
#line 125 "/usr/include/locale.h"
extern char *setlocale(int __category , char const   *__locale ) ;
#line 96 "/usr/include/string.h"
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 51 "hard-locale.c"
int hard_locale(int category ) 
{ 
  int hard ;
  char const   *p ;
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;

  {
  {
#line 58
  hard = 1;
  {
#line 59
  tmp = setlocale(category, (char const   *)0);
  }
#line 59
  p = (char const   *)tmp;
  }
#line 61
  if (p) {
#line 64
    if (0) {
      {
      {
#line 64
      __s1_len = strlen(p);
      }
      {
#line 64
      __s2_len = strlen("C");
      }
      }
#line 64
      if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1U)) {
#line 64
        goto _L___0;
      } else
#line 64
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 64
        if (! ((size_t )((void const   *)("C" + 1)) - (size_t )((void const   *)"C") == 1U)) {
#line 64
          tmp___5 = 1;
        } else
#line 64
        if (__s2_len >= 4U) {
#line 64
          tmp___5 = 1;
        } else {
#line 64
          tmp___5 = 0;
        }
      } else {
#line 64
        tmp___5 = 0;
      }
#line 64
      if (tmp___5) {
#line 64
        if (__s1_len < __s2_len) {
#line 64
          tmp___1 = __s1_len;
        } else {
#line 64
          tmp___1 = __s2_len;
        }
        {
        {
#line 64
        tmp___2 = memcmp((void const   *)p, (void const   *)"C", tmp___1 + 1U);
        }
#line 64
        tmp___4 = tmp___2;
        }
      } else {
        {
        {
#line 64
        tmp___3 = strcmp(p, "C");
        }
#line 64
        tmp___4 = tmp___3;
        }
      }
    } else {
      {
      {
#line 64
      tmp___3 = strcmp(p, "C");
      }
#line 64
      tmp___4 = tmp___3;
      }
    }
#line 64
    if (tmp___4 == 0) {
#line 65
      hard = 0;
    } else {
#line 64
      if (0) {
        {
        {
#line 64
        __s1_len___0 = strlen(p);
        }
        {
#line 64
        __s2_len___0 = strlen("POSIX");
        }
        }
#line 64
        if (! ((size_t )((void const   *)(p + 1)) - (size_t )((void const   *)p) == 1U)) {
#line 64
          goto _L___2;
        } else
#line 64
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 64
          if (! ((size_t )((void const   *)("POSIX" + 1)) - (size_t )((void const   *)"POSIX") == 1U)) {
#line 64
            tmp___11 = 1;
          } else
#line 64
          if (__s2_len___0 >= 4U) {
#line 64
            tmp___11 = 1;
          } else {
#line 64
            tmp___11 = 0;
          }
        } else {
#line 64
          tmp___11 = 0;
        }
#line 64
        if (tmp___11) {
#line 64
          if (__s1_len___0 < __s2_len___0) {
#line 64
            tmp___7 = __s1_len___0;
          } else {
#line 64
            tmp___7 = __s2_len___0;
          }
          {
          {
#line 64
          tmp___8 = memcmp((void const   *)p, (void const   *)"POSIX", tmp___7 + 1U);
          }
#line 64
          tmp___10 = tmp___8;
          }
        } else {
          {
          {
#line 64
          tmp___9 = strcmp(p, "POSIX");
          }
#line 64
          tmp___10 = tmp___9;
          }
        }
      } else {
        {
        {
#line 64
        tmp___9 = strcmp(p, "POSIX");
        }
#line 64
        tmp___10 = tmp___9;
        }
      }
#line 64
      if (tmp___10 == 0) {
#line 65
        hard = 0;
      }
    }
  }
#line 82
  return (hard);
}
}
#line 31 "exclude.h"
struct exclude *new_exclude(void) ;
#line 32
void add_exclude(struct exclude *ex , char const   *pattern ) ;
#line 33
int add_exclude_file(void (*add_func)(struct exclude * , char const   * ) , struct exclude *ex ,
                     char const   *filename___0 , char line_end___1 ) ;
#line 62 "fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__string , int __flags ) ;
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 252
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 724
extern int ferror(FILE *__stream ) ;
#line 46 "exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *ex ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 49
  tmp = xmalloc((size_t )sizeof(struct exclude ));
  }
#line 49
  ex = (struct exclude *)tmp;
#line 50
  ex->exclude_count = 0;
#line 51
  ex->exclude_alloc = 64;
  {
#line 52
  tmp___0 = xmalloc((size_t )((unsigned long )ex->exclude_alloc * sizeof(char *)));
  }
#line 52
  ex->exclude = (char const   **)tmp___0;
  }
#line 53
  return (ex);
}
}
#line 56 "exclude.c"
int excluded_filename(struct exclude  const  *ex , char const   *f , int options ) 
{ 
  char const   * const  *exclude ;
  int exclude_count ;
  int i ;
  int tmp ;

  {
#line 59
  exclude = (char const   * const  *)ex->exclude;
#line 60
  exclude_count = (int )ex->exclude_count;
#line 63
  i = 0;
  {
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < exclude_count)) {
#line 63
      goto while_break;
    }
    {
    {
#line 64
    tmp = fnmatch((char const   *)*(exclude + i), f, options);
    }
    }
#line 64
    if (tmp == 0) {
#line 65
      return (1);
    }
#line 63
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (0);
}
}
#line 70 "exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern ) 
{ 
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 73
  if (ex->exclude_alloc <= ex->exclude_count) {
    {
#line 74
    tmp = ex->exclude_alloc * 2;
#line 74
    ex->exclude_alloc = tmp;
    {
#line 74
    tmp___0 = xrealloc((void *)ex->exclude, (size_t )((unsigned long )tmp * sizeof(char *)));
    }
#line 74
    ex->exclude = (char const   **)tmp___0;
    }
  }
#line 78
  tmp___1 = ex->exclude_count;
#line 78
  (ex->exclude_count) ++;
#line 78
  *(ex->exclude + tmp___1) = pattern;
#line 79
  return;
}
}
#line 81 "exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * ) , struct exclude *ex ,
                     char const   *filename___0 , char line_end___1 ) 
{ 
  int use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp28 ;

  {
#line 85
  if ((int const   )*(filename___0 + 0) == 45) {
#line 85
    if (! *(filename___0 + 1)) {
#line 85
      tmp = 1;
    } else {
#line 85
      tmp = 0;
    }
  } else {
#line 85
    tmp = 0;
  }
#line 85
  use_stdin = tmp;
#line 91
  buf_alloc = (size_t )1024;
#line 92
  buf_count = (size_t )0;
#line 94
  e = 0;
#line 96
  if (use_stdin) {
#line 97
    in = stdin;
  } else {
    {
    {
#line 98
    in = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"r");
    }
    }
#line 98
    if (! in) {
#line 99
      return (-1);
    }
  }
  {
  {
#line 101
  tmp___0 = xmalloc(buf_alloc);
  }
#line 101
  buf = (char *)tmp___0;
  }
  {
  {
#line 103
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 103
    c = _IO_getc(in);
    }
    }
#line 103
    if (! (c != -1)) {
#line 103
      goto while_break;
    }
#line 105
    tmp___1 = buf_count;
#line 105
    buf_count ++;
#line 105
    *(buf + tmp___1) = (char )c;
#line 106
    if (buf_count == buf_alloc) {
      {
#line 107
      buf_alloc *= 2U;
      {
#line 107
      tmp___2 = xrealloc((void *)buf, buf_alloc);
      }
#line 107
      buf = (char *)tmp___2;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 110
  tmp___3 = xrealloc((void *)buf, buf_count + 1U);
  }
#line 110
  buf = (char *)tmp___3;
  {
#line 112
  tmp___5 = ferror(in);
  }
  }
#line 112
  if (tmp___5) {
    {
    {
#line 113
    tmp___4 = __errno_location();
    }
#line 113
    e = *tmp___4;
    }
  }
#line 115
  if (! use_stdin) {
    {
    {
#line 115
    tmp___7 = fclose(in);
    }
    }
#line 115
    if (tmp___7 != 0) {
      {
      {
#line 116
      tmp___6 = __errno_location();
      }
#line 116
      e = *tmp___6;
      }
    }
  }
#line 118
  p = buf;
#line 118
  pattern = (char const   *)p;
#line 118
  lim = (char const   *)(buf + buf_count);
  {
  {
#line 118
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )p <= (unsigned long )lim)) {
#line 118
      goto while_break___0;
    }
#line 119
    if ((unsigned long )p < (unsigned long )lim) {
#line 119
      tmp___9 = (int )*p == (int )line_end___1;
    } else {
#line 119
      if ((unsigned long )buf < (unsigned long )p) {
#line 119
        if (*(p + -1)) {
#line 119
          tmp___8 = 1;
        } else {
#line 119
          tmp___8 = 0;
        }
      } else {
#line 119
        tmp___8 = 0;
      }
#line 119
      tmp___9 = tmp___8;
    }
#line 119
    if (tmp___9) {
      {
#line 121
      *p = (char )'\000';
      {
#line 122
      (*add_func)(ex, pattern);
      }
#line 123
      pattern = (char const   *)(p + 1);
      }
    }
#line 118
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 126
  tmp___10 = __errno_location();
  }
#line 126
  *tmp___10 = e;
  }
#line 127
  if (e) {
#line 127
    tmp___11 = -1;
  } else {
#line 127
    tmp___11 = 0;
  }
#line 127
  return (tmp___11);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 248 "/usr/include/string.h"
extern char *strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 52 "error.h"
void ( /* format attribute */  error_at_line)(int status , int errnum , char const   *file_name___0 ,
                                              unsigned int line_number , char const   *message 
                                              , ...) ;
#line 59 "error.h"
void (*error_print_progname)(void)  ;
#line 68 "error.h"
unsigned int error_message_count  ;
#line 72 "error.h"
int error_one_per_line  ;
#line 98 "error.c"
char *program_name ;
#line 130 "error.c"
void ( /* format attribute */  error)(int status , int errnum , char const   *message 
                                      , ...) 
{ 
  va_list args ;
  char errbuf[1024] ;
  char *tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 145
  if (error_print_progname) {
    {
    {
#line 146
    (*error_print_progname)();
    }
    }
  } else {
    {
    {
#line 149
    fflush(stdout);
    }
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
    }
    }
  }
  {
  {
#line 154
  __builtin_va_start(args, message);
  }
  {
#line 156
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
  }
  {
#line 160
  __builtin_va_end(args);
  }
#line 165
  error_message_count ++;
  }
#line 166
  if (errnum) {
    {
    {
#line 171
    tmp = strerror_r(errnum, errbuf, (size_t )sizeof(errbuf));
    }
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
    }
  }
  {
  {
#line 182
  _IO_putc('\n', stderr);
  }
  {
#line 183
  fflush(stderr);
  }
  }
#line 184
  if (status) {
    {
    {
#line 185
    exit(status);
    }
    }
  }
#line 186
  return;
}
}
#line 212 "error.c"
static char const   *old_file_name  ;
#line 213 "error.c"
static unsigned int old_line_number  ;
#line 192 "error.c"
void ( /* format attribute */  error_at_line)(int status , int errnum , char const   *file_name___0 ,
                                              unsigned int line_number , char const   *message 
                                              , ...) 
{ 
  va_list args ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char errbuf[1024] ;
  char *tmp___5 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 210
  if (error_one_per_line) {
#line 216
    if (old_line_number == line_number) {
#line 216
      if ((unsigned long )file_name___0 == (unsigned long )old_file_name) {
#line 218
        return;
      } else {
#line 216
        if (0) {
          {
          {
#line 216
          __s1_len = strlen(old_file_name);
          }
          {
#line 216
          __s2_len = strlen(file_name___0);
          }
          }
#line 216
          if (! ((size_t )((void const   *)(old_file_name + 1)) - (size_t )((void const   *)old_file_name) == 1U)) {
#line 216
            goto _L___0;
          } else
#line 216
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 216
            if (! ((size_t )((void const   *)(file_name___0 + 1)) - (size_t )((void const   *)file_name___0) == 1U)) {
#line 216
              tmp___4 = 1;
            } else
#line 216
            if (__s2_len >= 4U) {
#line 216
              tmp___4 = 1;
            } else {
#line 216
              tmp___4 = 0;
            }
          } else {
#line 216
            tmp___4 = 0;
          }
#line 216
          if (tmp___4) {
#line 216
            if (__s1_len < __s2_len) {
#line 216
              tmp___0 = __s1_len;
            } else {
#line 216
              tmp___0 = __s2_len;
            }
            {
            {
#line 216
            tmp___1 = memcmp((void const   *)old_file_name, (void const   *)file_name___0,
                             tmp___0 + 1U);
            }
#line 216
            tmp___3 = tmp___1;
            }
          } else {
            {
            {
#line 216
            tmp___2 = strcmp(old_file_name, file_name___0);
            }
#line 216
            tmp___3 = tmp___2;
            }
          }
        } else {
          {
          {
#line 216
          tmp___2 = strcmp(old_file_name, file_name___0);
          }
#line 216
          tmp___3 = tmp___2;
          }
        }
#line 216
        if (! tmp___3) {
#line 218
          return;
        }
      }
    }
#line 220
    old_file_name = file_name___0;
#line 221
    old_line_number = line_number;
  }
#line 224
  if (error_print_progname) {
    {
    {
#line 225
    (*error_print_progname)();
    }
    }
  } else {
    {
    {
#line 228
    fflush(stdout);
    }
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:",
            program_name);
    }
    }
  }
#line 232
  if ((unsigned long )file_name___0 != (unsigned long )((void *)0)) {
    {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
            file_name___0, line_number);
    }
    }
  }
  {
  {
#line 236
  __builtin_va_start(args, message);
  }
  {
#line 238
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
  }
  {
#line 242
  __builtin_va_end(args);
  }
#line 247
  error_message_count ++;
  }
#line 248
  if (errnum) {
    {
    {
#line 253
    tmp___5 = strerror_r(errnum, errbuf, (size_t )sizeof(errbuf));
    }
    {
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp___5);
    }
    }
  }
  {
  {
#line 264
  _IO_putc('\n', stderr);
  }
  {
#line 265
  fflush(stderr);
  }
  }
#line 266
  if (status) {
    {
    {
#line 267
    exit(status);
    }
    }
  }
#line 268
  return;
}
}
#line 12 "closeout.h"
void close_stdout_set_status(int status ) ;
#line 13
void close_stdout_set_file_name(char const   *file ) ;
#line 14
void close_stdout(void) ;
#line 15
void close_stdout_status(int status ) ;
#line 50 "closeout.c"
static int default_exit_status  =    1;
#line 51 "closeout.c"
static char const   *file_name  ;
#line 56 "closeout.c"
void close_stdout_set_status(int status ) 
{ 


  {
#line 59
  default_exit_status = status;
#line 60
  return;
}
}
#line 64 "closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 67
  file_name = file;
#line 68
  return;
}
}
#line 93 "closeout.c"
void close_stdout_status(int status ) 
{ 
  int e ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char const   *write_error ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 96
  tmp___1 = ferror(stdout);
  }
  }
#line 96
  if (tmp___1) {
#line 96
    tmp___0 = 0;
  } else {
#line 96
    tmp___0 = -1;
  }
  {
#line 96
  e = tmp___0;
  {
#line 103
  tmp___3 = fclose(stdout);
  }
  }
#line 103
  if (tmp___3 != 0) {
    {
    {
#line 104
    tmp___2 = __errno_location();
    }
#line 104
    e = *tmp___2;
    }
  }
#line 106
  if (0 < e) {
    {
    {
#line 108
    tmp___4 = dcgettext((char const   *)((void *)0), "write error", 5);
    }
#line 108
    write_error = (char const   *)tmp___4;
    }
#line 109
    if (file_name) {
      {
      {
#line 110
      tmp___5 = quotearg_colon(file_name);
      }
      {
#line 110
      error(status, e, "%s: %s", tmp___5, write_error);
      }
      }
    } else {
      {
      {
#line 112
      error(status, e, "%s", write_error);
      }
      }
    }
  }
#line 114
  return;
}
}
#line 117 "closeout.c"
void close_stdout(void) 
{ 


  {
  {
  {
#line 120
  close_stdout_status(default_exit_status);
  }
  }
#line 121
  return;
}
}
#line 35 "grep.h"
char const   *matcher  ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 65
extern void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__)) ;
#line 27 "grep.h"
struct matcher  const  matchers[7] ;
#line 39
int match_icase ;
#line 40
int match_words ;
#line 41
int match_lines ;
#line 42
unsigned char eolbyte ;
#line 450 "../lib/posix/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
#line 455
extern char const   *re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *buffer ) ;
#line 471
extern int re_search(struct re_pattern_buffer *buffer , char const   *string , int length ,
                     int start , int range , struct re_registers *regs ) ;
#line 486
extern int re_match(struct re_pattern_buffer *buffer , char const   *string , int length ,
                    int start , struct re_registers *regs ) ;
#line 392 "dfa.h"
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) ;
#line 397
void dfacomp(char const   *s , size_t len , struct dfa *d , int searchflag ) ;
#line 406
size_t dfaexec(struct dfa *d , char const   *begin , size_t size , int *backref ) ;
#line 432
void dfaerror(char const   *mesg ) ;
#line 36 "kwset.h"
kwset_t kwsalloc(char const   *trans___0 ) ;
#line 41
char *kwsincr(kwset_t kws , char const   *text , size_t len ) ;
#line 45
char *kwsprep(kwset_t kws ) ;
#line 53
size_t kwsexec(kwset_t kws , char const   *text , size_t size , struct kwsmatch *kwsmatch ) ;
#line 210 "/usr/include/pcre.h"
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 217
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 231
extern unsigned char const   *pcre_maketables(void) ;
#line 232
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 49 "search.c"
static struct dfa dfa  ;
#line 52 "search.c"
static struct patterns patterns0  ;
#line 60 "search.c"
struct patterns *patterns  ;
#line 61 "search.c"
size_t pcount  ;
#line 66 "search.c"
static kwset_t kwset  ;
#line 71 "search.c"
static int kwset_exact_matches  ;
#line 74
static char *check_multibyte_string(char const   *buf , size_t size ) ;
#line 76
static void kwsinit(void) ;
#line 77
static void kwsmusts(void) ;
#line 78
static void Gcompile(char const   *pattern , size_t size ) ;
#line 79
static void Ecompile(char const   *pattern , size_t size ) ;
#line 80
static size_t EGexecute(char const   *buf , size_t size , size_t *match_size , int exact ) ;
#line 81
static void Fcompile(char const   *pattern , size_t size ) ;
#line 82
static size_t Fexecute(char const   *buf , size_t size , size_t *match_size , int exact ) ;
#line 83
static void Pcompile(char const   *pattern , size_t size ) ;
#line 84
static size_t Pexecute(char const   *buf , size_t size , size_t *match_size , int exact ) ;
#line 86 "search.c"
void dfaerror(char const   *mesg ) 
{ 


  {
  {
  {
#line 89
  error(2, 0, mesg);
  }
  }
#line 90
  return;
}
}
#line 95 "search.c"
static char trans[256]  ;
#line 92 "search.c"
static void kwsinit(void) 
{ 
  int i ;
  int __res ;
  __int32_t const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp10 ;

  {
#line 98
  if (match_icase) {
#line 99
    i = 0;
    {
    {
#line 99
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 99
      if (! (i < 256)) {
#line 99
        goto while_break;
      }
      {
      {
#line 100
      tmp___2 = __ctype_b_loc();
      }
      }
#line 100
      if ((int const   )*(*tmp___2 + i) & 256) {
#line 100
        if (sizeof(i) > 1UL) {
          {
          {
#line 100
          __res = tolower(i);
          }
          }
        } else {
          {
          {
#line 100
          tmp___1 = __ctype_tolower_loc();
          }
#line 100
          __res = (int )*(*tmp___1 + i);
          }
        }
#line 100
        trans[i] = (char )__res;
      } else {
#line 100
        trans[i] = (char )i;
      }
#line 99
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 102
  if (match_icase) {
#line 102
    tmp___4 = trans;
  } else {
#line 102
    tmp___4 = (char *)0;
  }
  {
  {
#line 102
  kwset = kwsalloc((char const   *)tmp___4);
  }
  }
#line 102
  if (! kwset) {
    {
    {
#line 103
    tmp___3 = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
    }
    {
#line 103
    error(2, 0, (char const   *)tmp___3);
    }
    }
  }
#line 104
  return;
}
}
#line 110 "search.c"
static void kwsmusts(void) 
{ 
  struct dfamust  const  *dm ;
  char const   *err ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 116
  if (dfa.musts) {
    {
    {
#line 118
    kwsinit();
    }
#line 122
    dm = (struct dfamust  const  *)dfa.musts;
    }
    {
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 122
      if (! dm) {
#line 122
        goto while_break;
      }
#line 124
      if (! dm->exact) {
#line 125
        goto __Cont;
      }
      {
#line 126
      kwset_exact_matches ++;
      {
#line 127
      tmp = strlen((char const   *)dm->must);
      }
      {
#line 127
      tmp___0 = kwsincr(kwset, (char const   *)dm->must, tmp);
      }
#line 127
      err = (char const   *)tmp___0;
      }
#line 127
      if ((unsigned long )err != (unsigned long )((char const   *)0)) {
        {
        {
#line 128
        error(2, 0, err);
        }
        }
      }
      __Cont: /* CIL Label */ 
#line 122
      dm = (struct dfamust  const  *)dm->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 132
    dm = (struct dfamust  const  *)dfa.musts;
    {
    {
#line 132
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 132
      if (! dm) {
#line 132
        goto while_break___0;
      }
#line 134
      if (dm->exact) {
#line 135
        goto __Cont___0;
      }
      {
      {
#line 136
      tmp___1 = strlen((char const   *)dm->must);
      }
      {
#line 136
      tmp___2 = kwsincr(kwset, (char const   *)dm->must, tmp___1);
      }
#line 136
      err = (char const   *)tmp___2;
      }
#line 136
      if ((unsigned long )err != (unsigned long )((char const   *)0)) {
        {
        {
#line 137
        error(2, 0, err);
        }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 132
      dm = (struct dfamust  const  *)dm->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 139
    tmp___3 = kwsprep(kwset);
    }
#line 139
    err = (char const   *)tmp___3;
    }
#line 139
    if ((unsigned long )err != (unsigned long )((char const   *)0)) {
      {
      {
#line 140
      error(2, 0, err);
      }
      }
    }
  }
#line 142
  return;
}
}
#line 149 "search.c"
static char *check_multibyte_string(char const   *buf , size_t size ) 
{ 
  char *mb_properties ;
  void *tmp ;
  mbstate_t cur_state ;
  int i ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_24 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  void *__s___2 ;
  void *__s___3 ;
  union __anonunion___u_25 *__u___0 ;
  __uint8_t __c___0 ;
  void *__s___4 ;
  size_t mbclen ;

  {
  {
  {
#line 152
  tmp = malloc(size);
  }
#line 152
  mb_properties = (char *)tmp;
  }
#line 155
  if (sizeof(mbstate_t ) <= 16UL) {
#line 155
    if (sizeof(mbstate_t ) == 1UL) {
#line 155
      __s___1 = (void *)(& cur_state);
#line 155
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 155
      __s___0 = (void *)(& cur_state);
#line 155
      __u = (union __anonunion___u_24 *)__s___0;
#line 155
      __c = (__uint8_t )0;
      {
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 155
        goto case_15;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 155
        goto case_11;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 155
        goto case_7;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 155
        goto case_3;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 155
        goto case_14;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 155
        goto case_10;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 155
        goto case_6;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 155
        goto case_2;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 155
        goto case_13;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 155
        goto case_9;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 155
        goto case_5;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 155
        goto case_1;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 155
        goto case_16;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 155
        goto case_12;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 155
        goto case_8;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 155
        goto case_4;
      }
#line 155
      if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 155
        goto case_0;
      }
#line 155
      goto switch_break;
      case_15: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 155
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 2);
#line 155
      __u->__uc = __c;
#line 155
      goto switch_break;
      case_14: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 155
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 155
      goto switch_break;
      case_13: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 155
      __u->__uc = __c;
#line 155
      goto switch_break;
      case_16: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 155
      __u = (union __anonunion___u_24 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 155
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 155
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 155
    __s = (void *)(& cur_state);
    {
#line 155
    __builtin_memset(__s, '\000', (int )sizeof(mbstate_t ));
    }
    }
  }
#line 156
  if (0) {
#line 156
    if (sizeof(char ) * (unsigned long )size == 1UL) {
#line 156
      __s___4 = (void *)mb_properties;
#line 156
      *((__uint8_t *)__s___4) = (__uint8_t )0;
    } else {
#line 156
      __s___3 = (void *)mb_properties;
#line 156
      __u___0 = (union __anonunion___u_25 *)__s___3;
#line 156
      __c___0 = (__uint8_t )0;
      {
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 15U) {
#line 156
        goto case_15___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 11U) {
#line 156
        goto case_11___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 7U) {
#line 156
        goto case_7___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 3U) {
#line 156
        goto case_3___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 14U) {
#line 156
        goto case_14___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 10U) {
#line 156
        goto case_10___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 6U) {
#line 156
        goto case_6___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 2U) {
#line 156
        goto case_2___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 13U) {
#line 156
        goto case_13___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 9U) {
#line 156
        goto case_9___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 5U) {
#line 156
        goto case_5___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 1U) {
#line 156
        goto case_1___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 16U) {
#line 156
        goto case_16___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 12U) {
#line 156
        goto case_12___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 8U) {
#line 156
        goto case_8___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 4U) {
#line 156
        goto case_4___0;
      }
#line 156
      if ((unsigned int )(sizeof(char ) * (unsigned long )size) == 0U) {
#line 156
        goto case_0___0;
      }
#line 156
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_11___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_7___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_3___0: /* CIL Label */ 
#line 156
      __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 2);
#line 156
      __u___0->__uc = __c___0;
#line 156
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_10___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_6___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_2___0: /* CIL Label */ 
#line 156
      __u___0->__usi = (unsigned short )((int )((unsigned short )__c___0) * 257);
#line 156
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_9___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_5___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_1___0: /* CIL Label */ 
#line 156
      __u___0->__uc = __c___0;
#line 156
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_12___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_8___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
#line 156
      __u___0 = (union __anonunion___u_25 *)((void *)__u___0 + 4);
      case_4___0: /* CIL Label */ 
#line 156
      __u___0->__ui = (unsigned int )((int )__c___0 * 16843009);
      case_0___0: /* CIL Label */ 
#line 156
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 156
    __s___2 = (void *)mb_properties;
    {
#line 156
    __builtin_memset(__s___2, '\000', (int )(sizeof(char ) * (unsigned long )size));
    }
    }
  }
#line 157
  i = 0;
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((size_t )i < size)) {
#line 157
      goto while_break;
    }
    {
    {
#line 160
    mbclen = mbrlen((char const   */* __restrict  */)(buf + i), size - (size_t )i,
                    (mbstate_t */* __restrict  */)(& cur_state));
    }
    }
#line 162
    if (mbclen == 4294967295U) {
#line 166
      mbclen = (size_t )1;
    } else
#line 162
    if (mbclen == 4294967294U) {
#line 166
      mbclen = (size_t )1;
    } else
#line 162
    if (mbclen == 0U) {
#line 166
      mbclen = (size_t )1;
    }
#line 168
    *(mb_properties + i) = (char )mbclen;
#line 169
    i = (int )((size_t )i + mbclen);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return (mb_properties);
}
}
#line 232 "search.c"
static char const   line_beg[4]  = {      (char const   )'^',      (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 233 "search.c"
static char const   line_end[4]  = {      (char const   )'\\',      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 234 "search.c"
static char const   word_beg[23]  = 
#line 234
  {      (char const   )'\\',      (char const   )'(',      (char const   )'^',      (char const   )'\\', 
        (char const   )'|',      (char const   )'[',      (char const   )'^',      (char const   )'[', 
        (char const   )':',      (char const   )'a',      (char const   )'l',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )':',      (char const   )']', 
        (char const   )'_',      (char const   )']',      (char const   )'\\',      (char const   )')', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000'};
#line 235 "search.c"
static char const   word_end[23]  = 
#line 235
  {      (char const   )'\\',      (char const   )')',      (char const   )'\\',      (char const   )'(', 
        (char const   )'[',      (char const   )'^',      (char const   )'[',      (char const   )':', 
        (char const   )'a',      (char const   )'l',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )':',      (char const   )']',      (char const   )'_', 
        (char const   )']',      (char const   )'\\',      (char const   )'|',      (char const   )'$', 
        (char const   )'\\',      (char const   )')',      (char const   )'\000'};
#line 176 "search.c"
static void Gcompile(char const   *pattern , size_t size ) 
{ 
  char const   *err ;
  char const   *sep ;
  size_t total ;
  char const   *motif ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *n ;
  void *tmp___3 ;
  size_t i ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp18 ;

  {
  {
#line 181
  total = size;
#line 182
  motif = pattern;
  {
#line 184
  re_set_syntax((((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
#line 185
  dfasyntax((((((1UL << 1) | ((1UL << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
            match_icase, eolbyte);
  }
  }
  {
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 194
    tmp = memchr((void const   *)motif, '\n', total);
    }
#line 194
    sep = (char const   *)tmp;
    }
#line 195
    if (sep) {
#line 197
      len = (size_t )(sep - motif);
#line 198
      sep ++;
#line 199
      total -= len + 1U;
    } else {
#line 203
      len = total;
#line 204
      total = (size_t )0;
    }
    {
    {
#line 207
    tmp___0 = realloc((void *)patterns, (size_t )((unsigned long )(pcount + 1U) * sizeof(*patterns)));
    }
#line 207
    patterns = (struct patterns *)tmp___0;
    }
#line 208
    if ((unsigned long )patterns == (unsigned long )((void *)0)) {
      {
      {
#line 209
      tmp___1 = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
      }
      {
#line 209
      tmp___2 = __errno_location();
      }
      {
#line 209
      error(2, *tmp___2, (char const   *)tmp___1);
      }
      }
    }
    {
#line 211
    *(patterns + pcount) = patterns0;
    {
#line 213
    err = re_compile_pattern(motif, len, & (patterns + pcount)->regexbuf);
    }
    }
#line 213
    if ((unsigned long )err != (unsigned long )((char const   *)0)) {
      {
      {
#line 215
      error(2, 0, err);
      }
      }
    }
#line 216
    pcount ++;
#line 218
    motif = sep;
#line 191
    if (sep) {
#line 191
      if (! (total != 0U)) {
#line 191
        goto while_break;
      }
    } else {
#line 191
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  if (match_words) {
#line 225
    goto _L;
  } else
#line 225
  if (match_lines) {
    _L: /* CIL Label */ 
    {
    {
#line 236
    tmp___3 = malloc((size_t )(((sizeof(word_beg) - 1UL) + (unsigned long )size) + sizeof(word_end)));
    }
#line 236
    n = (char *)tmp___3;
    }
#line 238
    if (match_lines) {
#line 238
      tmp___4 = line_beg;
    } else {
#line 238
      tmp___4 = word_beg;
    }
    {
    {
#line 238
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)tmp___4);
    }
    {
#line 239
    i = strlen((char const   *)n);
    }
    {
#line 240
    memcpy((void */* __restrict  */)(n + i), (void const   */* __restrict  */)pattern,
           size);
    }
#line 241
    i += size;
    }
#line 242
    if (match_lines) {
#line 242
      tmp___5 = line_end;
    } else {
#line 242
      tmp___5 = word_end;
    }
    {
    {
#line 242
    strcpy((char */* __restrict  */)(n + i), (char const   */* __restrict  */)tmp___5);
    }
    {
#line 243
    tmp___6 = strlen((char const   *)(n + i));
    }
#line 243
    i += tmp___6;
#line 244
    pattern = (char const   *)n;
#line 245
    size = i;
    }
  }
  {
  {
#line 248
  dfacomp(pattern, size, & dfa, 1);
  }
  {
#line 249
  kwsmusts();
  }
  }
#line 250
  return;
}
}
#line 315 "search.c"
static char const   line_beg___0[3]  = {      (char const   )'^',      (char const   )'(',      (char const   )'\000'};
#line 316 "search.c"
static char const   line_end___0[3]  = {      (char const   )')',      (char const   )'$',      (char const   )'\000'};
#line 317 "search.c"
static char const   word_beg___0[19]  = 
#line 317
  {      (char const   )'(',      (char const   )'^',      (char const   )'|',      (char const   )'[', 
        (char const   )'^',      (char const   )'[',      (char const   )':',      (char const   )'a', 
        (char const   )'l',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )':',      (char const   )']',      (char const   )'_',      (char const   )']', 
        (char const   )')',      (char const   )'(',      (char const   )'\000'};
#line 318 "search.c"
static char const   word_end___0[19]  = 
#line 318
  {      (char const   )')',      (char const   )'(',      (char const   )'[',      (char const   )'^', 
        (char const   )'[',      (char const   )':',      (char const   )'a',      (char const   )'l', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )':', 
        (char const   )']',      (char const   )'_',      (char const   )']',      (char const   )'|', 
        (char const   )'$',      (char const   )')',      (char const   )'\000'};
#line 252 "search.c"
static void Ecompile(char const   *pattern , size_t size ) 
{ 
  char const   *err ;
  char const   *sep ;
  size_t total ;
  char const   *motif ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t len ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *n ;
  void *tmp___9 ;
  size_t i ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 257
  total = size;
#line 258
  motif = pattern;
#line 260
  if (0) {
    {
    {
#line 260
    __s1_len = strlen(matcher);
    }
    {
#line 260
    __s2_len = strlen("awk");
    }
    }
#line 260
    if (! ((size_t )((void const   *)(matcher + 1)) - (size_t )((void const   *)matcher) == 1U)) {
#line 260
      goto _L___0;
    } else
#line 260
    if (__s1_len >= 4U) {
      _L___0: /* CIL Label */ 
#line 260
      if (! ((size_t )((void const   *)("awk" + 1)) - (size_t )((void const   *)"awk") == 1U)) {
#line 260
        tmp___4 = 1;
      } else
#line 260
      if (__s2_len >= 4U) {
#line 260
        tmp___4 = 1;
      } else {
#line 260
        tmp___4 = 0;
      }
    } else {
#line 260
      tmp___4 = 0;
    }
#line 260
    if (tmp___4) {
#line 260
      if (__s1_len < __s2_len) {
#line 260
        tmp___0 = __s1_len;
      } else {
#line 260
        tmp___0 = __s2_len;
      }
      {
      {
#line 260
      tmp___1 = memcmp((void const   *)matcher, (void const   *)"awk", tmp___0 + 1U);
      }
#line 260
      tmp___3 = tmp___1;
      }
    } else {
      {
      {
#line 260
      tmp___2 = strcmp(matcher, "awk");
      }
#line 260
      tmp___3 = tmp___2;
      }
    }
  } else {
    {
    {
#line 260
    tmp___2 = strcmp(matcher, "awk");
    }
#line 260
    tmp___3 = tmp___2;
    }
  }
#line 260
  if (tmp___3 == 0) {
    {
    {
#line 262
    re_set_syntax(((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
    {
#line 263
    dfasyntax(((((((((1UL | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
              match_icase, eolbyte);
    }
    }
  } else {
    {
    {
#line 267
    re_set_syntax(((((((((((1UL << 1) << 1) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
    {
#line 268
    dfasyntax(((((((((((1UL << 1) << 1) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1),
              match_icase, eolbyte);
    }
    }
  }
  {
  {
#line 275
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    tmp___5 = memchr((void const   *)motif, '\n', total);
    }
#line 278
    sep = (char const   *)tmp___5;
    }
#line 279
    if (sep) {
#line 281
      len = (size_t )(sep - motif);
#line 282
      sep ++;
#line 283
      total -= len + 1U;
    } else {
#line 287
      len = total;
#line 288
      total = (size_t )0;
    }
    {
    {
#line 291
    tmp___6 = realloc((void *)patterns, (size_t )((unsigned long )(pcount + 1U) * sizeof(*patterns)));
    }
#line 291
    patterns = (struct patterns *)tmp___6;
    }
#line 292
    if ((unsigned long )patterns == (unsigned long )((void *)0)) {
      {
      {
#line 293
      tmp___7 = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
      }
      {
#line 293
      tmp___8 = __errno_location();
      }
      {
#line 293
      error(2, *tmp___8, (char const   *)tmp___7);
      }
      }
    }
    {
#line 294
    *(patterns + pcount) = patterns0;
    {
#line 296
    err = re_compile_pattern(motif, len, & (patterns + pcount)->regexbuf);
    }
    }
#line 296
    if ((unsigned long )err != (unsigned long )((char const   *)0)) {
      {
      {
#line 298
      error(2, 0, err);
      }
      }
    }
#line 299
    pcount ++;
#line 301
    motif = sep;
#line 275
    if (sep) {
#line 275
      if (! (total != 0U)) {
#line 275
        goto while_break;
      }
    } else {
#line 275
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (match_words) {
#line 308
    goto _L___1;
  } else
#line 308
  if (match_lines) {
    _L___1: /* CIL Label */ 
    {
    {
#line 319
    tmp___9 = malloc((size_t )(((sizeof(word_beg___0) - 1UL) + (unsigned long )size) + sizeof(word_end___0)));
    }
#line 319
    n = (char *)tmp___9;
    }
#line 321
    if (match_lines) {
#line 321
      tmp___10 = line_beg___0;
    } else {
#line 321
      tmp___10 = word_beg___0;
    }
    {
    {
#line 321
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)tmp___10);
    }
    {
#line 322
    i = strlen((char const   *)n);
    }
    {
#line 323
    memcpy((void */* __restrict  */)(n + i), (void const   */* __restrict  */)pattern,
           size);
    }
#line 324
    i += size;
    }
#line 325
    if (match_lines) {
#line 325
      tmp___11 = line_end___0;
    } else {
#line 325
      tmp___11 = word_end___0;
    }
    {
    {
#line 325
    strcpy((char */* __restrict  */)(n + i), (char const   */* __restrict  */)tmp___11);
    }
    {
#line 326
    tmp___12 = strlen((char const   *)(n + i));
    }
#line 326
    i += tmp___12;
#line 327
    pattern = (char const   *)n;
#line 328
    size = i;
    }
  }
  {
  {
#line 331
  dfacomp(pattern, size, & dfa, 1);
  }
  {
#line 332
  kwsmusts();
  }
  }
#line 333
  return;
}
}
#line 335 "search.c"
static size_t EGexecute(char const   *buf , size_t size , size_t *match_size , int exact ) 
{ 
  register char const   *buflim___0 ;
  register char const   *beg ;
  register char const   *end ;
  char eol ;
  int backref ;
  int start ;
  int len ;
  struct kwsmatch kwsm ;
  size_t i ;
  char *mb_properties ;
  size_t tmp ;
  size_t offset ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t offset___0 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 339
  eol = (char )eolbyte;
#line 344
  mb_properties = (char *)((void *)0);
  {
#line 348
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 348
  if (tmp > 1U) {
#line 348
    if (kwset) {
      {
      {
#line 349
      mb_properties = check_multibyte_string(buf, size);
      }
      }
    }
  }
#line 352
  buflim___0 = buf + size;
#line 354
  end = buf;
#line 354
  beg = end;
  {
  {
#line 354
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 354
    if (! ((unsigned long )end < (unsigned long )buflim___0)) {
#line 354
      goto while_break;
    }
#line 356
    if (! exact) {
#line 358
      if (kwset) {
        {
        {
#line 361
        tmp___0 = kwsexec(kwset, beg, (size_t )(buflim___0 - beg), & kwsm);
        }
#line 361
        offset = tmp___0;
        }
#line 362
        if (offset == 4294967295U) {
          {
          {
#line 365
          tmp___1 = __ctype_get_mb_cur_max();
          }
          }
#line 365
          if (tmp___1 > 1U) {
            {
            {
#line 366
            free((void *)mb_properties);
            }
            }
          }
#line 368
          return ((size_t )-1);
        }
        {
#line 370
        beg += offset;
        {
#line 373
        tmp___2 = memchr((void const   *)beg, (int )eol, (size_t )(buflim___0 - beg));
        }
#line 373
        end = (char const   *)tmp___2;
#line 374
        end ++;
        {
#line 376
        tmp___3 = __ctype_get_mb_cur_max();
        }
        }
#line 376
        if (tmp___3 > 1U) {
#line 376
          if ((int )*(mb_properties + (beg - buf)) == 0) {
#line 377
            goto __Cont;
          }
        }
        {
        {
#line 379
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 379
          if ((unsigned long )beg > (unsigned long )buf) {
#line 379
            if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 379
              goto while_break___0;
            }
          } else {
#line 379
            goto while_break___0;
          }
#line 380
          beg --;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 381
        if (kwsm.index < kwset_exact_matches) {
#line 382
          goto success;
        }
        {
        {
#line 383
        tmp___4 = dfaexec(& dfa, beg, (size_t )(end - beg), & backref);
        }
        }
#line 383
        if (tmp___4 == 4294967295U) {
#line 384
          goto __Cont;
        }
      } else {
        {
        {
#line 389
        tmp___5 = dfaexec(& dfa, beg, (size_t )(buflim___0 - beg), & backref);
        }
#line 389
        offset___0 = tmp___5;
        }
#line 390
        if (offset___0 == 4294967295U) {
#line 391
          goto while_break;
        }
        {
#line 393
        beg += offset___0;
        {
#line 394
        tmp___6 = memchr((void const   *)beg, (int )eol, (size_t )(buflim___0 - beg));
        }
#line 394
        end = (char const   *)tmp___6;
#line 395
        end ++;
        }
        {
        {
#line 396
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 396
          if ((unsigned long )beg > (unsigned long )buf) {
#line 396
            if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 396
              goto while_break___1;
            }
          } else {
#line 396
            goto while_break___1;
          }
#line 397
          beg --;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 400
      if (! backref) {
#line 401
        goto success;
      }
    } else {
#line 404
      end = beg + size;
    }
#line 408
    i = (size_t )0;
    {
    {
#line 408
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 408
      if (! (i < pcount)) {
#line 408
        goto while_break___2;
      }
      {
#line 410
      (patterns + i)->regexbuf.not_eol = 0U;
      {
#line 411
      start = re_search(& (patterns + i)->regexbuf, beg, (int )((end - beg) - 1L),
                        0, (int )((end - beg) - 1L), & (patterns + i)->regs);
      }
      }
#line 411
      if (0 <= start) {
#line 415
        len = *((patterns + i)->regs.end + 0) - start;
#line 416
        if (exact) {
#line 418
          *match_size = (size_t )len;
#line 419
          return ((size_t )start);
        }
#line 421
        if (! match_lines) {
#line 421
          if (! match_words) {
#line 423
            goto success;
          } else {
#line 421
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 421
        if (match_lines) {
#line 421
          if ((long )len == (end - beg) - 1L) {
#line 423
            goto success;
          }
        }
#line 431
        if (match_words) {
          {
          {
#line 432
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
#line 432
            if (! (start >= 0)) {
#line 432
              goto while_break___3;
            }
#line 434
            if (start == 0) {
#line 434
              goto _L___0;
            } else {
              {
              {
#line 434
              tmp___7 = __ctype_b_loc();
              }
              }
#line 434
              if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*(beg + (start - 1)))) & 8)) {
#line 434
                if (! ((int )((unsigned char )*(beg + (start - 1))) == 95)) {
                  _L___0: /* CIL Label */ 
#line 434
                  if ((long )len == (end - beg) - 1L) {
#line 437
                    goto success;
                  } else {
                    {
                    {
#line 434
                    tmp___8 = __ctype_b_loc();
                    }
                    }
#line 434
                    if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(beg + (start + len)))) & 8)) {
#line 434
                      if (! ((int )((unsigned char )*(beg + (start + len))) == 95)) {
#line 437
                        goto success;
                      }
                    }
                  }
                }
              }
            }
#line 438
            if (len > 0) {
              {
#line 441
              len --;
#line 442
              (patterns + i)->regexbuf.not_eol = 1U;
              {
#line 443
              len = re_match(& (patterns + i)->regexbuf, beg, start + len, start,
                             & (patterns + i)->regs);
              }
              }
            }
#line 447
            if (len <= 0) {
#line 450
              if ((long )start == (end - beg) - 1L) {
#line 451
                goto while_break___3;
              }
              {
#line 452
              start ++;
#line 453
              (patterns + i)->regexbuf.not_eol = 0U;
              {
#line 454
              start = re_search(& (patterns + i)->regexbuf, beg, (int )((end - beg) - 1L),
                                start, (int )(((end - beg) - 1L) - (long )start),
                                & (patterns + i)->regs);
              }
#line 458
              len = *((patterns + i)->regs.end + 0) - start;
              }
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
#line 408
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 354
    beg = end;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 465
  tmp___9 = __ctype_get_mb_cur_max();
  }
  }
#line 465
  if (tmp___9 > 1U) {
#line 465
    if (mb_properties) {
      {
      {
#line 466
      free((void *)mb_properties);
      }
      }
    }
  }
#line 468
  return ((size_t )-1);
  success: 
  {
  {
#line 472
  tmp___10 = __ctype_get_mb_cur_max();
  }
  }
#line 472
  if (tmp___10 > 1U) {
#line 472
    if (mb_properties) {
      {
      {
#line 473
      free((void *)mb_properties);
      }
      }
    }
  }
#line 475
  *match_size = (size_t )(end - beg);
#line 476
  return ((size_t )(beg - buf));
}
}
#line 479 "search.c"
static void Fcompile(char const   *pattern , size_t size ) 
{ 
  char const   *beg ;
  char const   *lim ;
  char const   *err ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 484
  kwsinit();
  }
#line 485
  beg = pattern;
  }
  {
  {
#line 486
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 488
    lim = beg;
    {
    {
#line 488
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 488
      if ((unsigned long )lim < (unsigned long )(pattern + size)) {
#line 488
        if (! ((int const   )*lim != 10)) {
#line 488
          goto while_break___0;
        }
      } else {
#line 488
        goto while_break___0;
      }
#line 488
      lim ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 490
    tmp = kwsincr(kwset, beg, (size_t )(lim - beg));
    }
#line 490
    err = (char const   *)tmp;
    }
#line 490
    if ((unsigned long )err != (unsigned long )((char const   *)0)) {
      {
      {
#line 491
      error(2, 0, err);
      }
      }
    }
#line 492
    if ((unsigned long )lim < (unsigned long )(pattern + size)) {
#line 493
      lim ++;
    }
#line 494
    beg = lim;
#line 486
    if (! ((unsigned long )beg < (unsigned long )(pattern + size))) {
#line 486
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 498
  tmp___0 = kwsprep(kwset);
  }
#line 498
  err = (char const   *)tmp___0;
  }
#line 498
  if ((unsigned long )err != (unsigned long )((char const   *)0)) {
    {
    {
#line 499
    error(2, 0, err);
    }
    }
  }
#line 500
  return;
}
}
#line 502 "search.c"
static size_t Fexecute(char const   *buf , size_t size , size_t *match_size , int exact ) 
{ 
  register char const   *beg ;
  register char const   *try ;
  register char const   *end ;
  register size_t len ;
  char eol ;
  struct kwsmatch kwsmatch ;
  char *mb_properties ;
  size_t tmp ;
  size_t offset ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  unsigned short const   **tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 507
  eol = (char )eolbyte;
  {
#line 511
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 511
  if (tmp > 1U) {
    {
    {
#line 512
    mb_properties = check_multibyte_string(buf, size);
    }
    }
  }
#line 515
  beg = buf;
  {
  {
#line 515
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 515
    if (! ((unsigned long )beg <= (unsigned long )(buf + size))) {
#line 515
      goto while_break;
    }
    {
    {
#line 517
    tmp___0 = kwsexec(kwset, beg, (size_t )((buf + size) - beg), & kwsmatch);
    }
#line 517
    offset = tmp___0;
    }
#line 518
    if (offset == 4294967295U) {
      {
      {
#line 521
      tmp___1 = __ctype_get_mb_cur_max();
      }
      }
#line 521
      if (tmp___1 > 1U) {
        {
        {
#line 522
        free((void *)mb_properties);
        }
        }
      }
#line 524
      return (offset);
    }
    {
    {
#line 527
    tmp___2 = __ctype_get_mb_cur_max();
    }
    }
#line 527
    if (tmp___2 > 1U) {
#line 527
      if ((int )*(mb_properties + ((beg + offset) - buf)) == 0) {
#line 528
        goto __Cont;
      }
    }
#line 530
    beg += offset;
#line 531
    len = kwsmatch.size[0];
#line 532
    if (exact) {
      {
#line 534
      *match_size = len;
      {
#line 536
      tmp___3 = __ctype_get_mb_cur_max();
      }
      }
#line 536
      if (tmp___3 > 1U) {
        {
        {
#line 537
        free((void *)mb_properties);
        }
        }
      }
#line 539
      return ((size_t )(beg - buf));
    }
#line 541
    if (match_lines) {
#line 543
      if ((unsigned long )beg > (unsigned long )buf) {
#line 543
        if ((int const   )*(beg + -1) != (int const   )eol) {
#line 544
          goto __Cont;
        }
      }
#line 545
      if ((unsigned long )(beg + len) < (unsigned long )(buf + size)) {
#line 545
        if ((int const   )*(beg + len) != (int const   )eol) {
#line 546
          goto __Cont;
        }
      }
#line 547
      goto success;
    } else
#line 549
    if (match_words) {
#line 550
      try = beg;
      {
      {
#line 550
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 550
        if (! len) {
#line 550
          goto while_break___0;
        }
#line 552
        if ((unsigned long )try > (unsigned long )buf) {
          {
          {
#line 552
          tmp___4 = __ctype_b_loc();
          }
          }
#line 552
          if ((int const   )*(*tmp___4 + (int )((unsigned char )*(try + -1))) & 8) {
#line 553
            goto while_break___0;
          } else
#line 552
          if ((int )((unsigned char )*(try + -1)) == 95) {
#line 553
            goto while_break___0;
          }
        }
#line 554
        if ((unsigned long )(try + len) < (unsigned long )(buf + size)) {
          {
          {
#line 554
          tmp___6 = __ctype_b_loc();
          }
          }
#line 554
          if ((int const   )*(*tmp___6 + (int )((unsigned char )*(try + len))) & 8) {
#line 554
            goto _L;
          } else
#line 554
          if ((int )((unsigned char )*(try + len)) == 95) {
            _L: /* CIL Label */ 
            {
#line 556
            len --;
            {
#line 556
            offset = kwsexec(kwset, beg, len, & kwsmatch);
            }
            }
#line 557
            if (offset == 4294967295U) {
              {
              {
#line 560
              tmp___5 = __ctype_get_mb_cur_max();
              }
              }
#line 560
              if (tmp___5 > 1U) {
                {
                {
#line 561
                free((void *)mb_properties);
                }
                }
              }
#line 563
              return (offset);
            }
#line 565
            try = beg + offset;
#line 566
            len = kwsmatch.size[0];
          } else {
#line 569
            goto success;
          }
        } else {
#line 569
          goto success;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 572
      goto success;
    }
    __Cont: /* CIL Label */ 
#line 515
    beg ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 576
  tmp___7 = __ctype_get_mb_cur_max();
  }
  }
#line 576
  if (tmp___7 > 1U) {
    {
    {
#line 577
    free((void *)mb_properties);
    }
    }
  }
#line 579
  return ((size_t )-1);
  success: 
  {
  {
#line 582
  tmp___8 = memchr((void const   *)(beg + len), (int )eol, (size_t )((buf + size) - (beg + len)));
  }
#line 582
  end = (char const   *)tmp___8;
#line 583
  end ++;
  }
  {
  {
#line 584
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 584
    if ((unsigned long )buf < (unsigned long )beg) {
#line 584
      if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 584
        goto while_break___1;
      }
    } else {
#line 584
      goto while_break___1;
    }
#line 585
    beg --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 586
  *match_size = (size_t )(end - beg);
  {
#line 588
  tmp___9 = __ctype_get_mb_cur_max();
  }
  }
#line 588
  if (tmp___9 > 1U) {
    {
    {
#line 589
    free((void *)mb_properties);
    }
    }
  }
#line 591
  return ((size_t )(beg - buf));
}
}
#line 596 "search.c"
static pcre *cre  ;
#line 599 "search.c"
static pcre_extra *extra  ;
#line 602 "search.c"
static void Pcompile(char const   *pattern , size_t size ) 
{ 
  int e ;
  char const   *ep ;
  char *re ;
  void *tmp ;
  int flags ;
  int tmp___0 ;
  char const   *patlim ;
  char *n ;
  char const   *p ;
  char const   *pnul ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  unsigned char const   *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 610
  tmp = xmalloc(4U * size + 7U);
  }
#line 610
  re = (char *)tmp;
  }
#line 611
  if (match_icase) {
#line 611
    tmp___0 = 1;
  } else {
#line 611
    tmp___0 = 0;
  }
#line 611
  flags = 2 | tmp___0;
#line 612
  patlim = pattern + size;
#line 613
  n = re;
#line 618
  if ((int )eolbyte != 10) {
    {
    {
#line 619
    tmp___1 = dcgettext((char const   *)((void *)0), "The -P and -z options cannot be combined",
                        5);
    }
    {
#line 619
    error(2, 0, (char const   *)tmp___1);
    }
    }
  }
#line 621
  *n = (char )'\000';
#line 622
  if (match_lines) {
    {
    {
#line 623
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"^(");
    }
    }
  }
#line 624
  if (match_words) {
    {
    {
#line 625
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\b(");
    }
    }
  }
  {
  {
#line 626
  tmp___2 = strlen((char const   *)n);
  }
#line 626
  n += tmp___2;
#line 636
  p = pattern;
  }
  {
  {
#line 636
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 636
    tmp___3 = memchr((void const   *)p, '\000', (size_t )(patlim - p));
    }
#line 636
    pnul = (char const   *)tmp___3;
    }
#line 636
    if (! pnul) {
#line 636
      goto while_break;
    }
    {
    {
#line 638
    memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(pnul - p));
    }
#line 639
    n += pnul - p;
#line 640
    p = pnul;
    }
    {
    {
#line 640
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 640
      if ((unsigned long )pattern < (unsigned long )p) {
#line 640
        if (! ((int const   )*(p + -1) == 92)) {
#line 640
          goto while_break___0;
        }
      } else {
#line 640
        goto while_break___0;
      }
#line 641
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 640
      p --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 642
    n -= (pnul - p) & 1L;
    {
#line 643
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)"\\000");
    }
#line 644
    n += 4;
#line 636
    p = pnul + 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 647
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)p, (size_t )(patlim - p));
  }
#line 648
  n += patlim - p;
#line 649
  *n = (char )'\000';
  }
#line 650
  if (match_words) {
    {
    {
#line 651
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)")\\b");
    }
    }
  }
#line 652
  if (match_lines) {
    {
    {
#line 653
    strcpy((char */* __restrict  */)n, (char const   */* __restrict  */)")$");
    }
    }
  }
  {
  {
#line 655
  tmp___4 = pcre_maketables();
  }
  {
#line 655
  cre = pcre_compile((char const   *)re, flags, & ep, & e, tmp___4);
  }
  }
#line 656
  if (! cre) {
    {
    {
#line 657
    error(2, 0, ep);
    }
    }
  }
  {
  {
#line 659
  extra = pcre_study((pcre const   *)cre, 0, & ep);
  }
  }
#line 660
  if (ep) {
    {
    {
#line 661
    error(2, 0, ep);
    }
    }
  }
  {
  {
#line 663
  free((void *)re);
  }
  }
#line 665
  return;
}
}
#line 667 "search.c"
static size_t Pexecute(char const   *buf , size_t size , size_t *match_size , int exact ) 
{ 
  int sub[300] ;
  int e ;
  int tmp ;
  char *tmp___0 ;
  char const   *beg ;
  char const   *end ;
  char const   *buflim___0 ;
  char eol ;
  void *tmp___1 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 678
  tmp = pcre_exec((pcre const   *)cre, (pcre_extra const   *)extra, buf, (int )size,
                  0, 0, sub, (int )(sizeof(sub) / sizeof(sub[0])));
  }
#line 678
  e = tmp;
  }
#line 681
  if (e <= 0) {
    {
#line 685
    if (e == -1) {
#line 685
      goto case_neg_1;
    }
#line 688
    if (e == -6) {
#line 688
      goto case_neg_6;
    }
#line 691
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 686
    return ((size_t )-1);
    case_neg_6: /* CIL Label */ 
    {
    {
#line 689
    tmp___0 = dcgettext((char const   *)((void *)0), "Memory exhausted", 5);
    }
    {
#line 689
    error(2, 0, (char const   *)tmp___0);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 692
    abort();
    }
    }
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 698
    beg = buf + sub[0];
#line 699
    end = buf + sub[1];
#line 700
    buflim___0 = buf + size;
#line 701
    eol = (char )eolbyte;
#line 702
    if (! exact) {
      {
      {
#line 704
      tmp___1 = memchr((void const   *)end, (int )eol, (size_t )(buflim___0 - end));
      }
#line 704
      end = (char const   *)tmp___1;
#line 705
      end ++;
      }
      {
      {
#line 706
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 706
        if ((unsigned long )buf < (unsigned long )beg) {
#line 706
          if (! ((int const   )*(beg + -1) != (int const   )eol)) {
#line 706
            goto while_break;
          }
        } else {
#line 706
          goto while_break;
        }
#line 707
        beg --;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 710
    *match_size = (size_t )(end - beg);
#line 711
    return ((size_t )(beg - buf));
  }
}
}
#line 716 "search.c"
struct matcher  const  matchers[7]  = {      {{(char )'d', (char )'e', (char )'f', (char )'a', (char )'u', (char )'l', (char )'t',
       (char )'\000'}, & Gcompile, & EGexecute}, 
        {{(char )'g', (char )'r', (char )'e', (char )'p', (char )'\000'}, & Gcompile,
      & EGexecute}, 
        {{(char )'e', (char )'g', (char )'r', (char )'e', (char )'p', (char )'\000'},
      & Ecompile, & EGexecute}, 
        {{(char )'a', (char )'w', (char )'k', (char )'\000'}, & Ecompile, & EGexecute}, 
        {{(char )'f',
       (char )'g', (char )'r', (char )'e', (char )'p', (char )'\000'}, & Fcompile,
      & Fexecute}, 
        {{(char )'p', (char )'e', (char )'r', (char )'l', (char )'\000'}, & Pcompile,
      & Pexecute}, 
        {{(char )'\000'}, (void (*)(char const   * , size_t  ))0, (size_t (*)(char const   * ,
                                                                           size_t  ,
                                                                           size_t * ,
                                                                           int  ))0}};
#line 56 "kwset.h"
void kwsfree(kwset_t kws ) ;
#line 195 "../lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 197
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 223
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 95 "kwset.c"
extern int ( /* missing proto */  airac_print)() ;
#line 89 "kwset.c"
kwset_t kwsalloc(char const   *trans___0 ) 
{ 
  struct kwset *kwset___0 ;
  int tmp ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;

  {
  {
  {
#line 94
  tmp = (int )xmalloc(sizeof(struct kwset ));
  }
#line 94
  kwset___0 = (struct kwset *)tmp;
  {
#line 95
  }
  }
#line 96
  if (! kwset___0) {
    {
    {
#line 97
    }
    }
#line 98
    return ((kwset_t )0);
  }
  {
  {
#line 100
  }
  {
#line 101
  _obstack_begin(& kwset___0->obstack, 0, 0, (void *(*)(long  ))(& xmalloc), & free);
  }
#line 102
  kwset___0->words = 0;
#line 104
  __h = & kwset___0->obstack;
#line 104
  __o = __h;
#line 104
  __len = (int )sizeof(struct trie );
  }
#line 104
  if (__o->chunk_limit - __o->next_free < (long )__len) {
    {
    {
#line 104
    _obstack_newchunk(__o, __len);
    }
    }
  }
#line 104
  __o->next_free += __len;
#line 104
  __o1 = __h;
#line 104
  value = (void *)__o1->object_base;
#line 104
  if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 104
    __o1->maybe_empty_object = 1U;
  }
#line 104
  __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 104
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 104
    __o1->next_free = __o1->chunk_limit;
  }
#line 104
  __o1->object_base = __o1->next_free;
#line 104
  kwset___0->trie = (struct trie *)value;
#line 105
  if (! kwset___0->trie) {
    {
    {
#line 107
    kwsfree((kwset_t )kwset___0);
    }
    }
#line 108
    return ((kwset_t )0);
  }
#line 110
  (kwset___0->trie)->accepting = 0U;
#line 111
  (kwset___0->trie)->links = (struct tree *)0;
#line 112
  (kwset___0->trie)->parent = (struct trie *)0;
#line 113
  (kwset___0->trie)->next = (struct trie *)0;
#line 114
  (kwset___0->trie)->fail = (struct trie *)0;
#line 115
  (kwset___0->trie)->depth = 0;
#line 116
  (kwset___0->trie)->shift = 0;
#line 117
  kwset___0->mind = 2147483647;
#line 118
  kwset___0->maxd = -1;
#line 119
  kwset___0->target = (char *)0;
#line 120
  kwset___0->trans = trans___0;
#line 122
  return ((kwset_t )kwset___0);
}
}
#line 127 "kwset.c"
char *kwsincr(kwset_t kws , char const   *text , size_t len ) 
{ 
  struct kwset *kwset___0 ;
  register struct trie *trie ;
  register unsigned char label___0 ;
  register struct tree *link___0 ;
  register int depth___0 ;
  struct tree *links[12] ;
  enum __anonenum_dirs_15 dirs[12] ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  int tmp ;
  int tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;
  char *tmp___1 ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  int __len___0 ;
  struct obstack *__o1___0 ;
  void *value___0 ;
  char *tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 139
  kwset___0 = (struct kwset *)kws;
#line 140
  trie = kwset___0->trie;
#line 141
  text += len;
  {
  {
#line 145
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 145
    tmp___5 = len;
#line 145
    len --;
#line 145
    if (! tmp___5) {
#line 145
      goto while_break;
    }
#line 147
    if (kwset___0->trans) {
#line 147
      text --;
#line 147
      label___0 = (unsigned char )*(kwset___0->trans + (unsigned char )*text);
    } else {
#line 147
      text --;
#line 147
      label___0 = (unsigned char )*text;
    }
#line 152
    link___0 = trie->links;
#line 153
    links[0] = (struct tree *)(& trie->links);
#line 154
    dirs[0] = (enum __anonenum_dirs_15 )0;
#line 155
    depth___0 = 1;
    {
    {
#line 157
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 157
      if (link___0) {
#line 157
zoo_print (link___0);
zoo_print (trie);
zoo_print (trie->links);
        if (! ((int )label___0 != (int )link___0->label)) {
#line 157
          goto while_break___0;
        }
      } else {
#line 157
        goto while_break___0;
      }
#line 159
      links[depth___0] = link___0;
#line 160
      if ((int )label___0 < (int )link___0->label) {
#line 161
        tmp = depth___0;
#line 161
        depth___0 ++;
#line 161
        dirs[tmp] = (enum __anonenum_dirs_15 )0;
#line 161
        link___0 = link___0->llink;
      } else {
#line 163
        tmp___0 = depth___0;
#line 163
        depth___0 ++;
#line 163
        dirs[tmp___0] = (enum __anonenum_dirs_15 )1;
#line 163
        link___0 = link___0->rlink;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    if (! link___0) {
#line 171
      __h = & kwset___0->obstack;
#line 171
      __o = __h;
#line 171
      __len = (int )sizeof(struct tree );
#line 171
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
        {
#line 171
        _obstack_newchunk(__o, __len);
        }
        }
      }
#line 171
      __o->next_free += __len;
#line 171
      __o1 = __h;
#line 171
      value = (void *)__o1->object_base;
#line 171
      if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 171
        __o1->maybe_empty_object = 1U;
      }
#line 171
      __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 171
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 171
        __o1->next_free = __o1->chunk_limit;
      }
#line 171
      __o1->object_base = __o1->next_free;
#line 171
      link___0 = (struct tree *)value;
#line 173
      if (! link___0) {
        {
        {
#line 174
        tmp___1 = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
        }
        }
#line 174
        return (tmp___1);
      }
#line 175
      link___0->llink = (struct tree *)0;
#line 176
      link___0->rlink = (struct tree *)0;
#line 177
      __h___0 = & kwset___0->obstack;
#line 177
      __o___0 = __h___0;
#line 177
      __len___0 = (int )sizeof(struct trie );
#line 177
      if (__o___0->chunk_limit - __o___0->next_free < (long )__len___0) {
        {
        {
#line 177
        _obstack_newchunk(__o___0, __len___0);
        }
        }
      }
#line 177
      __o___0->next_free += __len___0;
#line 177
      __o1___0 = __h___0;
#line 177
      value___0 = (void *)__o1___0->object_base;
#line 177
      if ((unsigned long )__o1___0->next_free == (unsigned long )value___0) {
#line 177
        __o1___0->maybe_empty_object = 1U;
      }
#line 177
      __o1___0->next_free = (char *)0 + (((__o1___0->next_free - (char *)0) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 177
      if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 177
        __o1___0->next_free = __o1___0->chunk_limit;
      }
#line 177
      __o1___0->object_base = __o1___0->next_free;
#line 177
      link___0->trie = (struct trie *)value___0;
#line 179
      if (! link___0->trie) {
        {
        {
#line 180
        tmp___2 = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
        }
        }
#line 180
        return (tmp___2);
      }
#line 181
      (link___0->trie)->accepting = 0U;
#line 182
      (link___0->trie)->links = (struct tree *)0;
#line 183
      (link___0->trie)->parent = trie;
#line 184
      (link___0->trie)->next = (struct trie *)0;
#line 185
      (link___0->trie)->fail = (struct trie *)0;
#line 186
      (link___0->trie)->depth = trie->depth + 1;
#line 187
      (link___0->trie)->shift = 0;
#line 188
      link___0->label = label___0;
#line 189
      link___0->balance = (char)0;
#line 192
      depth___0 --;
#line 192
      if ((unsigned int )dirs[depth___0] == 0U) {
#line 193
        (links[depth___0])->llink = link___0;
      } else {
#line 195
        (links[depth___0])->rlink = link___0;
      }
      {
      {
#line 198
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 198
        if (depth___0) {
#line 198
          if (! (! (links[depth___0])->balance)) {
#line 198
            goto while_break___1;
          }
        } else {
#line 198
          goto while_break___1;
        }
#line 200
        if ((unsigned int )dirs[depth___0] == 0U) {
#line 201
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
        } else {
#line 203
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
        }
#line 204
        depth___0 --;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 208
      if (depth___0) {
#line 208
        if ((unsigned int )dirs[depth___0] == 0U) {
#line 208
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
#line 208
          if ((links[depth___0])->balance) {
#line 208
            goto _L;
          } else {
#line 208
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 208
        if ((unsigned int )dirs[depth___0] == 1U) {
#line 208
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
#line 208
          if ((links[depth___0])->balance) {
            _L: /* CIL Label */ 
            {
#line 213
            if ((int )(links[depth___0])->balance == -2) {
#line 213
              goto case_neg_2;
            }
#line 233
            if ((int )(links[depth___0])->balance == 2) {
#line 233
              goto case_2;
            }
#line 253
            goto switch_default___1;
            case_neg_2: /* CIL Label */ 
            {
#line 216
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
#line 216
              goto case_0;
            }
#line 221
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
#line 221
              goto case_1;
            }
#line 229
            goto switch_default;
            case_0: /* CIL Label */ 
#line 217
            r = links[depth___0];
#line 217
            t = r->llink;
#line 217
            rl = t->rlink;
#line 218
            t->rlink = r;
#line 218
            r->llink = rl;
#line 219
            tmp___3 = (char)0;
#line 219
            r->balance = tmp___3;
#line 219
            t->balance = tmp___3;
#line 220
            goto switch_break___0;
            case_1: /* CIL Label */ 
#line 222
            r = links[depth___0];
#line 222
            l = r->llink;
#line 222
            t = l->rlink;
#line 223
            rl = t->rlink;
#line 223
            lr = t->llink;
#line 224
            t->llink = l;
#line 224
            l->rlink = lr;
#line 224
            t->rlink = r;
#line 224
            r->llink = rl;
#line 225
            if ((int )t->balance != 1) {
#line 225
              l->balance = (char)0;
            } else {
#line 225
              l->balance = (char)-1;
            }
#line 226
            if ((int )t->balance != -1) {
#line 226
              r->balance = (char)0;
            } else {
#line 226
              r->balance = (char)1;
            }
#line 227
            t->balance = (char)0;
#line 228
            goto switch_break___0;
            switch_default: /* CIL Label */ 
            {
            {
#line 230
            abort();
            }
            }
            switch_break___0: /* CIL Label */ ;
            }
#line 232
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 236
            if ((unsigned int )dirs[depth___0 + 1] == 1U) {
#line 236
              goto case_1___0;
            }
#line 241
            if ((unsigned int )dirs[depth___0 + 1] == 0U) {
#line 241
              goto case_0___0;
            }
#line 249
            goto switch_default___0;
            case_1___0: /* CIL Label */ 
#line 237
            l = links[depth___0];
#line 237
            t = l->rlink;
#line 237
            lr = t->llink;
#line 238
            t->llink = l;
#line 238
            l->rlink = lr;
#line 239
            tmp___4 = (char)0;
#line 239
            l->balance = tmp___4;
#line 239
            t->balance = tmp___4;
#line 240
            goto switch_break___1;
            case_0___0: /* CIL Label */ 
#line 242
            l = links[depth___0];
#line 242
            r = l->rlink;
#line 242
            t = r->llink;
#line 243
            lr = t->llink;
#line 243
            rl = t->rlink;
#line 244
            t->llink = l;
#line 244
            l->rlink = lr;
#line 244
            t->rlink = r;
#line 244
            r->llink = rl;
#line 245
            if ((int )t->balance != 1) {
#line 245
              l->balance = (char)0;
            } else {
#line 245
              l->balance = (char)-1;
            }
#line 246
            if ((int )t->balance != -1) {
#line 246
              r->balance = (char)0;
            } else {
#line 246
              r->balance = (char)1;
            }
#line 247
            t->balance = (char)0;
#line 248
            goto switch_break___1;
            switch_default___0: /* CIL Label */ 
            {
            {
#line 250
            abort();
            }
            }
            switch_break___1: /* CIL Label */ ;
            }
#line 252
            goto switch_break;
            switch_default___1: /* CIL Label */ 
            {
            {
#line 254
            abort();
            }
            }
            switch_break: /* CIL Label */ ;
            }
#line 257
            if ((unsigned int )dirs[depth___0 - 1] == 0U) {
#line 258
              (links[depth___0 - 1])->llink = t;
            } else {
#line 260
              (links[depth___0 - 1])->rlink = t;
            }
          }
        }
      }
    }
#line 264
    trie = link___0->trie;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  if (! trie->accepting) {
#line 270
    trie->accepting = (unsigned int )(1 + 2 * kwset___0->words);
  }
#line 271
  (kwset___0->words) ++;
#line 274
  if (trie->depth < kwset___0->mind) {
#line 275
    kwset___0->mind = trie->depth;
  }
#line 276
  if (trie->depth > kwset___0->maxd) {
#line 277
    kwset___0->maxd = trie->depth;
  }
#line 279
  return ((char *)0);
}
}
#line 284 "kwset.c"
static void enqueue(struct tree *tree , struct trie **last ) 
{ 
  struct trie *tmp ;

  {
#line 287
  if (! tree) {
#line 288
    return;
  }
  {
  {
#line 289
  enqueue(tree->llink, last);
  }
  {
#line 290
  enqueue(tree->rlink, last);
  }
#line 291
  tmp = tree->trie;
#line 291
  (*last)->next = tmp;
#line 291
  *last = tmp;
  }
#line 292
  return;
}
}
#line 297 "kwset.c"
static void treefails(struct tree  const  *tree , struct trie  const  *fail , struct trie *recourse ) 
{ 
  register struct tree *link___0 ;

  {
#line 303
  if (! tree) {
#line 304
    return;
  }
  {
  {
#line 306
  treefails((struct tree  const  *)tree->llink, fail, recourse);
  }
  {
#line 307
  treefails((struct tree  const  *)tree->rlink, fail, recourse);
  }
  }
  {
  {
#line 311
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 311
    if (! fail) {
#line 311
      goto while_break;
    }
#line 313
    link___0 = (struct tree *)fail->links;
    {
    {
#line 314
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 314
      if (link___0) {
#line 314
        if (! ((int const   )tree->label != (int const   )link___0->label)) {
#line 314
          goto while_break___0;
        }
      } else {
#line 314
        goto while_break___0;
      }
#line 315
      if ((int const   )tree->label < (int const   )link___0->label) {
#line 316
        link___0 = link___0->llink;
      } else {
#line 318
        link___0 = link___0->rlink;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 319
    if (link___0) {
#line 321
      (tree->trie)->fail = link___0->trie;
#line 322
      return;
    }
#line 324
    fail = (struct trie  const  *)fail->fail;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  (tree->trie)->fail = recourse;
#line 328
  return;
}
}
#line 332 "kwset.c"
static void treedelta(struct tree  const  *tree , unsigned int depth___0 , unsigned char *delta ) 
{ 


  {
#line 337
  if (! tree) {
#line 338
    return;
  }
  {
  {
#line 339
  treedelta((struct tree  const  *)tree->llink, depth___0, delta);
  }
  {
#line 340
  treedelta((struct tree  const  *)tree->rlink, depth___0, delta);
  }
  }
#line 341
  if (depth___0 < (unsigned int )*(delta + tree->label)) {
#line 342
    *(delta + tree->label) = (unsigned char )depth___0;
  }
#line 343
  return;
}
}
#line 346 "kwset.c"
static int hasevery(struct tree  const  *a , struct tree  const  *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 349
  if (! b) {
#line 350
    return (1);
  }
  {
  {
#line 351
  tmp = hasevery(a, (struct tree  const  *)b->llink);
  }
  }
#line 351
  if (! tmp) {
#line 352
    return (0);
  }
  {
  {
#line 353
  tmp___0 = hasevery(a, (struct tree  const  *)b->rlink);
  }
  }
#line 353
  if (! tmp___0) {
#line 354
    return (0);
  }
  {
  {
#line 355
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 355
    if (a) {
#line 355
      if (! ((int const   )b->label != (int const   )a->label)) {
#line 355
        goto while_break;
      }
    } else {
#line 355
      goto while_break;
    }
#line 356
    if ((int const   )b->label < (int const   )a->label) {
#line 357
      a = (struct tree  const  *)a->llink;
    } else {
#line 359
      a = (struct tree  const  *)a->rlink;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return (! (! a));
}
}
#line 365 "kwset.c"
static void treenext(struct tree  const  *tree , struct trie **next ) 
{ 


  {
#line 368
  if (! tree) {
#line 369
    return;
  }
  {
  {
#line 370
  treenext((struct tree  const  *)tree->llink, next);
  }
  {
#line 371
  treenext((struct tree  const  *)tree->rlink, next);
  }
#line 372
  *(next + tree->label) = (struct trie *)tree->trie;
  }
#line 373
  return;
}
}
#line 377 "kwset.c"
char *kwsprep(kwset_t kws ) 
{ 
  register struct kwset *kwset___0 ;
  register int i ;
  register struct trie *curr ;
  register struct trie *fail ;
  register char const   *trans___0 ;
  unsigned char delta[256] ;
  struct trie *last ;
  struct trie *next[256] ;
  struct obstack *__h ;
  struct obstack *__o ;
  int __len ;
  struct obstack *__o1 ;
  void *value ;
  int tmp ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 387
  kwset___0 = (struct kwset *)kws;
#line 392
  if (kwset___0->mind < 256) {
#line 393
    i = 0;
    {
    {
#line 393
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 393
      if (! (i < 256)) {
#line 393
        goto while_break;
      }
#line 394
      delta[i] = (unsigned char )kwset___0->mind;
#line 393
      i ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 396
    i = 0;
    {
    {
#line 396
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! (i < 256)) {
#line 396
        goto while_break___0;
      }
#line 397
      delta[i] = (unsigned char)255;
#line 396
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 401
  if (kwset___0->words == 1) {
#line 401
    if ((unsigned long )kwset___0->trans == (unsigned long )((char const   *)0)) {
#line 404
      __h = & kwset___0->obstack;
#line 404
      __o = __h;
#line 404
      __len = kwset___0->mind;
#line 404
      if (__o->chunk_limit - __o->next_free < (long )__len) {
        {
        {
#line 404
        _obstack_newchunk(__o, __len);
        }
        }
      }
#line 404
      __o->next_free += __len;
#line 404
      __o1 = __h;
#line 404
      value = (void *)__o1->object_base;
#line 404
      if ((unsigned long )__o1->next_free == (unsigned long )value) {
#line 404
        __o1->maybe_empty_object = 1U;
      }
#line 404
      __o1->next_free = (char *)0 + (((__o1->next_free - (char *)0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 404
      if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 404
        __o1->next_free = __o1->chunk_limit;
      }
#line 404
      __o1->object_base = __o1->next_free;
#line 404
      kwset___0->target = (char *)value;
#line 405
      i = kwset___0->mind - 1;
#line 405
      curr = kwset___0->trie;
      {
      {
#line 405
      while (1) {
        while_continue___14: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 405
        if (! (i >= 0)) {
#line 405
          goto while_break___1;
        }
#line 407
        *(kwset___0->target + i) = (char )(curr->links)->label;
#line 408
        curr = (curr->links)->trie;
#line 405
        i --;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 411
      i = 0;
      {
      {
#line 411
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 411
        if (! (i < kwset___0->mind)) {
#line 411
          goto while_break___2;
        }
#line 412
        delta[(unsigned char )*(kwset___0->target + i)] = (unsigned char )(kwset___0->mind - (i + 1));
#line 411
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 413
      kwset___0->mind2 = kwset___0->mind;
#line 416
      i = 0;
      {
      {
#line 416
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 416
        if (! (i < kwset___0->mind - 1)) {
#line 416
          goto while_break___3;
        }
#line 417
        if ((int )*(kwset___0->target + i) == (int )*(kwset___0->target + (kwset___0->mind - 1))) {
#line 418
          kwset___0->mind2 = kwset___0->mind - (i + 1);
        }
#line 416
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 401
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 424
    last = kwset___0->trie;
#line 424
    curr = last;
    {
    {
#line 424
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 424
      if (! curr) {
#line 424
        goto while_break___4;
      }
      {
      {
#line 427
      enqueue(curr->links, & last);
      }
#line 429
      curr->shift = kwset___0->mind;
#line 430
      curr->maxshift = kwset___0->mind;
      {
#line 433
      treedelta((struct tree  const  *)curr->links, (unsigned int )curr->depth, delta);
      }
      {
#line 436
      treefails((struct tree  const  *)curr->links, (struct trie  const  *)curr->fail,
                kwset___0->trie);
      }
#line 440
      fail = curr->fail;
      }
      {
      {
#line 440
      while (1) {
        while_continue___18: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 440
        if (! fail) {
#line 440
          goto while_break___5;
        }
        {
        {
#line 445
        tmp = hasevery((struct tree  const  *)fail->links, (struct tree  const  *)curr->links);
        }
        }
#line 445
        if (! tmp) {
#line 446
          if (curr->depth - fail->depth < fail->shift) {
#line 447
            fail->shift = curr->depth - fail->depth;
          }
        }
#line 452
        if (curr->accepting) {
#line 452
          if (fail->maxshift > curr->depth - fail->depth) {
#line 453
            fail->maxshift = curr->depth - fail->depth;
          }
        }
#line 440
        fail = fail->fail;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 424
      curr = curr->next;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 459
    curr = (kwset___0->trie)->next;
    {
    {
#line 459
    while (1) {
      while_continue___19: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 459
      if (! curr) {
#line 459
        goto while_break___6;
      }
#line 461
      if (curr->maxshift > (curr->parent)->maxshift) {
#line 462
        curr->maxshift = (curr->parent)->maxshift;
      }
#line 463
      if (curr->shift > curr->maxshift) {
#line 464
        curr->shift = curr->maxshift;
      }
#line 459
      curr = curr->next;
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 469
    i = 0;
    {
    {
#line 469
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 469
      if (! (i < 256)) {
#line 469
        goto while_break___7;
      }
#line 470
      next[i] = (struct trie *)0;
#line 469
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
    {
#line 471
    treenext((struct tree  const  *)(kwset___0->trie)->links, next);
    }
#line 473
    trans___0 = kwset___0->trans;
    }
#line 473
    if ((unsigned long )trans___0 != (unsigned long )((char const   *)0)) {
#line 474
      i = 0;
      {
      {
#line 474
      while (1) {
        while_continue___21: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 474
        if (! (i < 256)) {
#line 474
          goto while_break___8;
        }
#line 475
        kwset___0->next[i] = next[(unsigned char )*(trans___0 + i)];
#line 474
        i ++;
      }
      while_break___21: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
#line 477
      i = 0;
      {
      {
#line 477
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 477
        if (! (i < 256)) {
#line 477
          goto while_break___9;
        }
#line 478
        kwset___0->next[i] = next[i];
#line 477
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
  }
#line 482
  trans___0 = kwset___0->trans;
#line 482
  if ((unsigned long )trans___0 != (unsigned long )((char const   *)0)) {
#line 483
    i = 0;
    {
    {
#line 483
    while (1) {
      while_continue___23: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 483
      if (! (i < 256)) {
#line 483
        goto while_break___10;
      }
#line 484
      kwset___0->delta[i] = delta[(unsigned char )*(trans___0 + i)];
#line 483
      i ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
  } else {
#line 486
    i = 0;
    {
    {
#line 486
    while (1) {
      while_continue___24: /* CIL Label */ ;
      while_continue___11: /* CIL Label */ ;
#line 486
      if (! (i < 256)) {
#line 486
        goto while_break___11;
      }
#line 487
      kwset___0->delta[i] = delta[i];
#line 486
      i ++;
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 489
  return ((char *)0);
}
}
#line 495 "kwset.c"
static size_t bmexec(kwset_t kws , char const   *text , size_t size ) 
{ 
  struct kwset  const  *kwset___0 ;
  register unsigned char const   *d1 ;
  register char const   *ep ;
  register char const   *sp ;
  register char const   *tp ;
  register int d ;
  register int gc ;
  register int i ;
  register int len ;
  register int md2 ;
  void *tmp ;
  long tmp___0 ;

  {
#line 503
  kwset___0 = (struct kwset  const  *)kws;
#line 504
  len = (int )kwset___0->mind;
#line 506
  if (len == 0) {
#line 507
    return ((size_t )0);
  }
#line 508
  if ((size_t )len > size) {
#line 509
    return ((size_t )-1);
  }
#line 510
  if (len == 1) {
    {
    {
#line 512
    tmp = memchr((void const   *)text, (int )*(kwset___0->target + 0), size);
    }
#line 512
    tp = (char const   *)tmp;
    }
#line 513
    if (tp) {
#line 513
      tmp___0 = tp - text;
    } else {
#line 513
      tmp___0 = -1L;
    }
#line 513
    return ((size_t )tmp___0);
  }
#line 516
  d1 = (unsigned char const   *)(kwset___0->delta);
#line 517
  sp = (char const   *)(kwset___0->target + len);
#line 518
  gc = (int )((unsigned char )*(sp + -2));
#line 519
  md2 = (int )kwset___0->mind2;
#line 520
  tp = text + len;
#line 523
  if (size > (size_t )(12 * len)) {
#line 525
    ep = (text + size) - 11 * len;
    {
    {
#line 525
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 527
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 527
        if (! ((unsigned long )tp <= (unsigned long )ep)) {
#line 527
          goto while_break___0;
        }
#line 529
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 529
        tp += d;
#line 530
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 530
        tp += d;
#line 531
        if (d == 0) {
#line 532
          goto found;
        }
#line 533
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 533
        tp += d;
#line 534
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 534
        tp += d;
#line 535
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 535
        tp += d;
#line 536
        if (d == 0) {
#line 537
          goto found;
        }
#line 538
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 538
        tp += d;
#line 539
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 539
        tp += d;
#line 540
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 540
        tp += d;
#line 541
        if (d == 0) {
#line 542
          goto found;
        }
#line 543
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 543
        tp += d;
#line 544
        d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 544
        tp += d;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 546
      goto while_break;
      found: 
#line 548
      if ((int )((unsigned char )*(tp + -2)) == gc) {
#line 550
        i = 3;
        {
        {
#line 550
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 550
          if (i <= len) {
#line 550
            if (! ((int )((unsigned char )*(tp + - i)) == (int )((unsigned char )*(sp + - i)))) {
#line 550
              goto while_break___1;
            }
          } else {
#line 550
            goto while_break___1;
          }
#line 550
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 552
        if (i > len) {
#line 553
          return ((size_t )((tp - len) - text));
        }
      }
#line 555
      tp += md2;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 560
  ep = text + size;
#line 561
  d = (int )*(d1 + (unsigned char )*(tp + -1));
  {
  {
#line 562
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 562
    if (! ((long )d <= ep - tp)) {
#line 562
      goto while_break___2;
    }
#line 564
    tp += d;
#line 564
    d = (int )*(d1 + (unsigned char )*(tp + -1));
#line 565
    if (d != 0) {
#line 566
      goto while_continue___2;
    }
#line 567
    if ((int )((unsigned char )*(tp + -2)) == gc) {
#line 569
      i = 3;
      {
      {
#line 569
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 569
        if (i <= len) {
#line 569
          if (! ((int )((unsigned char )*(tp + - i)) == (int )((unsigned char )*(sp + - i)))) {
#line 569
            goto while_break___3;
          }
        } else {
#line 569
          goto while_break___3;
        }
#line 569
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 571
      if (i > len) {
#line 572
        return ((size_t )((tp - len) - text));
      }
    }
#line 574
    d = md2;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 577
  return ((size_t )-1);
}
}
#line 581 "kwset.c"
static size_t cwexec(kwset_t kws , char const   *text , size_t len , struct kwsmatch *kwsmatch ) 
{ 
  struct kwset  const  *kwset___0 ;
  struct trie * const  *next ;
  struct trie  const  *trie ;
  struct trie  const  *accept ;
  char const   *beg ;
  char const   *lim ;
  char const   *mch ;
  char const   *lmch ;
  register unsigned char c ;
  register unsigned char const   *delta ;
  register int d ;
  register char const   *end ;
  register char const   *qlim ;
  register struct tree  const  *tree ;
  register char const   *trans___0 ;

  {
#line 601
  kwset___0 = (struct kwset  const  *)((struct kwset *)kws);
#line 602
  if (len < (size_t )kwset___0->mind) {
#line 603
    return ((size_t )-1);
  }
#line 604
  next = (struct trie * const  *)(kwset___0->next);
#line 605
  delta = (unsigned char const   *)(kwset___0->delta);
#line 606
  trans___0 = (char const   *)kwset___0->trans;
#line 607
  lim = text + len;
#line 608
  end = text;
#line 609
  d = (int )kwset___0->mind;
#line 609
  if (d != 0) {
#line 610
    mch = (char const   *)0;
  } else {
#line 613
    mch = text;
#line 613
    accept = (struct trie  const  *)kwset___0->trie;
#line 614
    goto match;
  }
#line 617
  if (len >= (size_t )(4 * (int )kwset___0->mind)) {
#line 618
    qlim = lim - 4 * (int )kwset___0->mind;
  } else {
#line 620
    qlim = (char const   *)0;
  }
  {
  {
#line 622
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 622
    if (! (lim - end >= (long )d)) {
#line 622
      goto while_break;
    }
#line 624
    if (qlim) {
#line 624
      if ((unsigned long )end <= (unsigned long )qlim) {
#line 626
        end += d - 1;
        {
        {
#line 627
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 627
          c = (unsigned char )*end;
#line 627
          d = (int )*(delta + c);
#line 627
          if (d) {
#line 627
            if (! ((unsigned long )end < (unsigned long )qlim)) {
#line 627
              goto while_break___0;
            }
          } else {
#line 627
            goto while_break___0;
          }
#line 629
          end += d;
#line 630
          end += (int const   )*(delta + (unsigned char )*end);
#line 631
          end += (int const   )*(delta + (unsigned char )*end);
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 633
        end ++;
      } else {
#line 636
        end += d;
#line 636
        c = (unsigned char )*(end + -1);
#line 636
        d = (int )*(delta + c);
      }
    } else {
#line 636
      end += d;
#line 636
      c = (unsigned char )*(end + -1);
#line 636
      d = (int )*(delta + c);
    }
#line 637
    if (d) {
#line 638
      goto while_continue;
    }
#line 639
    beg = end - 1;
#line 640
    trie = (struct trie  const  *)*(next + c);
#line 641
    if (trie->accepting) {
#line 643
      mch = beg;
#line 644
      accept = trie;
    }
#line 646
    d = (int )trie->shift;
    {
    {
#line 647
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 647
      if (! ((unsigned long )beg > (unsigned long )text)) {
#line 647
        goto while_break___1;
      }
#line 649
      if (trans___0) {
#line 649
        beg --;
#line 649
        c = (unsigned char )*(trans___0 + (unsigned char )*beg);
      } else {
#line 649
        beg --;
#line 649
        c = (unsigned char )*beg;
      }
#line 650
      tree = (struct tree  const  *)trie->links;
      {
      {
#line 651
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 651
        if (tree) {
#line 651
          if (! ((int )c != (int )tree->label)) {
#line 651
            goto while_break___2;
          }
        } else {
#line 651
          goto while_break___2;
        }
#line 652
        if ((int )c < (int )tree->label) {
#line 653
          tree = (struct tree  const  *)tree->llink;
        } else {
#line 655
          tree = (struct tree  const  *)tree->rlink;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 656
      if (tree) {
#line 658
        trie = (struct trie  const  *)tree->trie;
#line 659
        if (trie->accepting) {
#line 661
          mch = beg;
#line 662
          accept = trie;
        }
      } else {
#line 666
        goto while_break___1;
      }
#line 667
      d = (int )trie->shift;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 669
    if (mch) {
#line 670
      goto match;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  return ((size_t )-1);
  match: 
#line 678
  if (lim - mch > (long )kwset___0->maxd) {
#line 679
    lim = mch + kwset___0->maxd;
  }
#line 680
  lmch = (char const   *)0;
#line 681
  d = 1;
  {
  {
#line 682
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 682
    if (! (lim - end >= (long )d)) {
#line 682
      goto while_break___3;
    }
#line 684
    end += d;
#line 684
    c = (unsigned char )*(end + -1);
#line 684
    d = (int )*(delta + c);
#line 684
    if (d != 0) {
#line 685
      goto while_continue___3;
    }
#line 686
    beg = end - 1;
#line 687
    trie = (struct trie  const  *)*(next + c);
#line 687
    if (! trie) {
#line 689
      d = 1;
#line 690
      goto while_continue___3;
    }
#line 692
    if (trie->accepting) {
#line 692
      if ((unsigned long )beg <= (unsigned long )mch) {
#line 694
        lmch = beg;
#line 695
        accept = trie;
      }
    }
#line 697
    d = (int )trie->shift;
    {
    {
#line 698
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 698
      if (! ((unsigned long )beg > (unsigned long )text)) {
#line 698
        goto while_break___4;
      }
#line 700
      if (trans___0) {
#line 700
        beg --;
#line 700
        c = (unsigned char )*(trans___0 + (unsigned char )*beg);
      } else {
#line 700
        beg --;
#line 700
        c = (unsigned char )*beg;
      }
#line 701
      tree = (struct tree  const  *)trie->links;
      {
      {
#line 702
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 702
        if (tree) {
#line 702
          if (! ((int )c != (int )tree->label)) {
#line 702
            goto while_break___5;
          }
        } else {
#line 702
          goto while_break___5;
        }
#line 703
        if ((int )c < (int )tree->label) {
#line 704
          tree = (struct tree  const  *)tree->llink;
        } else {
#line 706
          tree = (struct tree  const  *)tree->rlink;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 707
      if (tree) {
#line 709
        trie = (struct trie  const  *)tree->trie;
#line 710
        if (trie->accepting) {
#line 710
          if ((unsigned long )beg <= (unsigned long )mch) {
#line 712
            lmch = beg;
#line 713
            accept = trie;
          }
        }
      } else {
#line 717
        goto while_break___4;
      }
#line 718
      d = (int )trie->shift;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 720
    if (lmch) {
#line 722
      mch = lmch;
#line 723
      goto match;
    }
#line 725
    if (! d) {
#line 726
      d = 1;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 729
  if (kwsmatch) {
#line 731
    kwsmatch->index = (int )(accept->accepting / 2U);
#line 732
    kwsmatch->offset[0] = (size_t )(mch - text);
#line 733
    kwsmatch->size[0] = (size_t )accept->depth;
  }
#line 735
  return ((size_t )(mch - text));
}
}
#line 742 "kwset.c"
size_t kwsexec(kwset_t kws , char const   *text , size_t size , struct kwsmatch *kwsmatch ) 
{ 
  struct kwset  const  *kwset___0 ;
  size_t ret ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 746
  kwset___0 = (struct kwset  const  *)((struct kwset *)kws);
#line 747
  if (kwset___0->words == 1) {
#line 747
    if ((unsigned long )kwset___0->trans == (unsigned long )((char const   */* const  */)0)) {
      {
      {
#line 749
      tmp = bmexec(kws, text, size);
      }
#line 749
      ret = tmp;
      }
#line 750
      if ((unsigned long )kwsmatch != (unsigned long )((struct kwsmatch *)0)) {
#line 750
        if (ret != 4294967295U) {
#line 752
          kwsmatch->index = 0;
#line 753
          kwsmatch->offset[0] = ret;
#line 754
          kwsmatch->size[0] = (size_t )kwset___0->mind;
        }
      }
#line 756
      return (ret);
    } else {
      {
      {
#line 759
      tmp___0 = cwexec(kws, text, size, kwsmatch);
      }
      }
#line 759
      return (tmp___0);
    }
  } else {
    {
    {
#line 759
    tmp___0 = cwexec(kws, text, size, kwsmatch);
    }
    }
#line 759
    return (tmp___0);
  }
}
}
#line 763 "kwset.c"
void kwsfree(kwset_t kws ) 
{ 
  struct kwset *kwset___0 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 768
  kwset___0 = (struct kwset *)kws;
#line 769
  __o = & kwset___0->obstack;
#line 769
  __obj = (void *)0;
#line 769
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 769
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 769
      tmp = (char *)__obj;
#line 769
      __o->object_base = tmp;
#line 769
      __o->next_free = tmp;
    } else {
      {
      {
#line 769
      obstack_free(__o, __obj);
      }
      }
    }
  } else {
    {
    {
#line 769
    obstack_free(__o, __obj);
    }
    }
  }
  {
  {
#line 770
  free(kws);
  }
  }
#line 771
  return;
}
}
#line 85 "/usr/include/string.h"
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 103
extern int strcoll(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 178 "/usr/include/wchar.h"
extern int wcscoll(wchar_t const   *__s1 , wchar_t const   *__s2 ) ;
#line 126 "/usr/include/wctype.h"
extern int iswalnum(wint_t __wc ) ;
#line 186
extern wctype_t wctype(char const   *__property ) ;
#line 190
extern int iswctype(wint_t __wc , wctype_t __desc ) ;
#line 539 "../lib/posix/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 543
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t *__pmatch , int __eflags ) ;
#line 551
extern void regfree(regex_t *__preg ) ;
#line 409 "dfa.h"
void dfafree(struct dfa *d ) ;
#line 414
void dfainit(struct dfa *d ) ;
#line 417
void dfaparse(char const   *s , size_t len , struct dfa *d ) ;
#line 421
void dfaanalyze(struct dfa *d , int searchflag ) ;
#line 425
void dfastate(int s , struct dfa *d , int *trans___0 ) ;
#line 127 "dfa.c"
static void dfamust(struct dfa *dfa___1 ) ;
#line 128
static void regexp(int toplevel ) ;
#line 130 "dfa.c"
static ptr_t xcalloc___0(size_t n , size_t s ) 
{ 
  ptr_t r ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 133
  tmp = calloc(n, s);
  }
#line 133
  r = tmp;
  }
#line 135
  if (! r) {
    {
    {
#line 136
    tmp___0 = dcgettext((char const   *)((void *)0), "Memory exhausted", 5);
    }
    {
#line 136
    dfaerror((char const   *)tmp___0);
    }
    }
  }
#line 137
  return (r);
}
}
#line 140 "dfa.c"
static ptr_t xmalloc___0(size_t n ) 
{ 
  ptr_t r ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 143
  tmp = malloc(n);
  }
#line 143
  r = tmp;
  }
#line 146
  if (! r) {
    {
    {
#line 147
    tmp___0 = dcgettext((char const   *)((void *)0), "Memory exhausted", 5);
    }
    {
#line 147
    dfaerror((char const   *)tmp___0);
    }
    }
  }
#line 148
  return (r);
}
}
#line 151 "dfa.c"
static ptr_t xrealloc___0(ptr_t p , size_t n ) 
{ 
  ptr_t r ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 154
  tmp = realloc(p, n);
  }
#line 154
  r = tmp;
  }
#line 157
  if (! r) {
    {
    {
#line 158
    tmp___0 = dcgettext((char const   *)((void *)0), "Memory exhausted", 5);
    }
    {
#line 158
    dfaerror((char const   *)tmp___0);
    }
    }
  }
#line 159
  return (r);
}
}
#line 221 "dfa.c"
static int tstbit(unsigned int b , int *c ) 
{ 


  {
#line 224
  return (*(c + (unsigned long )b / (8UL * sizeof(int ))) & (1 << (unsigned long )b % (8UL * sizeof(int ))));
}
}
#line 227 "dfa.c"
static void setbit(unsigned int b , int *c ) 
{ 


  {
#line 230
  *(c + (unsigned long )b / (8UL * sizeof(int ))) |= 1 << (unsigned long )b % (8UL * sizeof(int ));
#line 231
  return;
}
}
#line 233 "dfa.c"
static void clrbit(unsigned int b , int *c ) 
{ 


  {
#line 236
  *(c + (unsigned long )b / (8UL * sizeof(int ))) &= ~ (1 << (unsigned long )b % (8UL * sizeof(int )));
#line 237
  return;
}
}
#line 239 "dfa.c"
static void copyset(int *src , int *dst ) 
{ 


  {
  {
  {
#line 242
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, (size_t )sizeof(charclass ));
  }
  }
#line 243
  return;
}
}
#line 245 "dfa.c"
static void zeroset(int *s ) 
{ 
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_27 *__u ;
  __uint8_t __c ;
  void *__s___1 ;

  {
#line 248
  if (sizeof(charclass ) <= 16UL) {
#line 248
    if (sizeof(charclass ) == 1UL) {
#line 248
      __s___1 = (void *)s;
#line 248
      *((__uint8_t *)__s___1) = (__uint8_t )0;
    } else {
#line 248
      __s___0 = (void *)s;
#line 248
      __u = (union __anonunion___u_27 *)__s___0;
#line 248
      __c = (__uint8_t )0;
      {
#line 248
      if ((unsigned int )sizeof(charclass ) == 15U) {
#line 248
        goto case_15;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 11U) {
#line 248
        goto case_11;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 7U) {
#line 248
        goto case_7;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 3U) {
#line 248
        goto case_3;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 14U) {
#line 248
        goto case_14;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 10U) {
#line 248
        goto case_10;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 6U) {
#line 248
        goto case_6;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 2U) {
#line 248
        goto case_2;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 13U) {
#line 248
        goto case_13;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 9U) {
#line 248
        goto case_9;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 5U) {
#line 248
        goto case_5;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 1U) {
#line 248
        goto case_1;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 16U) {
#line 248
        goto case_16;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 12U) {
#line 248
        goto case_12;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 8U) {
#line 248
        goto case_8;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 4U) {
#line 248
        goto case_4;
      }
#line 248
      if ((unsigned int )sizeof(charclass ) == 0U) {
#line 248
        goto case_0;
      }
#line 248
      goto switch_break;
      case_15: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_11: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_7: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_3: /* CIL Label */ 
#line 248
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 2);
#line 248
      __u->__uc = __c;
#line 248
      goto switch_break;
      case_14: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_10: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_6: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_2: /* CIL Label */ 
#line 248
      __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 248
      goto switch_break;
      case_13: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_9: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_5: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_1: /* CIL Label */ 
#line 248
      __u->__uc = __c;
#line 248
      goto switch_break;
      case_16: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_12: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_8: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
#line 248
      __u = (union __anonunion___u_27 *)((void *)__u + 4);
      case_4: /* CIL Label */ 
#line 248
      __u->__ui = (unsigned int )((int )__c * 16843009);
      case_0: /* CIL Label */ 
#line 248
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 248
    __s = (void *)s;
    {
#line 248
    __builtin_memset(__s, '\000', (int )sizeof(charclass ));
    }
    }
  }
#line 249
  return;
}
}
#line 251 "dfa.c"
static void notset(int *s ) 
{ 
  int i ;

  {
#line 256
  i = 0;
  {
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 256
      goto while_break;
    }
#line 257
    *(s + i) = ~ *(s + i);
#line 256
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 260 "dfa.c"
static int equal(int *s1 , int *s2 ) 
{ 
  int tmp ;

  {
  {
  {
#line 263
  tmp = memcmp((void const   *)s1, (void const   *)s2, (size_t )sizeof(charclass ));
  }
  }
#line 263
  return (tmp == 0);
}
}
#line 267 "dfa.c"
static struct dfa *dfa___0  ;
#line 270 "dfa.c"
static int charclass_index(int *s ) 
{ 
  int i ;
  int tmp ;
  ptr_t tmp___0 ;

  {
#line 275
  i = 0;
  {
  {
#line 275
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 275
    if (! (i < dfa___0->cindex)) {
#line 275
      goto while_break;
    }
    {
    {
#line 276
    tmp = equal(s, *(dfa___0->charclasses + i));
    }
    }
#line 276
    if (tmp) {
#line 277
      return (i);
    }
#line 275
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  if (dfa___0->cindex >= dfa___0->calloc) {
    {
    {
#line 278
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 278
      dfa___0->calloc *= 2;
#line 278
      if (! (dfa___0->cindex >= dfa___0->calloc)) {
#line 278
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 278
    tmp___0 = xrealloc___0((ptr_t )dfa___0->charclasses, (size_t )((unsigned long )dfa___0->calloc * sizeof(charclass )));
    }
#line 278
    dfa___0->charclasses = (charclass *)tmp___0;
    }
  }
  {
#line 279
  (dfa___0->cindex) ++;
  {
#line 280
  copyset(s, *(dfa___0->charclasses + i));
  }
  }
#line 281
  return (i);
}
}
#line 285 "dfa.c"
static reg_syntax_t syntax_bits  ;
#line 285 "dfa.c"
static reg_syntax_t syntax_bits_set  ;
#line 288 "dfa.c"
static int case_fold  ;
#line 291 "dfa.c"
static unsigned char eolbyte___0  ;
#line 294 "dfa.c"
void dfasyntax(reg_syntax_t bits , int fold , unsigned char eol ) 
{ 


  {
#line 297
  syntax_bits_set = (reg_syntax_t )1;
#line 298
  syntax_bits = bits;
#line 299
  case_fold = fold;
#line 300
  eolbyte___0 = eol;
#line 301
  return;
}
}
#line 304 "dfa.c"
static void setbit_case_fold(unsigned int b , int *c ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
  {
#line 307
  setbit(b, c);
  }
  }
#line 308
  if (case_fold) {
    {
    {
#line 310
    tmp___4 = __ctype_b_loc();
    }
    }
#line 310
    if ((int const   )*(*tmp___4 + (int )b) & 256) {
#line 311
      if (sizeof(b) > 1UL) {
        {
        {
#line 311
        __res = tolower((int )b);
        }
        }
      } else {
        {
        {
#line 311
        tmp___0 = __ctype_tolower_loc();
        }
#line 311
        __res = (int )*(*tmp___0 + (int )b);
        }
      }
      {
      {
#line 311
      setbit((unsigned int )__res, c);
      }
      }
    } else {
      {
      {
#line 312
      tmp___3 = __ctype_b_loc();
      }
      }
#line 312
      if ((int const   )*(*tmp___3 + (int )b) & 512) {
#line 313
        if (sizeof(b) > 1UL) {
          {
          {
#line 313
          __res___0 = toupper((int )b);
          }
          }
        } else {
          {
          {
#line 313
          tmp___2 = __ctype_toupper_loc();
          }
#line 313
          __res___0 = (int )*(*tmp___2 + (int )b);
          }
        }
        {
        {
#line 313
        setbit((unsigned int )__res___0, c);
        }
        }
      }
    }
  }
#line 315
  return;
}
}
#line 322 "dfa.c"
static char const   *lexstart  ;
#line 323 "dfa.c"
static char const   *lexptr  ;
#line 324 "dfa.c"
static int lexleft  ;
#line 325 "dfa.c"
static token lasttok  ;
#line 326 "dfa.c"
static int laststart  ;
#line 328 "dfa.c"
static int parens  ;
#line 329 "dfa.c"
static int minrep  ;
#line 329 "dfa.c"
static int maxrep  ;
#line 330 "dfa.c"
static int hard_LC_COLLATE  ;
#line 334 "dfa.c"
static mbstate_t mbs  ;
#line 335 "dfa.c"
static int cur_mb_len  ;
#line 337 "dfa.c"
static int cur_mb_index  ;
#line 346 "dfa.c"
static unsigned char *mblen_buf  ;
#line 355 "dfa.c"
static wchar_t *inputwcs  ;
#line 362 "dfa.c"
static unsigned char const   *buf_begin  ;
#line 363 "dfa.c"
static unsigned char const   *buf_end  ;
#line 369 "dfa.c"
static void update_mb_len_index(unsigned char const   *p , int len ) 
{ 
  size_t tmp ;

  {
#line 374
  if (cur_mb_index) {
#line 375
    if (cur_mb_index >= cur_mb_len) {
#line 375
      cur_mb_index = 0;
    } else {
#line 375
      cur_mb_index ++;
    }
  }
#line 381
  if (! cur_mb_index) {
    {
    {
#line 383
    tmp = mbrlen((char const   */* __restrict  */)p, (size_t )len, (mbstate_t */* __restrict  */)(& mbs));
    }
#line 383
    cur_mb_len = (int )tmp;
    }
#line 384
    if (cur_mb_len > 1) {
#line 387
      cur_mb_index = 1;
    } else
#line 388
    if (cur_mb_len < 1) {
#line 391
      cur_mb_len = 1;
    }
  }
#line 395
  return;
}
}
#line 417 "dfa.c"
static wchar_t fetch_wc(char const   *eoferr ) 
{ 
  wchar_t wc ;
  size_t tmp ;

  {
#line 421
  if (! lexleft) {
#line 423
    if ((unsigned long )eoferr != (unsigned long )((char const   *)0)) {
      {
      {
#line 424
      dfaerror(eoferr);
      }
      }
    } else {
#line 426
      return ((wchar_t )-1);
    }
  }
  {
  {
#line 429
  tmp = mbrtowc((wchar_t */* __restrict  */)(& wc), (char const   */* __restrict  */)lexptr,
                (size_t )lexleft, & mbs);
  }
#line 429
  cur_mb_len = (int )tmp;
  }
#line 430
  if (cur_mb_len <= 0) {
#line 432
    cur_mb_len = 1;
#line 433
    wc = (wchar_t )*lexptr;
  }
#line 435
  lexptr += cur_mb_len;
#line 436
  lexleft -= cur_mb_len;
#line 437
  return (wc);
}
}
#line 459 "dfa.c"
static void parse_bracket_exp_mb(void) 
{ 
  wchar_t wc ;
  wchar_t wc1 ;
  wchar_t wc2 ;
  struct mb_char_classes *work_mbc ;
  int chars_al ;
  int range_sts_al ;
  int range_ends_al ;
  int ch_classes_al ;
  int equivs_al ;
  int coll_elems_al ;
  ptr_t tmp ;
  int tmp___0 ;
  ptr_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  wctype_t *tmp___5 ;
  wchar_t *tmp___6 ;
  char **tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char str[128] ;
  char *tmp___10 ;
  unsigned char c ;
  unsigned char delim ;
  int len ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  ptr_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  wctype_t wt ;
  ptr_t tmp___19 ;
  ptr_t tmp___20 ;
  int tmp___21 ;
  char *elem ;
  ptr_t tmp___22 ;
  ptr_t tmp___24 ;
  ptr_t tmp___25 ;
  int tmp___26 ;
  ptr_t tmp___27 ;
  ptr_t tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  ptr_t tmp___34 ;
  ptr_t tmp___35 ;
  ptr_t tmp___36 ;
  ptr_t tmp___37 ;
  int tmp___38 ;
  ptr_t tmp___39 ;
  int tmp___40 ;
  void *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;

  {
#line 469
  if (dfa___0->nmbcsets + 1 >= dfa___0->mbcsets_alloc) {
    {
    {
#line 469
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 469
      dfa___0->mbcsets_alloc *= 2;
#line 469
      if (! (dfa___0->nmbcsets + 1 >= dfa___0->mbcsets_alloc)) {
#line 469
        goto while_break;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 469
    tmp = xrealloc___0((ptr_t )dfa___0->mbcsets, (size_t )((unsigned long )dfa___0->mbcsets_alloc * sizeof(struct mb_char_classes )));
    }
#line 469
    dfa___0->mbcsets = (struct mb_char_classes *)tmp;
    }
  }
  {
#line 476
  tmp___0 = dfa___0->nmbcsets;
#line 476
  (dfa___0->nmbcsets) ++;
#line 476
  work_mbc = dfa___0->mbcsets + tmp___0;
#line 478
  chars_al = 1;
#line 479
  range_ends_al = 0;
#line 479
  range_sts_al = range_ends_al;
#line 480
  coll_elems_al = 0;
#line 480
  equivs_al = coll_elems_al;
#line 480
  ch_classes_al = equivs_al;
  {
#line 481
  tmp___1 = xmalloc___0((size_t )((unsigned long )chars_al * sizeof(wchar_t )));
  }
#line 481
  work_mbc->chars = (wchar_t *)tmp___1;
#line 483
  tmp___3 = 0;
#line 483
  work_mbc->nch_classes = tmp___3;
#line 483
  tmp___2 = tmp___3;
#line 483
  work_mbc->nranges = tmp___2;
#line 483
  work_mbc->nchars = tmp___2;
#line 484
  tmp___4 = 0;
#line 484
  work_mbc->ncoll_elems = tmp___4;
#line 484
  work_mbc->nequivs = tmp___4;
#line 485
  tmp___5 = (wctype_t *)((void *)0);
#line 485
  work_mbc->ch_classes = tmp___5;
#line 485
  work_mbc->chars = (wchar_t *)tmp___5;
#line 486
  tmp___6 = (wchar_t *)((void *)0);
#line 486
  work_mbc->range_ends = tmp___6;
#line 486
  work_mbc->range_sts = tmp___6;
#line 487
  tmp___7 = (char **)((void *)0);
#line 487
  work_mbc->coll_elems = tmp___7;
#line 487
  work_mbc->equivs = tmp___7;
  {
#line 489
  tmp___8 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
  }
  {
#line 489
  wc = fetch_wc((char const   *)tmp___8);
  }
  }
#line 490
  if (wc == 94L) {
    {
    {
#line 492
    tmp___9 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
    }
    {
#line 492
    wc = fetch_wc((char const   *)tmp___9);
    }
#line 493
    work_mbc->invert = 1;
    }
  } else {
#line 496
    work_mbc->invert = 0;
  }
  {
  {
#line 497
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 499
    wc1 = (wchar_t )-1;
#line 505
    if (wc == 91L) {
#line 505
      if (syntax_bits & ((1UL << 1) << 1)) {
        {
#line 509
        wc1 = wc;
        {
#line 510
        tmp___10 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
        }
        {
#line 510
        wc = fetch_wc((char const   *)tmp___10);
        }
        }
#line 513
        if (cur_mb_len == 1) {
#line 513
          if (wc == 58L) {
#line 513
            goto _L___1;
          } else
#line 513
          if (wc == 46L) {
#line 513
            goto _L___1;
          } else
#line 513
          if (wc == 61L) {
            _L___1: /* CIL Label */ 
#line 516
            delim = (unsigned char )wc;
#line 517
            len = 0;
            {
            {
#line 518
            while (1) {
              while_continue___11: /* CIL Label */ ;
              while_continue___1: /* CIL Label */ ;
#line 520
              if (! lexleft) {
                {
                {
#line 521
                tmp___11 = dcgettext((char const   *)((void *)0), "Unbalanced [",
                                     5);
                }
                {
#line 521
                dfaerror((char const   *)tmp___11);
                }
                }
              }
#line 522
              tmp___12 = lexptr;
#line 522
              lexptr ++;
#line 522
              c = (unsigned char )*tmp___12;
#line 523
              lexleft --;
#line 525
              if ((int )c == (int )delim) {
#line 525
                if ((int const   )*lexptr == 93) {
#line 526
                  goto while_break___1;
                } else {
#line 525
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 525
              if (lexleft == 0) {
#line 526
                goto while_break___1;
              }
#line 527
              if (len < 128) {
#line 528
                tmp___13 = len;
#line 528
                len ++;
#line 528
                str[tmp___13] = (char )c;
              } else {
#line 531
                str[0] = (char )'\000';
              }
            }
            while_break___11: /* CIL Label */ ;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 533
            str[len] = (char )'\000';
#line 535
            if (lexleft == 0) {
#line 537
              if (work_mbc->nchars + 2 >= chars_al) {
                {
                {
#line 537
                while (1) {
                  while_continue___12: /* CIL Label */ ;
                  while_continue___2: /* CIL Label */ ;
#line 537
                  chars_al *= 2;
#line 537
                  if (! (work_mbc->nchars + 2 >= chars_al)) {
#line 537
                    goto while_break___2;
                  }
                }
                while_break___12: /* CIL Label */ ;
                }
                while_break___2: /* CIL Label */ ;
                }
                {
                {
#line 537
                tmp___14 = xrealloc___0((ptr_t )work_mbc->chars, (size_t )((unsigned long )chars_al * sizeof(wchar_t )));
                }
#line 537
                work_mbc->chars = (wchar_t *)tmp___14;
                }
              }
#line 539
              tmp___15 = work_mbc->nchars;
#line 539
              (work_mbc->nchars) ++;
#line 539
              *(work_mbc->chars + tmp___15) = (wchar_t )91;
#line 540
              tmp___16 = work_mbc->nchars;
#line 540
              (work_mbc->nchars) ++;
#line 540
              *(work_mbc->chars + tmp___16) = (wchar_t )delim;
#line 541
              goto while_break___0;
            }
#line 544
            lexleft --;
#line 544
            tmp___18 = lexptr;
#line 544
            lexptr ++;
#line 544
            if ((int const   )*tmp___18 != 93) {
              {
              {
#line 545
              tmp___17 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
              }
              {
#line 545
              dfaerror((char const   *)tmp___17);
              }
              }
            }
#line 546
            if ((int )delim == 58) {
              {
              {
#line 551
              wt = wctype((char const   *)(str));
              }
              }
#line 553
              if (ch_classes_al == 0) {
                {
#line 554
                ch_classes_al ++;
                {
#line 554
                tmp___19 = xmalloc___0((size_t )((unsigned long )ch_classes_al * sizeof(wchar_t )));
                }
#line 554
                work_mbc->ch_classes = (wctype_t *)((wchar_t *)tmp___19);
                }
              }
#line 555
              if (work_mbc->nch_classes + 1 >= ch_classes_al) {
                {
                {
#line 555
                while (1) {
                  while_continue___13: /* CIL Label */ ;
                  while_continue___3: /* CIL Label */ ;
#line 555
                  ch_classes_al *= 2;
#line 555
                  if (! (work_mbc->nch_classes + 1 >= ch_classes_al)) {
#line 555
                    goto while_break___3;
                  }
                }
                while_break___13: /* CIL Label */ ;
                }
                while_break___3: /* CIL Label */ ;
                }
                {
                {
#line 555
                tmp___20 = xrealloc___0((ptr_t )work_mbc->ch_classes, (size_t )((unsigned long )ch_classes_al * sizeof(wctype_t )));
                }
#line 555
                work_mbc->ch_classes = (wctype_t *)tmp___20;
                }
              }
#line 558
              tmp___21 = work_mbc->nch_classes;
#line 558
              (work_mbc->nch_classes) ++;
#line 558
              *(work_mbc->ch_classes + tmp___21) = wt;
            } else
#line 561
            if ((int )delim == 61) {
#line 561
              goto _L___0;
            } else
#line 561
            if ((int )delim == 46) {
              _L___0: /* CIL Label */ 
              {
              {
#line 564
              tmp___22 = xmalloc___0((size_t )((unsigned long )(len + 1) * sizeof(char )));
              }
#line 564
              elem = (char *)tmp___22;
              {
#line 565
              strncpy((char */* __restrict  */)elem, (char const   */* __restrict  */)(str),
                      (size_t )(len + 1));
              }
              }
#line 567
              if ((int )delim == 61) {
#line 570
                if (equivs_al == 0) {
                  {
#line 571
                  equivs_al ++;
                  {
#line 571
                  tmp___24 = xmalloc___0((size_t )((unsigned long )equivs_al * sizeof(char *)));
                  }
#line 571
                  work_mbc->equivs = (char **)tmp___24;
                  }
                }
#line 572
                if (work_mbc->nequivs + 1 >= equivs_al) {
                  {
                  {
#line 572
                  while (1) {
                    while_continue___14: /* CIL Label */ ;
                    while_continue___4: /* CIL Label */ ;
#line 572
                    equivs_al *= 2;
#line 572
                    if (! (work_mbc->nequivs + 1 >= equivs_al)) {
#line 572
                      goto while_break___4;
                    }
                  }
                  while_break___14: /* CIL Label */ ;
                  }
                  while_break___4: /* CIL Label */ ;
                  }
                  {
                  {
#line 572
                  tmp___25 = xrealloc___0((ptr_t )work_mbc->equivs, (size_t )((unsigned long )equivs_al * sizeof(char *)));
                  }
#line 572
                  work_mbc->equivs = (char **)tmp___25;
                  }
                }
#line 575
                tmp___26 = work_mbc->nequivs;
#line 575
                (work_mbc->nequivs) ++;
#line 575
                *(work_mbc->equivs + tmp___26) = elem;
              }
#line 578
              if ((int )delim == 46) {
#line 581
                if (coll_elems_al == 0) {
                  {
#line 582
                  coll_elems_al ++;
                  {
#line 582
                  tmp___27 = xmalloc___0((size_t )((unsigned long )coll_elems_al * sizeof(char *)));
                  }
#line 582
                  work_mbc->coll_elems = (char **)tmp___27;
                  }
                }
#line 583
                if (work_mbc->ncoll_elems + 1 >= coll_elems_al) {
                  {
                  {
#line 583
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
                    while_continue___5: /* CIL Label */ ;
#line 583
                    coll_elems_al *= 2;
#line 583
                    if (! (work_mbc->ncoll_elems + 1 >= coll_elems_al)) {
#line 583
                      goto while_break___5;
                    }
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                  while_break___5: /* CIL Label */ ;
                  }
                  {
                  {
#line 583
                  tmp___28 = xrealloc___0((ptr_t )work_mbc->coll_elems, (size_t )((unsigned long )coll_elems_al * sizeof(char *)));
                  }
#line 583
                  work_mbc->coll_elems = (char **)tmp___28;
                  }
                }
#line 586
                tmp___29 = work_mbc->ncoll_elems;
#line 586
                (work_mbc->ncoll_elems) ++;
#line 586
                *(work_mbc->coll_elems + tmp___29) = elem;
              }
            }
#line 589
            wc = (wchar_t )-1;
          } else {
#line 594
            wc2 = wc1;
#line 594
            wc1 = wc;
#line 594
            wc = wc2;
          }
        } else {
#line 594
          wc2 = wc1;
#line 594
          wc1 = wc;
#line 594
          wc = wc2;
        }
      } else {
#line 505
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 599
    if (wc == 92L) {
#line 599
      if (syntax_bits & 1UL) {
        {
        {
#line 600
        wc = fetch_wc("Unbalanced [");
        }
        }
      }
    }
#line 603
    if (wc1 == -1L) {
      {
      {
#line 604
      tmp___30 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
      }
      {
#line 604
      wc1 = fetch_wc((char const   *)tmp___30);
      }
      }
    }
#line 606
    if (wc1 == 45L) {
      {
      {
#line 609
      tmp___31 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
      }
      {
#line 609
      wc2 = fetch_wc((char const   *)tmp___31);
      }
      }
#line 610
      if (wc2 == 93L) {
#line 614
        lexptr -= cur_mb_len;
#line 615
        lexleft += cur_mb_len;
#line 616
        wc2 = wc;
      } else {
#line 620
        if (wc2 == 92L) {
#line 620
          if (syntax_bits & 1UL) {
            {
            {
#line 622
            tmp___32 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
            }
            {
#line 622
            wc2 = fetch_wc((char const   *)tmp___32);
            }
            }
          }
        }
        {
        {
#line 623
        tmp___33 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
        }
        {
#line 623
        wc1 = fetch_wc((char const   *)tmp___33);
        }
        }
      }
#line 626
      if (range_sts_al == 0) {
        {
#line 628
        range_sts_al ++;
        {
#line 628
        tmp___34 = xmalloc___0((size_t )((unsigned long )range_sts_al * sizeof(wchar_t )));
        }
#line 628
        work_mbc->range_sts = (wchar_t *)tmp___34;
#line 629
        range_ends_al ++;
        {
#line 629
        tmp___35 = xmalloc___0((size_t )((unsigned long )range_ends_al * sizeof(wchar_t )));
        }
#line 629
        work_mbc->range_ends = (wchar_t *)tmp___35;
        }
      }
#line 631
      if (work_mbc->nranges + 1 >= range_sts_al) {
        {
        {
#line 631
        while (1) {
          while_continue___16: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 631
          range_sts_al *= 2;
#line 631
          if (! (work_mbc->nranges + 1 >= range_sts_al)) {
#line 631
            goto while_break___6;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
        {
#line 631
        tmp___36 = xrealloc___0((ptr_t )work_mbc->range_sts, (size_t )((unsigned long )range_sts_al * sizeof(wchar_t )));
        }
#line 631
        work_mbc->range_sts = (wchar_t *)tmp___36;
        }
      }
#line 633
      *(work_mbc->range_sts + work_mbc->nranges) = wc;
#line 634
      if (work_mbc->nranges + 1 >= range_ends_al) {
        {
        {
#line 634
        while (1) {
          while_continue___17: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 634
          range_ends_al *= 2;
#line 634
          if (! (work_mbc->nranges + 1 >= range_ends_al)) {
#line 634
            goto while_break___7;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
        {
#line 634
        tmp___37 = xrealloc___0((ptr_t )work_mbc->range_ends, (size_t )((unsigned long )range_ends_al * sizeof(wchar_t )));
        }
#line 634
        work_mbc->range_ends = (wchar_t *)tmp___37;
        }
      }
#line 636
      tmp___38 = work_mbc->nranges;
#line 636
      (work_mbc->nranges) ++;
#line 636
      *(work_mbc->range_ends + tmp___38) = wc2;
    } else
#line 638
    if (wc != -1L) {
#line 641
      if (work_mbc->nchars + 1 >= chars_al) {
        {
        {
#line 641
        while (1) {
          while_continue___18: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
#line 641
          chars_al *= 2;
#line 641
          if (! (work_mbc->nchars + 1 >= chars_al)) {
#line 641
            goto while_break___8;
          }
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
        {
#line 641
        tmp___39 = xrealloc___0((ptr_t )work_mbc->chars, (size_t )((unsigned long )chars_al * sizeof(wchar_t )));
        }
#line 641
        work_mbc->chars = (wchar_t *)tmp___39;
        }
      }
#line 643
      tmp___40 = work_mbc->nchars;
#line 643
      (work_mbc->nchars) ++;
#line 643
      *(work_mbc->chars + tmp___40) = wc;
    }
#line 497
    wc = wc1;
#line 497
    if (! (wc != 93L)) {
#line 497
      goto while_break___0;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 647
  return;
}
}
#line 656 "dfa.c"
static int is_alpha(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 656
  tmp = __ctype_b_loc();
  }
  }
#line 656
  return ((int )((int const   )*(*tmp + c) & 1024));
}
}
#line 657 "dfa.c"
static int is_upper(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 657
  tmp = __ctype_b_loc();
  }
  }
#line 657
  return ((int )((int const   )*(*tmp + c) & 256));
}
}
#line 658 "dfa.c"
static int is_lower(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 658
  tmp = __ctype_b_loc();
  }
  }
#line 658
  return ((int )((int const   )*(*tmp + c) & 512));
}
}
#line 659 "dfa.c"
static int is_digit(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 659
  tmp = __ctype_b_loc();
  }
  }
#line 659
  return ((int )((int const   )*(*tmp + c) & 2048));
}
}
#line 660 "dfa.c"
static int is_xdigit(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 660
  tmp = __ctype_b_loc();
  }
  }
#line 660
  return ((int )((int const   )*(*tmp + c) & 4096));
}
}
#line 661 "dfa.c"
static int is_space(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 661
  tmp = __ctype_b_loc();
  }
  }
#line 661
  return ((int )((int const   )*(*tmp + c) & 8192));
}
}
#line 662 "dfa.c"
static int is_punct(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 662
  tmp = __ctype_b_loc();
  }
  }
#line 662
  return ((int )((int const   )*(*tmp + c) & 4));
}
}
#line 663 "dfa.c"
static int is_alnum(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 663
  tmp = __ctype_b_loc();
  }
  }
#line 663
  return ((int )((int const   )*(*tmp + c) & 8));
}
}
#line 664 "dfa.c"
static int is_print(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 664
  tmp = __ctype_b_loc();
  }
  }
#line 664
  return ((int )((int const   )*(*tmp + c) & 16384));
}
}
#line 665 "dfa.c"
static int is_graph(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 665
  tmp = __ctype_b_loc();
  }
  }
#line 665
  return ((int )((int const   )*(*tmp + c) & 32768));
}
}
#line 666 "dfa.c"
static int is_cntrl(int c ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 666
  tmp = __ctype_b_loc();
  }
  }
#line 666
  return ((int )((int const   )*(*tmp + c) & 2));
}
}
#line 668 "dfa.c"
static int is_blank(int c ) 
{ 
  int tmp ;

  {
#line 671
  if (c == 32) {
#line 671
    tmp = 1;
  } else
#line 671
  if (c == 9) {
#line 671
    tmp = 1;
  } else {
#line 671
    tmp = 0;
  }
#line 671
  return (tmp);
}
}
#line 677 "dfa.c"
static struct __anonstruct_prednames_28  const  prednames[13]  = 
#line 677
  {      {":alpha:]", & is_alpha}, 
        {":upper:]", & is_upper}, 
        {":lower:]", & is_lower}, 
        {":digit:]", & is_digit}, 
        {":xdigit:]", & is_xdigit}, 
        {":space:]", & is_space}, 
        {":punct:]", & is_punct}, 
        {":alnum:]", & is_alnum}, 
        {":print:]", & is_print}, 
        {":graph:]", & is_graph}, 
        {":cntrl:]", & is_cntrl}, 
        {":blank:]", & is_blank}, 
        {(char const   *)0, (int (*)(int  ))0}};
#line 699 "dfa.c"
static int looking_at(char const   *s ) 
{ 
  size_t len ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
  {
#line 704
  len = strlen(s);
  }
  }
#line 705
  if ((size_t )lexleft < len) {
#line 706
    return (0);
  }
#line 707
  if (0) {
#line 707
    if (0) {
      {
      {
#line 707
      __s1_len = strlen(s);
      }
      {
#line 707
      __s2_len = strlen(lexptr);
      }
      }
#line 707
      if (! ((size_t )((void const   *)(s + 1)) - (size_t )((void const   *)s) == 1U)) {
#line 707
        goto _L___0;
      } else
#line 707
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 707
        if (! ((size_t )((void const   *)(lexptr + 1)) - (size_t )((void const   *)lexptr) == 1U)) {
#line 707
          tmp___6 = 1;
        } else
#line 707
        if (__s2_len >= 4U) {
#line 707
          tmp___6 = 1;
        } else {
#line 707
          tmp___6 = 0;
        }
      } else {
#line 707
        tmp___6 = 0;
      }
#line 707
      if (tmp___6) {
#line 707
        if (__s1_len < __s2_len) {
#line 707
          tmp___2 = __s1_len;
        } else {
#line 707
          tmp___2 = __s2_len;
        }
        {
        {
#line 707
        tmp___3 = memcmp((void const   *)s, (void const   *)lexptr, tmp___2 + 1U);
        }
#line 707
        tmp___5 = tmp___3;
        }
      } else {
        {
        {
#line 707
        tmp___4 = strcmp(s, lexptr);
        }
#line 707
        tmp___5 = tmp___4;
        }
      }
    } else {
      {
      {
#line 707
      tmp___4 = strcmp(s, lexptr);
      }
#line 707
      tmp___5 = tmp___4;
      }
    }
#line 707
    tmp___8 = tmp___5;
  } else {
    {
    {
#line 707
    tmp___7 = strncmp(s, lexptr, len);
    }
#line 707
    tmp___8 = tmp___7;
    }
  }
#line 707
  return (tmp___8 == 0);
}
}
#line 710 "dfa.c"
static token lex(void) 
{ 
  unsigned int c ;
  unsigned int c1 ;
  unsigned int c2 ;
  int backslash ;
  int invert ;
  charclass ccl ;
  int i ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int lo ;
  int hi ;
  char const   *p ;
  char const   *lim ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  unsigned short const   **tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  size_t tmp___42 ;
  char const   *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  size_t tmp___46 ;
  char const   *tmp___47 ;
  int (*pred)(int  ) ;
  int tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  size_t tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t tmp___58 ;
  char const   *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  size_t tmp___62 ;
  char const   *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  size_t tmp___66 ;
  char const   *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  size_t tmp___70 ;
  char const   *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  size_t tmp___74 ;
  char const   *tmp___75 ;
  char expr[6] ;
  regex_t re ;
  char buf[2] ;
  regmatch_t mat ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  unsigned short const   **tmp___81 ;
  void *__cil_tmp100 ;
  void *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;

  {
#line 714
  backslash = 0;
#line 724
  i = 0;
  {
  {
#line 724
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 724
    if (! (i < 2)) {
#line 724
      goto while_break;
    }
#line 726
    if (! lexleft) {
#line 726
      lasttok = (token )-1;
#line 726
      return (lasttok);
    }
    {
    {
#line 726
    tmp = __ctype_get_mb_cur_max();
    }
    }
#line 726
    if (tmp > 1U) {
      {
      {
#line 726
      update_mb_len_index((unsigned char const   *)lexptr, lexleft);
      }
      }
    }
    {
#line 726
    tmp___0 = lexptr;
#line 726
    lexptr ++;
#line 726
    c = (unsigned int )((unsigned char )*tmp___0);
#line 726
    lexleft --;
    {
#line 728
    tmp___1 = __ctype_get_mb_cur_max();
    }
    }
#line 728
    if (tmp___1 > 1U) {
#line 728
      if (cur_mb_index) {
#line 733
        goto normal_char;
      }
    }
    {
#line 737
    if (c == 92U) {
#line 737
      goto case_92;
    }
#line 745
    if (c == 94U) {
#line 745
      goto case_94;
    }
#line 755
    if (c == 36U) {
#line 755
      goto case_36;
    }
#line 779
    if (c == 57U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 56U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 55U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 54U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 53U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 52U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 51U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 50U) {
#line 779
      goto case_57;
    }
#line 779
    if (c == 49U) {
#line 779
      goto case_57;
    }
#line 787
    if (c == 96U) {
#line 787
      goto case_96;
    }
#line 792
    if (c == 39U) {
#line 792
      goto case_39;
    }
#line 797
    if (c == 60U) {
#line 797
      goto case_60;
    }
#line 802
    if (c == 62U) {
#line 802
      goto case_62;
    }
#line 807
    if (c == 98U) {
#line 807
      goto case_98;
    }
#line 812
    if (c == 66U) {
#line 812
      goto case_66;
    }
#line 817
    if (c == 63U) {
#line 817
      goto case_63;
    }
#line 826
    if (c == 42U) {
#line 826
      goto case_42;
    }
#line 833
    if (c == 43U) {
#line 833
      goto case_43;
    }
#line 842
    if (c == 123U) {
#line 842
      goto case_123;
    }
#line 920
    if (c == 124U) {
#line 920
      goto case_124;
    }
#line 928
    if (c == 10U) {
#line 928
      goto case_10;
    }
#line 936
    if (c == 40U) {
#line 936
      goto case_40;
    }
#line 943
    if (c == 41U) {
#line 943
      goto case_41;
    }
#line 952
    if (c == 46U) {
#line 952
      goto case_46;
    }
#line 974
    if (c == 87U) {
#line 974
      goto case_87;
    }
#line 974
    if (c == 119U) {
#line 974
      goto case_87;
    }
#line 986
    if (c == 91U) {
#line 986
      goto case_91;
    }
#line 1086
    goto normal_char;
    case_92: /* CIL Label */ 
#line 738
    if (backslash) {
#line 739
      goto normal_char;
    }
#line 740
    if (lexleft == 0) {
      {
      {
#line 741
      tmp___2 = dcgettext((char const   *)((void *)0), "Unfinished \\ escape", 5);
      }
      {
#line 741
      dfaerror((char const   *)tmp___2);
      }
      }
    }
#line 742
    backslash = 1;
#line 743
    goto switch_break;
    case_94: /* CIL Label */ 
#line 746
    if (backslash) {
#line 747
      goto normal_char;
    }
#line 748
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 752
      lasttok = (token )258;
#line 752
      return (lasttok);
    } else
#line 748
    if ((int )lasttok == -1) {
#line 752
      lasttok = (token )258;
#line 752
      return (lasttok);
    } else
#line 748
    if ((int )lasttok == 271) {
#line 752
      lasttok = (token )258;
#line 752
      return (lasttok);
    } else
#line 748
    if ((int )lasttok == 269) {
#line 752
      lasttok = (token )258;
#line 752
      return (lasttok);
    }
#line 753
    goto normal_char;
    case_36: /* CIL Label */ 
#line 756
    if (backslash) {
#line 757
      goto normal_char;
    }
#line 758
    if (syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 768
      lasttok = (token )259;
#line 768
      return (lasttok);
    } else
#line 758
    if (lexleft == 0) {
#line 768
      lasttok = (token )259;
#line 768
      return (lasttok);
    } else {
#line 758
      if (syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 758
        if (lexleft > 0) {
#line 758
          if ((int const   )*lexptr == 41) {
#line 758
            tmp___3 = 1;
          } else {
#line 758
            tmp___3 = 0;
          }
        } else {
#line 758
          tmp___3 = 0;
        }
#line 758
        tmp___5 = tmp___3;
      } else {
#line 758
        if (lexleft > 1) {
#line 758
          if ((int const   )*(lexptr + 0) == 92) {
#line 758
            if ((int const   )*(lexptr + 1) == 41) {
#line 758
              tmp___4 = 1;
            } else {
#line 758
              tmp___4 = 0;
            }
          } else {
#line 758
            tmp___4 = 0;
          }
        } else {
#line 758
          tmp___4 = 0;
        }
#line 758
        tmp___5 = tmp___4;
      }
#line 758
      if (tmp___5) {
#line 768
        lasttok = (token )259;
#line 768
        return (lasttok);
      } else {
#line 758
        if (syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 758
          if (lexleft > 0) {
#line 758
            if ((int const   )*lexptr == 124) {
#line 758
              tmp___6 = 1;
            } else {
#line 758
              tmp___6 = 0;
            }
          } else {
#line 758
            tmp___6 = 0;
          }
#line 758
          tmp___8 = tmp___6;
        } else {
#line 758
          if (lexleft > 1) {
#line 758
            if ((int const   )*(lexptr + 0) == 92) {
#line 758
              if ((int const   )*(lexptr + 1) == 124) {
#line 758
                tmp___7 = 1;
              } else {
#line 758
                tmp___7 = 0;
              }
            } else {
#line 758
              tmp___7 = 0;
            }
          } else {
#line 758
            tmp___7 = 0;
          }
#line 758
          tmp___8 = tmp___7;
        }
#line 758
        if (tmp___8) {
#line 768
          lasttok = (token )259;
#line 768
          return (lasttok);
        } else
#line 758
        if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 758
          if (lexleft > 0) {
#line 758
            if ((int const   )*lexptr == 10) {
#line 768
              lasttok = (token )259;
#line 768
              return (lasttok);
            }
          }
        }
      }
    }
#line 769
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 780
    if (backslash) {
#line 780
      if (! (syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 782
        laststart = 0;
#line 783
        lasttok = (token )257;
#line 783
        return (lasttok);
      }
    }
#line 785
    goto normal_char;
    case_96: /* CIL Label */ 
#line 788
    if (backslash) {
#line 788
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 789
        lasttok = (token )258;
#line 789
        return (lasttok);
      }
    }
#line 790
    goto normal_char;
    case_39: /* CIL Label */ 
#line 793
    if (backslash) {
#line 793
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 794
        lasttok = (token )259;
#line 794
        return (lasttok);
      }
    }
#line 795
    goto normal_char;
    case_60: /* CIL Label */ 
#line 798
    if (backslash) {
#line 798
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 799
        lasttok = (token )260;
#line 799
        return (lasttok);
      }
    }
#line 800
    goto normal_char;
    case_62: /* CIL Label */ 
#line 803
    if (backslash) {
#line 803
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 804
        lasttok = (token )261;
#line 804
        return (lasttok);
      }
    }
#line 805
    goto normal_char;
    case_98: /* CIL Label */ 
#line 808
    if (backslash) {
#line 808
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 809
        lasttok = (token )262;
#line 809
        return (lasttok);
      }
    }
#line 810
    goto normal_char;
    case_66: /* CIL Label */ 
#line 813
    if (backslash) {
#line 813
      if (! (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 814
        lasttok = (token )263;
#line 814
        return (lasttok);
      }
    }
#line 815
    goto normal_char;
    case_63: /* CIL Label */ 
#line 818
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 819
      goto normal_char;
    }
#line 820
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 821
      goto normal_char;
    }
#line 822
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 822
      if (laststart) {
#line 823
        goto normal_char;
      }
    }
#line 824
    lasttok = (token )264;
#line 824
    return (lasttok);
    case_42: /* CIL Label */ 
#line 827
    if (backslash) {
#line 828
      goto normal_char;
    }
#line 829
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 829
      if (laststart) {
#line 830
        goto normal_char;
      }
    }
#line 831
    lasttok = (token )265;
#line 831
    return (lasttok);
    case_43: /* CIL Label */ 
#line 834
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 835
      goto normal_char;
    }
#line 836
    if (backslash != ((syntax_bits & (1UL << 1)) != 0UL)) {
#line 837
      goto normal_char;
    }
#line 838
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 838
      if (laststart) {
#line 839
        goto normal_char;
      }
    }
#line 840
    lasttok = (token )266;
#line 840
    return (lasttok);
    case_123: /* CIL Label */ 
#line 843
    if (! (syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 844
      goto normal_char;
    }
#line 845
    if (backslash != ((syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 846
      goto normal_char;
    }
#line 847
    if (! (syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 847
      if (laststart) {
#line 848
        goto normal_char;
      }
    }
#line 850
    if (syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 854
      lo = -1;
#line 854
      hi = -1;
#line 855
      p = lexptr;
#line 856
      lim = p + lexleft;
      {
      {
#line 857
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 857
        if ((unsigned long )p != (unsigned long )lim) {
#line 857
          if (! ((unsigned int )*p - 48U <= 9U)) {
#line 857
            goto while_break___0;
          }
        } else {
#line 857
          goto while_break___0;
        }
#line 858
        if (lo < 0) {
#line 858
          tmp___9 = 0;
        } else {
#line 858
          tmp___9 = lo * 10;
        }
#line 858
        lo = (tmp___9 + (int )*p) - 48;
#line 857
        p ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 859
      if ((unsigned long )p != (unsigned long )lim) {
#line 859
        if ((int const   )*p == 44) {
          {
          {
#line 860
          while (1) {
            while_continue___12: /* CIL Label */ ;
            while_continue___1: /* CIL Label */ ;
#line 860
            p ++;
#line 860
            if ((unsigned long )p != (unsigned long )lim) {
#line 860
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 860
                goto while_break___1;
              }
            } else {
#line 860
              goto while_break___1;
            }
#line 861
            if (hi < 0) {
#line 861
              tmp___10 = 0;
            } else {
#line 861
              tmp___10 = hi * 10;
            }
#line 861
            hi = (tmp___10 + (int )*p) - 48;
          }
          while_break___12: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 863
          hi = lo;
        }
      } else {
#line 863
        hi = lo;
      }
#line 864
      if ((unsigned long )p == (unsigned long )lim) {
#line 866
        goto normal_char;
      } else
#line 864
      if ((int const   )*p != 125) {
#line 866
        goto normal_char;
      } else
#line 864
      if (lo < 0) {
#line 866
        goto normal_char;
      } else
#line 864
      if (32767 < hi) {
#line 866
        goto normal_char;
      } else
#line 864
      if (0 <= hi) {
#line 864
        if (hi < lo) {
#line 866
          goto normal_char;
        }
      }
    }
#line 869
    minrep = 0;
#line 874
    if (! lexleft) {
      {
      {
#line 874
      tmp___12 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                           5);
      }
      }
#line 874
      if ((unsigned long )tmp___12 != (unsigned long )((char *)0)) {
        {
        {
#line 874
        tmp___11 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                             5);
        }
        {
#line 874
        dfaerror((char const   *)tmp___11);
        }
        }
      } else {
#line 874
        lasttok = (token )-1;
#line 874
        return (lasttok);
      }
    }
    {
    {
#line 874
    tmp___13 = __ctype_get_mb_cur_max();
    }
    }
#line 874
    if (tmp___13 > 1U) {
      {
      {
#line 874
      update_mb_len_index((unsigned char const   *)lexptr, lexleft);
      }
      }
    }
#line 874
    tmp___14 = lexptr;
#line 874
    lexptr ++;
#line 874
    c = (unsigned int )((unsigned char )*tmp___14);
#line 874
    lexleft --;
#line 875
    if (c - 48U <= 9U) {
#line 877
      minrep = (int )(c - 48U);
      {
      {
#line 878
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 880
        if (! lexleft) {
          {
          {
#line 880
          tmp___16 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                               5);
          }
          }
#line 880
          if ((unsigned long )tmp___16 != (unsigned long )((char *)0)) {
            {
            {
#line 880
            tmp___15 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                                 5);
            }
            {
#line 880
            dfaerror((char const   *)tmp___15);
            }
            }
          } else {
#line 880
            lasttok = (token )-1;
#line 880
            return (lasttok);
          }
        }
        {
        {
#line 880
        tmp___17 = __ctype_get_mb_cur_max();
        }
        }
#line 880
        if (tmp___17 > 1U) {
          {
          {
#line 880
          update_mb_len_index((unsigned char const   *)lexptr, lexleft);
          }
          }
        }
#line 880
        tmp___18 = lexptr;
#line 880
        lexptr ++;
#line 880
        c = (unsigned int )((unsigned char )*tmp___18);
#line 880
        lexleft --;
#line 881
        if (! (c - 48U <= 9U)) {
#line 882
          goto while_break___2;
        }
#line 883
        minrep = (int )(((unsigned int )(10 * minrep) + c) - 48U);
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 887
      tmp___19 = dcgettext((char const   *)((void *)0), "malformed repeat count",
                           5);
      }
      {
#line 887
      dfaerror((char const   *)tmp___19);
      }
      }
    }
#line 888
    if (c == 44U) {
#line 890
      if (! lexleft) {
        {
        {
#line 890
        tmp___21 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                             5);
        }
        }
#line 890
        if ((unsigned long )tmp___21 != (unsigned long )((char *)0)) {
          {
          {
#line 890
          tmp___20 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                               5);
          }
          {
#line 890
          dfaerror((char const   *)tmp___20);
          }
          }
        } else {
#line 890
          lasttok = (token )-1;
#line 890
          return (lasttok);
        }
      }
      {
      {
#line 890
      tmp___22 = __ctype_get_mb_cur_max();
      }
      }
#line 890
      if (tmp___22 > 1U) {
        {
        {
#line 890
        update_mb_len_index((unsigned char const   *)lexptr, lexleft);
        }
        }
      }
#line 890
      tmp___23 = lexptr;
#line 890
      lexptr ++;
#line 890
      c = (unsigned int )((unsigned char )*tmp___23);
#line 890
      lexleft --;
#line 891
      if (! (c - 48U <= 9U)) {
#line 892
        maxrep = -1;
      } else {
#line 895
        maxrep = (int )(c - 48U);
        {
        {
#line 896
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 898
          if (! lexleft) {
            {
            {
#line 898
            tmp___25 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                                 5);
            }
            }
#line 898
            if ((unsigned long )tmp___25 != (unsigned long )((char *)0)) {
              {
              {
#line 898
              tmp___24 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                                   5);
              }
              {
#line 898
              dfaerror((char const   *)tmp___24);
              }
              }
            } else {
#line 898
              lasttok = (token )-1;
#line 898
              return (lasttok);
            }
          }
          {
          {
#line 898
          tmp___26 = __ctype_get_mb_cur_max();
          }
          }
#line 898
          if (tmp___26 > 1U) {
            {
            {
#line 898
            update_mb_len_index((unsigned char const   *)lexptr, lexleft);
            }
            }
          }
#line 898
          tmp___27 = lexptr;
#line 898
          lexptr ++;
#line 898
          c = (unsigned int )((unsigned char )*tmp___27);
#line 898
          lexleft --;
#line 899
          if (! (c - 48U <= 9U)) {
#line 900
            goto while_break___3;
          }
#line 901
          maxrep = (int )(((unsigned int )(10 * maxrep) + c) - 48U);
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 903
        if (0 <= maxrep) {
#line 903
          if (maxrep < minrep) {
            {
            {
#line 904
            tmp___28 = dcgettext((char const   *)((void *)0), "malformed repeat count",
                                 5);
            }
            {
#line 904
            dfaerror((char const   *)tmp___28);
            }
            }
          }
        }
      }
    } else {
#line 908
      maxrep = minrep;
    }
#line 909
    if (! (syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 911
      if (c != 92U) {
        {
        {
#line 912
        tmp___29 = dcgettext((char const   *)((void *)0), "malformed repeat count",
                             5);
        }
        {
#line 912
        dfaerror((char const   *)tmp___29);
        }
        }
      }
#line 913
      if (! lexleft) {
        {
        {
#line 913
        tmp___31 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                             5);
        }
        }
#line 913
        if ((unsigned long )tmp___31 != (unsigned long )((char *)0)) {
          {
          {
#line 913
          tmp___30 = dcgettext((char const   *)((void *)0), "unfinished repeat count",
                               5);
          }
          {
#line 913
          dfaerror((char const   *)tmp___30);
          }
          }
        } else {
#line 913
          lasttok = (token )-1;
#line 913
          return (lasttok);
        }
      }
      {
      {
#line 913
      tmp___32 = __ctype_get_mb_cur_max();
      }
      }
#line 913
      if (tmp___32 > 1U) {
        {
        {
#line 913
        update_mb_len_index((unsigned char const   *)lexptr, lexleft);
        }
        }
      }
#line 913
      tmp___33 = lexptr;
#line 913
      lexptr ++;
#line 913
      c = (unsigned int )((unsigned char )*tmp___33);
#line 913
      lexleft --;
    }
#line 915
    if (c != 125U) {
      {
      {
#line 916
      tmp___34 = dcgettext((char const   *)((void *)0), "malformed repeat count",
                           5);
      }
      {
#line 916
      dfaerror((char const   *)tmp___34);
      }
      }
    }
#line 917
    laststart = 0;
#line 918
    lasttok = (token )267;
#line 918
    return (lasttok);
    case_124: /* CIL Label */ 
#line 921
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 922
      goto normal_char;
    }
#line 923
    if (backslash != ((syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 924
      goto normal_char;
    }
#line 925
    laststart = 1;
#line 926
    lasttok = (token )269;
#line 926
    return (lasttok);
    case_10: /* CIL Label */ 
#line 929
    if (syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 932
      goto normal_char;
    } else
#line 929
    if (backslash) {
#line 932
      goto normal_char;
    } else
#line 929
    if (! (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 932
      goto normal_char;
    }
#line 933
    laststart = 1;
#line 934
    lasttok = (token )269;
#line 934
    return (lasttok);
    case_40: /* CIL Label */ 
#line 937
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 938
      goto normal_char;
    }
#line 939
    parens ++;
#line 940
    laststart = 1;
#line 941
    lasttok = (token )271;
#line 941
    return (lasttok);
    case_41: /* CIL Label */ 
#line 944
    if (backslash != ((syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 945
      goto normal_char;
    }
#line 946
    if (parens == 0) {
#line 946
      if (syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 947
        goto normal_char;
      }
    }
#line 948
    parens --;
#line 949
    laststart = 0;
#line 950
    lasttok = (token )272;
#line 950
    return (lasttok);
    case_46: /* CIL Label */ 
#line 953
    if (backslash) {
#line 954
      goto normal_char;
    }
    {
    {
#line 956
    tmp___35 = __ctype_get_mb_cur_max();
    }
    }
#line 956
    if (tmp___35 > 1U) {
#line 960
      laststart = 0;
#line 961
      lasttok = (token )274;
#line 961
      return (lasttok);
    }
    {
    {
#line 964
    zeroset(ccl);
    }
    {
#line 965
    notset(ccl);
    }
    }
#line 966
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
      {
#line 967
      clrbit((unsigned int )eolbyte___0, ccl);
      }
      }
    }
#line 968
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
      {
#line 969
      clrbit((unsigned int )'\000', ccl);
      }
      }
    }
    {
#line 970
    laststart = 0;
    {
#line 971
    tmp___36 = charclass_index(ccl);
    }
#line 971
    lasttok = (token )(276 + tmp___36);
    }
#line 971
    return (lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 975
    if (! backslash) {
#line 976
      goto normal_char;
    } else
#line 975
    if (syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 976
      goto normal_char;
    }
    {
    {
#line 977
    zeroset(ccl);
    }
#line 978
    c2 = 0U;
    }
    {
    {
#line 978
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 978
      if (! (c2 < (unsigned int )(1 << 8))) {
#line 978
        goto while_break___4;
      }
      {
      {
#line 979
      tmp___37 = __ctype_b_loc();
      }
      }
#line 979
      if ((int const   )*(*tmp___37 + (int )c2) & 8) {
        {
        {
#line 980
        setbit(c2, ccl);
        }
        }
      } else
#line 979
      if (c2 == 95U) {
        {
        {
#line 980
        setbit(c2, ccl);
        }
        }
      }
#line 978
      c2 ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 981
    if (c == 87U) {
      {
      {
#line 982
      notset(ccl);
      }
      }
    }
    {
#line 983
    laststart = 0;
    {
#line 984
    tmp___38 = charclass_index(ccl);
    }
#line 984
    lasttok = (token )(276 + tmp___38);
    }
#line 984
    return (lasttok);
    case_91: /* CIL Label */ 
#line 987
    if (backslash) {
#line 988
      goto normal_char;
    }
    {
#line 989
    laststart = 0;
    {
#line 991
    tmp___39 = __ctype_get_mb_cur_max();
    }
    }
#line 991
    if (tmp___39 > 1U) {
      {
      {
#line 996
      parse_bracket_exp_mb();
      }
#line 997
      lasttok = (token )275;
      }
#line 997
      return (lasttok);
    }
    {
    {
#line 1000
    zeroset(ccl);
    }
    }
#line 1001
    if (! lexleft) {
      {
      {
#line 1001
      tmp___41 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
      }
      }
#line 1001
      if ((unsigned long )tmp___41 != (unsigned long )((char *)0)) {
        {
        {
#line 1001
        tmp___40 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
        }
        {
#line 1001
        dfaerror((char const   *)tmp___40);
        }
        }
      } else {
#line 1001
        lasttok = (token )-1;
#line 1001
        return (lasttok);
      }
    }
    {
    {
#line 1001
    tmp___42 = __ctype_get_mb_cur_max();
    }
    }
#line 1001
    if (tmp___42 > 1U) {
      {
      {
#line 1001
      update_mb_len_index((unsigned char const   *)lexptr, lexleft);
      }
      }
    }
#line 1001
    tmp___43 = lexptr;
#line 1001
    lexptr ++;
#line 1001
    c = (unsigned int )((unsigned char )*tmp___43);
#line 1001
    lexleft --;
#line 1002
    if (c == 94U) {
#line 1004
      if (! lexleft) {
        {
        {
#line 1004
        tmp___45 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
        }
        }
#line 1004
        if ((unsigned long )tmp___45 != (unsigned long )((char *)0)) {
          {
          {
#line 1004
          tmp___44 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
          }
          {
#line 1004
          dfaerror((char const   *)tmp___44);
          }
          }
        } else {
#line 1004
          lasttok = (token )-1;
#line 1004
          return (lasttok);
        }
      }
      {
      {
#line 1004
      tmp___46 = __ctype_get_mb_cur_max();
      }
      }
#line 1004
      if (tmp___46 > 1U) {
        {
        {
#line 1004
        update_mb_len_index((unsigned char const   *)lexptr, lexleft);
        }
        }
      }
#line 1004
      tmp___47 = lexptr;
#line 1004
      lexptr ++;
#line 1004
      c = (unsigned int )((unsigned char )*tmp___47);
#line 1004
      lexleft --;
#line 1005
      invert = 1;
    } else {
#line 1008
      invert = 0;
    }
    {
    {
#line 1009
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 1017
      if (c == 91U) {
#line 1017
        if (syntax_bits & ((1UL << 1) << 1)) {
#line 1018
          c1 = 0U;
          {
          {
#line 1018
          while (1) {
            while_continue___17: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
#line 1018
            if (! prednames[c1].name) {
#line 1018
              goto while_break___6;
            }
            {
            {
#line 1019
            tmp___55 = looking_at((char const   *)prednames[c1].name);
            }
            }
#line 1019
            if (tmp___55) {
#line 1021
              pred = (int (*)(int  ))prednames[c1].pred;
#line 1023
              c2 = 0U;
              {
              {
#line 1023
              while (1) {
                while_continue___18: /* CIL Label */ ;
                while_continue___7: /* CIL Label */ ;
#line 1023
                if (! (c2 < (unsigned int )(1 << 8))) {
#line 1023
                  goto while_break___7;
                }
                {
                {
#line 1024
                tmp___48 = (*pred)((int )c2);
                }
                }
#line 1024
                if (tmp___48) {
                  {
                  {
#line 1025
                  setbit_case_fold(c2, ccl);
                  }
                  }
                }
#line 1023
                c2 ++;
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___7: /* CIL Label */ ;
              }
              {
              {
#line 1026
              tmp___49 = strlen((char const   *)prednames[c1].name);
              }
#line 1026
              lexptr += tmp___49;
              {
#line 1027
              tmp___50 = strlen((char const   *)prednames[c1].name);
              }
#line 1027
              lexleft = (int )((size_t )lexleft - tmp___50);
              }
#line 1028
              if (! lexleft) {
                {
                {
#line 1028
                tmp___52 = dcgettext((char const   *)((void *)0), "Unbalanced [",
                                     5);
                }
                }
#line 1028
                if ((unsigned long )tmp___52 != (unsigned long )((char *)0)) {
                  {
                  {
#line 1028
                  tmp___51 = dcgettext((char const   *)((void *)0), "Unbalanced [",
                                       5);
                  }
                  {
#line 1028
                  dfaerror((char const   *)tmp___51);
                  }
                  }
                } else {
#line 1028
                  lasttok = (token )-1;
#line 1028
                  return (lasttok);
                }
              }
              {
              {
#line 1028
              tmp___53 = __ctype_get_mb_cur_max();
              }
              }
#line 1028
              if (tmp___53 > 1U) {
                {
                {
#line 1028
                update_mb_len_index((unsigned char const   *)lexptr, lexleft);
                }
                }
              }
#line 1028
              tmp___54 = lexptr;
#line 1028
              lexptr ++;
#line 1028
              c1 = (unsigned int )((unsigned char )*tmp___54);
#line 1028
              lexleft --;
#line 1029
              goto skip;
            }
#line 1018
            c1 ++;
          }
          while_break___17: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
      }
#line 1031
      if (c == 92U) {
#line 1031
        if (syntax_bits & 1UL) {
#line 1032
          if (! lexleft) {
            {
            {
#line 1032
            tmp___57 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
            }
            }
#line 1032
            if ((unsigned long )tmp___57 != (unsigned long )((char *)0)) {
              {
              {
#line 1032
              tmp___56 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
              }
              {
#line 1032
              dfaerror((char const   *)tmp___56);
              }
              }
            } else {
#line 1032
              lasttok = (token )-1;
#line 1032
              return (lasttok);
            }
          }
          {
          {
#line 1032
          tmp___58 = __ctype_get_mb_cur_max();
          }
          }
#line 1032
          if (tmp___58 > 1U) {
            {
            {
#line 1032
            update_mb_len_index((unsigned char const   *)lexptr, lexleft);
            }
            }
          }
#line 1032
          tmp___59 = lexptr;
#line 1032
          lexptr ++;
#line 1032
          c = (unsigned int )((unsigned char )*tmp___59);
#line 1032
          lexleft --;
        }
      }
#line 1033
      if (! lexleft) {
        {
        {
#line 1033
        tmp___61 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
        }
        }
#line 1033
        if ((unsigned long )tmp___61 != (unsigned long )((char *)0)) {
          {
          {
#line 1033
          tmp___60 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
          }
          {
#line 1033
          dfaerror((char const   *)tmp___60);
          }
          }
        } else {
#line 1033
          lasttok = (token )-1;
#line 1033
          return (lasttok);
        }
      }
      {
      {
#line 1033
      tmp___62 = __ctype_get_mb_cur_max();
      }
      }
#line 1033
      if (tmp___62 > 1U) {
        {
        {
#line 1033
        update_mb_len_index((unsigned char const   *)lexptr, lexleft);
        }
        }
      }
#line 1033
      tmp___63 = lexptr;
#line 1033
      lexptr ++;
#line 1033
      c1 = (unsigned int )((unsigned char )*tmp___63);
#line 1033
      lexleft --;
#line 1034
      if (c1 == 45U) {
#line 1036
        if (! lexleft) {
          {
          {
#line 1036
          tmp___65 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
          }
          }
#line 1036
          if ((unsigned long )tmp___65 != (unsigned long )((char *)0)) {
            {
            {
#line 1036
            tmp___64 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
            }
            {
#line 1036
            dfaerror((char const   *)tmp___64);
            }
            }
          } else {
#line 1036
            lasttok = (token )-1;
#line 1036
            return (lasttok);
          }
        }
        {
        {
#line 1036
        tmp___66 = __ctype_get_mb_cur_max();
        }
        }
#line 1036
        if (tmp___66 > 1U) {
          {
          {
#line 1036
          update_mb_len_index((unsigned char const   *)lexptr, lexleft);
          }
          }
        }
#line 1036
        tmp___67 = lexptr;
#line 1036
        lexptr ++;
#line 1036
        c2 = (unsigned int )((unsigned char )*tmp___67);
#line 1036
        lexleft --;
#line 1037
        if (c2 == 93U) {
#line 1041
          lexptr --;
#line 1042
          lexleft ++;
        } else {
#line 1046
          if (c2 == 92U) {
#line 1046
            if (syntax_bits & 1UL) {
#line 1048
              if (! lexleft) {
                {
                {
#line 1048
                tmp___69 = dcgettext((char const   *)((void *)0), "Unbalanced [",
                                     5);
                }
                }
#line 1048
                if ((unsigned long )tmp___69 != (unsigned long )((char *)0)) {
                  {
                  {
#line 1048
                  tmp___68 = dcgettext((char const   *)((void *)0), "Unbalanced [",
                                       5);
                  }
                  {
#line 1048
                  dfaerror((char const   *)tmp___68);
                  }
                  }
                } else {
#line 1048
                  lasttok = (token )-1;
#line 1048
                  return (lasttok);
                }
              }
              {
              {
#line 1048
              tmp___70 = __ctype_get_mb_cur_max();
              }
              }
#line 1048
              if (tmp___70 > 1U) {
                {
                {
#line 1048
                update_mb_len_index((unsigned char const   *)lexptr, lexleft);
                }
                }
              }
#line 1048
              tmp___71 = lexptr;
#line 1048
              lexptr ++;
#line 1048
              c2 = (unsigned int )((unsigned char )*tmp___71);
#line 1048
              lexleft --;
            }
          }
#line 1049
          if (! lexleft) {
            {
            {
#line 1049
            tmp___73 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
            }
            }
#line 1049
            if ((unsigned long )tmp___73 != (unsigned long )((char *)0)) {
              {
              {
#line 1049
              tmp___72 = dcgettext((char const   *)((void *)0), "Unbalanced [", 5);
              }
              {
#line 1049
              dfaerror((char const   *)tmp___72);
              }
              }
            } else {
#line 1049
              lasttok = (token )-1;
#line 1049
              return (lasttok);
            }
          }
          {
          {
#line 1049
          tmp___74 = __ctype_get_mb_cur_max();
          }
          }
#line 1049
          if (tmp___74 > 1U) {
            {
            {
#line 1049
            update_mb_len_index((unsigned char const   *)lexptr, lexleft);
            }
            }
          }
#line 1049
          tmp___75 = lexptr;
#line 1049
          lexptr ++;
#line 1049
          c1 = (unsigned int )((unsigned char )*tmp___75);
#line 1049
          lexleft --;
#line 1050
          if (! hard_LC_COLLATE) {
            {
            {
#line 1051
            while (1) {
              while_continue___19: /* CIL Label */ ;
              while_continue___8: /* CIL Label */ ;
#line 1051
              if (! (c <= c2)) {
#line 1051
                goto while_break___8;
              }
              {
              {
#line 1052
              setbit_case_fold(c, ccl);
              }
#line 1051
              c ++;
              }
            }
            while_break___19: /* CIL Label */ ;
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
#line 1055
            expr[0] = (char )'[';
#line 1055
            expr[1] = (char )c;
#line 1055
            expr[2] = (char )'-';
#line 1055
            expr[3] = (char )c2;
#line 1055
            expr[4] = (char )']';
#line 1055
            expr[5] = (char )'\000';
#line 1057
            if (case_fold) {
#line 1057
              tmp___77 = 1 << 1;
            } else {
#line 1057
              tmp___77 = 0;
            }
            {
            {
#line 1057
            tmp___78 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)(expr),
                               tmp___77);
            }
            }
#line 1057
            if (tmp___78 == 0) {
#line 1058
              c = 0U;
              {
              {
#line 1058
              while (1) {
                while_continue___20: /* CIL Label */ ;
                while_continue___9: /* CIL Label */ ;
#line 1058
                if (! (c < (unsigned int )(1 << 8))) {
#line 1058
                  goto while_break___9;
                }
                {
#line 1059
                buf[0] = (char )c;
#line 1059
                buf[1] = (char )'\000';
                {
#line 1061
                tmp___76 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)(buf),
                                   (size_t )1, & mat, 0);
                }
                }
#line 1061
                if (tmp___76 == 0) {
#line 1061
                  if (mat.rm_so == 0) {
#line 1061
                    if (mat.rm_eo == 1) {
                      {
                      {
#line 1063
                      setbit_case_fold(c, ccl);
                      }
                      }
                    }
                  }
                }
#line 1058
                c ++;
              }
              while_break___20: /* CIL Label */ ;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
              {
#line 1065
              regfree(& re);
              }
              }
            }
          }
#line 1068
          goto __Cont;
        }
      }
      {
      {
#line 1072
      setbit_case_fold(c, ccl);
      }
      }
      skip: ;
      __Cont: /* CIL Label */ 
#line 1009
      c = c1;
#line 1009
      if (! (c != 93U)) {
#line 1009
        goto while_break___5;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1078
    if (invert) {
      {
      {
#line 1080
      notset(ccl);
      }
      }
#line 1081
      if (syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
        {
#line 1082
        clrbit((unsigned int )eolbyte___0, ccl);
        }
        }
      }
    }
    {
    {
#line 1084
    tmp___79 = charclass_index(ccl);
    }
#line 1084
    lasttok = (token )(276 + tmp___79);
    }
#line 1084
    return (lasttok);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1088
    laststart = 0;
#line 1089
    if (case_fold) {
      {
      {
#line 1089
      tmp___81 = __ctype_b_loc();
      }
      }
#line 1089
      if ((int const   )*(*tmp___81 + (int )c) & 1024) {
        {
        {
#line 1091
        zeroset(ccl);
        }
        {
#line 1092
        setbit_case_fold(c, ccl);
        }
        {
#line 1093
        tmp___80 = charclass_index(ccl);
        }
#line 1093
        lasttok = (token )(276 + tmp___80);
        }
#line 1093
        return (lasttok);
      }
    }
#line 1095
    return ((token )c);
    switch_break: /* CIL Label */ ;
    }
#line 724
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1101
  abort();
  }
  }
#line 1102
  return ((token )-1);
}
}
#line 1107 "dfa.c"
static token tok  ;
#line 1108 "dfa.c"
static int depth  ;
#line 1116 "dfa.c"
static void addtok(token t ) 
{ 
  ptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  ptr_t tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 1120
  tmp___2 = __ctype_get_mb_cur_max();
  }
  }
#line 1120
  if (tmp___2 > 1U) {
#line 1122
    if (dfa___0->tindex >= dfa___0->nmultibyte_prop) {
      {
      {
#line 1122
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 1122
        dfa___0->nmultibyte_prop *= 2;
#line 1122
        if (! (dfa___0->tindex >= dfa___0->nmultibyte_prop)) {
#line 1122
          goto while_break;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 1122
      tmp = xrealloc___0((ptr_t )dfa___0->multibyte_prop, (size_t )((unsigned long )dfa___0->nmultibyte_prop * sizeof(int )));
      }
#line 1122
      dfa___0->multibyte_prop = (int *)tmp;
      }
    }
#line 1125
    if ((int )t == 275) {
#line 1126
      *(dfa___0->multibyte_prop + dfa___0->tindex) = ((dfa___0->nmbcsets - 1) << 2) + 3;
    } else
#line 1127
    if ((int )t < 1 << 8) {
#line 1128
      if (cur_mb_len == 1) {
#line 1128
        *(dfa___0->multibyte_prop + dfa___0->tindex) = 3;
      } else {
#line 1128
        if (cur_mb_index == 1) {
#line 1128
          tmp___0 = 1;
        } else {
#line 1128
          tmp___0 = 0;
        }
#line 1128
        if (cur_mb_index == cur_mb_len) {
#line 1128
          tmp___1 = 2;
        } else {
#line 1128
          tmp___1 = 0;
        }
#line 1128
        *(dfa___0->multibyte_prop + dfa___0->tindex) = tmp___0 + tmp___1;
      }
    } else {
#line 1135
      *(dfa___0->multibyte_prop + dfa___0->tindex) = 3;
    }
  }
#line 1139
  if (dfa___0->tindex >= dfa___0->talloc) {
    {
    {
#line 1139
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1139
      dfa___0->talloc *= 2;
#line 1139
      if (! (dfa___0->tindex >= dfa___0->talloc)) {
#line 1139
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1139
    tmp___3 = xrealloc___0((ptr_t )dfa___0->tokens, (size_t )((unsigned long )dfa___0->talloc * sizeof(token )));
    }
#line 1139
    dfa___0->tokens = (token *)tmp___3;
    }
  }
#line 1140
  tmp___4 = dfa___0->tindex;
#line 1140
  (dfa___0->tindex) ++;
#line 1140
  *(dfa___0->tokens + tmp___4) = t;
  {
#line 1146
  if ((int )t == 266) {
#line 1146
    goto case_266;
  }
#line 1146
  if ((int )t == 265) {
#line 1146
    goto case_266;
  }
#line 1146
  if ((int )t == 264) {
#line 1146
    goto case_266;
  }
#line 1151
  if ((int )t == 270) {
#line 1151
    goto case_270;
  }
#line 1151
  if ((int )t == 269) {
#line 1151
    goto case_270;
  }
#line 1151
  if ((int )t == 268) {
#line 1151
    goto case_270;
  }
#line 1157
  if ((int )t == 256) {
#line 1157
    goto case_256;
  }
#line 1155
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1147
  goto switch_break;
  case_270: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1152
  depth --;
#line 1153
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1156
  (dfa___0->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1158
  depth ++;
#line 1159
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1161
  if (depth > dfa___0->depth) {
#line 1162
    dfa___0->depth = depth;
  }
#line 1163
  return;
}
}
#line 1201 "dfa.c"
static void atom(void) 
{ 
  size_t tmp ;
  charclass ccl ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;

  {
#line 1204
  if ((int )tok >= 0) {
#line 1204
    if ((int )tok < 1 << 8) {
#line 1204
      goto _L;
    } else {
#line 1204
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1204
  if ((int )tok >= 276) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 257) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 258) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 259) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 260) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 274) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 275) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 261) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 262) {
#line 1204
    goto _L;
  } else
#line 1204
  if ((int )tok == 263) {
    _L: /* CIL Label */ 
    {
    {
#line 1211
    addtok(tok);
    }
    {
#line 1212
    tok = lex();
    }
    {
#line 1221
    tmp = __ctype_get_mb_cur_max();
    }
    }
#line 1221
    if (tmp > 1U) {
      {
      {
#line 1223
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 1223
        if (cur_mb_index > 1) {
#line 1223
          if ((int )tok >= 0) {
#line 1223
            if (! ((int )tok < 1 << 8)) {
#line 1223
              goto while_break;
            }
          } else {
#line 1223
            goto while_break;
          }
        } else {
#line 1223
          goto while_break;
        }
        {
        {
#line 1225
        addtok(tok);
        }
        {
#line 1226
        addtok((token )268);
        }
        {
#line 1227
        tok = lex();
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 1232
  if ((int )tok == 273) {
    {
    {
#line 1241
    zeroset(ccl);
    }
    {
#line 1242
    notset(ccl);
    }
    {
#line 1243
    tmp___0 = charclass_index(ccl);
    }
    {
#line 1243
    addtok((token )(276 + tmp___0));
    }
    {
#line 1244
    addtok((token )257);
    }
    {
#line 1245
    addtok((token )268);
    }
    {
#line 1246
    tok = lex();
    }
    }
  } else
#line 1248
  if ((int )tok == 271) {
    {
    {
#line 1250
    tok = lex();
    }
    {
#line 1251
    regexp(0);
    }
    }
#line 1252
    if ((int )tok != 272) {
      {
      {
#line 1253
      tmp___1 = dcgettext((char const   *)((void *)0), "Unbalanced (", 5);
      }
      {
#line 1253
      dfaerror((char const   *)tmp___1);
      }
      }
    }
    {
    {
#line 1254
    tok = lex();
    }
    }
  } else {
    {
    {
#line 1257
    addtok((token )256);
    }
    }
  }
#line 1258
  return;
}
}
#line 1261 "dfa.c"
static int nsubtoks(int tindex ) 
{ 
  int ntoks1 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1272
  if ((int )*(dfa___0->tokens + (tindex - 1)) == 266) {
#line 1272
    goto case_266;
  }
#line 1272
  if ((int )*(dfa___0->tokens + (tindex - 1)) == 265) {
#line 1272
    goto case_266;
  }
#line 1272
  if ((int )*(dfa___0->tokens + (tindex - 1)) == 264) {
#line 1272
    goto case_266;
  }
#line 1276
  if ((int )*(dfa___0->tokens + (tindex - 1)) == 270) {
#line 1276
    goto case_270;
  }
#line 1276
  if ((int )*(dfa___0->tokens + (tindex - 1)) == 269) {
#line 1276
    goto case_270;
  }
#line 1276
  if ((int )*(dfa___0->tokens + (tindex - 1)) == 268) {
#line 1276
    goto case_270;
  }
#line 1268
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1269
  return (1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
  {
#line 1273
  tmp = nsubtoks(tindex - 1);
  }
  }
#line 1273
  return (1 + tmp);
  case_270: /* CIL Label */ 
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
  {
#line 1277
  ntoks1 = nsubtoks(tindex - 1);
  }
  {
#line 1278
  tmp___0 = nsubtoks((tindex - 1) - ntoks1);
  }
  }
#line 1278
  return ((1 + ntoks1) + tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1283 "dfa.c"
static void copytoks(int tindex , int ntokens ) 
{ 
  int i ;

  {
#line 1288
  i = 0;
  {
  {
#line 1288
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1288
    if (! (i < ntokens)) {
#line 1288
      goto while_break;
    }
    {
    {
#line 1289
    addtok(*(dfa___0->tokens + (tindex + i)));
    }
#line 1288
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  return;
}
}
#line 1292 "dfa.c"
static void closure(void) 
{ 
  int tindex ;
  int ntokens ;
  int i ;

  {
  {
  {
#line 1297
  atom();
  }
  }
  {
  {
#line 1298
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1298
    if (! ((int )tok == 264)) {
#line 1298
      if (! ((int )tok == 265)) {
#line 1298
        if (! ((int )tok == 266)) {
#line 1298
          if (! ((int )tok == 267)) {
#line 1298
            goto while_break;
          }
        }
      }
    }
#line 1299
    if ((int )tok == 267) {
      {
      {
#line 1301
      ntokens = nsubtoks(dfa___0->tindex);
      }
#line 1302
      tindex = dfa___0->tindex - ntokens;
      }
#line 1303
      if (maxrep < 0) {
        {
        {
#line 1304
        addtok((token )266);
        }
        }
      }
#line 1305
      if (minrep == 0) {
        {
        {
#line 1306
        addtok((token )264);
        }
        }
      }
#line 1307
      i = 1;
      {
      {
#line 1307
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 1307
        if (! (i < minrep)) {
#line 1307
          goto while_break___0;
        }
        {
        {
#line 1309
        copytoks(tindex, ntokens);
        }
        {
#line 1310
        addtok((token )268);
        }
#line 1307
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 1312
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 1312
        if (! (i < maxrep)) {
#line 1312
          goto while_break___1;
        }
        {
        {
#line 1314
        copytoks(tindex, ntokens);
        }
        {
#line 1315
        addtok((token )264);
        }
        {
#line 1316
        addtok((token )268);
        }
#line 1312
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 1318
      tok = lex();
      }
      }
    } else {
      {
      {
#line 1322
      addtok(tok);
      }
      {
#line 1323
      tok = lex();
      }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1325
  return;
}
}
#line 1327 "dfa.c"
static void branch(void) 
{ 


  {
  {
  {
#line 1330
  closure();
  }
  }
  {
  {
#line 1331
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1331
    if ((int )tok != 272) {
#line 1331
      if ((int )tok != 269) {
#line 1331
        if (! ((int )tok >= 0)) {
#line 1331
          goto while_break;
        }
      } else {
#line 1331
        goto while_break;
      }
    } else {
#line 1331
      goto while_break;
    }
    {
    {
#line 1333
    closure();
    }
    {
#line 1334
    addtok((token )268);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1336
  return;
}
}
#line 1338 "dfa.c"
static void regexp(int toplevel ) 
{ 


  {
  {
  {
#line 1341
  branch();
  }
  }
  {
  {
#line 1342
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1342
    if (! ((int )tok == 269)) {
#line 1342
      goto while_break;
    }
    {
    {
#line 1344
    tok = lex();
    }
    {
#line 1345
    branch();
    }
    }
#line 1346
    if (toplevel) {
      {
      {
#line 1347
      addtok((token )270);
      }
      }
    } else {
      {
      {
#line 1349
      addtok((token )269);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  return;
}
}
#line 1356 "dfa.c"
void dfaparse(char const   *s , size_t len , struct dfa *d ) 
{ 
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_29 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1359
  dfa___0 = d;
#line 1360
  lexptr = s;
#line 1360
  lexstart = lexptr;
#line 1361
  lexleft = (int )len;
#line 1362
  lasttok = (token )-1;
#line 1363
  laststart = 1;
#line 1364
  parens = 0;
  {
#line 1366
  hard_LC_COLLATE = hard_locale(3);
  }
  {
#line 1369
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 1369
  if (tmp > 1U) {
#line 1371
    cur_mb_index = 0;
#line 1372
    cur_mb_len = 0;
#line 1373
    if (sizeof(mbstate_t ) <= 16UL) {
#line 1373
      if (sizeof(mbstate_t ) == 1UL) {
#line 1373
        __s___1 = (void *)(& mbs);
#line 1373
        *((__uint8_t *)__s___1) = (__uint8_t )0;
      } else {
#line 1373
        __s___0 = (void *)(& mbs);
#line 1373
        __u = (union __anonunion___u_29 *)__s___0;
#line 1373
        __c = (__uint8_t )0;
        {
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 1373
          goto case_15;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 1373
          goto case_11;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 1373
          goto case_7;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 1373
          goto case_3;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 1373
          goto case_14;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 1373
          goto case_10;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 1373
          goto case_6;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 1373
          goto case_2;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 1373
          goto case_13;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 1373
          goto case_9;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 1373
          goto case_5;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 1373
          goto case_1;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 1373
          goto case_16;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 1373
          goto case_12;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 1373
          goto case_8;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 1373
          goto case_4;
        }
#line 1373
        if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 1373
          goto case_0;
        }
#line 1373
        goto switch_break;
        case_15: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 1373
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 2);
#line 1373
        __u->__uc = __c;
#line 1373
        goto switch_break;
        case_14: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 1373
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 1373
        goto switch_break;
        case_13: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 1373
        __u->__uc = __c;
#line 1373
        goto switch_break;
        case_16: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 1373
        __u = (union __anonunion___u_29 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 1373
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 1373
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 1373
      __s = (void *)(& mbs);
      {
#line 1373
      __builtin_memset(__s, '\000', (int )sizeof(mbstate_t ));
      }
      }
    }
  }
#line 1377
  if (! syntax_bits_set) {
    {
    {
#line 1378
    tmp___0 = dcgettext((char const   *)((void *)0), "No syntax specified", 5);
    }
    {
#line 1378
    dfaerror((char const   *)tmp___0);
    }
    }
  }
  {
  {
#line 1380
  tok = lex();
  }
#line 1381
  depth = d->depth;
  {
#line 1383
  regexp(1);
  }
  }
#line 1385
  if ((int )tok != -1) {
    {
    {
#line 1386
    tmp___1 = dcgettext((char const   *)((void *)0), "Unbalanced )", 5);
    }
    {
#line 1386
    dfaerror((char const   *)tmp___1);
    }
    }
  }
  {
  {
#line 1388
  addtok((token )(-1 - d->nregexps));
  }
  {
#line 1389
  addtok((token )268);
  }
  }
#line 1391
  if (d->nregexps) {
    {
    {
#line 1392
    addtok((token )270);
    }
    }
  }
#line 1394
  (d->nregexps) ++;
#line 1395
  return;
}
}
#line 1400 "dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  int i ;

  {
#line 1405
  i = 0;
  {
  {
#line 1405
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1405
    if (! (i < (int )src->nelem)) {
#line 1405
      goto while_break;
    }
#line 1406
    *(dst->elems + i) = *(src->elems + i);
#line 1405
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1407
  dst->nelem = (int )src->nelem;
#line 1408
  return;
}
}
#line 1414 "dfa.c"
static void insert(position p , position_set *s ) 
{ 
  int i ;
  position t1 ;
  position t2 ;
  int tmp ;

  {
#line 1420
  i = 0;
  {
  {
#line 1420
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1420
    if (i < s->nelem) {
#line 1420
      if (! (p.index < (s->elems + i)->index)) {
#line 1420
        goto while_break;
      }
    } else {
#line 1420
      goto while_break;
    }
#line 1421
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1420
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1422
  if (i < s->nelem) {
#line 1422
    if (p.index == (s->elems + i)->index) {
#line 1423
      (s->elems + i)->constraint |= p.constraint;
    } else {
#line 1422
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1426
    t1 = p;
#line 1427
    (s->nelem) ++;
    {
    {
#line 1428
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1428
      if (! (i < s->nelem)) {
#line 1428
        goto while_break___0;
      }
#line 1430
      t2 = *(s->elems + i);
#line 1431
      tmp = i;
#line 1431
      i ++;
#line 1431
      *(s->elems + tmp) = t1;
#line 1432
      t1 = t2;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1435
  return;
}
}
#line 1439 "dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1442
  i = 0;
#line 1442
  j = 0;
#line 1444
  m->nelem = 0;
  {
  {
#line 1445
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1445
    if (i < (int )s1->nelem) {
#line 1445
      if (! (j < (int )s2->nelem)) {
#line 1445
        goto while_break;
      }
    } else {
#line 1445
      goto while_break;
    }
#line 1446
    if ((s1->elems + i)->index > (s2->elems + j)->index) {
#line 1447
      tmp = m->nelem;
#line 1447
      (m->nelem) ++;
#line 1447
      tmp___0 = i;
#line 1447
      i ++;
#line 1447
      *(m->elems + tmp) = *(s1->elems + tmp___0);
    } else
#line 1448
    if ((s1->elems + i)->index < (s2->elems + j)->index) {
#line 1449
      tmp___1 = m->nelem;
#line 1449
      (m->nelem) ++;
#line 1449
      tmp___2 = j;
#line 1449
      j ++;
#line 1449
      *(m->elems + tmp___1) = *(s2->elems + tmp___2);
    } else {
#line 1452
      tmp___3 = i;
#line 1452
      i ++;
#line 1452
      *(m->elems + m->nelem) = *(s1->elems + tmp___3);
#line 1453
      tmp___4 = m->nelem;
#line 1453
      (m->nelem) ++;
#line 1453
      tmp___5 = j;
#line 1453
      j ++;
#line 1453
      (m->elems + tmp___4)->constraint |= (s2->elems + tmp___5)->constraint;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1455
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1455
    if (! (i < (int )s1->nelem)) {
#line 1455
      goto while_break___0;
    }
#line 1456
    tmp___6 = m->nelem;
#line 1456
    (m->nelem) ++;
#line 1456
    tmp___7 = i;
#line 1456
    i ++;
#line 1456
    *(m->elems + tmp___6) = *(s1->elems + tmp___7);
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1457
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1457
    if (! (j < (int )s2->nelem)) {
#line 1457
      goto while_break___1;
    }
#line 1458
    tmp___8 = m->nelem;
#line 1458
    (m->nelem) ++;
#line 1458
    tmp___9 = j;
#line 1458
    j ++;
#line 1458
    *(m->elems + tmp___8) = *(s2->elems + tmp___9);
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1459
  return;
}
}
#line 1462 "dfa.c"
static void delete(position p , position_set *s ) 
{ 
  int i ;

  {
#line 1467
  i = 0;
  {
  {
#line 1467
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1467
    if (! (i < s->nelem)) {
#line 1467
      goto while_break;
    }
#line 1468
    if (p.index == (s->elems + i)->index) {
#line 1469
      goto while_break;
    }
#line 1467
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1470
  if (i < s->nelem) {
#line 1471
    (s->nelem) --;
    {
    {
#line 1471
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1471
      if (! (i < s->nelem)) {
#line 1471
        goto while_break___0;
      }
#line 1472
      *(s->elems + i) = *(s->elems + (i + 1));
#line 1471
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1473
  return;
}
}
#line 1479 "dfa.c"
static int state_index(struct dfa *d , position_set const   *s , int newline___0 ,
                       int letter ) 
{ 
  int hash ;
  int constraint ;
  int i ;
  int j ;
  ptr_t tmp ;
  ptr_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1482
  hash = 0;
#line 1486
  if (newline___0) {
#line 1486
    newline___0 = 1;
  } else {
#line 1486
    newline___0 = 0;
  }
#line 1487
  if (letter) {
#line 1487
    letter = 1;
  } else {
#line 1487
    letter = 0;
  }
#line 1489
  i = 0;
  {
  {
#line 1489
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1489
    if (! (i < (int )s->nelem)) {
#line 1489
      goto while_break;
    }
#line 1490
    hash = (int )((unsigned int )hash ^ ((s->elems + i)->index + (s->elems + i)->constraint));
#line 1489
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1493
  i = 0;
  {
  {
#line 1493
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1493
    if (! (i < d->sindex)) {
#line 1493
      goto while_break___0;
    }
#line 1495
    if (hash != (d->states + i)->hash) {
#line 1497
      goto __Cont;
    } else
#line 1495
    if (s->nelem != (int const   )(d->states + i)->elems.nelem) {
#line 1497
      goto __Cont;
    } else
#line 1495
    if (newline___0 != (int )(d->states + i)->newline) {
#line 1497
      goto __Cont;
    } else
#line 1495
    if (letter != (int )(d->states + i)->letter) {
#line 1497
      goto __Cont;
    }
#line 1498
    j = 0;
    {
    {
#line 1498
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1498
      if (! (j < (int )s->nelem)) {
#line 1498
        goto while_break___1;
      }
#line 1499
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 1502
        goto while_break___1;
      } else
#line 1499
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 1502
        goto while_break___1;
      }
#line 1498
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1503
    if (j == (int )s->nelem) {
#line 1504
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 1493
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1508
  if (d->sindex >= d->salloc) {
    {
    {
#line 1508
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1508
      d->salloc *= 2;
#line 1508
      if (! (d->sindex >= d->salloc)) {
#line 1508
        goto while_break___2;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 1508
    tmp = xrealloc___0((ptr_t )d->states, (size_t )((unsigned long )d->salloc * sizeof(dfa_state )));
    }
#line 1508
    d->states = (dfa_state *)tmp;
    }
  }
  {
#line 1509
  (d->states + i)->hash = hash;
  {
#line 1510
  tmp___0 = xmalloc___0((size_t )((unsigned long )s->nelem * sizeof(position )));
  }
#line 1510
  (d->states + i)->elems.elems = (position *)tmp___0;
  {
#line 1511
  copy(s, & (d->states + i)->elems);
  }
#line 1512
  (d->states + i)->newline = (char )newline___0;
#line 1513
  (d->states + i)->letter = (char )letter;
#line 1514
  (d->states + i)->backref = (char)0;
#line 1515
  (d->states + i)->constraint = (unsigned char)0;
#line 1516
  (d->states + i)->first_end = 0;
  {
#line 1518
  tmp___1 = __ctype_get_mb_cur_max();
  }
  }
#line 1518
  if (tmp___1 > 1U) {
#line 1519
    (d->states + i)->mbps.nelem = 0;
  }
#line 1521
  j = 0;
  {
  {
#line 1521
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 1521
    if (! (j < (int )s->nelem)) {
#line 1521
      goto while_break___3;
    }
#line 1522
    if ((int )*(d->tokens + (s->elems + j)->index) < 0) {
#line 1524
      constraint = (int )(s->elems + j)->constraint;
#line 1525
      if (newline___0) {
#line 1525
        tmp___2 = 2;
      } else {
#line 1525
        tmp___2 = 0;
      }
#line 1525
      if (constraint & (1 << (tmp___2 + 4))) {
#line 1525
        if (letter) {
#line 1525
          tmp___3 = 2;
        } else {
#line 1525
          tmp___3 = 0;
        }
#line 1525
        if (constraint & (1 << tmp___3)) {
#line 1529
          (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
        } else {
#line 1525
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 1525
        if (newline___0) {
#line 1525
          tmp___4 = 2;
        } else {
#line 1525
          tmp___4 = 0;
        }
#line 1525
        if (constraint & (1 << (tmp___4 + 4))) {
#line 1525
          if (letter) {
#line 1525
            tmp___5 = 2;
          } else {
#line 1525
            tmp___5 = 0;
          }
#line 1525
          if (constraint & (1 << (tmp___5 + 1))) {
#line 1529
            (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
          } else {
#line 1525
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 1525
          if (newline___0) {
#line 1525
            tmp___6 = 2;
          } else {
#line 1525
            tmp___6 = 0;
          }
#line 1525
          if (constraint & (1 << ((tmp___6 + 1) + 4))) {
#line 1525
            if (letter) {
#line 1525
              tmp___7 = 2;
            } else {
#line 1525
              tmp___7 = 0;
            }
#line 1525
            if (constraint & (1 << tmp___7)) {
#line 1529
              (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
            } else {
#line 1525
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1525
            if (newline___0) {
#line 1525
              tmp___8 = 2;
            } else {
#line 1525
              tmp___8 = 0;
            }
#line 1525
            if (constraint & (1 << ((tmp___8 + 1) + 4))) {
#line 1525
              if (letter) {
#line 1525
                tmp___9 = 2;
              } else {
#line 1525
                tmp___9 = 0;
              }
#line 1525
              if (constraint & (1 << (tmp___9 + 1))) {
#line 1529
                (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
              }
            }
          }
        }
      }
#line 1530
      if (! (d->states + i)->first_end) {
#line 1531
        (d->states + i)->first_end = (int )*(d->tokens + (s->elems + j)->index);
      }
    } else
#line 1533
    if ((int )*(d->tokens + (s->elems + j)->index) == 257) {
#line 1535
      (d->states + i)->constraint = (unsigned char)255;
#line 1536
      (d->states + i)->backref = (char)1;
    }
#line 1521
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1539
  (d->sindex) ++;
#line 1541
  return (i);
}
}
#line 1549 "dfa.c"
static void epsclosure(position_set *s , struct dfa  const  *d ) 
{ 
  int i ;
  int j ;
  int *visited ;
  position p ;
  position old ;
  ptr_t tmp ;

  {
  {
  {
#line 1556
  tmp = xmalloc___0((size_t )((unsigned long )d->tindex * sizeof(int )));
  }
#line 1556
  visited = (int *)tmp;
#line 1557
  i = 0;
  }
  {
  {
#line 1557
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1557
    if (! (i < (int )d->tindex)) {
#line 1557
      goto while_break;
    }
#line 1558
    *(visited + i) = 0;
#line 1557
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1560
  i = 0;
  {
  {
#line 1560
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1560
    if (! (i < s->nelem)) {
#line 1560
      goto while_break___0;
    }
#line 1561
    if ((int )*(d->tokens + (s->elems + i)->index) >= 1 << 8) {
#line 1561
      if ((int )*(d->tokens + (s->elems + i)->index) != 257) {
#line 1561
        if ((int )*(d->tokens + (s->elems + i)->index) != 274) {
#line 1561
          if ((int )*(d->tokens + (s->elems + i)->index) != 275) {
#line 1561
            if ((int )*(d->tokens + (s->elems + i)->index) < 276) {
              {
#line 1569
              old = *(s->elems + i);
#line 1570
              p.constraint = old.constraint;
              {
#line 1571
              delete(*(s->elems + i), s);
              }
              }
#line 1572
              if (*(visited + old.index)) {
#line 1574
                i --;
#line 1575
                goto __Cont;
              }
#line 1577
              *(visited + old.index) = 1;
              {
#line 1580
              if ((int )*(d->tokens + old.index) == 258) {
#line 1580
                goto case_258;
              }
#line 1583
              if ((int )*(d->tokens + old.index) == 259) {
#line 1583
                goto case_259;
              }
#line 1586
              if ((int )*(d->tokens + old.index) == 260) {
#line 1586
                goto case_260;
              }
#line 1589
              if ((int )*(d->tokens + old.index) == 261) {
#line 1589
                goto case_261;
              }
#line 1592
              if ((int )*(d->tokens + old.index) == 262) {
#line 1592
                goto case_262;
              }
#line 1595
              if ((int )*(d->tokens + old.index) == 263) {
#line 1595
                goto case_263;
              }
#line 1598
              goto switch_default;
              case_258: /* CIL Label */ 
#line 1581
              p.constraint &= 207U;
#line 1582
              goto switch_break;
              case_259: /* CIL Label */ 
#line 1584
              p.constraint &= 175U;
#line 1585
              goto switch_break;
              case_260: /* CIL Label */ 
#line 1587
              p.constraint &= 242U;
#line 1588
              goto switch_break;
              case_261: /* CIL Label */ 
#line 1590
              p.constraint &= 244U;
#line 1591
              goto switch_break;
              case_262: /* CIL Label */ 
#line 1593
              p.constraint &= 246U;
#line 1594
              goto switch_break;
              case_263: /* CIL Label */ 
#line 1596
              p.constraint &= 249U;
#line 1597
              goto switch_break;
              switch_default: /* CIL Label */ 
#line 1599
              goto switch_break;
              switch_break: /* CIL Label */ ;
              }
#line 1601
              j = 0;
              {
              {
#line 1601
              while (1) {
                while_continue___4: /* CIL Label */ ;
                while_continue___1: /* CIL Label */ ;
#line 1601
                if (! (j < (d->follows + old.index)->nelem)) {
#line 1601
                  goto while_break___1;
                }
                {
#line 1603
                p.index = ((d->follows + old.index)->elems + j)->index;
                {
#line 1604
                insert(p, s);
                }
#line 1601
                j ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 1607
              i = -1;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1560
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1610
  free((void *)visited);
  }
  }
#line 1611
  return;
}
}
#line 1665 "dfa.c"
void dfaanalyze(struct dfa *d , int searchflag ) 
{ 
  int *nullable ;
  int *nfirstpos ;
  position *firstpos ;
  int *nlastpos ;
  position *lastpos ;
  int *nalloc ;
  position_set tmp ;
  position_set merged ;
  int wants_newline ;
  int *o_nullable ;
  int *o_nfirst ;
  int *o_nlast ;
  position *o_firstpos ;
  position *o_lastpos ;
  int i ;
  int j ;
  position *pos ;
  ptr_t tmp___0 ;
  ptr_t tmp___1 ;
  ptr_t tmp___2 ;
  ptr_t tmp___3 ;
  ptr_t tmp___4 ;
  ptr_t tmp___5 ;
  ptr_t tmp___6 ;
  ptr_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  ptr_t tmp___12 ;
  ptr_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  ptr_t tmp___22 ;
  ptr_t tmp___23 ;
  ptr_t tmp___24 ;

  {
  {
#line 1693
  d->searchflag = searchflag;
  {
#line 1695
  tmp___0 = xmalloc___0((size_t )((unsigned long )d->depth * sizeof(int )));
  }
#line 1695
  nullable = (int *)tmp___0;
#line 1696
  o_nullable = nullable;
  {
#line 1697
  tmp___1 = xmalloc___0((size_t )((unsigned long )d->depth * sizeof(int )));
  }
#line 1697
  nfirstpos = (int *)tmp___1;
#line 1698
  o_nfirst = nfirstpos;
  {
#line 1699
  tmp___2 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
  }
#line 1699
  firstpos = (position *)tmp___2;
#line 1700
  o_firstpos = firstpos;
#line 1700
  firstpos += d->nleaves;
  {
#line 1701
  tmp___3 = xmalloc___0((size_t )((unsigned long )d->depth * sizeof(int )));
  }
#line 1701
  nlastpos = (int *)tmp___3;
#line 1702
  o_nlast = nlastpos;
  {
#line 1703
  tmp___4 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
  }
#line 1703
  lastpos = (position *)tmp___4;
#line 1704
  o_lastpos = lastpos;
#line 1704
  lastpos += d->nleaves;
  {
#line 1705
  tmp___5 = xmalloc___0((size_t )((unsigned long )d->tindex * sizeof(int )));
  }
#line 1705
  nalloc = (int *)tmp___5;
#line 1706
  i = 0;
  }
  {
  {
#line 1706
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1706
    if (! (i < d->tindex)) {
#line 1706
      goto while_break;
    }
#line 1707
    *(nalloc + i) = 0;
#line 1706
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1708
  tmp___6 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
  }
#line 1708
  merged.elems = (position *)tmp___6;
  {
#line 1710
  tmp___7 = xcalloc___0((size_t )d->tindex, (size_t )sizeof(position_set ));
  }
#line 1710
  d->follows = (position_set *)tmp___7;
#line 1712
  i = 0;
  }
  {
  {
#line 1712
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1712
    if (! (i < d->tindex)) {
#line 1712
      goto while_break___0;
    }
    {
#line 1718
    if ((int )*(d->tokens + i) == 256) {
#line 1718
      goto case_256;
    }
#line 1727
    if ((int )*(d->tokens + i) == 266) {
#line 1727
      goto case_266;
    }
#line 1727
    if ((int )*(d->tokens + i) == 265) {
#line 1727
      goto case_266;
    }
#line 1741
    if ((int )*(d->tokens + i) == 264) {
#line 1741
      goto case_264;
    }
#line 1747
    if ((int )*(d->tokens + i) == 268) {
#line 1747
      goto case_268;
    }
#line 1789
    if ((int )*(d->tokens + i) == 270) {
#line 1789
      goto case_270;
    }
#line 1789
    if ((int )*(d->tokens + i) == 269) {
#line 1789
      goto case_270;
    }
#line 1803
    goto switch_default;
    case_256: /* CIL Label */ 
#line 1720
    tmp___8 = nullable;
#line 1720
    nullable ++;
#line 1720
    *tmp___8 = 1;
#line 1723
    tmp___9 = nfirstpos;
#line 1723
    nfirstpos ++;
#line 1723
    tmp___10 = nlastpos;
#line 1723
    nlastpos ++;
#line 1723
    tmp___11 = 0;
#line 1723
    *tmp___10 = tmp___11;
#line 1723
    *tmp___9 = tmp___11;
#line 1724
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 1730
    tmp.nelem = *(nfirstpos + -1);
#line 1731
    tmp.elems = firstpos;
#line 1732
    pos = lastpos;
#line 1733
    j = 0;
    {
    {
#line 1733
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1733
      if (! (j < *(nlastpos + -1))) {
#line 1733
        goto while_break___1;
      }
      {
      {
#line 1735
      merge((position_set const   *)(& tmp), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
      }
      }
#line 1736
      if (merged.nelem - 1 >= *(nalloc + (pos + j)->index)) {
        {
        {
#line 1736
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 1736
          *(nalloc + (pos + j)->index) *= 2;
#line 1736
          if (! (merged.nelem - 1 >= *(nalloc + (pos + j)->index))) {
#line 1736
            goto while_break___2;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        {
#line 1736
        tmp___12 = xrealloc___0((ptr_t )(d->follows + (pos + j)->index)->elems, (size_t )((unsigned long )*(nalloc + (pos + j)->index) * sizeof(position )));
        }
#line 1736
        (d->follows + (pos + j)->index)->elems = (position *)tmp___12;
        }
      }
      {
      {
#line 1738
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
      }
#line 1733
      j ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 1743
    if ((int )*(d->tokens + i) != 266) {
#line 1744
      *(nullable + -1) = 1;
    }
#line 1745
    goto switch_break;
    case_268: /* CIL Label */ 
#line 1750
    tmp.nelem = *(nfirstpos + -1);
#line 1751
    tmp.elems = firstpos;
#line 1752
    pos = lastpos + *(nlastpos + -1);
#line 1753
    j = 0;
    {
    {
#line 1753
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 1753
      if (! (j < *(nlastpos + -2))) {
#line 1753
        goto while_break___3;
      }
      {
      {
#line 1755
      merge((position_set const   *)(& tmp), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
      }
      }
#line 1756
      if (merged.nelem - 1 >= *(nalloc + (pos + j)->index)) {
        {
        {
#line 1756
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 1756
          *(nalloc + (pos + j)->index) *= 2;
#line 1756
          if (! (merged.nelem - 1 >= *(nalloc + (pos + j)->index))) {
#line 1756
            goto while_break___4;
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
        {
#line 1756
        tmp___13 = xrealloc___0((ptr_t )(d->follows + (pos + j)->index)->elems, (size_t )((unsigned long )*(nalloc + (pos + j)->index) * sizeof(position )));
        }
#line 1756
        (d->follows + (pos + j)->index)->elems = (position *)tmp___13;
        }
      }
      {
      {
#line 1758
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
      }
#line 1753
      j ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1763
    if (*(nullable + -2)) {
#line 1764
      *(nfirstpos + -2) += *(nfirstpos + -1);
    } else {
#line 1766
      firstpos += *(nfirstpos + -1);
    }
#line 1767
    nfirstpos --;
#line 1771
    if (*(nullable + -1)) {
#line 1772
      *(nlastpos + -2) += *(nlastpos + -1);
    } else {
#line 1775
      pos = lastpos + *(nlastpos + -2);
#line 1776
      j = *(nlastpos + -1) - 1;
      {
      {
#line 1776
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 1776
        if (! (j >= 0)) {
#line 1776
          goto while_break___5;
        }
#line 1777
        *(pos + j) = *(lastpos + j);
#line 1776
        j --;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1778
      lastpos += *(nlastpos + -2);
#line 1779
      *(nlastpos + -2) = *(nlastpos + -1);
    }
#line 1781
    nlastpos --;
#line 1784
    if (*(nullable + -1)) {
#line 1784
      if (*(nullable + -2)) {
#line 1784
        tmp___14 = 1;
      } else {
#line 1784
        tmp___14 = 0;
      }
    } else {
#line 1784
      tmp___14 = 0;
    }
#line 1784
    *(nullable + -2) = tmp___14;
#line 1785
    nullable --;
#line 1786
    goto switch_break;
    case_270: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 1791
    *(nfirstpos + -2) += *(nfirstpos + -1);
#line 1792
    nfirstpos --;
#line 1795
    *(nlastpos + -2) += *(nlastpos + -1);
#line 1796
    nlastpos --;
#line 1799
    if (*(nullable + -1)) {
#line 1799
      tmp___15 = 1;
    } else
#line 1799
    if (*(nullable + -2)) {
#line 1799
      tmp___15 = 1;
    } else {
#line 1799
      tmp___15 = 0;
    }
#line 1799
    *(nullable + -2) = tmp___15;
#line 1800
    nullable --;
#line 1801
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1809
    tmp___16 = nullable;
#line 1809
    nullable ++;
#line 1809
    *tmp___16 = (int )*(d->tokens + i) == 257;
#line 1812
    tmp___17 = nfirstpos;
#line 1812
    nfirstpos ++;
#line 1812
    tmp___18 = nlastpos;
#line 1812
    nlastpos ++;
#line 1812
    tmp___19 = 1;
#line 1812
    *tmp___18 = tmp___19;
#line 1812
    *tmp___17 = tmp___19;
#line 1813
    firstpos --;
#line 1813
    lastpos --;
#line 1814
    tmp___20 = (unsigned int )i;
#line 1814
    lastpos->index = tmp___20;
#line 1814
    firstpos->index = tmp___20;
#line 1815
    tmp___21 = 255U;
#line 1815
    lastpos->constraint = tmp___21;
#line 1815
    firstpos->constraint = tmp___21;
#line 1818
    *(nalloc + i) = 1;
    {
#line 1819
    tmp___22 = xmalloc___0((size_t )((unsigned long )*(nalloc + i) * sizeof(position )));
    }
#line 1819
    (d->follows + i)->elems = (position *)tmp___22;
    }
#line 1820
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1712
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1846
  i = 0;
  {
  {
#line 1846
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 1846
    if (! (i < d->tindex)) {
#line 1846
      goto while_break___6;
    }
#line 1847
    if ((int )*(d->tokens + i) < 1 << 8) {
#line 1847
      goto _L;
    } else
#line 1847
    if ((int )*(d->tokens + i) == 257) {
#line 1847
      goto _L;
    } else
#line 1847
    if ((int )*(d->tokens + i) == 274) {
#line 1847
      goto _L;
    } else
#line 1847
    if ((int )*(d->tokens + i) == 275) {
#line 1847
      goto _L;
    } else
#line 1847
    if ((int )*(d->tokens + i) >= 276) {
      _L: /* CIL Label */ 
      {
      {
#line 1865
      copy((position_set const   *)(d->follows + i), & merged);
      }
      {
#line 1866
      epsclosure(& merged, (struct dfa  const  *)d);
      }
      }
#line 1867
      if ((d->follows + i)->nelem < merged.nelem) {
        {
        {
#line 1868
        tmp___23 = xrealloc___0((ptr_t )(d->follows + i)->elems, (size_t )((unsigned long )merged.nelem * sizeof(position )));
        }
#line 1868
        (d->follows + i)->elems = (position *)tmp___23;
        }
      }
      {
      {
#line 1869
      copy((position_set const   *)(& merged), d->follows + i);
      }
      }
    }
#line 1846
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1874
  merged.nelem = 0;
#line 1875
  i = 0;
  {
  {
#line 1875
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 1875
    if (! (i < *(nfirstpos + -1))) {
#line 1875
      goto while_break___7;
    }
    {
    {
#line 1876
    insert(*(firstpos + i), & merged);
    }
#line 1875
    i ++;
    }
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
  {
#line 1877
  epsclosure(& merged, (struct dfa  const  *)d);
  }
#line 1880
  wants_newline = 0;
#line 1881
  i = 0;
  }
  {
  {
#line 1881
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 1881
    if (! (i < merged.nelem)) {
#line 1881
      goto while_break___8;
    }
#line 1882
    if (((merged.elems + i)->constraint & 192U) >> 2 != ((merged.elems + i)->constraint & 48U)) {
#line 1883
      wants_newline = 1;
    }
#line 1881
    i ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1886
  d->salloc = 1;
#line 1887
  d->sindex = 0;
  {
#line 1888
  tmp___24 = xmalloc___0((size_t )((unsigned long )d->salloc * sizeof(dfa_state )));
  }
#line 1888
  d->states = (dfa_state *)tmp___24;
  {
#line 1889
  state_index(d, (position_set const   *)(& merged), wants_newline, 0);
  }
  {
#line 1891
  free((void *)o_nullable);
  }
  {
#line 1892
  free((void *)o_nfirst);
  }
  {
#line 1893
  free((void *)o_firstpos);
  }
  {
#line 1894
  free((void *)o_nlast);
  }
  {
#line 1895
  free((void *)o_lastpos);
  }
  {
#line 1896
  free((void *)nalloc);
  }
  {
#line 1897
  free((void *)merged.elems);
  }
  }
#line 1898
  return;
}
}
#line 1943 "dfa.c"
static charclass letters  ;
#line 1944 "dfa.c"
static charclass newline  ;
#line 1952 "dfa.c"
static int initialized  ;
#line 1930 "dfa.c"
void dfastate(int s , struct dfa *d , int *trans___0 ) 
{ 
  position_set grps[1 << 8] ;
  charclass labels[1 << 8] ;
  int ngrps ;
  position pos ;
  charclass matches ;
  int matchesf ;
  charclass intersect ;
  int intersectf ;
  charclass leftovers ;
  int leftoversf ;
  position_set follows ;
  position_set tmp ;
  int state ;
  int wants_newline ;
  int state_newline ;
  int wants_letter ;
  int state_letter ;
  int next_isnt_1st_byte ;
  int i ;
  int j ;
  int k ;
  unsigned short const   **tmp___0 ;
  ptr_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int match ;
  int label___0 ;
  int tmp___8 ;
  int tmp___9 ;
  ptr_t tmp___10 ;
  int tmp___11 ;
  ptr_t tmp___12 ;
  ptr_t tmp___13 ;
  ptr_t tmp___14 ;
  unsigned short const   **tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int c ;
  unsigned short const   **tmp___20 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;

  {
#line 1935
  ngrps = 0;
#line 1954
  next_isnt_1st_byte = 0;
#line 1959
  if (! initialized) {
#line 1961
    initialized = 1;
#line 1962
    i = 0;
    {
    {
#line 1962
    while (1) {
      while_continue___22: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1962
      if (! (i < 1 << 8)) {
#line 1962
        goto while_break;
      }
      {
      {
#line 1963
      tmp___0 = __ctype_b_loc();
      }
      }
#line 1963
      if ((int const   )*(*tmp___0 + i) & 8) {
        {
        {
#line 1964
        setbit((unsigned int )i, letters);
        }
        }
      } else
#line 1963
      if (i == 95) {
        {
        {
#line 1964
        setbit((unsigned int )i, letters);
        }
        }
      }
#line 1962
      i ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1965
    setbit((unsigned int )eolbyte___0, newline);
    }
    }
  }
  {
  {
#line 1968
  zeroset(matches);
  }
#line 1970
  i = 0;
  }
  {
  {
#line 1970
  while (1) {
    while_continue___23: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1970
    if (! (i < (d->states + s)->elems.nelem)) {
#line 1970
      goto while_break___0;
    }
#line 1972
    pos = *((d->states + s)->elems.elems + i);
#line 1973
    if ((int )*(d->tokens + pos.index) >= 0) {
#line 1973
      if ((int )*(d->tokens + pos.index) < 1 << 8) {
        {
        {
#line 1974
        setbit((unsigned int )*(d->tokens + pos.index), matches);
        }
        }
      } else {
#line 1973
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1975
    if ((int )*(d->tokens + pos.index) >= 276) {
      {
      {
#line 1976
      copyset(*(d->charclasses + ((int )*(d->tokens + pos.index) - 276)), matches);
      }
      }
    } else
#line 1978
    if ((int )*(d->tokens + pos.index) == 274) {
#line 1978
      goto _L;
    } else
#line 1978
    if ((int )*(d->tokens + pos.index) == 275) {
      _L: /* CIL Label */ 
#line 1985
      if ((d->states + s)->mbps.nelem == 0) {
        {
        {
#line 1987
        tmp___1 = xmalloc___0((size_t )((unsigned long )(d->states + s)->elems.nelem * sizeof(position )));
        }
#line 1987
        (d->states + s)->mbps.elems = (position *)tmp___1;
        }
      }
      {
      {
#line 1990
      insert(pos, & (d->states + s)->mbps);
      }
      }
#line 1991
      goto __Cont;
    } else {
#line 1995
      goto __Cont;
    }
#line 1999
    if (pos.constraint != 255U) {
#line 2001
      if ((d->states + s)->newline) {
#line 2001
        tmp___2 = 2;
      } else {
#line 2001
        tmp___2 = 0;
      }
#line 2001
      if (! (pos.constraint & (unsigned int )(1 << ((tmp___2 + 1) + 4)))) {
        {
        {
#line 2003
        clrbit((unsigned int )eolbyte___0, matches);
        }
        }
      }
#line 2004
      if ((d->states + s)->newline) {
#line 2004
        tmp___3 = 2;
      } else {
#line 2004
        tmp___3 = 0;
      }
#line 2004
      if (! (pos.constraint & (unsigned int )(1 << (tmp___3 + 4)))) {
#line 2006
        j = 0;
        {
        {
#line 2006
        while (1) {
          while_continue___24: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 2006
          if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2006
            goto while_break___1;
          }
#line 2007
          matches[j] &= newline[j];
#line 2006
          j ++;
        }
        while_break___24: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 2008
      if ((d->states + s)->letter) {
#line 2008
        tmp___4 = 2;
      } else {
#line 2008
        tmp___4 = 0;
      }
#line 2008
      if (! (pos.constraint & (unsigned int )(1 << (tmp___4 + 1)))) {
#line 2010
        j = 0;
        {
        {
#line 2010
        while (1) {
          while_continue___25: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 2010
          if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2010
            goto while_break___2;
          }
#line 2011
          matches[j] &= ~ letters[j];
#line 2010
          j ++;
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 2012
      if ((d->states + s)->letter) {
#line 2012
        tmp___5 = 2;
      } else {
#line 2012
        tmp___5 = 0;
      }
#line 2012
      if (! (pos.constraint & (unsigned int )(1 << tmp___5))) {
#line 2014
        j = 0;
        {
        {
#line 2014
        while (1) {
          while_continue___26: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 2014
          if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2014
            goto while_break___3;
          }
#line 2015
          matches[j] &= letters[j];
#line 2014
          j ++;
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2018
      j = 0;
      {
      {
#line 2018
      while (1) {
        while_continue___27: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 2018
        if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2018
          if (! (! matches[j])) {
#line 2018
            goto while_break___4;
          }
        } else {
#line 2018
          goto while_break___4;
        }
#line 2019
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 2018
        j ++;
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2020
      if ((unsigned long )j == (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2021
        goto __Cont;
      }
    }
#line 2024
    j = 0;
    {
    {
#line 2024
    while (1) {
      while_continue___28: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 2024
      if (! (j < ngrps)) {
#line 2024
        goto while_break___5;
      }
#line 2029
      if ((int )*(d->tokens + pos.index) >= 0) {
#line 2029
        if ((int )*(d->tokens + pos.index) < 1 << 8) {
          {
          {
#line 2029
          tmp___6 = tstbit((unsigned int )*(d->tokens + pos.index), labels[j]);
          }
          }
#line 2029
          if (! tmp___6) {
#line 2031
            goto __Cont___1;
          }
        }
      }
#line 2035
      intersectf = 0;
#line 2036
      k = 0;
      {
      {
#line 2036
      while (1) {
        while_continue___29: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 2036
        if (! ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2036
          goto while_break___6;
        }
#line 2037
        tmp___7 = matches[k] & labels[j][k];
#line 2037
        intersect[k] = tmp___7;
#line 2037
        if (tmp___7) {
#line 2037
          intersectf = 1;
        }
#line 2036
        k ++;
      }
      while_break___29: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2038
      if (! intersectf) {
#line 2039
        goto __Cont___1;
      }
#line 2042
      matchesf = 0;
#line 2042
      leftoversf = matchesf;
#line 2043
      k = 0;
      {
      {
#line 2043
      while (1) {
        while_continue___30: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 2043
        if (! ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2043
          goto while_break___7;
        }
#line 2046
        match = matches[k];
#line 2046
        label___0 = labels[j][k];
#line 2048
        tmp___8 = ~ match & label___0;
#line 2048
        leftovers[k] = tmp___8;
#line 2048
        if (tmp___8) {
#line 2048
          leftoversf = 1;
        }
#line 2049
        tmp___9 = match & ~ label___0;
#line 2049
        matches[k] = tmp___9;
#line 2049
        if (tmp___9) {
#line 2049
          matchesf = 1;
        }
#line 2043
        k ++;
      }
      while_break___30: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 2053
      if (leftoversf) {
        {
        {
#line 2055
        copyset(leftovers, labels[ngrps]);
        }
        {
#line 2056
        copyset(intersect, labels[j]);
        }
        {
#line 2057
        tmp___10 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
        }
#line 2057
        grps[ngrps].elems = (position *)tmp___10;
        {
#line 2058
        copy((position_set const   *)(& grps[j]), & grps[ngrps]);
        }
#line 2059
        ngrps ++;
        }
      }
#line 2064
      tmp___11 = grps[j].nelem;
#line 2064
      (grps[j].nelem) ++;
#line 2064
      *(grps[j].elems + tmp___11) = pos;
#line 2068
      if (! matchesf) {
#line 2069
        goto while_break___5;
      }
      __Cont___1: /* CIL Label */ 
#line 2024
      j ++;
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2074
    if (j == ngrps) {
      {
      {
#line 2076
      copyset(matches, labels[ngrps]);
      }
      {
#line 2077
      zeroset(matches);
      }
      {
#line 2078
      tmp___12 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
      }
#line 2078
      grps[ngrps].elems = (position *)tmp___12;
#line 2079
      grps[ngrps].nelem = 1;
#line 2080
      *(grps[ngrps].elems + 0) = pos;
#line 2081
      ngrps ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 1970
    i ++;
  }
  while_break___23: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 2085
  tmp___13 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
  }
#line 2085
  follows.elems = (position *)tmp___13;
  {
#line 2086
  tmp___14 = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
  }
#line 2086
  tmp.elems = (position *)tmp___14;
  }
#line 2091
  if (d->searchflag) {
#line 2093
    wants_newline = 0;
#line 2094
    wants_letter = 0;
#line 2095
    i = 0;
    {
    {
#line 2095
    while (1) {
      while_continue___31: /* CIL Label */ ;
      while_continue___8: /* CIL Label */ ;
#line 2095
      if (! (i < (d->states + 0)->elems.nelem)) {
#line 2095
        goto while_break___8;
      }
#line 2097
      if ((((d->states + 0)->elems.elems + i)->constraint & 192U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 48U)) {
#line 2098
        wants_newline = 1;
      }
#line 2099
      if ((((d->states + 0)->elems.elems + i)->constraint & 12U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 3U)) {
#line 2100
        wants_letter = 1;
      }
#line 2095
      i ++;
    }
    while_break___31: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
    {
#line 2102
    copy((position_set const   *)(& (d->states + 0)->elems), & follows);
    }
    {
#line 2103
    state = state_index(d, (position_set const   *)(& follows), 0, 0);
    }
    }
#line 2104
    if (wants_newline) {
      {
      {
#line 2105
      state_newline = state_index(d, (position_set const   *)(& follows), 1, 0);
      }
      }
    } else {
#line 2107
      state_newline = state;
    }
#line 2108
    if (wants_letter) {
      {
      {
#line 2109
      state_letter = state_index(d, (position_set const   *)(& follows), 0, 1);
      }
      }
    } else {
#line 2111
      state_letter = state;
    }
#line 2112
    i = 0;
    {
    {
#line 2112
    while (1) {
      while_continue___32: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 2112
      if (! (i < 1 << 8)) {
#line 2112
        goto while_break___9;
      }
      {
      {
#line 2113
      tmp___16 = __ctype_b_loc();
      }
      }
#line 2113
      if ((int const   )*(*tmp___16 + i) & 8) {
#line 2113
        *(trans___0 + i) = state_letter;
      } else
#line 2113
      if (i == 95) {
#line 2113
        *(trans___0 + i) = state_letter;
      } else {
#line 2113
        *(trans___0 + i) = state;
      }
#line 2112
      i ++;
    }
    while_break___32: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2114
    *(trans___0 + eolbyte___0) = state_newline;
  } else {
#line 2117
    i = 0;
    {
    {
#line 2117
    while (1) {
      while_continue___33: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 2117
      if (! (i < 1 << 8)) {
#line 2117
        goto while_break___10;
      }
#line 2118
      *(trans___0 + i) = -1;
#line 2117
      i ++;
    }
    while_break___33: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 2120
  i = 0;
  {
  {
#line 2120
  while (1) {
    while_continue___34: /* CIL Label */ ;
    while_continue___11: /* CIL Label */ ;
#line 2120
    if (! (i < ngrps)) {
#line 2120
      goto while_break___11;
    }
#line 2122
    follows.nelem = 0;
#line 2126
    j = 0;
    {
    {
#line 2126
    while (1) {
      while_continue___35: /* CIL Label */ ;
      while_continue___12: /* CIL Label */ ;
#line 2126
      if (! (j < grps[i].nelem)) {
#line 2126
        goto while_break___12;
      }
#line 2127
      k = 0;
      {
      {
#line 2127
      while (1) {
        while_continue___36: /* CIL Label */ ;
        while_continue___13: /* CIL Label */ ;
#line 2127
        if (! (k < (d->follows + (grps[i].elems + j)->index)->nelem)) {
#line 2127
          goto while_break___13;
        }
        {
        {
#line 2128
        insert(*((d->follows + (grps[i].elems + j)->index)->elems + k), & follows);
        }
#line 2127
        k ++;
        }
      }
      while_break___36: /* CIL Label */ ;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 2126
      j ++;
    }
    while_break___35: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
    {
#line 2131
    tmp___17 = __ctype_get_mb_cur_max();
    }
    }
#line 2131
    if (tmp___17 > 1U) {
#line 2151
      next_isnt_1st_byte = 0;
#line 2152
      j = 0;
      {
      {
#line 2152
      while (1) {
        while_continue___37: /* CIL Label */ ;
        while_continue___14: /* CIL Label */ ;
#line 2152
        if (! (j < follows.nelem)) {
#line 2152
          goto while_break___14;
        }
#line 2154
        if (! (*(d->multibyte_prop + (follows.elems + j)->index) & 1)) {
#line 2156
          next_isnt_1st_byte = 1;
#line 2157
          goto while_break___14;
        }
#line 2152
        j ++;
      }
      while_break___37: /* CIL Label */ ;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 2166
    if (d->searchflag) {
      {
      {
#line 2166
      tmp___18 = __ctype_get_mb_cur_max();
      }
      }
#line 2166
      if (tmp___18 == 1U) {
#line 2166
        goto _L___1;
      } else
#line 2166
      if (! next_isnt_1st_byte) {
        _L___1: /* CIL Label */ 
#line 2170
        j = 0;
        {
        {
#line 2170
        while (1) {
          while_continue___38: /* CIL Label */ ;
          while_continue___15: /* CIL Label */ ;
#line 2170
          if (! (j < (d->states + 0)->elems.nelem)) {
#line 2170
            goto while_break___15;
          }
          {
          {
#line 2171
          insert(*((d->states + 0)->elems.elems + j), & follows);
          }
#line 2170
          j ++;
          }
        }
        while_break___38: /* CIL Label */ ;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
    }
    {
#line 2174
    wants_newline = 0;
    {
#line 2175
    tmp___19 = tstbit((unsigned int )eolbyte___0, labels[i]);
    }
    }
#line 2175
    if (tmp___19) {
#line 2176
      j = 0;
      {
      {
#line 2176
      while (1) {
        while_continue___39: /* CIL Label */ ;
        while_continue___16: /* CIL Label */ ;
#line 2176
        if (! (j < follows.nelem)) {
#line 2176
          goto while_break___16;
        }
#line 2177
        if (((follows.elems + j)->constraint & 192U) >> 2 != ((follows.elems + j)->constraint & 48U)) {
#line 2178
          wants_newline = 1;
        }
#line 2176
        j ++;
      }
      while_break___39: /* CIL Label */ ;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 2180
    wants_letter = 0;
#line 2181
    j = 0;
    {
    {
#line 2181
    while (1) {
      while_continue___40: /* CIL Label */ ;
      while_continue___17: /* CIL Label */ ;
#line 2181
      if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2181
        goto while_break___17;
      }
#line 2182
      if (labels[i][j] & letters[j]) {
#line 2183
        goto while_break___17;
      }
#line 2181
      j ++;
    }
    while_break___40: /* CIL Label */ ;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 2184
    if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
#line 2185
      j = 0;
      {
      {
#line 2185
      while (1) {
        while_continue___41: /* CIL Label */ ;
        while_continue___18: /* CIL Label */ ;
#line 2185
        if (! (j < follows.nelem)) {
#line 2185
          goto while_break___18;
        }
#line 2186
        if (((follows.elems + j)->constraint & 12U) >> 2 != ((follows.elems + j)->constraint & 3U)) {
#line 2187
          wants_letter = 1;
        }
#line 2185
        j ++;
      }
      while_break___41: /* CIL Label */ ;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
    {
    {
#line 2190
    state = state_index(d, (position_set const   *)(& follows), 0, 0);
    }
    }
#line 2191
    if (wants_newline) {
      {
      {
#line 2192
      state_newline = state_index(d, (position_set const   *)(& follows), 1, 0);
      }
      }
    } else {
#line 2194
      state_newline = state;
    }
#line 2195
    if (wants_letter) {
      {
      {
#line 2196
      state_letter = state_index(d, (position_set const   *)(& follows), 0, 1);
      }
      }
    } else {
#line 2198
      state_letter = state;
    }
#line 2201
    j = 0;
    {
    {
#line 2201
    while (1) {
      while_continue___42: /* CIL Label */ ;
      while_continue___19: /* CIL Label */ ;
#line 2201
      if (! ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int )))) {
#line 2201
        goto while_break___19;
      }
#line 2202
      k = 0;
      {
      {
#line 2202
      while (1) {
        while_continue___43: /* CIL Label */ ;
        while_continue___20: /* CIL Label */ ;
#line 2202
        if (! ((unsigned long )k < 8UL * sizeof(int ))) {
#line 2202
          goto while_break___20;
        }
#line 2203
        if (labels[i][j] & (1 << k)) {
#line 2205
          c = (int )((unsigned long )j * (8UL * sizeof(int )) + (unsigned long )k);
#line 2207
          if (c == (int )eolbyte___0) {
#line 2208
            *(trans___0 + c) = state_newline;
          } else {
            {
            {
#line 2209
            tmp___20 = __ctype_b_loc();
            }
            }
#line 2209
            if ((int const   )*(*tmp___20 + c) & 8) {
#line 2210
              *(trans___0 + c) = state_letter;
            } else
#line 2209
            if (c == 95) {
#line 2210
              *(trans___0 + c) = state_letter;
            } else
#line 2211
            if (c < 1 << 8) {
#line 2212
              *(trans___0 + c) = state;
            }
          }
        }
#line 2202
        k ++;
      }
      while_break___43: /* CIL Label */ ;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 2201
      j ++;
    }
    while_break___42: /* CIL Label */ ;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 2120
    i ++;
  }
  while_break___34: /* CIL Label */ ;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 2216
  i = 0;
  {
  {
#line 2216
  while (1) {
    while_continue___44: /* CIL Label */ ;
    while_continue___21: /* CIL Label */ ;
#line 2216
    if (! (i < ngrps)) {
#line 2216
      goto while_break___21;
    }
    {
    {
#line 2217
    free((void *)grps[i].elems);
    }
#line 2216
    i ++;
    }
  }
  while_break___44: /* CIL Label */ ;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
  {
#line 2218
  free((void *)follows.elems);
  }
  {
#line 2219
  free((void *)tmp.elems);
  }
  }
#line 2220
  return;
}
}
#line 2229 "dfa.c"
static void build_state(int s , struct dfa *d ) 
{ 
  int *trans___0 ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ptr_t tmp___5 ;
  int oldalloc ;
  ptr_t tmp___6 ;
  ptr_t tmp___7 ;
  ptr_t tmp___8 ;
  int tmp___9 ;

  {
#line 2235
  if (d->trcount >= 1024) {
#line 2237
    i = 0;
    {
    {
#line 2237
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2237
      if (! (i < d->tralloc)) {
#line 2237
        goto while_break;
      }
#line 2238
      if (*(d->trans + i)) {
        {
        {
#line 2240
        free((ptr_t )*(d->trans + i));
        }
#line 2241
        *(d->trans + i) = (int *)((void *)0);
        }
      } else
#line 2243
      if (*(d->fails + i)) {
        {
        {
#line 2245
        free((ptr_t )*(d->fails + i));
        }
#line 2246
        *(d->fails + i) = (int *)((void *)0);
        }
      }
#line 2237
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 2248
    d->trcount = 0;
  }
#line 2251
  (d->trcount) ++;
#line 2254
  *(d->success + s) = 0;
#line 2255
  if ((d->states + s)->newline) {
#line 2255
    tmp = 2;
  } else {
#line 2255
    tmp = 0;
  }
#line 2255
  if ((int )(d->states + s)->constraint & (1 << ((tmp + 1) + 4))) {
#line 2255
    if ((d->states + s)->letter) {
#line 2255
      tmp___0 = 2;
    } else {
#line 2255
      tmp___0 = 0;
    }
#line 2255
    if ((int )(d->states + s)->constraint & (1 << tmp___0)) {
#line 2257
      *(d->success + s) |= 4;
    }
  }
#line 2258
  if ((d->states + s)->newline) {
#line 2258
    tmp___1 = 2;
  } else {
#line 2258
    tmp___1 = 0;
  }
#line 2258
  if ((int )(d->states + s)->constraint & (1 << (tmp___1 + 4))) {
#line 2258
    if ((d->states + s)->letter) {
#line 2258
      tmp___2 = 2;
    } else {
#line 2258
      tmp___2 = 0;
    }
#line 2258
    if ((int )(d->states + s)->constraint & (1 << (tmp___2 + 1))) {
#line 2260
      *(d->success + s) |= 2;
    }
  }
#line 2261
  if ((d->states + s)->newline) {
#line 2261
    tmp___3 = 2;
  } else {
#line 2261
    tmp___3 = 0;
  }
#line 2261
  if ((int )(d->states + s)->constraint & (1 << (tmp___3 + 4))) {
#line 2261
    if ((d->states + s)->letter) {
#line 2261
      tmp___4 = 2;
    } else {
#line 2261
      tmp___4 = 0;
    }
#line 2261
    if ((int )(d->states + s)->constraint & (1 << tmp___4)) {
#line 2263
      *(d->success + s) |= 1;
    }
  }
  {
  {
#line 2265
  tmp___5 = xmalloc___0((size_t )((unsigned long )(1 << 8) * sizeof(int )));
  }
#line 2265
  trans___0 = (int *)tmp___5;
  {
#line 2266
  dfastate(s, d, trans___0);
  }
#line 2271
  i = 0;
  }
  {
  {
#line 2271
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2271
    if (! (i < 1 << 8)) {
#line 2271
      goto while_break___0;
    }
#line 2272
    if (*(trans___0 + i) >= d->tralloc) {
#line 2274
      oldalloc = d->tralloc;
      {
      {
#line 2276
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 2276
        if (! (*(trans___0 + i) >= d->tralloc)) {
#line 2276
          goto while_break___1;
        }
#line 2277
        d->tralloc *= 2;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 2278
      tmp___6 = xrealloc___0((ptr_t )d->realtrans, (size_t )((unsigned long )(d->tralloc + 1) * sizeof(int *)));
      }
#line 2278
      d->realtrans = (int **)tmp___6;
#line 2279
      d->trans = d->realtrans + 1;
      {
#line 2280
      tmp___7 = xrealloc___0((ptr_t )d->fails, (size_t )((unsigned long )d->tralloc * sizeof(int *)));
      }
#line 2280
      d->fails = (int **)tmp___7;
      {
#line 2281
      tmp___8 = xrealloc___0((ptr_t )d->success, (size_t )((unsigned long )d->tralloc * sizeof(int )));
      }
#line 2281
      d->success = (int *)tmp___8;
      }
      {
      {
#line 2282
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 2282
        if (! (oldalloc < d->tralloc)) {
#line 2282
          goto while_break___2;
        }
#line 2284
        *(d->trans + oldalloc) = (int *)((void *)0);
#line 2285
        tmp___9 = oldalloc;
#line 2285
        oldalloc ++;
#line 2285
        *(d->fails + tmp___9) = (int *)((void *)0);
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2271
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2290
  *(trans___0 + eolbyte___0) = -1;
#line 2292
  if ((d->states + s)->constraint) {
#line 2293
    *(d->fails + s) = trans___0;
  } else {
#line 2295
    *(d->trans + s) = trans___0;
  }
#line 2296
  return;
}
}
#line 2298 "dfa.c"
static void build_state_zero(struct dfa *d ) 
{ 
  ptr_t tmp ;
  ptr_t tmp___0 ;
  ptr_t tmp___1 ;

  {
  {
#line 2301
  d->tralloc = 1;
#line 2302
  d->trcount = 0;
  {
#line 2303
  tmp = xcalloc___0((size_t )(d->tralloc + 1), (size_t )sizeof(int *));
  }
#line 2303
  d->realtrans = (int **)tmp;
#line 2304
  d->trans = d->realtrans + 1;
  {
#line 2305
  tmp___0 = xcalloc___0((size_t )d->tralloc, (size_t )sizeof(int *));
  }
#line 2305
  d->fails = (int **)tmp___0;
  {
#line 2306
  tmp___1 = xmalloc___0((size_t )((unsigned long )d->tralloc * sizeof(int )));
  }
#line 2306
  d->success = (int *)tmp___1;
  {
#line 2307
  build_state(0, d);
  }
  }
#line 2308
  return;
}
}
#line 2339 "dfa.c"
static void realloc_trans_if_necessary(struct dfa *d , int new_state ) 
{ 
  int oldalloc ;
  ptr_t tmp ;
  ptr_t tmp___0 ;
  ptr_t tmp___1 ;
  int tmp___2 ;

  {
#line 2344
  if (new_state >= d->tralloc) {
#line 2346
    oldalloc = d->tralloc;
    {
    {
#line 2348
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2348
      if (! (new_state >= d->tralloc)) {
#line 2348
        goto while_break;
      }
#line 2349
      d->tralloc *= 2;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 2350
    tmp = xrealloc___0((ptr_t )d->realtrans, (size_t )((unsigned long )(d->tralloc + 1) * sizeof(int *)));
    }
#line 2350
    d->realtrans = (int **)tmp;
#line 2351
    d->trans = d->realtrans + 1;
    {
#line 2352
    tmp___0 = xrealloc___0((ptr_t )d->fails, (size_t )((unsigned long )d->tralloc * sizeof(int *)));
    }
#line 2352
    d->fails = (int **)tmp___0;
    {
#line 2353
    tmp___1 = xrealloc___0((ptr_t )d->success, (size_t )((unsigned long )d->tralloc * sizeof(int )));
    }
#line 2353
    d->success = (int *)tmp___1;
    }
    {
    {
#line 2354
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 2354
      if (! (oldalloc < d->tralloc)) {
#line 2354
        goto while_break___0;
      }
#line 2356
      *(d->trans + oldalloc) = (int *)((void *)0);
#line 2357
      tmp___2 = oldalloc;
#line 2357
      oldalloc ++;
#line 2357
      *(d->fails + tmp___2) = (int *)((void *)0);
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2360
  return;
}
}
#line 2375 "dfa.c"
static status_transit_state transit_state_singlebyte(struct dfa *d , int s , unsigned char const   *p ,
                                                     int *next_state ) 
{ 
  int *t ;
  int works ;
  status_transit_state rval ;

  {
#line 2380
  works = s;
#line 2382
  rval = (status_transit_state )0;
  {
  {
#line 2384
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2384
    if (! ((unsigned int )rval == 0U)) {
#line 2384
      goto while_break;
    }
#line 2386
    t = *(d->trans + works);
#line 2386
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 2388
      works = *(t + *p);
#line 2389
      rval = (status_transit_state )1;
#line 2390
      if (works < 0) {
#line 2391
        works = 0;
      }
    } else
#line 2393
    if (works < 0) {
#line 2395
      if ((unsigned long )p == (unsigned long )buf_end) {
#line 2397
        return ((status_transit_state )2);
      }
#line 2398
      works = 0;
    } else
#line 2400
    if (*(d->fails + works)) {
#line 2402
      works = *(*(d->fails + works) + *p);
#line 2403
      rval = (status_transit_state )1;
    } else {
      {
      {
#line 2407
      build_state(works, d);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2410
  *next_state = works;
#line 2411
  return (rval);
}
}
#line 2419 "dfa.c"
static int match_anychar(struct dfa *d , int s , position pos , int index___0 ) 
{ 
  int newline___0 ;
  int letter ;
  wchar_t wc ;
  int mbclen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2422
  newline___0 = 0;
#line 2423
  letter = 0;
#line 2427
  wc = *(inputwcs + index___0);
#line 2428
  if ((int )*(mblen_buf + index___0) == 0) {
#line 2428
    mbclen = 1;
  } else {
#line 2428
    mbclen = (int )*(mblen_buf + index___0);
  }
#line 2431
  if (wc == (wchar_t )eolbyte___0) {
#line 2433
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2434
      return (0);
    }
#line 2435
    newline___0 = 1;
  } else
#line 2437
  if (wc == 0L) {
#line 2439
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2440
      return (0);
    }
#line 2441
    newline___0 = 1;
  }
  {
  {
#line 2444
  tmp = iswalnum((wint_t )wc);
  }
  }
#line 2444
  if (tmp) {
#line 2445
    letter = 1;
  } else
#line 2444
  if (wc == 95L) {
#line 2445
    letter = 1;
  }
#line 2447
  if ((d->states + s)->newline) {
#line 2447
    tmp___0 = 2;
  } else {
#line 2447
    tmp___0 = 0;
  }
#line 2447
  if (newline___0) {
#line 2447
    tmp___1 = 1;
  } else {
#line 2447
    tmp___1 = 0;
  }
#line 2447
  if (pos.constraint & (unsigned int )(1 << ((tmp___0 + tmp___1) + 4))) {
#line 2447
    if ((d->states + s)->letter) {
#line 2447
      tmp___2 = 2;
    } else {
#line 2447
      tmp___2 = 0;
    }
#line 2447
    if (letter) {
#line 2447
      tmp___3 = 1;
    } else {
#line 2447
      tmp___3 = 0;
    }
#line 2447
    if (! (pos.constraint & (unsigned int )(1 << (tmp___2 + tmp___3)))) {
#line 2449
      return (0);
    }
  } else {
#line 2449
    return (0);
  }
#line 2451
  return (mbclen);
}
}
#line 2459 "dfa.c"
int match_mb_charset(struct dfa *d , int s , position pos , int index___0 ) 
{ 
  int i ;
  int match ;
  int match_len ;
  int op_len ;
  char buffer___0[128] ;
  wchar_t wcbuf[6] ;
  struct mb_char_classes *work_mbc ;
  int newline___0 ;
  int letter ;
  wchar_t wc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___6 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;

  {
#line 2473
  newline___0 = 0;
#line 2474
  letter = 0;
#line 2477
  wc = *(inputwcs + index___0);
#line 2480
  if (wc == (wchar_t )eolbyte___0) {
#line 2482
    if (! (syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2483
      return (0);
    }
#line 2484
    newline___0 = 1;
  } else
#line 2486
  if (wc == 0L) {
#line 2488
    if (syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2489
      return (0);
    }
#line 2490
    newline___0 = 1;
  }
  {
  {
#line 2492
  tmp = iswalnum((wint_t )wc);
  }
  }
#line 2492
  if (tmp) {
#line 2493
    letter = 1;
  } else
#line 2492
  if (wc == 95L) {
#line 2493
    letter = 1;
  }
#line 2494
  if ((d->states + s)->newline) {
#line 2494
    tmp___0 = 2;
  } else {
#line 2494
    tmp___0 = 0;
  }
#line 2494
  if (newline___0) {
#line 2494
    tmp___1 = 1;
  } else {
#line 2494
    tmp___1 = 0;
  }
#line 2494
  if (pos.constraint & (unsigned int )(1 << ((tmp___0 + tmp___1) + 4))) {
#line 2494
    if ((d->states + s)->letter) {
#line 2494
      tmp___2 = 2;
    } else {
#line 2494
      tmp___2 = 0;
    }
#line 2494
    if (letter) {
#line 2494
      tmp___3 = 1;
    } else {
#line 2494
      tmp___3 = 0;
    }
#line 2494
    if (! (pos.constraint & (unsigned int )(1 << (tmp___2 + tmp___3)))) {
#line 2496
      return (0);
    }
  } else {
#line 2496
    return (0);
  }
#line 2499
  work_mbc = d->mbcsets + (*(d->multibyte_prop + pos.index) >> 2);
#line 2500
  match = ! work_mbc->invert;
#line 2501
  if ((int )*(mblen_buf + index___0) == 0) {
#line 2501
    match_len = 1;
  } else {
#line 2501
    match_len = (int )*(mblen_buf + index___0);
  }
#line 2504
  i = 0;
  {
  {
#line 2504
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2504
    if (! (i < work_mbc->nch_classes)) {
#line 2504
      goto while_break;
    }
    {
    {
#line 2506
    tmp___4 = iswctype((wint_t )wc, *(work_mbc->ch_classes + i));
    }
    }
#line 2506
    if (tmp___4) {
#line 2507
      goto charset_matched;
    }
#line 2504
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2510
  strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(buf_begin + index___0),
          (size_t )match_len);
  }
#line 2511
  buffer___0[match_len] = (char )'\000';
#line 2514
  i = 0;
  }
  {
  {
#line 2514
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2514
    if (! (i < work_mbc->nequivs)) {
#line 2514
      goto while_break___0;
    }
    {
    {
#line 2516
    tmp___6 = strlen((char const   *)*(work_mbc->equivs + i));
    }
#line 2516
    op_len = (int )tmp___6;
    {
#line 2517
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(buf_begin + index___0),
            (size_t )op_len);
    }
#line 2518
    buffer___0[op_len] = (char )'\000';
    {
#line 2519
    tmp___8 = strcoll((char const   *)*(work_mbc->equivs + i), (char const   *)(buffer___0));
    }
    }
#line 2519
    if (tmp___8 == 0) {
#line 2521
      match_len = op_len;
#line 2522
      goto charset_matched;
    }
#line 2514
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2527
  i = 0;
  {
  {
#line 2527
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 2527
    if (! (i < work_mbc->ncoll_elems)) {
#line 2527
      goto while_break___1;
    }
    {
    {
#line 2529
    tmp___9 = strlen((char const   *)*(work_mbc->coll_elems + i));
    }
#line 2529
    op_len = (int )tmp___9;
    {
#line 2530
    strncpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(buf_begin + index___0),
            (size_t )op_len);
    }
#line 2531
    buffer___0[op_len] = (char )'\000';
    {
#line 2533
    tmp___11 = strcoll((char const   *)*(work_mbc->coll_elems + i), (char const   *)(buffer___0));
    }
    }
#line 2533
    if (tmp___11 == 0) {
#line 2535
      match_len = op_len;
#line 2536
      goto charset_matched;
    }
#line 2527
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2540
  wcbuf[0] = wc;
#line 2541
  wcbuf[5] = (wchar_t )'\000';
#line 2541
  wcbuf[3] = wcbuf[5];
#line 2541
  wcbuf[1] = wcbuf[3];
#line 2544
  i = 0;
  {
  {
#line 2544
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 2544
    if (! (i < work_mbc->nranges)) {
#line 2544
      goto while_break___2;
    }
    {
#line 2546
    wcbuf[2] = *(work_mbc->range_sts + i);
#line 2547
    wcbuf[4] = *(work_mbc->range_ends + i);
    {
#line 2549
    tmp___12 = wcscoll((wchar_t const   *)(wcbuf), (wchar_t const   *)(wcbuf + 2));
    }
    }
#line 2549
    if (tmp___12 >= 0) {
      {
      {
#line 2549
      tmp___13 = wcscoll((wchar_t const   *)(wcbuf + 4), (wchar_t const   *)(wcbuf));
      }
      }
#line 2549
      if (tmp___13 >= 0) {
#line 2551
        goto charset_matched;
      }
    }
#line 2544
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2555
  i = 0;
  {
  {
#line 2555
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 2555
    if (! (i < work_mbc->nchars)) {
#line 2555
      goto while_break___3;
    }
#line 2557
    if (wc == *(work_mbc->chars + i)) {
#line 2558
      goto charset_matched;
    }
#line 2555
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2561
  match = ! match;
  charset_matched: 
#line 2564
  if (match) {
#line 2564
    tmp___14 = match_len;
  } else {
#line 2564
    tmp___14 = 0;
  }
#line 2564
  return (tmp___14);
}
}
#line 2574 "dfa.c"
static int *check_matching_with_multibyte_ops(struct dfa *d , int s , int index___0 ) 
{ 
  int i ;
  int *rarray ;
  ptr_t tmp ;
  position pos ;

  {
  {
  {
#line 2580
  tmp = xmalloc___0((size_t )((unsigned long )(d->states + s)->mbps.nelem * sizeof(int )));
  }
#line 2580
  rarray = (int *)tmp;
#line 2581
  i = 0;
  }
  {
  {
#line 2581
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2581
    if (! (i < (d->states + s)->mbps.nelem)) {
#line 2581
      goto while_break;
    }
#line 2583
    pos = *((d->states + s)->mbps.elems + i);
    {
#line 2586
    if ((int )*(d->tokens + pos.index) == 274) {
#line 2586
      goto case_274;
    }
#line 2589
    if ((int )*(d->tokens + pos.index) == 275) {
#line 2589
      goto case_275;
    }
#line 2592
    goto switch_default;
    case_274: /* CIL Label */ 
    {
    {
#line 2587
    *(rarray + i) = match_anychar(d, s, pos, index___0);
    }
    }
#line 2588
    goto switch_break;
    case_275: /* CIL Label */ 
    {
    {
#line 2590
    *(rarray + i) = match_mb_charset(d, s, pos, index___0);
    }
    }
#line 2591
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2593
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2581
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2596
  return (rarray);
}
}
#line 2605 "dfa.c"
static status_transit_state transit_state_consume_1char(struct dfa *d , int s , unsigned char const   **pp ,
                                                        int *match_lens , int *mbclen ,
                                                        position_set *pps ) 
{ 
  int i ;
  int j ;
  int s1 ;
  int s2 ;
  int *work_mbls ;
  status_transit_state rs ;
  unsigned char const   *tmp ;

  {
#line 2612
  rs = (status_transit_state )1;
#line 2616
  if ((int )*(mblen_buf + (*pp - buf_begin)) == 0) {
#line 2616
    *mbclen = 1;
  } else {
#line 2616
    *mbclen = (int )*(mblen_buf + (*pp - buf_begin));
  }
#line 2621
  s1 = s;
#line 2622
  i = 0;
  {
  {
#line 2622
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2622
    if (! (i < *mbclen)) {
#line 2622
      goto while_break;
    }
    {
#line 2624
    s2 = s1;
#line 2625
    tmp = *pp;
#line 2625
    (*pp) ++;
    {
#line 2625
    rs = transit_state_singlebyte(d, s2, tmp, & s1);
    }
#line 2622
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2628
  copy((position_set const   *)(& (d->states + s1)->elems), pps);
  }
  }
#line 2631
  if ((unsigned long )match_lens == (unsigned long )((void *)0)) {
#line 2631
    if ((d->states + s)->mbps.nelem != 0) {
      {
      {
#line 2632
      work_mbls = check_matching_with_multibyte_ops(d, s, (int )(*pp - buf_begin));
      }
      }
    } else {
#line 2634
      work_mbls = match_lens;
    }
  } else {
#line 2634
    work_mbls = match_lens;
  }
#line 2638
  i = 0;
  {
  {
#line 2638
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2638
    if (! (i < (d->states + s)->mbps.nelem)) {
#line 2638
      goto while_break___0;
    }
#line 2640
    if (*(work_mbls + i) == *mbclen) {
#line 2641
      j = 0;
      {
      {
#line 2641
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 2641
        if (! (j < (d->follows + ((d->states + s)->mbps.elems + i)->index)->nelem)) {
#line 2641
          goto while_break___1;
        }
        {
        {
#line 2643
        insert(*((d->follows + ((d->states + s)->mbps.elems + i)->index)->elems + j),
               pps);
        }
#line 2641
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2638
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2647
  if ((unsigned long )match_lens == (unsigned long )((void *)0)) {
#line 2647
    if ((unsigned long )work_mbls != (unsigned long )((void *)0)) {
      {
      {
#line 2648
      free((void *)work_mbls);
      }
      }
    }
  }
#line 2649
  return (rs);
}
}
#line 2655 "dfa.c"
static int transit_state(struct dfa *d , int s , unsigned char const   **pp ) 
{ 
  int s1 ;
  int mbclen ;
  int maxlen ;
  int i ;
  int j ;
  int *match_lens ;
  int nelem ;
  position_set follows ;
  unsigned char const   *p1 ;
  status_transit_state rs ;
  wchar_t wc ;
  status_transit_state rs___0 ;
  ptr_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2660
  maxlen = 0;
#line 2662
  match_lens = (int *)((void *)0);
#line 2663
  nelem = (d->states + s)->mbps.nelem;
#line 2665
  p1 = *pp;
#line 2669
  if (nelem > 0) {
    {
    {
#line 2674
    match_lens = check_matching_with_multibyte_ops(d, s, (int )(*pp - buf_begin));
    }
#line 2676
    i = 0;
    }
    {
    {
#line 2676
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2676
      if (! (i < nelem)) {
#line 2676
        goto while_break;
      }
#line 2680
      if (*(match_lens + i) > maxlen) {
#line 2681
        maxlen = *(match_lens + i);
      }
#line 2676
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2685
  if (nelem == 0) {
#line 2685
    goto _L;
  } else
#line 2685
  if (maxlen == 0) {
    _L: /* CIL Label */ 
    {
    {
#line 2690
    rs___0 = transit_state_singlebyte(d, s, *pp, & s1);
    }
    }
#line 2693
    if ((unsigned int )rs___0 == 1U) {
#line 2694
      (*pp) ++;
    }
#line 2696
    if ((unsigned long )match_lens != (unsigned long )((void *)0)) {
      {
      {
#line 2697
      free((void *)match_lens);
      }
      }
    }
#line 2698
    return (s1);
  }
  {
#line 2702
  follows.nelem = 0;
  {
#line 2703
  tmp = xmalloc___0((size_t )((unsigned long )d->nleaves * sizeof(position )));
  }
#line 2703
  follows.elems = (position *)tmp;
  {
#line 2709
  rs = transit_state_consume_1char(d, s, pp, match_lens, & mbclen, & follows);
  }
#line 2711
  wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
  {
#line 2712
  tmp___0 = iswalnum((wint_t )wc);
  }
  {
#line 2712
  s1 = state_index(d, (position_set const   *)(& follows), wc == 10L, tmp___0);
  }
  {
#line 2713
  realloc_trans_if_necessary(d, s1);
  }
  }
  {
  {
#line 2715
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 2715
    if (! (*pp - p1 < (long )maxlen)) {
#line 2715
      goto while_break___0;
    }
    {
#line 2717
    follows.nelem = 0;
    {
#line 2718
    rs = transit_state_consume_1char(d, s1, pp, (int *)((void *)0), & mbclen, & follows);
    }
#line 2720
    i = 0;
    }
    {
    {
#line 2720
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 2720
      if (! (i < nelem)) {
#line 2720
        goto while_break___1;
      }
#line 2722
      if ((long )*(match_lens + i) == *pp - p1) {
#line 2723
        j = 0;
        {
        {
#line 2723
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 2723
          if (! (j < (d->follows + ((d->states + s1)->mbps.elems + i)->index)->nelem)) {
#line 2723
            goto while_break___2;
          }
          {
          {
#line 2725
          insert(*((d->follows + ((d->states + s1)->mbps.elems + i)->index)->elems + j),
                 & follows);
          }
#line 2723
          j ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 2720
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2729
    wc = *(inputwcs + ((*pp - mbclen) - buf_begin));
    {
#line 2730
    tmp___1 = iswalnum((wint_t )wc);
    }
    {
#line 2730
    s1 = state_index(d, (position_set const   *)(& follows), wc == 10L, tmp___1);
    }
    {
#line 2731
    realloc_trans_if_necessary(d, s1);
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 2733
  free((void *)match_lens);
  }
  {
#line 2734
  free((void *)follows.elems);
  }
  }
#line 2735
  return (s1);
}
}
#line 2758 "dfa.c"
static int sbit[256]  ;
#line 2759 "dfa.c"
static int sbit_init  ;
#line 2749 "dfa.c"
size_t dfaexec(struct dfa *d , char const   *begin , size_t size , int *backref ) 
{ 
  register int s ;
  register unsigned char const   *p ;
  register unsigned char const   *end ;
  register int **trans___0 ;
  register int *t ;
  register unsigned char eol ;
  int i ;
  unsigned short const   **tmp___0 ;
  int remain_bytes ;
  int i___0 ;
  ptr_t tmp___1 ;
  ptr_t tmp___2 ;
  void *__s ;
  void *__s___0 ;
  union __anonunion___u_31 *__u ;
  __uint8_t __c ;
  void *__s___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned char const   *nextp ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  unsigned char const   *nextp___0 ;
  unsigned char const   *tmp___10 ;
  unsigned char const   *tmp___11 ;
  size_t tmp___12 ;

  {
#line 2757
  eol = eolbyte___0;
#line 2761
  if (! sbit_init) {
#line 2765
    sbit_init = 1;
#line 2766
    i = 0;
    {
    {
#line 2766
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2766
      if (! (i < 1 << 8)) {
#line 2766
        goto while_break;
      }
      {
      {
#line 2767
      tmp___0 = __ctype_b_loc();
      }
      }
#line 2767
      if ((int const   )*(*tmp___0 + i) & 8) {
#line 2767
        sbit[i] = 2;
      } else
#line 2767
      if (i == 95) {
#line 2767
        sbit[i] = 2;
      } else {
#line 2767
        sbit[i] = 1;
      }
#line 2766
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 2768
    sbit[eol] = 4;
  }
#line 2771
  if (! d->tralloc) {
    {
    {
#line 2772
    build_state_zero(d);
    }
    }
  }
  {
#line 2774
  s = 0;
#line 2775
  p = (unsigned char const   *)begin;
#line 2776
  end = p + size;
#line 2777
  trans___0 = d->trans;
  {
#line 2780
  tmp___4 = __ctype_get_mb_cur_max();
  }
  }
#line 2780
  if (tmp___4 > 1U) {
    {
#line 2783
    buf_begin = (unsigned char const   *)begin;
#line 2784
    buf_end = end;
    {
#line 2787
    tmp___1 = xmalloc___0((size_t )((unsigned long )((end - (unsigned char const   *)begin) + 2L) * sizeof(unsigned char )));
    }
#line 2787
    mblen_buf = (unsigned char *)tmp___1;
    {
#line 2788
    tmp___2 = xmalloc___0((size_t )((unsigned long )((end - (unsigned char const   *)begin) + 2L) * sizeof(wchar_t )));
    }
#line 2788
    inputwcs = (wchar_t *)tmp___2;
    }
#line 2789
    if (sizeof(mbstate_t ) <= 16UL) {
#line 2789
      if (sizeof(mbstate_t ) == 1UL) {
#line 2789
        __s___1 = (void *)(& mbs);
#line 2789
        *((__uint8_t *)__s___1) = (__uint8_t )0;
      } else {
#line 2789
        __s___0 = (void *)(& mbs);
#line 2789
        __u = (union __anonunion___u_31 *)__s___0;
#line 2789
        __c = (__uint8_t )0;
        {
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 15U) {
#line 2789
          goto case_15;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 11U) {
#line 2789
          goto case_11;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 7U) {
#line 2789
          goto case_7;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 3U) {
#line 2789
          goto case_3;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 14U) {
#line 2789
          goto case_14;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 10U) {
#line 2789
          goto case_10;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 6U) {
#line 2789
          goto case_6;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 2U) {
#line 2789
          goto case_2;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 13U) {
#line 2789
          goto case_13;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 9U) {
#line 2789
          goto case_9;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 5U) {
#line 2789
          goto case_5;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 1U) {
#line 2789
          goto case_1;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 16U) {
#line 2789
          goto case_16;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 12U) {
#line 2789
          goto case_12;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 8U) {
#line 2789
          goto case_8;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 4U) {
#line 2789
          goto case_4;
        }
#line 2789
        if ((unsigned int )sizeof(mbstate_t ) == 0U) {
#line 2789
          goto case_0;
        }
#line 2789
        goto switch_break;
        case_15: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_11: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_7: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_3: /* CIL Label */ 
#line 2789
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 2);
#line 2789
        __u->__uc = __c;
#line 2789
        goto switch_break;
        case_14: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_10: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_6: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_2: /* CIL Label */ 
#line 2789
        __u->__usi = (unsigned short )((int )((unsigned short )__c) * 257);
#line 2789
        goto switch_break;
        case_13: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_9: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_5: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_1: /* CIL Label */ 
#line 2789
        __u->__uc = __c;
#line 2789
        goto switch_break;
        case_16: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_12: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_8: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
#line 2789
        __u = (union __anonunion___u_31 *)((void *)__u + 4);
        case_4: /* CIL Label */ 
#line 2789
        __u->__ui = (unsigned int )((int )__c * 16843009);
        case_0: /* CIL Label */ 
#line 2789
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 2789
      __s = (void *)(& mbs);
      {
#line 2789
      __builtin_memset(__s, '\000', (int )sizeof(mbstate_t ));
      }
      }
    }
#line 2790
    remain_bytes = 0;
#line 2791
    i___0 = 0;
    {
    {
#line 2791
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 2791
      if (! ((long )i___0 < (end - (unsigned char const   *)begin) + 1L)) {
#line 2791
        goto while_break___0;
      }
#line 2793
      if (remain_bytes == 0) {
        {
        {
#line 2795
        tmp___3 = mbrtowc((wchar_t */* __restrict  */)(inputwcs + i___0), (char const   */* __restrict  */)(begin + i___0),
                          (size_t )(((end - (unsigned char const   *)begin) - (long )i___0) + 1L),
                          & mbs);
        }
#line 2795
        remain_bytes = (int )tmp___3;
        }
#line 2798
        if (remain_bytes <= 1) {
#line 2800
          remain_bytes = 0;
#line 2801
          *(inputwcs + i___0) = (wchar_t )*(begin + i___0);
#line 2802
          *(mblen_buf + i___0) = (unsigned char)0;
        } else {
#line 2806
          *(mblen_buf + i___0) = (unsigned char )remain_bytes;
#line 2807
          remain_bytes --;
        }
      } else {
#line 2812
        *(mblen_buf + i___0) = (unsigned char )remain_bytes;
#line 2813
        *(inputwcs + i___0) = (wchar_t )0;
#line 2814
        remain_bytes --;
      }
#line 2791
      i___0 ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2817
    *(mblen_buf + i___0) = (unsigned char)0;
#line 2818
    *(inputwcs + i___0) = (wchar_t )0;
  }
  {
  {
#line 2822
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 2825
    tmp___7 = __ctype_get_mb_cur_max();
    }
    }
#line 2825
    if (tmp___7 > 1U) {
      {
      {
#line 2826
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 2826
        t = *(trans___0 + s);
#line 2826
        if (! t) {
#line 2826
          goto while_break___2;
        }
#line 2828
        if ((d->states + s)->mbps.nelem != 0) {
#line 2834
          if (s == 0) {
            {
            {
#line 2834
            while (1) {
              while_continue___11: /* CIL Label */ ;
              while_continue___3: /* CIL Label */ ;
#line 2834
              if (*(inputwcs + (p - buf_begin)) == 0L) {
#line 2834
                if ((int )*(mblen_buf + (p - buf_begin)) > 0) {
#line 2834
                  if (! ((unsigned long )p < (unsigned long )buf_end)) {
#line 2834
                    goto while_break___3;
                  }
                } else {
#line 2834
                  goto while_break___3;
                }
              } else {
#line 2834
                goto while_break___3;
              }
#line 2834
              p ++;
            }
            while_break___11: /* CIL Label */ ;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 2834
            if ((unsigned long )p >= (unsigned long )end) {
              {
              {
#line 2834
              free((void *)mblen_buf);
              }
              {
#line 2834
              free((void *)inputwcs);
              }
              }
#line 2834
              return ((size_t )-1);
            }
          }
          {
#line 2836
          nextp = p;
          {
#line 2837
          s = transit_state(d, s, & nextp);
          }
#line 2838
          p = nextp;
#line 2841
          trans___0 = d->trans;
          }
        } else {
#line 2845
          if (s == 0) {
            {
            {
#line 2845
            while (1) {
              while_continue___12: /* CIL Label */ ;
              while_continue___4: /* CIL Label */ ;
#line 2845
              if (*(inputwcs + (p - buf_begin)) == 0L) {
#line 2845
                if ((int )*(mblen_buf + (p - buf_begin)) > 0) {
#line 2845
                  if (! ((unsigned long )p < (unsigned long )buf_end)) {
#line 2845
                    goto while_break___4;
                  }
                } else {
#line 2845
                  goto while_break___4;
                }
              } else {
#line 2845
                goto while_break___4;
              }
#line 2845
              p ++;
            }
            while_break___12: /* CIL Label */ ;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 2845
            if ((unsigned long )p >= (unsigned long )end) {
              {
              {
#line 2845
              free((void *)mblen_buf);
              }
              {
#line 2845
              free((void *)inputwcs);
              }
              }
#line 2845
              return ((size_t )-1);
            }
          }
#line 2846
          tmp___5 = p;
#line 2846
          p ++;
#line 2846
          s = *(t + *tmp___5);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 2851
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 2851
        t = *(trans___0 + s);
#line 2851
        if (! t) {
#line 2851
          goto while_break___5;
        }
#line 2852
        tmp___6 = p;
#line 2852
        p ++;
#line 2852
        s = *(t + *tmp___6);
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 2854
    if (s < 0) {
#line 2856
      if ((unsigned long )p == (unsigned long )end) {
        {
        {
#line 2859
        tmp___8 = __ctype_get_mb_cur_max();
        }
        }
#line 2859
        if (tmp___8 > 1U) {
          {
          {
#line 2861
          free((void *)mblen_buf);
          }
          {
#line 2862
          free((void *)inputwcs);
          }
          }
        }
#line 2865
        return ((size_t )-1);
      }
#line 2867
      s = 0;
    } else {
#line 2869
      t = *(d->fails + s);
#line 2869
      if (t) {
#line 2871
        if (*(d->success + s) & sbit[*p]) {
#line 2873
          if (backref) {
#line 2874
            *backref = (int )(d->states + s)->backref != 0;
          }
          {
          {
#line 2876
          tmp___9 = __ctype_get_mb_cur_max();
          }
          }
#line 2876
          if (tmp___9 > 1U) {
            {
            {
#line 2878
            free((void *)mblen_buf);
            }
            {
#line 2879
            free((void *)inputwcs);
            }
            }
          }
#line 2882
          return ((size_t )((char const   *)p - begin));
        }
        {
        {
#line 2886
        tmp___12 = __ctype_get_mb_cur_max();
        }
        }
#line 2886
        if (tmp___12 > 1U) {
#line 2888
          if (s == 0) {
            {
            {
#line 2888
            while (1) {
              while_continue___14: /* CIL Label */ ;
              while_continue___6: /* CIL Label */ ;
#line 2888
              if (*(inputwcs + (p - buf_begin)) == 0L) {
#line 2888
                if ((int )*(mblen_buf + (p - buf_begin)) > 0) {
#line 2888
                  if (! ((unsigned long )p < (unsigned long )buf_end)) {
#line 2888
                    goto while_break___6;
                  }
                } else {
#line 2888
                  goto while_break___6;
                }
              } else {
#line 2888
                goto while_break___6;
              }
#line 2888
              p ++;
            }
            while_break___14: /* CIL Label */ ;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 2888
            if ((unsigned long )p >= (unsigned long )end) {
              {
              {
#line 2888
              free((void *)mblen_buf);
              }
              {
#line 2888
              free((void *)inputwcs);
              }
              }
#line 2888
              return ((size_t )-1);
            }
          }
#line 2889
          if ((d->states + s)->mbps.nelem != 0) {
            {
#line 2894
            nextp___0 = p;
            {
#line 2895
            s = transit_state(d, s, & nextp___0);
            }
#line 2896
            p = nextp___0;
#line 2899
            trans___0 = d->trans;
            }
          } else {
#line 2902
            tmp___10 = p;
#line 2902
            p ++;
#line 2902
            s = *(t + *tmp___10);
          }
        } else {
#line 2906
          tmp___11 = p;
#line 2906
          p ++;
#line 2906
          s = *(t + *tmp___11);
        }
      } else {
        {
        {
#line 2910
        build_state(s, d);
        }
#line 2911
        trans___0 = d->trans;
        }
      }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 2918 "dfa.c"
void dfainit(struct dfa *d ) 
{ 
  ptr_t tmp ;
  ptr_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ptr_t tmp___4 ;
  ptr_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 2921
  d->calloc = 1;
  {
#line 2922
  tmp = xmalloc___0((size_t )((unsigned long )d->calloc * sizeof(charclass )));
  }
#line 2922
  d->charclasses = (charclass *)tmp;
#line 2923
  d->cindex = 0;
#line 2925
  d->talloc = 1;
  {
#line 2926
  tmp___0 = xmalloc___0((size_t )((unsigned long )d->talloc * sizeof(token )));
  }
#line 2926
  d->tokens = (token *)tmp___0;
#line 2927
  tmp___3 = 0;
#line 2927
  d->nregexps = tmp___3;
#line 2927
  tmp___2 = tmp___3;
#line 2927
  d->nleaves = tmp___2;
#line 2927
  tmp___1 = tmp___2;
#line 2927
  d->depth = tmp___1;
#line 2927
  d->tindex = tmp___1;
  {
#line 2929
  tmp___6 = __ctype_get_mb_cur_max();
  }
  }
#line 2929
  if (tmp___6 > 1U) {
    {
#line 2931
    d->nmultibyte_prop = 1;
    {
#line 2932
    tmp___4 = xmalloc___0((size_t )((unsigned long )d->nmultibyte_prop * sizeof(int )));
    }
#line 2932
    d->multibyte_prop = (int *)tmp___4;
#line 2933
    d->nmbcsets = 0;
#line 2934
    d->mbcsets_alloc = 1;
    {
#line 2935
    tmp___5 = xmalloc___0((size_t )((unsigned long )d->mbcsets_alloc * sizeof(struct mb_char_classes )));
    }
#line 2935
    d->mbcsets = (struct mb_char_classes *)tmp___5;
    }
  }
#line 2939
  d->searchflag = 0;
#line 2940
  d->tralloc = 0;
#line 2942
  d->musts = (struct dfamust *)0;
#line 2943
  return;
}
}
#line 2946 "dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , int searchflag ) 
{ 
  char *lcopy ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  int __res ;
  __int32_t const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp18 ;

  {
#line 2949
  if (case_fold) {
    {
    {
#line 2954
    tmp = malloc(len);
    }
#line 2954
    lcopy = (char *)tmp;
    }
#line 2955
    if (! lcopy) {
      {
      {
#line 2956
      tmp___0 = dcgettext((char const   *)((void *)0), "out of memory", 5);
      }
      {
#line 2956
      dfaerror((char const   *)tmp___0);
      }
      }
    }
#line 2959
    case_fold = 0;
#line 2960
    i = 0;
    {
    {
#line 2960
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2960
      if (! ((size_t )i < len)) {
#line 2960
        goto while_break;
      }
      {
      {
#line 2961
      tmp___3 = __ctype_b_loc();
      }
      }
#line 2961
      if ((int const   )*(*tmp___3 + (int )((unsigned char )*(s + i))) & 256) {
#line 2962
        if (sizeof((unsigned char )*(s + i)) > 1UL) {
          {
          {
#line 2962
          __res = tolower((int )((unsigned char )*(s + i)));
          }
          }
        } else {
          {
          {
#line 2962
          tmp___2 = __ctype_tolower_loc();
          }
#line 2962
          __res = (int )*(*tmp___2 + (int )((unsigned char )*(s + i)));
          }
        }
#line 2962
        *(lcopy + i) = (char )__res;
      } else {
#line 2964
        *(lcopy + i) = (char )*(s + i);
      }
#line 2960
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 2966
    dfainit(d);
    }
    {
#line 2967
    dfaparse((char const   *)lcopy, len, d);
    }
    {
#line 2968
    free((void *)lcopy);
    }
    {
#line 2969
    dfamust(d);
    }
#line 2970
    tmp___7 = 0;
#line 2970
    d->nregexps = tmp___7;
#line 2970
    tmp___6 = tmp___7;
#line 2970
    d->nleaves = tmp___6;
#line 2970
    tmp___5 = tmp___6;
#line 2970
    d->depth = tmp___5;
#line 2970
    tmp___4 = tmp___5;
#line 2970
    d->tindex = tmp___4;
#line 2970
    d->cindex = tmp___4;
#line 2971
    case_fold = 1;
    {
#line 2972
    dfaparse(s, len, d);
    }
    {
#line 2973
    dfaanalyze(d, searchflag);
    }
    }
  } else {
    {
    {
#line 2977
    dfainit(d);
    }
    {
#line 2978
    dfaparse(s, len, d);
    }
    {
#line 2979
    dfamust(d);
    }
    {
#line 2980
    dfaanalyze(d, searchflag);
    }
    }
  }
#line 2982
  return;
}
}
#line 2985 "dfa.c"
void dfafree(struct dfa *d ) 
{ 
  int i ;
  struct dfamust *dm ;
  struct dfamust *ndm ;
  int j ;
  struct mb_char_classes *p ;
  size_t tmp ;

  {
  {
  {
#line 2991
  free((ptr_t )d->charclasses);
  }
  {
#line 2992
  free((ptr_t )d->tokens);
  }
  {
#line 2995
  tmp = __ctype_get_mb_cur_max();
  }
  }
#line 2995
  if (tmp > 1U) {
    {
    {
#line 2997
    free((ptr_t )d->multibyte_prop);
    }
#line 2998
    i = 0;
    }
    {
    {
#line 2998
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 2998
      if (! (i < d->nmbcsets)) {
#line 2998
        goto while_break;
      }
#line 3001
      p = d->mbcsets + i;
#line 3002
      if ((unsigned long )p->chars != (unsigned long )((void *)0)) {
        {
        {
#line 3003
        free((void *)p->chars);
        }
        }
      }
#line 3004
      if ((unsigned long )p->ch_classes != (unsigned long )((void *)0)) {
        {
        {
#line 3005
        free((void *)p->ch_classes);
        }
        }
      }
#line 3006
      if ((unsigned long )p->range_sts != (unsigned long )((void *)0)) {
        {
        {
#line 3007
        free((void *)p->range_sts);
        }
        }
      }
#line 3008
      if ((unsigned long )p->range_ends != (unsigned long )((void *)0)) {
        {
        {
#line 3009
        free((void *)p->range_ends);
        }
        }
      }
#line 3011
      j = 0;
      {
      {
#line 3011
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 3011
        if (! (j < p->nequivs)) {
#line 3011
          goto while_break___0;
        }
        {
        {
#line 3012
        free((void *)*(p->equivs + j));
        }
#line 3011
        j ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3013
      if ((unsigned long )p->equivs != (unsigned long )((void *)0)) {
        {
        {
#line 3014
        free((void *)p->equivs);
        }
        }
      }
#line 3016
      j = 0;
      {
      {
#line 3016
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 3016
        if (! (j < p->ncoll_elems)) {
#line 3016
          goto while_break___1;
        }
        {
        {
#line 3017
        free((void *)*(p->coll_elems + j));
        }
#line 3016
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3018
      if ((unsigned long )p->coll_elems != (unsigned long )((void *)0)) {
        {
        {
#line 3019
        free((void *)p->coll_elems);
        }
        }
      }
#line 2998
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 3021
    free((ptr_t )d->mbcsets);
    }
    }
  }
#line 3025
  i = 0;
  {
  {
#line 3025
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 3025
    if (! (i < d->sindex)) {
#line 3025
      goto while_break___2;
    }
    {
    {
#line 3026
    free((ptr_t )(d->states + i)->elems.elems);
    }
#line 3025
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 3027
  free((ptr_t )d->states);
  }
#line 3028
  i = 0;
  }
  {
  {
#line 3028
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 3028
    if (! (i < d->tindex)) {
#line 3028
      goto while_break___3;
    }
#line 3029
    if ((d->follows + i)->elems) {
      {
      {
#line 3030
      free((ptr_t )(d->follows + i)->elems);
      }
      }
    }
#line 3028
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 3031
  free((ptr_t )d->follows);
  }
#line 3032
  i = 0;
  }
  {
  {
#line 3032
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 3032
    if (! (i < d->tralloc)) {
#line 3032
      goto while_break___4;
    }
#line 3033
    if (*(d->trans + i)) {
      {
      {
#line 3034
      free((ptr_t )*(d->trans + i));
      }
      }
    } else
#line 3035
    if (*(d->fails + i)) {
      {
      {
#line 3036
      free((ptr_t )*(d->fails + i));
      }
      }
    }
#line 3032
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3037
  if (d->realtrans) {
    {
    {
#line 3037
    free((ptr_t )d->realtrans);
    }
    }
  }
#line 3038
  if (d->fails) {
    {
    {
#line 3038
    free((ptr_t )d->fails);
    }
    }
  }
#line 3039
  if (d->success) {
    {
    {
#line 3039
    free((ptr_t )d->success);
    }
    }
  }
#line 3040
  dm = d->musts;
  {
  {
#line 3040
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 3040
    if (! dm) {
#line 3040
      goto while_break___5;
    }
    {
#line 3042
    ndm = dm->next;
    {
#line 3043
    free((void *)dm->must);
    }
    {
#line 3044
    free((ptr_t )dm);
    }
#line 3040
    dm = ndm;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3046
  return;
}
}
#line 3132 "dfa.c"
static char *icatalloc(char *old , char *new ) 
{ 
  char *result ;
  size_t oldsize ;
  size_t newsize ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 3138
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3138
    newsize = (size_t )0;
  } else {
    {
    {
#line 3138
    tmp = strlen((char const   *)new);
    }
#line 3138
    newsize = tmp;
    }
  }
#line 3139
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3140
    oldsize = (size_t )0;
  } else
#line 3141
  if (newsize == 0U) {
#line 3142
    return (old);
  } else {
    {
    {
#line 3143
    oldsize = strlen((char const   *)old);
    }
    }
  }
#line 3144
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    {
    {
#line 3145
    tmp___0 = malloc(newsize + 1U);
    }
#line 3145
    result = (char *)tmp___0;
    }
  } else {
    {
    {
#line 3147
    tmp___1 = realloc((void *)old, (oldsize + newsize) + 1U);
    }
#line 3147
    result = (char *)tmp___1;
    }
  }
#line 3148
  if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 3148
    if ((unsigned long )new != (unsigned long )((void *)0)) {
      {
      {
#line 3149
      strcpy((char */* __restrict  */)(result + oldsize), (char const   */* __restrict  */)new);
      }
      }
    }
  }
#line 3150
  return (result);
}
}
#line 3153 "dfa.c"
static char *icpyalloc(char *string ) 
{ 
  char *tmp ;

  {
  {
  {
#line 3156
  tmp = icatalloc((char *)((void *)0), string);
  }
  }
#line 3156
  return (tmp);
}
}
#line 3159 "dfa.c"
static char *istrstr(char *lookin , char *lookfor ) 
{ 
  char *cp ;
  size_t len ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
  {
#line 3165
  len = strlen((char const   *)lookfor);
  }
#line 3166
  cp = lookin;
  }
  {
  {
#line 3166
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3166
    if (! ((int )*cp != 0)) {
#line 3166
      goto while_break;
    }
#line 3167
    if (0) {
#line 3167
      if (0) {
        {
        {
#line 3167
        __s1_len = strlen((char const   *)cp);
        }
        {
#line 3167
        __s2_len = strlen((char const   *)lookfor);
        }
        }
#line 3167
        if (! ((size_t )((void const   *)(cp + 1)) - (size_t )((void const   *)cp) == 1U)) {
#line 3167
          goto _L___0;
        } else
#line 3167
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 3167
          if (! ((size_t )((void const   *)(lookfor + 1)) - (size_t )((void const   *)lookfor) == 1U)) {
#line 3167
            tmp___6 = 1;
          } else
#line 3167
          if (__s2_len >= 4U) {
#line 3167
            tmp___6 = 1;
          } else {
#line 3167
            tmp___6 = 0;
          }
        } else {
#line 3167
          tmp___6 = 0;
        }
#line 3167
        if (tmp___6) {
#line 3167
          if (__s1_len < __s2_len) {
#line 3167
            tmp___2 = __s1_len;
          } else {
#line 3167
            tmp___2 = __s2_len;
          }
          {
          {
#line 3167
          tmp___3 = memcmp((void const   *)((char const   *)cp), (void const   *)((char const   *)lookfor),
                           tmp___2 + 1U);
          }
#line 3167
          tmp___5 = tmp___3;
          }
        } else {
          {
          {
#line 3167
          tmp___4 = strcmp((char const   *)cp, (char const   *)lookfor);
          }
#line 3167
          tmp___5 = tmp___4;
          }
        }
      } else {
        {
        {
#line 3167
        tmp___4 = strcmp((char const   *)cp, (char const   *)lookfor);
        }
#line 3167
        tmp___5 = tmp___4;
        }
      }
#line 3167
      tmp___8 = tmp___5;
    } else {
      {
      {
#line 3167
      tmp___7 = strncmp((char const   *)cp, (char const   *)lookfor, len);
      }
#line 3167
      tmp___8 = tmp___7;
      }
    }
#line 3167
    if (tmp___8 == 0) {
#line 3168
      return (cp);
    }
#line 3166
    cp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3169
  return ((char *)((void *)0));
}
}
#line 3172 "dfa.c"
static void ifree(char *cp ) 
{ 


  {
#line 3175
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
    {
#line 3176
    free((void *)cp);
    }
    }
  }
#line 3177
  return;
}
}
#line 3179 "dfa.c"
static void freelist(char **cpp ) 
{ 
  int i ;

  {
#line 3184
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3185
    return;
  }
#line 3186
  i = 0;
  {
  {
#line 3186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3186
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3186
      goto while_break;
    }
    {
    {
#line 3188
    free((void *)*(cpp + i));
    }
#line 3189
    *(cpp + i) = (char *)((void *)0);
#line 3186
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3191
  return;
}
}
#line 3193 "dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 3198
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3199
    return ((char **)((void *)0));
  }
  {
  {
#line 3200
  new = icpyalloc(new);
  }
  }
#line 3200
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
    {
#line 3202
    freelist(cpp);
    }
    }
#line 3203
    return ((char **)((void *)0));
  }
#line 3205
  *(new + len) = (char )'\000';
#line 3207
  i = 0;
  {
  {
#line 3207
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3207
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3207
      goto while_break;
    }
    {
    {
#line 3208
    tmp = istrstr(*(cpp + i), new);
    }
    }
#line 3208
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
      {
#line 3210
      free((void *)new);
      }
      }
#line 3211
      return (cpp);
    }
#line 3207
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3214
  j = 0;
  {
  {
#line 3215
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 3215
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3215
      goto while_break___0;
    }
    {
    {
#line 3216
    tmp___0 = istrstr(new, *(cpp + j));
    }
    }
#line 3216
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 3217
      j ++;
    } else {
      {
      {
#line 3220
      free((void *)*(cpp + j));
      }
#line 3221
      i --;
      }
#line 3221
      if (i == j) {
#line 3222
        goto while_break___0;
      }
#line 3223
      *(cpp + j) = *(cpp + i);
#line 3224
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 3227
  tmp___1 = realloc((void *)((char *)cpp), (size_t )((unsigned long )(i + 2) * sizeof(*cpp)));
  }
#line 3227
  cpp = (char **)tmp___1;
  }
#line 3228
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3229
    return ((char **)((void *)0));
  }
#line 3230
  *(cpp + i) = new;
#line 3231
  *(cpp + (i + 1)) = (char *)((void *)0);
#line 3232
  return (cpp);
}
}
#line 3238 "dfa.c"
static char **comsubs(char *left , char *right ) 
{ 
  char **cpp ;
  char *lcp ;
  char *rcp ;
  size_t i ;
  size_t len ;
  void *tmp ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
#line 3246
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3247
    return ((char **)((void *)0));
  } else
#line 3246
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3247
    return ((char **)((void *)0));
  }
  {
  {
#line 3248
  tmp = malloc((size_t )sizeof(*cpp));
  }
#line 3248
  cpp = (char **)tmp;
  }
#line 3249
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3250
    return ((char **)((void *)0));
  }
#line 3251
  *(cpp + 0) = (char *)((void *)0);
#line 3252
  lcp = left;
  {
  {
#line 3252
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3252
    if (! ((int )*lcp != 0)) {
#line 3252
      goto while_break;
    }
    {
#line 3254
    len = (size_t )0;
    {
#line 3255
    tmp___1 = strchr((char const   *)right, (int )*lcp);
    }
#line 3255
    rcp = tmp___1;
    }
    {
    {
#line 3256
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3256
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3256
        goto while_break___0;
      }
#line 3258
      i = (size_t )1;
      {
      {
#line 3258
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 3258
        if ((int )*(lcp + i) != 0) {
#line 3258
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3258
            goto while_break___1;
          }
        } else {
#line 3258
          goto while_break___1;
        }
#line 3259
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3258
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3260
      if (i > len) {
#line 3261
        len = i;
      }
      {
      {
#line 3262
      tmp___3 = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
#line 3262
      rcp = tmp___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3264
    if (len == 0U) {
#line 3265
      goto __Cont___0;
    }
    {
    {
#line 3266
    cpp = enlist(cpp, lcp, len);
    }
    }
#line 3266
    if ((unsigned long )cpp == (unsigned long )((void *)0)) {
#line 3267
      goto while_break;
    }
    __Cont___0: /* CIL Label */ 
#line 3252
    lcp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3269
  return (cpp);
}
}
#line 3272 "dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 3277
  if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3278
    return ((char **)((void *)0));
  } else
#line 3277
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3278
    return ((char **)((void *)0));
  }
#line 3279
  i = 0;
  {
  {
#line 3279
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3279
    if (! ((unsigned long )*(new + i) != (unsigned long )((void *)0))) {
#line 3279
      goto while_break;
    }
    {
    {
#line 3281
    tmp = strlen((char const   *)*(new + i));
    }
    {
#line 3281
    old = enlist(old, *(new + i), tmp);
    }
    }
#line 3282
    if ((unsigned long )old == (unsigned long )((void *)0)) {
#line 3283
      goto while_break;
    }
#line 3279
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3285
  return (old);
}
}
#line 3290 "dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  char **temp ;
  int lnum ;
  int rnum ;
  void *tmp ;

  {
#line 3297
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 3298
    return ((char **)((void *)0));
  } else
#line 3297
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 3298
    return ((char **)((void *)0));
  }
  {
  {
#line 3299
  tmp = malloc((size_t )sizeof(*both));
  }
#line 3299
  both = (char **)tmp;
  }
#line 3300
  if ((unsigned long )both == (unsigned long )((void *)0)) {
#line 3301
    return ((char **)((void *)0));
  }
#line 3302
  *(both + 0) = (char *)((void *)0);
#line 3303
  lnum = 0;
  {
  {
#line 3303
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3303
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3303
      goto while_break;
    }
#line 3305
    rnum = 0;
    {
    {
#line 3305
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3305
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3305
        goto while_break___0;
      }
      {
      {
#line 3307
      temp = comsubs(*(left + lnum), *(right + rnum));
      }
      }
#line 3308
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
        {
#line 3310
        freelist(both);
        }
        }
#line 3311
        return ((char **)((void *)0));
      }
      {
      {
#line 3313
      both = addlists(both, temp);
      }
      {
#line 3314
      freelist(temp);
      }
      {
#line 3315
      free((void *)temp);
      }
      }
#line 3316
      if ((unsigned long )both == (unsigned long )((void *)0)) {
#line 3317
        return ((char **)((void *)0));
      }
#line 3305
      rnum ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3303
    lnum ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3320
  return (both);
}
}
#line 3331 "dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3334
  tmp___0 = (char )'\000';
#line 3334
  *(mp->is + 0) = tmp___0;
#line 3334
  tmp = tmp___0;
#line 3334
  *(mp->right + 0) = tmp;
#line 3334
  *(mp->left + 0) = tmp;
  {
#line 3335
  freelist(mp->in);
  }
  }
#line 3336
  return;
}
}
#line 3348 "dfa.c"
static must must0  ;
#line 3350 "dfa.c"
static char empty_string[1]  = {      (char )'\000'};
#line 3338 "dfa.c"
static void dfamust(struct dfa *dfa___1 ) 
{ 
  must *musts ;
  must *mp ;
  char *result ;
  int ri ;
  int i ;
  int exact ;
  token t ;
  struct dfamust *dm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char **new ;
  must *lmp ;
  must *rmp ;
  int j ;
  int ln ;
  int rn ;
  int n ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  must *lmp___0 ;
  must *rmp___0 ;
  char *tp ;
  size_t tmp___22 ;
  char tmp___23 ;
  char tmp___24 ;
  char tmp___25 ;
  char tmp___26 ;
  void *tmp___27 ;
  size_t tmp___28 ;
  void *tmp___29 ;
  size_t tmp___30 ;

  {
  {
#line 3352
  result = empty_string;
#line 3353
  exact = 0;
  {
#line 3354
  tmp = malloc((size_t )((unsigned long )(dfa___1->tindex + 1) * sizeof(*musts)));
  }
#line 3354
  musts = (must *)tmp;
  }
#line 3355
  if ((unsigned long )musts == (unsigned long )((void *)0)) {
#line 3356
    return;
  }
#line 3357
  mp = musts;
#line 3358
  i = 0;
  {
  {
#line 3358
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3358
    if (! (i <= dfa___1->tindex)) {
#line 3358
      goto while_break;
    }
#line 3359
    *(mp + i) = must0;
#line 3358
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3360
  i = 0;
  {
  {
#line 3360
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 3360
    if (! (i <= dfa___1->tindex)) {
#line 3360
      goto while_break___0;
    }
    {
    {
#line 3362
    tmp___0 = malloc((size_t )sizeof(*((mp + i)->in)));
    }
#line 3362
    (mp + i)->in = (char **)tmp___0;
    {
#line 3363
    tmp___1 = malloc((size_t )2);
    }
#line 3363
    (mp + i)->left = (char *)tmp___1;
    {
#line 3364
    tmp___2 = malloc((size_t )2);
    }
#line 3364
    (mp + i)->right = (char *)tmp___2;
    {
#line 3365
    tmp___3 = malloc((size_t )2);
    }
#line 3365
    (mp + i)->is = (char *)tmp___3;
    }
#line 3366
    if ((unsigned long )(mp + i)->in == (unsigned long )((void *)0)) {
#line 3368
      goto done;
    } else
#line 3366
    if ((unsigned long )(mp + i)->left == (unsigned long )((void *)0)) {
#line 3368
      goto done;
    } else
#line 3366
    if ((unsigned long )(mp + i)->right == (unsigned long )((void *)0)) {
#line 3368
      goto done;
    } else
#line 3366
    if ((unsigned long )(mp + i)->is == (unsigned long )((void *)0)) {
#line 3368
      goto done;
    }
#line 3369
    tmp___5 = (char )'\000';
#line 3369
    *((mp + i)->is + 0) = tmp___5;
#line 3369
    tmp___4 = tmp___5;
#line 3369
    *((mp + i)->right + 0) = tmp___4;
#line 3369
    *((mp + i)->left + 0) = tmp___4;
#line 3370
    *((mp + i)->in + 0) = (char *)((void *)0);
#line 3360
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3381
  ri = 0;
  {
  {
#line 3381
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 3381
    if (! (ri < dfa___1->tindex)) {
#line 3381
      goto while_break___1;
    }
#line 3383
    t = *(dfa___1->tokens + ri);
    {
#line 3386
    if ((int )t == 272) {
#line 3386
      goto case_272;
    }
#line 3386
    if ((int )t == 271) {
#line 3386
      goto case_272;
    }
#line 3395
    if ((int )t == 257) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 263) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 262) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 261) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 260) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 259) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 258) {
#line 3395
      goto case_257;
    }
#line 3395
    if ((int )t == 256) {
#line 3395
      goto case_257;
    }
#line 3399
    if ((int )t == 264) {
#line 3399
      goto case_264;
    }
#line 3399
    if ((int )t == 265) {
#line 3399
      goto case_264;
    }
#line 3406
    if ((int )t == 270) {
#line 3406
      goto case_270;
    }
#line 3406
    if ((int )t == 269) {
#line 3406
      goto case_270;
    }
#line 3445
    if ((int )t == 266) {
#line 3445
      goto case_266;
    }
#line 3451
    if ((int )t == -1) {
#line 3451
      goto case_neg_1;
    }
#line 3460
    if ((int )t == 268) {
#line 3460
      goto case_268;
    }
#line 3517
    goto switch_default;
    case_272: /* CIL Label */ 
    case_271: /* CIL Label */ 
#line 3387
    goto done;
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_259: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
    {
#line 3396
    resetmust(mp);
    }
    }
#line 3397
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 3400
    if ((unsigned long )mp <= (unsigned long )musts) {
#line 3401
      goto done;
    }
    {
#line 3402
    mp --;
    {
#line 3403
    resetmust(mp);
    }
    }
#line 3404
    goto switch_break;
    case_270: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 3407
    if ((unsigned long )mp < (unsigned long )(musts + 2)) {
#line 3408
      goto done;
    }
#line 3415
    mp --;
#line 3415
    rmp = mp;
#line 3416
    mp --;
#line 3416
    lmp = mp;
#line 3418
    if (0) {
      {
      {
#line 3418
      __s1_len = strlen((char const   *)lmp->is);
      }
      {
#line 3418
      __s2_len = strlen((char const   *)rmp->is);
      }
      }
#line 3418
      if (! ((size_t )((void const   *)(lmp->is + 1)) - (size_t )((void const   *)lmp->is) == 1U)) {
#line 3418
        goto _L___0;
      } else
#line 3418
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 3418
        if (! ((size_t )((void const   *)(rmp->is + 1)) - (size_t )((void const   *)rmp->is) == 1U)) {
#line 3418
          tmp___11 = 1;
        } else
#line 3418
        if (__s2_len >= 4U) {
#line 3418
          tmp___11 = 1;
        } else {
#line 3418
          tmp___11 = 0;
        }
      } else {
#line 3418
        tmp___11 = 0;
      }
#line 3418
      if (tmp___11) {
#line 3418
        if (__s1_len < __s2_len) {
#line 3418
          tmp___7 = __s1_len;
        } else {
#line 3418
          tmp___7 = __s2_len;
        }
        {
        {
#line 3418
        tmp___8 = memcmp((void const   *)((char const   *)lmp->is), (void const   *)((char const   *)rmp->is),
                         tmp___7 + 1U);
        }
#line 3418
        tmp___10 = tmp___8;
        }
      } else {
        {
        {
#line 3418
        tmp___9 = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
        }
#line 3418
        tmp___10 = tmp___9;
        }
      }
    } else {
      {
      {
#line 3418
      tmp___9 = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
      }
#line 3418
      tmp___10 = tmp___9;
      }
    }
#line 3418
    if (tmp___10 != 0) {
#line 3419
      *(lmp->is + 0) = (char )'\000';
    }
#line 3421
    i = 0;
    {
    {
#line 3422
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 3422
      if ((int )*(lmp->left + i) != 0) {
#line 3422
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3422
          goto while_break___2;
        }
      } else {
#line 3422
        goto while_break___2;
      }
#line 3423
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3424
    *(lmp->left + i) = (char )'\000';
    {
#line 3426
    tmp___12 = strlen((char const   *)lmp->right);
    }
#line 3426
    ln = (int )tmp___12;
    {
#line 3427
    tmp___13 = strlen((char const   *)rmp->right);
    }
#line 3427
    rn = (int )tmp___13;
#line 3428
    n = ln;
    }
#line 3429
    if (n > rn) {
#line 3430
      n = rn;
    }
#line 3431
    i = 0;
    {
    {
#line 3431
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 3431
      if (! (i < n)) {
#line 3431
        goto while_break___3;
      }
#line 3432
      if ((int )*(lmp->right + ((ln - i) - 1)) != (int )*(rmp->right + ((rn - i) - 1))) {
#line 3433
        goto while_break___3;
      }
#line 3431
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3434
    j = 0;
    {
    {
#line 3434
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 3434
      if (! (j < i)) {
#line 3434
        goto while_break___4;
      }
#line 3435
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3434
      j ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3436
    *(lmp->right + j) = (char )'\000';
    {
#line 3437
    new = inboth(lmp->in, rmp->in);
    }
    }
#line 3438
    if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 3439
      goto done;
    }
    {
    {
#line 3440
    freelist(lmp->in);
    }
    {
#line 3441
    free((void *)((char *)lmp->in));
    }
#line 3442
    lmp->in = new;
    }
#line 3444
    goto switch_break;
    case_266: /* CIL Label */ 
#line 3446
    if ((unsigned long )mp <= (unsigned long )musts) {
#line 3447
      goto done;
    }
#line 3448
    mp --;
#line 3449
    *(mp->is + 0) = (char )'\000';
#line 3450
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 3452
    if ((unsigned long )mp != (unsigned long )(musts + 1)) {
#line 3453
      goto done;
    }
#line 3454
    i = 0;
    {
    {
#line 3454
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 3454
      if (! ((unsigned long )*((musts + 0)->in + i) != (unsigned long )((void *)0))) {
#line 3454
        goto while_break___5;
      }
      {
      {
#line 3455
      tmp___14 = strlen((char const   *)*((musts + 0)->in + i));
      }
      {
#line 3455
      tmp___15 = strlen((char const   *)result);
      }
      }
#line 3455
      if (tmp___14 > tmp___15) {
#line 3456
        result = *((musts + 0)->in + i);
      }
#line 3454
      i ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 3457
    if (0) {
      {
      {
#line 3457
      __s1_len___0 = strlen((char const   *)result);
      }
      {
#line 3457
      __s2_len___0 = strlen((char const   *)(musts + 0)->is);
      }
      }
#line 3457
      if (! ((size_t )((void const   *)(result + 1)) - (size_t )((void const   *)result) == 1U)) {
#line 3457
        goto _L___2;
      } else
#line 3457
      if (__s1_len___0 >= 4U) {
        _L___2: /* CIL Label */ 
#line 3457
        if (! ((size_t )((void const   *)((musts + 0)->is + 1)) - (size_t )((void const   *)(musts + 0)->is) == 1U)) {
#line 3457
          tmp___21 = 1;
        } else
#line 3457
        if (__s2_len___0 >= 4U) {
#line 3457
          tmp___21 = 1;
        } else {
#line 3457
          tmp___21 = 0;
        }
      } else {
#line 3457
        tmp___21 = 0;
      }
#line 3457
      if (tmp___21) {
#line 3457
        if (__s1_len___0 < __s2_len___0) {
#line 3457
          tmp___17 = __s1_len___0;
        } else {
#line 3457
          tmp___17 = __s2_len___0;
        }
        {
        {
#line 3457
        tmp___18 = memcmp((void const   *)((char const   *)result), (void const   *)((char const   *)(musts + 0)->is),
                          tmp___17 + 1U);
        }
#line 3457
        tmp___20 = tmp___18;
        }
      } else {
        {
        {
#line 3457
        tmp___19 = strcmp((char const   *)result, (char const   *)(musts + 0)->is);
        }
#line 3457
        tmp___20 = tmp___19;
        }
      }
    } else {
      {
      {
#line 3457
      tmp___19 = strcmp((char const   *)result, (char const   *)(musts + 0)->is);
      }
#line 3457
      tmp___20 = tmp___19;
      }
    }
#line 3457
    if (tmp___20 == 0) {
#line 3458
      exact = 1;
    }
#line 3459
    goto done;
    case_268: /* CIL Label */ 
#line 3461
    if ((unsigned long )mp < (unsigned long )(musts + 2)) {
#line 3462
      goto done;
    }
    {
#line 3467
    mp --;
#line 3467
    rmp___0 = mp;
#line 3468
    mp --;
#line 3468
    lmp___0 = mp;
    {
#line 3472
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
    }
#line 3473
    if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
#line 3474
      goto done;
    }
#line 3475
    if ((int )*(lmp___0->right + 0) != 0) {
#line 3475
      if ((int )*(rmp___0->left + 0) != 0) {
        {
        {
#line 3480
        tp = icpyalloc(lmp___0->right);
        }
        }
#line 3481
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
#line 3482
          goto done;
        }
        {
        {
#line 3483
        tp = icatalloc(tp, rmp___0->left);
        }
        }
#line 3484
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
#line 3485
          goto done;
        }
        {
        {
#line 3486
        tmp___22 = strlen((char const   *)tp);
        }
        {
#line 3486
        lmp___0->in = enlist(lmp___0->in, tp, tmp___22);
        }
        {
#line 3488
        free((void *)tp);
        }
        }
#line 3489
        if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
#line 3490
          goto done;
        }
      }
    }
#line 3493
    if ((int )*(lmp___0->is + 0) != 0) {
      {
      {
#line 3495
      lmp___0->left = icatalloc(lmp___0->left, rmp___0->left);
      }
      }
#line 3497
      if ((unsigned long )lmp___0->left == (unsigned long )((void *)0)) {
#line 3498
        goto done;
      }
    }
#line 3501
    if ((int )*(rmp___0->is + 0) == 0) {
#line 3502
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
    {
#line 3503
    lmp___0->right = icatalloc(lmp___0->right, rmp___0->right);
    }
    }
#line 3504
    if ((unsigned long )lmp___0->right == (unsigned long )((void *)0)) {
#line 3505
      goto done;
    }
#line 3507
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3507
      if ((int )*(rmp___0->is + 0) != 0) {
        {
        {
#line 3509
        lmp___0->is = icatalloc(lmp___0->is, rmp___0->is);
        }
        }
#line 3510
        if ((unsigned long )lmp___0->is == (unsigned long )((void *)0)) {
#line 3511
          goto done;
        }
      } else {
#line 3514
        *(lmp___0->is + 0) = (char )'\000';
      }
    } else {
#line 3514
      *(lmp___0->is + 0) = (char )'\000';
    }
#line 3516
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3518
    if ((int )t < -1) {
#line 3521
      goto done;
    } else
#line 3523
    if ((int )t == 0) {
#line 3526
      goto done;
    } else
#line 3528
    if ((int )t >= 276) {
      {
      {
#line 3536
      resetmust(mp);
      }
      }
    } else
#line 3528
    if ((int )t == 274) {
      {
      {
#line 3536
      resetmust(mp);
      }
      }
    } else
#line 3528
    if ((int )t == 275) {
      {
      {
#line 3536
      resetmust(mp);
      }
      }
    } else {
      {
      {
#line 3541
      resetmust(mp);
      }
#line 3542
      tmp___24 = (char )t;
#line 3542
      *(mp->right + 0) = tmp___24;
#line 3542
      tmp___23 = tmp___24;
#line 3542
      *(mp->left + 0) = tmp___23;
#line 3542
      *(mp->is + 0) = tmp___23;
#line 3543
      tmp___26 = (char )'\000';
#line 3543
      *(mp->right + 1) = tmp___26;
#line 3543
      tmp___25 = tmp___26;
#line 3543
      *(mp->left + 1) = tmp___25;
#line 3543
      *(mp->is + 1) = tmp___25;
      {
#line 3544
      mp->in = enlist(mp->in, mp->is, (size_t )1);
      }
      }
#line 3545
      if ((unsigned long )mp->in == (unsigned long )((void *)0)) {
#line 3546
        goto done;
      }
    }
#line 3548
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3560
    mp ++;
#line 3381
    ri ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  done: 
  {
  {
#line 3563
  tmp___30 = strlen((char const   *)result);
  }
  }
#line 3563
  if (tmp___30) {
    {
    {
#line 3565
    tmp___27 = malloc((size_t )sizeof(struct dfamust ));
    }
#line 3565
    dm = (struct dfamust *)tmp___27;
#line 3566
    dm->exact = exact;
    {
#line 3567
    tmp___28 = strlen((char const   *)result);
    }
    {
#line 3567
    tmp___29 = malloc(tmp___28 + 1U);
    }
#line 3567
    dm->must = (char *)tmp___29;
    {
#line 3568
    strcpy((char */* __restrict  */)dm->must, (char const   */* __restrict  */)result);
    }
#line 3569
    dm->next = dfa___1->musts;
#line 3570
    dfa___1->musts = dm;
    }
  }
#line 3572
  mp = musts;
#line 3573
  i = 0;
  {
  {
#line 3573
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
#line 3573
    if (! (i <= dfa___1->tindex)) {
#line 3573
      goto while_break___6;
    }
    {
    {
#line 3575
    freelist((mp + i)->in);
    }
    {
#line 3576
    ifree((char *)(mp + i)->in);
    }
    {
#line 3577
    ifree((mp + i)->left);
    }
    {
#line 3578
    ifree((mp + i)->right);
    }
    {
#line 3579
    ifree((mp + i)->is);
    }
#line 3573
    i ++;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  {
#line 3581
  free((void *)((char *)mp));
  }
  }
#line 3582
  return;
}
}
#line 62 "/usr/include/sys/mman.h"
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd ,
                  __off64_t __offset )  __asm__("mmap64")  ;
#line 327 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 583
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 589
extern int puts(char const   *__s ) ;
#line 603
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int feof(FILE *__stream ) ;
#line 75 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64")  ;
#line 289 "/usr/include/unistd.h"
extern __off64_t lseek(int __fd , __off64_t __offset , int __whence )  __asm__("lseek64")  ;
#line 305
extern int close(int __fd ) ;
#line 312
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 711
extern int isatty(int __fd ) ;
#line 36 "../lib/getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 872 "/usr/include/unistd.h"
extern int getpagesize(void)  __attribute__((__const__)) ;
#line 598 "/usr/include/stdlib.h"
extern int atexit(void (*__func)(void) ) ;
#line 626
extern char *getenv(char const   *__name ) ;
#line 42 "/usr/include/string.h"
extern void *memmove(void *__dest , void const   *__src , size_t __n ) ;
#line 164
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 287
extern int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 81 "/usr/include/libintl.h"
extern char *textdomain(char const   *__domainname ) ;
#line 85
extern char *bindtextdomain(char const   *__domainname , char const   *__dirname ) ;
#line 140 "../lib/getopt.h"
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 39 "grep.h"
int match_icase  ;
#line 40 "grep.h"
int match_words  ;
#line 41 "grep.h"
int match_lines  ;
#line 42 "grep.h"
unsigned char eolbyte  ;
#line 414 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) 
{ 
  unsigned long long tmp ;

  {
  {
  {
#line 418
  tmp = __strtoull_internal(nptr, endptr, base, 0);
  }
  }
#line 418
  return (tmp);
}
}
#line 55 "grep.c"
static struct stats stats_base  ;
#line 58 "grep.c"
static int show_help  ;
#line 61 "grep.c"
static int show_version  ;
#line 64 "grep.c"
static int suppress_errors  ;
#line 67 "grep.c"
static int mmap_option  ;
#line 70 "grep.c"
static int color_option  ;
#line 73 "grep.c"
static int only_matching  ;
#line 77 "grep.c"
static char const   *grep_color  =    "01;31";
#line 79 "grep.c"
static struct exclude *excluded_patterns  ;
#line 80 "grep.c"
static struct exclude *included_patterns  ;
#line 82 "grep.c"
static char const   short_options[58]  = 
#line 82
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )':', 
        (char const   )'B',      (char const   )':',      (char const   )'C',      (char const   )':', 
        (char const   )'D',      (char const   )':',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'P', 
        (char const   )'U',      (char const   )'V',      (char const   )'X',      (char const   )':', 
        (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )':',      (char const   )'e',      (char const   )':',      (char const   )'f', 
        (char const   )':',      (char const   )'h',      (char const   )'i',      (char const   )'K', 
        (char const   )'L',      (char const   )'l',      (char const   )'m',      (char const   )':', 
        (char const   )'n',      (char const   )'o',      (char const   )'q',      (char const   )'R', 
        (char const   )'r',      (char const   )'s',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'Z', 
        (char const   )'z',      (char const   )'\000'};
#line 98 "grep.c"
static struct option  const  long_options[47]  = 
#line 98
  {      {"after-context", 1, (int *)((void *)0), 'A'}, 
        {"basic-regexp", 0, (int *)((void *)0), 'G'}, 
        {"before-context", 1, (int *)((void *)0), 'B'}, 
        {"binary-files", 1, (int *)((void *)0), 128}, 
        {"byte-offset", 0, (int *)((void *)0), 'b'}, 
        {"context", 1, (int *)((void *)0), 'C'}, 
        {"color", 2, (int *)((void *)0), 129}, 
        {"colour", 2, (int *)((void *)0), 129}, 
        {"count", 0, (int *)((void *)0), 'c'}, 
        {"devices", 1, (int *)((void *)0), 'D'}, 
        {"directories", 1, (int *)((void *)0), 'd'}, 
        {"extended-regexp", 0, (int *)((void *)0), 'E'}, 
        {"exclude", 1, (int *)((void *)0), 131}, 
        {"exclude-from", 1, (int *)((void *)0), 132}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"files-with-matches", 0, (int *)((void *)0), 'l'}, 
        {"files-without-match", 0, (int *)((void *)0), 'L'}, 
        {"fixed-regexp", 0, (int *)((void *)0), 'F'}, 
        {"fixed-strings", 0, (int *)((void *)0), 'F'}, 
        {"help", 0, & show_help, 1}, 
        {"include", 1, (int *)((void *)0), 130}, 
        {"ignore-case", 0, (int *)((void *)0), 'i'}, 
        {"label", 1, (int *)((void *)0), 134}, 
        {"line-buffered", 0, (int *)((void *)0), 133}, 
        {"line-number", 0, (int *)((void *)0), 'n'}, 
        {"line-regexp", 0, (int *)((void *)0), 'x'}, 
        {"max-count", 1, (int *)((void *)0), 'm'}, 
        {"mmap", 0, & mmap_option, 1}, 
        {"no-filename", 0, (int *)((void *)0), 'h'}, 
        {"no-messages", 0, (int *)((void *)0), 's'}, 
        {"null", 0, (int *)((void *)0), 'Z'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"only-matching", 0, (int *)((void *)0), 'o'}, 
        {"perl-regexp", 0, (int *)((void *)0), 'P'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"recursive", 0, (int *)((void *)0), 'r'}, 
        {"recursive", 0, (int *)((void *)0), 'R'}, 
        {"regexp", 1, (int *)((void *)0), 'e'}, 
        {"invert-match", 0, (int *)((void *)0), 'v'}, 
        {"silent", 0, (int *)((void *)0), 'q'}, 
        {"text", 0, (int *)((void *)0), 'a'}, 
        {"binary", 0, (int *)((void *)0), 'U'}, 
        {"unix-byte-offsets", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"with-filename", 0, (int *)((void *)0), 'H'}, 
        {"word-regexp", 0, (int *)((void *)0), 'w'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 157 "grep.c"
char *program_name  ;
#line 158 "grep.c"
static char const   *filename  ;
#line 159 "grep.c"
static int errseen  ;
#line 162 "grep.c"
static enum __anonenum_directories_25 directories  =    (enum __anonenum_directories_25 )0;
#line 170 "grep.c"
static enum __anonenum_devices_26 devices  =    (enum __anonenum_devices_26 )0;
#line 176
static int grepdir(char const   *dir , struct stats  const  *stats ) ;
#line 182 "grep.c"
static void (*compile)(char const   * , size_t  )  ;
#line 183 "grep.c"
static size_t (*execute)(char const   * , size_t  , size_t * , int  )  ;
#line 186 "grep.c"
static void suppressible_error(char const   *mesg , int errnum ) 
{ 
  char *__cil_tmp3 ;

  {
#line 189
  if (! suppress_errors) {
    {
    {
#line 190
    error(0, errnum, "%s", mesg);
    }
    }
  }
#line 191
  errseen = 1;
#line 192
  return;
}
}
#line 197 "grep.c"
static void context_length_arg(char const   *str , int *out ) 
{ 
  uintmax_t value ;
  char *tmp ;
  strtol_error tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 201
  tmp___0 = xstrtoumax(str, (char **)0, 10, & value, "");
  }
  }
#line 201
  if ((unsigned int )tmp___0 == 0U) {
#line 201
    tmp___1 = (int )value;
#line 201
    *out = tmp___1;
#line 201
    if (0 <= tmp___1) {
#line 201
      if (! ((uintmax_t )*out == value)) {
        {
        {
#line 205
        tmp = dcgettext((char const   *)((void *)0), "invalid context length argument",
                        5);
        }
        {
#line 205
        error(2, 0, "%s: %s\n", str, tmp);
        }
        }
      }
    } else {
      {
      {
#line 205
      tmp = dcgettext((char const   *)((void *)0), "invalid context length argument",
                      5);
      }
      {
#line 205
      error(2, 0, "%s: %s\n", str, tmp);
      }
      }
    }
  } else {
    {
    {
#line 205
    tmp = dcgettext((char const   *)((void *)0), "invalid context length argument",
                    5);
    }
    {
#line 205
    error(2, 0, "%s: %s\n", str, tmp);
    }
    }
  }
#line 207
  return;
}
}
#line 214 "grep.c"
static char *buffer  ;
#line 215 "grep.c"
static size_t bufalloc  ;
#line 217 "grep.c"
static int bufdesc  ;
#line 218 "grep.c"
static char *bufbeg  ;
#line 219 "grep.c"
static char *buflim  ;
#line 220 "grep.c"
static size_t pagesize  ;
#line 221 "grep.c"
static off_t bufoffset  ;
#line 222 "grep.c"
static off_t after_last_match  ;
#line 227 "grep.c"
static int bufmapped  ;
#line 228 "grep.c"
static off_t initial_bufoffset  ;
#line 242 "grep.c"
static int reset(int fd , char const   *file , struct stats *stats ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 245
  if (! pagesize) {
    {
    {
#line 247
    tmp = getpagesize();
    }
#line 247
    pagesize = (size_t )tmp;
    }
#line 248
    if (pagesize == 0U) {
      {
      {
#line 249
      abort();
      }
      }
    } else
#line 248
    if (2U * pagesize + 1U <= pagesize) {
      {
      {
#line 249
      abort();
      }
      }
    }
#line 250
    if (32768U % pagesize == 0U) {
#line 250
      tmp___0 = (size_t )32768;
    } else {
#line 250
      tmp___0 = 32768U + (pagesize - 32768U % pagesize);
    }
    {
#line 250
    bufalloc = (tmp___0 + pagesize) + 1U;
    {
#line 251
    tmp___1 = xmalloc(bufalloc);
    }
#line 251
    buffer = (char *)tmp___1;
    }
  }
#line 254
  if ((size_t )(buffer + 1) % pagesize == 0U) {
#line 254
    buflim = buffer + 1;
  } else {
#line 254
    buflim = (buffer + 1) + (pagesize - (size_t )(buffer + 1) % pagesize);
  }
  {
#line 254
  bufbeg = buflim;
#line 255
  *(bufbeg + -1) = (char )eolbyte;
#line 256
  bufdesc = fd;
  {
#line 258
  tmp___3 = fstat(fd, & stats->stat);
  }
  }
#line 258
  if (tmp___3 != 0) {
    {
    {
#line 260
    tmp___2 = __errno_location();
    }
    {
#line 260
    error(0, *tmp___2, "fstat");
    }
    }
#line 261
    return (0);
  }
#line 263
  if ((unsigned int )directories == 2U) {
#line 263
    if ((stats->stat.st_mode & 61440U) == 16384U) {
#line 264
      return (0);
    }
  }
#line 266
  if ((unsigned int )devices == 1U) {
#line 266
    if ((stats->stat.st_mode & 61440U) == 8192U) {
#line 270
      return (0);
    } else
#line 266
    if ((stats->stat.st_mode & 61440U) == 24576U) {
#line 270
      return (0);
    } else
#line 266
    if ((stats->stat.st_mode & 61440U) == 49152U) {
#line 270
      return (0);
    }
  }
#line 271
  if ((stats->stat.st_mode & 61440U) == 32768U) {
#line 273
    if (file) {
#line 274
      bufoffset = (off_t )0;
    } else {
      {
      {
#line 277
      bufoffset = lseek(fd, (__off64_t )0, 1);
      }
      }
#line 278
      if (bufoffset < 0LL) {
        {
        {
#line 280
        tmp___4 = __errno_location();
        }
        {
#line 280
        error(0, *tmp___4, "lseek");
        }
        }
#line 281
        return (0);
      }
    }
#line 285
    initial_bufoffset = bufoffset;
#line 286
    if (mmap_option) {
#line 286
      if (bufoffset % (long long )pagesize == 0LL) {
#line 286
        tmp___5 = 1;
      } else {
#line 286
        tmp___5 = 0;
      }
    } else {
#line 286
      tmp___5 = 0;
    }
#line 286
    bufmapped = tmp___5;
  } else {
#line 292
    bufmapped = 0;
  }
#line 295
  return (1);
}
}
#line 302 "grep.c"
static int fillbuf(size_t save , struct stats  const  *stats ) 
{ 
  size_t fillsize ;
  int cc ;
  char *readbuf ;
  size_t readsize ;
  size_t saved_offset ;
  size_t minsize ;
  size_t newsize ;
  size_t newalloc ;
  char *newbuf ;
  off_t to_be_read ;
  off_t maxsize_off ;
  void *tmp ;
  size_t mmapsize ;
  int *tmp___0 ;
  __off64_t tmp___1 ;
  void *tmp___2 ;
  ssize_t bytesread ;
  int *tmp___3 ;
  char *__cil_tmp21 ;

  {
#line 305
  fillsize = (size_t )0;
#line 306
  cc = 1;
#line 312
  saved_offset = (size_t )((buflim - save) - buffer);
#line 314
  if ((long )pagesize <= (buffer + bufalloc) - buflim) {
#line 316
    readbuf = buflim;
#line 317
    bufbeg = buflim - save;
  } else {
#line 321
    minsize = save + pagesize;
#line 327
    newsize = (bufalloc - pagesize) - 1U;
    {
    {
#line 327
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 327
      if (! (newsize < minsize)) {
#line 327
        goto while_break;
      }
#line 328
      if (newsize * 2U < newsize) {
        {
        {
#line 329
        xalloc_die();
        }
        }
      } else
#line 328
      if ((newsize * 2U + pagesize) + 1U < newsize * 2U) {
        {
        {
#line 329
        xalloc_die();
        }
        }
      }
#line 327
      newsize *= 2U;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 336
    if ((stats->stat.st_mode & 61440U) == 32768U) {
#line 338
      to_be_read = (off_t )(stats->stat.st_size - (__off64_t const   )bufoffset);
#line 339
      maxsize_off = (off_t )save + to_be_read;
#line 340
      if (0LL <= to_be_read) {
#line 340
        if (to_be_read <= maxsize_off) {
#line 340
          if (maxsize_off == (off_t )((size_t )maxsize_off)) {
#line 340
            if (minsize <= (size_t )maxsize_off) {
#line 340
              if ((size_t )maxsize_off < newsize) {
#line 344
                newsize = (size_t )maxsize_off;
              }
            }
          }
        }
      }
    }
#line 349
    newalloc = (newsize + pagesize) + 1U;
#line 351
    if (bufalloc < newalloc) {
      {
#line 351
      bufalloc = newalloc;
      {
#line 351
      tmp = xmalloc(bufalloc);
      }
#line 351
      newbuf = (char *)tmp;
      }
    } else {
#line 351
      newbuf = buffer;
    }
#line 352
    if ((size_t )((newbuf + 1) + save) % pagesize == 0U) {
#line 352
      readbuf = (newbuf + 1) + save;
    } else {
#line 352
      readbuf = ((newbuf + 1) + save) + (pagesize - (size_t )((newbuf + 1) + save) % pagesize);
    }
    {
#line 353
    bufbeg = readbuf - save;
    {
#line 354
    memmove((void *)bufbeg, (void const   *)(buffer + saved_offset), save);
    }
#line 355
    *(bufbeg + -1) = (char )eolbyte;
    }
#line 356
    if ((unsigned long )newbuf != (unsigned long )buffer) {
      {
      {
#line 358
      free((void *)buffer);
      }
#line 359
      buffer = newbuf;
      }
    }
  }
#line 363
  readsize = (size_t )((buffer + bufalloc) - readbuf);
#line 364
  readsize -= readsize % pagesize;
#line 367
  if (bufmapped) {
#line 369
    mmapsize = readsize;
#line 373
    if (stats->stat.st_size - (__off64_t const   )bufoffset < (__off64_t const   )mmapsize) {
#line 375
      mmapsize = (size_t )(stats->stat.st_size - (__off64_t const   )bufoffset);
#line 376
      mmapsize -= mmapsize % pagesize;
    }
#line 379
    if (mmapsize) {
      {
      {
#line 379
      tmp___2 = mmap((void *)readbuf, mmapsize, 3, 18, bufdesc, bufoffset);
      }
      }
#line 379
      if ((unsigned long )tmp___2 != (unsigned long )((caddr_t )-1)) {
#line 388
        fillsize = mmapsize;
      } else {
#line 379
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 397
      bufmapped = 0;
#line 398
      if (bufoffset != initial_bufoffset) {
        {
        {
#line 398
        tmp___1 = lseek(bufdesc, bufoffset, 0);
        }
        }
#line 398
        if (tmp___1 < 0LL) {
          {
          {
#line 401
          tmp___0 = __errno_location();
          }
          {
#line 401
          error(0, *tmp___0, "lseek");
          }
#line 402
          cc = 0;
          }
        }
      }
    }
  }
#line 408
  if (! fillsize) {
    {
    {
#line 411
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 411
      bytesread = read(bufdesc, (void *)readbuf, readsize);
      }
      }
#line 411
      if (bytesread < 0) {
        {
        {
#line 411
        tmp___3 = __errno_location();
        }
        }
#line 411
        if (! (*tmp___3 == 4)) {
#line 411
          goto while_break___0;
        }
      } else {
#line 411
        goto while_break___0;
      }
#line 413
      goto while_continue___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 414
    if (bytesread < 0) {
#line 415
      cc = 0;
    } else {
#line 417
      fillsize = (size_t )bytesread;
    }
  }
#line 420
  bufoffset += (off_t )fillsize;
#line 425
  buflim = readbuf + fillsize;
#line 426
  return (cc);
}
}
#line 430 "grep.c"
static enum __anonenum_binary_files_27 binary_files  ;
#line 437 "grep.c"
static int filename_mask  ;
#line 438 "grep.c"
static int out_quiet  ;
#line 439 "grep.c"
static int out_invert  ;
#line 440 "grep.c"
static int out_file  ;
#line 441 "grep.c"
static int out_line  ;
#line 442 "grep.c"
static int out_byte  ;
#line 443 "grep.c"
static int out_before  ;
#line 444 "grep.c"
static int out_after  ;
#line 445 "grep.c"
static int count_matches  ;
#line 446 "grep.c"
static int list_files  ;
#line 447 "grep.c"
static int no_filenames  ;
#line 448 "grep.c"
static off_t max_count  ;
#line 450 "grep.c"
static int line_buffered  ;
#line 452 "grep.c"
static char *label  =    (char *)((void *)0);
#line 456 "grep.c"
static uintmax_t totalcc  ;
#line 457 "grep.c"
static char const   *lastnl  ;
#line 458 "grep.c"
static char const   *lastout  ;
#line 461 "grep.c"
static uintmax_t totalnl  ;
#line 462 "grep.c"
static off_t outleft  ;
#line 463 "grep.c"
static int pending  ;
#line 465 "grep.c"
static int done_on_match  ;
#line 466 "grep.c"
static int exit_on_match  ;
#line 474 "grep.c"
static uintmax_t add_count(uintmax_t a , uintmax_t b ) 
{ 
  uintmax_t sum ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 477
  sum = a + b;
#line 478
  if (sum < a) {
    {
    {
#line 479
    tmp = dcgettext((char const   *)((void *)0), "input is too large to count", 5);
    }
    {
#line 479
    error(2, 0, (char const   *)tmp);
    }
    }
  }
#line 480
  return (sum);
}
}
#line 483 "grep.c"
static void nlscan(char const   *lim ) 
{ 
  size_t newlines ;
  char const   *beg ;
  void *tmp ;

  {
#line 486
  newlines = (size_t )0;
#line 488
  beg = lastnl;
  {
  {
#line 488
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 488
    if (! ((unsigned long )beg != (unsigned long )lim)) {
#line 488
      goto while_break;
    }
    {
#line 489
    newlines ++;
    {
#line 488
    tmp = memchr((void const   *)beg, (int )eolbyte, (size_t )(lim - beg));
    }
#line 488
    beg = (char const   *)tmp;
#line 488
    beg ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  totalnl = add_count(totalnl, (uintmax_t )newlines);
  }
#line 491
  lastnl = lim;
  }
#line 492
  return;
}
}
#line 495 "grep.c"
static void print_offset_sep(uintmax_t pos , char sep ) 
{ 
  char buf[sizeof(pos) * 8UL] ;
  char *p ;
  void *__cil_tmp5 ;

  {
#line 502
  p = (buf + sizeof(buf)) - 1;
#line 503
  *p = sep;
  {
  {
#line 505
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 506
    p --;
#line 506
    *p = (char )(48ULL + pos % 10ULL);
#line 505
    pos /= 10ULL;
#line 505
    if (! (pos != 0ULL)) {
#line 505
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 509
  fwrite((void const   */* __restrict  */)p, (size_t )1, (size_t )((buf + sizeof(buf)) - p),
         (FILE */* __restrict  */)stdout);
  }
  }
#line 510
  return;
}
}
#line 512 "grep.c"
static void prline(char const   *beg , char const   *lim , int sep ) 
{ 
  uintmax_t pos ;
  uintmax_t tmp ;
  size_t match_size ;
  size_t match_offset ;
  char const   *b ;
  size_t match_size___0 ;
  size_t match_offset___0 ;
  char *buf ;
  void *tmp___0 ;
  char *ibeg ;
  char *ilim ;
  int i ;
  int __res ;
  __int32_t const   **tmp___2 ;
  char const   *b___0 ;
  char const   *b___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 515
  if (out_file) {
    {
    {
#line 516
    printf((char const   */* __restrict  */)"%s%c", filename, sep & filename_mask);
    }
    }
  }
#line 517
  if (out_line) {
    {
    {
#line 519
    nlscan(beg);
    }
    {
#line 520
    totalnl = add_count(totalnl, (uintmax_t )1);
    }
    {
#line 521
    print_offset_sep(totalnl, (char )sep);
    }
#line 522
    lastnl = lim;
    }
  }
#line 524
  if (out_byte) {
    {
    {
#line 526
    tmp = add_count(totalcc, (uintmax_t )(beg - (char const   *)bufbeg));
    }
#line 526
    pos = tmp;
    {
#line 530
    print_offset_sep(pos, (char )sep);
    }
    }
  }
#line 532
  if (only_matching) {
    {
    {
#line 536
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 536
      match_offset = (*execute)(beg, (size_t )(lim - beg), & match_size, 1);
      }
      }
#line 536
      if (! (match_offset != 4294967295U)) {
#line 536
        goto while_break;
      }
#line 539
      b = beg + match_offset;
#line 540
      if ((unsigned long )b == (unsigned long )lim) {
#line 541
        goto while_break;
      }
#line 542
      if (match_size == 0U) {
#line 543
        goto while_break;
      }
#line 544
      if (color_option) {
        {
        {
#line 545
        printf((char const   */* __restrict  */)"\033[%sm", grep_color);
        }
        }
      }
      {
      {
#line 546
      fwrite((void const   */* __restrict  */)b, (size_t )sizeof(char ), match_size,
             (FILE */* __restrict  */)stdout);
      }
      }
#line 547
      if (color_option) {
        {
        {
#line 548
        fputs((char const   */* __restrict  */)"\033[00m", (FILE */* __restrict  */)stdout);
        }
        }
      }
      {
      {
#line 549
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
      }
#line 550
      beg = b + match_size;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 552
    lastout = lim;
#line 553
    if (line_buffered) {
      {
      {
#line 554
      fflush(stdout);
      }
      }
    }
#line 555
    return;
  }
#line 557
  if (color_option) {
#line 561
    if (match_icase) {
      {
      {
#line 564
      tmp___0 = xmalloc((size_t )(lim - beg));
      }
#line 564
      buf = (char *)tmp___0;
#line 565
      ibeg = buf;
#line 566
      ilim = ibeg + (lim - beg);
#line 568
      i = 0;
      }
      {
      {
#line 568
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 568
        if (! ((long )i < lim - beg)) {
#line 568
          goto while_break___0;
        }
#line 569
        if (sizeof(*(beg + i)) > 1UL) {
          {
          {
#line 569
          __res = tolower((int )*(beg + i));
          }
          }
        } else {
          {
          {
#line 569
          tmp___2 = __ctype_tolower_loc();
          }
#line 569
          __res = (int )*(*tmp___2 + (int )*(beg + i));
          }
        }
#line 569
        *(ibeg + i) = (char )__res;
#line 568
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 570
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 570
        match_offset___0 = (*execute)((char const   *)ibeg, (size_t )(ilim - ibeg),
                                      & match_size___0, 1);
        }
        }
#line 570
        if (! (match_offset___0 != 4294967295U)) {
#line 570
          goto while_break___1;
        }
#line 573
        b___0 = beg + match_offset___0;
#line 574
        if ((unsigned long )b___0 == (unsigned long )lim) {
#line 575
          goto while_break___1;
        }
        {
        {
#line 576
        fwrite((void const   */* __restrict  */)beg, (size_t )sizeof(char ), match_offset___0,
               (FILE */* __restrict  */)stdout);
        }
        {
#line 577
        printf((char const   */* __restrict  */)"\033[%sm", grep_color);
        }
        {
#line 578
        fwrite((void const   */* __restrict  */)b___0, (size_t )sizeof(char ), match_size___0,
               (FILE */* __restrict  */)stdout);
        }
        {
#line 579
        fputs((char const   */* __restrict  */)"\033[00m", (FILE */* __restrict  */)stdout);
        }
#line 580
        beg = b___0 + match_size___0;
#line 581
        ibeg = (ibeg + match_offset___0) + match_size___0;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 583
      fwrite((void const   */* __restrict  */)beg, (size_t )1, (size_t )(lim - beg),
             (FILE */* __restrict  */)stdout);
      }
      {
#line 584
      free((void *)buf);
      }
#line 585
      lastout = lim;
      }
#line 586
      return;
    }
    {
    {
#line 588
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 588
      if (lim - beg) {
        {
        {
#line 588
        match_offset___0 = (*execute)(beg, (size_t )(lim - beg), & match_size___0,
                                      1);
        }
        }
#line 588
        if (! (match_offset___0 != 4294967295U)) {
#line 588
          goto while_break___2;
        }
      } else {
#line 588
        goto while_break___2;
      }
#line 591
      b___1 = beg + match_offset___0;
#line 593
      if ((unsigned long )b___1 == (unsigned long )lim) {
#line 594
        goto while_break___2;
      }
#line 596
      if (match_size___0 == 0U) {
#line 597
        goto while_break___2;
      }
      {
      {
#line 598
      fwrite((void const   */* __restrict  */)beg, (size_t )sizeof(char ), match_offset___0,
             (FILE */* __restrict  */)stdout);
      }
      {
#line 599
      printf((char const   */* __restrict  */)"\033[%sm", grep_color);
      }
      {
#line 600
      fwrite((void const   */* __restrict  */)b___1, (size_t )sizeof(char ), match_size___0,
             (FILE */* __restrict  */)stdout);
      }
      {
#line 601
      fputs((char const   */* __restrict  */)"\033[00m", (FILE */* __restrict  */)stdout);
      }
#line 602
      beg = b___1 + match_size___0;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
  {
#line 605
  fwrite((void const   */* __restrict  */)beg, (size_t )1, (size_t )(lim - beg), (FILE */* __restrict  */)stdout);
  }
  {
#line 606
  tmp___5 = ferror(stdout);
  }
  }
#line 606
  if (tmp___5) {
    {
    {
#line 607
    tmp___3 = dcgettext((char const   *)((void *)0), "writing output", 5);
    }
    {
#line 607
    tmp___4 = __errno_location();
    }
    {
#line 607
    error(0, *tmp___4, (char const   *)tmp___3);
    }
    }
  }
#line 608
  lastout = lim;
#line 609
  if (line_buffered) {
    {
    {
#line 610
    fflush(stdout);
    }
    }
  }
#line 611
  return;
}
}
#line 615 "grep.c"
static void prpending(char const   *lim ) 
{ 
  char const   *nl ;
  void *tmp ;
  size_t match_size ;
  size_t tmp___0 ;

  {
#line 618
  if (! lastout) {
#line 619
    lastout = (char const   *)bufbeg;
  }
  {
  {
#line 620
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 620
    if (pending > 0) {
#line 620
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
#line 620
        goto while_break;
      }
    } else {
#line 620
      goto while_break;
    }
    {
    {
#line 622
    tmp = memchr((void const   *)lastout, (int )eolbyte, (size_t )(lim - lastout));
    }
#line 622
    nl = (char const   *)tmp;
#line 624
    pending --;
    }
#line 625
    if (outleft) {
      {
      {
#line 628
      prline(lastout, nl + 1, '-');
      }
      }
    } else {
      {
      {
#line 625
      tmp___0 = (*execute)(lastout, (size_t )(nl - lastout), & match_size, 0);
      }
      }
#line 625
      if ((tmp___0 == 4294967295U) == ! out_invert) {
        {
        {
#line 628
        prline(lastout, nl + 1, '-');
        }
        }
      } else {
#line 630
        pending = 0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  return;
}
}
#line 639 "grep.c"
static int used  ;
#line 636 "grep.c"
static void prtext(char const   *beg , char const   *lim , int *nlinesp ) 
{ 
  char const   *bp ;
  char const   *p ;
  char eol ;
  int i ;
  int n ;
  char const   *nl ;
  void *tmp ;
  char const   *nl___0 ;
  void *tmp___0 ;
  char *__cil_tmp13 ;

  {
#line 641
  eol = (char )eolbyte;
#line 644
  if (! out_quiet) {
#line 644
    if (pending > 0) {
      {
      {
#line 645
      prpending(beg);
      }
      }
    }
  }
#line 647
  p = beg;
#line 649
  if (! out_quiet) {
#line 653
    if (lastout) {
#line 653
      bp = lastout;
    } else {
#line 653
      bp = (char const   *)bufbeg;
    }
#line 654
    i = 0;
    {
    {
#line 654
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 654
      if (! (i < out_before)) {
#line 654
        goto while_break;
      }
#line 655
      if ((unsigned long )p > (unsigned long )bp) {
        {
        {
#line 656
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 657
          p --;
#line 656
          if (! ((int const   )*(p + -1) != (int const   )eol)) {
#line 656
            goto while_break___0;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 654
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 662
    if (out_before) {
#line 662
      goto _L;
    } else
#line 662
    if (out_after) {
      _L: /* CIL Label */ 
#line 662
      if (used) {
#line 662
        if ((unsigned long )p != (unsigned long )lastout) {
          {
          {
#line 663
          puts("--");
          }
          }
        }
      }
    }
    {
    {
#line 665
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 665
      if (! ((unsigned long )p < (unsigned long )beg)) {
#line 665
        goto while_break___1;
      }
      {
      {
#line 667
      tmp = memchr((void const   *)p, (int )eol, (size_t )(beg - p));
      }
#line 667
      nl = (char const   *)tmp;
#line 668
      nl ++;
      {
#line 669
      prline(p, nl, '-');
      }
#line 670
      p = nl;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 674
  if (nlinesp) {
#line 677
    n = 0;
    {
    {
#line 677
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 677
      if ((unsigned long )p < (unsigned long )lim) {
#line 677
        if (! ((off_t )n < outleft)) {
#line 677
          goto while_break___2;
        }
      } else {
#line 677
        goto while_break___2;
      }
      {
      {
#line 679
      tmp___0 = memchr((void const   *)p, (int )eol, (size_t )(lim - p));
      }
#line 679
      nl___0 = (char const   *)tmp___0;
#line 680
      nl___0 ++;
      }
#line 681
      if (! out_quiet) {
        {
        {
#line 682
        prline(p, nl___0, ':');
        }
        }
      }
#line 683
      p = nl___0;
#line 677
      n ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 685
    *nlinesp = n;
#line 688
    after_last_match = bufoffset - (off_t )(buflim - (char *)p);
  } else
#line 691
  if (! out_quiet) {
    {
    {
#line 692
    prline(beg, lim, ':');
    }
    }
  }
#line 694
  if (out_quiet) {
#line 694
    pending = 0;
  } else {
#line 694
    pending = out_after;
  }
#line 695
  used = 1;
#line 696
  return;
}
}
#line 701 "grep.c"
static int grepbuf(char const   *beg , char const   *lim ) 
{ 
  int nlines ;
  int n ;
  register char const   *p ;
  size_t match_offset ;
  size_t match_size ;
  char const   *b ;
  char const   *endp ;

  {
#line 709
  nlines = 0;
#line 710
  p = beg;
  {
  {
#line 711
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 711
    match_offset = (*execute)(p, (size_t )(lim - p), & match_size, 0);
    }
    }
#line 711
    if (! (match_offset != 4294967295U)) {
#line 711
      goto while_break;
    }
#line 713
    b = p + match_offset;
#line 714
    endp = b + match_size;
#line 716
    if ((unsigned long )b == (unsigned long )lim) {
#line 717
      goto while_break;
    }
#line 718
    if (! out_invert) {
      {
      {
#line 720
      prtext(b, endp, (int *)0);
      }
#line 721
      nlines ++;
#line 722
      outleft --;
      }
#line 723
      if (! outleft) {
#line 723
        goto _L;
      } else
#line 723
      if (done_on_match) {
        _L: /* CIL Label */ 
#line 725
        if (exit_on_match) {
          {
          {
#line 726
          exit(0);
          }
          }
        }
#line 727
        after_last_match = bufoffset - (off_t )(buflim - (char *)endp);
#line 728
        return (nlines);
      }
    } else
#line 731
    if ((unsigned long )p < (unsigned long )b) {
      {
      {
#line 733
      prtext(p, b, & n);
      }
#line 734
      nlines += n;
#line 735
      outleft -= (off_t )n;
      }
#line 736
      if (! outleft) {
#line 737
        return (nlines);
      }
    }
#line 739
    p = endp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 741
  if (out_invert) {
#line 741
    if ((unsigned long )p < (unsigned long )lim) {
      {
      {
#line 743
      prtext(p, lim, & n);
      }
#line 744
      nlines += n;
#line 745
      outleft -= (off_t )n;
      }
    }
  }
#line 747
  return (nlines);
}
}
#line 753 "grep.c"
static int grep(int fd , char const   *file , struct stats *stats ) 
{ 
  int nlines ;
  int i ;
  int not_text ;
  size_t residue ;
  size_t save ;
  char oldc ;
  char *beg ;
  char *lim ;
  char eol ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 762
  eol = (char )eolbyte;
  {
#line 764
  tmp = reset(fd, file, stats);
  }
  }
#line 764
  if (! tmp) {
#line 765
    return (0);
  }
#line 767
  if (file) {
#line 767
    if ((unsigned int )directories == 1U) {
#line 767
      if ((stats->stat.st_mode & 61440U) == 16384U) {
        {
        {
#line 772
        tmp___1 = close(fd);
        }
        }
#line 772
        if (tmp___1 != 0) {
          {
          {
#line 773
          tmp___0 = __errno_location();
          }
          {
#line 773
          error(0, *tmp___0, "%s", file);
          }
          }
        }
        {
        {
#line 774
        tmp___2 = grepdir(file, (struct stats  const  *)stats);
        }
        }
#line 774
        return (tmp___2 - 2);
      }
    }
  }
  {
#line 777
  totalcc = (uintmax_t )0;
#line 778
  lastout = (char const   *)0;
#line 779
  totalnl = (uintmax_t )0;
#line 780
  outleft = max_count;
#line 781
  after_last_match = (off_t )0;
#line 782
  pending = 0;
#line 784
  nlines = 0;
#line 785
  residue = (size_t )0;
#line 786
  save = (size_t )0;
  {
#line 788
  tmp___5 = fillbuf(save, (struct stats  const  *)stats);
  }
  }
#line 788
  if (! tmp___5) {
    {
    {
#line 790
    tmp___4 = __errno_location();
    }
    }
#line 790
    if (! (*tmp___4 == 21)) {
      {
      {
#line 791
      tmp___3 = __errno_location();
      }
      {
#line 791
      suppressible_error(filename, *tmp___3);
      }
      }
    }
#line 792
    return (0);
  }
#line 795
  if ((unsigned int )binary_files == 0U) {
#line 795
    if (! out_quiet) {
#line 795
      goto _L;
    } else {
#line 795
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 795
  if ((unsigned int )binary_files == 2U) {
    _L: /* CIL Label */ 
#line 795
    if (eol) {
#line 795
      tmp___6 = '\000';
    } else {
#line 795
      tmp___6 = '\200';
    }
    {
    {
#line 795
    tmp___7 = memchr((void const   *)bufbeg, tmp___6, (size_t )(buflim - bufbeg));
    }
    }
#line 795
    if (tmp___7) {
#line 795
      tmp___8 = 1;
    } else {
#line 795
      tmp___8 = 0;
    }
  } else {
#line 795
    tmp___8 = 0;
  }
#line 795
  not_text = tmp___8;
#line 798
  if (not_text) {
#line 798
    if ((unsigned int )binary_files == 2U) {
#line 799
      return (0);
    }
  }
#line 800
  done_on_match += not_text;
#line 801
  out_quiet += not_text;
  {
  {
#line 803
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 805
    lastnl = (char const   *)bufbeg;
#line 806
    if (lastout) {
#line 807
      lastout = (char const   *)bufbeg;
    }
#line 809
    beg = bufbeg + save;
#line 812
    if ((unsigned long )beg == (unsigned long )buflim) {
#line 813
      goto while_break;
    }
#line 817
    oldc = *(beg + -1);
#line 818
    *(beg + -1) = eol;
#line 819
    lim = buflim;
    {
    {
#line 819
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 819
      if (! ((int )*(lim + -1) != (int )eol)) {
#line 819
        goto while_break___0;
      }
#line 820
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 819
      lim --;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 821
    *(beg + -1) = oldc;
#line 822
    if ((unsigned long )lim == (unsigned long )beg) {
#line 823
      lim = beg - residue;
    }
#line 824
    beg -= residue;
#line 825
    residue = (size_t )(buflim - lim);
#line 827
    if ((unsigned long )beg < (unsigned long )lim) {
#line 829
      if (outleft) {
        {
        {
#line 830
        tmp___9 = grepbuf((char const   *)beg, (char const   *)lim);
        }
#line 830
        nlines += tmp___9;
        }
      }
#line 831
      if (pending) {
        {
        {
#line 832
        prpending((char const   *)lim);
        }
        }
      }
#line 833
      if (! outleft) {
#line 833
        if (! pending) {
#line 834
          goto finish_grep;
        } else {
#line 833
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 833
      if (nlines) {
#line 833
        if (done_on_match) {
#line 833
          if (! out_invert) {
#line 834
            goto finish_grep;
          }
        }
      }
    }
#line 840
    i = 0;
#line 841
    beg = lim;
    {
    {
#line 842
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 842
      if (i < out_before) {
#line 842
        if ((unsigned long )beg > (unsigned long )bufbeg) {
#line 842
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
#line 842
            goto while_break___1;
          }
        } else {
#line 842
          goto while_break___1;
        }
      } else {
#line 842
        goto while_break___1;
      }
#line 844
      i ++;
      {
      {
#line 845
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 846
        beg --;
#line 845
        if (! ((int )*(beg + -1) != (int )eol)) {
#line 845
          goto while_break___2;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 851
    if ((unsigned long )beg != (unsigned long )lastout) {
#line 852
      lastout = (char const   *)0;
    }
#line 855
    save = (size_t )((lim + residue) - beg);
#line 856
    if (out_byte) {
      {
      {
#line 857
      totalcc = add_count(totalcc, (uintmax_t )((buflim - bufbeg) - (long )save));
      }
      }
    }
#line 858
    if (out_line) {
      {
      {
#line 859
      nlscan((char const   *)beg);
      }
      }
    }
    {
    {
#line 860
    tmp___12 = fillbuf(save, (struct stats  const  *)stats);
    }
    }
#line 860
    if (! tmp___12) {
      {
      {
#line 862
      tmp___11 = __errno_location();
      }
      }
#line 862
      if (! (*tmp___11 == 21)) {
        {
        {
#line 863
        tmp___10 = __errno_location();
        }
        {
#line 863
        suppressible_error(filename, *tmp___10);
        }
        }
      }
#line 864
      goto finish_grep;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 867
  if (residue) {
#line 869
    tmp___13 = buflim;
#line 869
    buflim ++;
#line 869
    *tmp___13 = eol;
#line 870
    if (outleft) {
      {
      {
#line 871
      tmp___14 = grepbuf((char const   *)((bufbeg + save) - residue), (char const   *)buflim);
      }
#line 871
      nlines += tmp___14;
      }
    }
#line 872
    if (pending) {
      {
      {
#line 873
      prpending((char const   *)buflim);
      }
      }
    }
  }
  finish_grep: 
#line 877
  done_on_match -= not_text;
#line 878
  out_quiet -= not_text;
#line 879
  if (not_text & ~ out_quiet) {
#line 879
    if (nlines != 0) {
      {
      {
#line 880
      tmp___15 = dcgettext((char const   *)((void *)0), "Binary file %s matches\n",
                           5);
      }
      {
#line 880
      printf((char const   */* __restrict  */)tmp___15, filename);
      }
      }
    }
  }
#line 881
  return (nlines);
}
}
#line 884 "grep.c"
static int grepfile(char const   *file , struct stats *stats ) 
{ 
  int desc ;
  int count ;
  int status ;
  char *tmp ;
  int *tmp___0 ;
  int e ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  off_t required_offset ;
  off_t tmp___6 ;
  int *tmp___7 ;
  __off64_t tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 891
  if (! file) {
#line 893
    desc = 0;
#line 894
    if (label) {
#line 894
      filename = (char const   *)label;
    } else {
      {
      {
#line 894
      tmp = dcgettext((char const   *)((void *)0), "(standard input)", 5);
      }
#line 894
      filename = (char const   *)tmp;
      }
    }
  } else {
    {
    {
#line 898
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 898
      desc = open(file, 0);
      }
      }
#line 898
      if (desc < 0) {
        {
        {
#line 898
        tmp___0 = __errno_location();
        }
        }
#line 898
        if (! (*tmp___0 == 4)) {
#line 898
          goto while_break;
        }
      } else {
#line 898
        goto while_break;
      }
#line 899
      goto while_continue;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 901
    if (desc < 0) {
      {
      {
#line 903
      tmp___1 = __errno_location();
      }
#line 903
      e = *tmp___1;
      }
#line 905
      if (e == 21) {
#line 905
        if ((unsigned int )directories == 1U) {
          {
          {
#line 907
          tmp___3 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& stats->stat));
          }
          }
#line 907
          if (tmp___3 != 0) {
            {
            {
#line 909
            tmp___2 = __errno_location();
            }
            {
#line 909
            error(0, *tmp___2, "%s", file);
            }
            }
#line 910
            return (1);
          }
          {
          {
#line 913
          tmp___4 = grepdir(file, (struct stats  const  *)stats);
          }
          }
#line 913
          return (tmp___4);
        }
      }
#line 916
      if (! suppress_errors) {
#line 918
        if ((unsigned int )directories == 2U) {
          {
#line 922
          if (e == 21) {
#line 922
            goto case_21;
          }
#line 925
          if (e == 13) {
#line 925
            goto case_13;
          }
#line 919
          goto switch_break;
          case_21: /* CIL Label */ 
#line 923
          return (1);
          case_13: /* CIL Label */ 
          {
          {
#line 928
          tmp___5 = isdir(file);
          }
          }
#line 928
          if (tmp___5) {
#line 929
            return (1);
          }
#line 930
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
      {
      {
#line 934
      suppressible_error(file, e);
      }
      }
#line 935
      return (1);
    }
#line 938
    filename = file;
  }
  {
  {
#line 948
  count = grep(desc, file, stats);
  }
  }
#line 949
  if (count < 0) {
#line 950
    status = count + 2;
  } else {
#line 953
    if (count_matches) {
#line 955
      if (out_file) {
        {
        {
#line 956
        printf((char const   */* __restrict  */)"%s%c", filename, 58 & filename_mask);
        }
        }
      }
      {
      {
#line 957
      printf((char const   */* __restrict  */)"%d\n", count);
      }
      }
    }
#line 960
    status = ! count;
#line 961
    if (list_files == 1 - 2 * status) {
      {
      {
#line 962
      printf((char const   */* __restrict  */)"%s%c", filename, 10 & filename_mask);
      }
      }
    }
#line 964
    if (! file) {
#line 966
      if (outleft) {
#line 966
        tmp___6 = bufoffset;
      } else {
#line 966
        tmp___6 = after_last_match;
      }
#line 966
      required_offset = tmp___6;
#line 967
      if (bufmapped) {
#line 967
        goto _L;
      } else
#line 967
      if (required_offset != bufoffset) {
        _L: /* CIL Label */ 
        {
        {
#line 967
        tmp___8 = lseek(desc, required_offset, 0);
        }
        }
#line 967
        if (tmp___8 < 0LL) {
#line 967
          if ((stats->stat.st_mode & 61440U) == 32768U) {
            {
            {
#line 970
            tmp___7 = __errno_location();
            }
            {
#line 970
            error(0, *tmp___7, "%s", filename);
            }
            }
          }
        }
      }
    } else {
      {
      {
#line 973
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 973
        tmp___11 = close(desc);
        }
        }
#line 973
        if (! (tmp___11 != 0)) {
#line 973
          goto while_break___0;
        }
        {
        {
#line 974
        tmp___10 = __errno_location();
        }
        }
#line 974
        if (*tmp___10 != 4) {
          {
          {
#line 976
          tmp___9 = __errno_location();
          }
          {
#line 976
          error(0, *tmp___9, "%s", file);
          }
          }
#line 977
          goto while_break___0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 981
  return (status);
}
}
#line 984 "grep.c"
static int grepdir(char const   *dir , struct stats  const  *stats ) 
{ 
  int status ;
  struct stats  const  *ancestor ;
  char *name_space ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t dirlen ;
  size_t tmp___3 ;
  int needs_slash ;
  int tmp___4 ;
  char *file ;
  char const   *namep ;
  struct stats child ;
  size_t namelen ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 987
  status = 1;
#line 993
  if (stats->stat.st_ino) {
#line 994
    ancestor = stats;
    {
    {
#line 994
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 994
      ancestor = (struct stats  const  *)ancestor->parent;
#line 994
      if (! ((unsigned long )ancestor != (unsigned long )((struct stats  const  *)0))) {
#line 994
        goto while_break;
      }
#line 995
      if (ancestor->stat.st_ino == stats->stat.st_ino) {
#line 995
        if (ancestor->stat.st_dev == stats->stat.st_dev) {
#line 998
          if (! suppress_errors) {
            {
            {
#line 999
            tmp = dcgettext((char const   *)((void *)0), "recursive directory loop",
                            5);
            }
            {
#line 999
            tmp___0 = dcgettext((char const   *)((void *)0), "warning: %s: %s\n",
                                5);
            }
            {
#line 999
            error(0, 0, (char const   *)tmp___0, dir, tmp);
            }
            }
          }
#line 1001
          return (1);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 1004
  name_space = savedir(dir, (off_t )stats->stat.st_size, included_patterns, excluded_patterns);
  }
  }
#line 1007
  if (! name_space) {
    {
    {
#line 1009
    tmp___2 = __errno_location();
    }
    }
#line 1009
    if (*tmp___2) {
      {
      {
#line 1010
      tmp___1 = __errno_location();
      }
      {
#line 1010
      suppressible_error(dir, *tmp___1);
      }
      }
    } else {
      {
      {
#line 1012
      xalloc_die();
      }
      }
    }
  } else {
    {
    {
#line 1016
    tmp___3 = strlen(dir);
    }
#line 1016
    dirlen = tmp___3;
    }
#line 1017
    if (dirlen == 0U) {
#line 1017
      tmp___4 = 0;
    } else
#line 1017
    if ((int const   )*(dir + (dirlen - 1U)) == 47) {
#line 1017
      tmp___4 = 0;
    } else {
#line 1017
      tmp___4 = 1;
    }
#line 1017
    needs_slash = tmp___4;
#line 1019
    file = (char *)((void *)0);
#line 1020
    namep = (char const   *)name_space;
#line 1022
    child.parent = stats;
#line 1023
    out_file += ! no_filenames;
    {
    {
#line 1024
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1024
      if (! *namep) {
#line 1024
        goto while_break___0;
      }
      {
      {
#line 1026
      tmp___5 = strlen(namep);
      }
#line 1026
      namelen = tmp___5;
      {
#line 1027
      tmp___6 = xrealloc((void *)file, ((dirlen + 1U) + namelen) + 1U);
      }
#line 1027
      file = (char *)tmp___6;
      {
#line 1028
      strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)dir);
      }
#line 1029
      *(file + dirlen) = (char )'/';
      {
#line 1030
      strcpy((char */* __restrict  */)((file + dirlen) + needs_slash), (char const   */* __restrict  */)namep);
      }
#line 1031
      namep += namelen + 1U;
      {
#line 1032
      tmp___7 = grepfile((char const   *)file, & child);
      }
#line 1032
      status &= tmp___7;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1034
    out_file -= ! no_filenames;
#line 1035
    if (file) {
      {
      {
#line 1036
      free((void *)file);
      }
      }
    }
    {
    {
#line 1037
    free((void *)name_space);
    }
    }
  }
#line 1040
  return (status);
}
}
#line 1043 "grep.c"
static void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1046
  if (status != 0) {
    {
    {
#line 1048
    tmp = dcgettext((char const   *)((void *)0), "Usage: %s [OPTION]... PATTERN [FILE]...\n",
                    5);
    }
    {
#line 1048
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            program_name);
    }
    {
#line 1050
    tmp___0 = dcgettext((char const   *)((void *)0), "Try `%s --help\' for more information.\n",
                        5);
    }
    {
#line 1050
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            program_name);
    }
    }
  } else {
    {
    {
#line 1055
    tmp___1 = dcgettext((char const   *)((void *)0), "Usage: %s [OPTION]... PATTERN [FILE] ...\n",
                        5);
    }
    {
#line 1055
    printf((char const   */* __restrict  */)tmp___1, program_name);
    }
    {
#line 1056
    tmp___2 = dcgettext((char const   *)((void *)0), "Search for PATTERN in each FILE or standard input.\nExample: %s -i \'hello world\' menu.h main.c\n\nRegexp selection and interpretation:\n",
                        5);
    }
    {
#line 1056
    printf((char const   */* __restrict  */)tmp___2, program_name);
    }
    {
#line 1061
    tmp___3 = dcgettext((char const   *)((void *)0), "  -E, --extended-regexp     PATTERN is an extended regular expression\n  -F, --fixed-strings       PATTERN is a set of newline-separated strings\n  -G, --basic-regexp        PATTERN is a basic regular expression\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n",
                        5);
    }
    {
#line 1061
    printf((char const   */* __restrict  */)tmp___3);
    }
    {
#line 1066
    tmp___4 = dcgettext((char const   *)((void *)0), "  -e, --regexp=PATTERN      use PATTERN as a regular expression\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n",
                        5);
    }
    {
#line 1066
    printf((char const   */* __restrict  */)tmp___4);
    }
    {
#line 1073
    tmp___5 = dcgettext((char const   *)((void *)0), "\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             print version information and exit\n      --help                display this help and exit\n      --mmap                use memory-mapped input if possible\n",
                        5);
    }
    {
#line 1073
    printf((char const   */* __restrict  */)tmp___5);
    }
    {
#line 1081
    tmp___6 = dcgettext((char const   *)((void *)0), "\nOutput control:\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the filename for each match\n  -h, --no-filename         suppress the prefixing filename on output\n      --label=LABEL         print LABEL as filename for standard input\n  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE\n                            TYPE is \'binary\', \'text\', or \'without-match\'\n  -a, --text                equivalent to --binary-files=text\n  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories\n                            ACTION is \'read\', \'recurse\', or \'skip\'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets\n                            ACTION is \'read\' or \'skip\'\n  -R, -r, --recursive       equivalent to --directories=recurse\n      --include=PATTERN     files that match PATTERN will be examined\n      --exclude=PATTERN     files that match PATTERN will be skipped.\n      --exclude-from=FILE   files that match PATTERN in FILE will be skipped.\n  -L, --files-without-match only print FILE names containing no match\n  -l, --files-with-matches  only print FILE names containing matches\n  -c, --count               only print a count of matching lines per FILE\n  -Z, --null                print 0 byte after FILE name\n",
                        5);
    }
    {
#line 1081
    printf((char const   */* __restrict  */)tmp___6);
    }
    {
#line 1109
    tmp___7 = dcgettext((char const   *)((void *)0), "\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to distinguish the matching string\n                            WHEN may be `always\', `never\' or `auto\'.\n  -U, --binary              do not strip CR characters at EOL (MSDOS)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\n`egrep\' means `grep -E\'.  `fgrep\' means `grep -F\'.\nWith no FILE, or when FILE is -, read standard input.  If less than\ntwo FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\nand 2 if trouble.\n",
                        5);
    }
    {
#line 1109
    printf((char const   */* __restrict  */)tmp___7);
    }
    {
#line 1126
    tmp___8 = dcgettext((char const   *)((void *)0), "\nReport bugs to <bug-gnu-utils@gnu.org>.\n",
                        5);
    }
    {
#line 1126
    printf((char const   */* __restrict  */)tmp___8);
    }
    }
  }
  {
  {
#line 1128
  exit(status);
  }
  }
}
}
#line 1132 "grep.c"
static void setmatcher(char const   *m ) 
{ 
  char *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;

  {
#line 1135
  if (matcher) {
#line 1135
    if (0) {
      {
      {
#line 1135
      __s1_len = strlen(matcher);
      }
      {
#line 1135
      __s2_len = strlen(m);
      }
      }
#line 1135
      if (! ((size_t )((void const   *)(matcher + 1)) - (size_t )((void const   *)matcher) == 1U)) {
#line 1135
        goto _L___0;
      } else
#line 1135
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1135
        if (! ((size_t )((void const   *)(m + 1)) - (size_t )((void const   *)m) == 1U)) {
#line 1135
          tmp___5 = 1;
        } else
#line 1135
        if (__s2_len >= 4U) {
#line 1135
          tmp___5 = 1;
        } else {
#line 1135
          tmp___5 = 0;
        }
      } else {
#line 1135
        tmp___5 = 0;
      }
#line 1135
      if (tmp___5) {
#line 1135
        if (__s1_len < __s2_len) {
#line 1135
          tmp___1 = __s1_len;
        } else {
#line 1135
          tmp___1 = __s2_len;
        }
        {
        {
#line 1135
        tmp___2 = memcmp((void const   *)matcher, (void const   *)m, tmp___1 + 1U);
        }
#line 1135
        tmp___4 = tmp___2;
        }
      } else {
        {
        {
#line 1135
        tmp___3 = strcmp(matcher, m);
        }
#line 1135
        tmp___4 = tmp___3;
        }
      }
    } else {
      {
      {
#line 1135
      tmp___3 = strcmp(matcher, m);
      }
#line 1135
      tmp___4 = tmp___3;
      }
    }
#line 1135
    if (tmp___4 != 0) {
      {
      {
#line 1136
      tmp = dcgettext((char const   *)((void *)0), "conflicting matchers specified",
                      5);
      }
      {
#line 1136
      error(2, 0, (char const   *)tmp);
      }
      }
    }
  }
#line 1137
  matcher = m;
#line 1138
  return;
}
}
#line 1142 "grep.c"
static int install_matcher(char const   *name ) 
{ 
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1150
  i = 0;
  {
  {
#line 1150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1150
    if (! matchers[i].compile) {
#line 1150
      goto while_break;
    }
#line 1151
    if (0) {
      {
      {
#line 1151
      __s1_len = strlen(name);
      }
      {
#line 1151
      __s2_len = strlen((char const   *)(matchers[i].name));
      }
      }
#line 1151
      if (! ((size_t )((void const   *)(name + 1)) - (size_t )((void const   *)name) == 1U)) {
#line 1151
        goto _L___0;
      } else
#line 1151
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 1151
        if (! ((size_t )((void const   *)(matchers[i].name + 1)) - (size_t )((void const   *)(matchers[i].name)) == 1U)) {
#line 1151
          tmp___4 = 1;
        } else
#line 1151
        if (__s2_len >= 4U) {
#line 1151
          tmp___4 = 1;
        } else {
#line 1151
          tmp___4 = 0;
        }
      } else {
#line 1151
        tmp___4 = 0;
      }
#line 1151
      if (tmp___4) {
#line 1151
        if (__s1_len < __s2_len) {
#line 1151
          tmp___0 = __s1_len;
        } else {
#line 1151
          tmp___0 = __s2_len;
        }
        {
        {
#line 1151
        tmp___1 = memcmp((void const   *)name, (void const   *)((char const   *)(matchers[i].name)),
                         tmp___0 + 1U);
        }
#line 1151
        tmp___3 = tmp___1;
        }
      } else {
        {
        {
#line 1151
        tmp___2 = strcmp(name, (char const   *)(matchers[i].name));
        }
#line 1151
        tmp___3 = tmp___2;
        }
      }
    } else {
      {
      {
#line 1151
      tmp___2 = strcmp(name, (char const   *)(matchers[i].name));
      }
#line 1151
      tmp___3 = tmp___2;
      }
    }
#line 1151
    if (tmp___3 == 0) {
#line 1153
      compile = (void (*)(char const   * , size_t  ))matchers[i].compile;
#line 1154
      execute = (size_t (*)(char const   * , size_t  , size_t * , int  ))matchers[i].execute;
#line 1181
      return (1);
    }
#line 1150
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1183
  return (0);
}
}
#line 1191 "grep.c"
static int prepend_args(char const   *options , char *buf , char **argv ) 
{ 
  char const   *o ;
  char *b ;
  int n ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
#line 1194
  o = options;
#line 1195
  b = buf;
#line 1196
  n = 0;
  {
  {
#line 1198
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1200
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 1200
      tmp = __ctype_b_loc();
      }
      }
#line 1200
      if (! ((int const   )*(*tmp + (int )((unsigned char )*o)) & 8192)) {
#line 1200
        goto while_break___0;
      }
#line 1201
      o ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1202
    if (! *o) {
#line 1203
      return (n);
    }
#line 1204
    if (argv) {
#line 1205
      *(argv + n) = b;
    }
#line 1206
    n ++;
    {
    {
#line 1208
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1209
      tmp___1 = b;
#line 1209
      b ++;
#line 1209
      tmp___3 = o;
#line 1209
      o ++;
#line 1209
      tmp___2 = (char )*tmp___3;
#line 1209
      *tmp___1 = tmp___2;
#line 1209
      if ((int )tmp___2 == 92) {
#line 1209
        if (*o) {
#line 1210
          tmp___0 = o;
#line 1210
          o ++;
#line 1210
          *(b + -1) = (char )*tmp___0;
        }
      }
#line 1208
      if (*o) {
        {
        {
#line 1208
        tmp___4 = __ctype_b_loc();
        }
        }
#line 1208
        if ((int const   )*(*tmp___4 + (int )((unsigned char )*o)) & 8192) {
#line 1208
          goto while_break___1;
        }
      } else {
#line 1208
        goto while_break___1;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1213
    tmp___5 = b;
#line 1213
    b ++;
#line 1213
    *tmp___5 = (char )'\000';
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1220 "grep.c"
static void prepend_default_options(char const   *options , int *pargc , char ***pargv ) 
{ 
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  int prepended ;
  int tmp___1 ;
  int argc ;
  char * const  *argv ;
  char **pp ;
  void *tmp___2 ;
  char **tmp___3 ;
  char * const  *tmp___4 ;
  int tmp___5 ;
  char **tmp___6 ;
  char *tmp___7 ;
  char * const  *tmp___8 ;

  {
#line 1223
  if (options) {
    {
    {
#line 1225
    tmp = strlen(options);
    }
    {
#line 1225
    tmp___0 = xmalloc(tmp + 1U);
    }
#line 1225
    buf = (char *)tmp___0;
    {
#line 1226
    tmp___1 = prepend_args(options, buf, (char **)((void *)0));
    }
#line 1226
    prepended = tmp___1;
#line 1227
    argc = *pargc;
#line 1228
    argv = (char * const  *)*pargv;
    {
#line 1229
    tmp___2 = xmalloc((size_t )((unsigned long )((prepended + argc) + 1) * sizeof(*pp)));
    }
#line 1229
    pp = (char **)tmp___2;
#line 1230
    *pargc = prepended + argc;
#line 1231
    *pargv = pp;
#line 1232
    tmp___3 = pp;
#line 1232
    pp ++;
#line 1232
    tmp___4 = argv;
#line 1232
    argv ++;
#line 1232
    *tmp___3 = (char *)*tmp___4;
    {
#line 1233
    tmp___5 = prepend_args(options, buf, pp);
    }
#line 1233
    pp += tmp___5;
    }
    {
    {
#line 1234
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1234
      tmp___6 = pp;
#line 1234
      pp ++;
#line 1234
      tmp___8 = argv;
#line 1234
      argv ++;
#line 1234
      tmp___7 = (char *)*tmp___8;
#line 1234
      *tmp___6 = tmp___7;
#line 1234
      if (! tmp___7) {
#line 1234
        goto while_break;
      }
#line 1235
      goto while_continue;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1237
  return;
}
}
#line 1243 "grep.c"
static int get_nondigit_option(int argc , char * const  *argv , int *default_context ) 
{ 
  int opt ;
  char buf[sizeof(uintmax_t ) * 8UL + 4UL] ;
  char *p ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1248
  p = buf;
#line 1251
  buf[0] = (char )'\000';
  {
  {
#line 1253
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1253
    opt = getopt_long(argc, argv, short_options, long_options, (int *)((void *)0));
    }
    }
#line 1253
    if (48 <= opt) {
#line 1253
      if (opt <= 57) {
#line 1253
        tmp___0 = 1;
      } else {
#line 1253
        tmp___0 = 0;
      }
    } else {
#line 1253
      tmp___0 = 0;
    }
#line 1253
    if (! tmp___0) {
#line 1253
      goto while_break;
    }
#line 1258
    p -= (int )buf[0] == 48;
#line 1260
    tmp = p;
#line 1260
    p ++;
#line 1260
    *tmp = (char )opt;
#line 1261
    if ((unsigned long )p == (unsigned long )((buf + sizeof(buf)) - 4)) {
      {
      {
#line 1266
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"...");
      }
#line 1267
      p += 3;
      }
#line 1268
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  if ((unsigned long )p != (unsigned long )(buf)) {
    {
#line 1273
    *p = (char )'\000';
    {
#line 1274
    context_length_arg((char const   *)(buf), default_context);
    }
    }
  }
#line 1277
  return (opt);
}
}
#line 1280 "grep.c"
int main(int argc , char **argv ) 
{ 
  char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int with_filenames ;
  int opt ;
  int cc ;
  int status ;
  int default_context ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  size_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  size_t tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  size_t tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t tmp___46 ;
  void *tmp___47 ;
  size_t tmp___48 ;
  FILE *tmp___55 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  size_t tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int *tmp___62 ;
  void *tmp___63 ;
  void *tmp___64 ;
  int tmp___65 ;
  size_t tmp___66 ;
  size_t tmp___67 ;
  uintmax_t value ;
  strtol_error tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  size_t tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  size_t tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  size_t tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  char *tmp___99 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  size_t tmp___105 ;
  char *tmp___106 ;
  int tmp___107 ;
  char *tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  char *tmp___132 ;
  char *tmp___133 ;
  char *tmp___134 ;
  int tmp___135 ;
  int *tmp___136 ;
  int tmp___137 ;
  char *userval ;
  char *tmp___138 ;
  char *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  char *file ;
  int tmp___145 ;
  int tmp___146 ;
  int tmp___147 ;
  char *tmp___154 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  size_t tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;

  {
#line 1293
  program_name = *(argv + 0);
#line 1294
  if (program_name) {
    {
    {
#line 1294
    tmp___0 = strrchr((char const   *)program_name, '/');
    }
    }
#line 1294
    if (tmp___0) {
      {
      {
#line 1295
      tmp = strrchr((char const   *)program_name, '/');
      }
#line 1295
      program_name = tmp + 1;
      }
    }
  }
#line 1297
  if (0) {
    {
    {
#line 1297
    __s1_len = strlen((char const   *)program_name);
    }
    {
#line 1297
    __s2_len = strlen("egrep");
    }
    }
#line 1297
    if (! ((size_t )((void const   *)(program_name + 1)) - (size_t )((void const   *)program_name) == 1U)) {
#line 1297
      goto _L___0;
    } else
#line 1297
    if (__s1_len >= 4U) {
      _L___0: /* CIL Label */ 
#line 1297
      if (! ((size_t )((void const   *)("egrep" + 1)) - (size_t )((void const   *)"egrep") == 1U)) {
#line 1297
        tmp___6 = 1;
      } else
#line 1297
      if (__s2_len >= 4U) {
#line 1297
        tmp___6 = 1;
      } else {
#line 1297
        tmp___6 = 0;
      }
    } else {
#line 1297
      tmp___6 = 0;
    }
#line 1297
    if (tmp___6) {
#line 1297
      if (__s1_len < __s2_len) {
#line 1297
        tmp___2 = __s1_len;
      } else {
#line 1297
        tmp___2 = __s2_len;
      }
      {
      {
#line 1297
      tmp___3 = memcmp((void const   *)((char const   *)program_name), (void const   *)"egrep",
                       tmp___2 + 1U);
      }
#line 1297
      tmp___5 = tmp___3;
      }
    } else {
      {
      {
#line 1297
      tmp___4 = strcmp((char const   *)program_name, "egrep");
      }
#line 1297
      tmp___5 = tmp___4;
      }
    }
  } else {
    {
    {
#line 1297
    tmp___4 = strcmp((char const   *)program_name, "egrep");
    }
#line 1297
    tmp___5 = tmp___4;
    }
  }
#line 1297
  if (! tmp___5) {
    {
    {
#line 1298
    setmatcher("egrep");
    }
    }
  }
#line 1299
  if (0) {
    {
    {
#line 1299
    __s1_len___0 = strlen((char const   *)program_name);
    }
    {
#line 1299
    __s2_len___0 = strlen("fgrep");
    }
    }
#line 1299
    if (! ((size_t )((void const   *)(program_name + 1)) - (size_t )((void const   *)program_name) == 1U)) {
#line 1299
      goto _L___2;
    } else
#line 1299
    if (__s1_len___0 >= 4U) {
      _L___2: /* CIL Label */ 
#line 1299
      if (! ((size_t )((void const   *)("fgrep" + 1)) - (size_t )((void const   *)"fgrep") == 1U)) {
#line 1299
        tmp___12 = 1;
      } else
#line 1299
      if (__s2_len___0 >= 4U) {
#line 1299
        tmp___12 = 1;
      } else {
#line 1299
        tmp___12 = 0;
      }
    } else {
#line 1299
      tmp___12 = 0;
    }
#line 1299
    if (tmp___12) {
#line 1299
      if (__s1_len___0 < __s2_len___0) {
#line 1299
        tmp___8 = __s1_len___0;
      } else {
#line 1299
        tmp___8 = __s2_len___0;
      }
      {
      {
#line 1299
      tmp___9 = memcmp((void const   *)((char const   *)program_name), (void const   *)"fgrep",
                       tmp___8 + 1U);
      }
#line 1299
      tmp___11 = tmp___9;
      }
    } else {
      {
      {
#line 1299
      tmp___10 = strcmp((char const   *)program_name, "fgrep");
      }
#line 1299
      tmp___11 = tmp___10;
      }
    }
  } else {
    {
    {
#line 1299
    tmp___10 = strcmp((char const   *)program_name, "fgrep");
    }
#line 1299
    tmp___11 = tmp___10;
    }
  }
#line 1299
  if (! tmp___11) {
    {
    {
#line 1300
    setmatcher("fgrep");
    }
    }
  }
  {
#line 1327
  keys = (char *)((void *)0);
#line 1328
  keycc = (size_t )0;
#line 1329
  with_filenames = 0;
#line 1330
  eolbyte = (unsigned char )'\n';
#line 1331
  filename_mask = ~ 0;
#line 1333
  max_count = -1LL - (-1LL << (sizeof(off_t ) * 8UL - 1UL));
#line 1336
  out_before = -1;
#line 1336
  out_after = out_before;
#line 1338
  default_context = 0;
#line 1340
  only_matching = 0;
  {
#line 1344
  setlocale(6, "");
  }
  {
#line 1347
  bindtextdomain("grep", "/usr/local/share/locale");
  }
  {
#line 1348
  textdomain("grep");
  }
  {
#line 1351
  atexit(& close_stdout);
  }
  {
#line 1353
  tmp___13 = getenv("GREP_OPTIONS");
  }
  {
#line 1353
  prepend_default_options((char const   *)tmp___13, & argc, & argv);
  }
  }
  {
  {
#line 1355
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1355
    opt = get_nondigit_option(argc, (char * const  *)argv, & default_context);
    }
    }
#line 1355
    if (! (opt != -1)) {
#line 1355
      goto while_break;
    }
    {
#line 1358
    if (opt == 65) {
#line 1358
      goto case_65;
    }
#line 1362
    if (opt == 66) {
#line 1362
      goto case_66;
    }
#line 1366
    if (opt == 67) {
#line 1366
      goto case_67;
    }
#line 1372
    if (opt == 68) {
#line 1372
      goto case_68;
    }
#line 1381
    if (opt == 69) {
#line 1381
      goto case_69;
    }
#line 1385
    if (opt == 70) {
#line 1385
      goto case_70;
    }
#line 1389
    if (opt == 80) {
#line 1389
      goto case_80;
    }
#line 1393
    if (opt == 71) {
#line 1393
      goto case_71;
    }
#line 1397
    if (opt == 72) {
#line 1397
      goto case_72;
    }
#line 1401
    if (opt == 73) {
#line 1401
      goto case_73;
    }
#line 1405
    if (opt == 85) {
#line 1405
      goto case_85;
    }
#line 1411
    if (opt == 117) {
#line 1411
      goto case_117;
    }
#line 1417
    if (opt == 86) {
#line 1417
      goto case_86;
    }
#line 1421
    if (opt == 88) {
#line 1421
      goto case_88;
    }
#line 1425
    if (opt == 97) {
#line 1425
      goto case_97;
    }
#line 1429
    if (opt == 98) {
#line 1429
      goto case_98;
    }
#line 1433
    if (opt == 99) {
#line 1433
      goto case_99;
    }
#line 1437
    if (opt == 100) {
#line 1437
      goto case_100;
    }
#line 1448
    if (opt == 101) {
#line 1448
      goto case_101;
    }
#line 1456
    if (opt == 102) {
#line 1456
      goto case_102;
    }
#line 1478
    if (opt == 104) {
#line 1478
      goto case_104;
    }
#line 1483
    if (opt == 121) {
#line 1483
      goto case_121;
    }
#line 1483
    if (opt == 105) {
#line 1483
      goto case_121;
    }
#line 1487
    if (opt == 76) {
#line 1487
      goto case_76;
    }
#line 1493
    if (opt == 108) {
#line 1493
      goto case_108;
    }
#line 1497
    if (opt == 109) {
#line 1497
      goto case_109;
    }
#line 1517
    if (opt == 110) {
#line 1517
      goto case_110;
    }
#line 1521
    if (opt == 111) {
#line 1521
      goto case_111;
    }
#line 1525
    if (opt == 113) {
#line 1525
      goto case_113;
    }
#line 1531
    if (opt == 114) {
#line 1531
      goto case_114;
    }
#line 1531
    if (opt == 82) {
#line 1531
      goto case_114;
    }
#line 1535
    if (opt == 115) {
#line 1535
      goto case_115;
    }
#line 1539
    if (opt == 118) {
#line 1539
      goto case_118;
    }
#line 1543
    if (opt == 119) {
#line 1543
      goto case_119;
    }
#line 1547
    if (opt == 120) {
#line 1547
      goto case_120;
    }
#line 1551
    if (opt == 90) {
#line 1551
      goto case_90;
    }
#line 1555
    if (opt == 122) {
#line 1555
      goto case_122;
    }
#line 1559
    if (opt == 128) {
#line 1559
      goto case_128;
    }
#line 1570
    if (opt == 129) {
#line 1570
      goto case_129;
    }
#line 1594
    if (opt == 131) {
#line 1594
      goto case_131;
    }
#line 1600
    if (opt == 132) {
#line 1600
      goto case_132;
    }
#line 1610
    if (opt == 130) {
#line 1610
      goto case_130;
    }
#line 1616
    if (opt == 133) {
#line 1616
      goto case_133;
    }
#line 1620
    if (opt == 134) {
#line 1620
      goto case_134;
    }
#line 1624
    if (opt == 0) {
#line 1624
      goto case_0___0;
    }
#line 1628
    goto switch_default___0;
    case_65: /* CIL Label */ 
    {
    {
#line 1359
    context_length_arg((char const   *)optarg, & out_after);
    }
    }
#line 1360
    goto switch_break;
    case_66: /* CIL Label */ 
    {
    {
#line 1363
    context_length_arg((char const   *)optarg, & out_before);
    }
    }
#line 1364
    goto switch_break;
    case_67: /* CIL Label */ 
    {
    {
#line 1369
    context_length_arg((char const   *)optarg, & default_context);
    }
    }
#line 1370
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1373
    if (0) {
      {
      {
#line 1373
      __s1_len___2 = strlen((char const   *)optarg);
      }
      {
#line 1373
      __s2_len___2 = strlen("read");
      }
      }
#line 1373
      if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1373
        goto _L___6;
      } else
#line 1373
      if (__s1_len___2 >= 4U) {
        _L___6: /* CIL Label */ 
#line 1373
        if (! ((size_t )((void const   *)("read" + 1)) - (size_t )((void const   *)"read") == 1U)) {
#line 1373
          tmp___26 = 1;
        } else
#line 1373
        if (__s2_len___2 >= 4U) {
#line 1373
          tmp___26 = 1;
        } else {
#line 1373
          tmp___26 = 0;
        }
      } else {
#line 1373
        tmp___26 = 0;
      }
#line 1373
      if (tmp___26) {
#line 1373
        if (__s1_len___2 < __s2_len___2) {
#line 1373
          tmp___22 = __s1_len___2;
        } else {
#line 1373
          tmp___22 = __s2_len___2;
        }
        {
        {
#line 1373
        tmp___23 = memcmp((void const   *)((char const   *)optarg), (void const   *)"read",
                          tmp___22 + 1U);
        }
#line 1373
        tmp___25 = tmp___23;
        }
      } else {
        {
        {
#line 1373
        tmp___24 = strcmp((char const   *)optarg, "read");
        }
#line 1373
        tmp___25 = tmp___24;
        }
      }
    } else {
      {
      {
#line 1373
      tmp___24 = strcmp((char const   *)optarg, "read");
      }
#line 1373
      tmp___25 = tmp___24;
      }
    }
#line 1373
    if (tmp___25 == 0) {
#line 1374
      devices = (enum __anonenum_devices_26 )0;
    } else {
#line 1375
      if (0) {
        {
        {
#line 1375
        __s1_len___1 = strlen((char const   *)optarg);
        }
        {
#line 1375
        __s2_len___1 = strlen("skip");
        }
        }
#line 1375
        if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1375
          goto _L___4;
        } else
#line 1375
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 1375
          if (! ((size_t )((void const   *)("skip" + 1)) - (size_t )((void const   *)"skip") == 1U)) {
#line 1375
            tmp___20 = 1;
          } else
#line 1375
          if (__s2_len___1 >= 4U) {
#line 1375
            tmp___20 = 1;
          } else {
#line 1375
            tmp___20 = 0;
          }
        } else {
#line 1375
          tmp___20 = 0;
        }
#line 1375
        if (tmp___20) {
#line 1375
          if (__s1_len___1 < __s2_len___1) {
#line 1375
            tmp___16 = __s1_len___1;
          } else {
#line 1375
            tmp___16 = __s2_len___1;
          }
          {
          {
#line 1375
          tmp___17 = memcmp((void const   *)((char const   *)optarg), (void const   *)"skip",
                            tmp___16 + 1U);
          }
#line 1375
          tmp___19 = tmp___17;
          }
        } else {
          {
          {
#line 1375
          tmp___18 = strcmp((char const   *)optarg, "skip");
          }
#line 1375
          tmp___19 = tmp___18;
          }
        }
      } else {
        {
        {
#line 1375
        tmp___18 = strcmp((char const   *)optarg, "skip");
        }
#line 1375
        tmp___19 = tmp___18;
        }
      }
#line 1375
      if (tmp___19 == 0) {
#line 1376
        devices = (enum __anonenum_devices_26 )1;
      } else {
        {
        {
#line 1378
        tmp___14 = dcgettext((char const   *)((void *)0), "unknown devices method",
                             5);
        }
        {
#line 1378
        error(2, 0, (char const   *)tmp___14);
        }
        }
      }
    }
#line 1379
    goto switch_break;
    case_69: /* CIL Label */ 
    {
    {
#line 1382
    setmatcher("egrep");
    }
    }
#line 1383
    goto switch_break;
    case_70: /* CIL Label */ 
    {
    {
#line 1386
    setmatcher("fgrep");
    }
    }
#line 1387
    goto switch_break;
    case_80: /* CIL Label */ 
    {
    {
#line 1390
    setmatcher("perl");
    }
    }
#line 1391
    goto switch_break;
    case_71: /* CIL Label */ 
    {
    {
#line 1394
    setmatcher("grep");
    }
    }
#line 1395
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1398
    with_filenames = 1;
#line 1399
    goto switch_break;
    case_73: /* CIL Label */ 
#line 1402
    binary_files = (enum __anonenum_binary_files_27 )2;
#line 1403
    goto switch_break;
    case_85: /* CIL Label */ 
#line 1409
    goto switch_break;
    case_117: /* CIL Label */ 
#line 1415
    goto switch_break;
    case_86: /* CIL Label */ 
#line 1418
    show_version = 1;
#line 1419
    goto switch_break;
    case_88: /* CIL Label */ 
    {
    {
#line 1422
    setmatcher((char const   *)optarg);
    }
    }
#line 1423
    goto switch_break;
    case_97: /* CIL Label */ 
#line 1426
    binary_files = (enum __anonenum_binary_files_27 )1;
#line 1427
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1430
    out_byte = 1;
#line 1431
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1434
    count_matches = 1;
#line 1435
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1438
    if (0) {
      {
      {
#line 1438
      __s1_len___5 = strlen((char const   *)optarg);
      }
      {
#line 1438
      __s2_len___5 = strlen("read");
      }
      }
#line 1438
      if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1438
        goto _L___12;
      } else
#line 1438
      if (__s1_len___5 >= 4U) {
        _L___12: /* CIL Label */ 
#line 1438
        if (! ((size_t )((void const   *)("read" + 1)) - (size_t )((void const   *)"read") == 1U)) {
#line 1438
          tmp___45 = 1;
        } else
#line 1438
        if (__s2_len___5 >= 4U) {
#line 1438
          tmp___45 = 1;
        } else {
#line 1438
          tmp___45 = 0;
        }
      } else {
#line 1438
        tmp___45 = 0;
      }
#line 1438
      if (tmp___45) {
#line 1438
        if (__s1_len___5 < __s2_len___5) {
#line 1438
          tmp___41 = __s1_len___5;
        } else {
#line 1438
          tmp___41 = __s2_len___5;
        }
        {
        {
#line 1438
        tmp___42 = memcmp((void const   *)((char const   *)optarg), (void const   *)"read",
                          tmp___41 + 1U);
        }
#line 1438
        tmp___44 = tmp___42;
        }
      } else {
        {
        {
#line 1438
        tmp___43 = strcmp((char const   *)optarg, "read");
        }
#line 1438
        tmp___44 = tmp___43;
        }
      }
    } else {
      {
      {
#line 1438
      tmp___43 = strcmp((char const   *)optarg, "read");
      }
#line 1438
      tmp___44 = tmp___43;
      }
    }
#line 1438
    if (tmp___44 == 0) {
#line 1439
      directories = (enum __anonenum_directories_25 )0;
    } else {
#line 1440
      if (0) {
        {
        {
#line 1440
        __s1_len___4 = strlen((char const   *)optarg);
        }
        {
#line 1440
        __s2_len___4 = strlen("skip");
        }
        }
#line 1440
        if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1440
          goto _L___10;
        } else
#line 1440
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 1440
          if (! ((size_t )((void const   *)("skip" + 1)) - (size_t )((void const   *)"skip") == 1U)) {
#line 1440
            tmp___39 = 1;
          } else
#line 1440
          if (__s2_len___4 >= 4U) {
#line 1440
            tmp___39 = 1;
          } else {
#line 1440
            tmp___39 = 0;
          }
        } else {
#line 1440
          tmp___39 = 0;
        }
#line 1440
        if (tmp___39) {
#line 1440
          if (__s1_len___4 < __s2_len___4) {
#line 1440
            tmp___35 = __s1_len___4;
          } else {
#line 1440
            tmp___35 = __s2_len___4;
          }
          {
          {
#line 1440
          tmp___36 = memcmp((void const   *)((char const   *)optarg), (void const   *)"skip",
                            tmp___35 + 1U);
          }
#line 1440
          tmp___38 = tmp___36;
          }
        } else {
          {
          {
#line 1440
          tmp___37 = strcmp((char const   *)optarg, "skip");
          }
#line 1440
          tmp___38 = tmp___37;
          }
        }
      } else {
        {
        {
#line 1440
        tmp___37 = strcmp((char const   *)optarg, "skip");
        }
#line 1440
        tmp___38 = tmp___37;
        }
      }
#line 1440
      if (tmp___38 == 0) {
#line 1441
        directories = (enum __anonenum_directories_25 )2;
      } else {
#line 1442
        if (0) {
          {
          {
#line 1442
          __s1_len___3 = strlen((char const   *)optarg);
          }
          {
#line 1442
          __s2_len___3 = strlen("recurse");
          }
          }
#line 1442
          if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1442
            goto _L___8;
          } else
#line 1442
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 1442
            if (! ((size_t )((void const   *)("recurse" + 1)) - (size_t )((void const   *)"recurse") == 1U)) {
#line 1442
              tmp___33 = 1;
            } else
#line 1442
            if (__s2_len___3 >= 4U) {
#line 1442
              tmp___33 = 1;
            } else {
#line 1442
              tmp___33 = 0;
            }
          } else {
#line 1442
            tmp___33 = 0;
          }
#line 1442
          if (tmp___33) {
#line 1442
            if (__s1_len___3 < __s2_len___3) {
#line 1442
              tmp___29 = __s1_len___3;
            } else {
#line 1442
              tmp___29 = __s2_len___3;
            }
            {
            {
#line 1442
            tmp___30 = memcmp((void const   *)((char const   *)optarg), (void const   *)"recurse",
                              tmp___29 + 1U);
            }
#line 1442
            tmp___32 = tmp___30;
            }
          } else {
            {
            {
#line 1442
            tmp___31 = strcmp((char const   *)optarg, "recurse");
            }
#line 1442
            tmp___32 = tmp___31;
            }
          }
        } else {
          {
          {
#line 1442
          tmp___31 = strcmp((char const   *)optarg, "recurse");
          }
#line 1442
          tmp___32 = tmp___31;
          }
        }
#line 1442
        if (tmp___32 == 0) {
#line 1443
          directories = (enum __anonenum_directories_25 )1;
        } else {
          {
          {
#line 1445
          tmp___27 = dcgettext((char const   *)((void *)0), "unknown directories method",
                               5);
          }
          {
#line 1445
          error(2, 0, (char const   *)tmp___27);
          }
          }
        }
      }
    }
#line 1446
    goto switch_break;
    case_101: /* CIL Label */ 
    {
    {
#line 1449
    tmp___46 = strlen((char const   *)optarg);
    }
#line 1449
    cc = (int )tmp___46;
    {
#line 1450
    tmp___47 = xrealloc((void *)keys, (keycc + (size_t )cc) + 1U);
    }
#line 1450
    keys = (char *)tmp___47;
    {
#line 1451
    strcpy((char */* __restrict  */)(keys + keycc), (char const   */* __restrict  */)optarg);
    }
#line 1452
    keycc += (size_t )cc;
#line 1453
    tmp___48 = keycc;
#line 1453
    keycc ++;
#line 1453
    *(keys + tmp___48) = (char )'\n';
    }
#line 1454
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1457
    if (0) {
      {
      {
#line 1457
      __s1_len___7 = strlen((char const   *)optarg);
      }
      {
#line 1457
      __s2_len___7 = strlen("-");
      }
      }
#line 1457
      if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1457
        goto _L___16;
      } else
#line 1457
      if (__s1_len___7 >= 4U) {
        _L___16: /* CIL Label */ 
#line 1457
        if (! ((size_t )((void const   *)("-" + 1)) - (size_t )((void const   *)"-") == 1U)) {
#line 1457
          tmp___61 = 1;
        } else
#line 1457
        if (__s2_len___7 >= 4U) {
#line 1457
          tmp___61 = 1;
        } else {
#line 1457
          tmp___61 = 0;
        }
      } else {
#line 1457
        tmp___61 = 0;
      }
#line 1457
      if (tmp___61) {
#line 1457
        if (__s1_len___7 < __s2_len___7) {
#line 1457
          tmp___57 = __s1_len___7;
        } else {
#line 1457
          tmp___57 = __s2_len___7;
        }
        {
        {
#line 1457
        tmp___58 = memcmp((void const   *)((char const   *)optarg), (void const   *)"-",
                          tmp___57 + 1U);
        }
#line 1457
        tmp___60 = tmp___58;
        }
      } else {
        {
        {
#line 1457
        tmp___59 = strcmp((char const   *)optarg, "-");
        }
#line 1457
        tmp___60 = tmp___59;
        }
      }
    } else {
      {
      {
#line 1457
      tmp___59 = strcmp((char const   *)optarg, "-");
      }
#line 1457
      tmp___60 = tmp___59;
      }
    }
#line 1457
    if (tmp___60 != 0) {
      {
      {
#line 1457
      tmp___55 = fopen((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"r");
      }
#line 1457
      fp = tmp___55;
      }
    } else {
#line 1457
      fp = stdin;
    }
#line 1458
    if (! fp) {
      {
      {
#line 1459
      tmp___62 = __errno_location();
      }
      {
#line 1459
      error(2, *tmp___62, "%s", optarg);
      }
      }
    }
#line 1460
    keyalloc = (size_t )1;
    {
    {
#line 1460
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1460
      if (! (keyalloc <= keycc + 1U)) {
#line 1460
        goto while_break___0;
      }
#line 1460
      keyalloc *= 2U;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1462
    tmp___63 = xrealloc((void *)keys, keyalloc);
    }
#line 1462
    keys = (char *)tmp___63;
#line 1463
    oldcc = keycc;
    }
    {
    {
#line 1464
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 1464
      tmp___65 = feof(fp);
      }
      }
#line 1464
      if (tmp___65) {
#line 1464
        goto while_break___1;
      } else {
        {
        {
#line 1464
        tmp___66 = fread((void */* __restrict  */)(keys + keycc), (size_t )1, (keyalloc - 1U) - keycc,
                         (FILE */* __restrict  */)fp);
        }
#line 1464
        cc = (int )tmp___66;
        }
#line 1464
        if (! (cc > 0)) {
#line 1464
          goto while_break___1;
        }
      }
#line 1467
      keycc += (size_t )cc;
#line 1468
      if (keycc == keyalloc - 1U) {
        {
#line 1469
        keyalloc *= 2U;
        {
#line 1469
        tmp___64 = xrealloc((void *)keys, keyalloc);
        }
#line 1469
        keys = (char *)tmp___64;
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1471
    if ((unsigned long )fp != (unsigned long )stdin) {
      {
      {
#line 1472
      fclose(fp);
      }
      }
    }
#line 1474
    if (oldcc != keycc) {
#line 1474
      if ((int )*(keys + (keycc - 1U)) != 10) {
#line 1475
        tmp___67 = keycc;
#line 1475
        keycc ++;
#line 1475
        *(keys + tmp___67) = (char )'\n';
      }
    }
#line 1476
    goto switch_break;
    case_104: /* CIL Label */ 
#line 1479
    no_filenames = 1;
#line 1480
    goto switch_break;
    case_121: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 1484
    match_icase = 1;
#line 1485
    goto switch_break;
    case_76: /* CIL Label */ 
#line 1490
    list_files = -1;
#line 1491
    goto switch_break;
    case_108: /* CIL Label */ 
#line 1494
    list_files = 1;
#line 1495
    goto switch_break;
    case_109: /* CIL Label */ 
    {
    {
#line 1500
    tmp___68 = xstrtoumax((char const   *)optarg, (char **)0, 10, & value, "");
    }
    }
    {
#line 1502
    if ((unsigned int )tmp___68 == 0U) {
#line 1502
      goto case_0;
    }
#line 1507
    if ((unsigned int )tmp___68 == 3U) {
#line 1507
      goto case_3;
    }
#line 1511
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1503
    max_count = (off_t )value;
#line 1504
    if (0LL <= max_count) {
#line 1504
      if ((uintmax_t )max_count == value) {
#line 1505
        goto switch_break___0;
      }
    }
    case_3: /* CIL Label */ 
#line 1508
    max_count = -1LL - (-1LL << (sizeof(off_t ) * 8UL - 1UL));
#line 1509
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
    {
#line 1512
    tmp___69 = dcgettext((char const   *)((void *)0), "invalid max count", 5);
    }
    {
#line 1512
    error(2, 0, (char const   *)tmp___69);
    }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1515
    goto switch_break;
    case_110: /* CIL Label */ 
#line 1518
    out_line = 1;
#line 1519
    goto switch_break;
    case_111: /* CIL Label */ 
#line 1522
    only_matching = 1;
#line 1523
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 1526
    exit_on_match = 1;
    {
#line 1527
    close_stdout_set_status(0);
    }
    }
#line 1528
    goto switch_break;
    case_114: /* CIL Label */ 
    case_82: /* CIL Label */ 
#line 1532
    directories = (enum __anonenum_directories_25 )1;
#line 1533
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1536
    suppress_errors = 1;
#line 1537
    goto switch_break;
    case_118: /* CIL Label */ 
#line 1540
    out_invert = 1;
#line 1541
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1544
    match_words = 1;
#line 1545
    goto switch_break;
    case_120: /* CIL Label */ 
#line 1548
    match_lines = 1;
#line 1549
    goto switch_break;
    case_90: /* CIL Label */ 
#line 1552
    filename_mask = 0;
#line 1553
    goto switch_break;
    case_122: /* CIL Label */ 
#line 1556
    eolbyte = (unsigned char )'\000';
#line 1557
    goto switch_break;
    case_128: /* CIL Label */ 
#line 1560
    if (0) {
      {
      {
#line 1560
      __s1_len___10 = strlen((char const   *)optarg);
      }
      {
#line 1560
      __s2_len___10 = strlen("binary");
      }
      }
#line 1560
      if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1560
        goto _L___22;
      } else
#line 1560
      if (__s1_len___10 >= 4U) {
        _L___22: /* CIL Label */ 
#line 1560
        if (! ((size_t )((void const   *)("binary" + 1)) - (size_t )((void const   *)"binary") == 1U)) {
#line 1560
          tmp___88 = 1;
        } else
#line 1560
        if (__s2_len___10 >= 4U) {
#line 1560
          tmp___88 = 1;
        } else {
#line 1560
          tmp___88 = 0;
        }
      } else {
#line 1560
        tmp___88 = 0;
      }
#line 1560
      if (tmp___88) {
#line 1560
        if (__s1_len___10 < __s2_len___10) {
#line 1560
          tmp___84 = __s1_len___10;
        } else {
#line 1560
          tmp___84 = __s2_len___10;
        }
        {
        {
#line 1560
        tmp___85 = memcmp((void const   *)((char const   *)optarg), (void const   *)"binary",
                          tmp___84 + 1U);
        }
#line 1560
        tmp___87 = tmp___85;
        }
      } else {
        {
        {
#line 1560
        tmp___86 = strcmp((char const   *)optarg, "binary");
        }
#line 1560
        tmp___87 = tmp___86;
        }
      }
    } else {
      {
      {
#line 1560
      tmp___86 = strcmp((char const   *)optarg, "binary");
      }
#line 1560
      tmp___87 = tmp___86;
      }
    }
#line 1560
    if (tmp___87 == 0) {
#line 1561
      binary_files = (enum __anonenum_binary_files_27 )0;
    } else {
#line 1562
      if (0) {
        {
        {
#line 1562
        __s1_len___9 = strlen((char const   *)optarg);
        }
        {
#line 1562
        __s2_len___9 = strlen("text");
        }
        }
#line 1562
        if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1562
          goto _L___20;
        } else
#line 1562
        if (__s1_len___9 >= 4U) {
          _L___20: /* CIL Label */ 
#line 1562
          if (! ((size_t )((void const   *)("text" + 1)) - (size_t )((void const   *)"text") == 1U)) {
#line 1562
            tmp___82 = 1;
          } else
#line 1562
          if (__s2_len___9 >= 4U) {
#line 1562
            tmp___82 = 1;
          } else {
#line 1562
            tmp___82 = 0;
          }
        } else {
#line 1562
          tmp___82 = 0;
        }
#line 1562
        if (tmp___82) {
#line 1562
          if (__s1_len___9 < __s2_len___9) {
#line 1562
            tmp___78 = __s1_len___9;
          } else {
#line 1562
            tmp___78 = __s2_len___9;
          }
          {
          {
#line 1562
          tmp___79 = memcmp((void const   *)((char const   *)optarg), (void const   *)"text",
                            tmp___78 + 1U);
          }
#line 1562
          tmp___81 = tmp___79;
          }
        } else {
          {
          {
#line 1562
          tmp___80 = strcmp((char const   *)optarg, "text");
          }
#line 1562
          tmp___81 = tmp___80;
          }
        }
      } else {
        {
        {
#line 1562
        tmp___80 = strcmp((char const   *)optarg, "text");
        }
#line 1562
        tmp___81 = tmp___80;
        }
      }
#line 1562
      if (tmp___81 == 0) {
#line 1563
        binary_files = (enum __anonenum_binary_files_27 )1;
      } else {
#line 1564
        if (0) {
          {
          {
#line 1564
          __s1_len___8 = strlen((char const   *)optarg);
          }
          {
#line 1564
          __s2_len___8 = strlen("without-match");
          }
          }
#line 1564
          if (! ((size_t )((void const   *)(optarg + 1)) - (size_t )((void const   *)optarg) == 1U)) {
#line 1564
            goto _L___18;
          } else
#line 1564
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 1564
            if (! ((size_t )((void const   *)("without-match" + 1)) - (size_t )((void const   *)"without-match") == 1U)) {
#line 1564
              tmp___76 = 1;
            } else
#line 1564
            if (__s2_len___8 >= 4U) {
#line 1564
              tmp___76 = 1;
            } else {
#line 1564
              tmp___76 = 0;
            }
          } else {
#line 1564
            tmp___76 = 0;
          }
#line 1564
          if (tmp___76) {
#line 1564
            if (__s1_len___8 < __s2_len___8) {
#line 1564
              tmp___72 = __s1_len___8;
            } else {
#line 1564
              tmp___72 = __s2_len___8;
            }
            {
            {
#line 1564
            tmp___73 = memcmp((void const   *)((char const   *)optarg), (void const   *)"without-match",
                              tmp___72 + 1U);
            }
#line 1564
            tmp___75 = tmp___73;
            }
          } else {
            {
            {
#line 1564
            tmp___74 = strcmp((char const   *)optarg, "without-match");
            }
#line 1564
            tmp___75 = tmp___74;
            }
          }
        } else {
          {
          {
#line 1564
          tmp___74 = strcmp((char const   *)optarg, "without-match");
          }
#line 1564
          tmp___75 = tmp___74;
          }
        }
#line 1564
        if (tmp___75 == 0) {
#line 1565
          binary_files = (enum __anonenum_binary_files_27 )2;
        } else {
          {
          {
#line 1567
          tmp___70 = dcgettext((char const   *)((void *)0), "unknown binary-files type",
                               5);
          }
          {
#line 1567
          error(2, 0, (char const   *)tmp___70);
          }
          }
        }
      }
    }
#line 1568
    goto switch_break;
    case_129: /* CIL Label */ 
#line 1571
    if (optarg) {
      {
      {
#line 1572
      tmp___95 = strcasecmp((char const   *)optarg, "always");
      }
      }
#line 1572
      if (tmp___95) {
        {
        {
#line 1572
        tmp___96 = strcasecmp((char const   *)optarg, "yes");
        }
        }
#line 1572
        if (tmp___96) {
          {
          {
#line 1572
          tmp___97 = strcasecmp((char const   *)optarg, "force");
          }
          }
#line 1572
          if (tmp___97) {
            {
            {
#line 1575
            tmp___92 = strcasecmp((char const   *)optarg, "never");
            }
            }
#line 1575
            if (tmp___92) {
              {
              {
#line 1575
              tmp___93 = strcasecmp((char const   *)optarg, "no");
              }
              }
#line 1575
              if (tmp___93) {
                {
                {
#line 1575
                tmp___94 = strcasecmp((char const   *)optarg, "none");
                }
                }
#line 1575
                if (tmp___94) {
                  {
                  {
#line 1578
                  tmp___89 = strcasecmp((char const   *)optarg, "auto");
                  }
                  }
#line 1578
                  if (tmp___89) {
                    {
                    {
#line 1578
                    tmp___90 = strcasecmp((char const   *)optarg, "tty");
                    }
                    }
#line 1578
                    if (tmp___90) {
                      {
                      {
#line 1578
                      tmp___91 = strcasecmp((char const   *)optarg, "if-tty");
                      }
                      }
#line 1578
                      if (tmp___91) {
#line 1582
                        show_help = 1;
                      } else {
#line 1580
                        color_option = 2;
                      }
                    } else {
#line 1580
                      color_option = 2;
                    }
                  } else {
#line 1580
                    color_option = 2;
                  }
                } else {
#line 1577
                  color_option = 0;
                }
              } else {
#line 1577
                color_option = 0;
              }
            } else {
#line 1577
              color_option = 0;
            }
          } else {
#line 1574
            color_option = 1;
          }
        } else {
#line 1574
          color_option = 1;
        }
      } else {
#line 1574
        color_option = 1;
      }
    } else {
#line 1584
      color_option = 2;
    }
#line 1585
    if (color_option == 2) {
      {
      {
#line 1586
      tmp___98 = isatty(1);
      }
      }
#line 1587
      if (tmp___98) {
        {
        {
#line 1586
        tmp___99 = getenv("TERM");
        }
        }
#line 1587
        if (tmp___99) {
#line 1587
          if (0) {
            {
            {
#line 1587
            tmp___132 = getenv("TERM");
            }
            {
#line 1587
            __s1_len___11 = strlen((char const   *)tmp___132);
            }
            {
#line 1587
            __s2_len___11 = strlen("dumb");
            }
            {
#line 1587
            tmp___133 = getenv("TERM");
            }
            {
#line 1587
            tmp___134 = getenv("TERM");
            }
            }
#line 1587
            if ((size_t )((void const   *)(tmp___133 + 1)) - (size_t )((void const   *)tmp___134) == 1U) {
#line 1587
              if (__s1_len___11 >= 4U) {
                _L___24: /* CIL Label */ 
#line 1587
                if (! ((size_t )((void const   *)("dumb" + 1)) - (size_t )((void const   *)"dumb") == 1U)) {
#line 1587
                  tmp___135 = 1;
                } else
#line 1587
                if (__s2_len___11 >= 4U) {
#line 1587
                  tmp___135 = 1;
                } else {
#line 1587
                  tmp___135 = 0;
                }
              } else {
#line 1587
                tmp___135 = 0;
              }
            } else {
#line 1587
              goto _L___24;
            }
#line 1587
            if (tmp___135) {
#line 1587
              if (__s1_len___11 < __s2_len___11) {
#line 1587
                tmp___105 = __s1_len___11;
              } else {
#line 1587
                tmp___105 = __s2_len___11;
              }
              {
              {
#line 1587
              tmp___106 = getenv("TERM");
              }
              {
#line 1587
              tmp___107 = memcmp((void const   *)((char const   *)tmp___106), (void const   *)"dumb",
                                 tmp___105 + 1U);
              }
#line 1587
              tmp___130 = tmp___107;
              }
            } else {
              {
              {
#line 1587
              tmp___128 = getenv("TERM");
              }
              {
#line 1587
              tmp___129 = strcmp((char const   *)tmp___128, "dumb");
              }
#line 1587
              tmp___130 = tmp___129;
              }
            }
          } else {
            {
            {
#line 1587
            tmp___128 = getenv("TERM");
            }
            {
#line 1587
            tmp___129 = strcmp((char const   *)tmp___128, "dumb");
            }
#line 1587
            tmp___130 = tmp___129;
            }
          }
#line 1587
          if (tmp___130) {
#line 1588
            color_option = 1;
          } else {
#line 1590
            color_option = 0;
          }
        } else {
#line 1590
          color_option = 0;
        }
      } else {
#line 1590
        color_option = 0;
      }
    }
#line 1592
    goto switch_break;
    case_131: /* CIL Label */ 
#line 1595
    if (! excluded_patterns) {
      {
      {
#line 1596
      excluded_patterns = new_exclude();
      }
      }
    }
    {
    {
#line 1597
    add_exclude(excluded_patterns, (char const   *)optarg);
    }
    }
#line 1598
    goto switch_break;
    case_132: /* CIL Label */ 
#line 1601
    if (! excluded_patterns) {
      {
      {
#line 1602
      excluded_patterns = new_exclude();
      }
      }
    }
    {
    {
#line 1603
    tmp___137 = add_exclude_file(& add_exclude, excluded_patterns, (char const   *)optarg,
                                 (char )'\n');
    }
    }
#line 1603
    if (tmp___137 != 0) {
      {
      {
#line 1606
      tmp___136 = __errno_location();
      }
      {
#line 1606
      error(2, *tmp___136, "%s", optarg);
      }
      }
    }
#line 1608
    goto switch_break;
    case_130: /* CIL Label */ 
#line 1611
    if (! included_patterns) {
      {
      {
#line 1612
      included_patterns = new_exclude();
      }
      }
    }
    {
    {
#line 1613
    add_exclude(included_patterns, (char const   *)optarg);
    }
    }
#line 1614
    goto switch_break;
    case_133: /* CIL Label */ 
#line 1617
    line_buffered = 1;
#line 1618
    goto switch_break;
    case_134: /* CIL Label */ 
#line 1621
    label = optarg;
#line 1622
    goto switch_break;
    case_0___0: /* CIL Label */ 
#line 1626
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
    {
#line 1629
    usage(2);
    }
    }
#line 1630
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1636
  if (exit_on_match) {
#line 1637
    list_files = 0;
  }
#line 1638
  if (exit_on_match | list_files) {
#line 1640
    count_matches = 0;
#line 1641
    done_on_match = 1;
  }
#line 1643
  out_quiet = count_matches | done_on_match;
#line 1645
  if (out_after < 0) {
#line 1646
    out_after = default_context;
  }
#line 1647
  if (out_before < 0) {
#line 1648
    out_before = default_context;
  }
#line 1650
  if (color_option) {
    {
    {
#line 1652
    tmp___138 = getenv("GREP_COLOR");
    }
#line 1652
    userval = tmp___138;
    }
#line 1653
    if ((unsigned long )userval != (unsigned long )((void *)0)) {
#line 1653
      if ((int )*userval != 0) {
#line 1654
        grep_color = (char const   *)userval;
      }
    }
  }
#line 1657
  if (! matcher) {
#line 1658
    matcher = "grep";
  }
#line 1660
  if (show_version) {
    {
    {
#line 1662
    tmp___139 = dcgettext((char const   *)((void *)0), "%s (GNU grep) %s\n", 5);
    }
    {
#line 1662
    printf((char const   */* __restrict  */)tmp___139, matcher, "2.5.1");
    }
    {
#line 1663
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 1664
    tmp___140 = dcgettext((char const   *)((void *)0), "Copyright 1988, 1992-1999, 2000, 2001 Free Software Foundation, Inc.\n",
                          5);
    }
    {
#line 1664
    printf((char const   */* __restrict  */)tmp___140);
    }
    {
#line 1666
    tmp___141 = dcgettext((char const   *)((void *)0), "This is free software; see the source for copying conditions. There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
                          5);
    }
    {
#line 1666
    printf((char const   */* __restrict  */)tmp___141);
    }
    {
#line 1669
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 1670
    exit(0);
    }
    }
  }
#line 1673
  if (show_help) {
    {
    {
#line 1674
    usage(0);
    }
    }
  }
#line 1676
  if (keys) {
#line 1678
    if (keycc == 0U) {
#line 1681
      out_invert ^= 1;
#line 1682
      match_words = 0;
#line 1682
      match_lines = match_words;
    } else {
#line 1686
      keycc --;
    }
  } else
#line 1689
  if (optind < argc) {
    {
#line 1691
    tmp___142 = optind;
#line 1691
    optind ++;
#line 1691
    keys = *(argv + tmp___142);
    {
#line 1692
    keycc = strlen((char const   *)keys);
    }
    }
  } else {
    {
    {
#line 1695
    usage(2);
    }
    }
  }
  {
  {
#line 1697
  tmp___143 = install_matcher(matcher);
  }
  }
#line 1697
  if (! tmp___143) {
    {
    {
#line 1697
    tmp___144 = install_matcher("default");
    }
    }
#line 1697
    if (! tmp___144) {
      {
      {
#line 1698
      abort();
      }
      }
    }
  }
  {
  {
#line 1700
  (*compile)((char const   *)keys, keycc);
  }
  }
#line 1702
  if (argc - optind > 1) {
#line 1702
    if (! no_filenames) {
#line 1703
      out_file = 1;
    } else {
#line 1702
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 1702
  if (with_filenames) {
#line 1703
    out_file = 1;
  }
#line 1712
  if (max_count == 0LL) {
    {
    {
#line 1713
    exit(1);
    }
    }
  }
#line 1715
  if (optind < argc) {
#line 1717
    status = 1;
    {
    {
#line 1718
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1720
      file = *(argv + optind);
#line 1721
      if (included_patterns) {
#line 1721
        goto _L___26;
      } else
#line 1721
      if (excluded_patterns) {
        _L___26: /* CIL Label */ 
        {
        {
#line 1721
        tmp___147 = isdir((char const   *)file);
        }
        }
#line 1721
        if (! tmp___147) {
#line 1724
          if (included_patterns) {
            {
            {
#line 1724
            tmp___145 = excluded_filename((struct exclude  const  *)included_patterns,
                                          (char const   *)file, 0);
            }
            }
#line 1724
            if (! tmp___145) {
#line 1726
              goto __Cont;
            }
          }
#line 1727
          if (excluded_patterns) {
            {
            {
#line 1727
            tmp___146 = excluded_filename((struct exclude  const  *)excluded_patterns,
                                          (char const   *)file, 0);
            }
            }
#line 1727
            if (tmp___146) {
#line 1729
              goto __Cont;
            }
          }
        }
      }
#line 1731
      if (0) {
        {
        {
#line 1731
        __s1_len___13 = strlen((char const   *)file);
        }
        {
#line 1731
        __s2_len___13 = strlen("-");
        }
        }
#line 1731
        if (! ((size_t )((void const   *)(file + 1)) - (size_t )((void const   *)file) == 1U)) {
#line 1731
          goto _L___30;
        } else
#line 1731
        if (__s1_len___13 >= 4U) {
          _L___30: /* CIL Label */ 
#line 1731
          if (! ((size_t )((void const   *)("-" + 1)) - (size_t )((void const   *)"-") == 1U)) {
#line 1731
            tmp___160 = 1;
          } else
#line 1731
          if (__s2_len___13 >= 4U) {
#line 1731
            tmp___160 = 1;
          } else {
#line 1731
            tmp___160 = 0;
          }
        } else {
#line 1731
          tmp___160 = 0;
        }
#line 1731
        if (tmp___160) {
#line 1731
          if (__s1_len___13 < __s2_len___13) {
#line 1731
            tmp___156 = __s1_len___13;
          } else {
#line 1731
            tmp___156 = __s2_len___13;
          }
          {
          {
#line 1731
          tmp___157 = memcmp((void const   *)((char const   *)file), (void const   *)"-",
                             tmp___156 + 1U);
          }
#line 1731
          tmp___159 = tmp___157;
          }
        } else {
          {
          {
#line 1731
          tmp___158 = strcmp((char const   *)file, "-");
          }
#line 1731
          tmp___159 = tmp___158;
          }
        }
      } else {
        {
        {
#line 1731
        tmp___158 = strcmp((char const   *)file, "-");
        }
#line 1731
        tmp___159 = tmp___158;
        }
      }
#line 1731
      if (tmp___159 == 0) {
#line 1731
        tmp___154 = (char *)((void *)0);
      } else {
#line 1731
        tmp___154 = file;
      }
      {
      {
#line 1731
      tmp___161 = grepfile((char const   *)tmp___154, & stats_base);
      }
#line 1731
      status &= tmp___161;
      }
      __Cont: /* CIL Label */ 
#line 1718
      optind ++;
#line 1718
      if (! (optind < argc)) {
#line 1718
        goto while_break___2;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1737
    status = grepfile((char const   *)((char *)((void *)0)), & stats_base);
    }
    }
  }
#line 1740
  if (errseen) {
#line 1740
    tmp___162 = 2;
  } else {
#line 1740
    tmp___162 = status;
  }
  {
  {
#line 1740
  exit(tmp___162);
  }
  }
}
}
