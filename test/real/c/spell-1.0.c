/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 36 "/abs/pronto/test-suite/spell-1.0/str.h"
struct str {
   char *str ;
   int len ;
   size_t mem ;
};
#line 42 "/abs/pronto/test-suite/spell-1.0/str.h"
typedef struct str str_t;
#line 105 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 78 "/abs/pronto/test-suite/spell-1.0/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_13 {
   __fd_mask __fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_13 fd_set;
#line 29 "/abs/pronto/test-suite/spell-1.0/str.h"
enum add_line_return {
    ADD_LINE_OK = 0,
    ADD_LINE_ERR = 1,
    ADD_LINE_EOF = 2
} ;
#line 73 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 71 "/abs/pronto/test-suite/spell-1.0/spell.c"
struct pipe {
   int pin ;
   int pout ;
   int perr ;
   int cin ;
   int cout ;
   int cerr ;
   fd_set error_set ;
};
#line 86 "/abs/pronto/test-suite/spell-1.0/spell.c"
typedef struct pipe pipe_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 433 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 329
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 336
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 724
extern int ferror(FILE *__stream ) ;
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 567
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 44 "/abs/pronto/test-suite/spell-1.0/str.h"
char *str_to_nstr(str_t *str ) ;
#line 45
int str_add_line(str_t *str , FILE *stream ) ;
#line 46
int str_add_line_from_desc(str_t *str , int file_desc ) ;
#line 47
str_t *int_to_str(int num ) ;
#line 48
str_t *nstr_to_str(char *nstr ) ;
#line 49
str_t *str_make(str_t *str ) ;
#line 50
void str_add_char(str_t *str , char c ) ;
#line 51
void str_add_str(str_t *str1 , str_t *str2 ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 243 "/usr/include/string.h"
extern char *strerror(int __errnum ) ;
#line 61 "/abs/pronto/test-suite/spell-1.0/str.c"
static void *xmalloc(size_t size ) ;
#line 62
static void *xrealloc(void *ptr , size_t size ) ;
#line 63
static void error(int status , int errnum , char const   *message  , ...) ;
#line 64
static int safe_read(int desc , char *ptr , int len ) ;
#line 68
char *program_name ;
#line 72
int interactive ;
#line 77 "/abs/pronto/test-suite/spell-1.0/str.c"
str_t *str_make(str_t *str ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 80
  if (! str) {
    {
#line 82
    tmp = xmalloc((size_t )sizeof(*str));
#line 82
    str = (str_t *)tmp;
#line 83
    tmp___0 = (size_t )64;
#line 83
    str->mem = tmp___0;
#line 83
    tmp___1 = xmalloc(tmp___0);
#line 83
    str->str = (char *)tmp___1;
    }
  } else {
    {
#line 86
    tmp___2 = (size_t )64;
#line 86
    str->mem = tmp___2;
#line 86
    tmp___3 = xrealloc((void *)str->str, tmp___2);
#line 86
    str->str = (char *)tmp___3;
    }
  }
#line 87
  str->len = 0;
#line 89
  return (str);
}
}
#line 95 "/abs/pronto/test-suite/spell-1.0/str.c"
void str_add_char(str_t *str , char c ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
#line 98
  if (! str) {
    {
#line 99
    str = str_make(str);
    }
  } else
#line 98
  if (! str->str) {
    {
#line 99
    str = str_make(str);
    }
  }
#line 101
  (str->len) ++;
#line 101
  if ((size_t )str->len > str->mem) {
    {
#line 102
    tmp = str->mem + 64U;
#line 102
    str->mem = tmp;
#line 102
    tmp___0 = xrealloc((void *)str->str, tmp);
#line 102
    str->str = (char *)tmp___0;
    }
  }
#line 104
  *(str->str + (str->len - 1)) = c;
#line 105
  return;
}
}
#line 110 "/abs/pronto/test-suite/spell-1.0/str.c"
void str_add_str(str_t *str1 , str_t *str2 ) 
{ 
  int pos ;

  {
#line 113
  pos = 0;
#line 115
  if (! str2) {
#line 116
    return;
  } else
#line 115
  if (! str2->str) {
#line 116
    return;
  }
#line 117
  if (! str1) {
    {
#line 118
    str1 = str_make(str1);
    }
  } else
#line 117
  if (! str1->str) {
    {
#line 118
    str1 = str_make(str1);
    }
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (pos < str2->len)) {
#line 120
      goto while_break;
    }
    {
#line 121
    str_add_char(str1, *(str2->str + pos));
#line 120
    pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return;
}
}
#line 129 "/abs/pronto/test-suite/spell-1.0/str.c"
int str_add_line(str_t *str , FILE *stream ) 
{ 
  register char c ;
  int tmp ;
  int tmp___0 ;

  {
#line 132
  if (! str) {
    {
#line 133
    str = str_make(str);
    }
  } else
#line 132
  if (! str->str) {
    {
#line 133
    str = str_make(str);
    }
  }
#line 134
  if (! stream) {
#line 135
    return (1);
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    tmp = _IO_getc(stream);
#line 139
    c = (char )tmp;
    }
#line 141
    if ((int )c == -1) {
#line 142
      return (2);
    } else {
      {
#line 141
      tmp___0 = ferror(stream);
      }
#line 141
      if (tmp___0) {
#line 142
        return (2);
      }
    }
    {
#line 143
    str_add_char(str, c);
    }
#line 144
    if ((int )c == 10) {
#line 145
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (0);
}
}
#line 157 "/abs/pronto/test-suite/spell-1.0/str.c"
int str_add_line_from_desc(str_t *str , int file_desc ) 
{ 
  int nchars ;
  char c ;

  {
#line 160
  nchars = 0;
#line 161
  c = (char)0;
#line 163
  if (! str) {
    {
#line 164
    str = str_make(str);
    }
  } else
#line 163
  if (! str->str) {
    {
#line 164
    str = str_make(str);
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    nchars = safe_read(file_desc, & c, 1);
    }
#line 170
    if (! nchars) {
#line 171
      return (2);
    }
#line 172
    if (nchars < 0) {
#line 173
      return (1);
    }
    {
#line 175
    str_add_char(str, c);
    }
#line 176
    if ((int )c == 10) {
#line 177
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (0);
}
}
#line 186 "/abs/pronto/test-suite/spell-1.0/str.c"
str_t *nstr_to_str(char *nstr ) 
{ 
  str_t *str ;
  int pos ;

  {
  {
#line 189
  str = (str_t *)0;
#line 190
  pos = 0;
#line 192
  str = str_make(str);
  }
#line 194
  if (! nstr) {
#line 195
    return (str);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! *(nstr + pos)) {
#line 196
      goto while_break;
    }
    {
#line 197
    str_add_char(str, *(nstr + pos));
#line 196
    pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (str);
}
}
#line 205 "/abs/pronto/test-suite/spell-1.0/str.c"
char *str_to_nstr(str_t *str ) 
{ 
  char *nstr ;
  void *tmp ;
  int pos ;

  {
  {
#line 208
  tmp = xmalloc((size_t )(str->len + 1));
#line 208
  nstr = (char *)tmp;
#line 209
  pos = 0;
  }
#line 211
  if (! str) {
#line 212
    return (nstr);
  } else
#line 211
  if (! str->str) {
#line 212
    return (nstr);
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (pos < str->len)) {
#line 214
      goto while_break;
    }
#line 216
    if (! *(str->str + pos)) {
#line 220
      *(str->str + pos) = (char )' ';
    }
#line 222
    *(nstr + pos) = *(str->str + pos);
#line 214
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  *(nstr + (pos + 1)) = (char)0;
#line 226
  return (nstr);
}
}
#line 236 "/abs/pronto/test-suite/spell-1.0/str.c"
str_t *int_to_str(int num ) 
{ 
  char c[2] ;
  int pos ;
  int rem ;
  str_t *rstr ;
  str_t *tmp ;
  str_t *str ;
  str_t *tmp___0 ;

  {
  {
#line 240
  pos = 0;
#line 241
  rem = 0;
#line 242
  tmp = str_make((str_t *)0);
#line 242
  rstr = tmp;
#line 243
  tmp___0 = str_make((str_t *)0);
#line 243
  str = tmp___0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (num > 0)) {
#line 247
      goto while_break;
    }
    {
#line 249
    rem = num % 10;
#line 250
    num /= 10;
#line 251
    sprintf((char */* __restrict  */)(c), (char const   */* __restrict  */)"%d", rem);
#line 252
    str_add_char(rstr, c[0]);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  pos = rstr->len - 1;
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! (pos >= 0)) {
#line 256
      goto while_break___0;
    }
    {
#line 257
    str_add_char(str, *(rstr->str + pos));
#line 256
    pos --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 259
  return (str);
}
}
#line 284 "/abs/pronto/test-suite/spell-1.0/str.c"
static void error(int status , int errnum , char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
#line 289
  if (! interactive) {
    {
#line 291
    fflush(stdout);
#line 292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            program_name);
    }
  }
  {
#line 295
  __builtin_va_start(args, message);
#line 296
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 297
  __builtin_va_end(args);
  }
#line 299
  if (errnum) {
    {
#line 300
    tmp = strerror(errnum);
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 301
  _IO_putc('\n', stderr);
#line 302
  fflush(stderr);
  }
#line 303
  if (status) {
    {
#line 304
    exit(status);
    }
  }
#line 305
  return;
}
}
#line 310 "/abs/pronto/test-suite/spell-1.0/str.c"
static void *xmalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 313
  tmp = malloc(size);
#line 313
  ptr = tmp;
  }
#line 315
  if (! ptr) {
    {
#line 316
    error(1, 0, "virtual memory exhausted");
    }
  }
#line 317
  return (ptr);
}
}
#line 324 "/abs/pronto/test-suite/spell-1.0/str.c"
static void *xrealloc(void *ptr , size_t size ) 
{ 
  void *tmp ;
  {
#line 327
  if (! ptr) {
    {
#line 328
    tmp = xmalloc(size);
    }
#line 328
    return (tmp);
  }
  {
#line 329
  ptr = realloc(ptr, size);
  }
#line 330
  if (! ptr) {
    {
#line 331
    error(1, 0, "virtual memory exhausted");
    }
  }
#line 332
  return (ptr);
}
}
#line 350
extern int ( /* missing proto */  read)() ;
#line 339 "/abs/pronto/test-suite/spell-1.0/str.c"
static int safe_read(int desc , char *ptr , int len ) 
{ 
  int n_chars ;
  int *tmp ;

  {
#line 344
  if (len <= 0) {
#line 345
    return (len);
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 350
    n_chars = read(desc, ptr, len);
    }
#line 348
    if (n_chars < 0) {
      {
#line 348
      tmp = __errno_location();
      }
#line 348
      if (! (*tmp == 4)) {
#line 348
        goto while_break;
      }
    } else {
#line 348
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return (n_chars);
}
}
#line 32 "/abs/pronto/test-suite/spell-1.0/getopt.h"
extern char *optarg ;
#line 46
extern int optind ;
#line 107
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 484
extern int putchar(int __c ) ;
#line 583
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 594 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 626
extern char *getenv(char const   *__name ) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 61
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 90 "/usr/include/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 207 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern int fstat(int __fd , struct stat *__statbuf ) ;
#line 235
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 319
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 320
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 322
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 359
  return (tmp);
}
}
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 379
  return (tmp);
}
}
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 318
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 369
extern int pipe(int *__pipedes ) ;
#line 469
extern int dup2(int __fd , int __fd2 ) ;
#line 500
extern int execl(char const   *__path , char const   *__arg  , ...) ;
#line 690
extern __pid_t fork(void) ;
#line 92 "/abs/pronto/test-suite/spell-1.0/spell.c"
char *find_ispell(void) ;
#line 93
static char *xstrdup(char const   *str ) ;
#line 94
static void *xmalloc___0(size_t size ) ;
#line 96
static void error___0(int status , int errnum , char const   *message  , ...) ;
#line 97
static void sig_chld(int signo ) ;
#line 98
static void sig_pipe(int signo ) ;
#line 99
void new_pipe(pipe_t *the_pipe ) ;
#line 100
void parent(pipe_t *the_pipe , int argc , char **argv ) ;
#line 101
void read_file(pipe_t *the_pipe , FILE *stream , char *file ) ;
#line 102
void read_ispell(pipe_t *ispell_pipe , char *file , int line ) ;
#line 103
void read_ispell_errors(pipe_t *the_pipe ) ;
#line 104
void run_ispell_in_child(pipe_t *the_pipe ) ;
#line 107 "/abs/pronto/test-suite/spell-1.0/spell.c"
char const   version[12]  = 
#line 107
  {      (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'0',      (char const   )'\000'};
#line 110 "/abs/pronto/test-suite/spell-1.0/spell.c"
struct option  const  long_options[13]  = 
#line 110
  {      {"all-chains", 0, (int *)((void *)0), 'l'}, 
        {"british", 0, (int *)((void *)0), 'b'}, 
        {"dictionary", 1, (int *)((void *)0), 'd'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"ispell", 1, (int *)((void *)0), 'i'}, 
        {"ispell-version", 0, (int *)((void *)0), 'I'}, 
        {"number", 0, (int *)((void *)0), 'n'}, 
        {"print-file-name", 0, (int *)((void *)0), 'o'}, 
        {"print-stems", 0, (int *)((void *)0), 'x'}, 
        {"stop-list", 1, (int *)((void *)0), 's'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 128 "/abs/pronto/test-suite/spell-1.0/spell.c"
char *program_name  =    (char *)((void *)0);
#line 131 "/abs/pronto/test-suite/spell-1.0/spell.c"
char *ispell_prog  =    (char *)((void *)0);
#line 134 "/abs/pronto/test-suite/spell-1.0/spell.c"
char *dictionary  =    (char *)((void *)0);
#line 137 "/abs/pronto/test-suite/spell-1.0/spell.c"
int show_ispell_version  =    0;
#line 140 "/abs/pronto/test-suite/spell-1.0/spell.c"
int read_stdin  =    0;
#line 143 "/abs/pronto/test-suite/spell-1.0/spell.c"
int british  =    0;
#line 147 "/abs/pronto/test-suite/spell-1.0/spell.c"
int verbose  =    0;
#line 150 "/abs/pronto/test-suite/spell-1.0/spell.c"
int number_lines  =    0;
#line 154 "/abs/pronto/test-suite/spell-1.0/spell.c"
int print_file_names  =    0;
#line 157 "/abs/pronto/test-suite/spell-1.0/spell.c"
int interactive  =    0;
#line 159 "/abs/pronto/test-suite/spell-1.0/spell.c"
int main(int argc , char **argv ) 
{ 
  char opt ;
  int opt_error ;
  int show_help ;
  int show_version ;
  pid_t pid ;
  pipe_t ispell_pipe ;
  int tmp ;
  int *tmp___0 ;

  {
#line 162
  opt = (char)0;
#line 163
  opt_error = 0;
#line 164
  show_help = 0;
#line 165
  show_version = 0;
#line 166
  pid = 0;
#line 169
  program_name = *(argv + 0);
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    tmp = getopt_long(argc, (char * const  *)argv, "IVbdhilnosvx", long_options, (int *)0);
#line 174
    opt = (char )tmp;
    }
#line 177
    if ((int )opt == -1) {
#line 178
      goto while_break;
    }
    {
#line 182
    if ((int )opt == 73) {
#line 182
      goto case_73;
    }
#line 185
    if ((int )opt == 86) {
#line 185
      goto case_86;
    }
#line 188
    if ((int )opt == 98) {
#line 188
      goto case_98;
    }
#line 191
    if ((int )opt == 100) {
#line 191
      goto case_100;
    }
#line 197
    if ((int )opt == 104) {
#line 197
      goto case_104;
    }
#line 200
    if ((int )opt == 105) {
#line 200
      goto case_105;
    }
#line 206
    if ((int )opt == 108) {
#line 206
      goto case_108;
    }
#line 208
    if ((int )opt == 110) {
#line 208
      goto case_110;
    }
#line 211
    if ((int )opt == 111) {
#line 211
      goto case_111;
    }
#line 214
    if ((int )opt == 115) {
#line 214
      goto case_115;
    }
#line 216
    if ((int )opt == 118) {
#line 216
      goto case_118;
    }
#line 219
    if ((int )opt == 120) {
#line 219
      goto case_120;
    }
#line 221
    goto switch_default;
    case_73: /* CIL Label */ 
#line 183
    show_ispell_version = 1;
#line 184
    goto switch_break;
    case_86: /* CIL Label */ 
#line 186
    show_version = 1;
#line 187
    goto switch_break;
    case_98: /* CIL Label */ 
#line 189
    british = 1;
#line 190
    goto switch_break;
    case_100: /* CIL Label */ 
#line 192
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 193
      dictionary = xstrdup((char const   *)optarg);
      }
    } else {
      {
#line 195
      error___0(0, 0, "option argument not given");
      }
    }
#line 196
    goto switch_break;
    case_104: /* CIL Label */ 
#line 198
    show_help = 1;
#line 199
    goto switch_break;
    case_105: /* CIL Label */ 
#line 201
    if ((unsigned long )optarg != (unsigned long )((void *)0)) {
      {
#line 202
      ispell_prog = xstrdup((char const   *)optarg);
      }
    } else {
      {
#line 204
      error___0(0, 0, "option argument not given");
      }
    }
#line 205
    goto switch_break;
    case_108: /* CIL Label */ 
#line 207
    goto switch_break;
    case_110: /* CIL Label */ 
#line 209
    number_lines = 1;
#line 210
    goto switch_break;
    case_111: /* CIL Label */ 
#line 212
    print_file_names = 1;
#line 213
    goto switch_break;
    case_115: /* CIL Label */ 
#line 215
    goto switch_break;
    case_118: /* CIL Label */ 
#line 217
    verbose = 1;
#line 218
    goto switch_break;
    case_120: /* CIL Label */ 
#line 220
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 222
    opt_error = 1;
#line 223
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if (opt_error) {
    {
#line 229
    printf((char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
           program_name);
#line 230
    exit(1);
    }
  }
#line 233
  if (show_version) {
    {
#line 235
    error___0(0, 0, version);
    }
#line 237
    if (! show_help) {
      {
#line 238
      exit(0);
      }
    }
  }
#line 241
  if (show_help) {
    {
#line 243
    printf((char const   */* __restrict  */)"Usage: %s [OPTION]... [FILE]...\n", program_name);
#line 244
    fputs((char const   */* __restrict  */)"This is GNU Spell, a Unix spell emulator.\n\n  -I, --ispell-version\t\tPrint Ispell\'s version.\n  -V, --version\t\t\tPrint the version number.\n  -b, --british\t\t\tUse the British dictionary.\n  -d, --dictionary=FILE\t\tUse FILE to look up words.\n  -h, --help\t\t\tPrint a summary of the options.\n  -i, --ispell=PROGRAM\t\tCalls PROGRAM as Ispell.\n  -l, --all-chains\t\tIgnored; for compatibility.\n  -n, --number\t\t\tPrint line numbers before lines.\n  -o, --print-file-name\t\tPrint file names before lines.\n  -s, --stop-list=FILE\t\tIgnored; for compatibility.\n  -v, --verbose\t\t\tPrint words not literally found.\n  -x, --print-stems\t\tIgnored; for compatibility.\n\nPlease use Info to read more (type `info spell\').\n",
          (FILE */* __restrict  */)stderr);
#line 258
    exit(0);
    }
  }
#line 261
  if (! ispell_prog) {
    {
#line 262
    ispell_prog = find_ispell();
    }
  }
  {
#line 264
  new_pipe(& ispell_pipe);
#line 266
  pid = fork();
  }
#line 270
  if (pid < 0) {
    {
#line 271
    tmp___0 = __errno_location();
#line 271
    error___0(1, *tmp___0, "error forking to run Ispell");
    }
  } else
#line 272
  if (pid > 0) {
    {
#line 273
    parent(& ispell_pipe, argc, argv);
    }
  } else {
    {
#line 275
    run_ispell_in_child(& ispell_pipe);
    }
  }
  {
#line 277
  exit(0);
  }
}
}
#line 284 "/abs/pronto/test-suite/spell-1.0/spell.c"
char *find_ispell(void) 
{ 
  char *ispell ;
  char *path ;
  int path_len ;
  int pos ;
  str_t *file ;
  str_t *tmp ;
  struct stat stat_buf ;
  char *tmp___0 ;
  size_t tmp___1 ;
  str_t *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 287
  ispell = (char *)((void *)0);
#line 288
  path = (char *)((void *)0);
#line 289
  path_len = 0;
#line 290
  pos = 0;
#line 291
  tmp = str_make((str_t *)0);
#line 291
  file = tmp;
#line 294
  tmp___0 = getenv("PATH");
#line 294
  path = xstrdup((char const   *)tmp___0);
#line 295
  tmp___1 = strlen((char const   *)path);
#line 295
  path_len = (int )tmp___1;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 298
    file = str_make(file);
    }
#line 300
    if (! pos) {
#line 300
      if ((int )*(path + pos) == 58) {
        {
#line 303
        str_add_char(file, (char )'.');
        }
      } else {
#line 300
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 305
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 305
        if (pos < path_len) {
#line 305
          if (! ((int )*(path + pos) != 58)) {
#line 305
            goto while_break___0;
          }
        } else {
#line 305
          goto while_break___0;
        }
        {
#line 306
        str_add_char(file, *(path + pos));
#line 305
        pos ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 308
    if ((int )*(file->str + (file->len - 1)) != 47) {
      {
#line 309
      str_add_char(file, (char )'/');
      }
    }
    {
#line 310
    tmp___2 = nstr_to_str((char *)"ispell");
#line 310
    str_add_str(file, tmp___2);
#line 312
    tmp___5 = str_to_nstr(file);
#line 312
    tmp___6 = stat((char const   */* __restrict  */)tmp___5, (struct stat */* __restrict  */)(& stat_buf));
    }
#line 312
    if (tmp___6 != -1) {
      {
#line 313
      tmp___3 = str_to_nstr(file);
#line 313
      tmp___4 = xstrdup((char const   *)tmp___3);
      }
#line 313
      return (tmp___4);
    }
#line 315
    if (pos >= path_len) {
      {
#line 316
      error___0(1, 0, "unable to locate Ispell");
      }
    }
#line 317
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  abort();
  }
}
}
#line 327 "/abs/pronto/test-suite/spell-1.0/spell.c"
void read_file(pipe_t *the_pipe , FILE *stream , char *file ) 
{ 
  str_t *str ;
  str_t *tmp ;
  enum add_line_return add_line_ret ;
  int line ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 330
  tmp = str_make((str_t *)0);
#line 330
  str = tmp;
#line 331
  add_line_ret = (enum add_line_return )0;
#line 332
  line = 0;
  }
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 336
    str = str_make(str);
#line 338
    str_add_char(str, (char )'^');
#line 339
    tmp___0 = str_add_line(str, stream);
#line 339
    add_line_ret = (enum add_line_return )tmp___0;
#line 340
    line ++;
    }
#line 342
    if ((unsigned int )add_line_ret == 1U) {
      {
#line 343
      tmp___1 = __errno_location();
#line 343
      error___0(1, *tmp___1, "%s: error reading line", file);
      }
    }
#line 344
    if ((unsigned int )add_line_ret == 2U) {
#line 344
      if (! str->len) {
#line 345
        return;
      }
    }
#line 348
    if ((int )*(str->str + (str->len - 1)) != 10) {
      {
#line 349
      str_add_char(str, (char )'\n');
      }
    }
    {
#line 351
    tmp___3 = str_to_nstr(str);
#line 351
    tmp___4 = write(the_pipe->pout, (void const   *)tmp___3, (size_t )str->len);
    }
#line 351
    if (tmp___4 != str->len) {
      {
#line 352
      tmp___2 = __errno_location();
#line 352
      error___0(1, *tmp___2, "error writing to Ispell");
      }
    }
    {
#line 354
    read_ispell_errors(the_pipe);
#line 355
    read_ispell(the_pipe, file, line);
#line 356
    read_ispell_errors(the_pipe);
    }
#line 358
    if ((unsigned int )add_line_ret == 2U) {
#line 359
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  tmp___6 = fclose(stream);
  }
#line 362
  if (tmp___6 == -1) {
    {
#line 363
    tmp___5 = __errno_location();
#line 363
    error___0(0, *tmp___5, "%s: close error", file);
    }
  }
}
}
#line 372 "/abs/pronto/test-suite/spell-1.0/spell.c"
void read_ispell(pipe_t *ispell_pipe , char *file , int line ) 
{ 
  str_t *str ;
  str_t *tmp ;
  int tmp___0 ;
  int pos ;
  char *tmp___1 ;

  {
  {
#line 375
  tmp = str_make((str_t *)0);
#line 375
  str = tmp;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    str = str_make(str);
#line 381
    tmp___0 = str_add_line_from_desc(str, ispell_pipe->pin);
    }
#line 381
    if (tmp___0 == 2) {
      {
#line 382
      exit(0);
      }
    }
#line 386
    if (str->len == 1) {
#line 386
      if ((int )*(str->str + 0) == 10) {
#line 387
        return;
      }
    }
#line 390
    if ((int )*(str->str + 0) == 42) {
#line 392
      goto while_continue;
    } else
#line 390
    if ((int )*(str->str + 0) == 43) {
#line 392
      goto while_continue;
    } else
#line 390
    if ((int )*(str->str + 0) == 45) {
#line 392
      goto while_continue;
    }
#line 395
    if ((int )*(str->str + 0) == 38) {
#line 395
      goto _L;
    } else
#line 395
    if ((int )*(str->str + 0) == 35) {
#line 395
      goto _L;
    } else
#line 395
    if ((int )*(str->str + 0) == 63) {
#line 395
      if (verbose) {
        _L: /* CIL Label */ 
#line 400
        if (print_file_names) {
          {
#line 402
          printf((char const   */* __restrict  */)"%s:", file);
          }
#line 403
          if (! number_lines) {
            {
#line 404
            putchar(' ');
            }
          }
        }
#line 406
        if (number_lines) {
          {
#line 407
          printf((char const   */* __restrict  */)"%d: ", line);
          }
        }
#line 409
        pos = 2;
        {
#line 409
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 409
          if (! ((int )*(str->str + pos) != 32)) {
#line 409
            goto while_break___0;
          }
          {
#line 410
          putchar((int )*(str->str + pos));
#line 409
          pos ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 411
        putchar('\n');
        }
#line 413
        goto while_continue;
      }
    }
#line 416
    if ((int )*(str->str + 0) == 63) {
#line 416
      if (! verbose) {
#line 417
        goto while_continue;
      }
    }
    {
#line 419
    tmp___1 = str_to_nstr(str);
#line 419
    error___0(0, 0, "unrecognized Ispell line `%s\'", tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 428 "/abs/pronto/test-suite/spell-1.0/spell.c"
void read_ispell_errors(pipe_t *the_pipe ) 
{ 
  struct timeval time_out ;
  str_t *str ;
  str_t *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 432
  tmp = str_make((str_t *)0);
#line 432
  str = tmp;
#line 434
  time_out.tv_usec = (__suseconds_t )0;
#line 434
  time_out.tv_sec = time_out.tv_usec;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 436
    tmp___4 = select(1024, (fd_set */* __restrict  */)(& the_pipe->error_set), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& time_out));
    }
#line 436
    if (! (tmp___4 == 1)) {
#line 436
      goto while_break;
    }
    {
#line 439
    str = str_make(str);
#line 441
    tmp___0 = str_add_line_from_desc(str, the_pipe->perr);
    }
#line 441
    if (tmp___0 == 2) {
      {
#line 443
      error___0(1, 0, "premature EOF from Ispell\'s stderr");
      }
    }
    {
#line 446
    str->len -= 2;
#line 447
    *(str->str + (str->len - 1)) = (char)0;
#line 449
    tmp___2 = strlen("Can\'t open ");
#line 449
    tmp___3 = memcmp((void const   *)str->str, (void const   *)"Can\'t open ", tmp___2);
    }
#line 449
    if (! tmp___3) {
      {
#line 450
      tmp___1 = strlen("Can\'t open ");
#line 450
      error___0(1, 0, "%s: cannot open", str->str + tmp___1);
      }
    }
    {
#line 453
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            ispell_prog, str->str);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return;
}
}
#line 460 "/abs/pronto/test-suite/spell-1.0/spell.c"
void new_pipe(pipe_t *the_pipe ) 
{ 
  int ifd[2] ;
  int ofd[2] ;
  int efd[2] ;
  int *tmp ;
  __sighandler_t tmp___0 ;
  int *tmp___1 ;
  __sighandler_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 467
  tmp___0 = signal(13, & sig_pipe);
  }
#line 467
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 468
    tmp = __errno_location();
#line 468
    error___0(1, *tmp, "error creating SIGPIPE handler");
    }
  }
  {
#line 469
  tmp___2 = signal(17, & sig_chld);
  }
#line 469
  if ((unsigned long )tmp___2 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 470
    tmp___1 = __errno_location();
#line 470
    error___0(1, *tmp___1, "error creating SIGCHLD handler");
    }
  }
  {
#line 472
  tmp___4 = pipe((int *)(ifd));
  }
#line 472
  if (tmp___4 < 0) {
    {
#line 473
    tmp___3 = __errno_location();
#line 473
    error___0(1, *tmp___3, "error creating pipe to Ispell");
    }
  }
  {
#line 474
  the_pipe->pin = ifd[0];
#line 475
  the_pipe->cout = ifd[1];
#line 477
  tmp___6 = pipe((int *)(ofd));
  }
#line 477
  if (tmp___6 < 0) {
    {
#line 478
    tmp___5 = __errno_location();
#line 478
    error___0(1, *tmp___5, "error creating pipe to Ispell");
    }
  }
  {
#line 479
  the_pipe->cin = ofd[0];
#line 480
  the_pipe->pout = ofd[1];
#line 482
  tmp___8 = pipe((int *)(efd));
  }
#line 482
  if (tmp___8 < 0) {
    {
#line 483
    tmp___7 = __errno_location();
#line 483
    error___0(1, *tmp___7, "error creating pipe to Ispell");
    }
  }
#line 484
  the_pipe->perr = efd[0];
#line 485
  the_pipe->cerr = efd[1];
#line 490
  return;
}
}
#line 494 "/abs/pronto/test-suite/spell-1.0/spell.c"
static void sig_pipe(int signo ) 
{ 


  {
  {
#line 497
  error___0(1, 0, "broken pipe");
  }
#line 498
  return;
}
}
#line 502 "/abs/pronto/test-suite/spell-1.0/spell.c"
static void sig_chld(int signo ) 
{ 


  {
  {
#line 505
  error___0(1, 0, "Ispell died");
  }
#line 506
  return;
}
}
#line 514 "/abs/pronto/test-suite/spell-1.0/spell.c"
void parent(pipe_t *the_pipe , int argc , char **argv ) 
{ 
  FILE *stream ;
  char *file ;
  int arg_error ;
  int arg_index ;
  int pos ;
  str_t *ispell_version ;
  str_t *tmp ;
  str_t *str ;
  str_t *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  struct stat stat_buf ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 518
  file = (char *)((void *)0);
#line 519
  arg_error = 0;
#line 520
  arg_index = optind;
#line 524
  close(the_pipe->cin);
#line 525
  close(the_pipe->cout);
#line 526
  close(the_pipe->cerr);
#line 528
  read_ispell_errors(the_pipe);
#line 536
  pos = 0;
#line 537
  tmp = str_make((str_t *)0);
#line 537
  ispell_version = tmp;
#line 538
  tmp___0 = str_make((str_t *)0);
#line 538
  str = tmp___0;
#line 540
  tmp___1 = str_add_line_from_desc(str, the_pipe->pin);
  }
#line 540
  if (tmp___1 == 2) {
    {
#line 541
    error___0(1, 0, "premature EOF from Ispell\'s stdout");
    }
  }
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 543
    tmp___2 = __ctype_b_loc();
    }
#line 543
    if ((int const   )*(*tmp___2 + (int )*(str->str + pos)) & 2048) {
#line 543
      goto while_break;
    } else
#line 543
    if (! (pos <= str->len)) {
#line 543
      goto while_break;
    }
#line 543
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 544
    if ((int )*(str->str + pos) != 32) {
#line 544
      if (! (pos <= str->len)) {
#line 544
        goto while_break___0;
      }
    } else {
#line 544
      goto while_break___0;
    }
    {
#line 545
    str_add_char(ispell_version, *(str->str + pos));
#line 544
    pos ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 547
  if (show_ispell_version) {
    {
#line 549
    tmp___3 = str_to_nstr(ispell_version);
#line 549
    printf((char const   */* __restrict  */)"%s: Ispell version %s\n", program_name,
           tmp___3);
#line 551
    exit(0);
    }
  }
  {
#line 555
  file = xstrdup("-");
  }
#line 557
  if (argc == 1) {
    {
#line 558
    read_file(the_pipe, stdin, (char *)"-");
    }
  }
  {
#line 560
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 560
    if (! (arg_index < argc)) {
#line 560
      goto while_break___1;
    }
#line 562
    arg_error = 0;
#line 564
    file = *(argv + arg_index);
#line 566
    if ((int )*(file + 0) == 45) {
#line 566
      if ((int )*(file + 1) == 0) {
#line 568
        if (! read_stdin) {
#line 570
          read_stdin = 1;
#line 571
          stream = stdin;
        }
      } else {
#line 566
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 578
      tmp___5 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& stat_buf));
      }
#line 578
      if (tmp___5 == -1) {
        {
#line 580
        tmp___4 = __errno_location();
#line 580
        error___0(0, *tmp___4, "%s: stat error", file);
#line 581
        arg_index ++;
        }
#line 582
        goto while_continue___1;
      }
#line 584
      if ((stat_buf.st_mode & 61440U) == 16384U) {
        {
#line 586
        error___0(0, 0, "%s: is a directory", file);
#line 587
        arg_index ++;
        }
#line 588
        goto while_continue___1;
      }
      {
#line 591
      stream = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
      }
#line 592
      if (! stream) {
        {
#line 594
        tmp___6 = __errno_location();
#line 594
        error___0(0, *tmp___6, "%s: open error", file);
#line 595
        arg_error = 1;
        }
      }
    }
#line 599
    if (! arg_error) {
      {
#line 600
      read_file(the_pipe, stream, file);
      }
    }
#line 602
    arg_index ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 604
  return;
}
}
#line 610 "/abs/pronto/test-suite/spell-1.0/spell.c"
void run_ispell_in_child(pipe_t *the_pipe ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 614
  close(the_pipe->pin);
#line 615
  close(the_pipe->pout);
#line 616
  close(the_pipe->perr);
  }
#line 618
  if (the_pipe->cin != 0) {
    {
#line 619
    tmp___0 = dup2(the_pipe->cin, 0);
    }
#line 619
    if (tmp___0 != 0) {
      {
#line 620
      tmp = __errno_location();
#line 620
      error___0(1, *tmp, "error duping to stdin");
      }
    }
  }
#line 622
  if (the_pipe->cout != 1) {
    {
#line 623
    tmp___2 = dup2(the_pipe->cout, 1);
    }
#line 623
    if (tmp___2 != 1) {
      {
#line 624
      tmp___1 = __errno_location();
#line 624
      error___0(1, *tmp___1, "error duping to stdout");
      }
    }
  }
#line 626
  if (the_pipe->cerr != 2) {
    {
#line 627
    tmp___4 = dup2(the_pipe->cerr, 2);
    }
#line 627
    if (tmp___4 != 2) {
      {
#line 628
      tmp___3 = __errno_location();
#line 628
      error___0(1, *tmp___3, "error duping to stderr");
      }
    }
  }
#line 630
  if ((unsigned long )dictionary != (unsigned long )((void *)0)) {
    {
#line 631
    tmp___6 = execl((char const   *)ispell_prog, "ispell", "-a", "-p", dictionary,
                    (void *)0);
    }
#line 631
    if (tmp___6 < 0) {
      {
#line 633
      tmp___5 = __errno_location();
#line 633
      error___0(1, *tmp___5, "error executing %s", ispell_prog);
      }
    }
  }
#line 635
  if (british) {
    {
#line 636
    tmp___8 = execl((char const   *)ispell_prog, "ispell", "-a", "-d", "british",
                    (void *)0);
    }
#line 636
    if (tmp___8 < 0) {
      {
#line 638
      tmp___7 = __errno_location();
#line 638
      error___0(1, *tmp___7, "error executing %s", ispell_prog);
      }
    }
  }
  {
#line 640
  tmp___10 = execl((char const   *)ispell_prog, "ispell", "-a", (void *)0);
  }
#line 640
  if (tmp___10 < 0) {
    {
#line 641
    tmp___9 = __errno_location();
#line 641
    error___0(1, *tmp___9, "error executing %s", ispell_prog);
    }
  }
#line 642
  return;
}
}
#line 664 "/abs/pronto/test-suite/spell-1.0/spell.c"
static void error___0(int status , int errnum , char const   *message  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
  {
#line 669
  fflush(stdout);
#line 670
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          program_name);
#line 672
  __builtin_va_start(args, message);
#line 673
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 674
  __builtin_va_end(args);
  }
#line 676
  if (errnum) {
    {
#line 677
    tmp = strerror(errnum);
#line 677
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 678
  _IO_putc('\n', stderr);
#line 679
  fflush(stderr);
  }
#line 680
  if (status) {
    {
#line 681
    exit(status);
    }
  }
#line 682
  return;
}
}
#line 687 "/abs/pronto/test-suite/spell-1.0/spell.c"
static void *xmalloc___0(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 690
  tmp = malloc(size);
#line 690
  ptr = tmp;
  }
#line 692
  if (! ptr) {
    {
#line 693
    error___0(1, 0, "virtual memory exhausted");
    }
  }
#line 694
  return (ptr);
}
}
#line 716 "/abs/pronto/test-suite/spell-1.0/spell.c"
static char *xstrdup(char const   *str ) 
{ 
  size_t len ;
  size_t tmp ;
  void *new ;
  void *tmp___0 ;

  {
  {
#line 719
  tmp = strlen(str);
#line 719
  len = tmp + 1U;
#line 720
  tmp___0 = xmalloc___0(len);
#line 720
  new = tmp___0;
#line 722
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)((void *)str),
         len);
  }
#line 724
  return ((char *)new);
}
}
