/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 137 "/usr/include/ncurses.h"
typedef unsigned long chtype;
#line 322
struct _win_st;
#line 322 "/usr/include/ncurses.h"
typedef struct _win_st WINDOW;
#line 324 "/usr/include/ncurses.h"
typedef chtype attr_t;
#line 369
struct ldat;
#line 371 "/usr/include/ncurses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 371 "/usr/include/ncurses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 43 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.h"
struct _Cell {
   unsigned char ch ;
   unsigned char attr ;
};
#line 53 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.h"
typedef struct _Cell Cell;
#line 55 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.h"
struct _Layer {
   char *name ;
   int width ;
   int height ;
   Cell **cells ;
   _Bool visible ;
   _Bool transp ;
};
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.h"
typedef struct _Layer Layer;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.h"
struct _Document {
   int layer_count ;
   Layer **layers ;
   char *metainfo ;
};
#line 48 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.h"
typedef struct _Document Document;
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.h"
struct _AbsMenu {
   int __ic ;
   int *item_count ;
   int x0 ;
   int y0 ;
   int w ;
   int h ;
   int attr_sel ;
   int attr_unsel ;
   int item_at_top ;
   int sel_item ;
   void (*painter)(int i , struct _AbsMenu *menu ) ;
};
#line 67 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.h"
typedef struct _AbsMenu AbsMenu;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.h"
struct VirtualLayer_ {
   int width ;
   int height ;
   void (*get_cell)(Cell *r_cell , int x , int y , void *ud ) ;
   void *user_data ;
};
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.h"
typedef struct VirtualLayer_ VirtualLayer;
#line 55 "/home/wslee/benchmarks/textformat/aewan-1.0.01/export.h"
struct __anonstruct_DecodedCell_23 {
   int fg ;
   int bg ;
   int ch ;
   _Bool bold ;
   _Bool blink ;
   int fg3 ;
   int bg3 ;
};
#line 55 "/home/wslee/benchmarks/textformat/aewan-1.0.01/export.h"
typedef struct __anonstruct_DecodedCell_23 DecodedCell;
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
struct MenuItem_ {
   char accel ;
   char const   *caption ;
   int command ;
   char const   *desc ;
};
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
typedef struct MenuItem_ MenuItem;
#line 62 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
struct Menu_ {
   char const   *caption ;
   int startcol ;
   int menu_h ;
   int menu_w ;
   int item_count ;
   MenuItem item[32] ;
};
#line 62 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
typedef struct Menu_ Menu;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/widget.h"
struct AewlForm_;
#line 43
struct AewlWidget_;
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/widget.h"
struct AewlWidget_ {
   WINDOW *win ;
   struct AewlForm_ *form ;
   int x ;
   int y ;
   int width ;
   int height ;
   int shortcut ;
   _Bool focusable ;
   struct AewlWidget_ *next ;
   void (*fn_repaint)(struct AewlWidget_ *self , _Bool focused ) ;
   int (*fn_handlekey)(struct AewlWidget_ *self , int ch ) ;
   void (*fn_destroy)(struct AewlWidget_ *self ) ;
};
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/widget.h"
typedef struct AewlWidget_ AewlWidget;
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.h"
struct AewlAttrQuad {
   int normal ;
   int focus ;
   int highlight ;
   int highlight_focus ;
};
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.h"
typedef struct AewlAttrQuad AewlAttrQuad;
#line 46 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.h"
struct AewlAttrSettings_ {
   AewlAttrQuad text ;
   AewlAttrQuad button ;
   AewlAttrQuad frame ;
   AewlAttrQuad field ;
   int field_pad ;
};
#line 46 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.h"
typedef struct AewlAttrSettings_ AewlAttrSettings;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.h"
struct AewlLabel_ {
   AewlWidget base ;
   char *caption ;
   AewlWidget *focus_peer ;
};
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.h"
typedef struct AewlLabel_ AewlLabel;
#line 7 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form_int.h"
struct AewlForm_ {
   WINDOW *win ;
   AewlWidget *first_widget ;
   AewlWidget *last_widget ;
   AewlWidget *focus_widget ;
};
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.h"
struct AewlButton_ {
   AewlWidget base ;
   char *caption ;
   int result ;
};
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.h"
typedef struct AewlButton_ AewlButton;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.h"
struct AewlListBox_ {
   AewlWidget base ;
   char *caption ;
   int result ;
   int sel ;
   int iat ;
   int item_count ;
   int capacity ;
   char **items ;
};
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.h"
typedef struct AewlListBox_ AewlListBox;
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.h"
typedef struct AewlForm_ AewlForm;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.h"
struct AewlField_ {
   AewlWidget base ;
   int result ;
   char *buffer ;
   int cap ;
   int pos ;
};
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.h"
typedef struct AewlField_ AewlField;
#line 58 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
struct html_output_state_t {
   _Bool font_tag_open ;
   _Bool blink_tag_open ;
   int color ;
   int bgcolor ;
};
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 94 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/autod.h"
struct AutodRegistryNode_ {
   void **ptr ;
   void (*destructor)(void * ) ;
   struct AutodRegistryNode_ *next ;
};
#line 94 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/autod.h"
typedef struct AutodRegistryNode_ AutodRegistryNode;
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.h"
struct AeFile_;
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.h"
typedef struct AeFile_ AeFile;
#line 347 "/usr/include/zconf.h"
typedef void *voidp;
#line 1078 "/usr/include/zlib.h"
typedef voidp gzFile;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
struct AeFile_ {
   gzFile f ;
   int indent_level ;
};
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 36 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.h"
struct DArray_;
#line 37 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.h"
typedef struct DArray_ DArray;
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
struct DArray_ {
   int len ;
   int cap ;
   void **items ;
   void (*value_destroyer)(void * ) ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.h"
struct HashDict_;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.h"
typedef struct HashDict_ HashDict;
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.h"
struct HashDictIt_ {
   _Bool pastend ;
   char const   *key ;
   void const   *value ;
   HashDict *dict ;
   int nextbucket ;
   void *nextnode ;
};
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.h"
typedef struct HashDictIt_ HashDictIt;
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
struct Node_ {
   char *key ;
   void const   *value ;
   struct Node_ *next ;
};
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
typedef struct Node_ Node;
#line 47 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
struct HashDict_ {
   int bucketcount ;
   Node *bucketheads ;
   void (*value_destroyer)(void * ) ;
};
#line 67 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
struct SavedScreenNode_ {
   WINDOW *win ;
   struct SavedScreenNode_ *next ;
};
#line 71 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
typedef struct SavedScreenNode_ SavedScreenNode;
#line 53 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.h"
void kurses_color(int fg , int bg ) ;
#line 66
int kurses_move(int x , int y ) ;
#line 100
void draw_centered_window(int w , int h , char const   *title , int *x , int *y ) ;
#line 105
void draw_hline(int x0 , int y0 , int w , int left_endpt , int interim , int right_endpt ) ;
#line 231 "/usr/include/ncurses.h"
extern chtype acs_map[] ;
#line 687
extern int printw(char const   *  , ...) ;
#line 748
extern int waddch(WINDOW * , chtype const    ) ;
#line 751
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 773
extern int wgetch(WINDOW * ) ;
#line 792
extern int wrefresh(WINDOW * ) ;
#line 1327
extern WINDOW *stdscr ;
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.h"
void document_del_layer(Document *doc___0 , int i ) ;
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
struct _Document *_doc ;
#line 56
int _lyr ;
#line 95
void switch_to_layer(int l ) ;
#line 89 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.h"
AbsMenu *menu_create(int *ic , int x0 , int y0 , int w , int h , int attr_sel , int attr_unsel ,
                     void (*painter___3)(int  , struct _AbsMenu * ) ) ;
#line 94
void menu_destroy(AbsMenu *m ) ;
#line 106
void menu_select_item(AbsMenu *m , int i ) ;
#line 109
void menu_paint(AbsMenu *m ) ;
#line 113
void menu_handle_key(AbsMenu *m , int ch ) ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static AbsMenu *menu  =    (AbsMenu *)0;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void painter(int i , AbsMenu *m ) 
{ 
  Layer *l ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 64
  l = *(_doc->layers + i);
#line 65
  if (l->name) {
#line 65
    tmp = (char const   *)l->name;
  } else {
#line 65
    tmp = "(untitled)";
  }
#line 65
  if (l->transp) {
#line 65
    tmp___0 = 't';
  } else {
#line 65
    tmp___0 = ' ';
  }
#line 65
  if (l->visible) {
#line 65
    tmp___1 = 'v';
  } else {
#line 65
    tmp___1 = ' ';
  }
  {
  {
#line 65
  printw("%2d: %c%c (%3d x %3d) %s", i, tmp___1, tmp___0, l->width, l->height, tmp);
  }
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void paint_dlg(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 74
  kurses_color(7, 0);
  }
  {
#line 75
  draw_centered_window(42, 19, "Layer Manager", & x0, & y0);
  }
  }
#line 77
  if (! menu) {
    {
    {
#line 78
    menu = menu_create(& _doc->layer_count, x0, y0, 40, 11, 113, 112, & painter);
    }
    {
#line 81
    menu_select_item(menu, _lyr);
    }
    }
  }
  {
  {
#line 84
  draw_hline(x0 - 1, y0 + 11, 42, (int )acs_map[(unsigned char )'t'], (int )acs_map[(unsigned char )'q'],
             (int )acs_map[(unsigned char )'u']);
  }
#line 87
  y = (y0 + 11) + 1;
#line 87
  x = x0 + 1;
  {
#line 87
  kurses_move(x, y);
  }
  {
#line 89
  kurses_color(2, 0);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )'<');
  }
  {
#line 89
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )' ');
  }
  {
#line 90
  kurses_color(7, 0);
  }
  {
#line 91
  printw(": go to layer");
  }
#line 93
  y ++;
  {
#line 93
  kurses_move(x, y);
  }
  {
#line 94
  kurses_color(2, 0);
  }
  {
#line 94
  waddnstr(stdscr, "d  ", -1);
  }
  {
#line 94
  kurses_color(7, 0);
  }
  {
#line 95
  printw(": delete layer");
  }
#line 97
  y ++;
  {
#line 97
  kurses_move(x, y);
  }
  {
#line 98
  kurses_color(2, 0);
  }
  {
#line 98
  waddnstr(stdscr, "+/-", -1);
  }
  {
#line 98
  kurses_color(7, 0);
  }
  {
#line 99
  printw(": move layer up/down");
  }
#line 101
  y ++;
  {
#line 101
  kurses_move(x, y);
  }
  {
#line 102
  kurses_color(2, 0);
  }
  {
#line 102
  waddnstr(stdscr, "v  ", -1);
  }
  {
#line 102
  kurses_color(7, 0);
  }
  {
#line 103
  printw(": toggle visibility");
  }
#line 105
  y ++;
  {
#line 105
  kurses_move(x, y);
  }
  {
#line 106
  kurses_color(2, 0);
  }
  {
#line 106
  waddnstr(stdscr, "t  ", -1);
  }
  {
#line 106
  kurses_color(7, 0);
  }
  {
#line 107
  printw(": toggle transparency");
  }
  {
#line 109
  menu_paint(menu);
  }
  }
#line 110
  return;
}
}
#line 112 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
void show_layer_dlg(void) 
{ 
  int ch ;
  int quit ;
  Layer *lyr___0 ;
  int i ;
  Layer **ls ;
  Layer *l ;
  int i___0 ;
  Layer **ls___0 ;
  Layer *l___0 ;

  {
#line 113
  quit = 0;
#line 116
  menu = (AbsMenu *)0;
  {
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 118
    if (! (! quit)) {
#line 118
      goto while_break;
    }
    {
    {
#line 119
    paint_dlg();
    }
    {
#line 120
    wrefresh(stdscr);
    }
    {
#line 121
    ch = wgetch(stdscr);
    }
    }
    {
#line 123
    if (ch == 10) {
#line 123
      goto case_10;
    }
#line 125
    if (ch == 7) {
#line 125
      goto case_7;
    }
#line 125
    if (ch == 3) {
#line 125
      goto case_7;
    }
#line 125
    if (ch == 27) {
#line 125
      goto case_7;
    }
#line 126
    if (ch == 100) {
#line 126
      goto case_100;
    }
#line 133
    if (ch == 61) {
#line 133
      goto case_61;
    }
#line 133
    if (ch == 43) {
#line 133
      goto case_61;
    }
#line 143
    if (ch == 95) {
#line 143
      goto case_95;
    }
#line 143
    if (ch == 45) {
#line 143
      goto case_95;
    }
#line 153
    if (ch == 118) {
#line 153
      goto case_118;
    }
#line 157
    if (ch == 116) {
#line 157
      goto case_116;
    }
#line 162
    goto switch_default;
    case_10: /* CIL Label */ 
    {
    {
#line 123
    switch_to_layer(menu->sel_item);
    }
    }
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 125
    quit = 1;
#line 125
    goto switch_break;
    case_100: /* CIL Label */ 
    {
    {
#line 127
    document_del_layer(_doc, menu->sel_item);
    }
    }
#line 128
    if (_doc->layer_count == 0) {
#line 129
      quit = 1;
    } else
#line 130
    if (menu->sel_item >= _doc->layer_count) {
#line 131
      menu->sel_item = _doc->layer_count - 1;
    }
#line 132
    goto switch_break;
    case_61: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 134
    if (menu->sel_item > 0) {
#line 135
      i = menu->sel_item;
#line 135
      ls = _doc->layers;
#line 136
      l = *(ls + (i - 1));
#line 137
      *(ls + (i - 1)) = *(ls + i);
#line 138
      *(ls + i) = l;
#line 140
      (menu->sel_item) --;
    }
#line 142
    goto switch_break;
    case_95: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 144
    if (menu->sel_item < _doc->layer_count - 1) {
#line 145
      i___0 = menu->sel_item;
#line 145
      ls___0 = _doc->layers;
#line 146
      l___0 = *(ls___0 + (i___0 + 1));
#line 147
      *(ls___0 + (i___0 + 1)) = *(ls___0 + i___0);
#line 148
      *(ls___0 + i___0) = l___0;
#line 150
      (menu->sel_item) ++;
    }
#line 152
    goto switch_break;
    case_118: /* CIL Label */ 
#line 154
    lyr___0 = *(_doc->layers + menu->sel_item);
#line 155
    lyr___0->visible = (_Bool )(! lyr___0->visible);
#line 156
    goto switch_break;
    case_116: /* CIL Label */ 
#line 158
    lyr___0 = *(_doc->layers + menu->sel_item);
#line 159
    lyr___0->transp = (_Bool )(! lyr___0->transp);
#line 160
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 162
    if (menu) {
      {
      {
#line 162
      menu_handle_key(menu, ch);
      }
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if (menu) {
    {
    {
#line 166
    menu_destroy(menu);
    }
    }
  }
#line 167
  return;
}
}
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/colordlg.h"
void show_color_dlg(void) ;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _fg ;
#line 63
int _bg ;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/colordlg.c"
static void paint_dlg___0(void) 
{ 
  int x0 ;
  int y0 ;
  int i ;
  int j ;
  char hexdigit___3[17] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 42
  hexdigit___3[0] = (char )'0';
#line 42
  hexdigit___3[1] = (char )'1';
#line 42
  hexdigit___3[2] = (char )'2';
#line 42
  hexdigit___3[3] = (char )'3';
#line 42
  hexdigit___3[4] = (char )'4';
#line 42
  hexdigit___3[5] = (char )'5';
#line 42
  hexdigit___3[6] = (char )'6';
#line 42
  hexdigit___3[7] = (char )'7';
#line 42
  hexdigit___3[8] = (char )'8';
#line 42
  hexdigit___3[9] = (char )'9';
#line 42
  hexdigit___3[10] = (char )'a';
#line 42
  hexdigit___3[11] = (char )'b';
#line 42
  hexdigit___3[12] = (char )'c';
#line 42
  hexdigit___3[13] = (char )'d';
#line 42
  hexdigit___3[14] = (char )'e';
#line 42
  hexdigit___3[15] = (char )'f';
#line 42
  hexdigit___3[16] = (char )'\000';
  {
#line 44
  kurses_color(7, 0);
  }
  {
#line 45
  draw_centered_window(39, 21, "Choose Color", & x0, & y0);
  }
  {
#line 48
  kurses_color(12, 0);
  }
  {
#line 49
  kurses_move((x0 + 4) + 2 * _bg, y0);
  }
  {
#line 50
  waddch(stdscr, (chtype const   )'b');
  }
  {
#line 53
  kurses_color(10, 0);
  }
  {
#line 54
  kurses_move(x0, (y0 + 2) + _fg);
  }
  {
#line 55
  waddch(stdscr, (chtype const   )'f');
  }
  {
#line 58
  kurses_color(7, 0);
  }
  {
#line 59
  kurses_move(x0 + 4, y0 + 1);
  }
  {
#line 60
  waddnstr(stdscr, "0 1 2 3 4 5 6 7 8 9 a b c d e f", -1);
  }
#line 63
  i = 0;
  }
  {
  {
#line 63
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 16)) {
#line 63
      goto while_break;
    }
    {
    {
#line 64
    kurses_move(x0 + 2, (y0 + 2) + i);
    }
    {
#line 65
    waddch(stdscr, (chtype const   )hexdigit___3[i]);
    }
#line 63
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  i = 0;
  {
  {
#line 69
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 16)) {
#line 69
      goto while_break___0;
    }
    {
    {
#line 70
    kurses_move(x0 + 4, (y0 + 2) + i);
    }
#line 71
    j = 0;
    }
    {
    {
#line 71
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! (j < 16)) {
#line 71
        goto while_break___1;
      }
      {
      {
#line 72
      kurses_color(i, j);
      }
      {
#line 73
      waddnstr(stdscr, "Aa", -1);
      }
#line 71
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 69
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 78
  kurses_move((x0 + 4) + 2 * _bg, (y0 + 2) + _fg);
  }
  }
#line 79
  return;
}
}
#line 81 "/home/wslee/benchmarks/textformat/aewan-1.0.01/colordlg.c"
void show_color_dlg(void) 
{ 
  int ch ;

  {
  {
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 84
    paint_dlg___0();
    }
    {
#line 85
    wrefresh(stdscr);
    }
    {
#line 86
    ch = wgetch(stdscr);
    }
    }
    {
#line 88
    if (ch == 10) {
#line 88
      goto case_10;
    }
#line 88
    if (ch == 7) {
#line 88
      goto case_10;
    }
#line 88
    if (ch == 3) {
#line 88
      goto case_10;
    }
#line 88
    if (ch == 27) {
#line 88
      goto case_10;
    }
#line 89
    if (ch == 259) {
#line 89
      goto case_259;
    }
#line 90
    if (ch == 258) {
#line 90
      goto case_258;
    }
#line 91
    if (ch == 260) {
#line 91
      goto case_260;
    }
#line 92
    if (ch == 261) {
#line 92
      goto case_261;
    }
#line 87
    goto switch_break;
    case_10: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 88
    return;
    case_259: /* CIL Label */ 
#line 89
    _fg --;
#line 89
    if (_fg < 0) {
#line 89
      _fg = 15;
    }
#line 89
    goto switch_break;
    case_258: /* CIL Label */ 
#line 90
    _fg ++;
#line 90
    if (_fg >= 16) {
#line 90
      _fg = 0;
    }
#line 90
    goto switch_break;
    case_260: /* CIL Label */ 
#line 91
    _bg --;
#line 91
    if (_bg < 0) {
#line 91
      _bg = 15;
    }
#line 91
    goto switch_break;
    case_261: /* CIL Label */ 
#line 92
    _bg ++;
#line 92
    if (_bg >= 16) {
#line 92
      _bg = 0;
    }
#line 92
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/chtr.h"
int chtr_a2c(unsigned char aewan_ch ) ;
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/chtr.c"
int chtr_a2c(unsigned char aewan_ch ) 
{ 
  int mappings[32] ;
  void *__cil_tmp3 ;

  {
#line 39
  mappings[0] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[1] = (int )acs_map[(unsigned char )'q'];
#line 39
  mappings[2] = (int )acs_map[(unsigned char )'x'];
#line 39
  mappings[3] = (int )acs_map[(unsigned char )'l'];
#line 39
  mappings[4] = (int )acs_map[(unsigned char )'w'];
#line 39
  mappings[5] = (int )acs_map[(unsigned char )'k'];
#line 39
  mappings[6] = (int )acs_map[(unsigned char )'t'];
#line 39
  mappings[7] = (int )acs_map[(unsigned char )'n'];
#line 39
  mappings[8] = (int )acs_map[(unsigned char )'u'];
#line 39
  mappings[9] = (int )acs_map[(unsigned char )'m'];
#line 39
  mappings[10] = (int )acs_map[(unsigned char )'v'];
#line 39
  mappings[11] = (int )acs_map[(unsigned char )'j'];
#line 39
  mappings[12] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[13] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[14] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[15] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[16] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[17] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[18] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[19] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[20] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[21] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[22] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[23] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[24] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[25] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[26] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[27] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[28] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[29] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[30] = (int )acs_map[(unsigned char )'a'];
#line 39
  mappings[31] = (int )acs_map[(unsigned char )'a'];
#line 58
  if ((int )aewan_ch < 32) {
#line 58
    return (mappings[aewan_ch]);
  }
#line 59
  return ((int )aewan_ch);
}
}
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 77 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.h"
void vlayer_get_cell(VirtualLayer *vl , Cell *r_cell , int x , int y ) ;
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/export.h"
_Bool export_vlayer_to_ansi(VirtualLayer *vl , _Bool use_ansi , _Bool use_newlines ,
                            _Bool quotemeta , FILE *f___0 ) ;
#line 71
void decode_cell(Cell const   *cell , DecodedCell *dc ) ;
#line 37 "/home/wslee/benchmarks/textformat/aewan-1.0.01/export.c"
void decode_cell(Cell const   *cell , DecodedCell *dc ) 
{ 


  {
#line 38
  dc->fg = (int )(((int const   )cell->attr & 240) >> 4);
#line 39
  dc->bg = (int )((int const   )cell->attr & 15);
#line 40
  dc->ch = (int )cell->ch;
#line 42
  dc->fg3 = (int )(((int const   )cell->attr & 112) >> 4);
#line 43
  dc->bg3 = (int )((int const   )cell->attr & 7);
#line 44
  if ((int const   )cell->attr & 128) {
#line 44
    dc->bold = (_Bool)1;
  } else {
#line 44
    dc->bold = (_Bool)0;
  }
#line 45
  if ((int const   )cell->attr & 8) {
#line 45
    dc->blink = (_Bool)1;
  } else {
#line 45
    dc->blink = (_Bool)0;
  }
#line 46
  return;
}
}
#line 48 "/home/wslee/benchmarks/textformat/aewan-1.0.01/export.c"
_Bool export_vlayer_to_ansi(VirtualLayer *vl , _Bool use_ansi , _Bool use_newlines ,
                            _Bool quotemeta , FILE *f___0 ) 
{ 
  int x ;
  int y ;
  DecodedCell dec ;
  Cell c ;
  int cur_fg___3 ;
  int cur_bg___3 ;
  char const   *must_quote ;
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 53
  cur_fg___3 = -1;
#line 54
  cur_bg___3 = -1;
#line 55
  must_quote = "\\`$";
#line 57
  y = 0;
  {
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 57
    if (! (y < vl->height)) {
#line 57
      goto while_break;
    }
#line 58
    x = 0;
    {
    {
#line 58
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 58
      if (! (x < vl->width)) {
#line 58
        goto while_break___0;
      }
      {
      {
#line 59
      vlayer_get_cell(vl, & c, x, y);
      }
      {
#line 60
      decode_cell((Cell const   *)(& c), & dec);
      }
      }
#line 63
      if (use_ansi) {
#line 63
        if (dec.fg != cur_fg___3) {
#line 63
          goto _L;
        } else
#line 63
        if (dec.bg != cur_bg___3) {
          _L: /* CIL Label */ 
          {
          {
#line 64
          fputs((char const   */* __restrict  */)"\033[", (FILE */* __restrict  */)f___0);
          }
          }
#line 65
          if (dec.bold) {
#line 65
            tmp = "1;";
          } else {
#line 65
            tmp = "0;";
          }
          {
          {
#line 65
          fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)f___0);
          }
          }
#line 66
          if (dec.blink) {
            {
            {
#line 66
            fputs((char const   */* __restrict  */)"5;", (FILE */* __restrict  */)f___0);
            }
            }
          }
          {
          {
#line 67
          fprintf((FILE */* __restrict  */)f___0, (char const   */* __restrict  */)"%d;%dm",
                  30 + dec.fg3, 40 + dec.bg3);
          }
#line 69
          cur_fg___3 = dec.fg;
#line 70
          cur_bg___3 = dec.bg;
          }
        }
      }
#line 74
      if (dec.ch >= 0) {
#line 74
        if (dec.ch <= 32) {
#line 74
          dec.ch = ' ';
        }
      }
#line 76
      if (quotemeta) {
        {
        {
#line 76
        tmp___0 = strchr(must_quote, dec.ch);
        }
        }
#line 76
        if (tmp___0) {
          {
          {
#line 76
          fputc('\\', f___0);
          }
          }
        }
      }
      {
      {
#line 77
      fputc(dec.ch, f___0);
      }
#line 58
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 80
    if (use_newlines) {
      {
      {
#line 80
      fputc('\n', f___0);
      }
      }
    }
#line 57
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  if (use_ansi) {
    {
    {
#line 83
    fputs((char const   */* __restrict  */)"\033[0m", (FILE */* __restrict  */)f___0);
    }
    }
  }
#line 84
  return ((_Bool)1);
}
}
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.h"
void kurses_color_at(int attr ) ;
#line 59
int kurses_width(void) ;
#line 62
int kurses_height(void) ;
#line 95
void draw_window(int x0 , int y0 , int w , int h , char const   *title ) ;
#line 115
void push_screen(void) ;
#line 123
void restore_screen(void) ;
#line 129
void pop_screen(void) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 48 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.h"
int menubar_show(int startm ) ;
#line 1 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static Menu menu___0[4]  = {      {"[F1] File", 1, 0, 0, 7, {{(char )'N', "&New", 35, "Clears everything and starts from scratch"},
                                {(char )'L', "&Load...", 8, "Loads a file into the editor"},
                                {(char )'S', "&Save", 9, "Saves the current drawing"},
                                {(char )'A', "Save &As...", 10, "Saves the current drawing in a specified file"},
                                {(char )'M', "Edit &Meta...", 11, "Opens an editor for you to edit this document\'s metadata"},
                                {(char )' ', "", 0, (char const   *)((void *)0)},
                                {(char )'Q', "&Quit", 34, "Quits program"}}}, 
        {"[F2] Edit", 16, 0, 0, 8, {{(char )'C', "Drawing &color...", 5, "Brings up the color selection dialog"},
                                 {(char )'I', "Toggle &Insert", 6, "Toggles insert/overwrite mode"},
                                 {(char )'K', "Pic&k color", 23, "Picks color under cursor to use as current color"},
                                 {(char )'T', "&Tint cell", 24, "Applies current color to cell under cursor"},
                                 {(char )' ', "", 0, (char const   *)((void *)0)},
                                 {(char )'S', "Toggle &select mode", 25, "Toggles select mode on/off"},
                                 {(char )'L', "Toggle &line-drawing", 32, "Toggles line-drawing mode on/off. Use 0-9 to draw lines"},
                                 {(char )'P', "Toggle com&posite", 33, "Toggles composite (all-layer) view on/off"}}}, 
        {"[F3] Layer",
      32, 0, 0, 9, {{(char )'A', "&Add layer (defaults)", 1, "Adds a layer with default parameters"},
                    {(char )'L', "Add &layer (specify)...", 2, "Adds a layer with custom parameters"},
                    {(char )'D', "&Duplicate layer", 30, "Duplicates current layer. Copy is added to the bottom of the stack."},
                    {(char )'R', "&Rename layer...", 31, "Renames the current layer"},
                    {(char )'Z', "Resi&ze layer...", 37, "Resizes the current layer"},
                    {(char )'M', "&Manage layers...", 27, "Shows a dialog in which you can manipulate layers"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'N',
                                                                       "Go to &next layer",
                                                                       28, "Goes to the next layer"},
                    {(char )'P', "Go to &previous layer", 29, "Goes to the previous layer"}}}, 
        {"[F4] Help",
      64, 0, 0, 3, {{(char )'K', "&Key reference", 7, "Shows a table of keys and their functions"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'A',
                                                                       "&About Aewan",
                                                                       36, "Shows information about the program"}}}};
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static int menu_count  =    4;
#line 78 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int open_menu  ;
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int menu_sel  ;
#line 83
static void menubar_paint(void) ;
#line 84
static void menuitem_print(char const   *s , _Bool sel , int minlen ) ;
#line 85
static void menu_calc_dims(Menu *m ) ;
#line 86
static _Bool chr_icomp(char c1 , char c2 ) ;
#line 89 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
int menubar_show(int startm ) 
{ 
  int ch ;
  int i ;
  int cmd ;
  _Bool quit ;
  Menu *omenu ;
  _Bool tmp ;

  {
#line 91
  cmd = 0;
#line 91
  quit = (_Bool)0;
#line 93
  menu_sel = 0;
#line 95
  open_menu = startm;
#line 96
  if (open_menu < 0) {
#line 96
    open_menu = 0;
  }
#line 97
  if (open_menu >= menu_count) {
#line 97
    open_menu = menu_count - 1;
  }
  {
  {
#line 99
  push_screen();
  }
  }
  {
  {
#line 101
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 101
    if (! (! quit)) {
#line 101
      goto while_break;
    }
    {
#line 102
    omenu = & menu___0[open_menu];
    {
#line 103
    menubar_paint();
    }
    {
#line 104
    ch = wgetch(stdscr);
    }
    }
    {
#line 107
    if (ch == 260) {
#line 107
      goto case_260;
    }
#line 110
    if (ch == 261) {
#line 110
      goto case_261;
    }
#line 113
    if (ch == 259) {
#line 113
      goto case_259;
    }
#line 118
    if (ch == 258) {
#line 118
      goto case_258;
    }
#line 123
    if (ch == 10) {
#line 123
      goto case_10;
    }
#line 125
    if (ch == 27) {
#line 125
      goto case_27;
    }
#line 106
    goto switch_break;
    case_260: /* CIL Label */ 
#line 107
    open_menu --;
#line 107
    if (open_menu < 0) {
#line 107
      open_menu = menu_count - 1;
    }
#line 108
    menu_sel = 0;
#line 109
    goto switch_break;
    case_261: /* CIL Label */ 
#line 110
    open_menu ++;
#line 110
    if (open_menu >= menu_count) {
#line 110
      open_menu = 0;
    }
#line 111
    menu_sel = 0;
#line 112
    goto switch_break;
    case_259: /* CIL Label */ 
    {
    {
#line 114
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 115
      menu_sel --;
#line 115
      if (menu_sel < 0) {
#line 115
        menu_sel = omenu->item_count - 1;
      }
#line 114
      if (! (! *(omenu->item[menu_sel].caption))) {
#line 114
        goto while_break___0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 117
    goto switch_break;
    case_258: /* CIL Label */ 
    {
    {
#line 119
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 120
      menu_sel ++;
#line 120
      if (menu_sel >= omenu->item_count) {
#line 120
        menu_sel = 0;
      }
#line 119
      if (! (! *(omenu->item[menu_sel].caption))) {
#line 119
        goto while_break___1;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 122
    goto switch_break;
    case_10: /* CIL Label */ 
#line 123
    quit = (_Bool)1;
#line 123
    cmd = omenu->item[menu_sel].command;
#line 124
    goto switch_break;
    case_27: /* CIL Label */ 
#line 125
    quit = (_Bool)1;
#line 125
    cmd = 0;
#line 126
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 129
    if (ch > 264) {
#line 129
      if (ch <= 276) {
#line 129
        if ((ch - 264) - 1 < menu_count) {
#line 130
          open_menu = (ch - 264) - 1;
#line 131
          menu_sel = 0;
        }
      }
    }
#line 135
    i = 0;
    {
    {
#line 135
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 135
      if (! (i < omenu->item_count)) {
#line 135
        goto while_break___2;
      }
      {
      {
#line 136
      tmp = chr_icomp(omenu->item[i].accel, (char )ch);
      }
      }
#line 136
      if (tmp) {
#line 138
        cmd = omenu->item[i].command;
#line 139
        quit = (_Bool)1;
#line 140
        goto while_break___2;
      }
#line 135
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 145
  restore_screen();
  }
  {
#line 146
  pop_screen();
  }
  {
#line 147
  wrefresh(stdscr);
  }
  }
#line 148
  return (cmd);
}
}
#line 151 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static _Bool chr_icomp(char c1 , char c2 ) 
{ 


  {
#line 152
  if ((int )c1 >= 65) {
#line 152
    if ((int )c1 <= 90) {
#line 152
      c1 = (char )(((int )c1 - 65) + 97);
    } else {
#line 152
      c1 = c1;
    }
  } else {
#line 152
    c1 = c1;
  }
#line 153
  if ((int )c2 >= 65) {
#line 153
    if ((int )c2 <= 90) {
#line 153
      c2 = (char )(((int )c2 - 65) + 97);
    } else {
#line 153
      c2 = c2;
    }
  } else {
#line 153
    c2 = c2;
  }
#line 154
  return ((_Bool )((int )c1 == (int )c2));
}
}
#line 157 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menubar_paint(void) 
{ 
  int i ;
  Menu *omenu ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 160
  restore_screen();
  }
  {
#line 162
  kurses_color_at(7);
  }
  {
#line 163
  tmp = kurses_width();
  }
  {
#line 163
  draw_hline(0, 0, tmp, ' ', ' ', ' ');
  }
#line 165
  i = 0;
  }
  {
  {
#line 165
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < menu_count)) {
#line 165
      goto while_break;
    }
    {
    {
#line 166
    kurses_move(menu___0[i].startcol, 0);
    }
    {
#line 167
    menuitem_print(menu___0[i].caption, (_Bool )(i == open_menu), -1);
    }
#line 165
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  omenu = & menu___0[open_menu];
#line 173
  if (! omenu->menu_h) {
    {
    {
#line 173
    menu_calc_dims(omenu);
    }
    }
  }
  {
  {
#line 176
  kurses_color_at(7);
  }
  {
#line 177
  draw_window(omenu->startcol, 1, omenu->menu_w + 2, omenu->menu_h + 2, "");
  }
#line 178
  i = 0;
  }
  {
  {
#line 178
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < omenu->item_count)) {
#line 178
      goto while_break___0;
    }
    {
    {
#line 179
    kurses_move(omenu->startcol + 1, i + 2);
    }
    {
#line 180
    menuitem_print(omenu->item[i].caption, (_Bool )(i == menu_sel), omenu->menu_w);
    }
#line 178
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 184
  tmp___0 = kurses_height();
  }
  {
#line 184
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 185
  kurses_color_at(7);
  }
  {
#line 186
  tmp___1 = strlen(omenu->item[menu_sel].desc);
  }
#line 186
  i = (int )tmp___1;
  {
#line 187
  waddnstr(stdscr, omenu->item[menu_sel].desc, -1);
  }
  }
  {
  {
#line 188
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
#line 188
    tmp___2 = i;
#line 188
    i ++;
    {
#line 188
    tmp___3 = kurses_width();
    }
    }
#line 188
    if (! (tmp___2 < tmp___3)) {
#line 188
      goto while_break___1;
    }
    {
    {
#line 188
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 190
  tmp___4 = kurses_height();
  }
  {
#line 190
  tmp___5 = kurses_width();
  }
  {
#line 190
  kurses_move(tmp___5 - 1, tmp___4 - 1);
  }
  {
#line 191
  wrefresh(stdscr);
  }
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menuitem_print(char const   *s , _Bool sel , int minlen ) 
{ 
  _Bool next_is_accel ;
  int printed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 195
  next_is_accel = (_Bool)0;
#line 196
  printed = 0;
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (! *s) {
#line 197
      if (! (printed < minlen)) {
#line 197
        goto while_break;
      }
    }
#line 198
    if ((int const   )*s == 38) {
#line 199
      next_is_accel = (_Bool)1;
#line 200
      s ++;
#line 201
      goto while_continue;
    }
#line 204
    if (sel) {
#line 204
      if (next_is_accel) {
#line 204
        tmp = 225;
      } else {
#line 204
        tmp = 241;
      }
#line 204
      tmp___1 = tmp;
    } else {
#line 204
      if (next_is_accel) {
#line 204
        tmp___0 = 23;
      } else {
#line 204
        tmp___0 = 7;
      }
#line 204
      tmp___1 = tmp___0;
    }
    {
    {
#line 204
    kurses_color_at(tmp___1);
    }
    }
#line 208
    if (*s) {
#line 208
      tmp___2 = (int const   )*s;
    } else {
#line 208
      tmp___2 = (int const   )' ';
    }
    {
    {
#line 208
    waddch(stdscr, (chtype const   )tmp___2);
    }
#line 209
    printed ++;
#line 211
    next_is_accel = (_Bool)0;
    }
#line 212
    if (*s) {
#line 212
      s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menu_calc_dims(Menu *m ) 
{ 
  int i ;
  int width___0 ;
  int len ;
  size_t tmp ;

  {
#line 218
  width___0 = 1;
#line 218
  len = 0;
#line 220
  i = 0;
  {
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < m->item_count)) {
#line 220
      goto while_break;
    }
    {
    {
#line 221
    tmp = strlen(m->item[i].caption);
    }
#line 221
    len = (int )tmp;
    }
#line 222
    if (len > width___0) {
#line 222
      width___0 = len;
    }
#line 220
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  m->menu_h = m->item_count;
#line 226
  m->menu_w = width___0;
#line 227
  return;
}
}
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 69 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
void *zalloc(int bytes ) ;
#line 99 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.h"
void menu_set_count(AbsMenu *m , int i ) ;
#line 102
int menu_get_count(AbsMenu *m ) ;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
AbsMenu *menu_create(int *ic , int x0 , int y0 , int w , int h , int attr_sel , int attr_unsel ,
                     void (*painter___3)(int  , struct _AbsMenu * ) ) 
{ 
  AbsMenu *new_menu ;
  void *tmp ;

  {
  {
  {
#line 44
  tmp = zalloc((int )sizeof(struct _AbsMenu ));
  }
#line 44
  new_menu = (AbsMenu *)tmp;
  }
#line 45
  if (ic) {
#line 45
    new_menu->item_count = ic;
  } else {
#line 45
    new_menu->item_count = & new_menu->__ic;
  }
#line 46
  new_menu->x0 = x0;
#line 47
  new_menu->y0 = y0;
#line 48
  new_menu->w = w;
#line 49
  new_menu->h = h;
#line 50
  new_menu->attr_sel = attr_sel;
#line 51
  new_menu->attr_unsel = attr_unsel;
#line 52
  new_menu->painter = painter___3;
#line 53
  return (new_menu);
}
}
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
void menu_destroy(AbsMenu *m ) 
{ 


  {
#line 57
  if (m) {
    {
    {
#line 57
    free((void *)m);
    }
    }
  }
#line 58
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
void menu_set_count(AbsMenu *m , int i ) 
{ 


  {
#line 61
  m->__ic = i;
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
int menu_get_count(AbsMenu *m ) 
{ 


  {
#line 65
  return (*(m->item_count));
}
}
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
void menu_paint(AbsMenu *m ) 
{ 
  int i ;
  int index ;
  int j ;
  int sely ;
  int tmp ;

  {
#line 70
  sely = m->y0;
#line 71
  i = 0;
  {
  {
#line 71
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < m->h)) {
#line 71
      goto while_break;
    }
#line 72
    index = i + m->item_at_top;
#line 73
    if (index == m->sel_item) {
#line 73
      sely = m->y0 + i;
    }
    {
    {
#line 75
    kurses_move(m->x0, m->y0 + i);
    }
    }
#line 76
    if (m->sel_item == index) {
#line 76
      tmp = m->attr_sel;
    } else {
#line 76
      tmp = m->attr_unsel;
    }
    {
    {
#line 76
    kurses_color_at(tmp);
    }
#line 77
    j = 0;
    }
    {
    {
#line 77
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! (j < m->w)) {
#line 77
        goto while_break___0;
      }
      {
      {
#line 77
      waddch(stdscr, (chtype const   )' ');
      }
#line 77
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 79
    kurses_move(m->x0, m->y0 + i);
    }
    }
#line 80
    if (index >= 0) {
#line 80
      if (index < *(m->item_count)) {
        {
        {
#line 80
        (*(m->painter))(index, m);
        }
        }
      }
    }
#line 71
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 84
  kurses_move(m->x0, sely);
  }
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
static void menu_correct(AbsMenu *m ) 
{ 


  {
  {
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 89
    if (! (m->sel_item < 0)) {
#line 89
      goto while_break;
    }
#line 89
    m->sel_item = 0;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (m->sel_item >= *(m->item_count))) {
#line 90
      goto while_break___0;
    }
#line 90
    m->sel_item = -1 + *(m->item_count);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  if (m->item_at_top > m->sel_item) {
#line 95
    m->item_at_top = m->sel_item;
  } else
#line 96
  if (m->sel_item >= m->item_at_top + m->h) {
#line 97
    m->item_at_top = (m->sel_item - m->h) + 1;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
void menu_handle_key(AbsMenu *m , int ch ) 
{ 


  {
  {
#line 102
  if (ch == 259) {
#line 102
    goto case_259;
  }
#line 103
  if (ch == 258) {
#line 103
    goto case_258;
  }
#line 104
  if (ch == 338) {
#line 104
    goto case_338;
  }
#line 105
  if (ch == 339) {
#line 105
    goto case_339;
  }
#line 101
  goto switch_break;
  case_259: /* CIL Label */ 
#line 102
  (m->sel_item) --;
#line 102
  goto switch_break;
  case_258: /* CIL Label */ 
#line 103
  (m->sel_item) ++;
#line 103
  goto switch_break;
  case_338: /* CIL Label */ 
#line 104
  m->sel_item += m->h;
#line 104
  goto switch_break;
  case_339: /* CIL Label */ 
#line 105
  m->sel_item -= m->h;
#line 105
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 108
  menu_correct(m);
  }
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
void menu_select_item(AbsMenu *m , int i ) 
{ 


  {
  {
#line 112
  m->sel_item = i;
  {
#line 113
  menu_correct(m);
  }
  }
#line 114
  return;
}
}
#line 787 "/usr/include/ncurses.h"
extern int wmove(WINDOW * , int  , int  ) ;
#line 83 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/widget.h"
void aewl_widget_fill_defaults(AewlWidget *w ) ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.h"
AewlAttrSettings aewl_attrs ;
#line 52 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.h"
AewlWidget *aewl_label_create(int x , int y , int width___0 , char const   *text ) ;
#line 55
void aewl_label_destroy(AewlWidget *w ) ;
#line 58
void aewl_label_repaint(AewlWidget *w , _Bool focused ) ;
#line 61
void aewl_label_set_text(AewlLabel *l , char const   *text ) ;
#line 65
void aewl_label_set_focus_peer(AewlLabel *l , AewlWidget *peer ) ;
#line 42 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.h"
void aewl_util_mvwaddstr(WINDOW *w , int y , int x , int attr1 , int attr2 , char const   *str ) ;
#line 48
int aewl_util_strlen_esc(char const   *str ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 513
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 42 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.c"
AewlWidget *aewl_label_create(int x , int y , int width___0 , char const   *text ) 
{ 
  AewlLabel *l ;
  void *tmp ;
  AewlWidget *base ;
  int tmp___0 ;

  {
  {
  {
#line 43
  tmp = malloc((size_t )sizeof(AewlLabel ));
  }
#line 43
  l = (AewlLabel *)tmp;
  }
#line 45
  if (! l) {
#line 45
    return ((AewlWidget *)((void *)0));
  }
  {
  {
#line 46
  memset((void *)l, 0, (size_t )sizeof(AewlLabel ));
  }
#line 48
  base = & l->base;
  {
#line 50
  aewl_widget_fill_defaults(base);
  }
#line 51
  base->x = x;
#line 52
  base->y = y;
  }
#line 53
  if (width___0 > 0) {
#line 53
    base->width = width___0;
  } else {
    {
    {
#line 53
    tmp___0 = aewl_util_strlen_esc(text);
    }
#line 53
    base->width = tmp___0;
    }
  }
  {
#line 54
  base->height = 1;
#line 55
  base->focusable = (_Bool)0;
#line 56
  base->shortcut = 0;
#line 58
  base->fn_repaint = & aewl_label_repaint;
#line 59
  base->fn_destroy = & aewl_label_destroy;
#line 60
  base->fn_handlekey = (int (*)(struct AewlWidget_ *self , int ch ))((void *)0);
  {
#line 62
  l->caption = strdup(text);
  }
  }
#line 63
  if (! l->caption) {
#line 63
    return ((AewlWidget *)((void *)0));
  }
#line 65
  return ((AewlWidget *)l);
}
}
#line 69 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.c"
void aewl_label_destroy(AewlWidget *w ) 
{ 
  AewlLabel *l ;

  {
  {
#line 70
  l = (AewlLabel *)w;
  {
#line 71
  free((void *)l->caption);
  }
  {
#line 72
  free((void *)w);
  }
  }
#line 73
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.c"
void aewl_label_repaint(AewlWidget *w , _Bool focused ) 
{ 
  AewlLabel *l ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 77
  l = (AewlLabel *)w;
#line 78
  n = w->width;
#line 80
  if (l->focus_peer) {
#line 80
    if ((unsigned long )l->focus_peer == (unsigned long )(w->form)->focus_widget) {
#line 81
      focused = (_Bool)1;
    }
  }
  {
  {
#line 84
  wmove(w->win, w->y, w->x);
  }
  }
  {
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 85
    tmp = n;
#line 85
    n --;
#line 85
    if (! tmp) {
#line 85
      goto while_break;
    }
    {
    {
#line 85
    waddch(w->win, (chtype const   )' ');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (focused) {
#line 88
    tmp___0 = aewl_attrs.text.highlight_focus;
  } else {
#line 88
    tmp___0 = aewl_attrs.text.highlight;
  }
#line 88
  if (focused) {
#line 88
    tmp___1 = aewl_attrs.text.focus;
  } else {
#line 88
    tmp___1 = aewl_attrs.text.normal;
  }
  {
  {
#line 88
  aewl_util_mvwaddstr(w->win, w->y, w->x, tmp___1, tmp___0, (char const   *)l->caption);
  }
  }
#line 92
  return;
}
}
#line 95 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.c"
void aewl_label_set_text(AewlLabel *l , char const   *text ) 
{ 


  {
#line 96
  if (l->caption) {
    {
    {
#line 96
    free((void *)l->caption);
    }
    }
  }
  {
  {
#line 97
  l->caption = strdup(text);
  }
  }
#line 98
  if (! l->caption) {
    {
    {
#line 98
    abort();
    }
    }
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/label.c"
void aewl_label_set_focus_peer(AewlLabel *l , AewlWidget *peer ) 
{ 


  {
#line 102
  l->focus_peer = peer;
#line 103
  return;
}
}
#line 52 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.h"
AewlWidget *aewl_button_create(int x , int y , int width___0 , int shortcut , int result ,
                               char const   *caption ) ;
#line 56
void aewl_button_destroy(AewlWidget *button ) ;
#line 59
void aewl_button_repaint(AewlWidget *button , _Bool focused ) ;
#line 62
int aewl_button_handlekey(AewlWidget *button , int ch ) ;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.c"
AewlWidget *aewl_button_create(int x , int y , int width___0 , int shortcut , int result ,
                               char const   *caption ) 
{ 
  AewlButton *b ;
  void *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 42
  tmp = malloc((size_t )sizeof(AewlButton ));
  }
#line 42
  b = (AewlButton *)tmp;
  }
#line 43
  if (! b) {
#line 43
    return ((AewlWidget *)((void *)0));
  }
  {
  {
#line 44
  memset((void *)b, 0, (size_t )sizeof(AewlButton ));
  }
  }
#line 46
  if (width___0 <= 0) {
    {
    {
#line 46
    tmp___0 = aewl_util_strlen_esc(caption);
    }
#line 46
    width___0 = tmp___0 + 2;
    }
  }
  {
  {
#line 48
  aewl_widget_fill_defaults(& b->base);
  }
#line 49
  b->base.x = x;
#line 50
  b->base.y = y;
#line 51
  b->base.height = 1;
#line 52
  b->base.width = width___0;
#line 53
  b->base.focusable = (_Bool)1;
#line 54
  b->base.shortcut = shortcut;
#line 56
  b->base.fn_repaint = & aewl_button_repaint;
#line 57
  b->base.fn_destroy = & aewl_button_destroy;
#line 58
  b->base.fn_handlekey = & aewl_button_handlekey;
  {
#line 60
  b->caption = strdup(caption);
  }
#line 61
  b->result = result;
  }
#line 63
  return ((AewlWidget *)b);
}
}
#line 66 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.c"
void aewl_button_destroy(AewlWidget *button ) 
{ 
  AewlButton *b ;

  {
#line 67
  b = (AewlButton *)button;
#line 68
  if (b->caption) {
    {
    {
#line 68
    free((void *)b->caption);
    }
    }
  }
  {
  {
#line 69
  free((void *)b);
  }
  }
#line 70
  return;
}
}
#line 72 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.c"
void aewl_button_repaint(AewlWidget *button , _Bool focused ) 
{ 
  AewlButton *b ;
  int i ;
  int cx ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 73
  b = (AewlButton *)button;
#line 77
  if (focused) {
#line 77
    (b->base.win)->_attrs = (attr_t )aewl_attrs.button.focus;
  } else {
#line 77
    (b->base.win)->_attrs = (attr_t )aewl_attrs.button.normal;
  }
  {
  {
#line 80
  wmove(b->base.win, b->base.y, b->base.x);
  }
#line 81
  i = 0;
  }
  {
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < b->base.width)) {
#line 81
      goto while_break;
    }
    {
    {
#line 81
    waddch(b->base.win, (chtype const   )' ');
    }
#line 81
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 84
  tmp = strlen((char const   *)b->caption);
  }
#line 84
  cx = (int )(((size_t )(2 * b->base.x + b->base.width) - tmp) / 2U);
  }
#line 85
  if (focused) {
#line 85
    tmp___0 = aewl_attrs.button.highlight_focus;
  } else {
#line 85
    tmp___0 = aewl_attrs.button.highlight;
  }
#line 85
  if (focused) {
#line 85
    tmp___1 = aewl_attrs.button.focus;
  } else {
#line 85
    tmp___1 = aewl_attrs.button.normal;
  }
  {
  {
#line 85
  aewl_util_mvwaddstr(b->base.win, b->base.y, cx, tmp___1, tmp___0, (char const   *)b->caption);
  }
  }
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/button.c"
int aewl_button_handlekey(AewlWidget *button , int ch ) 
{ 
  AewlButton *b ;
  int tmp ;

  {
#line 92
  b = (AewlButton *)button;
#line 93
  if (ch == 10) {
#line 93
    tmp = b->result;
  } else
#line 93
  if (ch == 32) {
#line 93
    tmp = b->result;
  } else {
#line 93
    tmp = 0;
  }
#line 93
  return (tmp);
}
}
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.h"
AewlAttrSettings aewl_attrs  ;
#line 66
void aewl_init(AewlAttrSettings const   *s ) ;
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/aewl.c"
void aewl_init(AewlAttrSettings const   *s ) 
{ 


  {
#line 41
  aewl_attrs = (AewlAttrSettings )*s;
#line 42
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.h"
AewlWidget *aewl_listbox_create(int x , int y , int width___0 , int height___0 , int shortcut ,
                                char const   *caption , int result ) ;
#line 65
void aewl_listbox_clear(AewlListBox *lb ) ;
#line 68
void aewl_listbox_add(AewlListBox *lb , char const   *text ) ;
#line 72
char const   *aewl_listbox_get(AewlListBox *lb , int i ) ;
#line 76
int aewl_listbox_get_sel(AewlListBox *lb ) ;
#line 80
_Bool aewl_listbox_set(AewlListBox *lb , int i , char const   *newvalue ) ;
#line 83
void aewl_listbox_destroy(AewlWidget *listbox ) ;
#line 86
void aewl_listbox_repaint(AewlWidget *listbox , _Bool focused ) ;
#line 89
int aewl_listbox_handlekey(AewlWidget *listbox , int ch ) ;
#line 92
void aewl_listbox_sort(AewlListBox *lb ) ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.h"
void aewl_util_erase(WINDOW *win , int x , int y , int w , int h ) ;
#line 55
void aewl_util_drawbox(WINDOW *win , int x0 , int y0 , int w , int h ) ;
#line 72
void aewl_util_addnstr(WINDOW *w , int n , char const   *str ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 756
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 43 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
AewlWidget *aewl_listbox_create(int x , int y , int width___0 , int height___0 , int shortcut ,
                                char const   *caption , int result ) 
{ 
  AewlListBox *lb ;
  void *tmp ;
  AewlWidget *base ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
  {
#line 45
  tmp = malloc((size_t )sizeof(AewlListBox ));
  }
#line 45
  lb = (AewlListBox *)tmp;
#line 46
  base = & lb->base;
  }
#line 47
  if (! lb) {
#line 47
    return ((AewlWidget *)((void *)0));
  }
  {
  {
#line 48
  memset((void *)lb, 0, (size_t )sizeof(AewlListBox ));
  }
  {
#line 50
  aewl_widget_fill_defaults(& lb->base);
  }
#line 51
  base->x = x;
#line 52
  base->y = y;
#line 53
  base->width = width___0;
#line 54
  base->height = height___0;
#line 55
  base->focusable = (_Bool)1;
#line 56
  base->shortcut = shortcut;
#line 58
  base->fn_repaint = & aewl_listbox_repaint;
#line 59
  base->fn_destroy = & aewl_listbox_destroy;
#line 60
  base->fn_handlekey = & aewl_listbox_handlekey;
  }
#line 62
  if (caption) {
    {
    {
#line 62
    tmp___0 = strdup(caption);
    }
#line 62
    lb->caption = tmp___0;
    }
  } else {
#line 62
    lb->caption = (char *)((void *)0);
  }
  {
#line 63
  lb->result = result;
#line 64
  lb->sel = 0;
#line 65
  lb->iat = 0;
#line 67
  lb->item_count = 0;
#line 68
  lb->capacity = 20;
  {
#line 69
  tmp___1 = malloc((size_t )(sizeof(char *) * 20UL));
  }
#line 69
  lb->items = (char **)tmp___1;
  }
#line 70
  if (! lb->items) {
    {
    {
#line 71
    free((void *)lb);
    }
    }
#line 72
    return ((AewlWidget *)((void *)0));
  }
#line 75
  return ((AewlWidget *)lb);
}
}
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
void aewl_listbox_clear(AewlListBox *lb ) 
{ 
  int i ;

  {
#line 81
  i = 0;
  {
  {
#line 81
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < lb->item_count)) {
#line 81
      goto while_break;
    }
#line 82
    if (*(lb->items + i)) {
      {
      {
#line 82
      free((void *)*(lb->items + i));
      }
      }
    }
#line 81
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  lb->item_count = 0;
#line 84
  lb->iat = 0;
#line 85
  lb->sel = 0;
#line 86
  return;
}
}
#line 88 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
void aewl_listbox_add(AewlListBox *lb , char const   *text ) 
{ 
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 89
  if (lb->capacity <= lb->item_count) {
    {
#line 90
    lb->capacity += 20;
    {
#line 91
    tmp = realloc((void *)lb->items, (size_t )(sizeof(char *) * (unsigned long )lb->capacity));
    }
#line 91
    lb->items = (char **)tmp;
    }
#line 92
    if (! lb->items) {
      {
      {
#line 92
      abort();
      }
      }
    }
  }
  {
#line 97
  tmp___0 = lb->item_count;
#line 97
  (lb->item_count) ++;
  {
#line 97
  tmp___1 = strdup(text);
  }
#line 97
  *(lb->items + tmp___0) = tmp___1;
  }
#line 97
  if (! tmp___1) {
    {
    {
#line 97
    abort();
    }
    }
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
char const   *aewl_listbox_get(AewlListBox *lb , int i ) 
{ 


  {
#line 101
  if (i < 0) {
#line 101
    return ((char const   *)((void *)0));
  } else
#line 101
  if (i >= lb->item_count) {
#line 101
    return ((char const   *)((void *)0));
  }
#line 102
  return ((char const   *)*(lb->items + i));
}
}
#line 105 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
_Bool aewl_listbox_set(AewlListBox *lb , int i , char const   *newvalue ) 
{ 
  char *tmp ;

  {
#line 106
  if (i < 0) {
#line 106
    return ((_Bool)0);
  } else
#line 106
  if (i >= lb->item_count) {
#line 106
    return ((_Bool)0);
  }
#line 107
  if (*(lb->items + i)) {
    {
    {
#line 107
    free((void *)*(lb->items + i));
    }
    }
  }
  {
  {
#line 108
  tmp = strdup(newvalue);
  }
#line 108
  *(lb->items + i) = tmp;
  }
#line 108
  if (! tmp) {
    {
    {
#line 108
    abort();
    }
    }
  }
#line 109
  return ((_Bool)1);
}
}
#line 112 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
void aewl_listbox_destroy(AewlWidget *listbox ) 
{ 
  AewlListBox *lb ;

  {
  {
#line 113
  lb = (AewlListBox *)listbox;
  {
#line 114
  aewl_listbox_clear(lb);
  }
  {
#line 115
  free((void *)lb->items);
  }
  }
#line 116
  if (lb->caption) {
    {
    {
#line 116
    free((void *)lb->caption);
    }
    }
  }
  {
  {
#line 117
  free((void *)lb);
  }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
void aewl_listbox_repaint(AewlWidget *listbox , _Bool focused ) 
{ 
  AewlListBox *lb ;
  AewlWidget *base ;
  int i ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 121
  lb = (AewlListBox *)listbox;
#line 122
  base = & lb->base;
#line 126
  if (focused) {
#line 126
    (base->win)->_attrs = (attr_t )aewl_attrs.frame.focus;
  } else {
#line 126
    (base->win)->_attrs = (attr_t )aewl_attrs.frame.normal;
  }
  {
  {
#line 127
  aewl_util_erase(base->win, base->x, base->y, base->width, base->height);
  }
  {
#line 128
  aewl_util_drawbox(base->win, base->x, base->y, base->width, base->height);
  }
  }
#line 131
  if (lb->caption) {
#line 132
    if (focused) {
#line 132
      tmp = aewl_attrs.frame.highlight_focus;
    } else {
#line 132
      tmp = aewl_attrs.frame.highlight;
    }
#line 132
    if (focused) {
#line 132
      tmp___0 = aewl_attrs.frame.focus;
    } else {
#line 132
      tmp___0 = aewl_attrs.frame.normal;
    }
    {
    {
#line 132
    aewl_util_mvwaddstr(base->win, base->y, base->x + 2, tmp___0, tmp, (char const   *)lb->caption);
    }
    }
  }
#line 137
  if (lb->item_count) {
#line 138
    y = base->y + 1;
#line 138
    i = lb->iat;
    {
    {
#line 138
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 138
      if (y < (base->y + base->height) - 1) {
#line 138
        if (! (i < lb->item_count)) {
#line 138
          goto while_break;
        }
      } else {
#line 138
        goto while_break;
      }
      {
      {
#line 142
      wmove(base->win, y, base->x + 1);
      }
      }
#line 143
      if (focused) {
#line 143
        if (i == lb->sel) {
#line 143
          tmp___1 = aewl_attrs.field.highlight_focus;
        } else {
#line 143
          tmp___1 = aewl_attrs.field.focus;
        }
#line 143
        (base->win)->_attrs = (attr_t )tmp___1;
      } else {
#line 143
        if (i == lb->sel) {
#line 143
          tmp___2 = aewl_attrs.field.highlight;
        } else {
#line 143
          tmp___2 = aewl_attrs.field.normal;
        }
#line 143
        (base->win)->_attrs = (attr_t )tmp___2;
      }
      {
      {
#line 144
      aewl_util_addnstr(base->win, base->width - 2, (char const   *)*(lb->items + i));
      }
#line 138
      i ++;
#line 138
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 149
  if (focused) {
#line 149
    (base->win)->_attrs = (attr_t )aewl_attrs.frame.highlight_focus;
  } else {
#line 149
    (base->win)->_attrs = (attr_t )aewl_attrs.frame.highlight;
  }
#line 151
  if (lb->iat > 0) {
    {
    {
#line 152
    tmp___3 = wmove(base->win, base->y + 1, (base->x + base->width) - 1);
    }
    }
#line 152
    if (! (tmp___3 == -1)) {
      {
      {
#line 152
      waddch(base->win, (chtype const   )'^');
      }
      }
    }
  }
#line 153
  if ((lb->iat + base->height) - 2 < lb->item_count) {
    {
    {
#line 154
    tmp___4 = wmove(base->win, (base->y + base->height) - 2, (base->x + base->width) - 1);
    }
    }
#line 154
    if (! (tmp___4 == -1)) {
      {
      {
#line 154
      waddch(base->win, (chtype const   )'v');
      }
      }
    }
  }
  {
  {
#line 158
  wmove(base->win, (base->y + 1) + (lb->sel - lb->iat), base->x + 1);
  }
  }
#line 159
  return;
}
}
#line 161 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
int aewl_listbox_handlekey(AewlWidget *listbox , int ch ) 
{ 
  AewlListBox *lb ;
  AewlWidget *base ;

  {
#line 162
  lb = (AewlListBox *)listbox;
#line 163
  base = & lb->base;
  {
#line 166
  if (ch == 259) {
#line 166
    goto case_259;
  }
#line 167
  if (ch == 258) {
#line 167
    goto case_258;
  }
#line 168
  if (ch == 339) {
#line 168
    goto case_339;
  }
#line 169
  if (ch == 338) {
#line 169
    goto case_338;
  }
#line 170
  if (ch == 10) {
#line 170
    goto case_10;
  }
#line 165
  goto switch_break;
  case_259: /* CIL Label */ 
#line 166
  (lb->sel) --;
#line 166
  goto switch_break;
  case_258: /* CIL Label */ 
#line 167
  (lb->sel) ++;
#line 167
  goto switch_break;
  case_339: /* CIL Label */ 
#line 168
  lb->sel -= base->height - 2;
#line 168
  goto switch_break;
  case_338: /* CIL Label */ 
#line 169
  lb->sel += base->height - 2;
#line 169
  goto switch_break;
  case_10: /* CIL Label */ 
#line 170
  return (lb->result);
  switch_break: /* CIL Label */ ;
  }
#line 174
  if (lb->sel < 0) {
#line 174
    lb->sel = 0;
  }
#line 175
  if (lb->sel >= lb->item_count) {
#line 175
    lb->sel = lb->item_count - 1;
  }
#line 178
  if (lb->sel < lb->iat) {
#line 178
    lb->iat = lb->sel;
  }
#line 179
  if (lb->sel >= lb->iat + (base->height - 2)) {
#line 180
    lb->iat = (lb->sel - (base->height - 2)) + 1;
  }
#line 182
  return (0);
}
}
#line 185 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
int aewl_listbox_get_sel(AewlListBox *lb ) 
{ 


  {
#line 186
  if (lb->sel >= 0) {
#line 186
    if (lb->sel < lb->item_count) {
#line 186
      return (lb->sel);
    }
  }
#line 187
  return (-1);
}
}
#line 190 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
static int _compar(void const   *p1 , void const   *p2 ) 
{ 
  char const   **a ;
  char const   **b ;
  int tmp ;

  {
  {
#line 191
  a = (char const   **)p1;
#line 192
  b = (char const   **)p2;
  {
#line 193
  tmp = strcmp(*a, *b);
  }
  }
#line 193
  return (tmp);
}
}
#line 196 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
void aewl_listbox_sort(AewlListBox *lb ) 
{ 


  {
  {
  {
#line 197
  qsort((void *)lb->items, (size_t )lb->item_count, (size_t )sizeof(char const   *),
        & _compar);
  }
  }
#line 198
  return;
}
}
#line 49 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.h"
AewlForm *aewl_form_create(WINDOW *w ) ;
#line 53
void aewl_form_add_widget(AewlForm *f___0 , AewlWidget *wid ) ;
#line 62
void aewl_form_paint(AewlForm *f___0 , _Bool refresh___0 ) ;
#line 86
int aewl_form_dispatch_key(AewlForm *f___0 , int ch ) ;
#line 90
void aewl_form_destroy(AewlForm *f___0 ) ;
#line 93
AewlWidget *aewl_form_get_focus_widget(AewlForm *fn ) ;
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.c"
AewlForm *aewl_form_create(WINDOW *w ) 
{ 
  AewlForm *f___0 ;
  void *tmp ;

  {
  {
  {
#line 39
  tmp = malloc((size_t )sizeof(struct AewlForm_ ));
  }
#line 39
  f___0 = (AewlForm *)tmp;
  }
#line 40
  if (! f___0) {
#line 40
    return ((AewlForm *)((void *)0));
  }
#line 42
  f___0->win = w;
#line 43
  f___0->first_widget = (AewlWidget *)((void *)0);
#line 44
  f___0->last_widget = (AewlWidget *)((void *)0);
#line 45
  f___0->focus_widget = (AewlWidget *)((void *)0);
#line 46
  return (f___0);
}
}
#line 49 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.c"
void aewl_form_add_widget(AewlForm *f___0 , AewlWidget *wid ) 
{ 
  AewlWidget *tmp ;
  AewlWidget *tmp___0 ;

  {
#line 50
  wid->win = f___0->win;
#line 51
  wid->form = f___0;
#line 52
  wid->next = (struct AewlWidget_ *)((void *)0);
#line 54
  if (! f___0->first_widget) {
#line 55
    tmp = wid;
#line 55
    f___0->last_widget = tmp;
#line 55
    f___0->first_widget = tmp;
  } else {
#line 57
    tmp___0 = wid;
#line 57
    f___0->last_widget = tmp___0;
#line 57
    (f___0->last_widget)->next = tmp___0;
  }
#line 61
  if (! f___0->focus_widget) {
#line 61
    if (wid->focusable) {
#line 61
      f___0->focus_widget = wid;
    }
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.c"
void aewl_form_paint(AewlForm *f___0 , _Bool refresh___0 ) 
{ 
  AewlWidget *w ;

  {
#line 68
  w = f___0->first_widget;
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 68
    if (! w) {
#line 68
      goto while_break;
    }
#line 69
    if ((unsigned long )w != (unsigned long )f___0->focus_widget) {
#line 69
      if (w->fn_repaint) {
        {
        {
#line 69
        (*(w->fn_repaint))(w, (_Bool)0);
        }
        }
      }
    }
#line 68
    w = w->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  if (f___0->focus_widget) {
#line 72
    if ((f___0->focus_widget)->fn_repaint) {
      {
      {
#line 73
      (*((f___0->focus_widget)->fn_repaint))(f___0->focus_widget, (_Bool)1);
      }
      }
    }
  }
#line 75
  if (refresh___0) {
    {
    {
#line 75
    wrefresh(f___0->win);
    }
    }
  }
#line 76
  return;
}
}
#line 78 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.c"
int aewl_form_dispatch_key(AewlForm *f___0 , int ch ) 
{ 
  AewlWidget *w ;
  int result ;

  {
#line 82
  if (ch == 9) {
#line 82
    if (f___0->focus_widget) {
      {
      {
#line 88
      while (1) {
        while_continue___1: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 89
        f___0->focus_widget = (f___0->focus_widget)->next;
#line 90
        if (! f___0->focus_widget) {
#line 90
          f___0->focus_widget = f___0->first_widget;
        }
#line 88
        if (! (! (f___0->focus_widget)->focusable)) {
#line 88
          goto while_break;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 93
      aewl_form_paint(f___0, (_Bool)1);
      }
      }
#line 94
      return (0);
    }
  }
#line 99
  w = f___0->first_widget;
  {
  {
#line 99
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 99
    if (! w) {
#line 99
      goto while_break___0;
    }
#line 100
    if (w->shortcut == ch) {
#line 100
      if (w->focusable) {
        {
#line 101
        f___0->focus_widget = w;
        {
#line 102
        aewl_form_paint(f___0, (_Bool)1);
        }
        }
#line 103
        return (0);
      }
    }
#line 99
    w = w->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  if (f___0->focus_widget) {
#line 108
    if ((f___0->focus_widget)->fn_handlekey) {
      {
      {
#line 109
      result = (*((f___0->focus_widget)->fn_handlekey))(f___0->focus_widget, ch);
      }
      {
#line 110
      aewl_form_paint(f___0, (_Bool)1);
      }
      }
#line 111
      return (result);
    }
  }
#line 114
  return (0);
}
}
#line 117 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.c"
void aewl_form_destroy(AewlForm *f___0 ) 
{ 
  AewlWidget *tmp ;
  AewlWidget *w ;

  {
#line 118
  w = f___0->first_widget;
  {
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 120
    if (! w) {
#line 120
      goto while_break;
    }
    {
#line 121
    tmp = w->next;
    {
#line 122
    (*(w->fn_destroy))(w);
    }
#line 123
    w = tmp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 126
  free((void *)f___0);
  }
  }
#line 127
  return;
}
}
#line 129 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/form.c"
AewlWidget *aewl_form_get_focus_widget(AewlForm *fn ) 
{ 


  {
#line 130
  return (fn->focus_widget);
}
}
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.h"
AewlWidget *aewl_field_create(int x , int y , int width___0 , int shortcut , int result ,
                              char const   *text ) ;
#line 54
void aewl_field_destroy(AewlWidget *w ) ;
#line 57
void aewl_field_repaint(AewlWidget *w , _Bool focused ) ;
#line 60
int aewl_field_handlekey(AewlWidget *w , int ch ) ;
#line 63
void aewl_field_set_text(AewlField *f___0 , char const   *text ) ;
#line 66
char const   *aewl_field_get_text(AewlField *f___0 ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap(AewlField *f___0 , int cap ) ;
#line 45
static void buf_insert_char(char *buf___15 , int cap , int pos , int ch ) ;
#line 46
static void buf_del_char(char *buf___15 , int cap , int pos , int ch ) ;
#line 48 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
AewlWidget *aewl_field_create(int x , int y , int width___0 , int shortcut , int result ,
                              char const   *text ) 
{ 
  AewlField *f___0 ;
  void *tmp ;
  AewlWidget *base ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
  {
#line 50
  tmp = malloc((size_t )sizeof(AewlField ));
  }
#line 50
  f___0 = (AewlField *)tmp;
  }
#line 53
  if (! f___0) {
#line 53
    return ((AewlWidget *)((void *)0));
  }
  {
  {
#line 55
  memset((void *)f___0, 0, (size_t )sizeof(AewlField ));
  }
#line 56
  base = & f___0->base;
  {
#line 58
  aewl_widget_fill_defaults(base);
  }
#line 59
  base->x = x;
#line 60
  base->y = y;
#line 61
  base->width = width___0;
#line 62
  base->height = 1;
#line 63
  base->focusable = (_Bool)1;
#line 64
  base->shortcut = shortcut;
#line 65
  base->fn_repaint = & aewl_field_repaint;
#line 66
  base->fn_destroy = & aewl_field_destroy;
#line 67
  base->fn_handlekey = & aewl_field_handlekey;
#line 69
  f___0->result = result;
#line 70
  f___0->pos = 0;
#line 71
  tmp___0 = 20;
#line 71
  f___0->cap = tmp___0;
  {
#line 71
  tmp___1 = malloc((size_t )tmp___0);
  }
#line 71
  f___0->buffer = (char *)tmp___1;
  }
#line 72
  if (! f___0->buffer) {
#line 72
    return ((AewlWidget *)((void *)0));
  }
#line 74
  if (text) {
    {
    {
#line 74
    aewl_field_set_text(f___0, text);
    }
    }
  }
#line 76
  return ((AewlWidget *)f___0);
}
}
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
void aewl_field_set_text(AewlField *f___0 , char const   *text ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
  {
#line 80
  tmp = strlen(text);
  }
#line 80
  len = (int )tmp;
  {
#line 81
  aewl_field_ensure_cap(f___0, len + 1);
  }
  {
#line 82
  strcpy((char */* __restrict  */)f___0->buffer, (char const   */* __restrict  */)text);
  }
  }
#line 84
  if (f___0->pos > len) {
#line 84
    f___0->pos = len;
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
char const   *aewl_field_get_text(AewlField *f___0 ) 
{ 


  {
#line 88
  return ((char const   *)f___0->buffer);
}
}
#line 91 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
void aewl_field_destroy(AewlWidget *w ) 
{ 
  AewlField *f___0 ;

  {
#line 92
  f___0 = (AewlField *)w;
#line 93
  if (f___0->buffer) {
    {
    {
#line 93
    free((void *)f___0->buffer);
    }
    }
  }
  {
  {
#line 94
  free((void *)f___0);
  }
  }
#line 95
  return;
}
}
#line 97 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
void aewl_field_repaint(AewlWidget *w , _Bool focused ) 
{ 
  int i ;
  AewlField *f___0 ;
  char const   *str ;

  {
#line 99
  f___0 = (AewlField *)w;
#line 100
  str = (char const   *)f___0->buffer;
#line 102
  if (focused) {
#line 102
    (w->win)->_attrs = (attr_t )aewl_attrs.field.focus;
  } else {
#line 102
    (w->win)->_attrs = (attr_t )aewl_attrs.field.normal;
  }
  {
  {
#line 105
  wmove(w->win, w->y, w->x);
  }
#line 106
  i = 0;
  }
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < w->width)) {
#line 106
      goto while_break;
    }
#line 107
    if (*str) {
      {
      {
#line 108
      waddch(w->win, (chtype const   )*str);
      }
#line 109
      str ++;
      }
    } else {
      {
#line 112
      (w->win)->_attrs = (attr_t )aewl_attrs.field_pad;
      {
#line 113
      waddch(w->win, (chtype const   )'_');
      }
      }
    }
#line 106
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 119
  wmove(w->win, w->y, w->x + f___0->pos);
  }
  }
#line 120
  return;
}
}
#line 122 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
int aewl_field_handlekey(AewlWidget *w , int ch ) 
{ 
  AewlField *f___0 ;
  int len ;
  size_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 123
  f___0 = (AewlField *)w;
  {
#line 124
  tmp = strlen((char const   *)f___0->buffer);
  }
#line 124
  len = (int )tmp;
  }
#line 127
  if (ch >= 32) {
#line 127
    if (ch <= 255) {
#line 127
      if (ch != 127) {
        {
        {
#line 128
        aewl_field_ensure_cap(f___0, len + 2);
        }
        {
#line 129
        buf_insert_char(f___0->buffer, f___0->cap, f___0->pos, ch);
        }
#line 130
        (f___0->pos) ++;
        }
#line 131
        return (0);
      }
    }
  }
  {
#line 136
  if (ch == 10) {
#line 136
    goto case_10;
  }
#line 137
  if (ch == 261) {
#line 137
    goto case_261;
  }
#line 139
  if (ch == 260) {
#line 139
    goto case_260;
  }
#line 140
  if (ch == 262) {
#line 140
    goto case_262;
  }
#line 141
  if (ch == 360) {
#line 141
    goto case_360;
  }
#line 142
  if (ch == 21) {
#line 142
    goto case_21;
  }
#line 144
  if (ch == 8) {
#line 144
    goto case_8;
  }
#line 144
  if (ch == 263) {
#line 144
    goto case_8;
  }
#line 151
  if (ch == 330) {
#line 151
    goto case_330;
  }
#line 135
  goto switch_break;
  case_10: /* CIL Label */ 
#line 136
  return (f___0->result);
  case_261: /* CIL Label */ 
#line 137
  if (f___0->pos < len) {
#line 137
    (f___0->pos) ++;
  }
#line 138
  goto switch_break;
  case_260: /* CIL Label */ 
#line 139
  if (f___0->pos) {
#line 139
    (f___0->pos) --;
  }
#line 139
  goto switch_break;
  case_262: /* CIL Label */ 
#line 140
  f___0->pos = 0;
#line 140
  goto switch_break;
  case_360: /* CIL Label */ 
#line 141
  f___0->pos = len;
#line 141
  goto switch_break;
  case_21: /* CIL Label */ 
  {
  {
#line 142
  aewl_field_set_text(f___0, "");
  }
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  case_263: /* CIL Label */ 
#line 145
  if (f___0->pos) {
    {
    {
#line 146
    buf_del_char(f___0->buffer, f___0->cap, f___0->pos - 1, ch);
    }
#line 147
    (f___0->pos) --;
    }
  }
#line 149
  goto switch_break;
  case_330: /* CIL Label */ 
#line 152
  if (f___0->pos < len) {
    {
    {
#line 152
    buf_del_char(f___0->buffer, f___0->cap, f___0->pos, ch);
    }
    }
  }
#line 153
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 156
  return (0);
}
}
#line 160 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap(AewlField *f___0 , int cap ) 
{ 
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 161
  if (f___0->cap >= cap) {
#line 161
    return;
  }
  {
#line 163
  tmp___0 = cap + 20;
#line 163
  f___0->cap = tmp___0;
  {
#line 163
  tmp___1 = realloc((void *)f___0->buffer, (size_t )tmp___0);
  }
#line 163
  tmp = (char *)tmp___1;
#line 163
  f___0->buffer = tmp;
  }
#line 163
  if (! tmp) {
    {
    {
#line 164
    abort();
    }
    }
  }
#line 165
  return;
}
}
#line 167 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_insert_char(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 171
  i = cap - 1;
  {
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i > pos)) {
#line 171
      goto while_break;
    }
#line 171
    *(buf___15 + i) = *(buf___15 + (i - 1));
#line 171
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  *(buf___15 + pos) = (char )ch;
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_del_char(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 177
  i = pos;
  {
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < cap - 1)) {
#line 177
      goto while_break;
    }
#line 177
    *(buf___15 + i) = *(buf___15 + (i + 1));
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 36 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/widget.c"
void aewl_widget_fill_defaults(AewlWidget *w ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 37
  w->win = stdscr;
#line 38
  tmp = 0;
#line 38
  w->y = tmp;
#line 38
  w->x = tmp;
#line 39
  tmp___0 = 0;
#line 39
  w->height = tmp___0;
#line 39
  w->width = tmp___0;
#line 40
  w->shortcut = 0;
#line 41
  w->focusable = (_Bool)0;
#line 43
  w->fn_repaint = (void (*)(struct AewlWidget_ *self , _Bool focused ))((void *)0);
#line 44
  w->fn_handlekey = (int (*)(struct AewlWidget_ *self , int ch ))((void *)0);
#line 45
  w->fn_destroy = (void (*)(struct AewlWidget_ *self ))((void *)0);
#line 46
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.h"
void aewl_util_drawline_h(WINDOW *w , int x0 , int x1 , int y , int lc , int mc ,
                          int rc ) ;
#line 66
void aewl_util_drawline_v(WINDOW *w , int x , int y0 , int y1 , int tc , int mc ,
                          int bc ) ;
#line 37 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
void aewl_util_mvwaddstr(WINDOW *w , int y , int x , int attr1 , int attr2 , char const   *str ) 
{ 


  {
  {
#line 39
  w->_attrs = (attr_t )attr1;
  {
#line 40
  wmove(w, y, x);
  }
  }
  {
  {
#line 42
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 42
    if (! *str) {
#line 42
      goto while_break;
    }
#line 43
    if ((int const   )*str == 38) {
      {
#line 44
      str ++;
#line 45
      w->_attrs = (attr_t )attr2;
      {
#line 46
      waddch(w, (chtype const   )*str);
      }
#line 47
      w->_attrs = (attr_t )attr1;
#line 48
      str ++;
      }
#line 49
      goto while_continue;
    }
    {
    {
#line 52
    waddch(w, (chtype const   )*str);
    }
#line 53
    str ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
int aewl_util_strlen_esc(char const   *str ) 
{ 
  int l ;

  {
#line 58
  l = 0;
  {
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 59
    if (! *str) {
#line 59
      goto while_break;
    }
#line 60
    if ((int const   )*str == 38) {
#line 61
      str += 2;
#line 62
      l ++;
#line 63
      goto while_continue;
    }
#line 66
    str ++;
#line 67
    l ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (l);
}
}
#line 73 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
void aewl_util_drawbox(WINDOW *win , int x0 , int y0 , int w , int h ) 
{ 


  {
  {
  {
#line 75
  aewl_util_drawline_v(win, x0, y0, (y0 + h) - 1, (int )acs_map[(unsigned char )'l'],
                       (int )acs_map[(unsigned char )'x'], (int )acs_map[(unsigned char )'m']);
  }
  {
#line 78
  aewl_util_drawline_v(win, (x0 + w) - 1, y0, (y0 + h) - 1, (int )acs_map[(unsigned char )'k'],
                       (int )acs_map[(unsigned char )'x'], (int )acs_map[(unsigned char )'j']);
  }
  {
#line 81
  aewl_util_drawline_h(win, x0 + 1, (x0 + w) - 2, y0, (int )acs_map[(unsigned char )'q'],
                       (int )acs_map[(unsigned char )'q'], (int )acs_map[(unsigned char )'q']);
  }
  {
#line 84
  aewl_util_drawline_h(win, x0 + 1, (x0 + w) - 2, (y0 + h) - 1, (int )acs_map[(unsigned char )'q'],
                       (int )acs_map[(unsigned char )'q'], (int )acs_map[(unsigned char )'q']);
  }
  }
#line 86
  return;
}
}
#line 88 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
void aewl_util_drawline_h(WINDOW *w , int x0 , int x1 , int y , int lc , int mc ,
                          int rc ) 
{ 
  int x ;
  int tmp ;

  {
#line 91
  if (x0 > x1) {
#line 91
    tmp = x0;
#line 91
    x0 = x1;
#line 91
    x1 = tmp;
  }
#line 93
  x = x0;
  {
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 93
    if (! (x <= x1)) {
#line 93
      goto while_break;
    }
    {
    {
#line 94
    wmove(w, y, x);
    }
    }
#line 95
    if (x == x0) {
      {
      {
#line 95
      waddch(w, (chtype const   )lc);
      }
      }
    } else
#line 96
    if (x == x1) {
      {
      {
#line 96
      waddch(w, (chtype const   )rc);
      }
      }
    } else {
      {
      {
#line 97
      waddch(w, (chtype const   )mc);
      }
      }
    }
#line 93
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
void aewl_util_drawline_v(WINDOW *w , int x , int y0 , int y1 , int tc , int mc ,
                          int bc ) 
{ 
  int y ;
  int tmp ;

  {
#line 104
  if (y0 > y1) {
#line 104
    tmp = y0;
#line 104
    y0 = y1;
#line 104
    y1 = tmp;
  }
#line 106
  y = y0;
  {
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! (y <= y1)) {
#line 106
      goto while_break;
    }
    {
    {
#line 107
    wmove(w, y, x);
    }
    }
#line 108
    if (y == y0) {
      {
      {
#line 108
      waddch(w, (chtype const   )tc);
      }
      }
    } else
#line 109
    if (y == y1) {
      {
      {
#line 109
      waddch(w, (chtype const   )bc);
      }
      }
    } else {
      {
      {
#line 110
      waddch(w, (chtype const   )mc);
      }
      }
    }
#line 106
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return;
}
}
#line 114 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
void aewl_util_addnstr(WINDOW *w , int n , char const   *str ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 115
    tmp___0 = n;
#line 115
    n --;
#line 115
    if (tmp___0) {
#line 115
      if (! *str) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
    {
#line 115
    tmp = str;
#line 115
    str ++;
    {
#line 115
    waddch(w, (chtype const   )*tmp);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 118 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/util.c"
void aewl_util_erase(WINDOW *win , int x , int y , int w , int h ) 
{ 
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp___1 = h;
#line 121
    h --;
#line 121
    if (! tmp___1) {
#line 121
      goto while_break;
    }
    {
#line 122
    j = w;
#line 123
    tmp = y;
#line 123
    y ++;
    {
#line 123
    wmove(win, tmp, x);
    }
    }
    {
    {
#line 124
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 124
      tmp___0 = j;
#line 124
      j --;
#line 124
      if (! tmp___0) {
#line 124
        goto while_break___0;
      }
      {
      {
#line 124
      waddch(win, (chtype const   )' ');
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return;
}
}
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 70 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.h"
char const   *aeff_get_error(void) ;
#line 99 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.h"
Document *document_load_from(char const   *filename ) ;
#line 105
Cell document_calc_effective_cell(Document *doc___0 , int x , int y ) ;
#line 65 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.h"
VirtualLayer *vlayer_create_from_layer(Layer *l ) ;
#line 70
VirtualLayer *vlayer_create_from_composite(Document *doc___0 ) ;
#line 74
void vlayer_destroy(VirtualLayer *vl ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
_Bool clear_screen  =    (_Bool)0;
#line 46 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
_Bool suppress_newlines  =    (_Bool)0;
#line 48 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
_Bool use_color  =    (_Bool)1;
#line 49 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
char *outputfile  ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
FILE *f  ;
#line 53 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
Document *doc  ;
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
int layer_number  ;
#line 55 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
Layer *lyr  ;
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
int width  ;
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
int height  ;
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
void get_decoded_cell(int x , int y , DecodedCell *dec ) 
{ 
  Cell c ;
  Cell tmp ;

  {
#line 69
  if (lyr) {
    {
    {
#line 69
    decode_cell((Cell const   *)(*(lyr->cells + x) + y), dec);
    }
    }
  } else {
    {
    {
#line 71
    tmp = document_calc_effective_cell(doc, x, y);
    }
#line 71
    c = tmp;
    {
#line 72
    decode_cell((Cell const   *)(& c), dec);
    }
    }
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
void output_text(void) 
{ 
  VirtualLayer *vl ;
  _Bool tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 79
  if (lyr) {
    {
    {
#line 79
    vl = vlayer_create_from_layer(lyr);
    }
    }
  } else {
    {
    {
#line 80
    vl = vlayer_create_from_composite(doc);
    }
    }
  }
#line 82
  if (! vl) {
    {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error creating virtual layer. Is the document empty?\n");
    }
    {
#line 84
    exit(2);
    }
    }
  }
#line 87
  if (clear_screen) {
    {
    {
#line 87
    fputs((char const   */* __restrict  */)"\033[2J\033[H", (FILE */* __restrict  */)f);
    }
    }
  }
  {
  {
#line 88
  tmp = export_vlayer_to_ansi(vl, use_color, (_Bool )(! suppress_newlines), (_Bool)0,
                              f);
  }
  }
#line 88
  if (! tmp) {
    {
    {
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error exporting virtual layer to ansi.\n");
    }
    {
#line 90
    exit(2);
    }
    }
  }
  {
  {
#line 93
  vlayer_destroy(vl);
  }
  }
#line 94
  return;
}
}
#line 105 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
static char *hex_codes[16]  = 
#line 105
  {      (char *)"000000",      (char *)"990000",      (char *)"009900",      (char *)"999900", 
        (char *)"000099",      (char *)"990099",      (char *)"009999",      (char *)"999999", 
        (char *)"404040",      (char *)"ff0000",      (char *)"00ff00",      (char *)"ffff00", 
        (char *)"0000ff",      (char *)"ff00ff",      (char *)"00ffff",      (char *)"ffffff"};
#line 111 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
void output_html(void) 
{ 
  int x ;
  int y ;
  struct html_output_state_t cur_state ;
  DecodedCell dec ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 116
  fputs((char const   */* __restrict  */)"<html><body style=\"color:#ffffff;background-color:#000000;\"><pre>",
        (FILE */* __restrict  */)f);
  }
#line 119
  y = 0;
  }
  {
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (y < height)) {
#line 119
      goto while_break;
    }
#line 120
    x = 0;
    {
    {
#line 120
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 120
      if (! (x < width)) {
#line 120
        goto while_break___0;
      }
      {
      {
#line 121
      get_decoded_cell(x, y, & dec);
      }
      }
#line 124
      if (use_color) {
#line 124
        if ((int )dec.blink != (int )cur_state.blink_tag_open) {
#line 125
          if (dec.blink) {
#line 125
            tmp = "";
          } else {
#line 125
            tmp = "/";
          }
          {
          {
#line 125
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"<%sblink>",
                  tmp);
          }
#line 126
          cur_state.blink_tag_open = dec.blink;
          }
        }
      }
#line 130
      if (use_color) {
#line 130
        if (dec.fg != cur_state.color) {
#line 130
          goto _L;
        } else
#line 130
        if (dec.bg != cur_state.bgcolor) {
          _L: /* CIL Label */ 
#line 132
          if (cur_state.font_tag_open) {
            {
            {
#line 132
            fputs((char const   */* __restrict  */)"</span>", (FILE */* __restrict  */)f);
            }
            }
          }
          {
          {
#line 133
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"<span style=\"color:#%s;background-color:#%s;\">",
                  hex_codes[dec.fg], hex_codes[dec.bg]);
          }
#line 135
          cur_state.color = dec.fg;
#line 136
          cur_state.bgcolor = dec.bg;
#line 137
          cur_state.font_tag_open = (_Bool)1;
          }
        }
      }
#line 141
      if (dec.ch >= 0) {
#line 141
        if (dec.ch <= 32) {
          {
          {
#line 141
          fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)f);
          }
          }
        } else {
#line 141
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 142
      if (dec.ch == 38) {
        {
        {
#line 142
        fputs((char const   */* __restrict  */)"&amp;", (FILE */* __restrict  */)f);
        }
        }
      } else
#line 143
      if (dec.ch == 60) {
        {
        {
#line 143
        fputs((char const   */* __restrict  */)"&lt;", (FILE */* __restrict  */)f);
        }
        }
      } else
#line 144
      if (dec.ch == 62) {
        {
        {
#line 144
        fputs((char const   */* __restrict  */)"&gt;", (FILE */* __restrict  */)f);
        }
        }
      } else {
        {
        {
#line 145
        fputc(dec.ch, f);
        }
        }
      }
#line 120
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 147
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)f);
    }
#line 119
    y ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if (cur_state.font_tag_open) {
    {
    {
#line 151
    fputs((char const   */* __restrict  */)"</span>", (FILE */* __restrict  */)f);
    }
    }
  }
#line 152
  if (cur_state.blink_tag_open) {
    {
    {
#line 152
    fputs((char const   */* __restrict  */)"</blink>", (FILE */* __restrict  */)f);
    }
    }
  }
  {
  {
#line 153
  fputs((char const   */* __restrict  */)"</pre></body></html>", (FILE */* __restrict  */)f);
  }
  }
#line 154
  return;
}
}
#line 156 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
void output_comment(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 157
  printf((char const   */* __restrict  */)"%s\n", doc->metainfo);
  }
  }
#line 158
  return;
}
}
#line 160 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
void output_layercount(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 161
  printf((char const   */* __restrict  */)"%d\n", doc->layer_count);
  }
  }
#line 162
  return;
}
}
#line 185 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
void rtfm(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 186
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Syntax: aecat [-b] [-c] [-{n|N}] [{-p | -l <layer_num>}]\n               [-f <format>] [-o <output_file>] inputfile\n\n   -f : specifies output format - can be text, html or comment\n        The \'comment\' format extracts document metadata.\n   -c : prepend a \'clear screen\' escape sequence (only valid when\n        outputting text)\n   -o : writes output to specified file rather than stdout\n   -b : disables output of color (only characters will be\n        printed).\n   -l : specifies which layer of the document is to be used.\n        (must be an index, not a layer name). By default,\n        layer 0 will be used.\n   -L : displays how many layers the document has.\n   -p : exports a composite, that is, overlays all visible layers,\n        paying attention to layer transparency, etc. The size of the\n        composite will be the size of the first layer\n   -n : suppress output of newlines\n   -h : prints this help text\n");
  }
  {
#line 187
  exit(1);
  }
  }
}
}
#line 196
int main(int argc , char **argv ) ;
#line 196 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
static char optstring[13]  = 
#line 196
  {      (char )'o',      (char )':',      (char )'c',      (char )'h', 
        (char )'l',      (char )':',      (char )'L',      (char )'b', 
        (char )'p',      (char )'f',      (char )':',      (char )'n', 
        (char )'\000'};
#line 195 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
int main(int argc , char **argv ) 
{ 
  char *inputfile ;
  int ch ;
  int out_fmt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 200
  out_fmt = 0;
  {
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 202
    ch = getopt(argc, (char * const  *)argv, (char const   *)(optstring));
    }
    }
#line 202
    if (! (0 < ch)) {
#line 202
      goto while_break;
    }
    {
#line 204
    if (ch == 99) {
#line 204
      goto case_99;
    }
#line 205
    if (ch == 111) {
#line 205
      goto case_111;
    }
#line 206
    if (ch == 108) {
#line 206
      goto case_108;
    }
#line 207
    if (ch == 76) {
#line 207
      goto case_76;
    }
#line 208
    if (ch == 112) {
#line 208
      goto case_112;
    }
#line 209
    if (ch == 98) {
#line 209
      goto case_98;
    }
#line 210
    if (ch == 110) {
#line 210
      goto case_110;
    }
#line 211
    if (ch == 102) {
#line 211
      goto case_102;
    }
#line 223
    goto switch_default;
    case_99: /* CIL Label */ 
#line 204
    clear_screen = (_Bool)1;
#line 204
    goto switch_break;
    case_111: /* CIL Label */ 
    {
    {
#line 205
    outputfile = strdup((char const   *)optarg);
    }
    }
#line 205
    goto switch_break;
    case_108: /* CIL Label */ 
    {
    {
#line 206
    layer_number = atoi((char const   *)optarg);
    }
    }
#line 206
    goto switch_break;
    case_76: /* CIL Label */ 
#line 207
    out_fmt = 4;
#line 207
    goto switch_break;
    case_112: /* CIL Label */ 
#line 208
    layer_number = -1;
#line 208
    goto switch_break;
    case_98: /* CIL Label */ 
#line 209
    use_color = (_Bool)0;
#line 209
    goto switch_break;
    case_110: /* CIL Label */ 
#line 210
    suppress_newlines = (_Bool)1;
#line 210
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 212
    tmp___1 = strcmp((char const   *)optarg, "text");
    }
    }
#line 212
    if (tmp___1 == 0) {
#line 213
      out_fmt = 1;
    } else {
      {
      {
#line 214
      tmp___0 = strcmp((char const   *)optarg, "html");
      }
      }
#line 214
      if (tmp___0 == 0) {
#line 215
        out_fmt = 2;
      } else {
        {
        {
#line 216
        tmp = strcmp((char const   *)optarg, "comment");
        }
        }
#line 216
        if (tmp == 0) {
#line 217
          out_fmt = 3;
        } else {
          {
          {
#line 219
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid format \"%s\"\n",
                  optarg);
          }
          {
#line 220
          exit(1);
          }
          }
        }
      }
    }
#line 222
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 223
    rtfm();
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  if (! out_fmt) {
#line 228
    out_fmt = 1;
  }
#line 230
  if (out_fmt != 1) {
#line 230
    if (clear_screen) {
      {
      {
#line 231
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: -c option only valid when outputting text\n");
      }
      }
    }
  }
#line 233
  if (out_fmt != 1) {
#line 233
    if (suppress_newlines) {
      {
      {
#line 234
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: -n option only valid when outputting text\n");
      }
      }
    }
  }
#line 237
  if (optind >= argc) {
    {
    {
#line 237
    rtfm();
    }
    }
  }
  {
  {
#line 238
  inputfile = strdup((char const   *)*(argv + optind));
  }
  {
#line 240
  doc = document_load_from((char const   *)inputfile);
  }
  }
#line 240
  if (! doc) {
    {
    {
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error loading document from %s (bad format?).\n",
            inputfile);
    }
    {
#line 243
    tmp___2 = aeff_get_error();
    }
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error description:\n   %s\n",
            tmp___2);
    }
    {
#line 244
    exit(1);
    }
    }
  }
#line 247
  if (layer_number >= doc->layer_count) {
#line 248
    if (layer_number) {
      {
      {
#line 249
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Document %s does not have the specified layer: %d\n",
              inputfile, layer_number);
      }
      }
    } else {
      {
      {
#line 252
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Document %s has no layers.\n",
              inputfile);
      }
      }
    }
    {
    {
#line 253
    exit(1);
    }
    }
  }
#line 256
  width = (*(doc->layers + 0))->width;
#line 257
  height = (*(doc->layers + 0))->height;
#line 258
  if (layer_number >= 0) {
#line 258
    lyr = *(doc->layers + layer_number);
  } else {
#line 258
    lyr = (Layer *)((void *)0);
  }
#line 260
  if (outputfile) {
    {
    {
#line 260
    f = fopen((char const   */* __restrict  */)outputfile, (char const   */* __restrict  */)"w");
    }
    }
#line 260
    if (f) {
#line 264
      f = stdout;
    } else {
      {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening %s for writing.\n",
              outputfile);
      }
      {
#line 262
      exit(1);
      }
      }
    }
  } else {
#line 264
    f = stdout;
  }
  {
#line 267
  if (out_fmt == 1) {
#line 267
    goto case_1;
  }
#line 268
  if (out_fmt == 2) {
#line 268
    goto case_2;
  }
#line 269
  if (out_fmt == 3) {
#line 269
    goto case_3;
  }
#line 270
  if (out_fmt == 4) {
#line 270
    goto case_4;
  }
#line 266
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
  {
#line 267
  output_text();
  }
  }
#line 267
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
  {
#line 268
  output_html();
  }
  }
#line 268
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
  {
#line 269
  output_comment();
  }
  }
#line 269
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
  {
#line 270
  output_layercount();
  }
  }
#line 270
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 273
  if ((unsigned long )f != (unsigned long )stdout) {
    {
    {
#line 273
    fclose(f);
    }
    }
  }
#line 274
  return (0);
}
}
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 615
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 712
extern int system(char const   *__command ) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 283 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 575 "/usr/include/ncurses.h"
extern int endwin(void) ;
#line 764
extern int wclear(WINDOW * ) ;
#line 802
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
char *dstrset(char **ptr , char const   *new_value ) ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.h"
void ui_message(char const   *msg___1 , int error ) ;
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char tmpname[64]  ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char buf[128]  ;
#line 46 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
void edit_metainfo(void) 
{ 
  char *editor ;
  FILE *f___0 ;
  int fd ;
  int ret ;
  int size ;
  int i ;
  mode_t oldumask ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 54
  editor = getenv("VISUAL");
  }
  }
#line 55
  if (! editor) {
    {
    {
#line 55
    editor = getenv("EDITOR");
    }
    }
  }
#line 56
  if (! editor) {
#line 56
    editor = (char *)"sensible-editor";
  }
  {
  {
#line 59
  strcpy((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"/tmp/aewan-XXXXXX");
  }
  {
#line 60
  oldumask = umask((__mode_t )63);
  }
  {
#line 61
  fd = mkstemp(tmpname);
  }
  {
#line 62
  umask(oldumask);
  }
  }
#line 65
  if (fd < 0) {
    {
    {
#line 66
    tmp = __errno_location();
    }
    {
#line 66
    tmp___0 = strerror(*tmp);
    }
    {
#line 66
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"ERROR creating temp file: %s",
            tmp___0);
    }
    {
#line 67
    ui_message((char const   *)(buf), 1);
    }
    }
#line 68
    return;
  }
  {
  {
#line 72
  f___0 = fdopen(fd, "w");
  }
  }
#line 75
  if (_doc->metainfo) {
    {
    {
#line 75
    fputs((char const   */* __restrict  */)_doc->metainfo, (FILE */* __restrict  */)f___0);
    }
    }
  }
  {
  {
#line 78
  fclose(f___0);
  }
  {
#line 79
  close(fd);
  }
  {
#line 82
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s %s",
          editor, tmpname);
  }
  {
#line 83
  wclear(stdscr);
  }
  {
#line 84
  wrefresh(stdscr);
  }
  {
#line 85
  endwin();
  }
  {
#line 86
  ret = system((char const   *)(buf));
  }
  }
#line 86
  if (ret) {
    {
    {
#line 88
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"ERROR: editor (%s) returned error code %d.",
            editor, ret);
    }
    {
#line 89
    ui_message((char const   *)(buf), 1);
    }
    }
#line 90
    return;
  }
#line 94
  if (stdscr) {
#line 94
    tmp___1 = (int )stdscr->_maxy + 1;
  } else {
#line 94
    tmp___1 = -1;
  }
  {
  {
#line 94
  wtouchln(stdscr, 0, tmp___1, 1);
  }
  {
#line 95
  wrefresh(stdscr);
  }
  {
#line 98
  f___0 = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"r");
  }
  }
#line 99
  if (! f___0) {
    {
    {
#line 100
    ui_message("ERROR: Failed to read back temp file.", 1);
    }
    }
#line 101
    return;
  }
  {
  {
#line 105
  fseek(f___0, 0L, 2);
  }
  {
#line 106
  tmp___2 = ftell(f___0);
  }
#line 106
  size = (int )(tmp___2 + 2L);
  {
#line 108
  fseek(f___0, 0L, 0);
  }
  {
#line 111
  dstrset(& _doc->metainfo, (char const   *)((void *)0));
  }
  {
#line 112
  tmp___3 = zalloc(size);
  }
#line 112
  _doc->metainfo = (char *)tmp___3;
  {
#line 115
  tmp___4 = fread((void */* __restrict  */)_doc->metainfo, (size_t )1, (size_t )size,
                  (FILE */* __restrict  */)f___0);
  }
#line 115
  i = (int )tmp___4;
#line 118
  *(_doc->metainfo + i) = (char)0;
  {
#line 121
  unlink((char const   *)(tmpname));
  }
  }
#line 122
  return;
}
}
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.h"
void keybind_init(void) ;
#line 47
int keybind_translate(int key ) ;
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.c"
static int *cmdforkey  ;
#line 47 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.c"
void keybind_init(void) 
{ 
  void *tmp ;

  {
  {
  {
#line 49
  tmp = zalloc((int )(sizeof(int ) * 512UL));
  }
#line 49
  cmdforkey = (int *)tmp;
#line 52
  *(cmdforkey + 3) = 34;
#line 53
  *(cmdforkey + 1) = 1;
#line 54
  *(cmdforkey + 400) = 2;
#line 55
  *(cmdforkey + 405) = 3;
#line 56
  *(cmdforkey + 401) = 4;
#line 57
  *(cmdforkey + 9) = 5;
#line 58
  *(cmdforkey + 15) = 8;
#line 59
  *(cmdforkey + 19) = 9;
#line 60
  *(cmdforkey + 5) = 11;
#line 61
  *(cmdforkey + 260) = 12;
#line 62
  *(cmdforkey + 259) = 14;
#line 63
  *(cmdforkey + 258) = 15;
#line 64
  *(cmdforkey + 261) = 13;
#line 65
  *(cmdforkey + 10) = 16;
#line 66
  *(cmdforkey + 338) = 17;
#line 67
  *(cmdforkey + 339) = 18;
#line 68
  *(cmdforkey + 262) = 19;
#line 69
  *(cmdforkey + 360) = 20;
#line 70
  *(cmdforkey + 26) = 21;
#line 71
  *(cmdforkey + 24) = 22;
#line 72
  *(cmdforkey + 415) = 23;
#line 73
  *(cmdforkey + 425) = 24;
#line 74
  *(cmdforkey + 418) = 25;
#line 75
  *(cmdforkey + 27) = 26;
#line 76
  *(cmdforkey + 12) = 27;
#line 77
  *(cmdforkey + 23) = 28;
#line 78
  *(cmdforkey + 17) = 29;
#line 79
  *(cmdforkey + 4) = 30;
#line 80
  *(cmdforkey + 18) = 31;
#line 81
  *(cmdforkey + 7) = 32;
#line 82
  *(cmdforkey + 16) = 33;
#line 83
  *(cmdforkey + 331) = 6;
#line 84
  *(cmdforkey + 417) = 37;
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.c"
int keybind_translate(int key ) 
{ 


  {
#line 91
  if (key == 407) {
#line 91
    key = 26;
  }
#line 94
  return (*(cmdforkey + key));
}
}
#line 109 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.h"
void draw_vline(int x0 , int y0 , int h , int upper_endpt , int interim , int lower_endpt ) ;
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/helpdlg.h"
void show_help_dlg(void) ;
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/helpdlg.c"
static char *helptext[2]  = {      (char *)"\001Legend\002\n^ means the Ctrl key and % means\nthe Alt key. Thus, ^A means \nCtrl+A and %A means Alt-A.\n\n\001General keys\002\n^X,^Z  fast horizontal movement\n^O     open a file\n^S     save file\n\n\001Layers\002\n^W     go to next layer\n^Q     go to previous layer\n^L     bring up Layer Manager\n^A     add layer (defaults)\n%A     add layer (specify)\n^D     add copy of current layer\n^R     rename this layer\n%R     resize this layer\n\n\001Selection\002\n%S     enter select mode.\n",      (char *)"\001Colors\002\nTAB    bring up color dialog\n%P     pick color from cell\n       under the cursor\n%Z     apply color to cell\n       under the cursor\n\n\001Mode toggles\002\nINS    toggle insert mode\n^G     toggle line-drawing mode\n       (0-9,|,- will draw lines)\n^P     toggle composite view\n\n\001Others\002\n^E     edit document metainfo\n^C     quit program\nF1-Fn  show menu\n\n*************************************\nCopyright (c) 2003 by\nBruno T. C. de Oliveira\nAll rights reserved."};
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/helpdlg.c"
void show_help_dlg(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  int i ;
  char const   *p ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 91
  wclear(stdscr);
  }
  {
#line 92
  wrefresh(stdscr);
  }
  {
#line 93
  kurses_color(4, 0);
  }
  {
#line 94
  waddnstr(stdscr, "Keys Quick Reference\n\n", -1);
  }
  {
#line 95
  kurses_color(7, 0);
  }
#line 97
  x0 = 0;
#line 98
  y0 = 2;
#line 100
  x = x0;
#line 101
  y = y0;
#line 102
  i = 0;
  }
  {
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < 2)) {
#line 102
      goto while_break;
    }
#line 103
    x = x0 + i * 40;
#line 104
    y = y0;
#line 105
    p = (char const   *)helptext[i];
    {
    {
#line 107
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! *p) {
#line 107
        goto while_break___0;
      }
      {
      {
#line 108
      kurses_move(x, y);
      }
      }
      {
#line 110
      if ((int const   )*p == 1) {
#line 110
        goto case_1;
      }
#line 111
      if ((int const   )*p == 2) {
#line 111
        goto case_2;
      }
#line 112
      if ((int const   )*p == 10) {
#line 112
        goto case_10;
      }
#line 113
      if ((int const   )*p == 42) {
#line 113
        goto case_42;
      }
#line 114
      goto switch_default;
      case_1: /* CIL Label */ 
      {
      {
#line 110
      kurses_color(4, 0);
      }
      }
#line 110
      goto switch_break;
      case_2: /* CIL Label */ 
      {
      {
#line 111
      kurses_color(7, 0);
      }
      }
#line 111
      goto switch_break;
      case_10: /* CIL Label */ 
#line 112
      x = x0 + i * 40;
#line 112
      y ++;
#line 112
      goto switch_break;
      case_42: /* CIL Label */ 
      {
      {
#line 113
      waddch(stdscr, (chtype const   )acs_map[(unsigned char )'q']);
      }
#line 113
      x ++;
      }
#line 113
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 114
      waddch(stdscr, (chtype const   )*p);
      }
#line 114
      x ++;
      }
      switch_break: /* CIL Label */ ;
      }
#line 117
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 102
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 122
  draw_vline(x0 + 37, y0, 24 - y0, (int )acs_map[(unsigned char )'x'], (int )acs_map[(unsigned char )'x'],
             (int )acs_map[(unsigned char )'x']);
  }
  {
#line 124
  wrefresh(stdscr);
  }
  {
#line 125
  wgetch(stdscr);
  }
  }
#line 126
  return;
}
}
#line 112 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/autod.h"
void do_autod_register(AutodRegistryNode *head , void **ptr , void (*destr)(void * ) ) ;
#line 115
void do_autod_assign(AutodRegistryNode *head , void **ptr , void *newvalue ) ;
#line 117
void do_autod_cleanup(AutodRegistryNode *head , void *ignore_ptr ) ;
#line 48 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
void zfree(char **str ) ;
#line 51
void sfree(void *ptr ) ;
#line 130
char *dsprintf(char const   *fmt  , ...) ;
#line 144
char *freadline_ex(void *fh , int (*readch)(void * ) ) ;
#line 154
char *sstrdup(char const   *s ) ;
#line 62 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.h"
AeFile *aeff_open(char const   *filename , char mode ) ;
#line 73
void aeff_set_error(char const   *s ) ;
#line 76
void aeff_close(AeFile *f___0 ) ;
#line 80
void aeff_write_header(AeFile *f___0 , char const   *header_name ) ;
#line 81
_Bool aeff_read_header(AeFile *f___0 , char const   *header_name ) ;
#line 85
void aeff_write_footer(AeFile *f___0 , char const   *footer_name ) ;
#line 86
_Bool aeff_read_footer(AeFile *f___0 , char const   *footer_name ) ;
#line 89
void aeff_write_int(AeFile *f___0 , char const   *label , int a ) ;
#line 90
_Bool aeff_read_int(AeFile *f___0 , char const   *label , int *ret ) ;
#line 93
void aeff_write_bool(AeFile *f___0 , char const   *label , _Bool a ) ;
#line 94
_Bool aeff_read_bool(AeFile *f___0 , char const   *label , _Bool *ret ) ;
#line 99
void aeff_write_string(AeFile *f___0 , char const   *label , char const   *s ) ;
#line 100
_Bool aeff_read_string(AeFile *f___0 , char const   *label , char **ret ) ;
#line 1135 "/usr/include/zlib.h"
extern int gzprintf(gzFile file , char const   *format  , ...) ;
#line 1148
extern int gzputs(gzFile file , char const   *s ) ;
#line 1164
extern int gzputc(gzFile file , int c ) ;
#line 1170
extern int gzgetc(gzFile file ) ;
#line 1244
extern int gzclose(gzFile file ) ;
#line 1387
extern gzFile gzopen(char const   * , char const   * ) ;
#line 72 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
char *err_string  =    (char *)0;
#line 80 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool read_parse_data_line(gzFile f___0 , char **label , char **type , char **value ) 
{ 
  char *field_start[3] ;
  char *line ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  char const   *r ;
  char *w ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 88
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 89
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 91
  tmp = freadline_ex(f___0, & gzgetc);
  }
  {
#line 91
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
#line 94
  field_start[0] = line;
  {
#line 95
  field_start[1] = strchr((char const   *)line, ':');
  }
  }
#line 95
  if (field_start[1]) {
    {
    {
#line 95
    field_start[2] = strchr((char const   *)(field_start[1] + 1), ':');
    }
    }
#line 95
    if (! field_start[2]) {
      {
      {
#line 98
      dstrset(& err_string, "There\'s a data line with <3 fields.");
      }
      {
#line 99
      do_autod_cleanup(& autodregistry_head, (void *)0);
      }
      }
#line 99
      return ((_Bool)0);
    }
  } else {
    {
    {
#line 98
    dstrset(& err_string, "There\'s a data line with <3 fields.");
    }
    {
#line 99
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 99
    return ((_Bool)0);
  }
#line 105
  *(field_start[1]) = (char)0;
#line 105
  field_start[1] += 2;
#line 106
  *(field_start[2]) = (char)0;
#line 106
  field_start[2] += 2;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((int )*(field_start[0]) == 32)) {
#line 110
      if (! ((int )*(field_start[0]) == 9)) {
#line 110
        goto while_break;
      }
    }
#line 111
    (field_start[0]) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )field_start[0] >= (unsigned long )field_start[1]) {
    {
    {
#line 115
    dstrset(& err_string, "There\'s a data line with an empty label");
    }
    {
#line 116
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 116
    return ((_Bool)0);
  }
#line 120
  if (label) {
    {
    {
#line 120
    *label = sstrdup((char const   *)field_start[0]);
    }
    }
  }
#line 121
  if (type) {
    {
    {
#line 121
    *type = sstrdup((char const   *)field_start[1]);
    }
    }
  }
#line 122
  if (value) {
    {
    {
#line 122
    *value = sstrdup((char const   *)field_start[2]);
    }
    }
  }
#line 125
  if (value) {
#line 126
    r = (char const   *)*value;
#line 127
    w = *value;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! *r) {
#line 129
        goto while_break___0;
      }
#line 130
      if ((int const   )*r == 92) {
#line 131
        r ++;
#line 131
        if ((int const   )*r == 92) {
#line 131
          *w = (char )'\\';
        } else {
#line 131
          *w = (char )((int const   )*r - 48);
        }
      } else {
#line 133
        *w = (char )*r;
      }
#line 135
      r ++;
#line 135
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    *w = (char)0;
  }
  {
  {
#line 142
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 142
  return ((_Bool)1);
}
}
#line 145 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static void aeff_indent(AeFile *f___0 ) 
{ 
  int n ;
  int tmp ;

  {
#line 146
  n = f___0->indent_level;
  {
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 147
    tmp = n;
#line 147
    n --;
#line 147
    if (! (tmp > 0)) {
#line 147
      goto while_break;
    }
    {
    {
#line 147
    gzputc(f___0->f, '\t');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 150 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
AeFile *aeff_open(char const   *filename , char mode ) 
{ 
  AeFile *f___0 ;
  void *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 151
  tmp = zalloc((int )sizeof(AeFile ));
  }
#line 151
  f___0 = (AeFile *)tmp;
  }
#line 153
  if ((int )mode == 114) {
#line 153
    tmp___0 = "rb";
  } else {
#line 153
    tmp___0 = "wb";
  }
  {
  {
#line 153
  f___0->f = gzopen(filename, tmp___0);
  }
  }
#line 154
  if (! f___0->f) {
    {
    {
#line 155
    free((void *)f___0);
    }
    {
#line 156
    zfree(& err_string);
    }
    {
#line 157
    tmp___1 = __errno_location();
    }
    {
#line 157
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 157
    err_string = dsprintf("%s: %s", filename, tmp___2);
    }
    }
#line 158
    return ((AeFile *)((void *)0));
  }
#line 161
  f___0->indent_level = 0;
#line 163
  return (f___0);
}
}
#line 166 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
char const   *aeff_get_error(void) 
{ 


  {
#line 167
  return ((char const   *)err_string);
}
}
#line 170 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_set_error(char const   *s ) 
{ 


  {
  {
  {
#line 171
  zfree(& err_string);
  }
  {
#line 172
  err_string = sstrdup(s);
  }
  }
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_close(AeFile *f___0 ) 
{ 


  {
  {
  {
#line 176
  gzclose(f___0->f);
  }
  {
#line 177
  sfree((void *)f___0);
  }
  }
#line 178
  return;
}
}
#line 180 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_write_header(AeFile *f___0 , char const   *header_name ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 181
  aeff_indent(f___0);
  }
  {
#line 182
  gzprintf(f___0->f, "<%s\n", header_name);
  }
#line 183
  (f___0->indent_level) ++;
  }
#line 184
  return;
}
}
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool aeff_read_mark(AeFile *f___0 , char const   *mark_name , char pref ) 
{ 
  char *line ;
  char *s ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 190
  zfree(& err_string);
  }
#line 192
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 193
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 195
  tmp = freadline_ex(f___0->f, & gzgetc);
  }
  {
#line 195
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
  }
#line 198
  if (! line) {
    {
    {
#line 199
    err_string = dsprintf("EOF reading mark \'%c%s\'", (int )pref, mark_name);
    }
    {
#line 200
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 200
    return ((_Bool)0);
  }
#line 204
  s = line;
  {
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((int )*s == 32)) {
#line 205
      if (! ((int )*s == 9)) {
#line 205
        goto while_break;
      }
    }
#line 205
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 208
  tmp___0 = strcmp((char const   *)(s + 1), mark_name);
  }
  }
#line 208
  if (tmp___0) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  } else
#line 208
  if ((int )*(s + 0) != (int )pref) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  }
  {
  {
#line 214
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 214
  return ((_Bool)1);
}
}
#line 217 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
_Bool aeff_read_header(AeFile *f___0 , char const   *header_name ) 
{ 
  _Bool tmp ;

  {
  {
  {
#line 218
  tmp = aeff_read_mark(f___0, header_name, (char )'<');
  }
  }
#line 218
  return (tmp);
}
}
#line 221 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_write_footer(AeFile *f___0 , char const   *footer_name ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 222
  (f___0->indent_level) --;
  {
#line 223
  aeff_indent(f___0);
  }
  {
#line 224
  gzprintf(f___0->f, ">%s\n", footer_name);
  }
  }
#line 225
  return;
}
}
#line 227 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
_Bool aeff_read_footer(AeFile *f___0 , char const   *footer_name ) 
{ 
  _Bool tmp ;

  {
  {
  {
#line 228
  tmp = aeff_read_mark(f___0, footer_name, (char )'>');
  }
  }
#line 228
  return (tmp);
}
}
#line 231 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_write_int(AeFile *f___0 , char const   *label , int a ) 
{ 
  char *__cil_tmp4 ;

  {
  {
  {
#line 232
  aeff_indent(f___0);
  }
  {
#line 233
  gzprintf(f___0->f, "%s: int: %d\n", label, a);
  }
  }
#line 234
  return;
}
}
#line 236 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
_Bool aeff_read_int(AeFile *f___0 , char const   *label , int *ret ) 
{ 
  char *rlabel ;
  char *rtype ;
  char *rvalue ;
  AutodRegistryNode autodregistry_head ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 239
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 240
  do_autod_register(& autodregistry_head, (void **)(& rlabel), & free);
  }
  {
#line 241
  do_autod_register(& autodregistry_head, (void **)(& rtype), & free);
  }
  {
#line 242
  do_autod_register(& autodregistry_head, (void **)(& rvalue), & free);
  }
  {
#line 244
  tmp = read_parse_data_line(f___0->f, & rlabel, & rtype, & rvalue);
  }
  }
#line 244
  if (! tmp) {
#line 245
    return ((_Bool)0);
  }
  {
  {
#line 247
  tmp___0 = strcmp((char const   *)rtype, "int");
  }
  }
#line 247
  if (tmp___0) {
    {
    {
#line 248
    zfree(& err_string);
    }
    {
#line 249
    err_string = dsprintf("Field \'%s\' not marked as integer", label);
    }
    {
#line 251
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 251
    return ((_Bool)0);
  }
  {
  {
#line 254
  tmp___1 = strcmp((char const   *)rlabel, label);
  }
  }
#line 254
  if (tmp___1) {
    {
    {
#line 255
    zfree(& err_string);
    }
    {
#line 256
    err_string = dsprintf("Expected label \'%s\', found \'%s\'", label, rlabel);
    }
    {
#line 258
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 258
    return ((_Bool)0);
  }
#line 261
  if (ret) {
    {
    {
#line 261
    *ret = atoi((char const   *)rvalue);
    }
    }
  }
  {
  {
#line 263
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 263
  return ((_Bool)1);
}
}
#line 266 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_write_bool(AeFile *f___0 , char const   *label , _Bool a ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 267
  aeff_indent(f___0);
  }
  }
#line 268
  if (a) {
#line 268
    tmp = "true";
  } else {
#line 268
    tmp = "false";
  }
  {
  {
#line 268
  gzprintf(f___0->f, "%s: bool: %s\n", label, tmp);
  }
  }
#line 269
  return;
}
}
#line 271 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
_Bool aeff_read_bool(AeFile *f___0 , char const   *label , _Bool *ret ) 
{ 
  char *rlabel ;
  char *rtype ;
  char *rvalue ;
  AutodRegistryNode autodregistry_head ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 274
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 275
  do_autod_register(& autodregistry_head, (void **)(& rlabel), & free);
  }
  {
#line 276
  do_autod_register(& autodregistry_head, (void **)(& rtype), & free);
  }
  {
#line 277
  do_autod_register(& autodregistry_head, (void **)(& rvalue), & free);
  }
  {
#line 279
  tmp = read_parse_data_line(f___0->f, & rlabel, & rtype, & rvalue);
  }
  }
#line 279
  if (! tmp) {
#line 280
    return ((_Bool)0);
  }
  {
  {
#line 282
  tmp___0 = strcmp((char const   *)rtype, "bool");
  }
  }
#line 282
  if (tmp___0) {
    {
    {
#line 283
    zfree(& err_string);
    }
    {
#line 284
    err_string = dsprintf("Field \'%s\' not marked as bool", label);
    }
    {
#line 286
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 286
    return ((_Bool)0);
  }
  {
  {
#line 289
  tmp___1 = strcmp((char const   *)rlabel, label);
  }
  }
#line 289
  if (tmp___1) {
    {
    {
#line 290
    zfree(& err_string);
    }
    {
#line 291
    err_string = dsprintf("Expected label \'%s\', found \'%s\'", label, rlabel);
    }
    {
#line 293
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 293
    return ((_Bool)0);
  }
#line 296
  if (ret) {
#line 296
    if ((int )*rvalue == 116) {
#line 296
      *ret = (_Bool)1;
    } else {
#line 296
      *ret = (_Bool)0;
    }
  }
  {
  {
#line 298
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 298
  return ((_Bool)1);
}
}
#line 301 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
void aeff_write_string(AeFile *f___0 , char const   *label , char const   *s ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 302
  aeff_indent(f___0);
  }
  {
#line 303
  gzprintf(f___0->f, "%s: str: ", label);
  }
  }
  {
  {
#line 306
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 306
    if (! *s) {
#line 306
      goto while_break;
    }
#line 307
    if ((int const   )*s >= 0) {
#line 307
      if ((int const   )*s <= 31) {
        {
        {
#line 308
        gzputc(f___0->f, '\\');
        }
        {
#line 309
        gzputc(f___0->f, (int )((int const   )*s + 48));
        }
        }
      } else {
#line 307
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 311
    if ((int const   )*s == 92) {
      {
      {
#line 311
      gzputs(f___0->f, "\\\\");
      }
      }
    } else {
      {
      {
#line 312
      gzputc(f___0->f, (int )*s);
      }
      }
    }
#line 313
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 316
  gzputc(f___0->f, '\n');
  }
  }
#line 317
  return;
}
}
#line 319 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
_Bool aeff_read_string(AeFile *f___0 , char const   *label , char **ret ) 
{ 
  char *rlabel ;
  char *rtype ;
  char *rvalue ;
  AutodRegistryNode autodregistry_head ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 322
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 323
  do_autod_register(& autodregistry_head, (void **)(& rlabel), & free);
  }
  {
#line 324
  do_autod_register(& autodregistry_head, (void **)(& rtype), & free);
  }
  {
#line 325
  do_autod_register(& autodregistry_head, (void **)(& rvalue), & free);
  }
  {
#line 327
  tmp = read_parse_data_line(f___0->f, & rlabel, & rtype, & rvalue);
  }
  }
#line 327
  if (! tmp) {
    {
    {
#line 328
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 328
    return ((_Bool)0);
  }
  {
  {
#line 330
  tmp___0 = strcmp((char const   *)rtype, "str");
  }
  }
#line 330
  if (tmp___0) {
    {
    {
#line 331
    zfree(& err_string);
    }
    {
#line 332
    err_string = dsprintf("Field \'%s\' not marked as string", label);
    }
    {
#line 334
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 334
    return ((_Bool)0);
  }
  {
  {
#line 337
  tmp___1 = strcmp((char const   *)rlabel, label);
  }
  }
#line 337
  if (tmp___1) {
    {
    {
#line 338
    zfree(& err_string);
    }
    {
#line 339
    err_string = dsprintf("Expected label \'%s\', found \'%s\'", label, rlabel);
    }
    {
#line 341
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 341
    return ((_Bool)0);
  }
#line 344
  if (ret) {
    {
    {
#line 344
    *ret = sstrdup((char const   *)rvalue);
    }
    }
  }
  {
  {
#line 346
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 346
  return ((_Bool)1);
}
}
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char tmpname___0[64]  ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char buf___0[128]  ;
#line 77 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
int printable_char(int ch ) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.h"
void handle_key(int ch ) ;
#line 41
void handle_command(int command ) ;
#line 47
void u_load_file(char const   *supplied_filename ) ;
#line 67 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.h"
struct _Cell  const  BLANK_CELL ;
#line 72
Layer *layer_create(char const   *layer_name , int width___0 , int height___0 ) ;
#line 77
Layer *layer_dup(char const   *layer_name , Layer *model ) ;
#line 80
void layer_destroy(Layer *layer ) ;
#line 121
void layer_flip_x(Layer *layer , _Bool flipchars ) ;
#line 127
void layer_flip_y(Layer *layer , _Bool flipchars ) ;
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.h"
void document_destroy(Document *doc___0 ) ;
#line 59
void document_add_layer(Document *doc___0 , Layer *layer ) ;
#line 65
void document_insert_layer(Document *doc___0 , int i , Layer *layer ) ;
#line 74
void document_get_nom_dim(Document *doc___0 , int *w , int *h ) ;
#line 77
void document_save(Document *doc___0 , AeFile *f___0 ) ;
#line 53 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
char *_filename ;
#line 58
int _x ;
#line 58
int _y ;
#line 59
int _svx ;
#line 59
int _svy ;
#line 64
int _selmode ;
#line 65
int _ax ;
#line 65
int _ay ;
#line 67
_Bool _insmode ;
#line 71
_Bool _lgmode ;
#line 74
_Bool _compmode ;
#line 77
struct _Layer *_clipboard ;
#line 83
void zero_state(void) ;
#line 86
_Bool doc_empty(void) ;
#line 91
void get_norm_sel(int *x0 , int *y0 , int *x1 , int *y1 ) ;
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.h"
int ui_cancel ;
#line 52
int ui_ask_i(char const   *prompt , int def , int min , int max ) ;
#line 59
char *ui_ask_s(char const   *prompt , char const   *def ) ;
#line 63
int ui_ask_color(char const   *prompt ) ;
#line 69
int ui_ask_yn(char const   *prompt , int defyes ) ;
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/clipboard.h"
void clear_clipboard(void) ;
#line 44
void copy_sel_to_clipboard(void) ;
#line 48
void paste_clipboard(void) ;
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.h"
void show_welcome_dlg(void) ;
#line 46 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.h"
char *filedlg_show(char const   *title ) ;
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_add_layer(_Bool interactive ) 
{ 
  int width___0 ;
  int height___0 ;
  int nom_width ;
  int nom_height ;
  char *name ;
  Layer *lyr___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 72
  document_get_nom_dim(_doc, & nom_width, & nom_height);
  }
  }
#line 73
  if (interactive) {
    {
    {
#line 74
    width___0 = ui_ask_i("NEW LAYER: Enter width", nom_width, 2, 2147483647);
    }
    }
#line 75
    if (ui_cancel) {
#line 75
      return;
    }
    {
    {
#line 76
    height___0 = ui_ask_i("NEW LAYER: Enter height", nom_height, 2, 2147483647);
    }
    }
#line 77
    if (ui_cancel) {
#line 77
      return;
    }
    {
    {
#line 78
    name = ui_ask_s("NEW LAYER: Name", "unnamed");
    }
    }
#line 78
    if (ui_cancel) {
#line 78
      return;
    }
  } else {
    {
#line 81
    width___0 = nom_width;
#line 82
    height___0 = nom_height;
    {
#line 83
    name = strdup("unnamed");
    }
    }
  }
  {
  {
#line 86
  lyr___0 = layer_create((char const   *)name, width___0, height___0);
  }
  }
#line 90
  if (_doc->layer_count) {
#line 90
    lyr___0->transp = (_Bool)1;
  } else {
#line 91
    lyr___0->transp = (_Bool)0;
  }
  {
  {
#line 93
  document_insert_layer(_doc, 0, lyr___0);
  }
  {
#line 95
  free((void *)name);
  }
  }
#line 96
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_rename_layer(void) 
{ 
  Layer *l ;
  char *new_name ;
  char *__cil_tmp3 ;

  {
  {
#line 101
  l = *(_doc->layers + _lyr);
  {
#line 104
  new_name = ui_ask_s("Rename layer to", (char const   *)l->name);
  }
  }
#line 105
  if (! ui_cancel) {
    {
    {
#line 106
    dstrset(& l->name, (char const   *)new_name);
    }
    }
  }
#line 108
  if (new_name) {
    {
    {
#line 108
    free((void *)new_name);
    }
    }
  }
#line 109
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_resize_layer(void) 
{ 
  Layer *l ;
  Layer *new_l ;
  int h ;
  int w ;
  int x ;
  int y ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 114
  l = *(_doc->layers + _lyr);
  {
#line 118
  w = ui_ask_i("RESIZE LAYER: Enter new width", l->width, 2, 2147483647);
  }
  }
#line 119
  if (ui_cancel) {
#line 119
    return;
  }
  {
  {
#line 120
  h = ui_ask_i("RESIZE LAYER: Enter new height", l->height, 2, 2147483647);
  }
  }
#line 121
  if (ui_cancel) {
#line 121
    return;
  }
  {
  {
#line 123
  new_l = layer_create((char const   *)l->name, w, h);
  }
  }
#line 125
  if (l->width > new_l->width) {
#line 125
    w = new_l->width;
  } else {
#line 125
    w = l->width;
  }
#line 126
  if (l->height > new_l->height) {
#line 126
    h = new_l->height;
  } else {
#line 126
    h = l->height;
  }
#line 128
  y = 0;
  {
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 128
    if (! (y < h)) {
#line 128
      goto while_break;
    }
#line 129
    x = 0;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (x < w)) {
#line 129
        goto while_break___0;
      }
#line 130
      (*(new_l->cells + x) + y)->ch = (*(l->cells + x) + y)->ch;
#line 131
      (*(new_l->cells + x) + y)->attr = (*(l->cells + x) + y)->attr;
#line 129
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  layer_destroy(l);
  }
#line 135
  *(_doc->layers + _lyr) = new_l;
  }
#line 136
  return;
}
}
#line 140 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_dup_layer(void) 
{ 
  char buf___15[32] ;
  Layer *l ;
  Layer *tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 143
  sprintf((char */* __restrict  */)(buf___15), (char const   */* __restrict  */)"copy of %d",
          _lyr);
  }
#line 145
  l = *(_doc->layers + _lyr);
  {
#line 146
  tmp = layer_dup((char const   *)(buf___15), l);
  }
  {
#line 146
  document_add_layer(_doc, tmp);
  }
  {
#line 147
  switch_to_layer(_doc->layer_count - 1);
  }
  }
#line 148
  return;
}
}
#line 152 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
char *get_home_dir(char *name ) 
{ 
  char msg___1[128] ;
  char *home_dir ;
  struct passwd *pw ;
  __uid_t tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 157
  if (name) {
    {
    {
#line 158
    pw = getpwnam((char const   *)name);
    }
    }
#line 159
    if (! pw) {
#line 160
      goto doesnt_have;
    }
#line 161
    return (pw->pw_dir);
  } else {
    {
    {
#line 163
    home_dir = getenv("HOME");
    }
    }
#line 164
    if (home_dir) {
#line 165
      return (home_dir);
    } else {
      {
      {
#line 168
      tmp = getuid();
      }
      {
#line 168
      pw = getpwuid(tmp);
      }
      }
#line 169
      if (! pw) {
#line 170
        goto doesnt_have;
      }
#line 171
      return (pw->pw_dir);
    }
  }
  doesnt_have: 
  {
  {
#line 177
  sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"ERROR: User \'%s\' doesn\'t have a home directory.",
          name);
  }
  {
#line 178
  ui_message((char const   *)(msg___1), 1);
  }
  }
#line 179
  return ((char *)((void *)0));
}
}
#line 184 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static char *expand_tilde(char *filename ) 
{ 
  char *home_dir ;
  char *slash ;
  char *username ;
  char *filename_dup ;
  char *ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 188
  if (*(filename + 1)) {
    {
    {
#line 192
    filename_dup = strdup((char const   *)filename);
    }
    {
#line 193
    slash = strchr((char const   *)filename_dup, '/');
    }
#line 194
    username = filename_dup + 1;
    }
#line 196
    if (! slash) {
      {
      {
#line 198
      free((void *)filename_dup);
      }
      }
#line 199
      return (filename);
    }
    {
#line 202
    *slash = (char )'\000';
    {
#line 204
    tmp = strlen((char const   *)username);
    }
    }
#line 204
    if (! tmp) {
#line 205
      username = (char *)((void *)0);
    }
    {
    {
#line 206
    home_dir = get_home_dir(username);
    }
    }
#line 207
    if (! home_dir) {
#line 208
      return ((char *)((void *)0));
    }
    {
#line 210
    slash ++;
    {
#line 211
    tmp___0 = strlen((char const   *)home_dir);
    }
    {
#line 211
    tmp___1 = strlen((char const   *)slash);
    }
    {
#line 211
    tmp___2 = malloc((tmp___0 + tmp___1) + 1U);
    }
#line 211
    ret = (char *)tmp___2;
    {
#line 212
    sprintf((char */* __restrict  */)ret, (char const   */* __restrict  */)"%s/%s",
            home_dir, slash);
    }
    {
#line 213
    free((void *)filename_dup);
    }
    }
#line 214
    return (ret);
  } else {
#line 217
    return (filename);
  }
}
}
#line 225 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
void u_load_file(char const   *supplied_filename ) 
{ 
  char *filename ;
  FILE *f___0 ;
  char msg___1[128] ;
  Document *newdoc ;
  char const   *tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 227
  f___0 = (FILE *)((void *)0);
#line 231
  if (! supplied_filename) {
    {
    {
#line 232
    filename = filedlg_show("Load File");
    }
    }
#line 233
    if (! filename) {
#line 233
      return;
    }
  } else {
    {
    {
#line 235
    filename = strdup(supplied_filename);
    }
    }
  }
  {
  {
#line 237
  newdoc = document_load_from((char const   *)filename);
  }
  }
#line 237
  if (! newdoc) {
    {
    {
#line 238
    sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"ERROR: Failed to load file.  -- More --");
    }
    {
#line 239
    ui_message((char const   *)(msg___1), 1);
    }
    {
#line 240
    tmp = aeff_get_error();
    }
    {
#line 240
    ui_message(tmp, 1);
    }
    }
#line 241
    goto cleanup;
  }
  {
  {
#line 245
  document_destroy(_doc);
  }
#line 246
  _doc = newdoc;
  {
#line 249
  dstrset(& _filename, (char const   *)filename);
  }
  }
  cleanup: 
#line 252
  if (f___0) {
    {
    {
#line 252
    fclose(f___0);
    }
    }
  }
#line 253
  if (filename) {
    {
    {
#line 253
    free((void *)filename);
    }
    }
  }
#line 254
  return;
}
}
#line 257 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_save_file(_Bool forceAsk ) 
{ 
  char *filename ;
  char *expanded_filename ;
  FILE *tmpf ;
  AeFile *f___0 ;
  char msg___1[128] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 260
  f___0 = (AeFile *)0;
#line 263
  if (forceAsk) {
#line 263
    goto _L;
  } else
#line 263
  if (! _filename) {
#line 263
    goto _L;
  } else {
    {
    {
#line 263
    tmp = strlen((char const   *)_filename);
    }
    }
#line 263
    if (tmp) {
      {
      {
#line 267
      filename = strdup((char const   *)_filename);
      }
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 264
      filename = filedlg_show("Save File As");
      }
      }
#line 265
      if (! filename) {
#line 265
        return;
      }
    }
  }
#line 269
  if ((int )*(filename + 0) == 126) {
    {
    {
#line 270
    expanded_filename = expand_tilde(filename);
    }
    }
#line 271
    if (! expanded_filename) {
#line 271
      return;
    }
#line 274
    if ((unsigned long )expanded_filename != (unsigned long )filename) {
      {
      {
#line 275
      free((void *)filename);
      }
#line 276
      filename = expanded_filename;
      }
    }
  }
#line 280
  if (_filename) {
    {
    {
#line 280
    tmp___1 = strcmp((char const   *)_filename, (char const   *)filename);
    }
    }
#line 280
    if (tmp___1) {
      {
      {
#line 280
      tmpf = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
      }
#line 280
      if (tmpf) {
        {
        {
#line 283
        fclose(tmpf);
        }
#line 283
        tmpf = (FILE *)0;
        {
#line 284
        tmp___0 = ui_ask_yn("FILE EXISTS. Overwrite?", 0);
        }
        }
#line 284
        if (tmp___0) {
#line 284
          if (ui_cancel) {
            {
            {
#line 285
            ui_message("File was NOT saved!", 0);
            }
            }
#line 286
            goto cleanup;
          }
        } else {
          {
          {
#line 285
          ui_message("File was NOT saved!", 0);
          }
          }
#line 286
          goto cleanup;
        }
      }
    }
  }
  {
  {
#line 290
  f___0 = aeff_open((char const   *)filename, (char )'w');
  }
  }
#line 290
  if (! f___0) {
    {
    {
#line 291
    tmp___2 = aeff_get_error();
    }
    {
#line 291
    sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"ERROR: Can\'t write to file. %s.",
            tmp___2);
    }
    {
#line 292
    ui_message((char const   *)(msg___1), 1);
    }
    }
#line 293
    goto cleanup;
  }
  {
  {
#line 296
  document_save(_doc, f___0);
  }
  {
#line 298
  dstrset(& _filename, (char const   *)filename);
  }
  {
#line 300
  sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"File saved: %s.",
          filename);
  }
  {
#line 301
  ui_message((char const   *)(msg___1), 0);
  }
  }
  cleanup: 
#line 304
  if (f___0) {
    {
    {
#line 304
    aeff_close(f___0);
    }
    }
  }
#line 305
  if (filename) {
    {
    {
#line 305
    free((void *)filename);
    }
    }
  }
#line 306
  return;
}
}
#line 309 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void erase_sel(void) 
{ 
  int x ;
  int y ;
  int x0 ;
  int x1 ;
  int y0 ;
  int y1 ;

  {
  {
  {
#line 313
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 314
  x = x0;
  }
  {
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 314
    if (! (x <= x1)) {
#line 314
      goto while_break;
    }
#line 315
    y = y0;
    {
    {
#line 315
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (y <= y1)) {
#line 315
        goto while_break___0;
      }
#line 316
      *(*((*(_doc->layers + _lyr))->cells + x) + y) = (Cell )BLANK_CELL;
#line 315
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 321 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void tint_sel(_Bool fg ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int x ;
  int y ;

  {
  {
  {
#line 323
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 325
  x = x0;
  }
  {
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 325
    if (! (x <= x1)) {
#line 325
      goto while_break;
    }
#line 326
    y = y0;
    {
    {
#line 326
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (y <= y1)) {
#line 326
        goto while_break___0;
      }
#line 327
      if (fg) {
#line 328
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )((_fg << 4) | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 15));
      } else {
#line 331
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )(_bg | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 240));
      }
#line 326
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 337 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static int lgmode_map_ch(int ch ) 
{ 


  {
  {
#line 339
  if (ch == 55) {
#line 339
    goto case_55;
  }
#line 340
  if (ch == 56) {
#line 340
    goto case_56;
  }
#line 341
  if (ch == 57) {
#line 341
    goto case_57;
  }
#line 342
  if (ch == 52) {
#line 342
    goto case_52;
  }
#line 343
  if (ch == 53) {
#line 343
    goto case_53;
  }
#line 344
  if (ch == 54) {
#line 344
    goto case_54;
  }
#line 345
  if (ch == 49) {
#line 345
    goto case_49;
  }
#line 346
  if (ch == 50) {
#line 346
    goto case_50;
  }
#line 347
  if (ch == 51) {
#line 347
    goto case_51;
  }
#line 348
  if (ch == 45) {
#line 348
    goto case_45;
  }
#line 349
  if (ch == 124) {
#line 349
    goto case_124;
  }
#line 350
  if (ch == 48) {
#line 350
    goto case_48;
  }
#line 351
  goto switch_default;
  case_55: /* CIL Label */ 
#line 339
  return (3);
  case_56: /* CIL Label */ 
#line 340
  return (4);
  case_57: /* CIL Label */ 
#line 341
  return (5);
  case_52: /* CIL Label */ 
#line 342
  return (6);
  case_53: /* CIL Label */ 
#line 343
  return (7);
  case_54: /* CIL Label */ 
#line 344
  return (8);
  case_49: /* CIL Label */ 
#line 345
  return (9);
  case_50: /* CIL Label */ 
#line 346
  return (10);
  case_51: /* CIL Label */ 
#line 347
  return (11);
  case_45: /* CIL Label */ 
#line 348
  return (1);
  case_124: /* CIL Label */ 
#line 349
  return (2);
  case_48: /* CIL Label */ 
#line 350
  return (12);
  switch_default: /* CIL Label */ 
#line 351
  return (ch);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 356 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_select_handle_key(int ch ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int tmp ;

  {
  {
  {
#line 359
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
  }
  {
#line 363
  if (ch == 109) {
#line 363
    goto case_109;
  }
#line 369
  if (ch == 99) {
#line 369
    goto case_99;
  }
#line 374
  if (ch == 101) {
#line 374
    goto case_101;
  }
#line 378
  if (ch == 102) {
#line 378
    goto case_102;
  }
#line 381
  if (ch == 98) {
#line 381
    goto case_98;
  }
#line 384
  if (ch == 111) {
#line 384
    goto case_111;
  }
#line 362
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 364
  _selmode = 2;
  {
#line 365
  copy_sel_to_clipboard();
  }
  {
#line 366
  erase_sel();
  }
#line 367
  _x = x0;
#line 367
  _y = y0;
  }
#line 368
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 370
  _selmode = 2;
  {
#line 371
  copy_sel_to_clipboard();
  }
#line 372
  _x = x0;
#line 372
  _y = y0;
  }
#line 373
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 375
  _selmode = 0;
  {
#line 376
  erase_sel();
  }
  }
#line 377
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 379
  tint_sel((_Bool)1);
  }
  }
#line 380
  goto switch_break;
  case_98: /* CIL Label */ 
  {
  {
#line 382
  tint_sel((_Bool)0);
  }
  }
#line 383
  goto switch_break;
  case_111: /* CIL Label */ 
#line 388
  tmp = _x;
#line 388
  _x = _ax;
#line 388
  _ax = tmp;
#line 389
  tmp = _y;
#line 389
  _y = _ay;
#line 389
  _ay = tmp;
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 395 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_float_handle_key(int ch ) 
{ 


  {
  {
#line 397
  if (ch == 115) {
#line 397
    goto case_115;
  }
#line 400
  if (ch == 88) {
#line 400
    goto case_88;
  }
#line 400
  if (ch == 120) {
#line 400
    goto case_88;
  }
#line 403
  if (ch == 89) {
#line 403
    goto case_89;
  }
#line 403
  if (ch == 121) {
#line 403
    goto case_89;
  }
#line 406
  if (ch == 84) {
#line 406
    goto case_84;
  }
#line 406
  if (ch == 116) {
#line 406
    goto case_84;
  }
#line 396
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  {
#line 398
  paste_clipboard();
  }
  }
#line 399
  goto switch_break;
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  {
  {
#line 401
  layer_flip_x(_clipboard, (_Bool )(ch == 120));
  }
  }
#line 402
  goto switch_break;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
  {
#line 404
  layer_flip_y(_clipboard, (_Bool )(ch == 121));
  }
  }
#line 405
  goto switch_break;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 407
  _clipboard->transp = (_Bool )(! _clipboard->transp);
#line 408
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 414 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
void u_edit_meta(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  int ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 416
  kurses_color(7, 0);
  }
  {
#line 417
  draw_centered_window(40, 5, "Edit Metainfo", & x0, & y0);
  }
#line 419
  x = x0;
#line 419
  y = y0;
#line 420
  tmp = y;
#line 420
  y ++;
  {
#line 420
  kurses_move(x, tmp);
  }
  {
#line 421
  waddnstr(stdscr, "You will now be taken into an editor", -1);
  }
#line 422
  tmp___0 = y;
#line 422
  y ++;
  {
#line 422
  kurses_move(x, tmp___0);
  }
  {
#line 423
  waddnstr(stdscr, "in which you will be able to edit this", -1);
  }
#line 424
  tmp___1 = y;
#line 424
  y ++;
  {
#line 424
  kurses_move(x, tmp___1);
  }
  {
#line 425
  waddnstr(stdscr, "document\'s metainfo (arbitrary text).", -1);
  }
  {
#line 427
  ch = wgetch(stdscr);
  }
  }
#line 428
  if (ch == 7) {
#line 428
    return;
  } else
#line 428
  if (ch == 27) {
#line 428
    return;
  }
  {
  {
#line 430
  edit_metainfo();
  }
  }
#line 431
  return;
}
}
#line 433 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void correct_coords(void) 
{ 
  Layer *lyr___0 ;
  int scr_width ;
  int tmp ;
  int scr_height ;
  int tmp___0 ;

  {
  {
  {
#line 435
  tmp = kurses_width();
  }
#line 435
  scr_width = tmp;
  {
#line 436
  tmp___0 = kurses_height();
  }
#line 436
  scr_height = tmp___0;
  }
#line 438
  if (! _doc->layer_count) {
#line 438
    return;
  }
#line 439
  lyr___0 = *(_doc->layers + _lyr);
#line 442
  if (_x < 0) {
#line 442
    _x = 0;
  }
#line 443
  if (_x >= lyr___0->width) {
#line 443
    _x = lyr___0->width - 1;
  }
#line 444
  if (_y < 0) {
#line 444
    _y = 0;
  }
#line 445
  if (_y >= lyr___0->height) {
#line 445
    _y = lyr___0->height - 1;
  }
#line 448
  if (_x >= _svx + scr_width) {
#line 448
    _svx = (_x - scr_width) + 1;
  } else
#line 449
  if (_x < _svx) {
#line 449
    _svx = _x;
  }
#line 450
  if (_y >= (_svy + scr_height) - 1) {
#line 450
    _svy = (_y - scr_height) + 2;
  } else
#line 451
  if (_y < _svy) {
#line 451
    _svy = _y;
  }
#line 452
  return;
}
}
#line 455 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
void handle_key(int ch ) 
{ 
  int command ;
  Layer *lyr___0 ;
  int ch_to_put ;
  int tmp ;
  int tmp___0 ;
  int x ;
  int tmp___1 ;
  int x___0 ;

  {
#line 468
  if (ch > 264) {
#line 468
    if (ch <= 276) {
      {
      {
#line 470
      command = menubar_show((ch - 264) - 1);
      }
      }
#line 471
      if (command != 0) {
        {
        {
#line 471
        handle_command(command);
        }
        }
      }
#line 472
      return;
    }
  }
  {
  {
#line 475
  command = keybind_translate(ch);
  }
  }
#line 475
  if (command) {
    {
    {
#line 477
    handle_command(command);
    }
    }
#line 478
    if (ch != 27) {
#line 478
      return;
    }
  }
#line 484
  if (! _doc->layer_count) {
#line 484
    return;
  }
  {
#line 485
  lyr___0 = *(_doc->layers + _lyr);
  {
#line 488
  tmp___1 = printable_char(ch);
  }
  }
#line 488
  if (tmp___1) {
#line 488
    if (_selmode == 0) {
#line 489
      if (_lgmode) {
        {
        {
#line 489
        tmp = lgmode_map_ch(ch);
        }
#line 489
        tmp___0 = tmp;
        }
      } else {
#line 489
        tmp___0 = ch;
      }
#line 489
      ch_to_put = tmp___0;
#line 491
      if (_insmode) {
#line 493
        x = lyr___0->width - 1;
        {
        {
#line 493
        while (1) {
          while_continue___1: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 493
          if (! (x > _x)) {
#line 493
            goto while_break;
          }
#line 494
          *(*(lyr___0->cells + x) + _y) = *(*(lyr___0->cells + (x - 1)) + _y);
#line 493
          x --;
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 497
      (*(lyr___0->cells + _x) + _y)->ch = (unsigned char )ch_to_put;
#line 498
      (*(lyr___0->cells + _x) + _y)->attr = (unsigned char )((_fg << 4) | _bg);
#line 499
      _x ++;
    }
  }
#line 503
  if (_selmode == 1) {
    {
    {
#line 503
    sm_select_handle_key(ch);
    }
    }
  } else
#line 504
  if (_selmode == 2) {
    {
    {
#line 504
    sm_float_handle_key(ch);
    }
    }
  }
#line 507
  if (_selmode == 0) {
#line 507
    if (_x > 0) {
#line 507
      if (ch == 8) {
#line 507
        goto _L;
      } else
#line 507
      if (ch == 263) {
#line 507
        goto _L;
      } else
#line 507
      if (ch == 127) {
#line 507
        goto _L;
      } else {
#line 507
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 507
    if (ch == 330) {
      _L: /* CIL Label */ 
#line 511
      _selmode = 0;
#line 512
      if (ch != 330) {
#line 512
        _x --;
      }
#line 514
      x___0 = _x;
      {
      {
#line 514
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 514
        if (! (x___0 < lyr___0->width - 1)) {
#line 514
          goto while_break___0;
        }
#line 515
        *(*(lyr___0->cells + x___0) + _y) = *(*(lyr___0->cells + (x___0 + 1)) + _y);
#line 514
        x___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 517
      *(*(lyr___0->cells + (lyr___0->width - 1)) + _y) = (Cell )BLANK_CELL;
    }
  }
  {
  {
#line 520
  correct_coords();
  }
  }
#line 521
  return;
}
}
#line 523 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
void handle_command(int command ) 
{ 
  int newfg ;
  int newbg ;
  int ret ;
  Layer *lyr___0 ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 530
  if (command == 34) {
#line 530
    goto case_34;
  }
#line 535
  if (command == 2) {
#line 535
    goto case_2;
  }
#line 535
  if (command == 1) {
#line 535
    goto case_2;
  }
#line 540
  if (command == 3) {
#line 540
    goto case_3;
  }
#line 544
  if (command == 4) {
#line 544
    goto case_4;
  }
#line 548
  if (command == 5) {
#line 548
    goto case_5;
  }
#line 549
  if (command == 6) {
#line 549
    goto case_6;
  }
#line 550
  if (command == 7) {
#line 550
    goto case_7;
  }
#line 551
  if (command == 36) {
#line 551
    goto case_36;
  }
#line 552
  if (command == 8) {
#line 552
    goto case_8;
  }
#line 553
  if (command == 9) {
#line 553
    goto case_9;
  }
#line 554
  if (command == 10) {
#line 554
    goto case_10;
  }
#line 555
  if (command == 35) {
#line 555
    goto case_35;
  }
#line 563
  if (command == 11) {
#line 563
    goto case_11;
  }
#line 529
  goto switch_break;
  case_34: /* CIL Label */ 
  {
  {
#line 531
  ret = ui_ask_yn("Really quit aewan?", 0);
  }
  }
#line 532
  if (! ui_cancel) {
#line 532
    if (ret) {
      {
      {
#line 532
      exit(0);
      }
      }
    }
  }
#line 533
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
  {
#line 536
  u_add_layer((_Bool )(command == 2));
  }
  {
#line 537
  tmp = doc_empty();
  }
  }
#line 537
  if (! tmp) {
#line 537
    _lyr = 0;
  }
#line 539
  return;
  case_3: /* CIL Label */ 
  {
  {
#line 541
  newfg = ui_ask_color("Foreground color");
  }
  }
#line 542
  if (! ui_cancel) {
#line 542
    _fg = newfg;
  }
#line 543
  return;
  case_4: /* CIL Label */ 
  {
  {
#line 545
  newbg = ui_ask_color("Background color");
  }
  }
#line 546
  if (! ui_cancel) {
#line 546
    _bg = newbg;
  }
#line 547
  return;
  case_5: /* CIL Label */ 
  {
  {
#line 548
  show_color_dlg();
  }
  }
#line 548
  return;
  case_6: /* CIL Label */ 
#line 549
  _insmode = (_Bool )(! _insmode);
#line 549
  return;
  case_7: /* CIL Label */ 
  {
  {
#line 550
  show_help_dlg();
  }
  }
#line 550
  return;
  case_36: /* CIL Label */ 
  {
  {
#line 551
  show_welcome_dlg();
  }
  }
#line 551
  return;
  case_8: /* CIL Label */ 
  {
  {
#line 552
  u_load_file((char const   *)((void *)0));
  }
  }
#line 552
  return;
  case_9: /* CIL Label */ 
  {
  {
#line 553
  u_save_file((_Bool)0);
  }
  }
#line 553
  return;
  case_10: /* CIL Label */ 
  {
  {
#line 554
  u_save_file((_Bool)1);
  }
  }
#line 554
  return;
  case_35: /* CIL Label */ 
#line 556
  if (_doc->layer_count > 0) {
    {
    {
#line 557
    ret = ui_ask_yn("Really start a new document?", 0);
    }
    }
#line 558
    if (ui_cancel) {
#line 558
      goto switch_break;
    } else
#line 558
    if (! ret) {
#line 558
      goto switch_break;
    }
  }
  {
  {
#line 560
  document_destroy(_doc);
  }
  {
#line 561
  zero_state();
  }
  }
#line 562
  return;
  case_11: /* CIL Label */ 
  {
  {
#line 563
  u_edit_meta();
  }
  }
#line 563
  return;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 568
  tmp___0 = doc_empty();
  }
  }
#line 568
  if (tmp___0) {
#line 568
    return;
  }
#line 569
  lyr___0 = *(_doc->layers + _lyr);
#line 572
  if (_clipboard) {
#line 572
    if (_selmode != 2) {
      {
      {
#line 572
      clear_clipboard();
      }
      }
    }
  }
  {
#line 575
  if (command == 12) {
#line 575
    goto case_12;
  }
#line 576
  if (command == 13) {
#line 576
    goto case_13;
  }
#line 577
  if (command == 14) {
#line 577
    goto case_14;
  }
#line 578
  if (command == 15) {
#line 578
    goto case_15;
  }
#line 579
  if (command == 16) {
#line 579
    goto case_16;
  }
#line 580
  if (command == 17) {
#line 580
    goto case_17;
  }
#line 581
  if (command == 18) {
#line 581
    goto case_18;
  }
#line 582
  if (command == 19) {
#line 582
    goto case_19;
  }
#line 583
  if (command == 20) {
#line 583
    goto case_20;
  }
#line 584
  if (command == 22) {
#line 584
    goto case_22;
  }
#line 585
  if (command == 21) {
#line 585
    goto case_21;
  }
#line 586
  if (command == 23) {
#line 586
    goto case_23;
  }
#line 591
  if (command == 24) {
#line 591
    goto case_24;
  }
#line 597
  if (command == 25) {
#line 597
    goto case_25;
  }
#line 606
  if (command == 26) {
#line 606
    goto case_26;
  }
#line 607
  if (command == 27) {
#line 607
    goto case_27;
  }
#line 612
  if (command == 28) {
#line 612
    goto case_28;
  }
#line 613
  if (command == 29) {
#line 613
    goto case_29;
  }
#line 614
  if (command == 30) {
#line 614
    goto case_30;
  }
#line 615
  if (command == 31) {
#line 615
    goto case_31;
  }
#line 616
  if (command == 37) {
#line 616
    goto case_37;
  }
#line 618
  if (command == 32) {
#line 618
    goto case_32;
  }
#line 619
  if (command == 33) {
#line 619
    goto case_33;
  }
#line 574
  goto switch_break___0;
  case_12: /* CIL Label */ 
#line 575
  _x --;
#line 575
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 576
  _x ++;
#line 576
  goto switch_break___0;
  case_14: /* CIL Label */ 
#line 577
  _y --;
#line 577
  goto switch_break___0;
  case_15: /* CIL Label */ 
#line 578
  _y ++;
#line 578
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 579
  _y ++;
#line 579
  _x = 0;
#line 579
  goto switch_break___0;
  case_17: /* CIL Label */ 
  {
  {
#line 580
  tmp___1 = kurses_height();
  }
#line 580
  _y += tmp___1 - 1;
  }
#line 580
  goto switch_break___0;
  case_18: /* CIL Label */ 
  {
  {
#line 581
  tmp___2 = kurses_height();
  }
#line 581
  _y -= tmp___2 - 2;
  }
#line 581
  goto switch_break___0;
  case_19: /* CIL Label */ 
#line 582
  _x = 0;
#line 582
  goto switch_break___0;
  case_20: /* CIL Label */ 
#line 583
  _x = lyr___0->width - 1;
#line 583
  goto switch_break___0;
  case_22: /* CIL Label */ 
#line 584
  _x += 8;
#line 584
  goto switch_break___0;
  case_21: /* CIL Label */ 
#line 585
  _x -= 8;
#line 585
  goto switch_break___0;
  case_23: /* CIL Label */ 
#line 587
  if (_selmode != 0) {
#line 587
    goto switch_break___0;
  }
#line 588
  _fg = (int )(*(lyr___0->cells + _x) + _y)->attr >> 4;
#line 589
  _bg = (int )(*(lyr___0->cells + _x) + _y)->attr & 15;
#line 590
  goto switch_break___0;
  case_24: /* CIL Label */ 
#line 592
  if (_selmode != 0) {
#line 592
    goto switch_break___0;
  }
#line 593
  (*(lyr___0->cells + _x) + _y)->attr = (unsigned char )((_fg << 4) | _bg);
#line 594
  _x ++;
#line 595
  goto switch_break___0;
  case_25: /* CIL Label */ 
#line 598
  if (_selmode == 0) {
#line 599
    _selmode = 1;
#line 600
    _ax = _x;
#line 601
    _ay = _y;
  } else {
#line 603
    _selmode = 0;
  }
#line 604
  goto switch_break___0;
  case_26: /* CIL Label */ 
#line 606
  _selmode = 0;
#line 606
  goto switch_break___0;
  case_27: /* CIL Label */ 
  {
  {
#line 608
  show_layer_dlg();
  }
  }
#line 610
  if (_lyr > _doc->layer_count) {
#line 610
    _lyr = _doc->layer_count - 1;
  }
#line 611
  goto switch_break___0;
  case_28: /* CIL Label */ 
  {
  {
#line 612
  switch_to_layer(_lyr + 1);
  }
  }
#line 612
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
  {
#line 613
  switch_to_layer(_lyr - 1);
  }
  }
#line 613
  goto switch_break___0;
  case_30: /* CIL Label */ 
  {
  {
#line 614
  u_dup_layer();
  }
  }
#line 614
  goto switch_break___0;
  case_31: /* CIL Label */ 
  {
  {
#line 615
  u_rename_layer();
  }
  }
#line 615
  goto switch_break___0;
  case_37: /* CIL Label */ 
  {
  {
#line 616
  u_resize_layer();
  }
  }
#line 616
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 618
  _lgmode = (_Bool )(! _lgmode);
#line 618
  goto switch_break___0;
  case_33: /* CIL Label */ 
#line 619
  _compmode = (_Bool )(! _compmode);
#line 619
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
  {
#line 622
  correct_coords();
  }
  }
#line 623
  return;
}
}
#line 190 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
static int _compar___0(void const   *p1 , void const   *p2 ) 
{ 
  char const   **a ;
  char const   **b ;
  int tmp ;

  {
  {
#line 191
  a = (char const   **)p1;
#line 192
  b = (char const   **)p2;
  {
#line 193
  tmp = strcmp(*a, *b);
  }
  }
#line 193
  return (tmp);
}
}
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.c"
static int *cmdforkey___0  ;
#line 852 "/usr/include/ncurses.h"
extern int define_key(char const   * , int  ) ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keys.h"
void keys_init(void) ;
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keys.c"
void keys_init(void) 
{ 
  int i ;
  char seq[3] ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 40
  seq[0] = (char )'\033';
#line 40
  seq[1] = (char )'x';
#line 40
  seq[2] = (char )'\000';
#line 41
  i = 400;
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i <= 425)) {
#line 41
      goto while_break;
    }
    {
#line 42
    seq[1] = (char )((i - 400) + 97);
    {
#line 43
    define_key((char const   *)(seq), i);
    }
#line 41
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 47
  define_key("\033[1;2A", 259);
  }
  {
#line 48
  define_key("\033[1;2B", 258);
  }
  {
#line 49
  define_key("\033[1;2C", 261);
  }
  {
#line 50
  define_key("\033[1;2D", 260);
  }
  {
#line 53
  define_key("\033[[a", 259);
  }
  {
#line 54
  define_key("\033[[b", 258);
  }
  {
#line 55
  define_key("\033[[c", 261);
  }
  {
#line 56
  define_key("\033[[d", 260);
  }
  {
#line 57
  define_key("\033[7~", 262);
  }
  {
#line 58
  define_key("\033[8~", 360);
  }
  {
#line 59
  define_key("\033[11~", 265);
  }
  {
#line 60
  define_key("\033[12~", 266);
  }
  {
#line 61
  define_key("\033[13~", 267);
  }
  {
#line 62
  define_key("\033[14~", 268);
  }
  }
#line 63
  return;
}
}
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/helpdlg.c"
static char *helptext___0[2]  = {      (char *)"\001Legend\002\n^ means the Ctrl key and % means\nthe Alt key. Thus, ^A means \nCtrl+A and %A means Alt-A.\n\n\001General keys\002\n^X,^Z  fast horizontal movement\n^O     open a file\n^S     save file\n\n\001Layers\002\n^W     go to next layer\n^Q     go to previous layer\n^L     bring up Layer Manager\n^A     add layer (defaults)\n%A     add layer (specify)\n^D     add copy of current layer\n^R     rename this layer\n%R     resize this layer\n\n\001Selection\002\n%S     enter select mode.\n",      (char *)"\001Colors\002\nTAB    bring up color dialog\n%P     pick color from cell\n       under the cursor\n%Z     apply color to cell\n       under the cursor\n\n\001Mode toggles\002\nINS    toggle insert mode\n^G     toggle line-drawing mode\n       (0-9,|,- will draw lines)\n^P     toggle composite view\n\n\001Others\002\n^E     edit document metainfo\n^C     quit program\nF1-Fn  show menu\n\n*************************************\nCopyright (c) 2003 by\nBruno T. C. de Oliveira\nAll rights reserved."};
#line 1 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static Menu menu___1[4]  = {      {"[F1] File", 1, 0, 0, 7, {{(char )'N', "&New", 35, "Clears everything and starts from scratch"},
                                {(char )'L', "&Load...", 8, "Loads a file into the editor"},
                                {(char )'S', "&Save", 9, "Saves the current drawing"},
                                {(char )'A', "Save &As...", 10, "Saves the current drawing in a specified file"},
                                {(char )'M', "Edit &Meta...", 11, "Opens an editor for you to edit this document\'s metadata"},
                                {(char )' ', "", 0, (char const   *)((void *)0)},
                                {(char )'Q', "&Quit", 34, "Quits program"}}}, 
        {"[F2] Edit", 16, 0, 0, 8, {{(char )'C', "Drawing &color...", 5, "Brings up the color selection dialog"},
                                 {(char )'I', "Toggle &Insert", 6, "Toggles insert/overwrite mode"},
                                 {(char )'K', "Pic&k color", 23, "Picks color under cursor to use as current color"},
                                 {(char )'T', "&Tint cell", 24, "Applies current color to cell under cursor"},
                                 {(char )' ', "", 0, (char const   *)((void *)0)},
                                 {(char )'S', "Toggle &select mode", 25, "Toggles select mode on/off"},
                                 {(char )'L', "Toggle &line-drawing", 32, "Toggles line-drawing mode on/off. Use 0-9 to draw lines"},
                                 {(char )'P', "Toggle com&posite", 33, "Toggles composite (all-layer) view on/off"}}}, 
        {"[F3] Layer",
      32, 0, 0, 9, {{(char )'A', "&Add layer (defaults)", 1, "Adds a layer with default parameters"},
                    {(char )'L', "Add &layer (specify)...", 2, "Adds a layer with custom parameters"},
                    {(char )'D', "&Duplicate layer", 30, "Duplicates current layer. Copy is added to the bottom of the stack."},
                    {(char )'R', "&Rename layer...", 31, "Renames the current layer"},
                    {(char )'Z', "Resi&ze layer...", 37, "Resizes the current layer"},
                    {(char )'M', "&Manage layers...", 27, "Shows a dialog in which you can manipulate layers"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'N',
                                                                       "Go to &next layer",
                                                                       28, "Goes to the next layer"},
                    {(char )'P', "Go to &previous layer", 29, "Goes to the previous layer"}}}, 
        {"[F4] Help",
      64, 0, 0, 3, {{(char )'K', "&Key reference", 7, "Shows a table of keys and their functions"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'A',
                                                                       "&About Aewan",
                                                                       36, "Shows information about the program"}}}};
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static int menu_count___0  =    4;
#line 78 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int open_menu___0  ;
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int menu_sel___0  ;
#line 83
static void menubar_paint___0(void) ;
#line 84
static void menuitem_print___0(char const   *s , _Bool sel , int minlen ) ;
#line 85
static void menu_calc_dims___0(Menu *m ) ;
#line 86
static _Bool chr_icomp___0(char c1 , char c2 ) ;
#line 151 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static _Bool chr_icomp___0(char c1 , char c2 ) 
{ 


  {
#line 152
  if ((int )c1 >= 65) {
#line 152
    if ((int )c1 <= 90) {
#line 152
      c1 = (char )(((int )c1 - 65) + 97);
    } else {
#line 152
      c1 = c1;
    }
  } else {
#line 152
    c1 = c1;
  }
#line 153
  if ((int )c2 >= 65) {
#line 153
    if ((int )c2 <= 90) {
#line 153
      c2 = (char )(((int )c2 - 65) + 97);
    } else {
#line 153
      c2 = c2;
    }
  } else {
#line 153
    c2 = c2;
  }
#line 154
  return ((_Bool )((int )c1 == (int )c2));
}
}
#line 157 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menubar_paint___0(void) 
{ 
  int i ;
  Menu *omenu ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 160
  restore_screen();
  }
  {
#line 162
  kurses_color_at(7);
  }
  {
#line 163
  tmp = kurses_width();
  }
  {
#line 163
  draw_hline(0, 0, tmp, ' ', ' ', ' ');
  }
#line 165
  i = 0;
  }
  {
  {
#line 165
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < menu_count___0)) {
#line 165
      goto while_break;
    }
    {
    {
#line 166
    kurses_move(menu___1[i].startcol, 0);
    }
    {
#line 167
    menuitem_print___0(menu___1[i].caption, (_Bool )(i == open_menu___0), -1);
    }
#line 165
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  omenu = & menu___1[open_menu___0];
#line 173
  if (! omenu->menu_h) {
    {
    {
#line 173
    menu_calc_dims___0(omenu);
    }
    }
  }
  {
  {
#line 176
  kurses_color_at(7);
  }
  {
#line 177
  draw_window(omenu->startcol, 1, omenu->menu_w + 2, omenu->menu_h + 2, "");
  }
#line 178
  i = 0;
  }
  {
  {
#line 178
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < omenu->item_count)) {
#line 178
      goto while_break___0;
    }
    {
    {
#line 179
    kurses_move(omenu->startcol + 1, i + 2);
    }
    {
#line 180
    menuitem_print___0(omenu->item[i].caption, (_Bool )(i == menu_sel___0), omenu->menu_w);
    }
#line 178
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 184
  tmp___0 = kurses_height();
  }
  {
#line 184
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 185
  kurses_color_at(7);
  }
  {
#line 186
  tmp___1 = strlen(omenu->item[menu_sel___0].desc);
  }
#line 186
  i = (int )tmp___1;
  {
#line 187
  waddnstr(stdscr, omenu->item[menu_sel___0].desc, -1);
  }
  }
  {
  {
#line 188
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
#line 188
    tmp___2 = i;
#line 188
    i ++;
    {
#line 188
    tmp___3 = kurses_width();
    }
    }
#line 188
    if (! (tmp___2 < tmp___3)) {
#line 188
      goto while_break___1;
    }
    {
    {
#line 188
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 190
  tmp___4 = kurses_height();
  }
  {
#line 190
  tmp___5 = kurses_width();
  }
  {
#line 190
  kurses_move(tmp___5 - 1, tmp___4 - 1);
  }
  {
#line 191
  wrefresh(stdscr);
  }
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menuitem_print___0(char const   *s , _Bool sel , int minlen ) 
{ 
  _Bool next_is_accel ;
  int printed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 195
  next_is_accel = (_Bool)0;
#line 196
  printed = 0;
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (! *s) {
#line 197
      if (! (printed < minlen)) {
#line 197
        goto while_break;
      }
    }
#line 198
    if ((int const   )*s == 38) {
#line 199
      next_is_accel = (_Bool)1;
#line 200
      s ++;
#line 201
      goto while_continue;
    }
#line 204
    if (sel) {
#line 204
      if (next_is_accel) {
#line 204
        tmp = 225;
      } else {
#line 204
        tmp = 241;
      }
#line 204
      tmp___1 = tmp;
    } else {
#line 204
      if (next_is_accel) {
#line 204
        tmp___0 = 23;
      } else {
#line 204
        tmp___0 = 7;
      }
#line 204
      tmp___1 = tmp___0;
    }
    {
    {
#line 204
    kurses_color_at(tmp___1);
    }
    }
#line 208
    if (*s) {
#line 208
      tmp___2 = (int const   )*s;
    } else {
#line 208
      tmp___2 = (int const   )' ';
    }
    {
    {
#line 208
    waddch(stdscr, (chtype const   )tmp___2);
    }
#line 209
    printed ++;
#line 211
    next_is_accel = (_Bool)0;
    }
#line 212
    if (*s) {
#line 212
      s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menu_calc_dims___0(Menu *m ) 
{ 
  int i ;
  int width___0 ;
  int len ;
  size_t tmp ;

  {
#line 218
  width___0 = 1;
#line 218
  len = 0;
#line 220
  i = 0;
  {
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < m->item_count)) {
#line 220
      goto while_break;
    }
    {
    {
#line 221
    tmp = strlen(m->item[i].caption);
    }
#line 221
    len = (int )tmp;
    }
#line 222
    if (len > width___0) {
#line 222
      width___0 = len;
    }
#line 220
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  m->menu_h = m->item_count;
#line 226
  m->menu_w = width___0;
#line 227
  return;
}
}
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.h"
DArray *darray_create(void) ;
#line 47
DArray *darray_create_ex(int cap , void (*vd)(void * ) ) ;
#line 51
void darray_destroy(DArray *da ) ;
#line 56
int darray_len(DArray *da ) ;
#line 64
void *darray_get(DArray *da , int i ) ;
#line 70
void *darray_snatch(DArray *da , int i ) ;
#line 86
void darray_set(DArray *da , int i , void const   *v ) ;
#line 89
void darray_append(DArray *da , void const   *v ) ;
#line 92
void darray_remove(DArray *da , int i ) ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
void *srealloc(void *buf___15 , int newsize ) ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
DArray *darray_create(void) 
{ 
  DArray *tmp ;

  {
  {
  {
#line 52
  tmp = darray_create_ex(20, (void (*)(void * ))((void *)0));
  }
  }
#line 52
  return (tmp);
}
}
#line 55 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
DArray *darray_create_ex(int cap , void (*vd)(void * ) ) 
{ 
  DArray *da ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 56
  tmp = zalloc((int )sizeof(DArray ));
  }
#line 56
  da = (DArray *)tmp;
#line 58
  da->len = 0;
  }
#line 59
  if (cap > 0) {
#line 59
    da->cap = cap;
  } else {
#line 59
    da->cap = 20;
  }
  {
  {
#line 60
  tmp___0 = zalloc((int )(sizeof(void *) * (unsigned long )da->cap));
  }
#line 60
  da->items = (void **)tmp___0;
#line 61
  da->value_destroyer = vd;
  }
#line 63
  return (da);
}
}
#line 66 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
void darray_destroy(DArray *da ) 
{ 
  int i ;

  {
#line 68
  if (! da) {
#line 68
    return;
  }
#line 69
  if (da->value_destroyer) {
#line 71
    i = 0;
    {
    {
#line 71
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 71
      if (! (i < da->len)) {
#line 71
        goto while_break;
      }
#line 72
      if (*(da->items + i)) {
        {
        {
#line 72
        (*(da->value_destroyer))(*(da->items + i));
        }
        }
      }
#line 71
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 76
  sfree((void *)da->items);
  }
  {
#line 77
  sfree((void *)da);
  }
  }
#line 78
  return;
}
}
#line 80 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
int darray_len(DArray *da ) 
{ 


  {
#line 82
  return (da->len);
}
}
#line 85 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
void *darray_get(DArray *da , int i ) 
{ 
  void *tmp ;

  {
#line 86
  if (i >= 0) {
#line 86
    if (i < da->len) {
#line 86
      tmp = *(da->items + i);
    } else {
#line 86
      tmp = (void *)0;
    }
  } else {
#line 86
    tmp = (void *)0;
  }
#line 86
  return (tmp);
}
}
#line 89 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
void darray_set(DArray *da , int i , void const   *v ) 
{ 
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 90
  if (i < 0) {
    {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** FATAL ERROR ***\nAttempt to darray_set with negative index %d\n",
            i);
    }
    {
#line 93
    abort();
    }
    }
  } else
#line 95
  if (i >= da->len) {
    {
#line 96
    da->cap = i + 20;
    {
#line 97
    tmp = srealloc((void *)da->items, (int )(sizeof(void *) * (unsigned long )da->cap));
    }
#line 97
    da->items = (void **)tmp;
    }
    {
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 100
      if (! (i >= da->len)) {
#line 100
        goto while_break;
      }
#line 100
      tmp___0 = da->len;
#line 100
      (da->len) ++;
#line 100
      *(da->items + tmp___0) = (void *)0;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 104
  if (*(da->items + i)) {
#line 104
    if (da->value_destroyer) {
      {
      {
#line 105
      (*(da->value_destroyer))(*(da->items + i));
      }
      }
    }
  }
#line 108
  *(da->items + i) = (void *)v;
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
void *darray_snatch(DArray *da , int i ) 
{ 
  void *v ;

  {
#line 113
  if (i >= 0) {
#line 113
    if (i < da->len) {
#line 114
      v = *(da->items + i);
#line 115
      *(da->items + i) = (void *)0;
#line 116
      return (v);
    } else {
#line 118
      return ((void *)0);
    }
  } else {
#line 118
    return ((void *)0);
  }
}
}
#line 121 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
void darray_append(DArray *da , void const   *v ) 
{ 


  {
  {
  {
#line 122
  darray_set(da, da->len, v);
  }
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/darray.c"
void darray_remove(DArray *da , int i ) 
{ 


  {
#line 126
  if (i < 0) {
#line 126
    return;
  } else
#line 126
  if (i >= da->len) {
#line 126
    return;
  }
#line 127
  if (*(da->items + i)) {
#line 127
    if (da->value_destroyer) {
      {
      {
#line 128
      (*(da->value_destroyer))(*(da->items + i));
      }
      }
    }
  }
  {
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < da->len - 1)) {
#line 130
      goto while_break;
    }
#line 131
    *(da->items + i) = *(da->items + (i + 1));
#line 132
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  (da->len) --;
#line 136
  return;
}
}
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/colordlg.c"
static void paint_dlg___1(void) 
{ 
  int x0 ;
  int y0 ;
  int i ;
  int j ;
  char hexdigit___3[17] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 42
  hexdigit___3[0] = (char )'0';
#line 42
  hexdigit___3[1] = (char )'1';
#line 42
  hexdigit___3[2] = (char )'2';
#line 42
  hexdigit___3[3] = (char )'3';
#line 42
  hexdigit___3[4] = (char )'4';
#line 42
  hexdigit___3[5] = (char )'5';
#line 42
  hexdigit___3[6] = (char )'6';
#line 42
  hexdigit___3[7] = (char )'7';
#line 42
  hexdigit___3[8] = (char )'8';
#line 42
  hexdigit___3[9] = (char )'9';
#line 42
  hexdigit___3[10] = (char )'a';
#line 42
  hexdigit___3[11] = (char )'b';
#line 42
  hexdigit___3[12] = (char )'c';
#line 42
  hexdigit___3[13] = (char )'d';
#line 42
  hexdigit___3[14] = (char )'e';
#line 42
  hexdigit___3[15] = (char )'f';
#line 42
  hexdigit___3[16] = (char )'\000';
  {
#line 44
  kurses_color(7, 0);
  }
  {
#line 45
  draw_centered_window(39, 21, "Choose Color", & x0, & y0);
  }
  {
#line 48
  kurses_color(12, 0);
  }
  {
#line 49
  kurses_move((x0 + 4) + 2 * _bg, y0);
  }
  {
#line 50
  waddch(stdscr, (chtype const   )'b');
  }
  {
#line 53
  kurses_color(10, 0);
  }
  {
#line 54
  kurses_move(x0, (y0 + 2) + _fg);
  }
  {
#line 55
  waddch(stdscr, (chtype const   )'f');
  }
  {
#line 58
  kurses_color(7, 0);
  }
  {
#line 59
  kurses_move(x0 + 4, y0 + 1);
  }
  {
#line 60
  waddnstr(stdscr, "0 1 2 3 4 5 6 7 8 9 a b c d e f", -1);
  }
#line 63
  i = 0;
  }
  {
  {
#line 63
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 16)) {
#line 63
      goto while_break;
    }
    {
    {
#line 64
    kurses_move(x0 + 2, (y0 + 2) + i);
    }
    {
#line 65
    waddch(stdscr, (chtype const   )hexdigit___3[i]);
    }
#line 63
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  i = 0;
  {
  {
#line 69
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 16)) {
#line 69
      goto while_break___0;
    }
    {
    {
#line 70
    kurses_move(x0 + 4, (y0 + 2) + i);
    }
#line 71
    j = 0;
    }
    {
    {
#line 71
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! (j < 16)) {
#line 71
        goto while_break___1;
      }
      {
      {
#line 72
      kurses_color(i, j);
      }
      {
#line 73
      waddnstr(stdscr, "Aa", -1);
      }
#line 71
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 69
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 78
  kurses_move((x0 + 4) + 2 * _bg, (y0 + 2) + _fg);
  }
  }
#line 79
  return;
}
}
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 507
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_fld  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *cancel_btn  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *ok_btn  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_lbl  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *dirs_box  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *files_box  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_stlbl  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_stlbl  ;
#line 99 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlForm *form  ;
#line 101 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *curdir  =    (char *)((void *)0);
#line 107
static void _update_widgets(void) ;
#line 109 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static _Bool _is_dir_valid(char const   *dir ) 
{ 
  DIR *d ;
  DIR *tmp ;

  {
  {
  {
#line 110
  tmp = opendir(dir);
  }
#line 110
  d = tmp;
  }
#line 111
  if (d) {
    {
    {
#line 112
    closedir(d);
    }
    }
#line 113
    return ((_Bool)1);
  }
#line 116
  return ((_Bool)0);
}
}
#line 119 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *my_getcwd(void) 
{ 
  int cap ;
  char *s ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 121
  cap = 32;
  {
#line 121
  tmp = malloc((size_t )cap);
  }
#line 121
  s = (char *)tmp;
  }
  {
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 123
    tmp___2 = getcwd(s, (size_t )cap);
    }
    }
#line 123
    if (tmp___2) {
#line 123
      goto while_break;
    }
    {
    {
#line 124
    tmp___0 = __errno_location();
    }
    }
#line 124
    if (*tmp___0 != 34) {
#line 124
      return ((char *)((void *)0));
    }
    {
#line 125
    cap += cap;
    {
#line 125
    tmp___1 = malloc((size_t )cap);
    }
#line 125
    s = (char *)tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (s);
}
}
#line 131 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *_get_canon_dir_path(char const   *base , char const   *relative ) 
{ 
  char *oldpwd ;
  char *tmp ;
  char *retval ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 133
  tmp = my_getcwd();
  }
#line 133
  oldpwd = tmp;
  }
#line 136
  if (! oldpwd) {
#line 136
    return ((char *)((void *)0));
  }
  {
  {
#line 138
  tmp___0 = chdir(base);
  }
  }
#line 138
  if (0 != tmp___0) {
#line 138
    return ((char *)((void *)0));
  }
  {
  {
#line 139
  tmp___1 = chdir(relative);
  }
  }
#line 139
  if (0 != tmp___1) {
#line 139
    return ((char *)((void *)0));
  }
  {
  {
#line 141
  retval = my_getcwd();
  }
  {
#line 143
  tmp___4 = chdir((char const   *)oldpwd);
  }
  }
#line 143
  if (0 != tmp___4) {
    {
    {
#line 144
    tmp___2 = __errno_location();
    }
    {
#line 144
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PANIC: Can\'t go back to old wd \'%s\'\n%s\n",
            oldpwd, tmp___3);
    }
    {
#line 146
    abort();
    }
    }
  }
#line 149
  return (retval);
}
}
#line 152 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
char *filedlg_show(char const   *title ) 
{ 
  int w ;
  int h ;
  int r ;
  int ch ;
  int s ;
  char *retval ;
  _Bool tmp ;
  char const   *s___0 ;
  int tmp___0 ;
  char const   *tmp___1 ;
  AewlWidget *tmp___2 ;
  char const   *fieldtext ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char const   *d ;
  char const   *tmp___7 ;
  char *canon_path ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 154
  retval = (char *)((void *)0);
#line 159
  if (! curdir) {
#line 159
    goto _L;
  } else {
    {
    {
#line 159
    tmp = _is_dir_valid((char const   *)curdir);
    }
    }
#line 159
    if (! tmp) {
      _L: /* CIL Label */ 
      {
      {
#line 160
      curdir = my_getcwd();
      }
      }
#line 161
      if (! curdir) {
        {
        {
#line 161
        curdir = strdup("/");
        }
        }
      }
    }
  }
  {
  {
#line 167
  push_screen();
  }
  {
#line 168
  wclear(stdscr);
  }
  {
#line 170
  kurses_color(14, 0);
  }
  {
#line 171
  kurses_move(0, 0);
  }
  {
#line 172
  waddnstr(stdscr, title, -1);
  }
  {
#line 174
  w = kurses_width();
  }
  {
#line 175
  h = kurses_height();
  }
  {
#line 177
  form = aewl_form_create(stdscr);
  }
  {
#line 178
  filename_stlbl = aewl_label_create(1, 2, 0, "File &Name:");
  }
  {
#line 180
  directory_stlbl = aewl_label_create(1, 3, 0, "Directory:");
  }
  {
#line 182
  filename_fld = aewl_field_create(13, 2, ((((w - 11) - 11) - 2) - 13) - 3, 413, 1001,
                                   "");
  }
  {
#line 184
  directory_lbl = aewl_label_create(13, 3, w - 13, "");
  }
  {
#line 186
  cancel_btn = aewl_button_create(((w - 11) - 11) - 2, 2, 11, 0, 1004, "Cancel");
  }
  {
#line 188
  ok_btn = aewl_button_create(w - 11, 2, 11, 0, 1005, "OK");
  }
  {
#line 190
  files_box = aewl_listbox_create((1 + w / 3) + 2, 5, (w - ((1 + w / 3) + 2)) - 1,
                                  h - 6, 405, "&Files", 1002);
  }
  {
#line 193
  dirs_box = aewl_listbox_create(1, 5, w / 3, h - 6, 403, "&Directory", 1003);
  }
  {
#line 198
  aewl_label_set_focus_peer((AewlLabel *)filename_stlbl, filename_fld);
  }
  {
#line 201
  aewl_form_add_widget(form, filename_stlbl);
  }
  {
#line 202
  aewl_form_add_widget(form, directory_stlbl);
  }
  {
#line 203
  aewl_form_add_widget(form, filename_fld);
  }
  {
#line 204
  aewl_form_add_widget(form, directory_lbl);
  }
  {
#line 205
  aewl_form_add_widget(form, cancel_btn);
  }
  {
#line 206
  aewl_form_add_widget(form, ok_btn);
  }
  {
#line 207
  aewl_form_add_widget(form, dirs_box);
  }
  {
#line 208
  aewl_form_add_widget(form, files_box);
  }
  {
#line 211
  _update_widgets();
  }
  {
#line 212
  aewl_form_paint(form, (_Bool)1);
  }
  }
  {
  {
#line 213
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 216
    tmp___2 = aewl_form_get_focus_widget(form);
    }
    }
#line 216
    if ((unsigned long )tmp___2 == (unsigned long )files_box) {
      {
      {
#line 217
      tmp___0 = aewl_listbox_get_sel((AewlListBox *)files_box);
      }
      {
#line 217
      tmp___1 = aewl_listbox_get((AewlListBox *)files_box, tmp___0);
      }
#line 217
      s___0 = tmp___1;
      }
#line 219
      if (s___0) {
        {
        {
#line 219
        aewl_field_set_text((AewlField *)filename_fld, s___0);
        }
        }
      }
      {
      {
#line 220
      aewl_form_paint(form, (_Bool)1);
      }
      }
    }
    {
    {
#line 224
    ch = wgetch(stdscr);
    }
    {
#line 225
    r = aewl_form_dispatch_key(form, ch);
    }
    }
#line 228
    if (r == 1004) {
#line 231
      retval = (char *)((void *)0);
#line 232
      goto while_break;
    } else
#line 228
    if (ch == 27) {
#line 231
      retval = (char *)((void *)0);
#line 232
      goto while_break;
    } else
#line 228
    if (ch == 3) {
#line 231
      retval = (char *)((void *)0);
#line 232
      goto while_break;
    } else
#line 228
    if (ch == 7) {
#line 231
      retval = (char *)((void *)0);
#line 232
      goto while_break;
    } else
#line 234
    if (r == 1001) {
#line 234
      goto _L___0;
    } else
#line 234
    if (r == 1005) {
#line 234
      goto _L___0;
    } else
#line 234
    if (r == 1002) {
      _L___0: /* CIL Label */ 
      {
      {
#line 239
      tmp___3 = aewl_field_get_text((AewlField *)filename_fld);
      }
#line 239
      fieldtext = tmp___3;
      {
#line 246
      tmp___4 = strlen(fieldtext);
      }
      {
#line 246
      tmp___5 = strlen((char const   *)curdir);
      }
      {
#line 246
      tmp___6 = malloc((tmp___4 + tmp___5) + 6U);
      }
#line 246
      retval = (char *)tmp___6;
      {
#line 247
      sprintf((char */* __restrict  */)retval, (char const   */* __restrict  */)"%s/%s",
              curdir, fieldtext);
      }
      }
#line 248
      goto while_break;
    } else
#line 250
    if (r == 1003) {
      {
      {
#line 250
      s = aewl_listbox_get_sel((AewlListBox *)dirs_box);
      }
      }
#line 250
      if (s >= 0) {
        {
        {
#line 254
        tmp___7 = aewl_listbox_get((AewlListBox *)dirs_box, s);
        }
#line 254
        d = tmp___7;
        {
#line 257
        tmp___8 = _get_canon_dir_path((char const   *)curdir, d);
        }
#line 257
        canon_path = tmp___8;
        }
#line 259
        if (! canon_path) {
#line 259
          return ((char *)((void *)0));
        }
        {
        {
#line 261
        tmp___9 = _is_dir_valid((char const   *)canon_path);
        }
        }
#line 261
        if (tmp___9) {
#line 262
          if (curdir) {
            {
            {
#line 262
            free((void *)curdir);
            }
            }
          }
          {
#line 263
          curdir = canon_path;
          {
#line 266
          aewl_field_set_text((AewlField *)filename_fld, "");
          }
          {
#line 268
          _update_widgets();
          }
          {
#line 269
          aewl_form_paint(form, (_Bool)1);
          }
          }
        } else {
          {
          {
#line 272
          free((void *)canon_path);
          }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 277
  aewl_form_destroy(form);
  }
  {
#line 278
  pop_screen();
  }
  }
#line 280
  return (retval);
}
}
#line 283 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static void _update_widgets(void) 
{ 
  DIR *d ;
  struct dirent *dent ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *compname ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 288
  d = opendir((char const   *)curdir);
  }
  }
#line 290
  if (! d) {
    {
    {
#line 291
    tmp = __errno_location();
    }
    {
#line 291
    tmp___0 = strerror(*tmp);
    }
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR in opendir(\"%s\"): %s\n",
            curdir, tmp___0);
    }
    {
#line 293
    abort();
    }
    }
  }
  {
  {
#line 296
  aewl_listbox_clear((AewlListBox *)dirs_box);
  }
  {
#line 297
  aewl_listbox_clear((AewlListBox *)files_box);
  }
  }
  {
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 298
    dent = readdir(d);
    }
    }
#line 298
    if (! dent) {
#line 298
      goto while_break;
    }
    {
    {
#line 299
    tmp___1 = strlen((char const   *)(dent->d_name));
    }
    {
#line 299
    tmp___2 = strlen((char const   *)curdir);
    }
    {
#line 299
    tmp___3 = zalloc((int )((tmp___1 + tmp___2) + 2U));
    }
#line 299
    compname = (char *)tmp___3;
    {
#line 300
    sprintf((char */* __restrict  */)compname, (char const   */* __restrict  */)"%s/%s",
            curdir, dent->d_name);
    }
    {
#line 302
    tmp___4 = stat((char const   */* __restrict  */)compname, (struct stat */* __restrict  */)(& st));
    }
    }
#line 302
    if (0 != tmp___4) {
#line 302
      goto while_continue;
    }
    {
    {
#line 304
    free((void *)compname);
    }
    }
#line 306
    if ((st.st_mode & 61440U) == 16384U) {
      {
      {
#line 307
      aewl_listbox_add((AewlListBox *)dirs_box, (char const   *)(dent->d_name));
      }
      }
    } else {
      {
      {
#line 309
      aewl_listbox_add((AewlListBox *)files_box, (char const   *)(dent->d_name));
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 311
  aewl_listbox_sort((AewlListBox *)dirs_box);
  }
  {
#line 312
  aewl_listbox_sort((AewlListBox *)files_box);
  }
  {
#line 314
  closedir(d);
  }
  {
#line 317
  aewl_label_set_text((AewlLabel *)directory_lbl, (char const   *)curdir);
  }
  }
#line 318
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.h"
VirtualLayer *vlayer_create(int width___0 , int height___0 , void (*get_cell)(Cell *r_cell ,
                                                                              int x ,
                                                                              int y ,
                                                                              void *ud ) ,
                            void *user_data ) ;
#line 5 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_LYR(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Layer *l ;

  {
#line 6
  l = (Layer *)ud;
#line 7
  *r_cell = *(*(l->cells + x) + y);
#line 8
  return;
}
}
#line 11 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_COMPOSITE(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Document *doc___0 ;

  {
  {
#line 12
  doc___0 = doc___0;
  {
#line 13
  *r_cell = document_calc_effective_cell(doc___0, x, y);
  }
  }
#line 14
  return;
}
}
#line 16 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
VirtualLayer *vlayer_create(int width___0 , int height___0 , void (*get_cell)(Cell *r_cell ,
                                                                              int x ,
                                                                              int y ,
                                                                              void *ud ) ,
                            void *user_data ) 
{ 
  VirtualLayer *vl ;
  void *tmp ;

  {
  {
  {
#line 18
  tmp = zalloc((int )sizeof(VirtualLayer ));
  }
#line 18
  vl = (VirtualLayer *)tmp;
#line 19
  vl->width = width___0;
#line 20
  vl->height = height___0;
#line 21
  vl->get_cell = get_cell;
#line 22
  vl->user_data = user_data;
  }
#line 23
  return (vl);
}
}
#line 26 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
VirtualLayer *vlayer_create_from_layer(Layer *l ) 
{ 
  VirtualLayer *tmp ;

  {
  {
  {
#line 27
  tmp = vlayer_create(l->width, l->height, & _get_cell_LYR, (void *)l);
  }
  }
#line 27
  return (tmp);
}
}
#line 30 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
VirtualLayer *vlayer_create_from_composite(Document *doc___0 ) 
{ 
  VirtualLayer *tmp ;

  {
#line 31
  if (doc___0->layer_count <= 0) {
#line 31
    return ((VirtualLayer *)((void *)0));
  }
  {
  {
#line 32
  tmp = vlayer_create((*(doc___0->layers + 0))->width, (*(doc___0->layers + 0))->height,
                      & _get_cell_COMPOSITE, (void *)doc___0);
  }
  }
#line 32
  return (tmp);
}
}
#line 36 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
void vlayer_destroy(VirtualLayer *vl ) 
{ 


  {
#line 37
  if (! vl) {
#line 37
    return;
  }
  {
  {
#line 38
  sfree((void *)vl);
  }
  }
#line 39
  return;
}
}
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
void vlayer_get_cell(VirtualLayer *vl , Cell *r_cell , int x , int y ) 
{ 


  {
#line 42
  if (x < 0) {
#line 43
    r_cell->ch = (unsigned char )' ';
#line 44
    r_cell->attr = (unsigned char)112;
  } else
#line 42
  if (x >= vl->width) {
#line 43
    r_cell->ch = (unsigned char )' ';
#line 44
    r_cell->attr = (unsigned char)112;
  } else
#line 42
  if (y < 0) {
#line 43
    r_cell->ch = (unsigned char )' ';
#line 44
    r_cell->attr = (unsigned char)112;
  } else
#line 42
  if (y >= vl->height) {
#line 43
    r_cell->ch = (unsigned char )' ';
#line 44
    r_cell->attr = (unsigned char)112;
  } else {
    {
    {
#line 46
    (*(vl->get_cell))(r_cell, x, y, vl->user_data);
    }
    }
  }
#line 47
  return;
}
}
#line 43 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static char *logo[6]  = {      (char *)"79         ",      (char *)"||         ",      (char *)"46799 97979",      (char *)"||43|||||||", 
        (char *)"311-1231231",      (char *)((void *)0)};
#line 52 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static int logo_colors[5]  = {      4,      6,      7,      6, 
        4};
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
void show_welcome_dlg(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  int ch ;
  int *clr ;
  char **p ;
  char *q ;
  int acschars[10] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 57
  acschars[0] = (int )acs_map[(unsigned char )'a'];
#line 57
  acschars[1] = (int )acs_map[(unsigned char )'m'];
#line 57
  acschars[2] = (int )acs_map[(unsigned char )'v'];
#line 57
  acschars[3] = (int )acs_map[(unsigned char )'j'];
#line 57
  acschars[4] = (int )acs_map[(unsigned char )'t'];
#line 57
  acschars[5] = (int )acs_map[(unsigned char )'n'];
#line 57
  acschars[6] = (int )acs_map[(unsigned char )'u'];
#line 57
  acschars[7] = (int )acs_map[(unsigned char )'l'];
#line 57
  acschars[8] = (int )acs_map[(unsigned char )'w'];
#line 57
  acschars[9] = (int )acs_map[(unsigned char )'k'];
  {
#line 70
  kurses_color(4, 0);
  }
  {
#line 71
  draw_centered_window(46, 18, "Welcome to AEWAN", & x0, & y0);
  }
#line 72
  y = y0 + 1;
#line 75
  p = logo;
#line 75
  clr = logo_colors;
  }
  {
  {
#line 75
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 75
    if (! *p) {
#line 75
      goto while_break;
    }
    {
    {
#line 76
    kurses_color(*clr, 0);
    }
#line 77
    tmp = y;
#line 77
    y ++;
    {
#line 77
    kurses_move(x0, tmp);
    }
#line 78
    q = *p;
    }
    {
    {
#line 78
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! *q) {
#line 78
        goto while_break___0;
      }
#line 79
      if ((int )*q >= 48) {
#line 79
        if ((int )*q <= 57) {
#line 79
          ch = acschars[(int )*q - 48];
        } else {
#line 79
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 80
      if ((int )*q == 45) {
#line 80
        ch = (int )acs_map[(unsigned char )'q'];
      } else
#line 81
      if ((int )*q == 124) {
#line 81
        ch = (int )acs_map[(unsigned char )'x'];
      } else {
#line 82
        ch = ' ';
      }
      {
      {
#line 83
      waddch(stdscr, (chtype const   )ch);
      }
#line 78
      q ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 75
    p ++;
#line 75
    clr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  x = (x0 + 11) + 2;
#line 89
  y = y0 + 1;
#line 91
  tmp___0 = y;
#line 91
  y ++;
  {
#line 91
  kurses_move(x, tmp___0);
  }
  {
#line 92
  kurses_color(12, 0);
  }
  {
#line 93
  waddnstr(stdscr, "AEWAN ascii art editor", -1);
  }
#line 95
  tmp___1 = y;
#line 95
  y ++;
  {
#line 95
  kurses_move(x, tmp___1);
  }
  {
#line 96
  kurses_color(7, 0);
  }
  {
#line 97
  waddnstr(stdscr, "Copyright (c) 2003", -1);
  }
#line 99
  tmp___2 = y;
#line 99
  y ++;
  {
#line 99
  kurses_move(x, tmp___2);
  }
  {
#line 100
  waddnstr(stdscr, "Bruno T. C. de Oliveira", -1);
  }
#line 102
  tmp___3 = y;
#line 102
  y ++;
  {
#line 102
  kurses_move(x, tmp___3);
  }
  {
#line 103
  waddnstr(stdscr, "All rights reserved.", -1);
  }
#line 105
  y += 2;
#line 105
  x = x0 + 1;
#line 106
  tmp___4 = y;
#line 106
  y ++;
  {
#line 106
  kurses_move(x, tmp___4);
  }
  {
#line 107
  kurses_color(12, 0);
  }
  {
#line 108
  waddnstr(stdscr, "Program version: ", -1);
  }
  {
#line 109
  kurses_color(7, 0);
  }
  {
#line 110
  waddnstr(stdscr, "1.0.01 (novae)", -1);
  }
#line 112
  y ++;
#line 113
  tmp___5 = y;
#line 113
  y ++;
  {
#line 113
  kurses_move(x, tmp___5);
  }
  {
#line 114
  waddnstr(stdscr, "This program is licensed under the GNU", -1);
  }
#line 116
  tmp___6 = y;
#line 116
  y ++;
  {
#line 116
  kurses_move(x, tmp___6);
  }
  {
#line 117
  waddnstr(stdscr, "General Public License. Please refer to", -1);
  }
#line 119
  tmp___7 = y;
#line 119
  y ++;
  {
#line 119
  kurses_move(x, tmp___7);
  }
  {
#line 120
  waddnstr(stdscr, "the COPYING file for more information.", -1);
  }
#line 122
  y ++;
#line 123
  tmp___8 = y;
#line 123
  y ++;
  {
#line 123
  kurses_move(x, tmp___8);
  }
  {
#line 124
  waddnstr(stdscr, "Press RETURN to continue. When in the", -1);
  }
#line 125
  tmp___9 = y;
#line 125
  y ++;
  {
#line 125
  kurses_move(x, tmp___9);
  }
  {
#line 126
  waddnstr(stdscr, "program, press <F1> to display a menu.", -1);
  }
  {
#line 128
  wgetch(stdscr);
  }
  }
#line 129
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.h"
int kurses_line_input(char *buf___15 , int buf_size ) ;
#line 41 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.h"
int ui_cancel  ;
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare_ex(int fg , int bg ) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 46
  tmp = kurses_width();
  }
#line 46
  w = tmp;
  {
#line 47
  tmp___0 = kurses_height();
  }
  {
#line 47
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 48
  kurses_color(fg, bg);
  }
  }
  {
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 49
    tmp___1 = w;
#line 49
    w --;
#line 49
    if (! tmp___1) {
#line 49
      goto while_break;
    }
    {
    {
#line 49
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 50
  tmp___2 = kurses_height();
  }
  {
#line 50
  kurses_move(0, tmp___2 - 1);
  }
#line 51
  ui_cancel = 0;
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare(void) 
{ 


  {
  {
  {
#line 55
  ui_prepare_ex(15, 4);
  }
  }
#line 56
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___1[32]  ;
#line 59 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
int ui_ask_i(char const   *prompt , int def , int min , int max ) 
{ 
  int ans ;
  int tmp ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 63
    ui_prepare();
    }
    {
#line 64
    printw("%s [%d]: ", prompt, def);
    }
    {
#line 65
    tmp = kurses_line_input(buf___1, 32);
    }
    }
#line 65
    if (! tmp) {
#line 65
      ui_cancel = -1;
#line 65
      return (ui_cancel);
    }
#line 66
    if (! buf___1[0]) {
#line 66
      return (def);
    }
    {
    {
#line 67
    ans = atoi((char const   *)(buf___1));
    }
    }
#line 62
    if (ans >= min) {
#line 62
      if (ans <= max) {
#line 62
        goto while_break;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  return (ans);
}
}
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___2[256]  ;
#line 73 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
char *ui_ask_s(char const   *prompt , char const   *def ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 75
  ui_prepare();
  }
  }
#line 77
  if (def) {
    {
    {
#line 77
    printw("%s [%s]: ", prompt, def);
    }
    }
  } else {
    {
    {
#line 78
    printw("%s: ", prompt);
    }
    }
  }
  {
  {
#line 80
  tmp = kurses_line_input(buf___2, 256);
  }
  }
#line 80
  if (! tmp) {
#line 80
    ui_cancel = -1;
#line 80
    return ((char *)((void *)0));
  }
#line 85
  if (! buf___2[0]) {
#line 85
    if (def) {
      {
      {
#line 85
      tmp___0 = strdup(def);
      }
      }
#line 85
      return (tmp___0);
    } else {
      {
      {
#line 86
      tmp___1 = strdup((char const   *)(buf___2));
      }
      }
#line 86
      return (tmp___1);
    }
  } else {
    {
    {
#line 86
    tmp___1 = strdup((char const   *)(buf___2));
    }
    }
#line 86
    return (tmp___1);
  }
}
}
#line 91 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char hexdigit[17]  = 
#line 91
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 89 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
int ui_ask_color(char const   *prompt ) 
{ 
  int i ;
  int tmp ;
  int ch ;
  int color_code ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 92
  ui_prepare();
  }
  {
#line 93
  printw("%s ", prompt);
  }
#line 96
  i = 0;
  }
  {
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i <= 15)) {
#line 96
      goto while_break;
    }
#line 97
    if (i) {
#line 97
      tmp = 0;
    } else {
#line 97
      tmp = 7;
    }
    {
    {
#line 97
    kurses_color(i, tmp);
    }
    {
#line 98
    printw(" %c ", (int )hexdigit[i]);
    }
#line 96
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 101
  kurses_color(0, 7);
  }
  {
#line 102
  printw(": ");
  }
  }
  {
  {
#line 104
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 106
    ch = wgetch(stdscr);
    }
    }
#line 106
    if (ch >= 97) {
#line 106
      if (ch <= 102) {
#line 106
        color_code = (ch - 97) + 10;
      } else {
#line 106
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 106
      if (ch >= 65) {
#line 106
        if (ch <= 70) {
#line 106
          tmp___0 = (ch - 65) + 10;
        } else {
#line 106
          tmp___0 = ch - 48;
        }
      } else {
#line 106
        tmp___0 = ch - 48;
      }
#line 106
      color_code = tmp___0;
    }
#line 109
    if (ch == 27) {
#line 109
      ui_cancel = -1;
#line 109
      return (ui_cancel);
    } else
#line 109
    if (ch == 3) {
#line 109
      ui_cancel = -1;
#line 109
      return (ui_cancel);
    } else
#line 109
    if (ch == 7) {
#line 109
      ui_cancel = -1;
#line 109
      return (ui_cancel);
    }
#line 110
    if (color_code >= 0) {
#line 110
      if (color_code <= 15) {
#line 110
        return (color_code);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 114 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
int ui_ask_yn(char const   *prompt , int defyes ) 
{ 
  char const   *tmp ;
  int ch ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 115
  ui_prepare();
  }
  }
#line 116
  if (defyes) {
#line 116
    tmp = "Yes";
  } else {
#line 116
    tmp = "No";
  }
  {
  {
#line 116
  printw("%s [%s] ", prompt, tmp);
  }
  }
  {
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 118
    tmp___0 = wgetch(stdscr);
    }
#line 118
    ch = tmp___0;
    }
    {
#line 120
    if (ch == 10) {
#line 120
      goto case_10;
    }
#line 122
    if (ch == 89) {
#line 122
      goto case_89;
    }
#line 122
    if (ch == 121) {
#line 122
      goto case_89;
    }
#line 123
    if (ch == 78) {
#line 123
      goto case_78;
    }
#line 123
    if (ch == 110) {
#line 123
      goto case_78;
    }
#line 127
    if (ch == 7) {
#line 127
      goto case_7;
    }
#line 127
    if (ch == 3) {
#line 127
      goto case_7;
    }
#line 127
    if (ch == 27) {
#line 127
      goto case_7;
    }
#line 119
    goto switch_break;
    case_10: /* CIL Label */ 
#line 120
    return (defyes);
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 122
    return (1);
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 123
    return (0);
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 127
    ui_cancel = -1;
#line 127
    return (ui_cancel);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 132 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
void ui_message(char const   *msg___1 , int error ) 
{ 


  {
#line 133
  if (error) {
    {
    {
#line 134
    ui_prepare_ex(15, 1);
    }
    }
  } else {
    {
    {
#line 136
    ui_prepare();
    }
    }
  }
  {
  {
#line 138
  waddnstr(stdscr, msg___1, -1);
  }
  {
#line 139
  wgetch(stdscr);
  }
  }
#line 140
  return;
}
}
#line 4 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/autod.c"
void do_autod_register(AutodRegistryNode *head , void **ptr , void (*destr)(void * ) ) 
{ 
  AutodRegistryNode *newnode ;
  void *tmp ;

  {
  {
  {
#line 6
  tmp = malloc((size_t )sizeof(AutodRegistryNode ));
  }
#line 6
  newnode = (AutodRegistryNode *)tmp;
#line 8
  newnode->ptr = ptr;
#line 9
  newnode->destructor = destr;
#line 10
  newnode->next = head->next;
#line 11
  head->next = newnode;
#line 13
  *ptr = (void *)0;
  }
#line 15
  return;
}
}
#line 17 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/autod.c"
void do_autod_assign(AutodRegistryNode *head , void **ptr , void *newvalue ) 
{ 
  AutodRegistryNode *n ;
  char *__cil_tmp5 ;

  {
#line 20
  if (*ptr) {
#line 23
    n = head->next;
    {
    {
#line 24
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 24
      if (! n) {
#line 24
        goto while_break;
      }
#line 25
      if ((unsigned long )n->ptr == (unsigned long )ptr) {
        {
        {
#line 27
        (*(n->destructor))(*ptr);
        }
        }
#line 28
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 32
    if (! n) {
      {
      {
#line 34
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"autod: FATAL ERROR: attempt to assign to\nunregistered pointer.\n\n");
      }
      {
#line 36
      abort();
      }
      }
    }
  }
#line 41
  *ptr = newvalue;
#line 42
  return;
}
}
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/autod.c"
void do_autod_cleanup(AutodRegistryNode *head , void *ignore_ptr ) 
{ 
  AutodRegistryNode *n ;
  AutodRegistryNode *next ;

  {
#line 45
  n = head->next;
  {
  {
#line 48
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 48
    if (! n) {
#line 48
      goto while_break;
    }
#line 49
    if (*(n->ptr)) {
#line 49
      if ((unsigned long )*(n->ptr) != (unsigned long )ignore_ptr) {
        {
        {
#line 50
        (*(n->destructor))(*(n->ptr));
        }
        }
      }
    }
    {
#line 52
    next = n->next;
    {
#line 53
    free((void *)n);
    }
#line 55
    n = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static AbsMenu *menu___2  =    (AbsMenu *)0;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void painter___0(int i , AbsMenu *m ) 
{ 
  Layer *l ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 64
  l = *(_doc->layers + i);
#line 65
  if (l->name) {
#line 65
    tmp = (char const   *)l->name;
  } else {
#line 65
    tmp = "(untitled)";
  }
#line 65
  if (l->transp) {
#line 65
    tmp___0 = 't';
  } else {
#line 65
    tmp___0 = ' ';
  }
#line 65
  if (l->visible) {
#line 65
    tmp___1 = 'v';
  } else {
#line 65
    tmp___1 = ' ';
  }
  {
  {
#line 65
  printw("%2d: %c%c (%3d x %3d) %s", i, tmp___1, tmp___0, l->width, l->height, tmp);
  }
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void paint_dlg___2(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 74
  kurses_color(7, 0);
  }
  {
#line 75
  draw_centered_window(42, 19, "Layer Manager", & x0, & y0);
  }
  }
#line 77
  if (! menu___2) {
    {
    {
#line 78
    menu___2 = menu_create(& _doc->layer_count, x0, y0, 40, 11, 113, 112, & painter___0);
    }
    {
#line 81
    menu_select_item(menu___2, _lyr);
    }
    }
  }
  {
  {
#line 84
  draw_hline(x0 - 1, y0 + 11, 42, (int )acs_map[(unsigned char )'t'], (int )acs_map[(unsigned char )'q'],
             (int )acs_map[(unsigned char )'u']);
  }
#line 87
  y = (y0 + 11) + 1;
#line 87
  x = x0 + 1;
  {
#line 87
  kurses_move(x, y);
  }
  {
#line 89
  kurses_color(2, 0);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )'<');
  }
  {
#line 89
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )' ');
  }
  {
#line 90
  kurses_color(7, 0);
  }
  {
#line 91
  printw(": go to layer");
  }
#line 93
  y ++;
  {
#line 93
  kurses_move(x, y);
  }
  {
#line 94
  kurses_color(2, 0);
  }
  {
#line 94
  waddnstr(stdscr, "d  ", -1);
  }
  {
#line 94
  kurses_color(7, 0);
  }
  {
#line 95
  printw(": delete layer");
  }
#line 97
  y ++;
  {
#line 97
  kurses_move(x, y);
  }
  {
#line 98
  kurses_color(2, 0);
  }
  {
#line 98
  waddnstr(stdscr, "+/-", -1);
  }
  {
#line 98
  kurses_color(7, 0);
  }
  {
#line 99
  printw(": move layer up/down");
  }
#line 101
  y ++;
  {
#line 101
  kurses_move(x, y);
  }
  {
#line 102
  kurses_color(2, 0);
  }
  {
#line 102
  waddnstr(stdscr, "v  ", -1);
  }
  {
#line 102
  kurses_color(7, 0);
  }
  {
#line 103
  printw(": toggle visibility");
  }
#line 105
  y ++;
  {
#line 105
  kurses_move(x, y);
  }
  {
#line 106
  kurses_color(2, 0);
  }
  {
#line 106
  waddnstr(stdscr, "t  ", -1);
  }
  {
#line 106
  kurses_color(7, 0);
  }
  {
#line 107
  printw(": toggle transparency");
  }
  {
#line 109
  menu_paint(menu___2);
  }
  }
#line 110
  return;
}
}
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap___0(AewlField *f___0 , int cap ) ;
#line 45
static void buf_insert_char___0(char *buf___15 , int cap , int pos , int ch ) ;
#line 46
static void buf_del_char___0(char *buf___15 , int cap , int pos , int ch ) ;
#line 160 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap___0(AewlField *f___0 , int cap ) 
{ 
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 161
  if (f___0->cap >= cap) {
#line 161
    return;
  }
  {
#line 163
  tmp___0 = cap + 20;
#line 163
  f___0->cap = tmp___0;
  {
#line 163
  tmp___1 = realloc((void *)f___0->buffer, (size_t )tmp___0);
  }
#line 163
  tmp = (char *)tmp___1;
#line 163
  f___0->buffer = tmp;
  }
#line 163
  if (! tmp) {
    {
    {
#line 164
    abort();
    }
    }
  }
#line 165
  return;
}
}
#line 167 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_insert_char___0(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 171
  i = cap - 1;
  {
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i > pos)) {
#line 171
      goto while_break;
    }
#line 171
    *(buf___15 + i) = *(buf___15 + (i - 1));
#line 171
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  *(buf___15 + pos) = (char )ch;
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_del_char___0(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 177
  i = pos;
  {
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < cap - 1)) {
#line 177
      goto while_break;
    }
#line 177
    *(buf___15 + i) = *(buf___15 + (i + 1));
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 513 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 103 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
char *floadstr(FILE *f___0 ) ;
#line 110
void interval_intersect(int a0 , int a1 , int b0 , int b1 , int *c0 , int *c1 ) ;
#line 165
void chr2hex(int c , char *ret ) ;
#line 166
int hex2chr(char const   *hex ) ;
#line 86 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.h"
void layer_blit(Layer *src , int xsrc , int ysrc , int width___0 , int height___0 ,
                Layer *dst , int xdst , int ydst ) ;
#line 102
void layer_paint(Layer *layer , int x0 , int y0 , int xclip , int yclip , int wclip ,
                 int hclip , void (*modify)(int x , int y , int *ch , int *attr ) ) ;
#line 108
void layer_paint_opaque(Layer *layer , int x0 , int y0 , int xclip , int yclip , int wclip ,
                        int hclip , void (*modify)(int x , int y , int *ch , int *attr ) ) ;
#line 115
_Bool layer_valid_cell(Layer *layer , int x , int y ) ;
#line 130
void layer_save(Layer *lyr___0 , AeFile *f___0 ) ;
#line 135
Layer *layer_load(AeFile *f___0 ) ;
#line 138
Layer *layer_load_OLD(FILE *f___0 ) ;
#line 141
_Bool is_cell_transp(Cell const   *c ) ;
#line 42 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
struct _Cell  const  BLANK_CELL  =    {(unsigned char )' ', (unsigned char)112};
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
Layer *layer_create(char const   *layer_name , int width___0 , int height___0 ) 
{ 
  int i ;
  int j ;
  Layer *layer ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
  {
#line 46
  tmp = zalloc((int )sizeof(Layer ));
  }
#line 46
  layer = (Layer *)tmp;
#line 48
  layer->name = (char *)0;
  {
#line 49
  dstrset(& layer->name, layer_name);
  }
#line 50
  layer->width = width___0;
#line 51
  layer->height = height___0;
#line 52
  layer->visible = (_Bool)1;
#line 53
  layer->transp = (_Bool)0;
  {
#line 55
  tmp___0 = zalloc((int )((unsigned long )width___0 * sizeof(Cell *)));
  }
#line 55
  layer->cells = (Cell **)tmp___0;
#line 56
  i = 0;
  }
  {
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i < width___0)) {
#line 56
      goto while_break;
    }
    {
    {
#line 57
    tmp___1 = zalloc((int )((unsigned long )height___0 * sizeof(Cell )));
    }
#line 57
    *(layer->cells + i) = (Cell *)tmp___1;
#line 58
    j = 0;
    }
    {
    {
#line 58
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 58
      if (! (j < height___0)) {
#line 58
        goto while_break___0;
      }
#line 59
      (*(layer->cells + i) + j)->ch = (unsigned char )' ';
#line 60
      (*(layer->cells + i) + j)->attr = (unsigned char)112;
#line 58
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 56
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return (layer);
}
}
#line 67 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_destroy(Layer *layer ) 
{ 
  int i ;

  {
#line 69
  if (! layer) {
#line 69
    return;
  }
  {
  {
#line 70
  dstrset(& layer->name, (char const   *)0);
  }
#line 72
  i = 0;
  }
  {
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < layer->width)) {
#line 72
      goto while_break;
    }
    {
    {
#line 72
    free((void *)*(layer->cells + i));
    }
#line 72
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 73
  free((void *)layer->cells);
  }
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
_Bool is_cell_transp(Cell const   *c ) 
{ 
  int tmp ;

  {
#line 77
  if ((int const   )c->ch == 32) {
#line 77
    if ((int const   )c->attr == 112) {
#line 77
      tmp = 1;
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  return ((_Bool )tmp);
}
}
#line 80 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_blit(Layer *src , int xsrc , int ysrc , int width___0 , int height___0 ,
                Layer *dst , int xdst , int ydst ) 
{ 
  int dx ;
  int dy ;
  int src_x ;
  int src_y ;
  int dst_x ;
  int dst_y ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 88
  dx = 0;
  {
  {
#line 88
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 88
    if (! (dx < width___0)) {
#line 88
      goto while_break;
    }
#line 89
    dy = 0;
    {
    {
#line 89
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! (dy < height___0)) {
#line 89
        goto while_break___0;
      }
      {
#line 90
      src_x = xsrc + dx;
#line 91
      src_y = ysrc + dy;
#line 92
      dst_x = xdst + dx;
#line 93
      dst_y = ydst + dy;
      {
#line 95
      tmp = layer_valid_cell(src, src_x, src_y);
      }
      }
#line 95
      if (tmp) {
        {
        {
#line 95
        tmp___0 = layer_valid_cell(dst, dst_x, dst_y);
        }
        }
#line 95
        if (! tmp___0) {
#line 96
          goto __Cont;
        }
      } else {
#line 96
        goto __Cont;
      }
#line 98
      if (src->transp) {
        {
        {
#line 98
        tmp___1 = is_cell_transp((Cell const   *)(*(src->cells + src_x) + src_y));
        }
        }
#line 98
        if (tmp___1) {
#line 99
          goto __Cont;
        }
      }
#line 101
      *(*(dst->cells + dst_x) + dst_y) = *(*(src->cells + src_x) + src_y);
      __Cont: /* CIL Label */ 
#line 89
      dy ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 88
    dx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return;
}
}
#line 107 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
_Bool layer_valid_cell(Layer *layer , int x , int y ) 
{ 
  int tmp ;

  {
#line 108
  if (x >= 0) {
#line 108
    if (x < layer->width) {
#line 108
      if (y >= 0) {
#line 108
        if (y < layer->height) {
#line 108
          tmp = 1;
        } else {
#line 108
          tmp = 0;
        }
      } else {
#line 108
        tmp = 0;
      }
    } else {
#line 108
      tmp = 0;
    }
  } else {
#line 108
    tmp = 0;
  }
#line 108
  return ((_Bool )tmp);
}
}
#line 111 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_paint(Layer *layer , int x0 , int y0 , int xclip , int yclip , int wclip ,
                 int hclip , void (*modify)(int x , int y , int *ch , int *attr ) ) 
{ 
  int x ;
  int xi ;
  int xf ;
  int y ;
  int yi ;
  int yf ;
  int ch ;
  int attr ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 117
  interval_intersect(x0, (x0 + layer->width) - 1, xclip, (xclip + wclip) - 1, & xi,
                     & xf);
  }
  {
#line 119
  interval_intersect(y0, (y0 + layer->height) - 1, yclip, (yclip + hclip) - 1, & yi,
                     & yf);
  }
#line 122
  x = xi;
  }
  {
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 122
    if (! (x <= xf)) {
#line 122
      goto while_break;
    }
#line 122
    y = yi;
    {
    {
#line 122
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 122
      if (! (y <= yf)) {
#line 122
        goto while_break___0;
      }
      {
      {
#line 123
      tmp = kurses_move(x, y);
      }
      }
#line 123
      if (! tmp) {
#line 123
        goto __Cont;
      }
#line 124
      ch = (int )(*(layer->cells + (x - x0)) + (y - y0))->ch;
#line 125
      attr = (int )(*(layer->cells + (x - x0)) + (y - y0))->attr;
#line 127
      if (modify) {
        {
        {
#line 127
        (*modify)(x - x0, y - y0, & ch, & attr);
        }
        }
      }
#line 129
      if (layer->transp) {
        {
        {
#line 129
        tmp___0 = is_cell_transp((Cell const   *)(*(layer->cells + (x - x0)) + (y - y0)));
        }
        }
#line 129
        if (tmp___0) {
#line 130
          goto __Cont;
        }
      }
      {
      {
#line 132
      kurses_color(attr >> 4, attr & 15);
      }
      {
#line 133
      tmp___1 = chtr_a2c((unsigned char )ch);
      }
      {
#line 133
      waddch(stdscr, (chtype const   )tmp___1);
      }
      }
      __Cont: /* CIL Label */ 
#line 122
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 137 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_paint_opaque(Layer *layer , int x0 , int y0 , int xclip , int yclip , int wclip ,
                        int hclip , void (*modify)(int x , int y , int *ch , int *attr ) ) 
{ 
  _Bool backup ;

  {
  {
#line 140
  backup = layer->transp;
#line 141
  layer->transp = (_Bool)0;
  {
#line 142
  layer_paint(layer, x0, y0, xclip, yclip, wclip, hclip, modify);
  }
#line 143
  layer->transp = backup;
  }
#line 147
  return;
}
}
#line 149 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
Layer *layer_dup(char const   *layer_name , Layer *model ) 
{ 
  Layer *l ;

  {
#line 151
  if (! model) {
#line 151
    return ((Layer *)((void *)0));
  }
  {
  {
#line 153
  l = layer_create(layer_name, model->width, model->height);
  }
#line 154
  l->transp = model->transp;
  {
#line 155
  layer_blit(model, 0, 0, model->width, model->height, l, 0, 0);
  }
  }
#line 156
  return (l);
}
}
#line 162 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char tbl_lookup(char **table , int ch ) 
{ 
  char const   *s ;
  char const   *p ;
  char const   *tmp ;

  {
#line 163
  s = (char const   *)*(table + 0);
#line 163
  p = (char const   *)*(table + 1);
  {
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 164
    if (! *s) {
#line 164
      goto while_break;
    }
#line 165
    tmp = s;
#line 165
    s ++;
#line 165
    if ((int const   )*tmp == (int const   )ch) {
#line 165
      return ((char )*p);
    }
#line 166
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return ((char )ch);
}
}
#line 174 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table[2]  = {      (char *)"`\'()/\\<>[]{}\003\005\006\b\t\v",      (char *)"\'`)(\\/><][}{\005\003\b\006\v\t"};
#line 171 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_flip_x(Layer *layer , _Bool flipchars ) 
{ 
  Layer *tmp ;
  int x ;
  int y ;
  Cell c ;
  char tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 179
  tmp = layer_dup("tmp", layer);
  }
#line 180
  y = 0;
  }
  {
  {
#line 180
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 180
    if (! (y < layer->height)) {
#line 180
      goto while_break;
    }
#line 181
    x = 0;
    {
    {
#line 181
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! (x < layer->width)) {
#line 181
        goto while_break___0;
      }
#line 182
      c = *(*(tmp->cells + x) + y);
#line 183
      if (flipchars) {
        {
        {
#line 183
        tmp___0 = tbl_lookup(flip_table, (int )c.ch);
        }
#line 183
        c.ch = (unsigned char )tmp___0;
        }
      }
#line 185
      *(*(layer->cells + ((layer->width - x) - 1)) + y) = c;
#line 181
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 180
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 189
  layer_destroy(tmp);
  }
  }
#line 190
  return;
}
}
#line 195 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___0[2]  = {      (char *)"/\\\003\t\004\n\005\v",      (char *)"\\/\t\003\n\004\v\005"};
#line 192 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_flip_y(Layer *layer , _Bool flipchars ) 
{ 
  Layer *tmp ;
  int x ;
  int y ;
  Cell c ;
  char tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 200
  tmp = layer_dup("tmp", layer);
  }
#line 201
  y = 0;
  }
  {
  {
#line 201
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 201
    if (! (y < layer->height)) {
#line 201
      goto while_break;
    }
#line 202
    x = 0;
    {
    {
#line 202
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 202
      if (! (x < layer->width)) {
#line 202
        goto while_break___0;
      }
#line 203
      c = *(*(tmp->cells + x) + y);
#line 204
      if (flipchars) {
        {
        {
#line 204
        tmp___0 = tbl_lookup(flip_table___0, (int )c.ch);
        }
#line 204
        c.ch = (unsigned char )tmp___0;
        }
      }
#line 206
      *(*(layer->cells + x) + ((layer->height - y) - 1)) = c;
#line 202
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 201
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 210
  layer_destroy(tmp);
  }
  }
#line 211
  return;
}
}
#line 213 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
void layer_save(Layer *lyr___0 , AeFile *f___0 ) 
{ 
  int x ;
  int y ;
  char *buf___15 ;
  void *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 215
  tmp = zalloc(lyr___0->width * 4 + 1);
  }
#line 215
  buf___15 = (char *)tmp;
  {
#line 217
  aeff_write_header(f___0, "Layer");
  }
  }
#line 218
  if (lyr___0->name) {
#line 218
    tmp___0 = (char const   *)lyr___0->name;
  } else {
#line 218
    tmp___0 = "unnamed";
  }
  {
  {
#line 218
  aeff_write_string(f___0, "name", tmp___0);
  }
  {
#line 219
  aeff_write_int(f___0, "width", lyr___0->width);
  }
  {
#line 220
  aeff_write_int(f___0, "height", lyr___0->height);
  }
  {
#line 221
  aeff_write_bool(f___0, "visible", lyr___0->visible);
  }
  {
#line 222
  aeff_write_bool(f___0, "transparent", lyr___0->transp);
  }
#line 224
  y = 0;
  }
  {
  {
#line 224
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 224
    if (! (y < lyr___0->height)) {
#line 224
      goto while_break;
    }
#line 226
    x = 0;
    {
    {
#line 226
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (x < lyr___0->width)) {
#line 226
        goto while_break___0;
      }
      {
      {
#line 227
      chr2hex((int )(*(lyr___0->cells + x) + y)->ch, buf___15 + x * 4);
      }
      {
#line 228
      chr2hex((int )(*(lyr___0->cells + x) + y)->attr, buf___15 + (x * 4 + 2));
      }
#line 226
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 232
    aeff_write_string(f___0, "layer-line", (char const   *)buf___15);
    }
#line 224
    y ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 235
  aeff_write_footer(f___0, "Layer");
  }
  {
#line 236
  zfree(& buf___15);
  }
  }
#line 237
  return;
}
}
#line 239 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
Layer *layer_load(AeFile *f___0 ) 
{ 
  int x ;
  int y ;
  char *buf___15 ;
  Layer *lyr___0 ;
  char *name ;
  int width___0 ;
  int height___0 ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 241
  buf___15 = (char *)0;
#line 242
  lyr___0 = (Layer *)((void *)0);
#line 243
  name = (char *)0;
  {
#line 246
  tmp = aeff_read_header(f___0, "Layer");
  }
  }
#line 246
  if (! tmp) {
#line 246
    goto exception;
  }
  {
  {
#line 247
  tmp___0 = aeff_read_string(f___0, "name", & name);
  }
  }
#line 247
  if (! tmp___0) {
#line 247
    goto exception;
  }
  {
  {
#line 248
  tmp___1 = aeff_read_int(f___0, "width", & width___0);
  }
  }
#line 248
  if (! tmp___1) {
#line 248
    goto exception;
  }
  {
  {
#line 249
  tmp___2 = aeff_read_int(f___0, "height", & height___0);
  }
  }
#line 249
  if (! tmp___2) {
#line 249
    goto exception;
  }
  {
  {
#line 251
  lyr___0 = layer_create((char const   *)name, width___0, height___0);
  }
  {
#line 252
  zfree(& name);
  }
  {
#line 254
  tmp___3 = aeff_read_bool(f___0, "visible", & lyr___0->visible);
  }
  }
#line 254
  if (! tmp___3) {
#line 254
    goto exception;
  }
  {
  {
#line 255
  tmp___4 = aeff_read_bool(f___0, "transparent", & lyr___0->transp);
  }
  }
#line 255
  if (! tmp___4) {
#line 255
    goto exception;
  }
#line 257
  y = 0;
  {
  {
#line 257
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 257
    if (! (y < lyr___0->height)) {
#line 257
      goto while_break;
    }
    {
    {
#line 258
    tmp___5 = aeff_read_string(f___0, "layer-line", & buf___15);
    }
    }
#line 258
    if (! tmp___5) {
#line 258
      goto exception;
    }
    {
    {
#line 260
    tmp___6 = strlen((char const   *)buf___15);
    }
    }
#line 260
    if (tmp___6 != (size_t )(lyr___0->width * 4)) {
      {
      {
#line 261
      aeff_set_error("layer-line line has incorrect width");
      }
      }
#line 262
      goto exception;
    }
#line 267
    x = 0;
    {
    {
#line 267
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 267
      if (! (x < lyr___0->width)) {
#line 267
        goto while_break___0;
      }
      {
      {
#line 268
      tmp___7 = hex2chr((char const   *)(buf___15 + x * 4));
      }
#line 268
      (*(lyr___0->cells + x) + y)->ch = (unsigned char )tmp___7;
      {
#line 269
      tmp___8 = hex2chr((char const   *)(buf___15 + (x * 4 + 2)));
      }
#line 269
      (*(lyr___0->cells + x) + y)->attr = (unsigned char )tmp___8;
#line 267
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 272
    zfree(& buf___15);
    }
#line 257
    y ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 275
  aeff_read_footer(f___0, "Layer");
  }
  }
#line 277
  return (lyr___0);
  exception: 
#line 280
  if (lyr___0) {
    {
    {
#line 280
    layer_destroy(lyr___0);
    }
    }
  }
#line 281
  if (buf___15) {
    {
    {
#line 281
    zfree(& buf___15);
    }
    }
  }
#line 282
  return ((Layer *)((void *)0));
}
}
#line 285 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
Layer *layer_load_OLD(FILE *f___0 ) 
{ 
  char *lyr_name ;
  char signature[3] ;
  int width___0 ;
  int height___0 ;
  int x ;
  int y ;
  _Bool v ;
  _Bool t ;
  Layer *l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 292
  tmp = fgetc(f___0);
  }
#line 292
  signature[0] = (char )tmp;
  {
#line 293
  tmp___0 = fgetc(f___0);
  }
#line 293
  signature[1] = (char )tmp___0;
#line 294
  signature[2] = (char)0;
  {
#line 296
  tmp___1 = strcmp((char const   *)(signature), "L3");
  }
  }
#line 296
  if (tmp___1) {
#line 296
    return ((Layer *)((void *)0));
  }
  {
  {
#line 297
  lyr_name = floadstr(f___0);
  }
  }
#line 297
  if (! lyr_name) {
#line 297
    return ((Layer *)((void *)0));
  }
  {
  {
#line 298
  fread((void */* __restrict  */)(& width___0), (size_t )sizeof(int ), (size_t )1,
        (FILE */* __restrict  */)f___0);
  }
  {
#line 299
  fread((void */* __restrict  */)(& height___0), (size_t )sizeof(int ), (size_t )1,
        (FILE */* __restrict  */)f___0);
  }
  {
#line 300
  tmp___3 = fgetc(f___0);
  }
  }
#line 300
  if (tmp___3) {
#line 300
    v = (_Bool)1;
  } else {
#line 300
    v = (_Bool)0;
  }
  {
  {
#line 301
  tmp___5 = fgetc(f___0);
  }
  }
#line 301
  if (tmp___5) {
#line 301
    t = (_Bool)1;
  } else {
#line 301
    t = (_Bool)0;
  }
  {
  {
#line 303
  l = layer_create((char const   *)lyr_name, width___0, height___0);
  }
#line 304
  l->visible = v;
#line 305
  l->transp = t;
#line 307
  x = 0;
  }
  {
  {
#line 307
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 307
    if (! (x < width___0)) {
#line 307
      goto while_break;
    }
#line 307
    y = 0;
    {
    {
#line 307
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 307
      if (! (y < height___0)) {
#line 307
        goto while_break___0;
      }
      {
      {
#line 308
      tmp___6 = fgetc(f___0);
      }
#line 308
      (*(l->cells + x) + y)->ch = (unsigned char )tmp___6;
      {
#line 309
      tmp___7 = fgetc(f___0);
      }
#line 309
      (*(l->cells + x) + y)->attr = (unsigned char )tmp___7;
#line 307
      y ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 307
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (l);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 367 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.h"
int minimum(int a , int b ) ;
#line 57
int maximum(int a , int b ) ;
#line 60
double minimum_d(double a , double b ) ;
#line 63
double maximum_d(double a , double b ) ;
#line 85
char *str_fit_ex(char const   *orig , int size , int padch ) ;
#line 89
char *str_fit(char const   *orig , int size ) ;
#line 94
float timeval_dif(struct timeval  const  *a , struct timeval  const  *b ) ;
#line 98
void fsavestr(char const   *str , FILE *f___0 ) ;
#line 113
void interval_intersect_d(double a0 , double a1 , double b0 , double b1 , double *c0 ,
                          double *c1 ) ;
#line 124
void sort_two(int v0 , int v1 , int *r0 , int *r1 ) ;
#line 136
char *freadline(FILE *f___0 ) ;
#line 148
char *strtrim(char const   *s ) ;
#line 159
char *dstrcat(char const   *s , char const   *t ) ;
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *dstrset(char **ptr , char const   *new_value ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 41
  if (*ptr) {
    {
    {
#line 41
    free((void *)*ptr);
    }
    }
  }
#line 42
  if (new_value) {
    {
    {
#line 42
    tmp___0 = sstrdup(new_value);
    }
#line 42
    tmp = tmp___0;
    }
  } else {
#line 42
    tmp = (char *)0;
  }
#line 42
  *ptr = tmp;
#line 42
  return (tmp);
}
}
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void *zalloc(int bytes ) 
{ 
  void *buf___15 ;
  char *__cil_tmp3 ;

  {
#line 48
  if (bytes <= 0) {
#line 48
    return ((void *)0);
  }
  {
  {
#line 50
  buf___15 = malloc((size_t )bytes);
  }
  }
#line 50
  if (! buf___15) {
    {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** FATAL ERROR ***\nzalloc failed to allocate memory.\nRequest size: %d bytes.\n\nSorry.\n",
            bytes);
    }
    {
#line 54
    abort();
    }
    }
  }
  {
  {
#line 57
  memset(buf___15, 0, (size_t )bytes);
  }
  }
#line 58
  return (buf___15);
}
}
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *sstrdup(char const   *s ) 
{ 
  char *r ;
  char *__cil_tmp3 ;

  {
#line 63
  if (! s) {
#line 63
    return ((char *)0);
  }
  {
  {
#line 65
  r = strdup(s);
  }
  }
#line 65
  if (! r) {
    {
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** FATAL ERROR ***\nsstrdup failed to allocate memory.\n");
    }
    {
#line 68
    abort();
    }
    }
  }
#line 70
  return (r);
}
}
#line 73 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void *srealloc(void *buf___15 , int newsize ) 
{ 
  void *tmp ;
  char *__cil_tmp4 ;

  {
#line 74
  if (! buf___15) {
    {
    {
#line 74
    tmp = zalloc(newsize);
    }
    }
#line 74
    return (tmp);
  }
  {
  {
#line 75
  buf___15 = realloc(buf___15, (size_t )newsize);
  }
  }
#line 75
  if (! buf___15) {
    {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** FATAL ERROR ***\nsrealloc failed to reallocate memory.\nRequest size: %d bytes.\n\nSorry.\n",
            newsize);
    }
    {
#line 79
    abort();
    }
    }
  }
#line 81
  return (buf___15);
}
}
#line 84 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
int minimum(int a , int b ) 
{ 
  int tmp ;

  {
#line 84
  if (a < b) {
#line 84
    tmp = a;
  } else {
#line 84
    tmp = b;
  }
#line 84
  return (tmp);
}
}
#line 85 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
int maximum(int a , int b ) 
{ 
  int tmp ;

  {
#line 85
  if (a > b) {
#line 85
    tmp = a;
  } else {
#line 85
    tmp = b;
  }
#line 85
  return (tmp);
}
}
#line 86 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
double minimum_d(double a , double b ) 
{ 
  double tmp ;

  {
#line 86
  if (a < b) {
#line 86
    tmp = a;
  } else {
#line 86
    tmp = b;
  }
#line 86
  return (tmp);
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
double maximum_d(double a , double b ) 
{ 
  double tmp ;

  {
#line 87
  if (a > b) {
#line 87
    tmp = a;
  } else {
#line 87
    tmp = b;
  }
#line 87
  return (tmp);
}
}
#line 90 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
int printable_char(int ch ) 
{ 


  {
#line 91
  if (ch < 0) {
#line 91
    return (0);
  } else
#line 91
  if (ch > 255) {
#line 91
    return (0);
  }
#line 92
  if (ch <= 31) {
#line 92
    return (0);
  } else
#line 92
  if (ch == 127) {
#line 92
    return (0);
  }
#line 93
  return (1);
}
}
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *str_fit_ex(char const   *orig , int size , int padch ) 
{ 
  char *s ;
  char *p ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 98
  if (size <= 0) {
#line 98
    return ((char *)0);
  }
  {
  {
#line 100
  tmp = zalloc(size + 1);
  }
#line 100
  s = (char *)tmp;
#line 100
  p = s;
  }
  {
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 101
    if (! (p - s < (long )size)) {
#line 101
      goto while_break;
    }
#line 102
    tmp___0 = p;
#line 102
    p ++;
#line 102
    if (*orig) {
#line 102
      tmp___1 = orig;
#line 102
      orig ++;
#line 102
      *tmp___0 = (char )*tmp___1;
    } else {
#line 102
      *tmp___0 = (char )padch;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  *p = (char)0;
#line 105
  return (s);
}
}
#line 108 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *str_fit(char const   *orig , int size ) 
{ 
  char *tmp ;

  {
  {
  {
#line 109
  tmp = str_fit_ex(orig, size, ' ');
  }
  }
#line 109
  return (tmp);
}
}
#line 112 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
float timeval_dif(struct timeval  const  *a , struct timeval  const  *b ) 
{ 
  long to_remove ;
  float af ;
  float bf ;

  {
#line 115
  if (a->tv_sec > b->tv_sec) {
#line 115
    to_remove = (long )b->tv_sec;
  } else {
#line 116
    to_remove = (long )a->tv_sec;
  }
#line 118
  af = (float )(a->tv_sec - (__time_t const   )to_remove) + (float )a->tv_usec / 1000000.0f;
#line 119
  bf = (float )(b->tv_sec - (__time_t const   )to_remove) + (float )b->tv_usec / 1000000.0f;
#line 120
  return (af - bf);
}
}
#line 123 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void fsavestr(char const   *str , FILE *f___0 ) 
{ 
  int len ;
  size_t tmp ;
  char const   *tmp___0 ;

  {
  {
  {
#line 124
  tmp = strlen(str);
  }
#line 124
  len = (int )tmp;
  {
#line 126
  fwrite((void const   */* __restrict  */)(& len), (size_t )sizeof(int ), (size_t )1,
         (FILE */* __restrict  */)f___0);
  }
  }
  {
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 127
    if (! *str) {
#line 127
      goto while_break;
    }
    {
#line 127
    tmp___0 = str;
#line 127
    str ++;
    {
#line 127
    fputc((int )*tmp___0, f___0);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 130 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *floadstr(FILE *f___0 ) 
{ 
  char *str ;
  char *p ;
  int len ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 133
  fread((void */* __restrict  */)(& len), (size_t )sizeof(int ), (size_t )1, (FILE */* __restrict  */)f___0);
  }
  {
#line 135
  tmp = zalloc(len + 1);
  }
#line 135
  str = (char *)tmp;
#line 135
  p = str;
  }
  {
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 136
    tmp___2 = len;
#line 136
    len --;
#line 136
    if (! tmp___2) {
#line 136
      goto while_break;
    }
    {
#line 136
    tmp___0 = p;
#line 136
    p ++;
    {
#line 136
    tmp___1 = fgetc(f___0);
    }
#line 136
    *tmp___0 = (char )tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (str);
}
}
#line 141 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void interval_intersect(int a0 , int a1 , int b0 , int b1 , int *c0 , int *c1 ) 
{ 


  {
  {
  {
#line 142
  *c0 = maximum(a0, b0);
  }
  {
#line 143
  *c1 = minimum(a1, b1);
  }
  }
#line 144
  return;
}
}
#line 146 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void interval_intersect_d(double a0 , double a1 , double b0 , double b1 , double *c0 ,
                          double *c1 ) 
{ 


  {
  {
  {
#line 148
  *c0 = maximum_d(a0, b0);
  }
  {
#line 149
  *c1 = minimum_d(a1, b1);
  }
  }
#line 150
  return;
}
}
#line 152 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void sort_two(int v0 , int v1 , int *r0 , int *r1 ) 
{ 


  {
#line 153
  if (v0 <= v1) {
#line 154
    if (r0) {
#line 154
      *r0 = v0;
    }
#line 155
    if (r1) {
#line 155
      *r1 = v1;
    }
  } else {
#line 158
    if (r0) {
#line 158
      *r0 = v1;
    }
#line 159
    if (r1) {
#line 159
      *r1 = v0;
    }
  }
#line 161
  return;
}
}
#line 163 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *dsprintf(char const   *fmt  , ...) 
{ 
  int n ;
  int size ;
  char *p ;
  va_list ap ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 166
  size = 100;
  {
#line 170
  tmp = zalloc(size);
  }
#line 170
  p = (char *)tmp;
  }
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 174
    __builtin_va_start(ap, fmt);
    }
    {
#line 174
    n = vsnprintf((char */* __restrict  */)p, (size_t )size, (char const   */* __restrict  */)fmt,
                  ap);
    }
    {
#line 174
    __builtin_va_end(ap);
    }
    }
#line 177
    if (n > -1) {
#line 177
      if (n < size) {
#line 177
        return (p);
      }
    }
#line 180
    if (n > -1) {
#line 181
      size = n + 1;
    } else {
#line 183
      size *= 2;
    }
    {
    {
#line 185
    tmp___0 = srealloc((void *)p, size);
    }
#line 185
    p = (char *)tmp___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 189 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void sfree(void *ptr ) 
{ 


  {
#line 190
  if (ptr) {
    {
    {
#line 190
    free(ptr);
    }
    }
  }
#line 191
  return;
}
}
#line 193 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void zfree(char **str ) 
{ 


  {
#line 194
  if (*str) {
    {
    {
#line 195
    free((void *)*str);
    }
#line 196
    *str = (char *)0;
    }
  }
#line 198
  return;
}
}
#line 200 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *freadline(FILE *f___0 ) 
{ 
  char *tmp ;

  {
  {
  {
#line 201
  tmp = freadline_ex((void *)f___0, (int (*)(void * ))(& fgetc));
  }
  }
#line 201
  return (tmp);
}
}
#line 204 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *freadline_ex(void *fh , int (*readch)(void * ) ) 
{ 
  int size ;
  char *buf___15 ;
  int i ;
  char ch ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 205
  size = 64;
  {
#line 211
  tmp = (*readch)(fh);
  }
#line 211
  ch = (char )tmp;
  }
#line 212
  if ((int )ch < 0) {
#line 212
    return ((char *)((void *)0));
  }
  {
  {
#line 215
  tmp___0 = zalloc(size + 1);
  }
#line 215
  buf___15 = (char *)tmp___0;
#line 216
  i = 0;
  }
  {
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 219
    if ((int )ch != 10) {
#line 219
      if (! ((int )ch != -1)) {
#line 219
        goto while_break;
      }
    } else {
#line 219
      goto while_break;
    }
#line 220
    tmp___1 = i;
#line 220
    i ++;
#line 220
    *(buf___15 + tmp___1) = ch;
#line 221
    if (i >= size) {
      {
#line 221
      size += size;
      {
#line 221
      tmp___2 = srealloc((void *)buf___15, 1 + size);
      }
#line 221
      buf___15 = (char *)tmp___2;
      }
    }
    {
    {
#line 223
    tmp___3 = (*readch)(fh);
    }
#line 223
    ch = (char )tmp___3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  *(buf___15 + i) = (char)0;
#line 228
  return (buf___15);
}
}
#line 231 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *strtrim(char const   *s ) 
{ 
  char *t ;
  char *u ;
  size_t tmp ;

  {
  {
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((int const   )*s == 32)) {
#line 233
      if (! ((int const   )*s == 9)) {
#line 233
        if (! ((int const   )*s == 10)) {
#line 233
          goto while_break;
        }
      }
    }
#line 233
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 234
  t = sstrdup(s);
  }
  {
#line 235
  tmp = strlen((char const   *)t);
  }
#line 235
  u = (t + tmp) - 1;
  }
  {
  {
#line 236
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 236
    if ((unsigned long )u >= (unsigned long )t) {
#line 236
      if (! ((int )*u == 32)) {
#line 236
        if (! ((int )*u == 9)) {
#line 236
          if (! ((int )*u == 10)) {
#line 236
            goto while_break___0;
          }
        }
      }
    } else {
#line 236
      goto while_break___0;
    }
#line 236
    u --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 237
  *(u + 1) = (char)0;
#line 238
  return (t);
}
}
#line 241 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
char *dstrcat(char const   *s , char const   *t ) 
{ 
  char *u ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 242
  if (s) {
    {
    {
#line 242
    tmp = strlen(s);
    }
#line 242
    tmp___0 = tmp;
    }
  } else {
#line 242
    tmp___0 = (size_t )0;
  }
#line 242
  if (t) {
    {
    {
#line 242
    tmp___1 = strlen(t);
    }
#line 242
    tmp___2 = tmp___1;
    }
  } else {
#line 242
    tmp___2 = (size_t )0;
  }
  {
  {
#line 242
  tmp___3 = zalloc((int )((1U + tmp___0) + tmp___2));
  }
#line 242
  u = (char *)tmp___3;
  }
#line 243
  if (s) {
    {
    {
#line 243
    strcpy((char */* __restrict  */)u, (char const   */* __restrict  */)s);
    }
    }
  }
#line 244
  if (t) {
    {
    {
#line 244
    strcat((char */* __restrict  */)u, (char const   */* __restrict  */)t);
    }
    }
  }
#line 245
  return (u);
}
}
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static char hs[17]  = 
#line 250
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 249 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
void chr2hex(int c , char *ret ) 
{ 


  {
#line 252
  if (c <= 0) {
#line 252
    c = 0;
  }
#line 253
  if (c >= 256) {
#line 253
    c = 255;
  }
#line 255
  *(ret + 0) = hs[c / 16];
#line 256
  *(ret + 1) = hs[c % 16];
#line 257
  *(ret + 2) = (char)0;
#line 258
  return;
}
}
#line 260 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static int hex_digit_val(char c ) 
{ 


  {
#line 261
  if ((int )c >= 48) {
#line 261
    if ((int )c <= 57) {
#line 261
      return ((int )c - 48);
    } else {
#line 261
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 262
  if ((int )c >= 97) {
#line 262
    if ((int )c <= 102) {
#line 262
      return (((int )c - 97) + 10);
    } else {
#line 262
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 263
  if ((int )c >= 65) {
#line 263
    if ((int )c <= 70) {
#line 263
      return (((int )c - 65) + 10);
    } else {
#line 264
      return (0);
    }
  } else {
#line 264
    return (0);
  }
}
}
#line 267 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
int hex2chr(char const   *hex ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 268
  tmp = hex_digit_val((char )*(hex + 0));
  }
  {
#line 268
  tmp___0 = hex_digit_val((char )*(hex + 1));
  }
  }
#line 268
  return (tmp * 16 + tmp___0);
}
}
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/init_aewl.c"
static int curses_attr_for_pair(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 39
  cp = (short )((bg * 8 + 7) - fg);
#line 40
  if (! cp) {
#line 40
    if (bold) {
#line 40
      tmp = 1UL << 21;
    } else {
#line 40
      tmp = 0UL;
    }
#line 40
    return ((int )tmp);
  }
#line 41
  if (bold) {
#line 41
    tmp___0 = 1UL << 21;
  } else {
#line 41
    tmp___0 = 0UL;
  }
#line 41
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/init_aewl.c"
void init_aewl(void) 
{ 
  AewlAttrSettings ats ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
  {
#line 45
  tmp = curses_attr_for_pair(7, 0, (_Bool)0);
  }
  {
#line 45
  tmp___0 = curses_attr_for_pair(7, 0, (_Bool)1);
  }
  {
#line 45
  tmp___1 = curses_attr_for_pair(1, 0, (_Bool)0);
  }
  {
#line 45
  tmp___2 = curses_attr_for_pair(1, 0, (_Bool)1);
  }
  {
#line 45
  tmp___3 = curses_attr_for_pair(7, 4, (_Bool)0);
  }
  {
#line 45
  tmp___4 = curses_attr_for_pair(7, 2, (_Bool)1);
  }
  {
#line 45
  tmp___5 = curses_attr_for_pair(1, 4, (_Bool)0);
  }
  {
#line 45
  tmp___6 = curses_attr_for_pair(1, 2, (_Bool)1);
  }
  {
#line 45
  tmp___7 = curses_attr_for_pair(7, 0, (_Bool)0);
  }
  {
#line 45
  tmp___8 = curses_attr_for_pair(7, 0, (_Bool)1);
  }
  {
#line 45
  tmp___9 = curses_attr_for_pair(1, 0, (_Bool)0);
  }
  {
#line 45
  tmp___10 = curses_attr_for_pair(1, 0, (_Bool)1);
  }
  {
#line 45
  tmp___11 = curses_attr_for_pair(7, 0, (_Bool)0);
  }
  {
#line 45
  tmp___12 = curses_attr_for_pair(7, 0, (_Bool)1);
  }
  {
#line 45
  tmp___13 = curses_attr_for_pair(7, 4, (_Bool)0);
  }
  {
#line 45
  tmp___14 = curses_attr_for_pair(7, 1, (_Bool)1);
  }
  {
#line 45
  tmp___15 = curses_attr_for_pair(0, 0, (_Bool)1);
  }
#line 45
  ats.text.normal = tmp;
#line 45
  ats.text.focus = tmp___0;
#line 45
  ats.text.highlight = tmp___1;
#line 45
  ats.text.highlight_focus = tmp___2;
#line 45
  ats.button.normal = tmp___3;
#line 45
  ats.button.focus = tmp___4;
#line 45
  ats.button.highlight = tmp___5;
#line 45
  ats.button.highlight_focus = tmp___6;
#line 45
  ats.frame.normal = tmp___7;
#line 45
  ats.frame.focus = tmp___8;
#line 45
  ats.frame.highlight = tmp___9;
#line 45
  ats.frame.highlight_focus = tmp___10;
#line 45
  ats.field.normal = tmp___11;
#line 45
  ats.field.focus = tmp___12;
#line 45
  ats.field.highlight = tmp___13;
#line 45
  ats.field.highlight_focus = tmp___14;
#line 45
  ats.field_pad = tmp___15;
  {
#line 77
  aewl_init((AewlAttrSettings const   *)(& ats));
  }
  }
#line 78
  return;
}
}
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.h"
Document *document_create(void) ;
#line 82
Document *document_load_OLD(FILE *f___0 ) ;
#line 91
Document *document_load(AeFile *f___0 ) ;
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
Document *document_create(void) 
{ 
  Document *doc___0 ;
  void *tmp ;

  {
  {
  {
#line 45
  tmp = zalloc((int )sizeof(Document ));
  }
#line 45
  doc___0 = (Document *)tmp;
  }
#line 46
  return (doc___0);
}
}
#line 49 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
void document_destroy(Document *doc___0 ) 
{ 
  int i ;

  {
#line 51
  if (! doc___0) {
#line 51
    return;
  }
#line 52
  if (doc___0->layers) {
#line 53
    i = 0;
    {
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 53
      if (! (i < doc___0->layer_count)) {
#line 53
        goto while_break;
      }
      {
      {
#line 54
      free((void *)*(doc___0->layers + i));
      }
#line 53
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 55
    free((void *)doc___0->layers);
    }
    }
  }
  {
  {
#line 58
  dstrset(& doc___0->metainfo, (char const   *)0);
  }
  {
#line 59
  free((void *)doc___0);
  }
  }
#line 60
  return;
}
}
#line 62 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
void document_add_layer(Document *doc___0 , Layer *layer ) 
{ 
  Layer **tmp ;
  void *tmp___0 ;

  {
  {
#line 63
  (doc___0->layer_count) ++;
  {
#line 63
  tmp___0 = srealloc((void *)doc___0->layers, (int )((unsigned long )doc___0->layer_count * sizeof(Layer *)));
  }
#line 63
  tmp = (Layer **)tmp___0;
#line 63
  doc___0->layers = tmp;
#line 63
  *(tmp + (doc___0->layer_count - 1)) = layer;
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
void document_insert_layer(Document *doc___0 , int i , Layer *layer ) 
{ 
  int j ;
  void *tmp ;

  {
#line 69
  if (i < 0) {
#line 69
    i = 0;
  }
#line 70
  if (i > doc___0->layer_count) {
#line 70
    i = doc___0->layer_count;
  }
  {
#line 73
  (doc___0->layer_count) ++;
  {
#line 73
  tmp = srealloc((void *)doc___0->layers, (int )((unsigned long )doc___0->layer_count * sizeof(Layer *)));
  }
#line 73
  doc___0->layers = (Layer **)tmp;
#line 76
  j = doc___0->layer_count - 1;
  }
  {
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 76
    if (! (j > i)) {
#line 76
      goto while_break;
    }
#line 77
    *(doc___0->layers + j) = *(doc___0->layers + (j - 1));
#line 76
    j --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  *(doc___0->layers + i) = layer;
#line 81
  return;
}
}
#line 83 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
void document_del_layer(Document *doc___0 , int i ) 
{ 


  {
#line 84
  if (i < 0) {
#line 84
    return;
  } else
#line 84
  if (i >= doc___0->layer_count) {
#line 84
    return;
  }
  {
  {
#line 88
  layer_destroy(*(doc___0->layers + i));
  }
  }
  {
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < doc___0->layer_count - 1)) {
#line 89
      goto while_break;
    }
#line 90
    *(doc___0->layers + i) = *(doc___0->layers + (i + 1));
#line 89
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  (doc___0->layer_count) --;
#line 93
  return;
}
}
#line 95 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
void document_get_nom_dim(Document *doc___0 , int *w , int *h ) 
{ 


  {
#line 96
  if (! doc___0) {
#line 96
    goto _L;
  } else
#line 96
  if (! doc___0->layer_count) {
    _L: /* CIL Label */ 
#line 97
    if (w) {
#line 97
      *w = 80;
    }
#line 98
    if (h) {
#line 98
      *h = 25;
    }
  } else {
#line 101
    if (w) {
#line 101
      *w = (*(doc___0->layers + 0))->width;
    }
#line 102
    if (h) {
#line 102
      *h = (*(doc___0->layers + 0))->height;
    }
  }
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
void document_save(Document *doc___0 , AeFile *f___0 ) 
{ 
  int i ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 109
  aeff_write_header(f___0, "Aewan Document v1");
  }
  {
#line 110
  aeff_write_int(f___0, "layer-count", doc___0->layer_count);
  }
  }
#line 111
  if (doc___0->metainfo) {
#line 111
    tmp = (char const   *)doc___0->metainfo;
  } else {
#line 111
    tmp = "";
  }
  {
  {
#line 111
  aeff_write_string(f___0, "meta-info", tmp);
  }
#line 113
  i = 0;
  }
  {
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < doc___0->layer_count)) {
#line 113
      goto while_break;
    }
    {
    {
#line 114
    layer_save(*(doc___0->layers + i), f___0);
    }
#line 113
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 116
  aeff_write_footer(f___0, "Aewan Document v1");
  }
  }
#line 117
  return;
}
}
#line 120 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
static char buf___3[2]  ;
#line 119 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
Document *document_load_from(char const   *filename ) 
{ 
  int i ;
  Document *d ;
  FILE *f___0 ;
  FILE *tmp ;
  char *msg___1 ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  AeFile *aeff ;
  AeFile *tmp___4 ;
  Document *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 122
  d = (Document *)((void *)0);
  {
#line 124
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 124
  f___0 = tmp;
  }
#line 125
  if (! f___0) {
    {
    {
#line 126
    tmp___0 = __errno_location();
    }
    {
#line 126
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 126
    tmp___2 = dsprintf("%s: %s", filename, tmp___1);
    }
#line 126
    msg___1 = tmp___2;
    {
#line 127
    aeff_set_error((char const   *)msg___1);
    }
    {
#line 128
    zfree(& msg___1);
    }
    }
#line 129
    return ((Document *)((void *)0));
  }
#line 133
  i = 0;
  {
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < 2)) {
#line 133
      goto while_break;
    }
    {
    {
#line 133
    tmp___3 = fgetc(f___0);
    }
#line 133
    buf___3[i] = (char )tmp___3;
#line 133
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  fclose(f___0);
  }
  {
#line 136
  tmp___7 = strncmp((char const   *)(buf___3), "DO", (size_t )2);
  }
  }
#line 136
  if (tmp___7) {
    {
    {
#line 143
    tmp___6 = strncmp((char const   *)(buf___3), "\037\213", (size_t )2);
    }
    }
#line 143
    if (tmp___6) {
      {
      {
#line 150
      aeff_set_error("Unrecognized file format.");
      }
      }
#line 151
      return ((Document *)((void *)0));
    } else {
      {
      {
#line 145
      tmp___4 = aeff_open(filename, (char )'r');
      }
#line 145
      aeff = tmp___4;
      }
#line 146
      if (! aeff) {
#line 146
        return ((Document *)((void *)0));
      }
      {
      {
#line 147
      tmp___5 = document_load(aeff);
      }
      }
#line 147
      return (tmp___5);
    }
  } else {
    {
    {
#line 138
    f___0 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
    {
#line 138
    d = document_load_OLD(f___0);
    }
    }
#line 139
    if (! d) {
      {
      {
#line 139
      aeff_set_error("Malformed (old) binary format");
      }
      }
    }
    {
    {
#line 140
    fclose(f___0);
    }
    }
#line 141
    return (d);
  }
}
}
#line 155 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
Document *document_load(AeFile *f___0 ) 
{ 
  int lc ;
  Document *d ;
  Document *tmp ;
  Layer *l ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 157
  tmp = document_create();
  }
#line 157
  d = tmp;
#line 158
  l = (Layer *)((void *)0);
  {
#line 160
  tmp___0 = aeff_read_header(f___0, "Aewan Document v1");
  }
  }
#line 160
  if (! tmp___0) {
#line 160
    goto exception;
  }
  {
  {
#line 161
  tmp___1 = aeff_read_int(f___0, "layer-count", & lc);
  }
  }
#line 161
  if (! tmp___1) {
#line 161
    goto exception;
  }
  {
  {
#line 162
  tmp___2 = aeff_read_string(f___0, "meta-info", & d->metainfo);
  }
  }
#line 162
  if (! tmp___2) {
#line 162
    goto exception;
  }
  {
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 166
    tmp___3 = lc;
#line 166
    lc --;
#line 166
    if (! tmp___3) {
#line 166
      goto while_break;
    }
    {
    {
#line 167
    l = layer_load(f___0);
    }
    }
#line 167
    if (! l) {
#line 167
      goto exception;
    }
    {
    {
#line 168
    document_add_layer(d, l);
    }
#line 169
    l = (Layer *)0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 172
  tmp___4 = aeff_read_footer(f___0, "Aewan Document v1");
  }
  }
#line 172
  if (! tmp___4) {
#line 172
    goto exception;
  }
#line 173
  return (d);
  exception: 
#line 178
  if (d) {
    {
    {
#line 178
    document_destroy(d);
    }
    }
  }
#line 179
  if (l) {
    {
    {
#line 179
    layer_destroy(l);
    }
    }
  }
#line 180
  return ((Document *)((void *)0));
}
}
#line 183 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
Document *document_load_OLD(FILE *f___0 ) 
{ 
  int i ;
  int lc ;
  Document *d ;
  Layer *l ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
  {
#line 187
  tmp = fgetc(f___0);
  }
  }
#line 187
  if (68 != tmp) {
#line 187
    return ((Document *)((void *)0));
  } else {
    {
    {
#line 187
    tmp___0 = fgetc(f___0);
    }
    }
#line 187
    if (79 != tmp___0) {
#line 187
      return ((Document *)((void *)0));
    }
  }
  {
  {
#line 189
  fread((void */* __restrict  */)(& lc), (size_t )sizeof(int ), (size_t )1, (FILE */* __restrict  */)f___0);
  }
  {
#line 191
  d = document_create();
  }
  {
#line 192
  tmp___1 = floadstr(f___0);
  }
#line 192
  d->metainfo = tmp___1;
  }
#line 192
  if (! tmp___1) {
    {
    {
#line 193
    document_destroy(d);
    }
    }
#line 194
    return ((Document *)((void *)0));
  }
#line 197
  i = 0;
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (! (i < lc)) {
#line 197
      goto while_break;
    }
    {
    {
#line 198
    l = layer_load_OLD(f___0);
    }
    }
#line 198
    if (! l) {
      {
      {
#line 199
      document_destroy(d);
      }
      }
#line 200
      return ((Document *)((void *)0));
    }
    {
    {
#line 203
    document_add_layer(d, l);
    }
#line 197
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return (d);
}
}
#line 209 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
Cell document_calc_effective_cell(Document *doc___0 , int x , int y ) 
{ 
  int i ;
  Layer *lyr___0 ;
  Cell result ;
  _Bool tmp ;

  {
#line 213
  result.ch = (unsigned char)32;
#line 213
  result.attr = (unsigned char)112;
#line 215
  i = doc___0->layer_count - 1;
  {
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i >= 0)) {
#line 215
      goto while_break;
    }
#line 216
    lyr___0 = *(doc___0->layers + i);
#line 217
    if (x < 0) {
#line 217
      goto __Cont;
    } else
#line 217
    if (x >= lyr___0->width) {
#line 217
      goto __Cont;
    } else
#line 217
    if (y < 0) {
#line 217
      goto __Cont;
    } else
#line 217
    if (y >= lyr___0->width) {
#line 217
      goto __Cont;
    }
#line 218
    if (! lyr___0->visible) {
#line 218
      goto __Cont;
    }
#line 219
    if (lyr___0->transp) {
      {
      {
#line 219
      tmp = is_cell_transp((Cell const   *)(*(lyr___0->cells + x) + y));
      }
      }
#line 219
      if (tmp) {
#line 219
        goto __Cont;
      }
    }
#line 221
    result.ch = (*(lyr___0->cells + x) + y)->ch;
#line 222
    result.attr = (*(lyr___0->cells + x) + y)->attr;
    __Cont: /* CIL Label */ 
#line 215
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (result);
}
}
#line 4 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.h"
void debug_aewl(void) ;
#line 16 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.c"
static int curses_attr_for_pair___0(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 17
  cp = (short )((bg * 8 + 7) - fg);
#line 18
  if (! cp) {
#line 18
    if (bold) {
#line 18
      tmp = 1UL << 21;
    } else {
#line 18
      tmp = 0UL;
    }
#line 18
    return ((int )tmp);
  }
#line 19
  if (bold) {
#line 19
    tmp___0 = 1UL << 21;
  } else {
#line 19
    tmp___0 = 0UL;
  }
#line 19
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 22 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.c"
void debug_aewl(void) 
{ 
  char *s ;
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 23
  tmp = filedlg_show("Test Dialog");
  }
#line 23
  s = tmp;
  {
#line 24
  wclear(stdscr);
  }
  {
#line 26
  printw("Answer: \'%s\'\n", s);
  }
  {
#line 27
  wgetch(stdscr);
  }
  }
#line 28
  return;
}
}
#line 30 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.c"
void debug_aewl_OLD(void) 
{ 
  AewlWidget *b1 ;
  AewlWidget *b2 ;
  AewlWidget *b3 ;
  AewlWidget *lbl ;
  AewlListBox *lb ;
  AewlWidget *fld ;
  AewlForm *f___0 ;
  int r ;
  AewlAttrSettings ats ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  AewlWidget *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
  {
#line 37
  tmp = curses_attr_for_pair___0(7, 0, (_Bool)0);
  }
  {
#line 37
  tmp___0 = curses_attr_for_pair___0(7, 0, (_Bool)1);
  }
  {
#line 37
  tmp___1 = curses_attr_for_pair___0(1, 0, (_Bool)0);
  }
  {
#line 37
  tmp___2 = curses_attr_for_pair___0(1, 0, (_Bool)1);
  }
  {
#line 37
  tmp___3 = curses_attr_for_pair___0(7, 4, (_Bool)0);
  }
  {
#line 37
  tmp___4 = curses_attr_for_pair___0(7, 2, (_Bool)1);
  }
  {
#line 37
  tmp___5 = curses_attr_for_pair___0(1, 4, (_Bool)0);
  }
  {
#line 37
  tmp___6 = curses_attr_for_pair___0(1, 2, (_Bool)1);
  }
  {
#line 37
  tmp___7 = curses_attr_for_pair___0(7, 0, (_Bool)0);
  }
  {
#line 37
  tmp___8 = curses_attr_for_pair___0(7, 0, (_Bool)1);
  }
  {
#line 37
  tmp___9 = curses_attr_for_pair___0(1, 0, (_Bool)0);
  }
  {
#line 37
  tmp___10 = curses_attr_for_pair___0(1, 0, (_Bool)1);
  }
  {
#line 37
  tmp___11 = curses_attr_for_pair___0(7, 0, (_Bool)0);
  }
  {
#line 37
  tmp___12 = curses_attr_for_pair___0(7, 0, (_Bool)1);
  }
  {
#line 37
  tmp___13 = curses_attr_for_pair___0(7, 4, (_Bool)0);
  }
  {
#line 37
  tmp___14 = curses_attr_for_pair___0(7, 1, (_Bool)1);
  }
  {
#line 37
  tmp___15 = curses_attr_for_pair___0(0, 0, (_Bool)1);
  }
#line 37
  ats.text.normal = tmp;
#line 37
  ats.text.focus = tmp___0;
#line 37
  ats.text.highlight = tmp___1;
#line 37
  ats.text.highlight_focus = tmp___2;
#line 37
  ats.button.normal = tmp___3;
#line 37
  ats.button.focus = tmp___4;
#line 37
  ats.button.highlight = tmp___5;
#line 37
  ats.button.highlight_focus = tmp___6;
#line 37
  ats.frame.normal = tmp___7;
#line 37
  ats.frame.focus = tmp___8;
#line 37
  ats.frame.highlight = tmp___9;
#line 37
  ats.frame.highlight_focus = tmp___10;
#line 37
  ats.field.normal = tmp___11;
#line 37
  ats.field.focus = tmp___12;
#line 37
  ats.field.highlight = tmp___13;
#line 37
  ats.field.highlight_focus = tmp___14;
#line 37
  ats.field_pad = tmp___15;
  {
#line 69
  aewl_init((AewlAttrSettings const   *)(& ats));
  }
  {
#line 71
  wclear(stdscr);
  }
  {
#line 72
  wrefresh(stdscr);
  }
  {
#line 73
  f___0 = aewl_form_create(stdscr);
  }
  {
#line 75
  b1 = aewl_button_create(10, 10, 20, 400, 1, "Button &Ay One");
  }
  {
#line 76
  b2 = aewl_button_create(10, 12, 20, 401, 2, "Button &Bee Two");
  }
  {
#line 77
  b3 = aewl_button_create(10, 14, 20, 402, 3, "Button &Cee Three");
  }
  {
#line 78
  tmp___16 = aewl_listbox_create(40, 10, 30, 10, 411, "My &List", 123);
  }
#line 78
  lb = (AewlListBox *)tmp___16;
  {
#line 80
  fld = aewl_field_create(10, 20, 20, 419, 4, "Test field");
  }
  {
#line 81
  lbl = aewl_label_create(4, 20, -1, "&Text:");
  }
  {
#line 83
  aewl_listbox_add(lb, "Ut queant laxis");
  }
  {
#line 84
  aewl_listbox_add(lb, "Resonare fibris");
  }
  {
#line 85
  aewl_listbox_add(lb, "Mira gestorum");
  }
  {
#line 86
  aewl_listbox_add(lb, "Famuli tuorum");
  }
  {
#line 87
  aewl_listbox_add(lb, "Solve polluti");
  }
  {
#line 88
  aewl_listbox_add(lb, "Labii reatum");
  }
  {
#line 89
  aewl_listbox_add(lb, "Sancte Ioannes");
  }
  {
#line 90
  aewl_listbox_add(lb, "Lacrymosa dies illa");
  }
  {
#line 91
  aewl_listbox_add(lb, "Qua resurget ex favilla");
  }
  {
#line 92
  aewl_listbox_add(lb, "Iudicandus homo reus");
  }
  {
#line 93
  aewl_listbox_add(lb, "Huic ergo parce Deus");
  }
  {
#line 94
  aewl_listbox_add(lb, "Pie iesu domine");
  }
  {
#line 95
  aewl_listbox_add(lb, "Dona eis requiem");
  }
  {
#line 96
  aewl_listbox_add(lb, "Stabat mater dolorosa");
  }
  {
#line 97
  aewl_listbox_add(lb, "Iuxta crucem lacrymosam");
  }
  {
#line 98
  aewl_listbox_add(lb, "Dum pendebat filius");
  }
  {
#line 99
  aewl_listbox_add(lb, "Quis est homo qui non fleret");
  }
  {
#line 100
  aewl_listbox_add(lb, "Matrem Christi se videret");
  }
  {
#line 101
  aewl_listbox_add(lb, "In tanto suplicio?");
  }
  {
#line 103
  aewl_form_add_widget(f___0, b1);
  }
  {
#line 104
  aewl_form_add_widget(f___0, b2);
  }
  {
#line 105
  aewl_form_add_widget(f___0, b3);
  }
  {
#line 106
  aewl_form_add_widget(f___0, (AewlWidget *)lb);
  }
  {
#line 107
  aewl_form_add_widget(f___0, fld);
  }
  {
#line 108
  aewl_form_add_widget(f___0, lbl);
  }
  {
#line 110
  aewl_form_paint(f___0, (_Bool)1);
  }
  }
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 111
    tmp___17 = wgetch(stdscr);
    }
    {
#line 111
    r = aewl_form_dispatch_key(f___0, tmp___17);
    }
    }
#line 111
    if (! (0 == r)) {
#line 111
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 112
  aewl_form_destroy(f___0);
  }
  {
#line 114
  wclear(stdscr);
  }
  {
#line 115
  wrefresh(stdscr);
  }
  {
#line 116
  printw("Selected value %d", r);
  }
  {
#line 117
  wgetch(stdscr);
  }
  {
#line 119
  wclear(stdscr);
  }
  {
#line 120
  wrefresh(stdscr);
  }
  }
#line 121
  return;
}
}
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
struct _Document *_doc  ;
#line 53 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
char *_filename  ;
#line 56 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _lyr  ;
#line 58 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _x  ;
#line 58 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _y  ;
#line 59 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _svx  ;
#line 59 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _svy  ;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _fg  ;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _bg  ;
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _selmode  ;
#line 65 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _ax  ;
#line 65 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
int _ay  ;
#line 67 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
_Bool _insmode  ;
#line 71 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
_Bool _lgmode  ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
_Bool _compmode  ;
#line 77 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.h"
struct _Layer *_clipboard  ;
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.c"
void get_norm_sel(int *x0 , int *y0 , int *x1 , int *y1 ) 
{ 


  {
  {
  {
#line 55
  sort_two(_x, _ax, x0, x1);
  }
  {
#line 56
  sort_two(_y, _ay, y0, y1);
  }
  }
#line 57
  return;
}
}
#line 59 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.c"
_Bool doc_empty(void) 
{ 


  {
#line 59
  return ((_Bool )(0 >= _doc->layer_count));
}
}
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.c"
void zero_state(void) 
{ 


  {
  {
  {
#line 62
  _doc = document_create();
  }
#line 63
  _filename = (char *)0;
#line 64
  _ay = 0;
#line 64
  _ax = _ay;
#line 64
  _svy = _ax;
#line 64
  _svx = _svy;
#line 64
  _y = _svx;
#line 64
  _x = _y;
#line 64
  _lyr = _x;
#line 65
  _selmode = 0;
#line 66
  _fg = 7;
#line 67
  _bg = 0;
#line 68
  _insmode = (_Bool)0;
#line 69
  _clipboard = (struct _Layer *)0;
#line 70
  _lgmode = (_Bool)0;
#line 71
  _compmode = (_Bool)0;
  }
#line 72
  return;
}
}
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/psd.c"
void switch_to_layer(int l ) 
{ 
  Layer *lyr___0 ;

  {
#line 76
  if (l < 0) {
#line 76
    return;
  } else
#line 76
  if (l >= _doc->layer_count) {
#line 76
    return;
  }
#line 78
  _lyr = l;
#line 78
  lyr___0 = *(_doc->layers + _lyr);
#line 79
  if (_x >= lyr___0->width) {
#line 79
    _x = lyr___0->width - 1;
  }
#line 80
  if (_y >= lyr___0->height) {
#line 80
    _y = lyr___0->height - 1;
  }
#line 81
  return;
}
}
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/clipboard.c"
void clear_clipboard(void) 
{ 


  {
#line 41
  if (_clipboard) {
    {
    {
#line 41
    layer_destroy(_clipboard);
    }
    }
  }
#line 42
  _clipboard = (struct _Layer *)((void *)0);
#line 43
  return;
}
}
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/clipboard.c"
void copy_sel_to_clipboard(void) 
{ 
  int selwidth ;
  int selheight ;
  int x0 ;
  int x1 ;
  int y0 ;
  int y1 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 50
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 51
  selwidth = (x1 - x0) + 1;
#line 52
  selheight = (y1 - y0) + 1;
  {
#line 55
  clear_clipboard();
  }
  {
#line 56
  _clipboard = layer_create("clipboard", selwidth, selheight);
  }
  {
#line 59
  layer_blit(*(_doc->layers + _lyr), x0, y0, selwidth, selheight, _clipboard, 0, 0);
  }
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/clipboard.c"
void paste_clipboard(void) 
{ 


  {
#line 65
  if (! _clipboard) {
#line 65
    return;
  }
  {
  {
#line 66
  layer_blit(_clipboard, 0, 0, _clipboard->width, _clipboard->height, *(_doc->layers + _lyr),
             _x, _y);
  }
  }
#line 68
  return;
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
static void menu_correct___0(AbsMenu *m ) 
{ 


  {
  {
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 89
    if (! (m->sel_item < 0)) {
#line 89
      goto while_break;
    }
#line 89
    m->sel_item = 0;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (m->sel_item >= *(m->item_count))) {
#line 90
      goto while_break___0;
    }
#line 90
    m->sel_item = -1 + *(m->item_count);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  if (m->item_at_top > m->sel_item) {
#line 95
    m->item_at_top = m->sel_item;
  } else
#line 96
  if (m->sel_item >= m->item_at_top + m->h) {
#line 97
    m->item_at_top = (m->sel_item - m->h) + 1;
  }
#line 98
  return;
}
}
#line 83 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.h"
HashDict *hashdict_create(void) ;
#line 86
HashDict *hashdict_create_ex(int bucketcount , void (*value_destroyer)(void * ) ) ;
#line 89
void hashdict_destroy(HashDict *hd ) ;
#line 93
void *hashdict_get(HashDict *hd , char const   *key ) ;
#line 101
void hashdict_set(HashDict *hd , char const   *key , void const   *value ) ;
#line 105
_Bool hashdict_unset(HashDict *hd , char const   *key ) ;
#line 109
void hashdict_write(HashDict *hd , FILE *f___0 , void (*value_writer)(void * , FILE * ) ) ;
#line 116
HashDict *hashdict_read(HashDict *hd , FILE *f___0 , void *(*valuereader)(FILE * ) ) ;
#line 132
HashDictIt hashdict_it_start(HashDict *hd ) ;
#line 136
_Bool hashdict_it_advance(HashDictIt *hdi ) ;
#line 57 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node(HashDict *hd , Node *n ) ;
#line 58
static int _which_bucket(char const   *key , int bucketcount ) ;
#line 59
static Node *_node_lookup(HashDict *hd , char const   *key ) ;
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
HashDict *hashdict_create_ex(int bucketcount , void (*value_destroyer)(void * ) ) 
{ 
  HashDict *hd ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 65
  tmp = zalloc((int )sizeof(struct HashDict_ ));
  }
#line 65
  hd = (HashDict *)tmp;
#line 66
  hd->bucketcount = bucketcount;
#line 67
  hd->value_destroyer = value_destroyer;
  {
#line 68
  tmp___0 = zalloc((int )(sizeof(Node ) * (unsigned long )bucketcount));
  }
#line 68
  hd->bucketheads = (Node *)tmp___0;
  }
#line 70
  return (hd);
}
}
#line 73 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
HashDict *hashdict_create(void) 
{ 
  HashDict *tmp ;

  {
  {
  {
#line 74
  tmp = hashdict_create_ex(30, (void (*)(void * ))0);
  }
  }
#line 74
  return (tmp);
}
}
#line 77 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
void hashdict_destroy(HashDict *hd ) 
{ 
  int i ;
  Node *n ;

  {
#line 79
  if (! hd) {
#line 79
    return;
  }
#line 82
  i = 0;
  {
  {
#line 82
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < hd->bucketcount)) {
#line 82
      goto while_break;
    }
    {
    {
#line 83
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 83
      n = (hd->bucketheads + i)->next;
#line 83
      if (! n) {
#line 83
        goto while_break___0;
      }
      {
#line 85
      (hd->bucketheads + i)->next = n->next;
      {
#line 86
      _destroy_node(hd, n);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 82
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 90
  free((void *)hd->bucketheads);
  }
  {
#line 91
  free((void *)hd);
  }
  }
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
void *hashdict_get(HashDict *hd , char const   *key ) 
{ 
  Node *n ;
  Node *tmp ;
  void const   *tmp___0 ;

  {
  {
  {
#line 95
  tmp = _node_lookup(hd, key);
  }
#line 95
  n = tmp;
  }
#line 99
  if (n->next) {
#line 99
    tmp___0 = (n->next)->value;
  } else {
#line 99
    tmp___0 = (void const   *)0;
  }
#line 99
  return ((void *)tmp___0);
}
}
#line 102 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
void hashdict_set(HashDict *hd , char const   *key , void const   *value ) 
{ 
  Node *n ;
  Node *newnode ;
  void *tmp ;

  {
#line 104
  if (! value) {
    {
    {
#line 104
    hashdict_unset(hd, key);
    }
    }
#line 104
    return;
  }
  {
  {
#line 106
  n = _node_lookup(hd, key);
  }
  }
#line 107
  if (n->next) {
#line 109
    if (hd->value_destroyer) {
      {
      {
#line 109
      (*(hd->value_destroyer))((void *)(n->next)->value);
      }
      }
    }
#line 110
    (n->next)->value = value;
  } else {
    {
    {
#line 114
    tmp = zalloc((int )sizeof(Node ));
    }
#line 114
    newnode = (Node *)tmp;
    {
#line 115
    newnode->key = sstrdup(key);
    }
#line 116
    newnode->value = value;
#line 117
    newnode->next = (struct Node_ *)((void *)0);
#line 118
    n->next = newnode;
    }
  }
#line 120
  return;
}
}
#line 122 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
_Bool hashdict_unset(HashDict *hd , char const   *key ) 
{ 
  Node *n ;
  Node *tmp ;

  {
  {
  {
#line 123
  tmp = _node_lookup(hd, key);
  }
#line 123
  n = tmp;
  }
#line 124
  if (n->next) {
    {
    {
#line 125
    _destroy_node(hd, n->next);
    }
#line 126
    n->next = (n->next)->next;
    }
#line 127
    return ((_Bool)1);
  }
#line 129
  return ((_Bool)0);
}
}
#line 132 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
void hashdict_write(HashDict *hd , FILE *f___0 , void (*value_writer)(void * , FILE * ) ) 
{ 


  {
#line 134
  return;
}
}
#line 136 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
HashDict *hashdict_read(HashDict *hd , FILE *f___0 , void *(*valuereader)(FILE * ) ) 
{ 


  {
#line 138
  return ((HashDict *)((void *)0));
}
}
#line 141 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
HashDictIt hashdict_it_start(HashDict *hd ) 
{ 
  HashDictIt it ;

  {
#line 145
  it.pastend = (_Bool)0;
#line 146
  it.value = (void const   *)((void *)0);
#line 146
  it.key = (char const   *)it.value;
#line 147
  it.dict = hd;
#line 148
  it.nextbucket = 0;
#line 149
  it.nextnode = (void *)0;
#line 151
  return (it);
}
}
#line 154 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
_Bool hashdict_it_advance(HashDictIt *hdi ) 
{ 
  HashDict *hd ;
  int i ;
  void const   *tmp ;

  {
#line 155
  if (hdi->pastend) {
#line 155
    return ((_Bool)0);
  }
#line 157
  if (hdi->nextnode) {
#line 158
    hdi->key = (char const   *)((Node *)hdi->nextnode)->key;
#line 159
    hdi->value = ((Node *)hdi->nextnode)->value;
#line 160
    hdi->nextnode = (void *)((Node *)hdi->nextnode)->next;
  } else {
#line 164
    hd = hdi->dict;
#line 165
    i = hdi->nextbucket;
    {
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 166
      if (i < hd->bucketcount) {
#line 166
        if (! (! (hd->bucketheads + i)->next)) {
#line 166
          goto while_break;
        }
      } else {
#line 166
        goto while_break;
      }
#line 166
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 168
    if (i < hd->bucketcount) {
#line 170
      hdi->key = (char const   *)((hd->bucketheads + i)->next)->key;
#line 171
      hdi->value = ((hd->bucketheads + i)->next)->value;
#line 172
      hdi->nextbucket = i + 1;
#line 173
      hdi->nextnode = (void *)((hd->bucketheads + i)->next)->next;
    } else {
#line 177
      tmp = (void const   *)((void *)0);
#line 177
      hdi->value = tmp;
#line 177
      hdi->key = (char const   *)tmp;
#line 178
      hdi->pastend = (_Bool)1;
#line 179
      return ((_Bool)0);
    }
  }
#line 183
  return ((_Bool)1);
}
}
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static Node *_node_lookup(HashDict *hd , char const   *key ) 
{ 
  Node *n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 196
  tmp = _which_bucket(key, hd->bucketcount);
  }
#line 196
  n = hd->bucketheads + tmp;
  }
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (n->next) {
      {
      {
#line 197
      tmp___0 = strcmp((char const   *)(n->next)->key, key);
      }
      }
#line 197
      if (! tmp___0) {
#line 197
        goto while_break;
      }
    } else {
#line 197
      goto while_break;
    }
#line 197
    n = n->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (n);
}
}
#line 201 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node(HashDict *hd , Node *n ) 
{ 


  {
#line 202
  if (n) {
#line 203
    if (hd->value_destroyer) {
#line 203
      if (n->value) {
        {
        {
#line 204
        (*(hd->value_destroyer))((void *)n->value);
        }
        }
      }
    }
    {
    {
#line 205
    zfree(& n->key);
    }
    {
#line 206
    free((void *)n);
    }
    }
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static int _which_bucket(char const   *key , int bucketcount ) 
{ 
  int x ;
  char const   *tmp ;

  {
#line 218
  x = 0;
  {
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 219
    if (! *key) {
#line 219
      goto while_break;
    }
#line 219
    tmp = key;
#line 219
    key ++;
#line 219
    x += (int )*tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (x % bucketcount);
}
}
#line 105 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
static char *hex_codes___0[16]  = 
#line 105 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
  {      (char *)"000000",      (char *)"990000",      (char *)"009900",      (char *)"999900", 
        (char *)"000099",      (char *)"990099",      (char *)"009999",      (char *)"999999", 
        (char *)"404040",      (char *)"ff0000",      (char *)"00ff00",      (char *)"ffff00", 
        (char *)"0000ff",      (char *)"ff00ff",      (char *)"00ffff",      (char *)"ffffff"};
#line 196 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aecat.c"
static char optstring___0[13]  = 
#line 196
  {      (char )'o',      (char )':',      (char )'c',      (char )'h', 
        (char )'l',      (char )':',      (char )'L',      (char )'b', 
        (char )'p',      (char )'f',      (char )':',      (char )'n', 
        (char )'\000'};
#line 46 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.h"
void kurses_init(void) ;
#line 49
void kurses_finalize(void) ;
#line 69
int kurses_pos_valid(int x , int y ) ;
#line 89
int kurses_line_input_ex(char *buf___15 , int buf_size , int *skeys , int flags ) ;
#line 586 "/usr/include/ncurses.h"
extern _Bool has_colors(void) ;
#line 596
extern WINDOW *initscr(void) ;
#line 598
extern int init_pair(short  , short  , short  ) ;
#line 611
extern int keypad(WINDOW * , _Bool  ) ;
#line 671
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 675
extern int noecho(void) ;
#line 681
extern int overwrite(WINDOW const   * , WINDOW * ) ;
#line 691
extern int raw(void) ;
#line 728
extern int start_color(void) ;
#line 757
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 772
extern int werase(WINDOW * ) ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_fg  ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_bg  ;
#line 64
static int kurses_pair_for(int fg , int bg ) ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
SavedScreenNode *sss_top  ;
#line 78 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void kurses_init(void) 
{ 
  int fg ;
  int bg ;
  _Bool tmp ;
  int pair ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 81
  initscr();
  }
  {
#line 82
  raw();
  }
  {
#line 83
  noecho();
  }
  {
#line 84
  keypad(stdscr, (_Bool)1);
  }
#line 87
  cur_fg = 7;
#line 88
  cur_bg = 0;
#line 89
  sss_top = (SavedScreenNode *)((void *)0);
  {
#line 91
  tmp = has_colors();
  }
  }
#line 91
  if (! tmp) {
    {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*** Fatal error: Terminal has no color support.\n");
    }
    {
#line 93
    exit(1);
    }
    }
  }
  {
  {
#line 96
  start_color();
  }
#line 99
  fg = 0;
  }
  {
  {
#line 99
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! (fg < 8)) {
#line 99
      goto while_break;
    }
#line 99
    bg = 0;
    {
    {
#line 99
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 99
      if (! (bg < 8)) {
#line 99
        goto while_break___0;
      }
      {
      {
#line 100
      tmp___0 = kurses_pair_for(fg, bg);
      }
#line 100
      pair = tmp___0;
      }
#line 101
      if (! pair) {
#line 101
        goto __Cont;
      }
      {
      {
#line 104
      init_pair((short )pair, (short )fg, (short )bg);
      }
      }
      __Cont: /* CIL Label */ 
#line 99
      bg ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    fg ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 107
  wclear(stdscr);
  }
  {
#line 108
  wrefresh(stdscr);
  }
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void kurses_finalize(void) 
{ 


  {
  {
  {
#line 112
  wclear(stdscr);
  }
  {
#line 113
  wrefresh(stdscr);
  }
  {
#line 114
  endwin();
  }
  }
#line 115
  return;
}
}
#line 117 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void kurses_color(int fg , int bg ) 
{ 
  int pair ;

  {
#line 120
  if (fg < 0) {
#line 120
    fg = cur_fg;
  }
#line 121
  if (bg < 0) {
#line 121
    bg = cur_bg;
  }
  {
  {
#line 124
  pair = kurses_pair_for(fg, bg);
  }
  }
#line 127
  if (pair) {
#line 127
    stdscr->_attrs = (attr_t )(pair << 8);
  } else {
#line 128
    stdscr->_attrs = 0UL;
  }
#line 132
  if (fg & 8) {
    {
    {
#line 132
    wattr_on(stdscr, 1UL << 21, (void *)0);
    }
    }
  }
#line 133
  if (bg & 8) {
    {
    {
#line 133
    wattr_on(stdscr, 1UL << 19, (void *)0);
    }
    }
  }
#line 134
  return;
}
}
#line 137 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void kurses_color_at(int attr ) 
{ 


  {
  {
  {
#line 138
  kurses_color(attr >> 4, attr & 15);
  }
  }
#line 139
  return;
}
}
#line 141 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
int kurses_width(void) 
{ 
  int maxy ;
  int maxx ;

  {
#line 143
  if (stdscr) {
#line 143
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 143
    maxy = -1;
  }
#line 143
  if (stdscr) {
#line 143
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 143
    maxx = -1;
  }
#line 144
  return (maxx);
}
}
#line 147 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
int kurses_height(void) 
{ 
  int maxy ;
  int maxx ;

  {
#line 149
  if (stdscr) {
#line 149
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 149
    maxy = -1;
  }
#line 149
  if (stdscr) {
#line 149
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 149
    maxx = -1;
  }
#line 150
  return (maxy);
}
}
#line 153 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
int kurses_pos_valid(int x , int y ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 154
  if (x >= 0) {
    {
    {
#line 154
    tmp = kurses_width();
    }
    }
#line 154
    if (x < tmp) {
#line 154
      if (y >= 0) {
        {
        {
#line 154
        tmp___0 = kurses_height();
        }
        }
#line 154
        if (y < tmp___0) {
#line 154
          tmp___1 = 1;
        } else {
#line 154
          tmp___1 = 0;
        }
      } else {
#line 154
        tmp___1 = 0;
      }
    } else {
#line 154
      tmp___1 = 0;
    }
  } else {
#line 154
    tmp___1 = 0;
  }
#line 154
  return (tmp___1);
}
}
#line 158 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
int kurses_move(int x , int y ) 
{ 
  int tmp ;

  {
  {
  {
#line 159
  tmp = kurses_pos_valid(x, y);
  }
  }
#line 159
  if (! tmp) {
#line 159
    return (0);
  }
  {
  {
#line 160
  wmove(stdscr, y, x);
  }
  }
#line 161
  return (1);
}
}
#line 164 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
int kurses_line_input(char *buf___15 , int buf_size ) 
{ 
  int tmp ;

  {
  {
  {
#line 165
  tmp = kurses_line_input_ex(buf___15, buf_size, (int *)((void *)0), 0);
  }
  }
#line 165
  return (tmp);
}
}
#line 168 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
int kurses_line_input_ex(char *buf___15 , int buf_size , int *skeys , int flags ) 
{ 
  int pos ;
  int ch ;
  int const   *p ;
  int const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 169
  pos = 0;
  {
  {
#line 173
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 174
    wrefresh(stdscr);
    }
    {
#line 175
    ch = wgetch(stdscr);
    }
    }
#line 176
    if (ch < 0) {
#line 176
      goto while_continue;
    }
#line 179
    p = (int const   *)skeys;
#line 179
    if (p) {
      {
      {
#line 179
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! *p) {
#line 179
          goto while_break___0;
        }
#line 179
        tmp = p;
#line 179
        p ++;
#line 179
        if (*tmp == (int const   )ch) {
#line 179
          return (- ch);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 183
    if (ch == 10) {
#line 183
      goto case_10;
    }
#line 186
    if (ch == 27) {
#line 186
      goto case_27;
    }
#line 186
    if (ch == 7) {
#line 186
      goto case_27;
    }
#line 186
    if (ch == 3) {
#line 186
      goto case_27;
    }
#line 187
    if (ch == 127) {
#line 187
      goto case_127;
    }
#line 187
    if (ch == 8) {
#line 187
      goto case_127;
    }
#line 187
    if (ch == 263) {
#line 187
      goto case_127;
    }
#line 190
    if (ch == 21) {
#line 190
      goto case_21;
    }
#line 194
    goto switch_default;
    case_10: /* CIL Label */ 
#line 183
    *(buf___15 + pos) = (char)0;
#line 183
    return (1);
    case_27: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 186
    *buf___15 = (char)0;
#line 186
    return (0);
    case_127: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_263: /* CIL Label */ 
#line 188
    if (pos > 0) {
      {
#line 188
      pos --;
      {
#line 188
      waddch(stdscr, (chtype const   )'\b');
      }
      {
#line 188
      waddch(stdscr, (chtype const   )' ');
      }
      {
#line 188
      waddch(stdscr, (chtype const   )'\b');
      }
      }
    }
#line 189
    goto switch_break;
    case_21: /* CIL Label */ 
    {
    {
#line 191
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 191
      tmp___0 = pos;
#line 191
      pos --;
#line 191
      if (! tmp___0) {
#line 191
        goto while_break___1;
      }
      {
      {
#line 191
      waddch(stdscr, (chtype const   )'\b');
      }
      {
#line 191
      waddch(stdscr, (chtype const   )' ');
      }
      {
#line 191
      waddch(stdscr, (chtype const   )'\b');
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 192
    pos = 0;
#line 193
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 195
    if (pos <= buf_size - 2) {
      {
      {
#line 195
      tmp___3 = printable_char(ch);
      }
      }
#line 195
      if (tmp___3) {
#line 198
        tmp___1 = pos;
#line 198
        pos ++;
#line 198
        *(buf___15 + tmp___1) = (char )ch;
#line 199
        if (flags & 1) {
#line 199
          tmp___2 = '*';
        } else {
#line 199
          tmp___2 = ch;
        }
        {
        {
#line 199
        waddch(stdscr, (chtype const   )tmp___2);
        }
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 205 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void draw_window(int x0 , int y0 , int w , int h , char const   *title ) 
{ 
  int x ;
  int y ;
  int x1 ;
  int y1 ;
  int gr_ch[3][3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;

  {
#line 209
  gr_ch[0][0] = (int )acs_map[(unsigned char )'l'];
#line 209
  gr_ch[0][1] = (int )acs_map[(unsigned char )'q'];
#line 209
  gr_ch[0][2] = (int )acs_map[(unsigned char )'k'];
#line 210
  gr_ch[1][0] = (int )acs_map[(unsigned char )'x'];
#line 210
  gr_ch[1][1] = ' ';
#line 210
  gr_ch[1][2] = (int )acs_map[(unsigned char )'x'];
#line 211
  gr_ch[2][0] = (int )acs_map[(unsigned char )'m'];
#line 211
  gr_ch[2][1] = (int )acs_map[(unsigned char )'q'];
#line 211
  gr_ch[2][2] = (int )acs_map[(unsigned char )'j'];
#line 213
  x1 = (x0 + w) - 1;
#line 214
  y1 = (y0 + h) - 1;
#line 216
  y = y0;
  {
  {
#line 216
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 216
    if (! (y < y0 + h)) {
#line 216
      goto while_break;
    }
#line 217
    x = x0;
    {
    {
#line 217
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (x < x0 + w)) {
#line 217
        goto while_break___0;
      }
      {
      {
#line 218
      tmp___3 = kurses_move(x, y);
      }
      }
#line 218
      if (tmp___3) {
#line 219
        if (y == y0) {
#line 219
          tmp___0 = 0;
        } else {
#line 219
          if (y == y1) {
#line 219
            tmp = 2;
          } else {
#line 219
            tmp = 1;
          }
#line 219
          tmp___0 = tmp;
        }
#line 219
        if (x == x0) {
#line 219
          tmp___2 = 0;
        } else {
#line 219
          if (x == x1) {
#line 219
            tmp___1 = 2;
          } else {
#line 219
            tmp___1 = 1;
          }
#line 219
          tmp___2 = tmp___1;
        }
        {
        {
#line 219
        waddch(stdscr, (chtype const   )gr_ch[tmp___0][tmp___2]);
        }
        }
      }
#line 217
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 216
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  if (title) {
    {
    {
#line 222
    tmp___4 = strlen(title);
    }
    {
#line 222
    tmp___5 = kurses_move((int )((size_t )(x0 + w / 2) - tmp___4 / 2U), y0);
    }
    }
#line 222
    if (tmp___5) {
      {
      {
#line 222
      waddnstr(stdscr, title, -1);
      }
      }
    }
  }
  {
  {
#line 223
  kurses_move(x0 + 1, y0 + 1);
  }
  }
#line 224
  return;
}
}
#line 226 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void draw_centered_window(int w , int h , char const   *title , int *x , int *y ) 
{ 
  int x0 ;
  int tmp ;
  int y0 ;
  int tmp___0 ;

  {
  {
  {
#line 227
  tmp = kurses_width();
  }
#line 227
  x0 = (tmp - w) / 2;
  {
#line 228
  tmp___0 = kurses_height();
  }
#line 228
  y0 = (tmp___0 - h) / 2;
  }
#line 229
  if (x) {
#line 229
    *x = x0 + 1;
  }
#line 230
  if (y) {
#line 230
    *y = y0 + 1;
  }
  {
  {
#line 232
  draw_window(x0, y0, w, h, title);
  }
  }
#line 233
  return;
}
}
#line 235 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void draw_hline(int x0 , int y0 , int w , int left_endpt , int interim , int right_endpt ) 
{ 
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 239
  tmp = kurses_move(x0, y0);
  }
  }
#line 239
  if (! tmp) {
#line 239
    return;
  }
#line 240
  x = x0;
  {
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 240
    if (! (x < x0 + w)) {
#line 240
      goto while_break;
    }
#line 241
    if (x == x0) {
#line 241
      tmp___1 = left_endpt;
    } else {
#line 241
      if (x == (x0 + w) - 1) {
#line 241
        tmp___0 = right_endpt;
      } else {
#line 241
        tmp___0 = interim;
      }
#line 241
      tmp___1 = tmp___0;
    }
    {
    {
#line 241
    waddch(stdscr, (chtype const   )tmp___1);
    }
#line 240
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 245 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void draw_vline(int x0 , int y0 , int h , int upper_endpt , int interim , int lower_endpt ) 
{ 
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 248
  tmp = kurses_move(x0, y0);
  }
  }
#line 248
  if (! tmp) {
#line 248
    return;
  }
#line 249
  y = y0;
  {
  {
#line 249
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 249
    if (! (y < y0 + h)) {
#line 249
      goto while_break;
    }
    {
    {
#line 250
    kurses_move(x0, y);
    }
    }
#line 251
    if (y == y0) {
#line 251
      tmp___1 = upper_endpt;
    } else {
#line 251
      if (y == (y0 + h) - 1) {
#line 251
        tmp___0 = lower_endpt;
      } else {
#line 251
        tmp___0 = interim;
      }
#line 251
      tmp___1 = tmp___0;
    }
    {
    {
#line 251
    waddch(stdscr, (chtype const   )tmp___1);
    }
#line 249
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 256 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void push_screen(void) 
{ 
  SavedScreenNode *n ;
  void *tmp ;

  {
  {
  {
#line 257
  tmp = zalloc((int )sizeof(SavedScreenNode ));
  }
#line 257
  n = (SavedScreenNode *)tmp;
  {
#line 258
  n->win = newwin(0, 0, 0, 0);
  }
  {
#line 259
  overwrite((WINDOW const   *)stdscr, n->win);
  }
#line 260
  n->next = sss_top;
#line 262
  sss_top = n;
  }
#line 263
  return;
}
}
#line 265 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void restore_screen(void) 
{ 
  int tmp ;

  {
#line 266
  if (! sss_top) {
    {
    {
#line 269
    werase(stdscr);
    }
    }
#line 270
    return;
  }
  {
  {
#line 273
  overwrite((WINDOW const   *)sss_top->win, stdscr);
  }
  }
#line 274
  if (stdscr) {
#line 274
    tmp = (int )stdscr->_maxy + 1;
  } else {
#line 274
    tmp = -1;
  }
  {
  {
#line 274
  wtouchln(stdscr, 0, tmp, 1);
  }
  }
#line 275
  return;
}
}
#line 277 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
void pop_screen(void) 
{ 
  SavedScreenNode *newtop ;

  {
#line 279
  if (! sss_top) {
#line 279
    return;
  }
  {
#line 281
  newtop = sss_top->next;
  {
#line 282
  free((void *)sss_top);
  }
#line 283
  sss_top = newtop;
  }
#line 284
  return;
}
}
#line 287 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int kurses_pair_for(int fg , int bg ) 
{ 


  {
#line 288
  fg &= 7;
#line 288
  bg &= 7;
#line 289
  return ((bg << 3) + (7 - fg));
}
}
#line 43 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static char *logo___0[6]  = {      (char *)"79         ",      (char *)"||         ",      (char *)"46799 97979",      (char *)"||43|||||||", 
        (char *)"311-1231231",      (char *)((void *)0)};
#line 52 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static int logo_colors___0[5]  = {      4,      6,      7,      6, 
        4};
#line 80 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool read_parse_data_line___0(gzFile f___0 , char **label , char **type ,
                                      char **value ) 
{ 
  char *field_start[3] ;
  char *line ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  char const   *r ;
  char *w ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 88
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 89
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 91
  tmp = freadline_ex(f___0, & gzgetc);
  }
  {
#line 91
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
#line 94
  field_start[0] = line;
  {
#line 95
  field_start[1] = strchr((char const   *)line, ':');
  }
  }
#line 95
  if (field_start[1]) {
    {
    {
#line 95
    field_start[2] = strchr((char const   *)(field_start[1] + 1), ':');
    }
    }
#line 95
    if (! field_start[2]) {
      {
      {
#line 98
      dstrset(& err_string, "There\'s a data line with <3 fields.");
      }
      {
#line 99
      do_autod_cleanup(& autodregistry_head, (void *)0);
      }
      }
#line 99
      return ((_Bool)0);
    }
  } else {
    {
    {
#line 98
    dstrset(& err_string, "There\'s a data line with <3 fields.");
    }
    {
#line 99
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 99
    return ((_Bool)0);
  }
#line 105
  *(field_start[1]) = (char)0;
#line 105
  field_start[1] += 2;
#line 106
  *(field_start[2]) = (char)0;
#line 106
  field_start[2] += 2;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((int )*(field_start[0]) == 32)) {
#line 110
      if (! ((int )*(field_start[0]) == 9)) {
#line 110
        goto while_break;
      }
    }
#line 111
    (field_start[0]) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )field_start[0] >= (unsigned long )field_start[1]) {
    {
    {
#line 115
    dstrset(& err_string, "There\'s a data line with an empty label");
    }
    {
#line 116
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 116
    return ((_Bool)0);
  }
#line 120
  if (label) {
    {
    {
#line 120
    *label = sstrdup((char const   *)field_start[0]);
    }
    }
  }
#line 121
  if (type) {
    {
    {
#line 121
    *type = sstrdup((char const   *)field_start[1]);
    }
    }
  }
#line 122
  if (value) {
    {
    {
#line 122
    *value = sstrdup((char const   *)field_start[2]);
    }
    }
  }
#line 125
  if (value) {
#line 126
    r = (char const   *)*value;
#line 127
    w = *value;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! *r) {
#line 129
        goto while_break___0;
      }
#line 130
      if ((int const   )*r == 92) {
#line 131
        r ++;
#line 131
        if ((int const   )*r == 92) {
#line 131
          *w = (char )'\\';
        } else {
#line 131
          *w = (char )((int const   )*r - 48);
        }
      } else {
#line 133
        *w = (char )*r;
      }
#line 135
      r ++;
#line 135
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    *w = (char)0;
  }
  {
  {
#line 142
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 142
  return ((_Bool)1);
}
}
#line 145 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static void aeff_indent___0(AeFile *f___0 ) 
{ 
  int n ;
  int tmp ;

  {
#line 146
  n = f___0->indent_level;
  {
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 147
    tmp = n;
#line 147
    n --;
#line 147
    if (! (tmp > 0)) {
#line 147
      goto while_break;
    }
    {
    {
#line 147
    gzputc(f___0->f, '\t');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool aeff_read_mark___0(AeFile *f___0 , char const   *mark_name , char pref ) 
{ 
  char *line ;
  char *s ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 190
  zfree(& err_string);
  }
#line 192
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 193
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 195
  tmp = freadline_ex(f___0->f, & gzgetc);
  }
  {
#line 195
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
  }
#line 198
  if (! line) {
    {
    {
#line 199
    err_string = dsprintf("EOF reading mark \'%c%s\'", (int )pref, mark_name);
    }
    {
#line 200
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 200
    return ((_Bool)0);
  }
#line 204
  s = line;
  {
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((int )*s == 32)) {
#line 205
      if (! ((int )*s == 9)) {
#line 205
        goto while_break;
      }
    }
#line 205
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 208
  tmp___0 = strcmp((char const   *)(s + 1), mark_name);
  }
  }
#line 208
  if (tmp___0) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  } else
#line 208
  if ((int )*(s + 0) != (int )pref) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  }
  {
  {
#line 214
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 214
  return ((_Bool)1);
}
}
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_fld___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *cancel_btn___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *ok_btn___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_lbl___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *dirs_box___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *files_box___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_stlbl___0  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_stlbl___0  ;
#line 99 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlForm *form___0  ;
#line 101 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *curdir___0  =    (char *)((void *)0);
#line 107
static void _update_widgets___0(void) ;
#line 109 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static _Bool _is_dir_valid___0(char const   *dir ) 
{ 
  DIR *d ;
  DIR *tmp ;

  {
  {
  {
#line 110
  tmp = opendir(dir);
  }
#line 110
  d = tmp;
  }
#line 111
  if (d) {
    {
    {
#line 112
    closedir(d);
    }
    }
#line 113
    return ((_Bool)1);
  }
#line 116
  return ((_Bool)0);
}
}
#line 119 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *my_getcwd___0(void) 
{ 
  int cap ;
  char *s ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 121
  cap = 32;
  {
#line 121
  tmp = malloc((size_t )cap);
  }
#line 121
  s = (char *)tmp;
  }
  {
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 123
    tmp___2 = getcwd(s, (size_t )cap);
    }
    }
#line 123
    if (tmp___2) {
#line 123
      goto while_break;
    }
    {
    {
#line 124
    tmp___0 = __errno_location();
    }
    }
#line 124
    if (*tmp___0 != 34) {
#line 124
      return ((char *)((void *)0));
    }
    {
#line 125
    cap += cap;
    {
#line 125
    tmp___1 = malloc((size_t )cap);
    }
#line 125
    s = (char *)tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (s);
}
}
#line 131 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *_get_canon_dir_path___0(char const   *base , char const   *relative ) 
{ 
  char *oldpwd ;
  char *tmp ;
  char *retval ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 133
  tmp = my_getcwd___0();
  }
#line 133
  oldpwd = tmp;
  }
#line 136
  if (! oldpwd) {
#line 136
    return ((char *)((void *)0));
  }
  {
  {
#line 138
  tmp___0 = chdir(base);
  }
  }
#line 138
  if (0 != tmp___0) {
#line 138
    return ((char *)((void *)0));
  }
  {
  {
#line 139
  tmp___1 = chdir(relative);
  }
  }
#line 139
  if (0 != tmp___1) {
#line 139
    return ((char *)((void *)0));
  }
  {
  {
#line 141
  retval = my_getcwd___0();
  }
  {
#line 143
  tmp___4 = chdir((char const   *)oldpwd);
  }
  }
#line 143
  if (0 != tmp___4) {
    {
    {
#line 144
    tmp___2 = __errno_location();
    }
    {
#line 144
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PANIC: Can\'t go back to old wd \'%s\'\n%s\n",
            oldpwd, tmp___3);
    }
    {
#line 146
    abort();
    }
    }
  }
#line 149
  return (retval);
}
}
#line 283 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static void _update_widgets___0(void) 
{ 
  DIR *d ;
  struct dirent *dent ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *compname ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 288
  d = opendir((char const   *)curdir___0);
  }
  }
#line 290
  if (! d) {
    {
    {
#line 291
    tmp = __errno_location();
    }
    {
#line 291
    tmp___0 = strerror(*tmp);
    }
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR in opendir(\"%s\"): %s\n",
            curdir___0, tmp___0);
    }
    {
#line 293
    abort();
    }
    }
  }
  {
  {
#line 296
  aewl_listbox_clear((AewlListBox *)dirs_box___0);
  }
  {
#line 297
  aewl_listbox_clear((AewlListBox *)files_box___0);
  }
  }
  {
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 298
    dent = readdir(d);
    }
    }
#line 298
    if (! dent) {
#line 298
      goto while_break;
    }
    {
    {
#line 299
    tmp___1 = strlen((char const   *)(dent->d_name));
    }
    {
#line 299
    tmp___2 = strlen((char const   *)curdir___0);
    }
    {
#line 299
    tmp___3 = zalloc((int )((tmp___1 + tmp___2) + 2U));
    }
#line 299
    compname = (char *)tmp___3;
    {
#line 300
    sprintf((char */* __restrict  */)compname, (char const   */* __restrict  */)"%s/%s",
            curdir___0, dent->d_name);
    }
    {
#line 302
    tmp___4 = stat((char const   */* __restrict  */)compname, (struct stat */* __restrict  */)(& st));
    }
    }
#line 302
    if (0 != tmp___4) {
#line 302
      goto while_continue;
    }
    {
    {
#line 304
    free((void *)compname);
    }
    }
#line 306
    if ((st.st_mode & 61440U) == 16384U) {
      {
      {
#line 307
      aewl_listbox_add((AewlListBox *)dirs_box___0, (char const   *)(dent->d_name));
      }
      }
    } else {
      {
      {
#line 309
      aewl_listbox_add((AewlListBox *)files_box___0, (char const   *)(dent->d_name));
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 311
  aewl_listbox_sort((AewlListBox *)dirs_box___0);
  }
  {
#line 312
  aewl_listbox_sort((AewlListBox *)files_box___0);
  }
  {
#line 314
  closedir(d);
  }
  {
#line 317
  aewl_label_set_text((AewlLabel *)directory_lbl___0, (char const   *)curdir___0);
  }
  }
#line 318
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node___0(HashDict *hd , Node *n ) ;
#line 58
static int _which_bucket___0(char const   *key , int bucketcount ) ;
#line 59
static Node *_node_lookup___0(HashDict *hd , char const   *key ) ;
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static Node *_node_lookup___0(HashDict *hd , char const   *key ) 
{ 
  Node *n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 196
  tmp = _which_bucket___0(key, hd->bucketcount);
  }
#line 196
  n = hd->bucketheads + tmp;
  }
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (n->next) {
      {
      {
#line 197
      tmp___0 = strcmp((char const   *)(n->next)->key, key);
      }
      }
#line 197
      if (! tmp___0) {
#line 197
        goto while_break;
      }
    } else {
#line 197
      goto while_break;
    }
#line 197
    n = n->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (n);
}
}
#line 201 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node___0(HashDict *hd , Node *n ) 
{ 


  {
#line 202
  if (n) {
#line 203
    if (hd->value_destroyer) {
#line 203
      if (n->value) {
        {
        {
#line 204
        (*(hd->value_destroyer))((void *)n->value);
        }
        }
      }
    }
    {
    {
#line 205
    zfree(& n->key);
    }
    {
#line 206
    free((void *)n);
    }
    }
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static int _which_bucket___0(char const   *key , int bucketcount ) 
{ 
  int x ;
  char const   *tmp ;

  {
#line 218
  x = 0;
  {
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 219
    if (! *key) {
#line 219
      goto while_break;
    }
#line 219
    tmp = key;
#line 219
    key ++;
#line 219
    x += (int )*tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (x % bucketcount);
}
}
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_fg___0  ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_bg___0  ;
#line 64
static int kurses_pair_for___0(int fg , int bg ) ;
#line 287 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int kurses_pair_for___0(int fg , int bg ) 
{ 


  {
#line 288
  fg &= 7;
#line 288
  bg &= 7;
#line 289
  return ((bg << 3) + (7 - fg));
}
}
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static char hs___0[17]  = 
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 260 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static int hex_digit_val___0(char c ) 
{ 


  {
#line 261
  if ((int )c >= 48) {
#line 261
    if ((int )c <= 57) {
#line 261
      return ((int )c - 48);
    } else {
#line 261
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 262
  if ((int )c >= 97) {
#line 262
    if ((int )c <= 102) {
#line 262
      return (((int )c - 97) + 10);
    } else {
#line 262
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 263
  if ((int )c >= 65) {
#line 263
    if ((int )c <= 70) {
#line 263
      return (((int )c - 65) + 10);
    } else {
#line 264
      return (0);
    }
  } else {
#line 264
    return (0);
  }
}
}
#line 5 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_LYR___0(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Layer *l ;

  {
#line 6
  l = (Layer *)ud;
#line 7
  *r_cell = *(*(l->cells + x) + y);
#line 8
  return;
}
}
#line 11 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_COMPOSITE___0(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Document *doc___0 ;

  {
  {
#line 12
  doc___0 = doc___0;
  {
#line 13
  *r_cell = document_calc_effective_cell(doc___0, x, y);
  }
  }
#line 14
  return;
}
}
#line 162 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char tbl_lookup___0(char **table , int ch ) 
{ 
  char const   *s ;
  char const   *p ;
  char const   *tmp ;

  {
#line 163
  s = (char const   *)*(table + 0);
#line 163
  p = (char const   *)*(table + 1);
  {
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 164
    if (! *s) {
#line 164
      goto while_break;
    }
#line 165
    tmp = s;
#line 165
    s ++;
#line 165
    if ((int const   )*tmp == (int const   )ch) {
#line 165
      return ((char )*p);
    }
#line 166
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return ((char )ch);
}
}
#line 174 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___1[2]  = {      (char *)"`\'()/\\<>[]{}\003\005\006\b\t\v",      (char *)"\'`)(\\/><][}{\005\003\b\006\v\t"};
#line 195 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___2[2]  = {      (char *)"/\\\003\t\004\n\005\v",      (char *)"\\/\t\003\n\004\v\005"};
#line 517 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 58 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
void paint_status_bar(void) ;
#line 61
void paint_desktop(void) ;
#line 64
void paint_screen(void) ;
#line 69 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
void paint_status_bar(void) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 70
  tmp = kurses_height();
  }
  {
#line 70
  kurses_move(0, tmp - 1);
  }
  {
#line 71
  kurses_color(3, 0);
  }
  {
#line 72
  printw("[Lyr %2d] (%3d, %3d) ", _lyr, _x, _y);
  }
  }
#line 74
  if (_selmode == 0) {
#line 75
    if (_doc->layer_count) {
#line 75
      tmp___0 = (char const   *)(*(_doc->layers + _lyr))->name;
    } else {
#line 75
      tmp___0 = "[empty]";
    }
    {
    {
#line 75
    printw("%-20s", tmp___0);
    }
    {
#line 76
    kurses_color(3, 0);
    }
    {
#line 77
    waddnstr(stdscr, "   ", -1);
    }
    {
#line 79
    kurses_color(_fg, _bg);
    }
    {
#line 80
    waddnstr(stdscr, "AaBbCc", -1);
    }
    {
#line 81
    kurses_color(7, 0);
    }
    {
#line 82
    waddnstr(stdscr, "    ", -1);
    }
    }
#line 84
    if (_insmode) {
      {
      {
#line 85
      kurses_color(0, 22);
      }
      {
#line 86
      printw(" INSERT ");
      }
      {
#line 87
      kurses_color(7, 0);
      }
      }
    } else {
      {
      {
#line 89
      printw("        ");
      }
      }
    }
#line 91
    if (_lgmode) {
      {
      {
#line 92
      kurses_color(0, 4);
      }
      {
#line 93
      waddnstr(stdscr, " LINES! ", -1);
      }
      {
#line 94
      kurses_color(7, 0);
      }
      }
    } else {
      {
      {
#line 96
      printw("        ");
      }
      }
    }
#line 98
    if (_compmode) {
      {
      {
#line 99
      kurses_color(0, 5);
      }
      {
#line 100
      waddnstr(stdscr, " COMPOS ", -1);
      }
      {
#line 101
      kurses_color(7, 0);
      }
      }
    }
  } else
#line 104
  if (_selmode == 1) {
    {
    {
#line 105
    kurses_color(0, 2);
    }
    {
#line 106
    printw(" SELECT ");
    }
    {
#line 107
    kurses_color(2, 0);
    }
    {
#line 108
    printw(" (c)opy (m)ove (e)rase (f)g-tint (b)g-tint (o)-edge");
    }
    }
  } else {
    {
    {
#line 111
    kurses_color(0, 1);
    }
    {
#line 112
    printw(" FLOAT ");
    }
    {
#line 113
    kurses_color(1, 0);
    }
    {
#line 114
    printw(" (s)tamp (x) flip-x (y) flip-y (t)ransparent ");
    }
    }
  }
#line 116
  return;
}
}
#line 118 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
void layer_paint_callback(int x , int y , int *ch , int *attr ) 
{ 
  int x0 ;
  int x1 ;
  int y0 ;
  int y1 ;

  {
  {
  {
#line 120
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
  }
#line 122
  if (x >= x0) {
#line 122
    if (x <= x1) {
#line 122
      if (y >= y0) {
#line 122
        if (y <= y1) {
#line 124
          *attr = ((*attr & 15) << 4) | (*attr >> 4);
#line 125
          *attr &= 247;
        }
      }
    }
  }
#line 127
  return;
}
}
#line 139 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
static char *msg  =    (char *)"[Document contains no layers; press F1 for menu]";
#line 129 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
void paint_screen(void) 
{ 
  int scr_width ;
  int scr_height ;
  int i ;
  size_t tmp ;
  _Bool tmp___0 ;
  Layer *l ;
  void (*tmp___1)(int x , int y , int *ch , int *attr ) ;
  void (*tmp___2)(int x , int y , int *ch , int *attr ) ;
  int tmp___3 ;

  {
  {
  {
#line 132
  scr_width = kurses_width();
  }
  {
#line 133
  scr_height = kurses_height();
  }
  {
#line 135
  werase(stdscr);
  }
  {
#line 136
  paint_desktop();
  }
  {
#line 137
  paint_status_bar();
  }
  {
#line 138
  tmp___0 = doc_empty();
  }
  }
#line 138
  if (tmp___0) {
    {
    {
#line 140
    tmp = strlen((char const   *)msg);
    }
    {
#line 140
    kurses_move((int )(((size_t )scr_width - tmp) / 2U), scr_height / 2);
    }
    {
#line 141
    kurses_color(7, 0);
    }
    {
#line 142
    printw((char const   *)msg);
    }
    {
#line 143
    wrefresh(stdscr);
    }
    }
#line 144
    return;
  }
#line 148
  if (_compmode) {
#line 149
    i = _doc->layer_count - 1;
    {
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 149
      if (! (i >= 0)) {
#line 149
        goto while_break;
      }
#line 150
      l = *(_doc->layers + i);
#line 151
      if (l->visible) {
#line 152
        if (_selmode == 1) {
#line 152
          if (i == _lyr) {
#line 152
            tmp___1 = & layer_paint_callback;
          } else {
#line 152
            tmp___1 = (void (*)(int x , int y , int *ch , int *attr ))0;
          }
        } else {
#line 152
          tmp___1 = (void (*)(int x , int y , int *ch , int *attr ))0;
        }
        {
        {
#line 152
        layer_paint(l, - _svx, - _svy, 0, 0, scr_width, scr_height - 1, tmp___1);
        }
        }
      }
#line 149
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 161
    if (_selmode == 1) {
#line 161
      tmp___2 = & layer_paint_callback;
    } else {
#line 161
      tmp___2 = (void (*)(int x , int y , int *ch , int *attr ))0;
    }
    {
    {
#line 161
    layer_paint_opaque(*(_doc->layers + _lyr), - _svx, - _svy, 0, 0, scr_width, scr_height - 1,
                       tmp___2);
    }
    }
  }
#line 166
  if (_clipboard) {
#line 166
    if (_selmode == 2) {
      {
      {
#line 168
      layer_paint(_clipboard, _x - _svx, _y - _svy, 0, 0, scr_width, scr_height - 1,
                  (void (*)(int x , int y , int *ch , int *attr ))((void *)0));
      }
      }
    }
  }
  {
  {
#line 171
  tmp___3 = kurses_move(_x - _svx, _y - _svy);
  }
  }
#line 171
  if (! tmp___3) {
    {
    {
#line 171
    kurses_move(0, 0);
    }
    }
  }
  {
  {
#line 172
  wrefresh(stdscr);
  }
  }
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
void paint_desktop(void) 
{ 
  int scr_width ;
  int scr_height ;
  int x ;
  int y ;

  {
  {
  {
#line 179
  scr_width = kurses_width();
  }
  {
#line 180
  scr_height = kurses_height();
  }
  {
#line 182
  kurses_color(8, 0);
  }
#line 183
  y = 0;
  }
  {
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 183
    if (! (y < scr_height - 1)) {
#line 183
      goto while_break;
    }
    {
    {
#line 184
    kurses_move(0, y);
    }
#line 185
    x = 0;
    }
    {
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 185
      if (! (x < scr_width)) {
#line 185
        goto while_break___0;
      }
      {
      {
#line 185
      waddch(stdscr, (chtype const   )acs_map[(unsigned char )'a']);
      }
#line 185
      x ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 183
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_add_layer___0(_Bool interactive ) 
{ 
  int width___0 ;
  int height___0 ;
  int nom_width ;
  int nom_height ;
  char *name ;
  Layer *lyr___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 72
  document_get_nom_dim(_doc, & nom_width, & nom_height);
  }
  }
#line 73
  if (interactive) {
    {
    {
#line 74
    width___0 = ui_ask_i("NEW LAYER: Enter width", nom_width, 2, 2147483647);
    }
    }
#line 75
    if (ui_cancel) {
#line 75
      return;
    }
    {
    {
#line 76
    height___0 = ui_ask_i("NEW LAYER: Enter height", nom_height, 2, 2147483647);
    }
    }
#line 77
    if (ui_cancel) {
#line 77
      return;
    }
    {
    {
#line 78
    name = ui_ask_s("NEW LAYER: Name", "unnamed");
    }
    }
#line 78
    if (ui_cancel) {
#line 78
      return;
    }
  } else {
    {
#line 81
    width___0 = nom_width;
#line 82
    height___0 = nom_height;
    {
#line 83
    name = strdup("unnamed");
    }
    }
  }
  {
  {
#line 86
  lyr___0 = layer_create((char const   *)name, width___0, height___0);
  }
  }
#line 90
  if (_doc->layer_count) {
#line 90
    lyr___0->transp = (_Bool)1;
  } else {
#line 91
    lyr___0->transp = (_Bool)0;
  }
  {
  {
#line 93
  document_insert_layer(_doc, 0, lyr___0);
  }
  {
#line 95
  free((void *)name);
  }
  }
#line 96
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_rename_layer___0(void) 
{ 
  Layer *l ;
  char *new_name ;
  char *__cil_tmp3 ;

  {
  {
#line 101
  l = *(_doc->layers + _lyr);
  {
#line 104
  new_name = ui_ask_s("Rename layer to", (char const   *)l->name);
  }
  }
#line 105
  if (! ui_cancel) {
    {
    {
#line 106
    dstrset(& l->name, (char const   *)new_name);
    }
    }
  }
#line 108
  if (new_name) {
    {
    {
#line 108
    free((void *)new_name);
    }
    }
  }
#line 109
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_resize_layer___0(void) 
{ 
  Layer *l ;
  Layer *new_l ;
  int h ;
  int w ;
  int x ;
  int y ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 114
  l = *(_doc->layers + _lyr);
  {
#line 118
  w = ui_ask_i("RESIZE LAYER: Enter new width", l->width, 2, 2147483647);
  }
  }
#line 119
  if (ui_cancel) {
#line 119
    return;
  }
  {
  {
#line 120
  h = ui_ask_i("RESIZE LAYER: Enter new height", l->height, 2, 2147483647);
  }
  }
#line 121
  if (ui_cancel) {
#line 121
    return;
  }
  {
  {
#line 123
  new_l = layer_create((char const   *)l->name, w, h);
  }
  }
#line 125
  if (l->width > new_l->width) {
#line 125
    w = new_l->width;
  } else {
#line 125
    w = l->width;
  }
#line 126
  if (l->height > new_l->height) {
#line 126
    h = new_l->height;
  } else {
#line 126
    h = l->height;
  }
#line 128
  y = 0;
  {
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 128
    if (! (y < h)) {
#line 128
      goto while_break;
    }
#line 129
    x = 0;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (x < w)) {
#line 129
        goto while_break___0;
      }
#line 130
      (*(new_l->cells + x) + y)->ch = (*(l->cells + x) + y)->ch;
#line 131
      (*(new_l->cells + x) + y)->attr = (*(l->cells + x) + y)->attr;
#line 129
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  layer_destroy(l);
  }
#line 135
  *(_doc->layers + _lyr) = new_l;
  }
#line 136
  return;
}
}
#line 140 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_dup_layer___0(void) 
{ 
  char buf___15[32] ;
  Layer *l ;
  Layer *tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 143
  sprintf((char */* __restrict  */)(buf___15), (char const   */* __restrict  */)"copy of %d",
          _lyr);
  }
#line 145
  l = *(_doc->layers + _lyr);
  {
#line 146
  tmp = layer_dup((char const   *)(buf___15), l);
  }
  {
#line 146
  document_add_layer(_doc, tmp);
  }
  {
#line 147
  switch_to_layer(_doc->layer_count - 1);
  }
  }
#line 148
  return;
}
}
#line 184 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static char *expand_tilde___0(char *filename ) 
{ 
  char *home_dir ;
  char *slash ;
  char *username ;
  char *filename_dup ;
  char *ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 188
  if (*(filename + 1)) {
    {
    {
#line 192
    filename_dup = strdup((char const   *)filename);
    }
    {
#line 193
    slash = strchr((char const   *)filename_dup, '/');
    }
#line 194
    username = filename_dup + 1;
    }
#line 196
    if (! slash) {
      {
      {
#line 198
      free((void *)filename_dup);
      }
      }
#line 199
      return (filename);
    }
    {
#line 202
    *slash = (char )'\000';
    {
#line 204
    tmp = strlen((char const   *)username);
    }
    }
#line 204
    if (! tmp) {
#line 205
      username = (char *)((void *)0);
    }
    {
    {
#line 206
    home_dir = get_home_dir(username);
    }
    }
#line 207
    if (! home_dir) {
#line 208
      return ((char *)((void *)0));
    }
    {
#line 210
    slash ++;
    {
#line 211
    tmp___0 = strlen((char const   *)home_dir);
    }
    {
#line 211
    tmp___1 = strlen((char const   *)slash);
    }
    {
#line 211
    tmp___2 = malloc((tmp___0 + tmp___1) + 1U);
    }
#line 211
    ret = (char *)tmp___2;
    {
#line 212
    sprintf((char */* __restrict  */)ret, (char const   */* __restrict  */)"%s/%s",
            home_dir, slash);
    }
    {
#line 213
    free((void *)filename_dup);
    }
    }
#line 214
    return (ret);
  } else {
#line 217
    return (filename);
  }
}
}
#line 257 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_save_file___0(_Bool forceAsk ) 
{ 
  char *filename ;
  char *expanded_filename ;
  FILE *tmpf ;
  AeFile *f___0 ;
  char msg___1[128] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 260
  f___0 = (AeFile *)0;
#line 263
  if (forceAsk) {
#line 263
    goto _L;
  } else
#line 263
  if (! _filename) {
#line 263
    goto _L;
  } else {
    {
    {
#line 263
    tmp = strlen((char const   *)_filename);
    }
    }
#line 263
    if (tmp) {
      {
      {
#line 267
      filename = strdup((char const   *)_filename);
      }
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 264
      filename = filedlg_show("Save File As");
      }
      }
#line 265
      if (! filename) {
#line 265
        return;
      }
    }
  }
#line 269
  if ((int )*(filename + 0) == 126) {
    {
    {
#line 270
    expanded_filename = expand_tilde___0(filename);
    }
    }
#line 271
    if (! expanded_filename) {
#line 271
      return;
    }
#line 274
    if ((unsigned long )expanded_filename != (unsigned long )filename) {
      {
      {
#line 275
      free((void *)filename);
      }
#line 276
      filename = expanded_filename;
      }
    }
  }
#line 280
  if (_filename) {
    {
    {
#line 280
    tmp___1 = strcmp((char const   *)_filename, (char const   *)filename);
    }
    }
#line 280
    if (tmp___1) {
      {
      {
#line 280
      tmpf = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
      }
#line 280
      if (tmpf) {
        {
        {
#line 283
        fclose(tmpf);
        }
#line 283
        tmpf = (FILE *)0;
        {
#line 284
        tmp___0 = ui_ask_yn("FILE EXISTS. Overwrite?", 0);
        }
        }
#line 284
        if (tmp___0) {
#line 284
          if (ui_cancel) {
            {
            {
#line 285
            ui_message("File was NOT saved!", 0);
            }
            }
#line 286
            goto cleanup;
          }
        } else {
          {
          {
#line 285
          ui_message("File was NOT saved!", 0);
          }
          }
#line 286
          goto cleanup;
        }
      }
    }
  }
  {
  {
#line 290
  f___0 = aeff_open((char const   *)filename, (char )'w');
  }
  }
#line 290
  if (! f___0) {
    {
    {
#line 291
    tmp___2 = aeff_get_error();
    }
    {
#line 291
    sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"ERROR: Can\'t write to file. %s.",
            tmp___2);
    }
    {
#line 292
    ui_message((char const   *)(msg___1), 1);
    }
    }
#line 293
    goto cleanup;
  }
  {
  {
#line 296
  document_save(_doc, f___0);
  }
  {
#line 298
  dstrset(& _filename, (char const   *)filename);
  }
  {
#line 300
  sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"File saved: %s.",
          filename);
  }
  {
#line 301
  ui_message((char const   *)(msg___1), 0);
  }
  }
  cleanup: 
#line 304
  if (f___0) {
    {
    {
#line 304
    aeff_close(f___0);
    }
    }
  }
#line 305
  if (filename) {
    {
    {
#line 305
    free((void *)filename);
    }
    }
  }
#line 306
  return;
}
}
#line 309 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void erase_sel___0(void) 
{ 
  int x ;
  int y ;
  int x0 ;
  int x1 ;
  int y0 ;
  int y1 ;

  {
  {
  {
#line 313
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 314
  x = x0;
  }
  {
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 314
    if (! (x <= x1)) {
#line 314
      goto while_break;
    }
#line 315
    y = y0;
    {
    {
#line 315
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (y <= y1)) {
#line 315
        goto while_break___0;
      }
#line 316
      *(*((*(_doc->layers + _lyr))->cells + x) + y) = (Cell )BLANK_CELL;
#line 315
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 321 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void tint_sel___0(_Bool fg ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int x ;
  int y ;

  {
  {
  {
#line 323
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 325
  x = x0;
  }
  {
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 325
    if (! (x <= x1)) {
#line 325
      goto while_break;
    }
#line 326
    y = y0;
    {
    {
#line 326
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (y <= y1)) {
#line 326
        goto while_break___0;
      }
#line 327
      if (fg) {
#line 328
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )((_fg << 4) | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 15));
      } else {
#line 331
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )(_bg | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 240));
      }
#line 326
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 337 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static int lgmode_map_ch___0(int ch ) 
{ 


  {
  {
#line 339
  if (ch == 55) {
#line 339
    goto case_55;
  }
#line 340
  if (ch == 56) {
#line 340
    goto case_56;
  }
#line 341
  if (ch == 57) {
#line 341
    goto case_57;
  }
#line 342
  if (ch == 52) {
#line 342
    goto case_52;
  }
#line 343
  if (ch == 53) {
#line 343
    goto case_53;
  }
#line 344
  if (ch == 54) {
#line 344
    goto case_54;
  }
#line 345
  if (ch == 49) {
#line 345
    goto case_49;
  }
#line 346
  if (ch == 50) {
#line 346
    goto case_50;
  }
#line 347
  if (ch == 51) {
#line 347
    goto case_51;
  }
#line 348
  if (ch == 45) {
#line 348
    goto case_45;
  }
#line 349
  if (ch == 124) {
#line 349
    goto case_124;
  }
#line 350
  if (ch == 48) {
#line 350
    goto case_48;
  }
#line 351
  goto switch_default;
  case_55: /* CIL Label */ 
#line 339
  return (3);
  case_56: /* CIL Label */ 
#line 340
  return (4);
  case_57: /* CIL Label */ 
#line 341
  return (5);
  case_52: /* CIL Label */ 
#line 342
  return (6);
  case_53: /* CIL Label */ 
#line 343
  return (7);
  case_54: /* CIL Label */ 
#line 344
  return (8);
  case_49: /* CIL Label */ 
#line 345
  return (9);
  case_50: /* CIL Label */ 
#line 346
  return (10);
  case_51: /* CIL Label */ 
#line 347
  return (11);
  case_45: /* CIL Label */ 
#line 348
  return (1);
  case_124: /* CIL Label */ 
#line 349
  return (2);
  case_48: /* CIL Label */ 
#line 350
  return (12);
  switch_default: /* CIL Label */ 
#line 351
  return (ch);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 356 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_select_handle_key___0(int ch ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int tmp ;

  {
  {
  {
#line 359
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
  }
  {
#line 363
  if (ch == 109) {
#line 363
    goto case_109;
  }
#line 369
  if (ch == 99) {
#line 369
    goto case_99;
  }
#line 374
  if (ch == 101) {
#line 374
    goto case_101;
  }
#line 378
  if (ch == 102) {
#line 378
    goto case_102;
  }
#line 381
  if (ch == 98) {
#line 381
    goto case_98;
  }
#line 384
  if (ch == 111) {
#line 384
    goto case_111;
  }
#line 362
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 364
  _selmode = 2;
  {
#line 365
  copy_sel_to_clipboard();
  }
  {
#line 366
  erase_sel___0();
  }
#line 367
  _x = x0;
#line 367
  _y = y0;
  }
#line 368
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 370
  _selmode = 2;
  {
#line 371
  copy_sel_to_clipboard();
  }
#line 372
  _x = x0;
#line 372
  _y = y0;
  }
#line 373
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 375
  _selmode = 0;
  {
#line 376
  erase_sel___0();
  }
  }
#line 377
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 379
  tint_sel___0((_Bool)1);
  }
  }
#line 380
  goto switch_break;
  case_98: /* CIL Label */ 
  {
  {
#line 382
  tint_sel___0((_Bool)0);
  }
  }
#line 383
  goto switch_break;
  case_111: /* CIL Label */ 
#line 388
  tmp = _x;
#line 388
  _x = _ax;
#line 388
  _ax = tmp;
#line 389
  tmp = _y;
#line 389
  _y = _ay;
#line 389
  _ay = tmp;
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 395 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_float_handle_key___0(int ch ) 
{ 


  {
  {
#line 397
  if (ch == 115) {
#line 397
    goto case_115;
  }
#line 400
  if (ch == 88) {
#line 400
    goto case_88;
  }
#line 400
  if (ch == 120) {
#line 400
    goto case_88;
  }
#line 403
  if (ch == 89) {
#line 403
    goto case_89;
  }
#line 403
  if (ch == 121) {
#line 403
    goto case_89;
  }
#line 406
  if (ch == 84) {
#line 406
    goto case_84;
  }
#line 406
  if (ch == 116) {
#line 406
    goto case_84;
  }
#line 396
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  {
#line 398
  paste_clipboard();
  }
  }
#line 399
  goto switch_break;
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  {
  {
#line 401
  layer_flip_x(_clipboard, (_Bool )(ch == 120));
  }
  }
#line 402
  goto switch_break;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
  {
#line 404
  layer_flip_y(_clipboard, (_Bool )(ch == 121));
  }
  }
#line 405
  goto switch_break;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 407
  _clipboard->transp = (_Bool )(! _clipboard->transp);
#line 408
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 433 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void correct_coords___0(void) 
{ 
  Layer *lyr___0 ;
  int scr_width ;
  int tmp ;
  int scr_height ;
  int tmp___0 ;

  {
  {
  {
#line 435
  tmp = kurses_width();
  }
#line 435
  scr_width = tmp;
  {
#line 436
  tmp___0 = kurses_height();
  }
#line 436
  scr_height = tmp___0;
  }
#line 438
  if (! _doc->layer_count) {
#line 438
    return;
  }
#line 439
  lyr___0 = *(_doc->layers + _lyr);
#line 442
  if (_x < 0) {
#line 442
    _x = 0;
  }
#line 443
  if (_x >= lyr___0->width) {
#line 443
    _x = lyr___0->width - 1;
  }
#line 444
  if (_y < 0) {
#line 444
    _y = 0;
  }
#line 445
  if (_y >= lyr___0->height) {
#line 445
    _y = lyr___0->height - 1;
  }
#line 448
  if (_x >= _svx + scr_width) {
#line 448
    _svx = (_x - scr_width) + 1;
  } else
#line 449
  if (_x < _svx) {
#line 449
    _svx = _x;
  }
#line 450
  if (_y >= (_svy + scr_height) - 1) {
#line 450
    _svy = (_y - scr_height) + 2;
  } else
#line 451
  if (_y < _svy) {
#line 451
    _svy = _y;
  }
#line 452
  return;
}
}
#line 80 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool read_parse_data_line___1(gzFile f___0 , char **label , char **type ,
                                      char **value ) 
{ 
  char *field_start[3] ;
  char *line ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  char const   *r ;
  char *w ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 88
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 89
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 91
  tmp = freadline_ex(f___0, & gzgetc);
  }
  {
#line 91
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
#line 94
  field_start[0] = line;
  {
#line 95
  field_start[1] = strchr((char const   *)line, ':');
  }
  }
#line 95
  if (field_start[1]) {
    {
    {
#line 95
    field_start[2] = strchr((char const   *)(field_start[1] + 1), ':');
    }
    }
#line 95
    if (! field_start[2]) {
      {
      {
#line 98
      dstrset(& err_string, "There\'s a data line with <3 fields.");
      }
      {
#line 99
      do_autod_cleanup(& autodregistry_head, (void *)0);
      }
      }
#line 99
      return ((_Bool)0);
    }
  } else {
    {
    {
#line 98
    dstrset(& err_string, "There\'s a data line with <3 fields.");
    }
    {
#line 99
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 99
    return ((_Bool)0);
  }
#line 105
  *(field_start[1]) = (char)0;
#line 105
  field_start[1] += 2;
#line 106
  *(field_start[2]) = (char)0;
#line 106
  field_start[2] += 2;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((int )*(field_start[0]) == 32)) {
#line 110
      if (! ((int )*(field_start[0]) == 9)) {
#line 110
        goto while_break;
      }
    }
#line 111
    (field_start[0]) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )field_start[0] >= (unsigned long )field_start[1]) {
    {
    {
#line 115
    dstrset(& err_string, "There\'s a data line with an empty label");
    }
    {
#line 116
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 116
    return ((_Bool)0);
  }
#line 120
  if (label) {
    {
    {
#line 120
    *label = sstrdup((char const   *)field_start[0]);
    }
    }
  }
#line 121
  if (type) {
    {
    {
#line 121
    *type = sstrdup((char const   *)field_start[1]);
    }
    }
  }
#line 122
  if (value) {
    {
    {
#line 122
    *value = sstrdup((char const   *)field_start[2]);
    }
    }
  }
#line 125
  if (value) {
#line 126
    r = (char const   *)*value;
#line 127
    w = *value;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! *r) {
#line 129
        goto while_break___0;
      }
#line 130
      if ((int const   )*r == 92) {
#line 131
        r ++;
#line 131
        if ((int const   )*r == 92) {
#line 131
          *w = (char )'\\';
        } else {
#line 131
          *w = (char )((int const   )*r - 48);
        }
      } else {
#line 133
        *w = (char )*r;
      }
#line 135
      r ++;
#line 135
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    *w = (char)0;
  }
  {
  {
#line 142
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 142
  return ((_Bool)1);
}
}
#line 145 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static void aeff_indent___1(AeFile *f___0 ) 
{ 
  int n ;
  int tmp ;

  {
#line 146
  n = f___0->indent_level;
  {
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 147
    tmp = n;
#line 147
    n --;
#line 147
    if (! (tmp > 0)) {
#line 147
      goto while_break;
    }
    {
    {
#line 147
    gzputc(f___0->f, '\t');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool aeff_read_mark___1(AeFile *f___0 , char const   *mark_name , char pref ) 
{ 
  char *line ;
  char *s ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 190
  zfree(& err_string);
  }
#line 192
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 193
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 195
  tmp = freadline_ex(f___0->f, & gzgetc);
  }
  {
#line 195
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
  }
#line 198
  if (! line) {
    {
    {
#line 199
    err_string = dsprintf("EOF reading mark \'%c%s\'", (int )pref, mark_name);
    }
    {
#line 200
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 200
    return ((_Bool)0);
  }
#line 204
  s = line;
  {
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((int )*s == 32)) {
#line 205
      if (! ((int )*s == 9)) {
#line 205
        goto while_break;
      }
    }
#line 205
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 208
  tmp___0 = strcmp((char const   *)(s + 1), mark_name);
  }
  }
#line 208
  if (tmp___0) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  } else
#line 208
  if ((int )*(s + 0) != (int )pref) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  }
  {
  {
#line 214
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 214
  return ((_Bool)1);
}
}
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char tmpname___1[64]  ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char buf___4[128]  ;
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_add_layer___1(_Bool interactive ) 
{ 
  int width___0 ;
  int height___0 ;
  int nom_width ;
  int nom_height ;
  char *name ;
  Layer *lyr___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 72
  document_get_nom_dim(_doc, & nom_width, & nom_height);
  }
  }
#line 73
  if (interactive) {
    {
    {
#line 74
    width___0 = ui_ask_i("NEW LAYER: Enter width", nom_width, 2, 2147483647);
    }
    }
#line 75
    if (ui_cancel) {
#line 75
      return;
    }
    {
    {
#line 76
    height___0 = ui_ask_i("NEW LAYER: Enter height", nom_height, 2, 2147483647);
    }
    }
#line 77
    if (ui_cancel) {
#line 77
      return;
    }
    {
    {
#line 78
    name = ui_ask_s("NEW LAYER: Name", "unnamed");
    }
    }
#line 78
    if (ui_cancel) {
#line 78
      return;
    }
  } else {
    {
#line 81
    width___0 = nom_width;
#line 82
    height___0 = nom_height;
    {
#line 83
    name = strdup("unnamed");
    }
    }
  }
  {
  {
#line 86
  lyr___0 = layer_create((char const   *)name, width___0, height___0);
  }
  }
#line 90
  if (_doc->layer_count) {
#line 90
    lyr___0->transp = (_Bool)1;
  } else {
#line 91
    lyr___0->transp = (_Bool)0;
  }
  {
  {
#line 93
  document_insert_layer(_doc, 0, lyr___0);
  }
  {
#line 95
  free((void *)name);
  }
  }
#line 96
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_rename_layer___1(void) 
{ 
  Layer *l ;
  char *new_name ;
  char *__cil_tmp3 ;

  {
  {
#line 101
  l = *(_doc->layers + _lyr);
  {
#line 104
  new_name = ui_ask_s("Rename layer to", (char const   *)l->name);
  }
  }
#line 105
  if (! ui_cancel) {
    {
    {
#line 106
    dstrset(& l->name, (char const   *)new_name);
    }
    }
  }
#line 108
  if (new_name) {
    {
    {
#line 108
    free((void *)new_name);
    }
    }
  }
#line 109
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_resize_layer___1(void) 
{ 
  Layer *l ;
  Layer *new_l ;
  int h ;
  int w ;
  int x ;
  int y ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 114
  l = *(_doc->layers + _lyr);
  {
#line 118
  w = ui_ask_i("RESIZE LAYER: Enter new width", l->width, 2, 2147483647);
  }
  }
#line 119
  if (ui_cancel) {
#line 119
    return;
  }
  {
  {
#line 120
  h = ui_ask_i("RESIZE LAYER: Enter new height", l->height, 2, 2147483647);
  }
  }
#line 121
  if (ui_cancel) {
#line 121
    return;
  }
  {
  {
#line 123
  new_l = layer_create((char const   *)l->name, w, h);
  }
  }
#line 125
  if (l->width > new_l->width) {
#line 125
    w = new_l->width;
  } else {
#line 125
    w = l->width;
  }
#line 126
  if (l->height > new_l->height) {
#line 126
    h = new_l->height;
  } else {
#line 126
    h = l->height;
  }
#line 128
  y = 0;
  {
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 128
    if (! (y < h)) {
#line 128
      goto while_break;
    }
#line 129
    x = 0;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (x < w)) {
#line 129
        goto while_break___0;
      }
#line 130
      (*(new_l->cells + x) + y)->ch = (*(l->cells + x) + y)->ch;
#line 131
      (*(new_l->cells + x) + y)->attr = (*(l->cells + x) + y)->attr;
#line 129
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  layer_destroy(l);
  }
#line 135
  *(_doc->layers + _lyr) = new_l;
  }
#line 136
  return;
}
}
#line 140 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_dup_layer___1(void) 
{ 
  char buf___15[32] ;
  Layer *l ;
  Layer *tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 143
  sprintf((char */* __restrict  */)(buf___15), (char const   */* __restrict  */)"copy of %d",
          _lyr);
  }
#line 145
  l = *(_doc->layers + _lyr);
  {
#line 146
  tmp = layer_dup((char const   *)(buf___15), l);
  }
  {
#line 146
  document_add_layer(_doc, tmp);
  }
  {
#line 147
  switch_to_layer(_doc->layer_count - 1);
  }
  }
#line 148
  return;
}
}
#line 184 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static char *expand_tilde___1(char *filename ) 
{ 
  char *home_dir ;
  char *slash ;
  char *username ;
  char *filename_dup ;
  char *ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 188
  if (*(filename + 1)) {
    {
    {
#line 192
    filename_dup = strdup((char const   *)filename);
    }
    {
#line 193
    slash = strchr((char const   *)filename_dup, '/');
    }
#line 194
    username = filename_dup + 1;
    }
#line 196
    if (! slash) {
      {
      {
#line 198
      free((void *)filename_dup);
      }
      }
#line 199
      return (filename);
    }
    {
#line 202
    *slash = (char )'\000';
    {
#line 204
    tmp = strlen((char const   *)username);
    }
    }
#line 204
    if (! tmp) {
#line 205
      username = (char *)((void *)0);
    }
    {
    {
#line 206
    home_dir = get_home_dir(username);
    }
    }
#line 207
    if (! home_dir) {
#line 208
      return ((char *)((void *)0));
    }
    {
#line 210
    slash ++;
    {
#line 211
    tmp___0 = strlen((char const   *)home_dir);
    }
    {
#line 211
    tmp___1 = strlen((char const   *)slash);
    }
    {
#line 211
    tmp___2 = malloc((tmp___0 + tmp___1) + 1U);
    }
#line 211
    ret = (char *)tmp___2;
    {
#line 212
    sprintf((char */* __restrict  */)ret, (char const   */* __restrict  */)"%s/%s",
            home_dir, slash);
    }
    {
#line 213
    free((void *)filename_dup);
    }
    }
#line 214
    return (ret);
  } else {
#line 217
    return (filename);
  }
}
}
#line 257 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_save_file___1(_Bool forceAsk ) 
{ 
  char *filename ;
  char *expanded_filename ;
  FILE *tmpf ;
  AeFile *f___0 ;
  char msg___1[128] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 260
  f___0 = (AeFile *)0;
#line 263
  if (forceAsk) {
#line 263
    goto _L;
  } else
#line 263
  if (! _filename) {
#line 263
    goto _L;
  } else {
    {
    {
#line 263
    tmp = strlen((char const   *)_filename);
    }
    }
#line 263
    if (tmp) {
      {
      {
#line 267
      filename = strdup((char const   *)_filename);
      }
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 264
      filename = filedlg_show("Save File As");
      }
      }
#line 265
      if (! filename) {
#line 265
        return;
      }
    }
  }
#line 269
  if ((int )*(filename + 0) == 126) {
    {
    {
#line 270
    expanded_filename = expand_tilde___1(filename);
    }
    }
#line 271
    if (! expanded_filename) {
#line 271
      return;
    }
#line 274
    if ((unsigned long )expanded_filename != (unsigned long )filename) {
      {
      {
#line 275
      free((void *)filename);
      }
#line 276
      filename = expanded_filename;
      }
    }
  }
#line 280
  if (_filename) {
    {
    {
#line 280
    tmp___1 = strcmp((char const   *)_filename, (char const   *)filename);
    }
    }
#line 280
    if (tmp___1) {
      {
      {
#line 280
      tmpf = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
      }
#line 280
      if (tmpf) {
        {
        {
#line 283
        fclose(tmpf);
        }
#line 283
        tmpf = (FILE *)0;
        {
#line 284
        tmp___0 = ui_ask_yn("FILE EXISTS. Overwrite?", 0);
        }
        }
#line 284
        if (tmp___0) {
#line 284
          if (ui_cancel) {
            {
            {
#line 285
            ui_message("File was NOT saved!", 0);
            }
            }
#line 286
            goto cleanup;
          }
        } else {
          {
          {
#line 285
          ui_message("File was NOT saved!", 0);
          }
          }
#line 286
          goto cleanup;
        }
      }
    }
  }
  {
  {
#line 290
  f___0 = aeff_open((char const   *)filename, (char )'w');
  }
  }
#line 290
  if (! f___0) {
    {
    {
#line 291
    tmp___2 = aeff_get_error();
    }
    {
#line 291
    sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"ERROR: Can\'t write to file. %s.",
            tmp___2);
    }
    {
#line 292
    ui_message((char const   *)(msg___1), 1);
    }
    }
#line 293
    goto cleanup;
  }
  {
  {
#line 296
  document_save(_doc, f___0);
  }
  {
#line 298
  dstrset(& _filename, (char const   *)filename);
  }
  {
#line 300
  sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"File saved: %s.",
          filename);
  }
  {
#line 301
  ui_message((char const   *)(msg___1), 0);
  }
  }
  cleanup: 
#line 304
  if (f___0) {
    {
    {
#line 304
    aeff_close(f___0);
    }
    }
  }
#line 305
  if (filename) {
    {
    {
#line 305
    free((void *)filename);
    }
    }
  }
#line 306
  return;
}
}
#line 309 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void erase_sel___1(void) 
{ 
  int x ;
  int y ;
  int x0 ;
  int x1 ;
  int y0 ;
  int y1 ;

  {
  {
  {
#line 313
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 314
  x = x0;
  }
  {
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 314
    if (! (x <= x1)) {
#line 314
      goto while_break;
    }
#line 315
    y = y0;
    {
    {
#line 315
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (y <= y1)) {
#line 315
        goto while_break___0;
      }
#line 316
      *(*((*(_doc->layers + _lyr))->cells + x) + y) = (Cell )BLANK_CELL;
#line 315
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 321 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void tint_sel___1(_Bool fg ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int x ;
  int y ;

  {
  {
  {
#line 323
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 325
  x = x0;
  }
  {
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 325
    if (! (x <= x1)) {
#line 325
      goto while_break;
    }
#line 326
    y = y0;
    {
    {
#line 326
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (y <= y1)) {
#line 326
        goto while_break___0;
      }
#line 327
      if (fg) {
#line 328
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )((_fg << 4) | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 15));
      } else {
#line 331
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )(_bg | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 240));
      }
#line 326
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 337 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static int lgmode_map_ch___1(int ch ) 
{ 


  {
  {
#line 339
  if (ch == 55) {
#line 339
    goto case_55;
  }
#line 340
  if (ch == 56) {
#line 340
    goto case_56;
  }
#line 341
  if (ch == 57) {
#line 341
    goto case_57;
  }
#line 342
  if (ch == 52) {
#line 342
    goto case_52;
  }
#line 343
  if (ch == 53) {
#line 343
    goto case_53;
  }
#line 344
  if (ch == 54) {
#line 344
    goto case_54;
  }
#line 345
  if (ch == 49) {
#line 345
    goto case_49;
  }
#line 346
  if (ch == 50) {
#line 346
    goto case_50;
  }
#line 347
  if (ch == 51) {
#line 347
    goto case_51;
  }
#line 348
  if (ch == 45) {
#line 348
    goto case_45;
  }
#line 349
  if (ch == 124) {
#line 349
    goto case_124;
  }
#line 350
  if (ch == 48) {
#line 350
    goto case_48;
  }
#line 351
  goto switch_default;
  case_55: /* CIL Label */ 
#line 339
  return (3);
  case_56: /* CIL Label */ 
#line 340
  return (4);
  case_57: /* CIL Label */ 
#line 341
  return (5);
  case_52: /* CIL Label */ 
#line 342
  return (6);
  case_53: /* CIL Label */ 
#line 343
  return (7);
  case_54: /* CIL Label */ 
#line 344
  return (8);
  case_49: /* CIL Label */ 
#line 345
  return (9);
  case_50: /* CIL Label */ 
#line 346
  return (10);
  case_51: /* CIL Label */ 
#line 347
  return (11);
  case_45: /* CIL Label */ 
#line 348
  return (1);
  case_124: /* CIL Label */ 
#line 349
  return (2);
  case_48: /* CIL Label */ 
#line 350
  return (12);
  switch_default: /* CIL Label */ 
#line 351
  return (ch);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 356 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_select_handle_key___1(int ch ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int tmp ;

  {
  {
  {
#line 359
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
  }
  {
#line 363
  if (ch == 109) {
#line 363
    goto case_109;
  }
#line 369
  if (ch == 99) {
#line 369
    goto case_99;
  }
#line 374
  if (ch == 101) {
#line 374
    goto case_101;
  }
#line 378
  if (ch == 102) {
#line 378
    goto case_102;
  }
#line 381
  if (ch == 98) {
#line 381
    goto case_98;
  }
#line 384
  if (ch == 111) {
#line 384
    goto case_111;
  }
#line 362
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 364
  _selmode = 2;
  {
#line 365
  copy_sel_to_clipboard();
  }
  {
#line 366
  erase_sel___1();
  }
#line 367
  _x = x0;
#line 367
  _y = y0;
  }
#line 368
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 370
  _selmode = 2;
  {
#line 371
  copy_sel_to_clipboard();
  }
#line 372
  _x = x0;
#line 372
  _y = y0;
  }
#line 373
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 375
  _selmode = 0;
  {
#line 376
  erase_sel___1();
  }
  }
#line 377
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 379
  tint_sel___1((_Bool)1);
  }
  }
#line 380
  goto switch_break;
  case_98: /* CIL Label */ 
  {
  {
#line 382
  tint_sel___1((_Bool)0);
  }
  }
#line 383
  goto switch_break;
  case_111: /* CIL Label */ 
#line 388
  tmp = _x;
#line 388
  _x = _ax;
#line 388
  _ax = tmp;
#line 389
  tmp = _y;
#line 389
  _y = _ay;
#line 389
  _ay = tmp;
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 395 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_float_handle_key___1(int ch ) 
{ 


  {
  {
#line 397
  if (ch == 115) {
#line 397
    goto case_115;
  }
#line 400
  if (ch == 88) {
#line 400
    goto case_88;
  }
#line 400
  if (ch == 120) {
#line 400
    goto case_88;
  }
#line 403
  if (ch == 89) {
#line 403
    goto case_89;
  }
#line 403
  if (ch == 121) {
#line 403
    goto case_89;
  }
#line 406
  if (ch == 84) {
#line 406
    goto case_84;
  }
#line 406
  if (ch == 116) {
#line 406
    goto case_84;
  }
#line 396
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  {
#line 398
  paste_clipboard();
  }
  }
#line 399
  goto switch_break;
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  {
  {
#line 401
  layer_flip_x(_clipboard, (_Bool )(ch == 120));
  }
  }
#line 402
  goto switch_break;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
  {
#line 404
  layer_flip_y(_clipboard, (_Bool )(ch == 121));
  }
  }
#line 405
  goto switch_break;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 407
  _clipboard->transp = (_Bool )(! _clipboard->transp);
#line 408
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 433 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void correct_coords___1(void) 
{ 
  Layer *lyr___0 ;
  int scr_width ;
  int tmp ;
  int scr_height ;
  int tmp___0 ;

  {
  {
  {
#line 435
  tmp = kurses_width();
  }
#line 435
  scr_width = tmp;
  {
#line 436
  tmp___0 = kurses_height();
  }
#line 436
  scr_height = tmp___0;
  }
#line 438
  if (! _doc->layer_count) {
#line 438
    return;
  }
#line 439
  lyr___0 = *(_doc->layers + _lyr);
#line 442
  if (_x < 0) {
#line 442
    _x = 0;
  }
#line 443
  if (_x >= lyr___0->width) {
#line 443
    _x = lyr___0->width - 1;
  }
#line 444
  if (_y < 0) {
#line 444
    _y = 0;
  }
#line 445
  if (_y >= lyr___0->height) {
#line 445
    _y = lyr___0->height - 1;
  }
#line 448
  if (_x >= _svx + scr_width) {
#line 448
    _svx = (_x - scr_width) + 1;
  } else
#line 449
  if (_x < _svx) {
#line 449
    _svx = _x;
  }
#line 450
  if (_y >= (_svy + scr_height) - 1) {
#line 450
    _svy = (_y - scr_height) + 2;
  } else
#line 451
  if (_y < _svy) {
#line 451
    _svy = _y;
  }
#line 452
  return;
}
}
#line 190 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
static int _compar___1(void const   *p1 , void const   *p2 ) 
{ 
  char const   **a ;
  char const   **b ;
  int tmp ;

  {
  {
#line 191
  a = (char const   **)p1;
#line 192
  b = (char const   **)p2;
  {
#line 193
  tmp = strcmp(*a, *b);
  }
  }
#line 193
  return (tmp);
}
}
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.c"
static int *cmdforkey___1  ;
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/helpdlg.c"
static char *helptext___1[2]  = {      (char *)"\001Legend\002\n^ means the Ctrl key and % means\nthe Alt key. Thus, ^A means \nCtrl+A and %A means Alt-A.\n\n\001General keys\002\n^X,^Z  fast horizontal movement\n^O     open a file\n^S     save file\n\n\001Layers\002\n^W     go to next layer\n^Q     go to previous layer\n^L     bring up Layer Manager\n^A     add layer (defaults)\n%A     add layer (specify)\n^D     add copy of current layer\n^R     rename this layer\n%R     resize this layer\n\n\001Selection\002\n%S     enter select mode.\n",      (char *)"\001Colors\002\nTAB    bring up color dialog\n%P     pick color from cell\n       under the cursor\n%Z     apply color to cell\n       under the cursor\n\n\001Mode toggles\002\nINS    toggle insert mode\n^G     toggle line-drawing mode\n       (0-9,|,- will draw lines)\n^P     toggle composite view\n\n\001Others\002\n^E     edit document metainfo\n^C     quit program\nF1-Fn  show menu\n\n*************************************\nCopyright (c) 2003 by\nBruno T. C. de Oliveira\nAll rights reserved."};
#line 1 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static Menu menu___3[4]  = {      {"[F1] File", 1, 0, 0, 7, {{(char )'N', "&New", 35, "Clears everything and starts from scratch"},
                                {(char )'L', "&Load...", 8, "Loads a file into the editor"},
                                {(char )'S', "&Save", 9, "Saves the current drawing"},
                                {(char )'A', "Save &As...", 10, "Saves the current drawing in a specified file"},
                                {(char )'M', "Edit &Meta...", 11, "Opens an editor for you to edit this document\'s metadata"},
                                {(char )' ', "", 0, (char const   *)((void *)0)},
                                {(char )'Q', "&Quit", 34, "Quits program"}}}, 
        {"[F2] Edit", 16, 0, 0, 8, {{(char )'C', "Drawing &color...", 5, "Brings up the color selection dialog"},
                                 {(char )'I', "Toggle &Insert", 6, "Toggles insert/overwrite mode"},
                                 {(char )'K', "Pic&k color", 23, "Picks color under cursor to use as current color"},
                                 {(char )'T', "&Tint cell", 24, "Applies current color to cell under cursor"},
                                 {(char )' ', "", 0, (char const   *)((void *)0)},
                                 {(char )'S', "Toggle &select mode", 25, "Toggles select mode on/off"},
                                 {(char )'L', "Toggle &line-drawing", 32, "Toggles line-drawing mode on/off. Use 0-9 to draw lines"},
                                 {(char )'P', "Toggle com&posite", 33, "Toggles composite (all-layer) view on/off"}}}, 
        {"[F3] Layer",
      32, 0, 0, 9, {{(char )'A', "&Add layer (defaults)", 1, "Adds a layer with default parameters"},
                    {(char )'L', "Add &layer (specify)...", 2, "Adds a layer with custom parameters"},
                    {(char )'D', "&Duplicate layer", 30, "Duplicates current layer. Copy is added to the bottom of the stack."},
                    {(char )'R', "&Rename layer...", 31, "Renames the current layer"},
                    {(char )'Z', "Resi&ze layer...", 37, "Resizes the current layer"},
                    {(char )'M', "&Manage layers...", 27, "Shows a dialog in which you can manipulate layers"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'N',
                                                                       "Go to &next layer",
                                                                       28, "Goes to the next layer"},
                    {(char )'P', "Go to &previous layer", 29, "Goes to the previous layer"}}}, 
        {"[F4] Help",
      64, 0, 0, 3, {{(char )'K', "&Key reference", 7, "Shows a table of keys and their functions"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'A',
                                                                       "&About Aewan",
                                                                       36, "Shows information about the program"}}}};
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static int menu_count___1  =    4;
#line 78 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int open_menu___1  ;
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int menu_sel___1  ;
#line 83
static void menubar_paint___1(void) ;
#line 84
static void menuitem_print___1(char const   *s , _Bool sel , int minlen ) ;
#line 85
static void menu_calc_dims___1(Menu *m ) ;
#line 86
static _Bool chr_icomp___1(char c1 , char c2 ) ;
#line 151 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static _Bool chr_icomp___1(char c1 , char c2 ) 
{ 


  {
#line 152
  if ((int )c1 >= 65) {
#line 152
    if ((int )c1 <= 90) {
#line 152
      c1 = (char )(((int )c1 - 65) + 97);
    } else {
#line 152
      c1 = c1;
    }
  } else {
#line 152
    c1 = c1;
  }
#line 153
  if ((int )c2 >= 65) {
#line 153
    if ((int )c2 <= 90) {
#line 153
      c2 = (char )(((int )c2 - 65) + 97);
    } else {
#line 153
      c2 = c2;
    }
  } else {
#line 153
    c2 = c2;
  }
#line 154
  return ((_Bool )((int )c1 == (int )c2));
}
}
#line 157 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menubar_paint___1(void) 
{ 
  int i ;
  Menu *omenu ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 160
  restore_screen();
  }
  {
#line 162
  kurses_color_at(7);
  }
  {
#line 163
  tmp = kurses_width();
  }
  {
#line 163
  draw_hline(0, 0, tmp, ' ', ' ', ' ');
  }
#line 165
  i = 0;
  }
  {
  {
#line 165
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < menu_count___1)) {
#line 165
      goto while_break;
    }
    {
    {
#line 166
    kurses_move(menu___3[i].startcol, 0);
    }
    {
#line 167
    menuitem_print___1(menu___3[i].caption, (_Bool )(i == open_menu___1), -1);
    }
#line 165
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  omenu = & menu___3[open_menu___1];
#line 173
  if (! omenu->menu_h) {
    {
    {
#line 173
    menu_calc_dims___1(omenu);
    }
    }
  }
  {
  {
#line 176
  kurses_color_at(7);
  }
  {
#line 177
  draw_window(omenu->startcol, 1, omenu->menu_w + 2, omenu->menu_h + 2, "");
  }
#line 178
  i = 0;
  }
  {
  {
#line 178
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < omenu->item_count)) {
#line 178
      goto while_break___0;
    }
    {
    {
#line 179
    kurses_move(omenu->startcol + 1, i + 2);
    }
    {
#line 180
    menuitem_print___1(omenu->item[i].caption, (_Bool )(i == menu_sel___1), omenu->menu_w);
    }
#line 178
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 184
  tmp___0 = kurses_height();
  }
  {
#line 184
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 185
  kurses_color_at(7);
  }
  {
#line 186
  tmp___1 = strlen(omenu->item[menu_sel___1].desc);
  }
#line 186
  i = (int )tmp___1;
  {
#line 187
  waddnstr(stdscr, omenu->item[menu_sel___1].desc, -1);
  }
  }
  {
  {
#line 188
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
#line 188
    tmp___2 = i;
#line 188
    i ++;
    {
#line 188
    tmp___3 = kurses_width();
    }
    }
#line 188
    if (! (tmp___2 < tmp___3)) {
#line 188
      goto while_break___1;
    }
    {
    {
#line 188
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 190
  tmp___4 = kurses_height();
  }
  {
#line 190
  tmp___5 = kurses_width();
  }
  {
#line 190
  kurses_move(tmp___5 - 1, tmp___4 - 1);
  }
  {
#line 191
  wrefresh(stdscr);
  }
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menuitem_print___1(char const   *s , _Bool sel , int minlen ) 
{ 
  _Bool next_is_accel ;
  int printed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 195
  next_is_accel = (_Bool)0;
#line 196
  printed = 0;
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (! *s) {
#line 197
      if (! (printed < minlen)) {
#line 197
        goto while_break;
      }
    }
#line 198
    if ((int const   )*s == 38) {
#line 199
      next_is_accel = (_Bool)1;
#line 200
      s ++;
#line 201
      goto while_continue;
    }
#line 204
    if (sel) {
#line 204
      if (next_is_accel) {
#line 204
        tmp = 225;
      } else {
#line 204
        tmp = 241;
      }
#line 204
      tmp___1 = tmp;
    } else {
#line 204
      if (next_is_accel) {
#line 204
        tmp___0 = 23;
      } else {
#line 204
        tmp___0 = 7;
      }
#line 204
      tmp___1 = tmp___0;
    }
    {
    {
#line 204
    kurses_color_at(tmp___1);
    }
    }
#line 208
    if (*s) {
#line 208
      tmp___2 = (int const   )*s;
    } else {
#line 208
      tmp___2 = (int const   )' ';
    }
    {
    {
#line 208
    waddch(stdscr, (chtype const   )tmp___2);
    }
#line 209
    printed ++;
#line 211
    next_is_accel = (_Bool)0;
    }
#line 212
    if (*s) {
#line 212
      s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menu_calc_dims___1(Menu *m ) 
{ 
  int i ;
  int width___0 ;
  int len ;
  size_t tmp ;

  {
#line 218
  width___0 = 1;
#line 218
  len = 0;
#line 220
  i = 0;
  {
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < m->item_count)) {
#line 220
      goto while_break;
    }
    {
    {
#line 221
    tmp = strlen(m->item[i].caption);
    }
#line 221
    len = (int )tmp;
    }
#line 222
    if (len > width___0) {
#line 222
      width___0 = len;
    }
#line 220
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  m->menu_h = m->item_count;
#line 226
  m->menu_w = width___0;
#line 227
  return;
}
}
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/colordlg.c"
static void paint_dlg___3(void) 
{ 
  int x0 ;
  int y0 ;
  int i ;
  int j ;
  char hexdigit___3[17] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 42
  hexdigit___3[0] = (char )'0';
#line 42
  hexdigit___3[1] = (char )'1';
#line 42
  hexdigit___3[2] = (char )'2';
#line 42
  hexdigit___3[3] = (char )'3';
#line 42
  hexdigit___3[4] = (char )'4';
#line 42
  hexdigit___3[5] = (char )'5';
#line 42
  hexdigit___3[6] = (char )'6';
#line 42
  hexdigit___3[7] = (char )'7';
#line 42
  hexdigit___3[8] = (char )'8';
#line 42
  hexdigit___3[9] = (char )'9';
#line 42
  hexdigit___3[10] = (char )'a';
#line 42
  hexdigit___3[11] = (char )'b';
#line 42
  hexdigit___3[12] = (char )'c';
#line 42
  hexdigit___3[13] = (char )'d';
#line 42
  hexdigit___3[14] = (char )'e';
#line 42
  hexdigit___3[15] = (char )'f';
#line 42
  hexdigit___3[16] = (char )'\000';
  {
#line 44
  kurses_color(7, 0);
  }
  {
#line 45
  draw_centered_window(39, 21, "Choose Color", & x0, & y0);
  }
  {
#line 48
  kurses_color(12, 0);
  }
  {
#line 49
  kurses_move((x0 + 4) + 2 * _bg, y0);
  }
  {
#line 50
  waddch(stdscr, (chtype const   )'b');
  }
  {
#line 53
  kurses_color(10, 0);
  }
  {
#line 54
  kurses_move(x0, (y0 + 2) + _fg);
  }
  {
#line 55
  waddch(stdscr, (chtype const   )'f');
  }
  {
#line 58
  kurses_color(7, 0);
  }
  {
#line 59
  kurses_move(x0 + 4, y0 + 1);
  }
  {
#line 60
  waddnstr(stdscr, "0 1 2 3 4 5 6 7 8 9 a b c d e f", -1);
  }
#line 63
  i = 0;
  }
  {
  {
#line 63
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 16)) {
#line 63
      goto while_break;
    }
    {
    {
#line 64
    kurses_move(x0 + 2, (y0 + 2) + i);
    }
    {
#line 65
    waddch(stdscr, (chtype const   )hexdigit___3[i]);
    }
#line 63
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  i = 0;
  {
  {
#line 69
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 16)) {
#line 69
      goto while_break___0;
    }
    {
    {
#line 70
    kurses_move(x0 + 4, (y0 + 2) + i);
    }
#line 71
    j = 0;
    }
    {
    {
#line 71
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! (j < 16)) {
#line 71
        goto while_break___1;
      }
      {
      {
#line 72
      kurses_color(i, j);
      }
      {
#line 73
      waddnstr(stdscr, "Aa", -1);
      }
#line 71
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 69
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 78
  kurses_move((x0 + 4) + 2 * _bg, (y0 + 2) + _fg);
  }
  }
#line 79
  return;
}
}
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_fld___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *cancel_btn___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *ok_btn___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_lbl___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *dirs_box___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *files_box___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_stlbl___1  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_stlbl___1  ;
#line 99 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlForm *form___1  ;
#line 101 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *curdir___1  =    (char *)((void *)0);
#line 107
static void _update_widgets___1(void) ;
#line 109 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static _Bool _is_dir_valid___1(char const   *dir ) 
{ 
  DIR *d ;
  DIR *tmp ;

  {
  {
  {
#line 110
  tmp = opendir(dir);
  }
#line 110
  d = tmp;
  }
#line 111
  if (d) {
    {
    {
#line 112
    closedir(d);
    }
    }
#line 113
    return ((_Bool)1);
  }
#line 116
  return ((_Bool)0);
}
}
#line 119 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *my_getcwd___1(void) 
{ 
  int cap ;
  char *s ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 121
  cap = 32;
  {
#line 121
  tmp = malloc((size_t )cap);
  }
#line 121
  s = (char *)tmp;
  }
  {
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 123
    tmp___2 = getcwd(s, (size_t )cap);
    }
    }
#line 123
    if (tmp___2) {
#line 123
      goto while_break;
    }
    {
    {
#line 124
    tmp___0 = __errno_location();
    }
    }
#line 124
    if (*tmp___0 != 34) {
#line 124
      return ((char *)((void *)0));
    }
    {
#line 125
    cap += cap;
    {
#line 125
    tmp___1 = malloc((size_t )cap);
    }
#line 125
    s = (char *)tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (s);
}
}
#line 131 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *_get_canon_dir_path___1(char const   *base , char const   *relative ) 
{ 
  char *oldpwd ;
  char *tmp ;
  char *retval ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 133
  tmp = my_getcwd___1();
  }
#line 133
  oldpwd = tmp;
  }
#line 136
  if (! oldpwd) {
#line 136
    return ((char *)((void *)0));
  }
  {
  {
#line 138
  tmp___0 = chdir(base);
  }
  }
#line 138
  if (0 != tmp___0) {
#line 138
    return ((char *)((void *)0));
  }
  {
  {
#line 139
  tmp___1 = chdir(relative);
  }
  }
#line 139
  if (0 != tmp___1) {
#line 139
    return ((char *)((void *)0));
  }
  {
  {
#line 141
  retval = my_getcwd___1();
  }
  {
#line 143
  tmp___4 = chdir((char const   *)oldpwd);
  }
  }
#line 143
  if (0 != tmp___4) {
    {
    {
#line 144
    tmp___2 = __errno_location();
    }
    {
#line 144
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PANIC: Can\'t go back to old wd \'%s\'\n%s\n",
            oldpwd, tmp___3);
    }
    {
#line 146
    abort();
    }
    }
  }
#line 149
  return (retval);
}
}
#line 283 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static void _update_widgets___1(void) 
{ 
  DIR *d ;
  struct dirent *dent ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *compname ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 288
  d = opendir((char const   *)curdir___1);
  }
  }
#line 290
  if (! d) {
    {
    {
#line 291
    tmp = __errno_location();
    }
    {
#line 291
    tmp___0 = strerror(*tmp);
    }
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR in opendir(\"%s\"): %s\n",
            curdir___1, tmp___0);
    }
    {
#line 293
    abort();
    }
    }
  }
  {
  {
#line 296
  aewl_listbox_clear((AewlListBox *)dirs_box___1);
  }
  {
#line 297
  aewl_listbox_clear((AewlListBox *)files_box___1);
  }
  }
  {
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 298
    dent = readdir(d);
    }
    }
#line 298
    if (! dent) {
#line 298
      goto while_break;
    }
    {
    {
#line 299
    tmp___1 = strlen((char const   *)(dent->d_name));
    }
    {
#line 299
    tmp___2 = strlen((char const   *)curdir___1);
    }
    {
#line 299
    tmp___3 = zalloc((int )((tmp___1 + tmp___2) + 2U));
    }
#line 299
    compname = (char *)tmp___3;
    {
#line 300
    sprintf((char */* __restrict  */)compname, (char const   */* __restrict  */)"%s/%s",
            curdir___1, dent->d_name);
    }
    {
#line 302
    tmp___4 = stat((char const   */* __restrict  */)compname, (struct stat */* __restrict  */)(& st));
    }
    }
#line 302
    if (0 != tmp___4) {
#line 302
      goto while_continue;
    }
    {
    {
#line 304
    free((void *)compname);
    }
    }
#line 306
    if ((st.st_mode & 61440U) == 16384U) {
      {
      {
#line 307
      aewl_listbox_add((AewlListBox *)dirs_box___1, (char const   *)(dent->d_name));
      }
      }
    } else {
      {
      {
#line 309
      aewl_listbox_add((AewlListBox *)files_box___1, (char const   *)(dent->d_name));
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 311
  aewl_listbox_sort((AewlListBox *)dirs_box___1);
  }
  {
#line 312
  aewl_listbox_sort((AewlListBox *)files_box___1);
  }
  {
#line 314
  closedir(d);
  }
  {
#line 317
  aewl_label_set_text((AewlLabel *)directory_lbl___1, (char const   *)curdir___1);
  }
  }
#line 318
  return;
}
}
#line 5 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_LYR___1(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Layer *l ;

  {
#line 6
  l = (Layer *)ud;
#line 7
  *r_cell = *(*(l->cells + x) + y);
#line 8
  return;
}
}
#line 11 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_COMPOSITE___1(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Document *doc___0 ;

  {
  {
#line 12
  doc___0 = doc___0;
  {
#line 13
  *r_cell = document_calc_effective_cell(doc___0, x, y);
  }
  }
#line 14
  return;
}
}
#line 43 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static char *logo___1[6]  = {      (char *)"79         ",      (char *)"||         ",      (char *)"46799 97979",      (char *)"||43|||||||", 
        (char *)"311-1231231",      (char *)((void *)0)};
#line 52 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static int logo_colors___1[5]  = {      4,      6,      7,      6, 
        4};
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare_ex___0(int fg , int bg ) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 46
  tmp = kurses_width();
  }
#line 46
  w = tmp;
  {
#line 47
  tmp___0 = kurses_height();
  }
  {
#line 47
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 48
  kurses_color(fg, bg);
  }
  }
  {
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 49
    tmp___1 = w;
#line 49
    w --;
#line 49
    if (! tmp___1) {
#line 49
      goto while_break;
    }
    {
    {
#line 49
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 50
  tmp___2 = kurses_height();
  }
  {
#line 50
  kurses_move(0, tmp___2 - 1);
  }
#line 51
  ui_cancel = 0;
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare___0(void) 
{ 


  {
  {
  {
#line 55
  ui_prepare_ex___0(15, 4);
  }
  }
#line 56
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___5[32]  ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___6[256]  ;
#line 91 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char hexdigit___0[17]  = 
#line 91
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static AbsMenu *menu___4  =    (AbsMenu *)0;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void painter___1(int i , AbsMenu *m ) 
{ 
  Layer *l ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 64
  l = *(_doc->layers + i);
#line 65
  if (l->name) {
#line 65
    tmp = (char const   *)l->name;
  } else {
#line 65
    tmp = "(untitled)";
  }
#line 65
  if (l->transp) {
#line 65
    tmp___0 = 't';
  } else {
#line 65
    tmp___0 = ' ';
  }
#line 65
  if (l->visible) {
#line 65
    tmp___1 = 'v';
  } else {
#line 65
    tmp___1 = ' ';
  }
  {
  {
#line 65
  printw("%2d: %c%c (%3d x %3d) %s", i, tmp___1, tmp___0, l->width, l->height, tmp);
  }
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void paint_dlg___4(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 74
  kurses_color(7, 0);
  }
  {
#line 75
  draw_centered_window(42, 19, "Layer Manager", & x0, & y0);
  }
  }
#line 77
  if (! menu___4) {
    {
    {
#line 78
    menu___4 = menu_create(& _doc->layer_count, x0, y0, 40, 11, 113, 112, & painter___1);
    }
    {
#line 81
    menu_select_item(menu___4, _lyr);
    }
    }
  }
  {
  {
#line 84
  draw_hline(x0 - 1, y0 + 11, 42, (int )acs_map[(unsigned char )'t'], (int )acs_map[(unsigned char )'q'],
             (int )acs_map[(unsigned char )'u']);
  }
#line 87
  y = (y0 + 11) + 1;
#line 87
  x = x0 + 1;
  {
#line 87
  kurses_move(x, y);
  }
  {
#line 89
  kurses_color(2, 0);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )'<');
  }
  {
#line 89
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )' ');
  }
  {
#line 90
  kurses_color(7, 0);
  }
  {
#line 91
  printw(": go to layer");
  }
#line 93
  y ++;
  {
#line 93
  kurses_move(x, y);
  }
  {
#line 94
  kurses_color(2, 0);
  }
  {
#line 94
  waddnstr(stdscr, "d  ", -1);
  }
  {
#line 94
  kurses_color(7, 0);
  }
  {
#line 95
  printw(": delete layer");
  }
#line 97
  y ++;
  {
#line 97
  kurses_move(x, y);
  }
  {
#line 98
  kurses_color(2, 0);
  }
  {
#line 98
  waddnstr(stdscr, "+/-", -1);
  }
  {
#line 98
  kurses_color(7, 0);
  }
  {
#line 99
  printw(": move layer up/down");
  }
#line 101
  y ++;
  {
#line 101
  kurses_move(x, y);
  }
  {
#line 102
  kurses_color(2, 0);
  }
  {
#line 102
  waddnstr(stdscr, "v  ", -1);
  }
  {
#line 102
  kurses_color(7, 0);
  }
  {
#line 103
  printw(": toggle visibility");
  }
#line 105
  y ++;
  {
#line 105
  kurses_move(x, y);
  }
  {
#line 106
  kurses_color(2, 0);
  }
  {
#line 106
  waddnstr(stdscr, "t  ", -1);
  }
  {
#line 106
  kurses_color(7, 0);
  }
  {
#line 107
  printw(": toggle transparency");
  }
  {
#line 109
  menu_paint(menu___4);
  }
  }
#line 110
  return;
}
}
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap___1(AewlField *f___0 , int cap ) ;
#line 45
static void buf_insert_char___1(char *buf___15 , int cap , int pos , int ch ) ;
#line 46
static void buf_del_char___1(char *buf___15 , int cap , int pos , int ch ) ;
#line 160 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap___1(AewlField *f___0 , int cap ) 
{ 
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 161
  if (f___0->cap >= cap) {
#line 161
    return;
  }
  {
#line 163
  tmp___0 = cap + 20;
#line 163
  f___0->cap = tmp___0;
  {
#line 163
  tmp___1 = realloc((void *)f___0->buffer, (size_t )tmp___0);
  }
#line 163
  tmp = (char *)tmp___1;
#line 163
  f___0->buffer = tmp;
  }
#line 163
  if (! tmp) {
    {
    {
#line 164
    abort();
    }
    }
  }
#line 165
  return;
}
}
#line 167 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_insert_char___1(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 171
  i = cap - 1;
  {
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i > pos)) {
#line 171
      goto while_break;
    }
#line 171
    *(buf___15 + i) = *(buf___15 + (i - 1));
#line 171
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  *(buf___15 + pos) = (char )ch;
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_del_char___1(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 177
  i = pos;
  {
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < cap - 1)) {
#line 177
      goto while_break;
    }
#line 177
    *(buf___15 + i) = *(buf___15 + (i + 1));
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 162 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char tbl_lookup___1(char **table , int ch ) 
{ 
  char const   *s ;
  char const   *p ;
  char const   *tmp ;

  {
#line 163
  s = (char const   *)*(table + 0);
#line 163
  p = (char const   *)*(table + 1);
  {
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 164
    if (! *s) {
#line 164
      goto while_break;
    }
#line 165
    tmp = s;
#line 165
    s ++;
#line 165
    if ((int const   )*tmp == (int const   )ch) {
#line 165
      return ((char )*p);
    }
#line 166
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return ((char )ch);
}
}
#line 174 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___3[2]  = {      (char *)"`\'()/\\<>[]{}\003\005\006\b\t\v",      (char *)"\'`)(\\/><][}{\005\003\b\006\v\t"};
#line 195 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___4[2]  = {      (char *)"/\\\003\t\004\n\005\v",      (char *)"\\/\t\003\n\004\v\005"};
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static char hs___1[17]  = 
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 260 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static int hex_digit_val___1(char c ) 
{ 


  {
#line 261
  if ((int )c >= 48) {
#line 261
    if ((int )c <= 57) {
#line 261
      return ((int )c - 48);
    } else {
#line 261
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 262
  if ((int )c >= 97) {
#line 262
    if ((int )c <= 102) {
#line 262
      return (((int )c - 97) + 10);
    } else {
#line 262
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 263
  if ((int )c >= 65) {
#line 263
    if ((int )c <= 70) {
#line 263
      return (((int )c - 65) + 10);
    } else {
#line 264
      return (0);
    }
  } else {
#line 264
    return (0);
  }
}
}
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/init_aewl.c"
static int curses_attr_for_pair___1(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 39
  cp = (short )((bg * 8 + 7) - fg);
#line 40
  if (! cp) {
#line 40
    if (bold) {
#line 40
      tmp = 1UL << 21;
    } else {
#line 40
      tmp = 0UL;
    }
#line 40
    return ((int )tmp);
  }
#line 41
  if (bold) {
#line 41
    tmp___0 = 1UL << 21;
  } else {
#line 41
    tmp___0 = 0UL;
  }
#line 41
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 120 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
static char buf___7[2]  ;
#line 16 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.c"
static int curses_attr_for_pair___2(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 17
  cp = (short )((bg * 8 + 7) - fg);
#line 18
  if (! cp) {
#line 18
    if (bold) {
#line 18
      tmp = 1UL << 21;
    } else {
#line 18
      tmp = 0UL;
    }
#line 18
    return ((int )tmp);
  }
#line 19
  if (bold) {
#line 19
    tmp___0 = 1UL << 21;
  } else {
#line 19
    tmp___0 = 0UL;
  }
#line 19
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
static void menu_correct___1(AbsMenu *m ) 
{ 


  {
  {
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 89
    if (! (m->sel_item < 0)) {
#line 89
      goto while_break;
    }
#line 89
    m->sel_item = 0;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (m->sel_item >= *(m->item_count))) {
#line 90
      goto while_break___0;
    }
#line 90
    m->sel_item = -1 + *(m->item_count);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  if (m->item_at_top > m->sel_item) {
#line 95
    m->item_at_top = m->sel_item;
  } else
#line 96
  if (m->sel_item >= m->item_at_top + m->h) {
#line 97
    m->item_at_top = (m->sel_item - m->h) + 1;
  }
#line 98
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node___1(HashDict *hd , Node *n ) ;
#line 58
static int _which_bucket___1(char const   *key , int bucketcount ) ;
#line 59
static Node *_node_lookup___1(HashDict *hd , char const   *key ) ;
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static Node *_node_lookup___1(HashDict *hd , char const   *key ) 
{ 
  Node *n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 196
  tmp = _which_bucket___1(key, hd->bucketcount);
  }
#line 196
  n = hd->bucketheads + tmp;
  }
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (n->next) {
      {
      {
#line 197
      tmp___0 = strcmp((char const   *)(n->next)->key, key);
      }
      }
#line 197
      if (! tmp___0) {
#line 197
        goto while_break;
      }
    } else {
#line 197
      goto while_break;
    }
#line 197
    n = n->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (n);
}
}
#line 201 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node___1(HashDict *hd , Node *n ) 
{ 


  {
#line 202
  if (n) {
#line 203
    if (hd->value_destroyer) {
#line 203
      if (n->value) {
        {
        {
#line 204
        (*(hd->value_destroyer))((void *)n->value);
        }
        }
      }
    }
    {
    {
#line 205
    zfree(& n->key);
    }
    {
#line 206
    free((void *)n);
    }
    }
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static int _which_bucket___1(char const   *key , int bucketcount ) 
{ 
  int x ;
  char const   *tmp ;

  {
#line 218
  x = 0;
  {
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 219
    if (! *key) {
#line 219
      goto while_break;
    }
#line 219
    tmp = key;
#line 219
    key ++;
#line 219
    x += (int )*tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (x % bucketcount);
}
}
#line 139 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewan.c"
static char *msg___0  =    (char *)"[Document contains no layers; press F1 for menu]";
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_fg___1  ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_bg___1  ;
#line 64
static int kurses_pair_for___1(int fg , int bg ) ;
#line 287 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int kurses_pair_for___1(int fg , int bg ) 
{ 


  {
#line 288
  fg &= 7;
#line 288
  bg &= 7;
#line 289
  return ((bg << 3) + (7 - fg));
}
}
#line 80 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool read_parse_data_line___2(gzFile f___0 , char **label , char **type ,
                                      char **value ) 
{ 
  char *field_start[3] ;
  char *line ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  char const   *r ;
  char *w ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 88
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 89
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 91
  tmp = freadline_ex(f___0, & gzgetc);
  }
  {
#line 91
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
#line 94
  field_start[0] = line;
  {
#line 95
  field_start[1] = strchr((char const   *)line, ':');
  }
  }
#line 95
  if (field_start[1]) {
    {
    {
#line 95
    field_start[2] = strchr((char const   *)(field_start[1] + 1), ':');
    }
    }
#line 95
    if (! field_start[2]) {
      {
      {
#line 98
      dstrset(& err_string, "There\'s a data line with <3 fields.");
      }
      {
#line 99
      do_autod_cleanup(& autodregistry_head, (void *)0);
      }
      }
#line 99
      return ((_Bool)0);
    }
  } else {
    {
    {
#line 98
    dstrset(& err_string, "There\'s a data line with <3 fields.");
    }
    {
#line 99
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 99
    return ((_Bool)0);
  }
#line 105
  *(field_start[1]) = (char)0;
#line 105
  field_start[1] += 2;
#line 106
  *(field_start[2]) = (char)0;
#line 106
  field_start[2] += 2;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! ((int )*(field_start[0]) == 32)) {
#line 110
      if (! ((int )*(field_start[0]) == 9)) {
#line 110
        goto while_break;
      }
    }
#line 111
    (field_start[0]) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((unsigned long )field_start[0] >= (unsigned long )field_start[1]) {
    {
    {
#line 115
    dstrset(& err_string, "There\'s a data line with an empty label");
    }
    {
#line 116
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 116
    return ((_Bool)0);
  }
#line 120
  if (label) {
    {
    {
#line 120
    *label = sstrdup((char const   *)field_start[0]);
    }
    }
  }
#line 121
  if (type) {
    {
    {
#line 121
    *type = sstrdup((char const   *)field_start[1]);
    }
    }
  }
#line 122
  if (value) {
    {
    {
#line 122
    *value = sstrdup((char const   *)field_start[2]);
    }
    }
  }
#line 125
  if (value) {
#line 126
    r = (char const   *)*value;
#line 127
    w = *value;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! *r) {
#line 129
        goto while_break___0;
      }
#line 130
      if ((int const   )*r == 92) {
#line 131
        r ++;
#line 131
        if ((int const   )*r == 92) {
#line 131
          *w = (char )'\\';
        } else {
#line 131
          *w = (char )((int const   )*r - 48);
        }
      } else {
#line 133
        *w = (char )*r;
      }
#line 135
      r ++;
#line 135
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 138
    *w = (char)0;
  }
  {
  {
#line 142
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 142
  return ((_Bool)1);
}
}
#line 145 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static void aeff_indent___2(AeFile *f___0 ) 
{ 
  int n ;
  int tmp ;

  {
#line 146
  n = f___0->indent_level;
  {
  {
#line 147
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 147
    tmp = n;
#line 147
    n --;
#line 147
    if (! (tmp > 0)) {
#line 147
      goto while_break;
    }
    {
    {
#line 147
    gzputc(f___0->f, '\t');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aeff.c"
static _Bool aeff_read_mark___2(AeFile *f___0 , char const   *mark_name , char pref ) 
{ 
  char *line ;
  char *s ;
  AutodRegistryNode autodregistry_head ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 190
  zfree(& err_string);
  }
#line 192
  autodregistry_head.next = (struct AutodRegistryNode_ *)0;
  {
#line 193
  do_autod_register(& autodregistry_head, (void **)(& line), & free);
  }
  {
#line 195
  tmp = freadline_ex(f___0->f, & gzgetc);
  }
  {
#line 195
  do_autod_assign(& autodregistry_head, (void **)(& line), (void *)tmp);
  }
  }
#line 198
  if (! line) {
    {
    {
#line 199
    err_string = dsprintf("EOF reading mark \'%c%s\'", (int )pref, mark_name);
    }
    {
#line 200
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 200
    return ((_Bool)0);
  }
#line 204
  s = line;
  {
  {
#line 205
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((int )*s == 32)) {
#line 205
      if (! ((int )*s == 9)) {
#line 205
        goto while_break;
      }
    }
#line 205
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 208
  tmp___0 = strcmp((char const   *)(s + 1), mark_name);
  }
  }
#line 208
  if (tmp___0) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  } else
#line 208
  if ((int )*(s + 0) != (int )pref) {
    {
    {
#line 209
    err_string = dsprintf("Mark \'%c%s\' not found.", (int )pref, mark_name);
    }
    {
#line 210
    do_autod_cleanup(& autodregistry_head, (void *)0);
    }
    }
#line 210
    return ((_Bool)0);
  }
  {
  {
#line 214
  do_autod_cleanup(& autodregistry_head, (void *)0);
  }
  }
#line 214
  return ((_Bool)1);
}
}
#line 50 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char tmpname___2[64]  ;
#line 51 "/home/wslee/benchmarks/textformat/aewan-1.0.01/editmeta.c"
static char buf___8[128]  ;
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_add_layer___2(_Bool interactive ) 
{ 
  int width___0 ;
  int height___0 ;
  int nom_width ;
  int nom_height ;
  char *name ;
  Layer *lyr___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 72
  document_get_nom_dim(_doc, & nom_width, & nom_height);
  }
  }
#line 73
  if (interactive) {
    {
    {
#line 74
    width___0 = ui_ask_i("NEW LAYER: Enter width", nom_width, 2, 2147483647);
    }
    }
#line 75
    if (ui_cancel) {
#line 75
      return;
    }
    {
    {
#line 76
    height___0 = ui_ask_i("NEW LAYER: Enter height", nom_height, 2, 2147483647);
    }
    }
#line 77
    if (ui_cancel) {
#line 77
      return;
    }
    {
    {
#line 78
    name = ui_ask_s("NEW LAYER: Name", "unnamed");
    }
    }
#line 78
    if (ui_cancel) {
#line 78
      return;
    }
  } else {
    {
#line 81
    width___0 = nom_width;
#line 82
    height___0 = nom_height;
    {
#line 83
    name = strdup("unnamed");
    }
    }
  }
  {
  {
#line 86
  lyr___0 = layer_create((char const   *)name, width___0, height___0);
  }
  }
#line 90
  if (_doc->layer_count) {
#line 90
    lyr___0->transp = (_Bool)1;
  } else {
#line 91
    lyr___0->transp = (_Bool)0;
  }
  {
  {
#line 93
  document_insert_layer(_doc, 0, lyr___0);
  }
  {
#line 95
  free((void *)name);
  }
  }
#line 96
  return;
}
}
#line 100 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_rename_layer___2(void) 
{ 
  Layer *l ;
  char *new_name ;
  char *__cil_tmp3 ;

  {
  {
#line 101
  l = *(_doc->layers + _lyr);
  {
#line 104
  new_name = ui_ask_s("Rename layer to", (char const   *)l->name);
  }
  }
#line 105
  if (! ui_cancel) {
    {
    {
#line 106
    dstrset(& l->name, (char const   *)new_name);
    }
    }
  }
#line 108
  if (new_name) {
    {
    {
#line 108
    free((void *)new_name);
    }
    }
  }
#line 109
  return;
}
}
#line 113 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_resize_layer___2(void) 
{ 
  Layer *l ;
  Layer *new_l ;
  int h ;
  int w ;
  int x ;
  int y ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 114
  l = *(_doc->layers + _lyr);
  {
#line 118
  w = ui_ask_i("RESIZE LAYER: Enter new width", l->width, 2, 2147483647);
  }
  }
#line 119
  if (ui_cancel) {
#line 119
    return;
  }
  {
  {
#line 120
  h = ui_ask_i("RESIZE LAYER: Enter new height", l->height, 2, 2147483647);
  }
  }
#line 121
  if (ui_cancel) {
#line 121
    return;
  }
  {
  {
#line 123
  new_l = layer_create((char const   *)l->name, w, h);
  }
  }
#line 125
  if (l->width > new_l->width) {
#line 125
    w = new_l->width;
  } else {
#line 125
    w = l->width;
  }
#line 126
  if (l->height > new_l->height) {
#line 126
    h = new_l->height;
  } else {
#line 126
    h = l->height;
  }
#line 128
  y = 0;
  {
  {
#line 128
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 128
    if (! (y < h)) {
#line 128
      goto while_break;
    }
#line 129
    x = 0;
    {
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 129
      if (! (x < w)) {
#line 129
        goto while_break___0;
      }
#line 130
      (*(new_l->cells + x) + y)->ch = (*(l->cells + x) + y)->ch;
#line 131
      (*(new_l->cells + x) + y)->attr = (*(l->cells + x) + y)->attr;
#line 129
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 128
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  layer_destroy(l);
  }
#line 135
  *(_doc->layers + _lyr) = new_l;
  }
#line 136
  return;
}
}
#line 140 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_dup_layer___2(void) 
{ 
  char buf___15[32] ;
  Layer *l ;
  Layer *tmp ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 143
  sprintf((char */* __restrict  */)(buf___15), (char const   */* __restrict  */)"copy of %d",
          _lyr);
  }
#line 145
  l = *(_doc->layers + _lyr);
  {
#line 146
  tmp = layer_dup((char const   *)(buf___15), l);
  }
  {
#line 146
  document_add_layer(_doc, tmp);
  }
  {
#line 147
  switch_to_layer(_doc->layer_count - 1);
  }
  }
#line 148
  return;
}
}
#line 184 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static char *expand_tilde___2(char *filename ) 
{ 
  char *home_dir ;
  char *slash ;
  char *username ;
  char *filename_dup ;
  char *ret ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 188
  if (*(filename + 1)) {
    {
    {
#line 192
    filename_dup = strdup((char const   *)filename);
    }
    {
#line 193
    slash = strchr((char const   *)filename_dup, '/');
    }
#line 194
    username = filename_dup + 1;
    }
#line 196
    if (! slash) {
      {
      {
#line 198
      free((void *)filename_dup);
      }
      }
#line 199
      return (filename);
    }
    {
#line 202
    *slash = (char )'\000';
    {
#line 204
    tmp = strlen((char const   *)username);
    }
    }
#line 204
    if (! tmp) {
#line 205
      username = (char *)((void *)0);
    }
    {
    {
#line 206
    home_dir = get_home_dir(username);
    }
    }
#line 207
    if (! home_dir) {
#line 208
      return ((char *)((void *)0));
    }
    {
#line 210
    slash ++;
    {
#line 211
    tmp___0 = strlen((char const   *)home_dir);
    }
    {
#line 211
    tmp___1 = strlen((char const   *)slash);
    }
    {
#line 211
    tmp___2 = malloc((tmp___0 + tmp___1) + 1U);
    }
#line 211
    ret = (char *)tmp___2;
    {
#line 212
    sprintf((char */* __restrict  */)ret, (char const   */* __restrict  */)"%s/%s",
            home_dir, slash);
    }
    {
#line 213
    free((void *)filename_dup);
    }
    }
#line 214
    return (ret);
  } else {
#line 217
    return (filename);
  }
}
}
#line 257 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void u_save_file___2(_Bool forceAsk ) 
{ 
  char *filename ;
  char *expanded_filename ;
  FILE *tmpf ;
  AeFile *f___0 ;
  char msg___1[128] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 260
  f___0 = (AeFile *)0;
#line 263
  if (forceAsk) {
#line 263
    goto _L;
  } else
#line 263
  if (! _filename) {
#line 263
    goto _L;
  } else {
    {
    {
#line 263
    tmp = strlen((char const   *)_filename);
    }
    }
#line 263
    if (tmp) {
      {
      {
#line 267
      filename = strdup((char const   *)_filename);
      }
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 264
      filename = filedlg_show("Save File As");
      }
      }
#line 265
      if (! filename) {
#line 265
        return;
      }
    }
  }
#line 269
  if ((int )*(filename + 0) == 126) {
    {
    {
#line 270
    expanded_filename = expand_tilde___2(filename);
    }
    }
#line 271
    if (! expanded_filename) {
#line 271
      return;
    }
#line 274
    if ((unsigned long )expanded_filename != (unsigned long )filename) {
      {
      {
#line 275
      free((void *)filename);
      }
#line 276
      filename = expanded_filename;
      }
    }
  }
#line 280
  if (_filename) {
    {
    {
#line 280
    tmp___1 = strcmp((char const   *)_filename, (char const   *)filename);
    }
    }
#line 280
    if (tmp___1) {
      {
      {
#line 280
      tmpf = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
      }
#line 280
      if (tmpf) {
        {
        {
#line 283
        fclose(tmpf);
        }
#line 283
        tmpf = (FILE *)0;
        {
#line 284
        tmp___0 = ui_ask_yn("FILE EXISTS. Overwrite?", 0);
        }
        }
#line 284
        if (tmp___0) {
#line 284
          if (ui_cancel) {
            {
            {
#line 285
            ui_message("File was NOT saved!", 0);
            }
            }
#line 286
            goto cleanup;
          }
        } else {
          {
          {
#line 285
          ui_message("File was NOT saved!", 0);
          }
          }
#line 286
          goto cleanup;
        }
      }
    }
  }
  {
  {
#line 290
  f___0 = aeff_open((char const   *)filename, (char )'w');
  }
  }
#line 290
  if (! f___0) {
    {
    {
#line 291
    tmp___2 = aeff_get_error();
    }
    {
#line 291
    sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"ERROR: Can\'t write to file. %s.",
            tmp___2);
    }
    {
#line 292
    ui_message((char const   *)(msg___1), 1);
    }
    }
#line 293
    goto cleanup;
  }
  {
  {
#line 296
  document_save(_doc, f___0);
  }
  {
#line 298
  dstrset(& _filename, (char const   *)filename);
  }
  {
#line 300
  sprintf((char */* __restrict  */)(msg___1), (char const   */* __restrict  */)"File saved: %s.",
          filename);
  }
  {
#line 301
  ui_message((char const   *)(msg___1), 0);
  }
  }
  cleanup: 
#line 304
  if (f___0) {
    {
    {
#line 304
    aeff_close(f___0);
    }
    }
  }
#line 305
  if (filename) {
    {
    {
#line 305
    free((void *)filename);
    }
    }
  }
#line 306
  return;
}
}
#line 309 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void erase_sel___2(void) 
{ 
  int x ;
  int y ;
  int x0 ;
  int x1 ;
  int y0 ;
  int y1 ;

  {
  {
  {
#line 313
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 314
  x = x0;
  }
  {
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 314
    if (! (x <= x1)) {
#line 314
      goto while_break;
    }
#line 315
    y = y0;
    {
    {
#line 315
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 315
      if (! (y <= y1)) {
#line 315
        goto while_break___0;
      }
#line 316
      *(*((*(_doc->layers + _lyr))->cells + x) + y) = (Cell )BLANK_CELL;
#line 315
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 314
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return;
}
}
#line 321 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void tint_sel___2(_Bool fg ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int x ;
  int y ;

  {
  {
  {
#line 323
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
#line 325
  x = x0;
  }
  {
  {
#line 325
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 325
    if (! (x <= x1)) {
#line 325
      goto while_break;
    }
#line 326
    y = y0;
    {
    {
#line 326
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 326
      if (! (y <= y1)) {
#line 326
        goto while_break___0;
      }
#line 327
      if (fg) {
#line 328
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )((_fg << 4) | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 15));
      } else {
#line 331
        (*((*(_doc->layers + _lyr))->cells + x) + y)->attr = (unsigned char )(_bg | ((int )(*((*(_doc->layers + _lyr))->cells + x) + y)->attr & 240));
      }
#line 326
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 337 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static int lgmode_map_ch___2(int ch ) 
{ 


  {
  {
#line 339
  if (ch == 55) {
#line 339
    goto case_55;
  }
#line 340
  if (ch == 56) {
#line 340
    goto case_56;
  }
#line 341
  if (ch == 57) {
#line 341
    goto case_57;
  }
#line 342
  if (ch == 52) {
#line 342
    goto case_52;
  }
#line 343
  if (ch == 53) {
#line 343
    goto case_53;
  }
#line 344
  if (ch == 54) {
#line 344
    goto case_54;
  }
#line 345
  if (ch == 49) {
#line 345
    goto case_49;
  }
#line 346
  if (ch == 50) {
#line 346
    goto case_50;
  }
#line 347
  if (ch == 51) {
#line 347
    goto case_51;
  }
#line 348
  if (ch == 45) {
#line 348
    goto case_45;
  }
#line 349
  if (ch == 124) {
#line 349
    goto case_124;
  }
#line 350
  if (ch == 48) {
#line 350
    goto case_48;
  }
#line 351
  goto switch_default;
  case_55: /* CIL Label */ 
#line 339
  return (3);
  case_56: /* CIL Label */ 
#line 340
  return (4);
  case_57: /* CIL Label */ 
#line 341
  return (5);
  case_52: /* CIL Label */ 
#line 342
  return (6);
  case_53: /* CIL Label */ 
#line 343
  return (7);
  case_54: /* CIL Label */ 
#line 344
  return (8);
  case_49: /* CIL Label */ 
#line 345
  return (9);
  case_50: /* CIL Label */ 
#line 346
  return (10);
  case_51: /* CIL Label */ 
#line 347
  return (11);
  case_45: /* CIL Label */ 
#line 348
  return (1);
  case_124: /* CIL Label */ 
#line 349
  return (2);
  case_48: /* CIL Label */ 
#line 350
  return (12);
  switch_default: /* CIL Label */ 
#line 351
  return (ch);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 356 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_select_handle_key___2(int ch ) 
{ 
  int x0 ;
  int y0 ;
  int x1 ;
  int y1 ;
  int tmp ;

  {
  {
  {
#line 359
  get_norm_sel(& x0, & y0, & x1, & y1);
  }
  }
  {
#line 363
  if (ch == 109) {
#line 363
    goto case_109;
  }
#line 369
  if (ch == 99) {
#line 369
    goto case_99;
  }
#line 374
  if (ch == 101) {
#line 374
    goto case_101;
  }
#line 378
  if (ch == 102) {
#line 378
    goto case_102;
  }
#line 381
  if (ch == 98) {
#line 381
    goto case_98;
  }
#line 384
  if (ch == 111) {
#line 384
    goto case_111;
  }
#line 362
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 364
  _selmode = 2;
  {
#line 365
  copy_sel_to_clipboard();
  }
  {
#line 366
  erase_sel___2();
  }
#line 367
  _x = x0;
#line 367
  _y = y0;
  }
#line 368
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 370
  _selmode = 2;
  {
#line 371
  copy_sel_to_clipboard();
  }
#line 372
  _x = x0;
#line 372
  _y = y0;
  }
#line 373
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 375
  _selmode = 0;
  {
#line 376
  erase_sel___2();
  }
  }
#line 377
  goto switch_break;
  case_102: /* CIL Label */ 
  {
  {
#line 379
  tint_sel___2((_Bool)1);
  }
  }
#line 380
  goto switch_break;
  case_98: /* CIL Label */ 
  {
  {
#line 382
  tint_sel___2((_Bool)0);
  }
  }
#line 383
  goto switch_break;
  case_111: /* CIL Label */ 
#line 388
  tmp = _x;
#line 388
  _x = _ax;
#line 388
  _ax = tmp;
#line 389
  tmp = _y;
#line 389
  _y = _ay;
#line 389
  _ay = tmp;
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  return;
}
}
#line 395 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void sm_float_handle_key___2(int ch ) 
{ 


  {
  {
#line 397
  if (ch == 115) {
#line 397
    goto case_115;
  }
#line 400
  if (ch == 88) {
#line 400
    goto case_88;
  }
#line 400
  if (ch == 120) {
#line 400
    goto case_88;
  }
#line 403
  if (ch == 89) {
#line 403
    goto case_89;
  }
#line 403
  if (ch == 121) {
#line 403
    goto case_89;
  }
#line 406
  if (ch == 84) {
#line 406
    goto case_84;
  }
#line 406
  if (ch == 116) {
#line 406
    goto case_84;
  }
#line 396
  goto switch_break;
  case_115: /* CIL Label */ 
  {
  {
#line 398
  paste_clipboard();
  }
  }
#line 399
  goto switch_break;
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  {
  {
#line 401
  layer_flip_x(_clipboard, (_Bool )(ch == 120));
  }
  }
#line 402
  goto switch_break;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
  {
#line 404
  layer_flip_y(_clipboard, (_Bool )(ch == 121));
  }
  }
#line 405
  goto switch_break;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 407
  _clipboard->transp = (_Bool )(! _clipboard->transp);
#line 408
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 433 "/home/wslee/benchmarks/textformat/aewan-1.0.01/handlekey.c"
static void correct_coords___2(void) 
{ 
  Layer *lyr___0 ;
  int scr_width ;
  int tmp ;
  int scr_height ;
  int tmp___0 ;

  {
  {
  {
#line 435
  tmp = kurses_width();
  }
#line 435
  scr_width = tmp;
  {
#line 436
  tmp___0 = kurses_height();
  }
#line 436
  scr_height = tmp___0;
  }
#line 438
  if (! _doc->layer_count) {
#line 438
    return;
  }
#line 439
  lyr___0 = *(_doc->layers + _lyr);
#line 442
  if (_x < 0) {
#line 442
    _x = 0;
  }
#line 443
  if (_x >= lyr___0->width) {
#line 443
    _x = lyr___0->width - 1;
  }
#line 444
  if (_y < 0) {
#line 444
    _y = 0;
  }
#line 445
  if (_y >= lyr___0->height) {
#line 445
    _y = lyr___0->height - 1;
  }
#line 448
  if (_x >= _svx + scr_width) {
#line 448
    _svx = (_x - scr_width) + 1;
  } else
#line 449
  if (_x < _svx) {
#line 449
    _svx = _x;
  }
#line 450
  if (_y >= (_svy + scr_height) - 1) {
#line 450
    _svy = (_y - scr_height) + 2;
  } else
#line 451
  if (_y < _svy) {
#line 451
    _svy = _y;
  }
#line 452
  return;
}
}
#line 190 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/listbox.c"
static int _compar___2(void const   *p1 , void const   *p2 ) 
{ 
  char const   **a ;
  char const   **b ;
  int tmp ;

  {
  {
#line 191
  a = (char const   **)p1;
#line 192
  b = (char const   **)p2;
  {
#line 193
  tmp = strcmp(*a, *b);
  }
  }
#line 193
  return (tmp);
}
}
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/keybind.c"
static int *cmdforkey___2  ;
#line 39 "/home/wslee/benchmarks/textformat/aewan-1.0.01/helpdlg.c"
static char *helptext___2[2]  = {      (char *)"\001Legend\002\n^ means the Ctrl key and % means\nthe Alt key. Thus, ^A means \nCtrl+A and %A means Alt-A.\n\n\001General keys\002\n^X,^Z  fast horizontal movement\n^O     open a file\n^S     save file\n\n\001Layers\002\n^W     go to next layer\n^Q     go to previous layer\n^L     bring up Layer Manager\n^A     add layer (defaults)\n%A     add layer (specify)\n^D     add copy of current layer\n^R     rename this layer\n%R     resize this layer\n\n\001Selection\002\n%S     enter select mode.\n",      (char *)"\001Colors\002\nTAB    bring up color dialog\n%P     pick color from cell\n       under the cursor\n%Z     apply color to cell\n       under the cursor\n\n\001Mode toggles\002\nINS    toggle insert mode\n^G     toggle line-drawing mode\n       (0-9,|,- will draw lines)\n^P     toggle composite view\n\n\001Others\002\n^E     edit document metainfo\n^C     quit program\nF1-Fn  show menu\n\n*************************************\nCopyright (c) 2003 by\nBruno T. C. de Oliveira\nAll rights reserved."};
#line 1 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static Menu menu___5[4]  = {      {"[F1] File", 1, 0, 0, 7, {{(char )'N', "&New", 35, "Clears everything and starts from scratch"},
                                {(char )'L', "&Load...", 8, "Loads a file into the editor"},
                                {(char )'S', "&Save", 9, "Saves the current drawing"},
                                {(char )'A', "Save &As...", 10, "Saves the current drawing in a specified file"},
                                {(char )'M', "Edit &Meta...", 11, "Opens an editor for you to edit this document\'s metadata"},
                                {(char )' ', "", 0, (char const   *)((void *)0)},
                                {(char )'Q', "&Quit", 34, "Quits program"}}}, 
        {"[F2] Edit", 16, 0, 0, 8, {{(char )'C', "Drawing &color...", 5, "Brings up the color selection dialog"},
                                 {(char )'I', "Toggle &Insert", 6, "Toggles insert/overwrite mode"},
                                 {(char )'K', "Pic&k color", 23, "Picks color under cursor to use as current color"},
                                 {(char )'T', "&Tint cell", 24, "Applies current color to cell under cursor"},
                                 {(char )' ', "", 0, (char const   *)((void *)0)},
                                 {(char )'S', "Toggle &select mode", 25, "Toggles select mode on/off"},
                                 {(char )'L', "Toggle &line-drawing", 32, "Toggles line-drawing mode on/off. Use 0-9 to draw lines"},
                                 {(char )'P', "Toggle com&posite", 33, "Toggles composite (all-layer) view on/off"}}}, 
        {"[F3] Layer",
      32, 0, 0, 9, {{(char )'A', "&Add layer (defaults)", 1, "Adds a layer with default parameters"},
                    {(char )'L', "Add &layer (specify)...", 2, "Adds a layer with custom parameters"},
                    {(char )'D', "&Duplicate layer", 30, "Duplicates current layer. Copy is added to the bottom of the stack."},
                    {(char )'R', "&Rename layer...", 31, "Renames the current layer"},
                    {(char )'Z', "Resi&ze layer...", 37, "Resizes the current layer"},
                    {(char )'M', "&Manage layers...", 27, "Shows a dialog in which you can manipulate layers"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'N',
                                                                       "Go to &next layer",
                                                                       28, "Goes to the next layer"},
                    {(char )'P', "Go to &previous layer", 29, "Goes to the previous layer"}}}, 
        {"[F4] Help",
      64, 0, 0, 3, {{(char )'K', "&Key reference", 7, "Shows a table of keys and their functions"},
                    {(char )' ', "", 0, (char const   *)((void *)0)}, {(char )'A',
                                                                       "&About Aewan",
                                                                       36, "Shows information about the program"}}}};
#line 76 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar-items.inc"
static int menu_count___2  =    4;
#line 78 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int open_menu___2  ;
#line 79 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static int menu_sel___2  ;
#line 83
static void menubar_paint___2(void) ;
#line 84
static void menuitem_print___2(char const   *s , _Bool sel , int minlen ) ;
#line 85
static void menu_calc_dims___2(Menu *m ) ;
#line 86
static _Bool chr_icomp___2(char c1 , char c2 ) ;
#line 151 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static _Bool chr_icomp___2(char c1 , char c2 ) 
{ 


  {
#line 152
  if ((int )c1 >= 65) {
#line 152
    if ((int )c1 <= 90) {
#line 152
      c1 = (char )(((int )c1 - 65) + 97);
    } else {
#line 152
      c1 = c1;
    }
  } else {
#line 152
    c1 = c1;
  }
#line 153
  if ((int )c2 >= 65) {
#line 153
    if ((int )c2 <= 90) {
#line 153
      c2 = (char )(((int )c2 - 65) + 97);
    } else {
#line 153
      c2 = c2;
    }
  } else {
#line 153
    c2 = c2;
  }
#line 154
  return ((_Bool )((int )c1 == (int )c2));
}
}
#line 157 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menubar_paint___2(void) 
{ 
  int i ;
  Menu *omenu ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 160
  restore_screen();
  }
  {
#line 162
  kurses_color_at(7);
  }
  {
#line 163
  tmp = kurses_width();
  }
  {
#line 163
  draw_hline(0, 0, tmp, ' ', ' ', ' ');
  }
#line 165
  i = 0;
  }
  {
  {
#line 165
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < menu_count___2)) {
#line 165
      goto while_break;
    }
    {
    {
#line 166
    kurses_move(menu___5[i].startcol, 0);
    }
    {
#line 167
    menuitem_print___2(menu___5[i].caption, (_Bool )(i == open_menu___2), -1);
    }
#line 165
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  omenu = & menu___5[open_menu___2];
#line 173
  if (! omenu->menu_h) {
    {
    {
#line 173
    menu_calc_dims___2(omenu);
    }
    }
  }
  {
  {
#line 176
  kurses_color_at(7);
  }
  {
#line 177
  draw_window(omenu->startcol, 1, omenu->menu_w + 2, omenu->menu_h + 2, "");
  }
#line 178
  i = 0;
  }
  {
  {
#line 178
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 178
    if (! (i < omenu->item_count)) {
#line 178
      goto while_break___0;
    }
    {
    {
#line 179
    kurses_move(omenu->startcol + 1, i + 2);
    }
    {
#line 180
    menuitem_print___2(omenu->item[i].caption, (_Bool )(i == menu_sel___2), omenu->menu_w);
    }
#line 178
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 184
  tmp___0 = kurses_height();
  }
  {
#line 184
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 185
  kurses_color_at(7);
  }
  {
#line 186
  tmp___1 = strlen(omenu->item[menu_sel___2].desc);
  }
#line 186
  i = (int )tmp___1;
  {
#line 187
  waddnstr(stdscr, omenu->item[menu_sel___2].desc, -1);
  }
  }
  {
  {
#line 188
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
#line 188
    tmp___2 = i;
#line 188
    i ++;
    {
#line 188
    tmp___3 = kurses_width();
    }
    }
#line 188
    if (! (tmp___2 < tmp___3)) {
#line 188
      goto while_break___1;
    }
    {
    {
#line 188
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 190
  tmp___4 = kurses_height();
  }
  {
#line 190
  tmp___5 = kurses_width();
  }
  {
#line 190
  kurses_move(tmp___5 - 1, tmp___4 - 1);
  }
  {
#line 191
  wrefresh(stdscr);
  }
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menuitem_print___2(char const   *s , _Bool sel , int minlen ) 
{ 
  _Bool next_is_accel ;
  int printed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 195
  next_is_accel = (_Bool)0;
#line 196
  printed = 0;
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (! *s) {
#line 197
      if (! (printed < minlen)) {
#line 197
        goto while_break;
      }
    }
#line 198
    if ((int const   )*s == 38) {
#line 199
      next_is_accel = (_Bool)1;
#line 200
      s ++;
#line 201
      goto while_continue;
    }
#line 204
    if (sel) {
#line 204
      if (next_is_accel) {
#line 204
        tmp = 225;
      } else {
#line 204
        tmp = 241;
      }
#line 204
      tmp___1 = tmp;
    } else {
#line 204
      if (next_is_accel) {
#line 204
        tmp___0 = 23;
      } else {
#line 204
        tmp___0 = 7;
      }
#line 204
      tmp___1 = tmp___0;
    }
    {
    {
#line 204
    kurses_color_at(tmp___1);
    }
    }
#line 208
    if (*s) {
#line 208
      tmp___2 = (int const   )*s;
    } else {
#line 208
      tmp___2 = (int const   )' ';
    }
    {
    {
#line 208
    waddch(stdscr, (chtype const   )tmp___2);
    }
#line 209
    printed ++;
#line 211
    next_is_accel = (_Bool)0;
    }
#line 212
    if (*s) {
#line 212
      s ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/wslee/benchmarks/textformat/aewan-1.0.01/menubar.c"
static void menu_calc_dims___2(Menu *m ) 
{ 
  int i ;
  int width___0 ;
  int len ;
  size_t tmp ;

  {
#line 218
  width___0 = 1;
#line 218
  len = 0;
#line 220
  i = 0;
  {
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < m->item_count)) {
#line 220
      goto while_break;
    }
    {
    {
#line 221
    tmp = strlen(m->item[i].caption);
    }
#line 221
    len = (int )tmp;
    }
#line 222
    if (len > width___0) {
#line 222
      width___0 = len;
    }
#line 220
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  m->menu_h = m->item_count;
#line 226
  m->menu_w = width___0;
#line 227
  return;
}
}
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
FILE *outf  ;
#line 64 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
_Bool add_instructions  =    (_Bool)1;
#line 68 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
int interframe_delay  =    100;
#line 77 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
void output_lessmovie_instructions(void) 
{ 
  int instruction_lines ;
  int instruction_cols ;
  int lines_left ;
  int i ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 78
  instruction_lines = 18;
#line 82
  instruction_cols = 70;
  {
#line 87
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"----------------------------------------[ TOP ]----------\nAEWAN LESS-MOVIE\n\nThis is an ascii animation intended to be viewed in the \'less\'\npager. You must set your terminal dimensions to the following:\n\n                %d columns x %d rows\n\nThen run \'less -c -r <filename>.ae\' and hold down the PageDown key\nto see the animation play.\n\nYou can tell if the terminal dimensions are correct by looking at\nthe top and bottom dotted lines: the one marked \'[ TOP ]\' should\nappear at the topmost line of the terminal and the dotted line\nmarked [ BOTTOM ] should appear at the bottommost. As you page-down\na few times, they should REMAIN FIXED, not move around.\n\nThis animation was generated with AEWAN, an open-source ascii and\nanimation editor. Visit http://aewan.sourceforge.net for more info.\n",
          width, height + 1);
  }
#line 104
  lines_left = (height - instruction_lines) - 1;
  }
#line 105
  if (lines_left < 1) {
    {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t add instructions because the document\ndimensions are too small. Height must be at least\n%d and width must be at least %d.\n",
            instruction_lines, instruction_cols);
    }
    {
#line 110
    exit(2);
    }
    }
  } else
#line 105
  if (width < instruction_cols) {
    {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: can\'t add instructions because the document\ndimensions are too small. Height must be at least\n%d and width must be at least %d.\n",
            instruction_lines, instruction_cols);
    }
    {
#line 110
    exit(2);
    }
    }
  }
  {
  {
#line 113
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 113
    if (! (lines_left > 1)) {
#line 113
      goto while_break;
    }
    {
    {
#line 114
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)outf);
    }
#line 115
    lines_left --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 118
  fputs((char const   */* __restrict  */)"----------------------------------------[ BOTTOM ]-------\n",
        (FILE */* __restrict  */)outf);
  }
#line 120
  i = 4;
  }
  {
  {
#line 120
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (i >= 1)) {
#line 120
      goto while_break___0;
    }
    {
    {
#line 121
    fputs((char const   */* __restrict  */)"----------------------------------------[ TOP ]----------\n",
          (FILE */* __restrict  */)outf);
    }
#line 122
    lines_left = height - 2;
    {
#line 124
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"(movie starts in %d frame[s])...\n",
            i);
    }
#line 125
    lines_left --;
    }
    {
    {
#line 127
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 127
      tmp = lines_left;
#line 127
      lines_left --;
#line 127
      if (! (tmp > 0)) {
#line 127
        goto while_break___1;
      }
      {
      {
#line 127
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)outf);
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 128
    fputs((char const   */* __restrict  */)"----------------------------------------[ BOTTOM ]-------\n",
          (FILE */* __restrict  */)outf);
    }
#line 120
    i --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 132 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
void output_shellscript_instructions(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 133
  fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"echo \'AEWAN SHELLSCRIPT ANIMATION\'\necho \'This is an aewan animation shellscript. It will now play an\'\necho \'animation on your terminal. Please make sure the terminal\'\necho \'has at least the following dimensions:\'\necho \'     %d lines, %d columns\'\necho\necho \'This animation was generated with AEWAN, an open-source ascii art and\'\necho \'and animation editor. For more info, see http://aewan.sourceforge.net\'\necho\necho \'Press ENTER to start the animation\'\nread\necho -ne \'\\e[2J\\e[H\'\n",
          height, width);
  }
  }
#line 147
  return;
}
}
#line 149 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
void output_lessmovie(void) 
{ 
  int i ;
  VirtualLayer *vl ;
  VirtualLayer *tmp ;

  {
#line 152
  if (add_instructions) {
    {
    {
#line 152
    output_lessmovie_instructions();
    }
    }
  }
#line 154
  i = 0;
  {
  {
#line 154
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < doc->layer_count)) {
#line 154
      goto while_break;
    }
    {
    {
#line 155
    tmp = vlayer_create_from_layer(*(doc->layers + i));
    }
#line 155
    vl = tmp;
    {
#line 156
    export_vlayer_to_ansi(vl, use_color, (_Bool)1, (_Bool)0, outf);
    }
    {
#line 157
    vlayer_destroy(vl);
    }
#line 154
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 161 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aemakeflic.c"
void output_shellscript(void) 
{ 
  int i ;
  VirtualLayer *vl ;
  VirtualLayer *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 164
  fputs((char const   */* __restrict  */)"#!/bin/bash\n# This is an aewan animation shellscript. Upon execution,\n# it will play an animation on the terminal.\n# Aewan is an open-source ascii art and animation editor.\n#       http://aewan.sourceforge.net\n\necho -ne \'\\e[2J\\e[H\'\n",
        (FILE */* __restrict  */)outf);
  }
  }
#line 172
  if (add_instructions) {
    {
    {
#line 172
    output_shellscript_instructions();
    }
    }
  }
#line 174
  i = 0;
  {
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i < doc->layer_count)) {
#line 174
      goto while_break;
    }
    {
    {
#line 175
    tmp = vlayer_create_from_layer(*(doc->layers + i));
    }
#line 175
    vl = tmp;
    {
#line 176
    fputs((char const   */* __restrict  */)"echo -ne \'\\e[H\'\n", (FILE */* __restrict  */)outf);
    }
    {
#line 177
    fputs((char const   */* __restrict  */)"cat <<QWPOEIURASDKJFAS\n", (FILE */* __restrict  */)outf);
    }
    {
#line 178
    export_vlayer_to_ansi(vl, use_color, (_Bool)1, (_Bool)1, outf);
    }
    {
#line 179
    fputs((char const   */* __restrict  */)"\nQWPOEIURASDKJFAS\n", (FILE */* __restrict  */)outf);
    }
    {
#line 183
    fprintf((FILE */* __restrict  */)outf, (char const   */* __restrict  */)"sleep %.3f\n",
            (double )((float )interframe_delay / 1000.0f));
    }
    {
#line 184
    vlayer_destroy(vl);
    }
#line 174
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 40 "/home/wslee/benchmarks/textformat/aewan-1.0.01/colordlg.c"
static void paint_dlg___5(void) 
{ 
  int x0 ;
  int y0 ;
  int i ;
  int j ;
  char hexdigit___3[17] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 42
  hexdigit___3[0] = (char )'0';
#line 42
  hexdigit___3[1] = (char )'1';
#line 42
  hexdigit___3[2] = (char )'2';
#line 42
  hexdigit___3[3] = (char )'3';
#line 42
  hexdigit___3[4] = (char )'4';
#line 42
  hexdigit___3[5] = (char )'5';
#line 42
  hexdigit___3[6] = (char )'6';
#line 42
  hexdigit___3[7] = (char )'7';
#line 42
  hexdigit___3[8] = (char )'8';
#line 42
  hexdigit___3[9] = (char )'9';
#line 42
  hexdigit___3[10] = (char )'a';
#line 42
  hexdigit___3[11] = (char )'b';
#line 42
  hexdigit___3[12] = (char )'c';
#line 42
  hexdigit___3[13] = (char )'d';
#line 42
  hexdigit___3[14] = (char )'e';
#line 42
  hexdigit___3[15] = (char )'f';
#line 42
  hexdigit___3[16] = (char )'\000';
  {
#line 44
  kurses_color(7, 0);
  }
  {
#line 45
  draw_centered_window(39, 21, "Choose Color", & x0, & y0);
  }
  {
#line 48
  kurses_color(12, 0);
  }
  {
#line 49
  kurses_move((x0 + 4) + 2 * _bg, y0);
  }
  {
#line 50
  waddch(stdscr, (chtype const   )'b');
  }
  {
#line 53
  kurses_color(10, 0);
  }
  {
#line 54
  kurses_move(x0, (y0 + 2) + _fg);
  }
  {
#line 55
  waddch(stdscr, (chtype const   )'f');
  }
  {
#line 58
  kurses_color(7, 0);
  }
  {
#line 59
  kurses_move(x0 + 4, y0 + 1);
  }
  {
#line 60
  waddnstr(stdscr, "0 1 2 3 4 5 6 7 8 9 a b c d e f", -1);
  }
#line 63
  i = 0;
  }
  {
  {
#line 63
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 16)) {
#line 63
      goto while_break;
    }
    {
    {
#line 64
    kurses_move(x0 + 2, (y0 + 2) + i);
    }
    {
#line 65
    waddch(stdscr, (chtype const   )hexdigit___3[i]);
    }
#line 63
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  i = 0;
  {
  {
#line 69
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 69
    if (! (i < 16)) {
#line 69
      goto while_break___0;
    }
    {
    {
#line 70
    kurses_move(x0 + 4, (y0 + 2) + i);
    }
#line 71
    j = 0;
    }
    {
    {
#line 71
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 71
      if (! (j < 16)) {
#line 71
        goto while_break___1;
      }
      {
      {
#line 72
      kurses_color(i, j);
      }
      {
#line 73
      waddnstr(stdscr, "Aa", -1);
      }
#line 71
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 69
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 78
  kurses_move((x0 + 4) + 2 * _bg, (y0 + 2) + _fg);
  }
  }
#line 79
  return;
}
}
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_fld___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *cancel_btn___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *ok_btn___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_lbl___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *dirs_box___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *files_box___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *filename_stlbl___2  ;
#line 96 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlWidget *directory_stlbl___2  ;
#line 99 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static AewlForm *form___2  ;
#line 101 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *curdir___2  =    (char *)((void *)0);
#line 107
static void _update_widgets___2(void) ;
#line 109 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static _Bool _is_dir_valid___2(char const   *dir ) 
{ 
  DIR *d ;
  DIR *tmp ;

  {
  {
  {
#line 110
  tmp = opendir(dir);
  }
#line 110
  d = tmp;
  }
#line 111
  if (d) {
    {
    {
#line 112
    closedir(d);
    }
    }
#line 113
    return ((_Bool)1);
  }
#line 116
  return ((_Bool)0);
}
}
#line 119 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *my_getcwd___2(void) 
{ 
  int cap ;
  char *s ;
  void *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 121
  cap = 32;
  {
#line 121
  tmp = malloc((size_t )cap);
  }
#line 121
  s = (char *)tmp;
  }
  {
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 123
    tmp___2 = getcwd(s, (size_t )cap);
    }
    }
#line 123
    if (tmp___2) {
#line 123
      goto while_break;
    }
    {
    {
#line 124
    tmp___0 = __errno_location();
    }
    }
#line 124
    if (*tmp___0 != 34) {
#line 124
      return ((char *)((void *)0));
    }
    {
#line 125
    cap += cap;
    {
#line 125
    tmp___1 = malloc((size_t )cap);
    }
#line 125
    s = (char *)tmp___1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return (s);
}
}
#line 131 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static char *_get_canon_dir_path___2(char const   *base , char const   *relative ) 
{ 
  char *oldpwd ;
  char *tmp ;
  char *retval ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 133
  tmp = my_getcwd___2();
  }
#line 133
  oldpwd = tmp;
  }
#line 136
  if (! oldpwd) {
#line 136
    return ((char *)((void *)0));
  }
  {
  {
#line 138
  tmp___0 = chdir(base);
  }
  }
#line 138
  if (0 != tmp___0) {
#line 138
    return ((char *)((void *)0));
  }
  {
  {
#line 139
  tmp___1 = chdir(relative);
  }
  }
#line 139
  if (0 != tmp___1) {
#line 139
    return ((char *)((void *)0));
  }
  {
  {
#line 141
  retval = my_getcwd___2();
  }
  {
#line 143
  tmp___4 = chdir((char const   *)oldpwd);
  }
  }
#line 143
  if (0 != tmp___4) {
    {
    {
#line 144
    tmp___2 = __errno_location();
    }
    {
#line 144
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PANIC: Can\'t go back to old wd \'%s\'\n%s\n",
            oldpwd, tmp___3);
    }
    {
#line 146
    abort();
    }
    }
  }
#line 149
  return (retval);
}
}
#line 283 "/home/wslee/benchmarks/textformat/aewan-1.0.01/filedlg.c"
static void _update_widgets___2(void) 
{ 
  DIR *d ;
  struct dirent *dent ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *compname ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 288
  d = opendir((char const   *)curdir___2);
  }
  }
#line 290
  if (! d) {
    {
    {
#line 291
    tmp = __errno_location();
    }
    {
#line 291
    tmp___0 = strerror(*tmp);
    }
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR in opendir(\"%s\"): %s\n",
            curdir___2, tmp___0);
    }
    {
#line 293
    abort();
    }
    }
  }
  {
  {
#line 296
  aewl_listbox_clear((AewlListBox *)dirs_box___2);
  }
  {
#line 297
  aewl_listbox_clear((AewlListBox *)files_box___2);
  }
  }
  {
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 298
    dent = readdir(d);
    }
    }
#line 298
    if (! dent) {
#line 298
      goto while_break;
    }
    {
    {
#line 299
    tmp___1 = strlen((char const   *)(dent->d_name));
    }
    {
#line 299
    tmp___2 = strlen((char const   *)curdir___2);
    }
    {
#line 299
    tmp___3 = zalloc((int )((tmp___1 + tmp___2) + 2U));
    }
#line 299
    compname = (char *)tmp___3;
    {
#line 300
    sprintf((char */* __restrict  */)compname, (char const   */* __restrict  */)"%s/%s",
            curdir___2, dent->d_name);
    }
    {
#line 302
    tmp___4 = stat((char const   */* __restrict  */)compname, (struct stat */* __restrict  */)(& st));
    }
    }
#line 302
    if (0 != tmp___4) {
#line 302
      goto while_continue;
    }
    {
    {
#line 304
    free((void *)compname);
    }
    }
#line 306
    if ((st.st_mode & 61440U) == 16384U) {
      {
      {
#line 307
      aewl_listbox_add((AewlListBox *)dirs_box___2, (char const   *)(dent->d_name));
      }
      }
    } else {
      {
      {
#line 309
      aewl_listbox_add((AewlListBox *)files_box___2, (char const   *)(dent->d_name));
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 311
  aewl_listbox_sort((AewlListBox *)dirs_box___2);
  }
  {
#line 312
  aewl_listbox_sort((AewlListBox *)files_box___2);
  }
  {
#line 314
  closedir(d);
  }
  {
#line 317
  aewl_label_set_text((AewlLabel *)directory_lbl___2, (char const   *)curdir___2);
  }
  }
#line 318
  return;
}
}
#line 5 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_LYR___2(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Layer *l ;

  {
#line 6
  l = (Layer *)ud;
#line 7
  *r_cell = *(*(l->cells + x) + y);
#line 8
  return;
}
}
#line 11 "/home/wslee/benchmarks/textformat/aewan-1.0.01/vlayer.c"
static void _get_cell_COMPOSITE___2(Cell *r_cell , int x , int y , void *ud ) 
{ 
  Document *doc___0 ;

  {
  {
#line 12
  doc___0 = doc___0;
  {
#line 13
  *r_cell = document_calc_effective_cell(doc___0, x, y);
  }
  }
#line 14
  return;
}
}
#line 43 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static char *logo___2[6]  = {      (char *)"79         ",      (char *)"||         ",      (char *)"46799 97979",      (char *)"||43|||||||", 
        (char *)"311-1231231",      (char *)((void *)0)};
#line 52 "/home/wslee/benchmarks/textformat/aewan-1.0.01/welcomedlg.c"
static int logo_colors___2[5]  = {      4,      6,      7,      6, 
        4};
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare_ex___1(int fg , int bg ) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 46
  tmp = kurses_width();
  }
#line 46
  w = tmp;
  {
#line 47
  tmp___0 = kurses_height();
  }
  {
#line 47
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 48
  kurses_color(fg, bg);
  }
  }
  {
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 49
    tmp___1 = w;
#line 49
    w --;
#line 49
    if (! tmp___1) {
#line 49
      goto while_break;
    }
    {
    {
#line 49
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 50
  tmp___2 = kurses_height();
  }
  {
#line 50
  kurses_move(0, tmp___2 - 1);
  }
#line 51
  ui_cancel = 0;
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare___1(void) 
{ 


  {
  {
  {
#line 55
  ui_prepare_ex___1(15, 4);
  }
  }
#line 56
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___9[32]  ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___10[256]  ;
#line 91 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char hexdigit___1[17]  = 
#line 91
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static AbsMenu *menu___6  =    (AbsMenu *)0;
#line 63 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void painter___2(int i , AbsMenu *m ) 
{ 
  Layer *l ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 64
  l = *(_doc->layers + i);
#line 65
  if (l->name) {
#line 65
    tmp = (char const   *)l->name;
  } else {
#line 65
    tmp = "(untitled)";
  }
#line 65
  if (l->transp) {
#line 65
    tmp___0 = 't';
  } else {
#line 65
    tmp___0 = ' ';
  }
#line 65
  if (l->visible) {
#line 65
    tmp___1 = 'v';
  } else {
#line 65
    tmp___1 = ' ';
  }
  {
  {
#line 65
  printw("%2d: %c%c (%3d x %3d) %s", i, tmp___1, tmp___0, l->width, l->height, tmp);
  }
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layerdlg.c"
static void paint_dlg___6(void) 
{ 
  int x0 ;
  int y0 ;
  int x ;
  int y ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 74
  kurses_color(7, 0);
  }
  {
#line 75
  draw_centered_window(42, 19, "Layer Manager", & x0, & y0);
  }
  }
#line 77
  if (! menu___6) {
    {
    {
#line 78
    menu___6 = menu_create(& _doc->layer_count, x0, y0, 40, 11, 113, 112, & painter___2);
    }
    {
#line 81
    menu_select_item(menu___6, _lyr);
    }
    }
  }
  {
  {
#line 84
  draw_hline(x0 - 1, y0 + 11, 42, (int )acs_map[(unsigned char )'t'], (int )acs_map[(unsigned char )'q'],
             (int )acs_map[(unsigned char )'u']);
  }
#line 87
  y = (y0 + 11) + 1;
#line 87
  x = x0 + 1;
  {
#line 87
  kurses_move(x, y);
  }
  {
#line 89
  kurses_color(2, 0);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )'<');
  }
  {
#line 89
  waddch(stdscr, (chtype const   )acs_map[(unsigned char )'j']);
  }
  {
#line 89
  waddch(stdscr, (chtype const   )' ');
  }
  {
#line 90
  kurses_color(7, 0);
  }
  {
#line 91
  printw(": go to layer");
  }
#line 93
  y ++;
  {
#line 93
  kurses_move(x, y);
  }
  {
#line 94
  kurses_color(2, 0);
  }
  {
#line 94
  waddnstr(stdscr, "d  ", -1);
  }
  {
#line 94
  kurses_color(7, 0);
  }
  {
#line 95
  printw(": delete layer");
  }
#line 97
  y ++;
  {
#line 97
  kurses_move(x, y);
  }
  {
#line 98
  kurses_color(2, 0);
  }
  {
#line 98
  waddnstr(stdscr, "+/-", -1);
  }
  {
#line 98
  kurses_color(7, 0);
  }
  {
#line 99
  printw(": move layer up/down");
  }
#line 101
  y ++;
  {
#line 101
  kurses_move(x, y);
  }
  {
#line 102
  kurses_color(2, 0);
  }
  {
#line 102
  waddnstr(stdscr, "v  ", -1);
  }
  {
#line 102
  kurses_color(7, 0);
  }
  {
#line 103
  printw(": toggle visibility");
  }
#line 105
  y ++;
  {
#line 105
  kurses_move(x, y);
  }
  {
#line 106
  kurses_color(2, 0);
  }
  {
#line 106
  waddnstr(stdscr, "t  ", -1);
  }
  {
#line 106
  kurses_color(7, 0);
  }
  {
#line 107
  printw(": toggle transparency");
  }
  {
#line 109
  menu_paint(menu___6);
  }
  }
#line 110
  return;
}
}
#line 44 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap___2(AewlField *f___0 , int cap ) ;
#line 45
static void buf_insert_char___2(char *buf___15 , int cap , int pos , int ch ) ;
#line 46
static void buf_del_char___2(char *buf___15 , int cap , int pos , int ch ) ;
#line 160 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void aewl_field_ensure_cap___2(AewlField *f___0 , int cap ) 
{ 
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 161
  if (f___0->cap >= cap) {
#line 161
    return;
  }
  {
#line 163
  tmp___0 = cap + 20;
#line 163
  f___0->cap = tmp___0;
  {
#line 163
  tmp___1 = realloc((void *)f___0->buffer, (size_t )tmp___0);
  }
#line 163
  tmp = (char *)tmp___1;
#line 163
  f___0->buffer = tmp;
  }
#line 163
  if (! tmp) {
    {
    {
#line 164
    abort();
    }
    }
  }
#line 165
  return;
}
}
#line 167 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_insert_char___2(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 171
  i = cap - 1;
  {
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i > pos)) {
#line 171
      goto while_break;
    }
#line 171
    *(buf___15 + i) = *(buf___15 + (i - 1));
#line 171
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  *(buf___15 + pos) = (char )ch;
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/textformat/aewan-1.0.01/aewl/field.c"
static void buf_del_char___2(char *buf___15 , int cap , int pos , int ch ) 
{ 
  int i ;

  {
#line 177
  i = pos;
  {
  {
#line 177
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < cap - 1)) {
#line 177
      goto while_break;
    }
#line 177
    *(buf___15 + i) = *(buf___15 + (i + 1));
#line 177
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 162 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char tbl_lookup___2(char **table , int ch ) 
{ 
  char const   *s ;
  char const   *p ;
  char const   *tmp ;

  {
#line 163
  s = (char const   *)*(table + 0);
#line 163
  p = (char const   *)*(table + 1);
  {
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 164
    if (! *s) {
#line 164
      goto while_break;
    }
#line 165
    tmp = s;
#line 165
    s ++;
#line 165
    if ((int const   )*tmp == (int const   )ch) {
#line 165
      return ((char )*p);
    }
#line 166
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return ((char )ch);
}
}
#line 174 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___5[2]  = {      (char *)"`\'()/\\<>[]{}\003\005\006\b\t\v",      (char *)"\'`)(\\/><][}{\005\003\b\006\v\t"};
#line 195 "/home/wslee/benchmarks/textformat/aewan-1.0.01/layer.c"
static char *flip_table___6[2]  = {      (char *)"/\\\003\t\004\n\005\v",      (char *)"\\/\t\003\n\004\v\005"};
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static char hs___2[17]  = 
#line 250 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
#line 260 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/util.c"
static int hex_digit_val___2(char c ) 
{ 


  {
#line 261
  if ((int )c >= 48) {
#line 261
    if ((int )c <= 57) {
#line 261
      return ((int )c - 48);
    } else {
#line 261
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 262
  if ((int )c >= 97) {
#line 262
    if ((int )c <= 102) {
#line 262
      return (((int )c - 97) + 10);
    } else {
#line 262
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 263
  if ((int )c >= 65) {
#line 263
    if ((int )c <= 70) {
#line 263
      return (((int )c - 65) + 10);
    } else {
#line 264
      return (0);
    }
  } else {
#line 264
    return (0);
  }
}
}
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/init_aewl.c"
static int curses_attr_for_pair___3(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 39
  cp = (short )((bg * 8 + 7) - fg);
#line 40
  if (! cp) {
#line 40
    if (bold) {
#line 40
      tmp = 1UL << 21;
    } else {
#line 40
      tmp = 0UL;
    }
#line 40
    return ((int )tmp);
  }
#line 41
  if (bold) {
#line 41
    tmp___0 = 1UL << 21;
  } else {
#line 41
    tmp___0 = 0UL;
  }
#line 41
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 120 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
static char buf___11[2]  ;
#line 16 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.c"
static int curses_attr_for_pair___4(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 17
  cp = (short )((bg * 8 + 7) - fg);
#line 18
  if (! cp) {
#line 18
    if (bold) {
#line 18
      tmp = 1UL << 21;
    } else {
#line 18
      tmp = 0UL;
    }
#line 18
    return ((int )tmp);
  }
#line 19
  if (bold) {
#line 19
    tmp___0 = 1UL << 21;
  } else {
#line 19
    tmp___0 = 0UL;
  }
#line 19
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 87 "/home/wslee/benchmarks/textformat/aewan-1.0.01/absmenu.c"
static void menu_correct___2(AbsMenu *m ) 
{ 


  {
  {
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 89
    if (! (m->sel_item < 0)) {
#line 89
      goto while_break;
    }
#line 89
    m->sel_item = 0;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 90
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (m->sel_item >= *(m->item_count))) {
#line 90
      goto while_break___0;
    }
#line 90
    m->sel_item = -1 + *(m->item_count);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  if (m->item_at_top > m->sel_item) {
#line 95
    m->item_at_top = m->sel_item;
  } else
#line 96
  if (m->sel_item >= m->item_at_top + m->h) {
#line 97
    m->item_at_top = (m->sel_item - m->h) + 1;
  }
#line 98
  return;
}
}
#line 57 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node___2(HashDict *hd , Node *n ) ;
#line 58
static int _which_bucket___2(char const   *key , int bucketcount ) ;
#line 59
static Node *_node_lookup___2(HashDict *hd , char const   *key ) ;
#line 187 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static Node *_node_lookup___2(HashDict *hd , char const   *key ) 
{ 
  Node *n ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 196
  tmp = _which_bucket___2(key, hd->bucketcount);
  }
#line 196
  n = hd->bucketheads + tmp;
  }
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (n->next) {
      {
      {
#line 197
      tmp___0 = strcmp((char const   *)(n->next)->key, key);
      }
      }
#line 197
      if (! tmp___0) {
#line 197
        goto while_break;
      }
    } else {
#line 197
      goto while_break;
    }
#line 197
    n = n->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (n);
}
}
#line 201 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static void _destroy_node___2(HashDict *hd , Node *n ) 
{ 


  {
#line 202
  if (n) {
#line 203
    if (hd->value_destroyer) {
#line 203
      if (n->value) {
        {
        {
#line 204
        (*(hd->value_destroyer))((void *)n->value);
        }
        }
      }
    }
    {
    {
#line 205
    zfree(& n->key);
    }
    {
#line 206
    free((void *)n);
    }
    }
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/hashdict.c"
static int _which_bucket___2(char const   *key , int bucketcount ) 
{ 
  int x ;
  char const   *tmp ;

  {
#line 218
  x = 0;
  {
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 219
    if (! *key) {
#line 219
      goto while_break;
    }
#line 219
    tmp = key;
#line 219
    key ++;
#line 219
    x += (int )*tmp;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (x % bucketcount);
}
}
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_fg___2  ;
#line 61 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int cur_bg___2  ;
#line 64
static int kurses_pair_for___2(int fg , int bg ) ;
#line 287 "/home/wslee/benchmarks/textformat/aewan-1.0.01/bores/kurses.c"
static int kurses_pair_for___2(int fg , int bg ) 
{ 


  {
#line 288
  fg &= 7;
#line 288
  bg &= 7;
#line 289
  return ((bg << 3) + (7 - fg));
}
}
#line 120 "/home/wslee/benchmarks/textformat/aewan-1.0.01/document.c"
static char buf___12[2]  ;
#line 16 "/home/wslee/benchmarks/textformat/aewan-1.0.01/debug_aewl.c"
static int curses_attr_for_pair___5(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 17
  cp = (short )((bg * 8 + 7) - fg);
#line 18
  if (! cp) {
#line 18
    if (bold) {
#line 18
      tmp = 1UL << 21;
    } else {
#line 18
      tmp = 0UL;
    }
#line 18
    return ((int )tmp);
  }
#line 19
  if (bold) {
#line 19
    tmp___0 = 1UL << 21;
  } else {
#line 19
    tmp___0 = 0UL;
  }
#line 19
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 38 "/home/wslee/benchmarks/textformat/aewan-1.0.01/init_aewl.c"
static int curses_attr_for_pair___6(int fg , int bg , _Bool bold ) 
{ 
  short cp ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 39
  cp = (short )((bg * 8 + 7) - fg);
#line 40
  if (! cp) {
#line 40
    if (bold) {
#line 40
      tmp = 1UL << 21;
    } else {
#line 40
      tmp = 0UL;
    }
#line 40
    return ((int )tmp);
  }
#line 41
  if (bold) {
#line 41
    tmp___0 = 1UL << 21;
  } else {
#line 41
    tmp___0 = 0UL;
  }
#line 41
  return ((int )((unsigned long )((int )cp << 8) | tmp___0));
}
}
#line 45 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare_ex___2(int fg , int bg ) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 46
  tmp = kurses_width();
  }
#line 46
  w = tmp;
  {
#line 47
  tmp___0 = kurses_height();
  }
  {
#line 47
  kurses_move(0, tmp___0 - 1);
  }
  {
#line 48
  kurses_color(fg, bg);
  }
  }
  {
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 49
    tmp___1 = w;
#line 49
    w --;
#line 49
    if (! tmp___1) {
#line 49
      goto while_break;
    }
    {
    {
#line 49
    waddch(stdscr, (chtype const   )' ');
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 50
  tmp___2 = kurses_height();
  }
  {
#line 50
  kurses_move(0, tmp___2 - 1);
  }
#line 51
  ui_cancel = 0;
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static void ui_prepare___2(void) 
{ 


  {
  {
  {
#line 55
  ui_prepare_ex___2(15, 4);
  }
  }
#line 56
  return;
}
}
#line 60 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___13[32]  ;
#line 74 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char buf___14[256]  ;
#line 91 "/home/wslee/benchmarks/textformat/aewan-1.0.01/ui.c"
static char hexdigit___2[17]  = 
#line 91
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'\000'};
