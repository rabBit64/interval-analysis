/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 66 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_meta_options_29 {
   int byte_limit ;
   int min_frame_seq ;
};
#line 66 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_meta_options_29 meta_options;
#line 82 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_command_flags_30 {
   int aflag ;
   int bflag ;
   int eflag ;
   int fflag ;
   int iflag ;
   int pflag ;
   int qflag ;
   int sflag ;
   int ssflag ;
   int vflag ;
   int vvflag ;
};
#line 82 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_command_flags_30 command_flags;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 178 "/usr/include/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 44 "/usr/include/sys/resource.h"
typedef int __rusage_who_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 19 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_gen_info_27 {
   int file_pos ;
   int good_frame_count ;
   int bad_frame_count ;
   int frame_sequence_count ;
   int byte_count ;
   int next_expected_frame ;
   double time_in_seconds ;
};
#line 19 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_gen_info_27 gen_info;
#line 45 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_vbr_data_28 {
   int high_rate ;
   int low_rate ;
   int sum_rate ;
   int ave_rate ;
};
#line 45 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_vbr_data_28 vbr_data;
#line 56 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_mp3_time_29 {
   int minutes ;
   int seconds ;
   int frac_second ;
};
#line 56 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_mp3_time_29 mp3_time;
#line 104 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_frame_info_32 {
   int FRAME_LENGTH ;
   int FRAME_DATA_LENGTH ;
   int BIT_RATE ;
   int SAMPLE_FREQ ;
   int SAMPLES_PER_FRAME ;
   short MPV_1 ;
   short MPV_2 ;
   short MPV_25 ;
   short MPV_RESERVED ;
   short L1 ;
   short L2 ;
   short L3 ;
   short L_RESERVED ;
   short PROT_BIT ;
   short PAD_BIT ;
   short PRIV_BIT ;
   short STEREO ;
   short JOINT_STEREO ;
   short DUAL_STEREO ;
   short SINGLE_CHANNEL ;
   short MODE_EXTENSION ;
   short ID3V2 ;
   short COPYRIGHT ;
   short ORIGINAL ;
   short EMPH_NONE ;
   short EMPH_5015 ;
   short EMPH_RESERV ;
   short EMPH_CCIT ;
   char BIN_STRING[33] ;
   int INT_HEADER ;
   short CRC16_VALUE ;
   short CORRECT_CRC16_VALUE ;
   short check_state ;
};
#line 104 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_frame_info_32 frame_info;
#line 145 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
struct __anonstruct_id3_tag_info_33 {
   short TAG_PRESENT ;
   short ID3_311_VERSION ;
   char TITLE[31] ;
   char ARTIST[31] ;
   char ALBUM[31] ;
   char YEAR[5] ;
   char COMMENT[31] ;
   short GENRE ;
   short TRACK_NUMBER ;
   short COMPLIANT_PAD_FIELDS ;
};
#line 145 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.h"
typedef struct __anonstruct_id3_tag_info_33 id3_tag_info;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 69 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.c"
int parse_args(char **argv , meta_options *flag_options , command_flags *flags ) ;
#line 70
void print_usage(void) ;
#line 71
void init_command_flags_struct(command_flags *flags ) ;
#line 72
void print_sys_usage(void) ;
#line 74 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check.c"
int main(int argc , char **argv ) 
{ 
  int ch ;
  int got_error ;
  command_flags flags ;
  meta_options flag_options ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 81
  got_error = 0;
  {
#line 85
  init_command_flags_struct(& flags);
  }
  }
  {
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 87
    ch = getopt(argc, (char * const  *)argv, "q:epv::ahs::ib::");
    }
    }
#line 87
    if (! (ch != -1)) {
#line 87
      goto while_break;
    }
    {
#line 89
    if (ch == 113) {
#line 89
      goto case_113;
    }
#line 114
    if (ch == 101) {
#line 114
      goto case_101;
    }
#line 120
    if (ch == 112) {
#line 120
      goto case_112;
    }
#line 126
    if (ch == 118) {
#line 126
      goto case_118;
    }
#line 137
    if (ch == 97) {
#line 137
      goto case_97;
    }
#line 142
    if (ch == 115) {
#line 142
      goto case_115;
    }
#line 159
    if (ch == 105) {
#line 159
      goto case_105;
    }
#line 165
    if (ch == 98) {
#line 165
      goto case_98;
    }
#line 173
    if (ch == 104) {
#line 173
      goto case_104;
    }
#line 178
    goto switch_default;
    case_113: /* CIL Label */ 
    {
    {
#line 103
    tmp = atoi((char const   *)optarg);
    }
    }
#line 103
    if (tmp > 1) {
      {
      {
#line 104
      flag_options.min_frame_seq = atoi((char const   *)optarg);
      }
#line 105
      flags.qflag = 1;
      }
    } else {
      {
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"You must supply an integer greater than 1 to use the \'-q\' flag.");
      }
      }
#line 110
      return (-1);
    }
#line 113
    goto switch_break;
    case_101: /* CIL Label */ 
#line 117
    flags.eflag = 1;
#line 119
    goto switch_break;
    case_112: /* CIL Label */ 
#line 123
    flags.pflag = 1;
#line 125
    goto switch_break;
    case_118: /* CIL Label */ 
#line 128
    flags.vflag = 1;
#line 132
    if (optarg) {
#line 132
      if ((int )*optarg == 118) {
#line 133
        flags.vvflag = 1;
      }
    }
#line 135
    goto switch_break;
    case_97: /* CIL Label */ 
#line 139
    flags.aflag = 1;
#line 140
    goto switch_break;
    case_115: /* CIL Label */ 
#line 144
    flags.sflag = 1;
#line 149
    if (optarg) {
#line 149
      if ((int )*optarg == 115) {
#line 150
        flags.ssflag = 1;
      }
    }
#line 152
    if (optarg) {
#line 152
      if ((int )*optarg == 102) {
#line 153
        flags.fflag = 1;
      }
    }
#line 157
    goto switch_break;
    case_105: /* CIL Label */ 
#line 162
    flags.iflag = 1;
#line 163
    goto switch_break;
    case_98: /* CIL Label */ 
#line 167
    if (optarg) {
      {
      {
#line 168
      flag_options.byte_limit = atoi((char const   *)optarg);
      }
      }
    }
#line 170
    flags.bflag = 1;
#line 171
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 175
    print_usage();
    }
    }
#line 176
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 179
    print_usage();
    }
    }
#line 180
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  argv += optind;
#line 188
  if ((unsigned long )*argv == (unsigned long )((void *)0)) {
    {
    {
#line 189
    print_usage();
    }
    }
  }
#line 200
  if (! flags.vflag) {
#line 200
    if (! flags.aflag) {
#line 200
      if (! flags.bflag) {
#line 201
        flags.aflag = 1;
      }
    }
  }
#line 203
  if (! flags.aflag) {
#line 204
    flags.bflag = 1;
  }
  {
  {
#line 209
  tmp___0 = parse_args(argv, & flag_options, & flags);
  }
  }
#line 209
  if (! tmp___0) {
#line 210
    got_error ++;
  }
#line 212
  if (! flags.sflag) {
    {
    {
#line 213
    print_sys_usage();
    }
    }
  }
#line 220
  if (got_error > 0) {
#line 221
    return (-1);
  } else {
#line 223
    return (0);
  }
}
}
#line 88 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 799
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 67
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 10 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
__inline int cmp_str(char const   *full_str , char const   *chk_str , int full_str_offset ) ;
#line 11
int check_header_value(unsigned int *header , char *filename , frame_info *FI ) ;
#line 12
int check_vbr_and_time(frame_info *mp3_i , vbr_data *vbr_info , gen_info *file_info ) ;
#line 13
int copy_int_array_to_str(char *possible_mp3_tag , char *tag_field , int offset ,
                          int length , int max_length ) ;
#line 14
int dump_id3_tag(id3_tag_info *id3_tag ) ;
#line 15
int get_last_char_offset(char *fat_string ) ;
#line 16
int print_frame_info(frame_info *mp3_i , gen_info *file_info ) ;
#line 17
int rotate_char_array(char *byte_list , int *new_byte , gen_info *file_info ) ;
#line 18
int transform_char_array(char *byte_list , gen_info *file_info ) ;
#line 19
int validate_id3_tag(char *possible_mp3_tag , id3_tag_info *id3_tag ) ;
#line 20
void init_id3_tag_struct(id3_tag_info *TAG ) ;
#line 21
void init_vbr_tag_struct(vbr_data *vbr_info ) ;
#line 22
void init_mp3_time_struct(mp3_time *song_time ) ;
#line 23
void init_gen_info_struct(gen_info *file_info ) ;
#line 25
void translate_time(gen_info *file_info , mp3_time *song_time ) ;
#line 28 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
void init_vbr_tag_struct(vbr_data *vbr_info ) 
{ 


  {
#line 32
  vbr_info->high_rate = 0;
#line 33
  vbr_info->low_rate = 0;
#line 34
  vbr_info->ave_rate = 0;
#line 35
  vbr_info->sum_rate = 0;
#line 36
  return;
}
}
#line 38 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
void init_gen_info_struct(gen_info *file_info ) 
{ 


  {
#line 42
  file_info->file_pos = 0;
#line 43
  file_info->good_frame_count = 0;
#line 44
  file_info->bad_frame_count = 0;
#line 45
  file_info->frame_sequence_count = 0;
#line 46
  file_info->byte_count = 0;
#line 47
  file_info->next_expected_frame = 4;
#line 48
  file_info->time_in_seconds = (double )0;
#line 49
  return;
}
}
#line 51 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
void init_mp3_time_struct(mp3_time *song_time ) 
{ 


  {
#line 55
  song_time->minutes = 0;
#line 56
  song_time->seconds = 0;
#line 57
  song_time->frac_second = 0;
#line 58
  return;
}
}
#line 60 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
__inline int cmp_str(char const   *full_str , char const   *chk_str , int full_str_offset ) 
{ 
  int check_state ;
  int start ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 66
  check_state = 0;
#line 67
  start = 31 - full_str_offset;
  {
#line 69
  tmp = strlen(chk_str);
  }
  {
#line 69
  tmp___0 = memcmp((void const   *)(full_str + start), (void const   *)chk_str, tmp);
  }
  }
#line 69
  if (! tmp___0) {
#line 70
    return (1);
  }
#line 72
  return (check_state);
}
}
#line 75 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int copy_int_array_to_str(char *possible_mp3_tag , char *tag_field , int offset ,
                          int length , int max_length ) 
{ 
  int counter ;
  int position ;

  {
#line 83
  counter = 0;
#line 84
  position = 0;
#line 86
  if (max_length < offset + length) {
#line 87
    return (0);
  }
#line 89
  position = offset;
  {
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 89
    if (! (position < offset + length)) {
#line 89
      goto while_break;
    }
#line 90
    *(tag_field + counter) = *(possible_mp3_tag + position);
#line 91
    counter ++;
#line 89
    position ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (1);
}
}
#line 97 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int validate_id3_tag(char *possible_mp3_tag , id3_tag_info *id3_tag ) 
{ 


  {
#line 109
  if ((int )*(possible_mp3_tag + 0) == 84) {
#line 109
    if ((int )*(possible_mp3_tag + 1) == 65) {
#line 109
      if ((int )*(possible_mp3_tag + 2) == 71) {
#line 110
        id3_tag->TAG_PRESENT = (short)1;
#line 112
        if ((int )*(possible_mp3_tag + 126) != 0) {
#line 113
          id3_tag->TRACK_NUMBER = (short )*(possible_mp3_tag + 126);
#line 114
          id3_tag->ID3_311_VERSION = (short)1;
        } else {
#line 116
          id3_tag->TRACK_NUMBER = (short)0;
#line 117
          id3_tag->ID3_311_VERSION = (short)0;
        }
        {
#line 121
        id3_tag->GENRE = (short )*(possible_mp3_tag + 127);
        {
#line 123
        copy_int_array_to_str(possible_mp3_tag, id3_tag->TITLE, 3, 30, 128);
        }
        {
#line 124
        copy_int_array_to_str(possible_mp3_tag, id3_tag->ARTIST, 33, 30, 128);
        }
        {
#line 125
        copy_int_array_to_str(possible_mp3_tag, id3_tag->ALBUM, 63, 30, 128);
        }
        {
#line 126
        copy_int_array_to_str(possible_mp3_tag, id3_tag->YEAR, 93, 4, 128);
        }
        {
#line 127
        copy_int_array_to_str(possible_mp3_tag, id3_tag->COMMENT, 97, 30, 128);
        }
        }
      } else {
#line 141
        id3_tag->TAG_PRESENT = (short)0;
#line 142
        return (0);
      }
    } else {
#line 141
      id3_tag->TAG_PRESENT = (short)0;
#line 142
      return (0);
    }
  } else {
#line 141
    id3_tag->TAG_PRESENT = (short)0;
#line 142
    return (0);
  }
#line 145
  return (1);
}
}
#line 148 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
void init_id3_tag_struct(id3_tag_info *TAG ) 
{ 


  {
  {
#line 152
  TAG->TAG_PRESENT = (short)0;
#line 153
  TAG->ID3_311_VERSION = (short)0;
  {
#line 155
  memset((void *)(TAG->TITLE), '\000', (size_t )sizeof(TAG->TITLE));
  }
  {
#line 156
  memset((void *)(TAG->ARTIST), '\000', (size_t )sizeof(TAG->ARTIST));
  }
  {
#line 157
  memset((void *)(TAG->ALBUM), '\000', (size_t )sizeof(TAG->ALBUM));
  }
  {
#line 158
  memset((void *)(TAG->YEAR), '\000', (size_t )sizeof(TAG->YEAR));
  }
  {
#line 159
  memset((void *)(TAG->COMMENT), '\000', (size_t )sizeof(TAG->COMMENT));
  }
#line 161
  TAG->GENRE = (short)0;
#line 162
  TAG->TRACK_NUMBER = (short)0;
#line 163
  TAG->COMPLIANT_PAD_FIELDS = (short)0;
  }
#line 164
  return;
}
}
#line 185 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
static int bitrate_matrix[6][16]  = { {        1,        32,        64,        96, 
            128,        160,        192,        224, 
            256,        288,        320,        352, 
            384,        416,        448,        0}, 
   {        1,        32,        48,        56, 
            64,        80,        96,        112, 
            128,        160,        192,        224, 
            256,        320,        384,        0}, 
   {        1,        32,        40,        48, 
            56,        64,        80,        96, 
            112,        128,        160,        192, 
            224,        256,        320,        0}, 
   {        1,        32,        48,        56, 
            64,        80,        96,        112, 
            128,        144,        160,        176, 
            192,        224,        256,        0}, 
   {        1,        8,        16,        24, 
            32,        40,        48,        56, 
            64,        80,        96,        112, 
            128,        144,        160,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0}};
#line 194 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
static int sampling_rate_matrix[4][3]  = { {        44100,        22050,        11025}, 
   {        48000,        24000,        12000}, 
   {        32000,        16000,        8000}, 
   {        0,        0,        0}};
#line 166 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int check_header_value(unsigned int *header , char *filename , frame_info *FI ) 
{ 
  char bin_string[33] ;
  unsigned int tmp ;
  int i ;
  int value_part ;
  int column_part ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 178
  bin_string[0] = (char)0;
#line 178
  tmp = 1U;
  {
  {
#line 178
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 178
    if (tmp >= 33U) {
#line 178
      goto while_break;
    }
#line 178
    bin_string[tmp] = (char)0;
#line 178
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  i = 0;
#line 180
  value_part = 0;
#line 181
  column_part = 0;
#line 208
  FI->check_state = (short)0;
#line 210
  bin_string[32] = (char )'\000';
#line 212
  i = 0;
  {
  {
#line 212
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i < 32)) {
#line 212
      goto while_break___0;
    }
#line 213
    bin_string[i] = (char )'0';
#line 212
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  i = 0;
  {
  {
#line 220
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 220
    if (! (i < 32)) {
#line 220
      goto while_break___1;
    }
#line 221
    if (((*header >> i) & 1U) == 1U) {
#line 222
      bin_string[31 - i] = (char )'1';
    }
#line 220
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 229
  strcpy((char */* __restrict  */)(FI->BIN_STRING), (char const   */* __restrict  */)(bin_string));
  }
#line 230
  FI->INT_HEADER = (int )*header;
  {
#line 238
  tmp___0 = cmp_str((char const   *)(bin_string), "11111111111", 31);
  }
  }
#line 238
  if (tmp___0) {
#line 239
    FI->check_state = (short)1;
  } else {
#line 241
    return ((int )FI->check_state);
  }
  {
  {
#line 247
  tmp___4 = cmp_str((char const   *)(bin_string), "00", 20);
  }
  }
#line 247
  if (tmp___4) {
#line 248
    FI->MPV_25 = (short)1;
  } else {
    {
    {
#line 250
    tmp___3 = cmp_str((char const   *)(bin_string), "01", 20);
    }
    }
#line 250
    if (tmp___3) {
#line 251
      FI->MPV_RESERVED = (short)1;
    } else {
      {
      {
#line 253
      tmp___2 = cmp_str((char const   *)(bin_string), "10", 20);
      }
      }
#line 253
      if (tmp___2) {
#line 254
        FI->MPV_2 = (short)1;
      } else {
        {
        {
#line 256
        tmp___1 = cmp_str((char const   *)(bin_string), "11", 20);
        }
        }
#line 256
        if (tmp___1) {
#line 257
          FI->MPV_1 = (short)1;
        }
      }
    }
  }
  {
  {
#line 263
  tmp___8 = cmp_str((char const   *)(bin_string), "00", 18);
  }
  }
#line 263
  if (tmp___8) {
#line 264
    FI->L_RESERVED = (short)1;
#line 265
    FI->SAMPLES_PER_FRAME = 0;
  } else {
    {
    {
#line 267
    tmp___7 = cmp_str((char const   *)(bin_string), "01", 18);
    }
    }
#line 267
    if (tmp___7) {
#line 268
      FI->L3 = (short)1;
#line 269
      FI->SAMPLES_PER_FRAME = 1152;
    } else {
      {
      {
#line 271
      tmp___6 = cmp_str((char const   *)(bin_string), "10", 18);
      }
      }
#line 271
      if (tmp___6) {
#line 272
        FI->L2 = (short)1;
#line 273
        FI->SAMPLES_PER_FRAME = 1152;
      } else {
        {
        {
#line 275
        tmp___5 = cmp_str((char const   *)(bin_string), "11", 18);
        }
        }
#line 275
        if (tmp___5) {
#line 276
          FI->L1 = (short)1;
#line 277
          FI->SAMPLES_PER_FRAME = 384;
        }
      }
    }
  }
  {
  {
#line 284
  tmp___9 = cmp_str((char const   *)(bin_string), "0", 16);
  }
  }
#line 284
  if (tmp___9) {
#line 285
    FI->PROT_BIT = (short)1;
  }
#line 297
  value_part = (int )((*header >> 12) & 15U);
#line 300
  if (FI->MPV_1) {
#line 300
    if (FI->L1) {
#line 301
      column_part = 0;
    } else {
#line 300
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 303
  if (FI->MPV_1) {
#line 303
    if (FI->L2) {
#line 304
      column_part = 1;
    } else {
#line 303
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 306
  if (FI->MPV_1) {
#line 306
    if (FI->L3) {
#line 307
      column_part = 2;
    } else {
#line 306
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 309
  if (FI->MPV_2) {
#line 309
    goto _L___1;
  } else
#line 309
  if (FI->MPV_25) {
    _L___1: /* CIL Label */ 
#line 309
    if (FI->L1) {
#line 310
      column_part = 3;
    } else {
#line 309
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 312
  if (FI->MPV_2) {
#line 312
    goto _L;
  } else
#line 312
  if (FI->MPV_25) {
    _L: /* CIL Label */ 
#line 312
    if (FI->L2) {
#line 313
      column_part = 4;
    } else
#line 312
    if (FI->L3) {
#line 313
      column_part = 4;
    } else {
#line 316
      column_part = 5;
    }
  } else {
#line 316
    column_part = 5;
  }
#line 319
  FI->BIT_RATE = bitrate_matrix[column_part][value_part];
#line 328
  value_part = (int )((*header >> 10) & 3U);
#line 330
  if (FI->MPV_1) {
#line 331
    FI->SAMPLE_FREQ = sampling_rate_matrix[value_part][0];
  } else
#line 333
  if (FI->MPV_2) {
#line 334
    FI->SAMPLE_FREQ = sampling_rate_matrix[value_part][1];
  } else
#line 336
  if (FI->MPV_25) {
#line 337
    FI->SAMPLE_FREQ = sampling_rate_matrix[value_part][2];
  } else {
#line 340
    FI->SAMPLE_FREQ = 0;
  }
  {
  {
#line 346
  tmp___10 = cmp_str((char const   *)(bin_string), "1", 9);
  }
  }
#line 346
  if (tmp___10) {
#line 347
    FI->PAD_BIT = (short)1;
  }
  {
  {
#line 353
  tmp___11 = cmp_str((char const   *)(bin_string), "1", 8);
  }
  }
#line 353
  if (tmp___11) {
#line 354
    FI->PRIV_BIT = (short)1;
  }
  {
  {
#line 363
  tmp___15 = cmp_str((char const   *)(bin_string), "00", 7);
  }
  }
#line 363
  if (tmp___15) {
#line 364
    FI->STEREO = (short)1;
  } else {
    {
    {
#line 366
    tmp___14 = cmp_str((char const   *)(bin_string), "01", 7);
    }
    }
#line 366
    if (tmp___14) {
#line 368
      FI->JOINT_STEREO = (short)1;
#line 369
      FI->MODE_EXTENSION = (short)1;
    } else {
      {
      {
#line 372
      tmp___13 = cmp_str((char const   *)(bin_string), "10", 7);
      }
      }
#line 372
      if (tmp___13) {
#line 373
        FI->DUAL_STEREO = (short)1;
      } else {
        {
        {
#line 375
        tmp___12 = cmp_str((char const   *)(bin_string), "11", 7);
        }
        }
#line 375
        if (tmp___12) {
#line 376
          FI->SINGLE_CHANNEL = (short)1;
        }
      }
    }
  }
  {
  {
#line 382
  tmp___16 = cmp_str((char const   *)(bin_string), "1", 3);
  }
  }
#line 382
  if (tmp___16) {
#line 383
    FI->COPYRIGHT = (short)1;
  }
  {
  {
#line 389
  tmp___17 = cmp_str((char const   *)(bin_string), "1", 2);
  }
  }
#line 389
  if (tmp___17) {
#line 390
    FI->ORIGINAL = (short)1;
  }
  {
  {
#line 396
  tmp___21 = cmp_str((char const   *)(bin_string), "00", 1);
  }
  }
#line 396
  if (tmp___21) {
#line 397
    FI->EMPH_NONE = (short)1;
  } else {
    {
    {
#line 399
    tmp___20 = cmp_str((char const   *)(bin_string), "01", 1);
    }
    }
#line 399
    if (tmp___20) {
#line 400
      FI->EMPH_5015 = (short)1;
    } else {
      {
      {
#line 402
      tmp___19 = cmp_str((char const   *)(bin_string), "10", 1);
      }
      }
#line 402
      if (tmp___19) {
#line 403
        FI->EMPH_RESERV = (short)1;
      } else {
        {
        {
#line 405
        tmp___18 = cmp_str((char const   *)(bin_string), "11", 1);
        }
        }
#line 405
        if (tmp___18) {
#line 406
          FI->EMPH_CCIT = (short)1;
        }
      }
    }
  }
#line 412
  if (FI->SAMPLE_FREQ > 0) {
#line 413
    if (FI->MPV_1) {
#line 414
      if (FI->L1) {
#line 414
        if ((int )FI->PAD_BIT == 1) {
#line 415
          FI->FRAME_LENGTH = (((12 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ + 4) * 4;
        } else {
#line 414
          goto _L___9;
        }
      } else
      _L___9: /* CIL Label */ 
#line 417
      if (FI->L1) {
#line 417
        if ((int )FI->PAD_BIT == 0) {
#line 418
          FI->FRAME_LENGTH = (((12 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ) * 4;
        } else {
#line 417
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 420
      if (FI->L2) {
#line 420
        goto _L___7;
      } else
#line 420
      if (FI->L3) {
        _L___7: /* CIL Label */ 
#line 420
        if ((int )FI->PAD_BIT == 1) {
#line 421
          FI->FRAME_LENGTH = ((144 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ + 1;
        } else {
#line 420
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 423
      if (FI->L2) {
#line 423
        goto _L___5;
      } else
#line 423
      if (FI->L3) {
        _L___5: /* CIL Label */ 
#line 423
        if ((int )FI->PAD_BIT == 0) {
#line 424
          FI->FRAME_LENGTH = ((144 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ;
        }
      }
    } else
#line 426
    if (FI->MPV_2) {
#line 426
      goto _L___15;
    } else
#line 426
    if (FI->MPV_25) {
      _L___15: /* CIL Label */ 
#line 427
      if (FI->L1) {
#line 427
        if ((int )FI->PAD_BIT == 1) {
#line 428
          FI->FRAME_LENGTH = (((240 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ + 4) * 4;
        } else {
#line 427
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 430
      if (FI->L1) {
#line 430
        if ((int )FI->PAD_BIT == 0) {
#line 431
          FI->FRAME_LENGTH = (((240 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ) * 4;
        } else {
#line 430
          goto _L___13;
        }
      } else
      _L___13: /* CIL Label */ 
#line 433
      if (FI->L2) {
#line 433
        goto _L___12;
      } else
#line 433
      if (FI->L3) {
        _L___12: /* CIL Label */ 
#line 433
        if ((int )FI->PAD_BIT == 1) {
#line 434
          FI->FRAME_LENGTH = ((72 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ + 1;
        } else {
#line 433
          goto _L___11;
        }
      } else
      _L___11: /* CIL Label */ 
#line 436
      if (FI->L2) {
#line 436
        goto _L___10;
      } else
#line 436
      if (FI->L3) {
        _L___10: /* CIL Label */ 
#line 436
        if ((int )FI->PAD_BIT == 0) {
#line 437
          FI->FRAME_LENGTH = ((72 * FI->BIT_RATE) * 1000) / FI->SAMPLE_FREQ;
        }
      }
    }
  } else {
#line 441
    FI->FRAME_LENGTH = 0;
  }
#line 450
  if (FI->L_RESERVED) {
#line 451
    FI->check_state = (short)0;
  } else
#line 450
  if (FI->BIT_RATE == 0) {
#line 451
    FI->check_state = (short)0;
  } else
#line 450
  if (FI->BIT_RATE == 1) {
#line 451
    FI->check_state = (short)0;
  } else
#line 450
  if (FI->SAMPLE_FREQ == 0) {
#line 451
    FI->check_state = (short)0;
  } else
#line 453
  if (FI->L2) {
#line 453
    if (FI->BIT_RATE == 32) {
#line 453
      if ((int )FI->SINGLE_CHANNEL == 0) {
#line 454
        FI->check_state = (short)0;
      } else {
#line 453
        goto _L___31;
      }
    } else {
#line 453
      goto _L___31;
    }
  } else
  _L___31: /* CIL Label */ 
#line 456
  if (FI->L2) {
#line 456
    if (FI->BIT_RATE == 48) {
#line 456
      if ((int )FI->SINGLE_CHANNEL == 0) {
#line 457
        FI->check_state = (short)0;
      } else {
#line 456
        goto _L___29;
      }
    } else {
#line 456
      goto _L___29;
    }
  } else
  _L___29: /* CIL Label */ 
#line 459
  if (FI->L2) {
#line 459
    if (FI->BIT_RATE == 56) {
#line 459
      if ((int )FI->SINGLE_CHANNEL == 0) {
#line 460
        FI->check_state = (short)0;
      } else {
#line 459
        goto _L___27;
      }
    } else {
#line 459
      goto _L___27;
    }
  } else
  _L___27: /* CIL Label */ 
#line 462
  if (FI->L2) {
#line 462
    if (FI->BIT_RATE == 80) {
#line 462
      if ((int )FI->SINGLE_CHANNEL == 0) {
#line 463
        FI->check_state = (short)0;
      } else {
#line 462
        goto _L___25;
      }
    } else {
#line 462
      goto _L___25;
    }
  } else
  _L___25: /* CIL Label */ 
#line 465
  if (FI->L2) {
#line 465
    if (FI->BIT_RATE == 32) {
#line 465
      if ((int )FI->SINGLE_CHANNEL == 0) {
#line 466
        FI->check_state = (short)0;
      } else {
#line 465
        goto _L___23;
      }
    } else {
#line 465
      goto _L___23;
    }
  } else
  _L___23: /* CIL Label */ 
#line 468
  if (FI->L2) {
#line 468
    if (FI->BIT_RATE == 224) {
#line 468
      if (FI->STEREO) {
#line 468
        goto _L___21;
      } else
#line 468
      if (FI->DUAL_STEREO) {
#line 468
        goto _L___21;
      } else {
#line 469
        FI->check_state = (short)0;
      }
    } else {
#line 468
      goto _L___21;
    }
  } else
  _L___21: /* CIL Label */ 
#line 471
  if (FI->L2) {
#line 471
    if (FI->BIT_RATE == 256) {
#line 471
      if (FI->STEREO) {
#line 471
        goto _L___19;
      } else
#line 471
      if (FI->DUAL_STEREO) {
#line 471
        goto _L___19;
      } else {
#line 472
        FI->check_state = (short)0;
      }
    } else {
#line 471
      goto _L___19;
    }
  } else
  _L___19: /* CIL Label */ 
#line 474
  if (FI->L2) {
#line 474
    if (FI->BIT_RATE == 320) {
#line 474
      if (FI->STEREO) {
#line 474
        goto _L___17;
      } else
#line 474
      if (FI->DUAL_STEREO) {
#line 474
        goto _L___17;
      } else {
#line 475
        FI->check_state = (short)0;
      }
    } else {
#line 474
      goto _L___17;
    }
  } else
  _L___17: /* CIL Label */ 
#line 477
  if (FI->L2) {
#line 477
    if (FI->BIT_RATE == 384) {
#line 477
      if (! FI->STEREO) {
#line 477
        if (! FI->DUAL_STEREO) {
#line 478
          FI->check_state = (short)0;
        }
      }
    }
  }
#line 481
  return ((int )FI->check_state);
}
}
#line 484 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
void print_sys_usage(void) 
{ 
  struct rusage process_usage ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 489
  tmp = getrusage(0, & process_usage);
  }
  }
#line 489
  if (tmp) {
    {
    {
#line 490
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not get system usage for myself.");
    }
    }
  } else {
    {
    {
#line 492
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 493
    printf((char const   */* __restrict  */)"%-20s%1ld.%02lds\n", "USER_TIME", process_usage.ru_utime.tv_sec,
           process_usage.ru_utime.tv_usec / 10000L);
    }
    {
#line 494
    printf((char const   */* __restrict  */)"%-20s%1ld.%02lds\n", "SYS_TIME", process_usage.ru_stime.tv_sec,
           process_usage.ru_stime.tv_usec / 10000L);
    }
    }
  }
#line 496
  return;
}
}
#line 498 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int rotate_char_array(char *byte_list , int *new_byte , gen_info *file_info ) 
{ 
  int place_holder ;

  {
#line 504
  place_holder = 0;
#line 507
  place_holder = file_info->byte_count % 128;
#line 509
  *(byte_list + place_holder) = (char )*new_byte;
#line 511
  return (1);
}
}
#line 514 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int transform_char_array(char *byte_list , gen_info *file_info ) 
{ 
  int place_holder ;
  int counter ;
  char trans_list[128] ;
  unsigned int tmp ;
  void *__cil_tmp7 ;

  {
#line 519
  place_holder = 0;
#line 521
  trans_list[0] = (char )'*';
#line 521
  tmp = 1U;
  {
  {
#line 521
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 521
    if (tmp >= 128U) {
#line 521
      goto while_break;
    }
#line 521
    trans_list[tmp] = (char)0;
#line 521
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  place_holder = file_info->byte_count % 128 + 1;
#line 531
  counter = place_holder;
  {
  {
#line 531
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 531
    if (! (counter < 128)) {
#line 531
      goto while_break___0;
    }
#line 532
    *(trans_list + (counter - place_holder)) = *(byte_list + counter);
#line 531
    counter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 535
  counter = 0;
  {
  {
#line 535
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 535
    if (! (counter < place_holder)) {
#line 535
      goto while_break___1;
    }
#line 536
    *(trans_list + ((128 - place_holder) + counter)) = *(byte_list + counter);
#line 535
    counter ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 538
  memcpy((void */* __restrict  */)byte_list, (void const   */* __restrict  */)(trans_list),
         (size_t )128);
  }
  }
#line 540
  return (1);
}
}
#line 543 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
void translate_time(gen_info *file_info , mp3_time *song_time ) 
{ 
  double float_minute ;
  double float_second ;

  {
#line 548
  float_minute = 0.0;
#line 549
  float_second = 0.0;
#line 551
  float_minute = file_info->time_in_seconds / 60.0;
#line 552
  float_second = 60.0 * (float_minute - (double )((int )float_minute));
#line 555
  song_time->frac_second = (int )(100.0 * (float_second - (double )((int )float_second)));
#line 556
  song_time->minutes = (int )float_minute;
#line 557
  song_time->seconds = (int )float_second;
#line 558
  return;
}
}
#line 560 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int dump_id3_tag(id3_tag_info *id3_tag ) 
{ 
  char title[30] ;
  char artist[30] ;
  char album[30] ;
  char year[4] ;
  char comment[30] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 569
  i = 0;
  {
#line 572
  memset((void *)(title), '\000', (size_t )sizeof(title));
  }
  {
#line 573
  memset((void *)(artist), '\000', (size_t )sizeof(artist));
  }
  {
#line 574
  memset((void *)(album), '\000', (size_t )sizeof(album));
  }
  {
#line 575
  memset((void *)(year), '\000', (size_t )sizeof(year));
  }
  {
#line 576
  memset((void *)(comment), '\000', (size_t )sizeof(comment));
  }
  {
#line 581
  tmp = get_last_char_offset(id3_tag->TITLE);
  }
  {
#line 581
  strncpy((char */* __restrict  */)(title), (char const   */* __restrict  */)(id3_tag->TITLE),
          (size_t )tmp);
  }
  {
#line 582
  tmp___0 = get_last_char_offset(id3_tag->ARTIST);
  }
  {
#line 582
  strncpy((char */* __restrict  */)(artist), (char const   */* __restrict  */)(id3_tag->ARTIST),
          (size_t )tmp___0);
  }
  {
#line 583
  tmp___1 = get_last_char_offset(id3_tag->ALBUM);
  }
  {
#line 583
  strncpy((char */* __restrict  */)(album), (char const   */* __restrict  */)(id3_tag->ALBUM),
          (size_t )tmp___1);
  }
  {
#line 584
  tmp___2 = get_last_char_offset(id3_tag->YEAR);
  }
  {
#line 584
  strncpy((char */* __restrict  */)(year), (char const   */* __restrict  */)(id3_tag->YEAR),
          (size_t )tmp___2);
  }
  {
#line 585
  tmp___3 = get_last_char_offset(id3_tag->COMMENT);
  }
  {
#line 585
  strncpy((char */* __restrict  */)(comment), (char const   */* __restrict  */)(id3_tag->COMMENT),
          (size_t )tmp___3);
  }
  {
#line 596
  fputs((char const   */* __restrict  */)"TAG", (FILE */* __restrict  */)stdout);
  }
#line 598
  i = 0;
  }
  {
  {
#line 598
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 598
    if (! (i < 30)) {
#line 598
      goto while_break;
    }
    {
    {
#line 599
    fputc((int )*(title + i), stdout);
    }
#line 598
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 601
  i = 0;
  {
  {
#line 601
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 601
    if (! (i < 30)) {
#line 601
      goto while_break___0;
    }
    {
    {
#line 602
    fputc((int )*(artist + i), stdout);
    }
#line 601
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 604
  i = 0;
  {
  {
#line 604
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 604
    if (! (i < 30)) {
#line 604
      goto while_break___1;
    }
    {
    {
#line 605
    fputc((int )*(album + i), stdout);
    }
#line 604
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 607
  i = 0;
  {
  {
#line 607
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 607
    if (! (i < 4)) {
#line 607
      goto while_break___2;
    }
    {
    {
#line 608
    fputc((int )*(year + i), stdout);
    }
#line 607
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 614
  i = 0;
  {
  {
#line 614
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 614
    if (! (i < 29)) {
#line 614
      goto while_break___3;
    }
    {
    {
#line 615
    fputc((int )*(comment + i), stdout);
    }
#line 614
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 617
  if ((int )id3_tag->TRACK_NUMBER != 0) {
    {
    {
#line 618
    fputc((int )id3_tag->TRACK_NUMBER, stdout);
    }
    }
  } else {
    {
    {
#line 620
    fputc((int )*(comment + 29), stdout);
    }
    }
  }
  {
  {
#line 623
  fputc((int )id3_tag->GENRE, stdout);
  }
  }
#line 625
  return (1);
}
}
#line 628 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int get_last_char_offset(char *fat_string ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 632
  i = 0;
  {
#line 634
  tmp = strlen((char const   *)fat_string);
  }
#line 634
  i = (int )(tmp - 1U);
  }
  {
  {
#line 634
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 634
    if (! (i >= 0)) {
#line 634
      goto while_break;
    }
    {
    {
#line 635
    tmp___0 = __ctype_b_loc();
    }
    }
#line 635
    if ((int const   )*(*tmp___0 + (int )*(fat_string + i)) & 32768) {
#line 636
      return (i + 1);
    }
#line 634
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 639
  tmp___1 = strlen((char const   *)fat_string);
  }
  }
#line 639
  return ((int )tmp___1);
}
}
#line 642 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int check_vbr_and_time(frame_info *mp3_i , vbr_data *vbr_info , gen_info *file_info ) 
{ 


  {
#line 652
  file_info->time_in_seconds += ((double )mp3_i->SAMPLES_PER_FRAME * 1.0) / ((double )mp3_i->SAMPLE_FREQ * 1.0);
#line 657
  if (vbr_info->high_rate < mp3_i->BIT_RATE) {
#line 658
    vbr_info->high_rate = mp3_i->BIT_RATE;
  }
#line 660
  if (mp3_i->BIT_RATE < vbr_info->low_rate) {
#line 661
    vbr_info->low_rate = mp3_i->BIT_RATE;
  } else
#line 660
  if (vbr_info->low_rate == 0) {
#line 661
    vbr_info->low_rate = mp3_i->BIT_RATE;
  }
#line 665
  vbr_info->sum_rate += mp3_i->BIT_RATE;
#line 667
  return (1);
}
}
#line 670 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
int print_frame_info(frame_info *mp3_i , gen_info *file_info ) 
{ 
  size_t tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 675
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 676
  printf((char const   */* __restrict  */)"%-20s%d\n", "FRAME", file_info->good_frame_count);
  }
  {
#line 677
  printf((char const   */* __restrict  */)"%-20s%d\n", "FrameOffset", file_info->byte_count);
  }
  {
#line 678
  printf((char const   */* __restrict  */)"%-20s%d\n", "FrameLength", mp3_i->FRAME_LENGTH);
  }
  {
#line 679
  printf((char const   */* __restrict  */)"%-20s%d\n", "FrameDataLength", mp3_i->FRAME_DATA_LENGTH);
  }
  {
#line 680
  printf((char const   */* __restrict  */)"%-20s%d\n", "BitRate", mp3_i->BIT_RATE);
  }
  {
#line 681
  printf((char const   */* __restrict  */)"%-20s%d\n", "SampRate", mp3_i->SAMPLE_FREQ);
  }
  {
#line 682
  printf((char const   */* __restrict  */)"%-20s%s\n", "BinString", mp3_i->BIN_STRING);
  }
  {
#line 683
  tmp = strlen((char const   *)(mp3_i->BIN_STRING));
  }
  {
#line 683
  printf((char const   */* __restrict  */)"%-20s%lu\n", "BinLen", (unsigned long )tmp);
  }
  {
#line 684
  printf((char const   */* __restrict  */)"%-20s%u\n", "IntHeader", mp3_i->INT_HEADER);
  }
  {
#line 688
  printf((char const   */* __restrict  */)"%-20s%d\n", "NEXT_FRAME", file_info->byte_count + mp3_i->FRAME_LENGTH);
  }
  }
#line 690
  return (1);
}
}
#line 14 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
__inline int move_to_next_frame(char *possible_mp3_tag , frame_info *mp3_i , gen_info *file_info ,
                                command_flags *flags , FILE *fp ) ;
#line 15
int get_char_from_file(FILE *fp , unsigned int *header_value , gen_info *file_info ,
                       command_flags *flags , char *possible_mp3_tag ) ;
#line 16
int scan_file(FILE *fp , char *filename , meta_options *flag_options , command_flags *flags ) ;
#line 18
int crc_check_frame(char *data_frame , frame_info *mp3_i ) ;
#line 20
void init_frame_struct(frame_info *FI ) ;
#line 21
void print_summary(frame_info mp3_i , char *filename ) ;
#line 40 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
int scan_file(FILE *fp , char *filename , meta_options *flag_options , command_flags *flags ) 
{ 
  int counter ;
  int END_OF_FILE ;
  int found_first_frame ;
  char possible_mp3_tag[128] ;
  unsigned int header_value ;
  char found_valid_header ;
  char found_weak_header ;
  frame_info mp3_i ;
  vbr_data vbr_info ;
  mp3_time song_time ;
  frame_info first_mp3_frame ;
  id3_tag_info id3_tag ;
  gen_info file_info ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;

  {
  {
#line 47
  counter = 0;
#line 48
  END_OF_FILE = 0;
#line 49
  found_first_frame = 0;
#line 51
  header_value = 0U;
#line 56
  found_valid_header = (char)1;
#line 57
  found_weak_header = (char)0;
  {
#line 70
  init_frame_struct(& first_mp3_frame);
  }
  {
#line 71
  init_vbr_tag_struct(& vbr_info);
  }
  {
#line 72
  init_gen_info_struct(& file_info);
  }
  }
  {
  {
#line 75
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 75
    if (! (! END_OF_FILE)) {
#line 75
      goto while_break;
    }
#line 76
    if (flags->bflag) {
#line 76
      goto _L;
    } else
#line 76
    if (flags->aflag) {
      _L: /* CIL Label */ 
#line 82
      if (flags->bflag) {
#line 82
        if (file_info.byte_count > flag_options->byte_limit) {
#line 83
          goto while_break;
        }
      }
    }
#line 95
    if (! found_valid_header) {
      {
      {
#line 103
      tmp = get_char_from_file(fp, & header_value, & file_info, flags, possible_mp3_tag);
      }
      }
#line 103
      if (tmp) {
#line 104
        if (! flags->ssflag) {
#line 104
          if (flags->sflag) {
#line 104
            if (! flags->fflag) {
              {
              {
#line 105
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                      header_value & 255U);
              }
              }
            }
          }
        }
      } else {
#line 108
        goto while_break;
      }
    } else {
#line 111
      header_value = 0U;
#line 115
      counter = 0;
      {
      {
#line 115
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 115
        if (! (counter < 4)) {
#line 115
          goto while_break___0;
        }
        {
        {
#line 116
        tmp___0 = get_char_from_file(fp, & header_value, & file_info, flags, possible_mp3_tag);
        }
        }
#line 116
        if (tmp___0) {
#line 117
          if (! flags->ssflag) {
#line 117
            if (flags->sflag) {
#line 117
              if (! flags->fflag) {
                {
                {
#line 118
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                        header_value & 255U);
                }
                }
              }
            }
          }
        } else {
#line 121
          goto while_break___0;
        }
#line 115
        counter ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 129
    if (((header_value >> 21) & 2047U) == 2047U) {
      {
#line 131
      found_weak_header = (char)1;
      {
#line 133
      init_frame_struct(& mp3_i);
      }
      {
#line 135
      tmp___3 = check_header_value(& header_value, filename, & mp3_i);
      }
      }
#line 135
      if (tmp___3) {
#line 136
        found_valid_header = (char)1;
#line 144
        if (file_info.good_frame_count > 0) {
#line 144
          if (file_info.next_expected_frame != file_info.byte_count) {
            {
#line 145
            (file_info.bad_frame_count) ++;
            {
#line 152
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAn expected frame was not found. Expected it at offset 0x%x (BYTE %d), now at offset 0x%x (BYTE %d).",
                    file_info.next_expected_frame, file_info.next_expected_frame,
                    file_info.byte_count, file_info.byte_count);
            }
            }
#line 158
            if (flags->qflag) {
#line 158
              if (file_info.frame_sequence_count > 0) {
#line 158
                if (flag_options->min_frame_seq > file_info.frame_sequence_count) {
                  {
                  {
#line 159
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMininum contiguous number of frames wasn\'t reached. Got to %d, needed %d at offset 0x%x (BYTE %d).",
                          file_info.frame_sequence_count, flag_options->min_frame_seq,
                          file_info.next_expected_frame, file_info.next_expected_frame);
                  }
#line 162
                  file_info.frame_sequence_count = 0;
                  }
                }
              }
            }
          } else {
#line 144
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 165
        if (file_info.next_expected_frame == file_info.byte_count) {
#line 166
          (file_info.good_frame_count) ++;
#line 167
          (file_info.frame_sequence_count) ++;
        } else {
          {
          {
#line 169
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nSomething happened at byte %d. Next expected frame: %d.\n",
                  file_info.byte_count, file_info.next_expected_frame);
          }
          }
        }
#line 180
        if (! flags->ssflag) {
#line 180
          if (flags->sflag) {
#line 180
            if (flags->fflag) {
              {
              {
#line 181
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c%c%c%c",
                      (header_value >> 24) & 255U, (header_value >> 16) & 255U, (header_value >> 8) & 255U,
                      header_value & 255U);
              }
              }
            }
          }
        }
#line 192
        if (mp3_i.PROT_BIT) {
#line 194
          counter = 0;
          {
          {
#line 194
          while (1) {
            while_continue___6: /* CIL Label */ ;
            while_continue___1: /* CIL Label */ ;
#line 194
            if (! (counter < 2)) {
#line 194
              goto while_break___1;
            }
            {
            {
#line 195
            tmp___1 = get_char_from_file(fp, & header_value, & file_info, flags, possible_mp3_tag);
            }
            }
#line 195
            if (tmp___1) {
#line 196
              if (! flags->ssflag) {
#line 196
                if (flags->sflag) {
#line 196
                  if (! flags->fflag) {
                    {
                    {
#line 197
                    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                            header_value & 255U);
                    }
                    }
                  }
                }
              }
            } else {
#line 200
              goto while_break___1;
            }
#line 194
            counter ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 205
          mp3_i.CRC16_VALUE = (short )(header_value & 65535U);
#line 215
          if (! flags->ssflag) {
#line 215
            if (flags->sflag) {
#line 215
              if (flags->fflag) {
                {
                {
#line 216
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c%c",
                        (header_value >> 8) & 255U, header_value & 255U);
                }
                }
              }
            }
          }
        }
        {
        {
#line 228
        check_vbr_and_time(& mp3_i, & vbr_info, & file_info);
        }
        }
#line 242
        if (file_info.good_frame_count > 0) {
#line 243
          first_mp3_frame = mp3_i;
#line 244
          found_first_frame = 1;
        }
#line 249
        if (! flags->sflag) {
#line 249
          if (flags->vvflag) {
#line 249
            if (file_info.good_frame_count > 0) {
              {
              {
#line 250
              print_frame_info(& mp3_i, & file_info);
              }
              }
            }
          }
        }
#line 257
        if (mp3_i.PROT_BIT) {
#line 258
          file_info.next_expected_frame = (file_info.byte_count + mp3_i.FRAME_LENGTH) - 2;
        } else {
#line 260
          file_info.next_expected_frame = file_info.byte_count + mp3_i.FRAME_LENGTH;
        }
#line 265
        if (flags->aflag) {
#line 265
          goto _L___1;
        } else
#line 265
        if (flags->bflag) {
#line 265
          if (flag_options->byte_limit > 0) {
            _L___1: /* CIL Label */ 
            {
            {
#line 266
            tmp___2 = move_to_next_frame(possible_mp3_tag, & mp3_i, & file_info, flags,
                                         fp);
            }
            }
#line 266
            if (! tmp___2) {
#line 267
              goto while_break;
            }
          } else {
#line 270
            goto while_break;
          }
        } else {
#line 270
          goto while_break;
        }
      } else {
#line 278
        (file_info.bad_frame_count) ++;
#line 280
        if (flags->vflag) {
          {
          {
#line 281
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nA possible header 0x%x passed the weak sieve, but failed the strong one at offset 0x%x (BYTE %d).",
                  header_value, file_info.byte_count, file_info.byte_count);
          }
          }
        }
#line 285
        if (flags->qflag) {
#line 285
          if (file_info.frame_sequence_count > 0) {
#line 285
            if (flag_options->min_frame_seq > file_info.frame_sequence_count) {
              {
              {
#line 286
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMininum contiguous number of frames wasn\'t reached. Got to %d, needed %d at offset 0x%x (BYTE %d).",
                      file_info.frame_sequence_count, flag_options->min_frame_seq,
                      file_info.next_expected_frame, file_info.next_expected_frame);
              }
#line 289
              file_info.frame_sequence_count = 0;
              }
            }
          }
        }
      }
    } else
#line 293
    if (file_info.file_pos == 4) {
#line 293
      if ((header_value & 4294967040U) == 1229206272U) {
        {
        {
#line 297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Possible ID3v2 frame found, skipping\n");
        }
#line 304
        mp3_i.ID3V2 = (short)1;
        }
#line 306
        if (flags->eflag) {
#line 307
          if (flags->qflag) {
#line 307
            if (file_info.frame_sequence_count > 0) {
#line 307
              if (flag_options->min_frame_seq > file_info.frame_sequence_count) {
                {
                {
#line 308
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nMininum contiguous number of frames wasn\'t reached. Got to %d, needed %d at offset 0x%x (BYTE %d).",
                        file_info.frame_sequence_count, flag_options->min_frame_seq,
                        file_info.next_expected_frame, file_info.next_expected_frame);
                }
#line 311
                file_info.frame_sequence_count = 0;
                }
              }
            }
          }
#line 314
          (file_info.bad_frame_count) ++;
        }
#line 322
        counter = 0;
        {
        {
#line 322
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 322
          if (! (counter < 6)) {
#line 322
            goto while_break___2;
          }
          {
          {
#line 323
          tmp___4 = get_char_from_file(fp, & header_value, & file_info, flags, possible_mp3_tag);
          }
          }
#line 323
          if (tmp___4) {
#line 324
            if (! flags->ssflag) {
#line 324
              if (flags->sflag) {
#line 324
                if (! flags->fflag) {
                  {
                  {
#line 325
                  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                          header_value & 255U);
                  }
                  }
                }
              }
            }
          } else {
#line 328
            goto while_break___2;
          }
#line 322
          counter ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 333
        counter = (int )(((((header_value >> 3) & 266338304U) | ((header_value >> 2) & 2080768U)) | ((header_value >> 1) & 16256U)) | (header_value & 127U));
#line 343
        file_info.next_expected_frame = counter + 14;
        {
        {
#line 346
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 346
          tmp___6 = counter;
#line 346
          counter --;
#line 346
          if (! (tmp___6 > 0)) {
#line 346
            goto while_break___3;
          }
          {
          {
#line 347
          tmp___5 = get_char_from_file(fp, & header_value, & file_info, flags, possible_mp3_tag);
          }
          }
#line 347
          if (tmp___5) {
#line 348
            if (! flags->ssflag) {
#line 348
              if (flags->sflag) {
#line 348
                if (! flags->fflag) {
                  {
                  {
#line 349
                  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                          header_value & 255U);
                  }
                  }
                }
              }
            }
          } else {
#line 352
            goto while_break___3;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 357
        found_valid_header = (char)1;
#line 358
        found_weak_header = (char)0;
      } else {
#line 363
        found_valid_header = (char)0;
#line 364
        found_weak_header = (char)0;
      }
    } else {
#line 363
      found_valid_header = (char)0;
#line 364
      found_weak_header = (char)0;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (! flags->sflag) {
#line 370
    if (flags->pflag) {
      {
      {
#line 371
      printf((char const   */* __restrict  */)"%s %s\t%s %d\t%s %d\t%s %d", "FILE_NAME",
             filename, "GOOD_FRAMES", file_info.good_frame_count, "BAD_FRAMES", file_info.bad_frame_count,
             "LAST_BYTE_CHECKED", file_info.byte_count);
      }
      }
    } else {
      {
      {
#line 373
      printf((char const   */* __restrict  */)"\n");
      }
      {
#line 374
      printf((char const   */* __restrict  */)"%-20s%s\n", "FILE_NAME", filename);
      }
      {
#line 375
      printf((char const   */* __restrict  */)"%-20s%d\n", "GOOD_FRAMES", file_info.good_frame_count);
      }
      {
#line 376
      printf((char const   */* __restrict  */)"%-20s%d\n", "BAD_FRAMES", file_info.bad_frame_count);
      }
      {
#line 377
      printf((char const   */* __restrict  */)"%-20s%d", "LAST_BYTE_CHECKED", file_info.byte_count);
      }
      }
    }
#line 380
    if (vbr_info.high_rate != vbr_info.low_rate) {
#line 380
      if (file_info.good_frame_count > 0) {
#line 383
        vbr_info.ave_rate = vbr_info.sum_rate / file_info.good_frame_count;
#line 385
        if (flags->pflag) {
          {
          {
#line 389
          printf((char const   */* __restrict  */)"\t%s %d\t%s %d\t%s %d", "VBR_HIGH",
                 vbr_info.high_rate, "VBR_LOW", vbr_info.low_rate, "VBR_AVERAGE",
                 vbr_info.ave_rate);
          }
          }
        } else {
          {
          {
#line 391
          printf((char const   */* __restrict  */)"\n");
          }
          {
#line 392
          printf((char const   */* __restrict  */)"%-20s%d\n", "VBR_HIGH", vbr_info.high_rate);
          }
          {
#line 393
          printf((char const   */* __restrict  */)"%-20s%d\n", "VBR_LOW", vbr_info.low_rate);
          }
          {
#line 394
          printf((char const   */* __restrict  */)"%-20s%d", "VBR_AVERAGE", vbr_info.ave_rate);
          }
          }
        }
      }
    }
#line 398
    if (found_first_frame) {
#line 399
      if (flags->vflag) {
#line 399
        if (! flags->pflag) {
          {
          {
#line 400
          print_summary(first_mp3_frame, filename);
          }
          }
        }
      }
      {
      {
#line 403
      translate_time(& file_info, & song_time);
      }
      }
#line 405
      if (flags->pflag) {
        {
        {
#line 406
        printf((char const   */* __restrict  */)"\t%-20s%02u:%02u.%02u\n", "SONG_LENGTH",
               song_time.minutes, song_time.seconds, song_time.frac_second);
        }
        }
      } else {
        {
        {
#line 408
        printf((char const   */* __restrict  */)"\n%-20s%02u:%02u.%02u\n", "SONG_LENGTH",
               song_time.minutes, song_time.seconds, song_time.frac_second);
        }
        }
      }
    } else {
      {
      {
#line 413
      printf((char const   */* __restrict  */)"\n");
      }
      }
    }
  }
  {
  {
#line 418
  init_id3_tag_struct(& id3_tag);
  }
  {
#line 419
  transform_char_array(possible_mp3_tag, & file_info);
  }
  }
#line 422
  if (flags->iflag) {
    {
    {
#line 422
    tmp___7 = validate_id3_tag(possible_mp3_tag, & id3_tag);
    }
    }
#line 422
    if (tmp___7) {
#line 423
      if (flags->iflag) {
#line 423
        if (flags->fflag) {
#line 423
          if (flags->sflag) {
            {
            {
#line 424
            dump_id3_tag(& id3_tag);
            }
            }
          }
        }
      }
#line 426
      if (! flags->sflag) {
#line 426
        if (flags->vflag) {
          {
          {
#line 427
          printf((char const   */* __restrict  */)"\n%-20s%d\n", "MP3_TAG", 1);
          }
          {
#line 429
          printf((char const   */* __restrict  */)"%-20s%s\n", "TITLE", id3_tag.TITLE);
          }
          {
#line 430
          printf((char const   */* __restrict  */)"%-20s%s\n", "ARTIST", id3_tag.ARTIST);
          }
          {
#line 431
          printf((char const   */* __restrict  */)"%-20s%s\n", "ALBUM", id3_tag.ALBUM);
          }
          {
#line 432
          printf((char const   */* __restrict  */)"%-20s%s\n", "YEAR", id3_tag.YEAR);
          }
          {
#line 433
          printf((char const   */* __restrict  */)"%-20s%s\n", "COMMENT", id3_tag.COMMENT);
          }
          {
#line 434
          printf((char const   */* __restrict  */)"%-20s%d\n", "GENRE", (int )id3_tag.GENRE);
          }
          {
#line 435
          printf((char const   */* __restrict  */)"%-20s%d\n", "TRACK", (int )id3_tag.TRACK_NUMBER);
          }
          {
#line 436
          printf((char const   */* __restrict  */)"%-20s%d\n", "ID3.11", (int )id3_tag.ID3_311_VERSION);
          }
          }
        }
      }
    } else {
#line 422
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 438
  if (! flags->sflag) {
#line 438
    if (flags->iflag) {
      {
      {
#line 439
      printf((char const   */* __restrict  */)"\n%-20s%d\n", "MP3_TAG", 0);
      }
      }
    }
  }
  {
  {
#line 442
  tmp___10 = ferror(fp);
  }
  }
#line 442
  if (tmp___10) {
    {
    {
#line 443
    tmp___8 = __errno_location();
    }
    {
#line 443
    tmp___9 = strerror(*tmp___8);
    }
    {
#line 443
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mp3_check: %s %s\n",
            filename, tmp___9);
    }
    {
#line 444
    clearerr(fp);
    }
    }
  }
  {
  {
#line 447
  tmp___13 = ferror(stdout);
  }
  }
#line 447
  if (tmp___13) {
    {
    {
#line 448
    tmp___11 = __errno_location();
    }
    {
#line 448
    tmp___12 = strerror(*tmp___11);
    }
    {
#line 448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mp3_check: stdout %s\n",
            tmp___12);
    }
    {
#line 449
    exit(1);
    }
    }
  }
#line 457
  if (file_info.bad_frame_count > 0) {
#line 458
    return (0);
  } else {
#line 460
    return (1);
  }
}
}
#line 464 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
void init_command_flags_struct(command_flags *flags ) 
{ 


  {
#line 468
  flags->aflag = 0;
#line 469
  flags->bflag = 0;
#line 470
  flags->eflag = 0;
#line 471
  flags->fflag = 0;
#line 472
  flags->iflag = 0;
#line 473
  flags->pflag = 0;
#line 474
  flags->qflag = 0;
#line 475
  flags->sflag = 0;
#line 476
  flags->ssflag = 0;
#line 477
  flags->vflag = 0;
#line 478
  flags->vvflag = 0;
#line 479
  return;
}
}
#line 481 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
void print_summary(frame_info mp3_i , char *filename ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
  {
  {
#line 486
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 487
  printf((char const   */* __restrict  */)"%-20s%d\n", "TRUE", 1);
  }
  {
#line 488
  printf((char const   */* __restrict  */)"%-20s%d\n", "FALSE", 0);
  }
  {
#line 489
  printf((char const   */* __restrict  */)"%-20s%d\n", "MPV_1", (int )mp3_i.MPV_1);
  }
  {
#line 490
  printf((char const   */* __restrict  */)"%-20s%d\n", "MPV_2", (int )mp3_i.MPV_2);
  }
  {
#line 491
  printf((char const   */* __restrict  */)"%-20s%d\n", "MPV_25", (int )mp3_i.MPV_25);
  }
  {
#line 492
  printf((char const   */* __restrict  */)"%-20s%d\n", "MPV_RESERVED", (int )mp3_i.MPV_RESERVED);
  }
  {
#line 493
  printf((char const   */* __restrict  */)"%-20s%d\n", "L1", (int )mp3_i.L1);
  }
  {
#line 494
  printf((char const   */* __restrict  */)"%-20s%d\n", "L2", (int )mp3_i.L2);
  }
  {
#line 495
  printf((char const   */* __restrict  */)"%-20s%d\n", "L3", (int )mp3_i.L3);
  }
  {
#line 496
  printf((char const   */* __restrict  */)"%-20s%d\n", "L_RESERVED", (int )mp3_i.L_RESERVED);
  }
  {
#line 497
  printf((char const   */* __restrict  */)"%-20s%d\n", "PROT_BIT", (int )mp3_i.PROT_BIT);
  }
  {
#line 498
  printf((char const   */* __restrict  */)"%-20s%d\n", "BIT_RATE", mp3_i.BIT_RATE);
  }
  {
#line 499
  printf((char const   */* __restrict  */)"%-20s%d\n", "SAMPLE_FREQ", mp3_i.SAMPLE_FREQ);
  }
  {
#line 500
  printf((char const   */* __restrict  */)"%-20s%d\n", "SAMPLES_PER_FRAME", mp3_i.SAMPLES_PER_FRAME);
  }
  {
#line 501
  printf((char const   */* __restrict  */)"%-20s%d\n", "PAD_BIT", (int )mp3_i.PAD_BIT);
  }
  {
#line 502
  printf((char const   */* __restrict  */)"%-20s%d\n", "PRIV_BIT", (int )mp3_i.PRIV_BIT);
  }
  {
#line 503
  printf((char const   */* __restrict  */)"%-20s%d\n", "STEREO", (int )mp3_i.STEREO);
  }
  {
#line 504
  printf((char const   */* __restrict  */)"%-20s%d\n", "JOINT_STEREO", (int )mp3_i.JOINT_STEREO);
  }
  {
#line 505
  printf((char const   */* __restrict  */)"%-20s%d\n", "DUAL_STEREO", (int )mp3_i.DUAL_STEREO);
  }
  {
#line 506
  printf((char const   */* __restrict  */)"%-20s%d\n", "SINGLE_CHANNEL", (int )mp3_i.SINGLE_CHANNEL);
  }
  {
#line 507
  printf((char const   */* __restrict  */)"%-20s%d\n", "MODE_EXTENSION", (int )mp3_i.MODE_EXTENSION);
  }
  {
#line 508
  printf((char const   */* __restrict  */)"%-20s%d\n", "ID3V2", (int )mp3_i.ID3V2);
  }
  {
#line 509
  printf((char const   */* __restrict  */)"%-20s%d\n", "FRAME_LENGTH", mp3_i.FRAME_LENGTH);
  }
  {
#line 510
  printf((char const   */* __restrict  */)"%-20s%d\n", "COPYRIGHT", (int )mp3_i.COPYRIGHT);
  }
  {
#line 511
  printf((char const   */* __restrict  */)"%-20s%d\n", "ORIGINAL", (int )mp3_i.ORIGINAL);
  }
  {
#line 512
  printf((char const   */* __restrict  */)"%-20s%d\n", "EMPH_NONE", (int )mp3_i.EMPH_NONE);
  }
  {
#line 513
  printf((char const   */* __restrict  */)"%-20s%d\n", "EMPH_5015", (int )mp3_i.EMPH_5015);
  }
  {
#line 514
  printf((char const   */* __restrict  */)"%-20s%d\n", "EMPH_RESERV", (int )mp3_i.EMPH_RESERV);
  }
  {
#line 515
  printf((char const   */* __restrict  */)"%-20s%d\n", "EMPH_CCIT", (int )mp3_i.EMPH_CCIT);
  }
  {
#line 516
  printf((char const   */* __restrict  */)"%-20s%d\n", "CHECK_STATE", (int )mp3_i.check_state);
  }
  {
#line 517
  printf((char const   */* __restrict  */)"%-20s%s\n", "BIN_STRING", mp3_i.BIN_STRING);
  }
  }
#line 518
  return;
}
}
#line 524 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
static frame_info empty_frame  ;
#line 525 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
static int inited  =    0;
#line 520 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
void init_frame_struct(frame_info *FI ) 
{ 
  int i ;

  {
#line 527
  if (! inited) {
#line 529
    i = 0;
#line 530
    inited = 1;
#line 532
    empty_frame.FRAME_LENGTH = 0;
#line 533
    empty_frame.FRAME_DATA_LENGTH = 0;
#line 534
    empty_frame.CRC16_VALUE = (short)0;
#line 535
    empty_frame.CORRECT_CRC16_VALUE = (short)0;
#line 536
    empty_frame.BIT_RATE = 0;
#line 537
    empty_frame.SAMPLE_FREQ = 0;
#line 538
    empty_frame.SAMPLES_PER_FRAME = 0;
#line 539
    empty_frame.MPV_1 = (short)0;
#line 540
    empty_frame.MPV_2 = (short)0;
#line 541
    empty_frame.MPV_25 = (short)0;
#line 542
    empty_frame.MPV_RESERVED = (short)0;
#line 543
    empty_frame.L1 = (short)0;
#line 544
    empty_frame.L2 = (short)0;
#line 545
    empty_frame.L3 = (short)0;
#line 546
    empty_frame.L_RESERVED = (short)0;
#line 547
    empty_frame.PROT_BIT = (short)0;
#line 548
    empty_frame.PAD_BIT = (short)0;
#line 549
    empty_frame.PRIV_BIT = (short)0;
#line 550
    empty_frame.STEREO = (short)0;
#line 551
    empty_frame.JOINT_STEREO = (short)0;
#line 552
    empty_frame.DUAL_STEREO = (short)0;
#line 553
    empty_frame.SINGLE_CHANNEL = (short)0;
#line 554
    empty_frame.MODE_EXTENSION = (short)0;
#line 555
    empty_frame.ID3V2 = (short)0;
#line 556
    empty_frame.COPYRIGHT = (short)0;
#line 557
    empty_frame.ORIGINAL = (short)0;
#line 558
    empty_frame.EMPH_NONE = (short)0;
#line 559
    empty_frame.EMPH_5015 = (short)0;
#line 560
    empty_frame.EMPH_RESERV = (short)0;
#line 561
    empty_frame.EMPH_CCIT = (short)0;
#line 563
    i = 0;
    {
    {
#line 563
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 563
      if (! (i < 32)) {
#line 563
        goto while_break;
      }
#line 564
      empty_frame.BIN_STRING[i] = (char )'0';
#line 563
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 566
    empty_frame.BIN_STRING[32] = (char )'\000';
#line 568
    empty_frame.INT_HEADER = 0;
#line 570
    empty_frame.check_state = (short)0;
  }
#line 574
  *FI = empty_frame;
#line 575
  return;
}
}
#line 577 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
void print_usage(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
  {
#line 580
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nusage: checkmp3 [-e] [-p] [-v[v]] [-a] [-b[<byte_count>]] [-i] [-s[s]] [-h] [-] [file ...]\n");
  }
  {
#line 581
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -q<number>        Determines the mininum <number> of contiguous frames\n");
  }
  {
#line 582
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       that must be present for an error NOT to occur.\n");
  }
  {
#line 583
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       Analyzing random data will find spurious MP3 headers,\n");
  }
  {
#line 584
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       but finding <number> sequential headers are even\n");
  }
  {
#line 585
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       harder to find.\n\n");
  }
  {
#line 586
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -e                While id3v2 support is under development, this flag will\n");
  }
  {
#line 587
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       allow you to have mp3_check record a frame error when\n");
  }
  {
#line 588
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       a id3v2 tag is found.\n\n");
  }
  {
#line 589
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -p                Shows just the essentials (what you get without the\n");
  }
  {
#line 590
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       -v option) on a single line for easy parsing. The\n");
  }
  {
#line 591
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       fields are separated by tabs, and the name/value pairs\n");
  }
  {
#line 592
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       are separated by spaces.\n\n");
  }
  {
#line 593
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -v[v]             Lists details about the mp3 in name -> value order.\n");
  }
  {
#line 594
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       Adding an extra \'v\' at the end gives details about\n");
  }
  {
#line 595
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       each frame. Extremly verbose!\n\n");
  }
  {
#line 596
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -a                Checks the mp3 from stem to stern (default).\n");
  }
  {
#line 597
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       If any other flags are present, it will not be\n");
  }
  {
#line 598
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       enabled, and will instead behave as though the\n");
  }
  {
#line 599
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       \'-b\' switch is present.\n\n");
  }
  {
#line 600
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -b[<byte_count>]  If a frame is not found by <byte_count> bytes,\n");
  }
  {
#line 601
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       quit, and return an error. If byte_count\n");
  }
  {
#line 602
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       is not specified, it will search until the\n");
  }
  {
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       first valid frame and quit.\n\n");
  }
  {
#line 604
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -i                Check to see if there is a ID3 tag, and if so,\n");
  }
  {
#line 605
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       display the info.\n\n");
  }
  {
#line 606
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -s[s|f]           Sends the mp3 to stdout (for CGI applications).\n");
  }
  {
#line 607
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       If an additional \'s\' is there, then no output is\n");
  }
  {
#line 608
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       made, just errors are reported (super silent).\n");
  }
  {
#line 609
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       With the \'f\' used, only valid frames are sent\n");
  }
  {
#line 610
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       to stdout (\'f\'ixing the mp3 is attempted). Also,\n");
  }
  {
#line 611
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       it is important to note that the id3 tag will not\n");
  }
  {
#line 612
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       be included in the \'f\'ixed mp3. If you want it\n");
  }
  {
#line 613
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"                       included, you have to include the \'-i\' option.\n\n");
  }
  {
#line 614
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     -h                Print this text including the version.\n\n");
  }
  {
#line 615
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* VERSION:  %s   \n",
          "1.98");
  }
  {
#line 616
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* HOMEPAGE: %s   \n",
          "http://sourceforge.net/project/?group_id=6126");
  }
  {
#line 617
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* AUTHOR :  %s   \n",
          "Eric Bullen <ericb at thedeepsky.com>");
  }
  {
#line 620
  exit(1);
  }
  }
}
}
#line 623 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
int parse_args(char **argv , meta_options *flag_options , command_flags *flags ) 
{ 
  register FILE *fp ;
  char *filename ;
  int error_count ;
  int found_file ;
  char **tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 631
  error_count = 0;
#line 632
  found_file = 0;
  {
  {
#line 635
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 636
    if (*argv) {
      {
      {
#line 637
      tmp___2 = strcmp((char const   *)*argv, "-");
      }
      }
#line 637
      if (tmp___2 == 0) {
#line 638
        found_file = 1;
#line 639
        filename = (char *)"stdin";
#line 640
        fp = stdin;
#line 641
        argv ++;
      } else {
        {
        {
#line 643
        fp = fopen((char const   */* __restrict  */)*argv, (char const   */* __restrict  */)"rb");
        }
        }
#line 643
        if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 644
          found_file = 1;
#line 645
          tmp = argv;
#line 645
          argv ++;
#line 645
          filename = *tmp;
        } else {
          {
          {
#line 648
          tmp___0 = __errno_location();
          }
          {
#line 648
          tmp___1 = strerror(*tmp___0);
          }
          {
#line 648
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mp3_check: %s %s\n",
                  *argv, tmp___1);
          }
#line 649
          argv ++;
          }
#line 650
          goto __Cont;
        }
      }
    }
#line 655
    if (found_file) {
      {
      {
#line 656
      tmp___3 = scan_file(fp, filename, flag_options, flags);
      }
      }
#line 656
      if (! tmp___3) {
#line 657
        error_count ++;
      }
#line 659
      if ((unsigned long )fp != (unsigned long )stdin) {
        {
        {
#line 660
        fclose(fp);
        }
        }
      }
#line 662
      found_file = 0;
    }
    __Cont: /* CIL Label */ 
#line 635
    if (! *argv) {
#line 635
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  if (error_count > 0) {
#line 668
    return (0);
  } else {
#line 670
    return (1);
  }
}
}
#line 673 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
__inline int move_to_next_frame(char *possible_mp3_tag , frame_info *mp3_i , gen_info *file_info ,
                                command_flags *flags , FILE *fp ) 
{ 
  int counter ;
  int unk_char ;
  int actual_bytes_read ;
  int pos_before_read ;
  register char *data_frame ;
  int print_to_stdout ;
  int tmp ;
  int bytes_to_read ;
  void *tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 681
  counter = 0;
#line 682
  unk_char = 0;
#line 683
  actual_bytes_read = 0;
#line 687
  if (! flags->ssflag) {
#line 687
    if (flags->sflag) {
#line 687
      tmp = 1;
    } else
#line 687
    if (flags->fflag) {
#line 687
      tmp = 1;
    } else {
#line 687
      tmp = 0;
    }
  } else {
#line 687
    tmp = 0;
  }
#line 687
  print_to_stdout = tmp;
#line 688
  bytes_to_read = 0;
#line 691
  if (mp3_i->PROT_BIT) {
#line 692
    bytes_to_read = mp3_i->FRAME_LENGTH - 6;
  } else {
#line 694
    bytes_to_read = mp3_i->FRAME_LENGTH - 4;
  }
  {
  {
#line 700
  tmp___0 = malloc((size_t )bytes_to_read);
  }
#line 700
  data_frame = (char *)tmp___0;
  }
#line 710
  if ((unsigned long )fp != (unsigned long )stdin) {
#line 710
    if (! print_to_stdout) {
#line 710
      if (! flags->iflag) {
        {
        {
#line 711
        tmp___1 = ftell(fp);
        }
#line 711
        pos_before_read = (int )tmp___1;
        }
#line 712
        if (mp3_i->PROT_BIT) {
          {
          {
#line 713
          tmp___2 = fread((void */* __restrict  */)data_frame, (size_t )sizeof(char ),
                          (size_t )bytes_to_read, (FILE */* __restrict  */)fp);
          }
#line 713
          actual_bytes_read = (int )tmp___2;
          }
#line 715
          if (actual_bytes_read == bytes_to_read) {
            {
#line 716
            file_info->file_pos += bytes_to_read;
#line 717
            file_info->byte_count += bytes_to_read;
#line 724
            mp3_i->FRAME_DATA_LENGTH = actual_bytes_read;
            {
#line 730
            tmp___3 = crc_check_frame(data_frame, mp3_i);
            }
            }
#line 730
            if (tmp___3) {
              {
              {
#line 732
              free((void *)data_frame);
              }
              }
#line 733
              return (1);
            }
          } else {
            {
            {
#line 744
            tmp___6 = feof(fp);
            }
            }
#line 744
            if (tmp___6) {
#line 744
              tmp___5 = " (EOF)";
            } else {
#line 744
              tmp___5 = "";
            }
            {
            {
#line 744
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"At position %d: expected %d bytes, got %d bytes.%s\n",
                    pos_before_read, bytes_to_read, actual_bytes_read, tmp___5);
            }
            {
#line 746
            free((void *)data_frame);
            }
            }
#line 747
            return (0);
          }
        } else {
          {
          {
#line 750
          tmp___7 = fseek(fp, (long )bytes_to_read, 1);
          }
          }
#line 750
          if (! tmp___7) {
            {
#line 751
            file_info->file_pos += bytes_to_read;
#line 752
            file_info->byte_count += bytes_to_read;
            {
#line 754
            free((void *)data_frame);
            }
            }
#line 755
            return (1);
          }
        }
      } else {
#line 710
        goto _L___0;
      }
    } else {
#line 710
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 765
    counter = 0;
    {
    {
#line 765
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 765
      if (! (counter < bytes_to_read)) {
#line 765
        goto while_break;
      }
      {
      {
#line 766
      unk_char = _IO_getc(fp);
      }
      }
#line 766
      if (unk_char != -1) {
#line 768
        (file_info->file_pos) ++;
#line 769
        (file_info->byte_count) ++;
#line 771
        *(data_frame + counter) = (char )unk_char;
#line 777
        if (flags->iflag) {
          {
          {
#line 778
          rotate_char_array(possible_mp3_tag, & unk_char, file_info);
          }
          }
        }
#line 784
        if (print_to_stdout) {
          {
          {
#line 785
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%c",
                  unk_char);
          }
          }
        }
      } else {
        {
        {
#line 789
        free((void *)data_frame);
        }
        }
#line 790
        return (0);
#line 791
        goto while_break;
      }
#line 765
      counter ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 796
  free((void *)data_frame);
  }
  }
#line 797
  return (1);
}
}
#line 810 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
static short crc_table[256]  = 
#line 810
  {      (short)0,      (short)-16191,      (short)-15999,      (short)320, 
        (short)-15615,      (short)960,      (short)640,      (short)-15807, 
        (short)-14847,      (short)1728,      (short)1920,      (short)-14527, 
        (short)1280,      (short)-14911,      (short)-15231,      (short)1088, 
        (short)-13311,      (short)3264,      (short)3456,      (short)-12991, 
        (short)3840,      (short)-12351,      (short)-12671,      (short)3648, 
        (short)2560,      (short)-13631,      (short)-13439,      (short)2880, 
        (short)-14079,      (short)2496,      (short)2176,      (short)-14271, 
        (short)-10239,      (short)6336,      (short)6528,      (short)-9919, 
        (short)6912,      (short)-9279,      (short)-9599,      (short)6720, 
        (short)7680,      (short)-8511,      (short)-8319,      (short)8000, 
        (short)-8959,      (short)7616,      (short)7296,      (short)-9151, 
        (short)5120,      (short)-11071,      (short)-10879,      (short)5440, 
        (short)-10495,      (short)6080,      (short)5760,      (short)-10687, 
        (short)-11775,      (short)4800,      (short)4992,      (short)-11455, 
        (short)4352,      (short)-11839,      (short)-12159,      (short)4160, 
        (short)-4095,      (short)12480,      (short)12672,      (short)-3775, 
        (short)13056,      (short)-3135,      (short)-3455,      (short)12864, 
        (short)13824,      (short)-2367,      (short)-2175,      (short)14144, 
        (short)-2815,      (short)13760,      (short)13440,      (short)-3007, 
        (short)15360,      (short)-831,      (short)-639,      (short)15680, 
        (short)-255,      (short)16320,      (short)16000,      (short)-447, 
        (short)-1535,      (short)15040,      (short)15232,      (short)-1215, 
        (short)14592,      (short)-1599,      (short)-1919,      (short)14400, 
        (short)10240,      (short)-5951,      (short)-5759,      (short)10560, 
        (short)-5375,      (short)11200,      (short)10880,      (short)-5567, 
        (short)-4607,      (short)11968,      (short)12160,      (short)-4287, 
        (short)11520,      (short)-4671,      (short)-4991,      (short)11328, 
        (short)-7167,      (short)9408,      (short)9600,      (short)-6847, 
        (short)9984,      (short)-6207,      (short)-6527,      (short)9792, 
        (short)8704,      (short)-7487,      (short)-7295,      (short)9024, 
        (short)-7935,      (short)8640,      (short)8320,      (short)-8127, 
        (short)-24575,      (short)24768,      (short)24960,      (short)-24255, 
        (short)25344,      (short)-23615,      (short)-23935,      (short)25152, 
        (short)26112,      (short)-22847,      (short)-22655,      (short)26432, 
        (short)-23295,      (short)26048,      (short)25728,      (short)-23487, 
        (short)27648,      (short)-21311,      (short)-21119,      (short)27968, 
        (short)-20735,      (short)28608,      (short)28288,      (short)-20927, 
        (short)-22015,      (short)27328,      (short)27520,      (short)-21695, 
        (short)26880,      (short)-22079,      (short)-22399,      (short)26688, 
        (short)30720,      (short)-18239,      (short)-18047,      (short)31040, 
        (short)-17663,      (short)31680,      (short)31360,      (short)-17855, 
        (short)-16895,      (short)32448,      (short)32640,      (short)-16575, 
        (short)32000,      (short)-16959,      (short)-17279,      (short)31808, 
        (short)-19455,      (short)29888,      (short)30080,      (short)-19135, 
        (short)30464,      (short)-18495,      (short)-18815,      (short)30272, 
        (short)29184,      (short)-19775,      (short)-19583,      (short)29504, 
        (short)-20223,      (short)29120,      (short)28800,      (short)-20415, 
        (short)20480,      (short)-28479,      (short)-28287,      (short)20800, 
        (short)-27903,      (short)21440,      (short)21120,      (short)-28095, 
        (short)-27135,      (short)22208,      (short)22400,      (short)-26815, 
        (short)21760,      (short)-27199,      (short)-27519,      (short)21568, 
        (short)-25599,      (short)23744,      (short)23936,      (short)-25279, 
        (short)24320,      (short)-24639,      (short)-24959,      (short)24128, 
        (short)23040,      (short)-25919,      (short)-25727,      (short)23360, 
        (short)-26367,      (short)22976,      (short)22656,      (short)-26559, 
        (short)-30719,      (short)18624,      (short)18816,      (short)-30399, 
        (short)19200,      (short)-29759,      (short)-30079,      (short)19008, 
        (short)19968,      (short)-28991,      (short)-28799,      (short)20288, 
        (short)-29439,      (short)19904,      (short)19584,      (short)-29631, 
        (short)17408,      (short)-31551,      (short)-31359,      (short)17728, 
        (short)-30975,      (short)18368,      (short)18048,      (short)-31167, 
        (short)-32255,      (short)17088,      (short)17280,      (short)-31935, 
        (short)16640,      (short)-32319,      (short)-32639,      (short)16448};
#line 800 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
int crc_check_frame(char *data_frame , frame_info *mp3_i ) 
{ 
  register int i ;
  register short crc ;
  int size_of_data ;
  char *tmp ;

  {
#line 845
  i = 0;
#line 846
  crc = (short)0;
#line 847
  size_of_data = mp3_i->FRAME_DATA_LENGTH;
#line 852
  i = 0;
  {
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < size_of_data)) {
#line 852
      goto while_break;
    }
#line 853
    tmp = data_frame;
#line 853
    data_frame ++;
#line 853
    crc = (short )((((int )crc >> 8) & 255) ^ (int )crc_table[((int )crc ^ (int )*tmp) & 255]);
#line 852
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 856
  mp3_i->CORRECT_CRC16_VALUE = (short )((int )crc & 65535);
#line 859
  if ((int )mp3_i->CRC16_VALUE == (int )mp3_i->CORRECT_CRC16_VALUE) {
#line 860
    return (1);
  } else {
#line 862
    return (0);
  }
}
}
#line 865 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
int get_char_from_file(FILE *fp , unsigned int *header_value , gen_info *file_info ,
                       command_flags *flags , char *possible_mp3_tag ) 
{ 
  int step_char ;

  {
  {
#line 873
  step_char = 0;
  {
#line 875
  step_char = _IO_getc(fp);
  }
  }
#line 875
  if (step_char != -1) {
#line 879
    *header_value = (*header_value << 8) + (unsigned int )step_char;
#line 881
    (file_info->file_pos) ++;
#line 882
    (file_info->byte_count) ++;
#line 886
    if (flags->iflag) {
      {
      {
#line 887
      rotate_char_array(possible_mp3_tag, & step_char, file_info);
      }
      }
    }
#line 889
    return (1);
  } else {
#line 891
    return (0);
  }
}
}
#line 185 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
static int bitrate_matrix___0[6][16]  = { {        1,        32,        64,        96, 
            128,        160,        192,        224, 
            256,        288,        320,        352, 
            384,        416,        448,        0}, 
   {        1,        32,        48,        56, 
            64,        80,        96,        112, 
            128,        160,        192,        224, 
            256,        320,        384,        0}, 
   {        1,        32,        40,        48, 
            56,        64,        80,        96, 
            112,        128,        160,        192, 
            224,        256,        320,        0}, 
   {        1,        32,        48,        56, 
            64,        80,        96,        112, 
            128,        144,        160,        176, 
            192,        224,        256,        0}, 
   {        1,        8,        16,        24, 
            32,        40,        48,        56, 
            64,        80,        96,        112, 
            128,        144,        160,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0}};
#line 194 "/home/wslee/benchmarks/sound/checkmp3-1.98/support_functions.h"
static int sampling_rate_matrix___0[4][3]  = { {        44100,        22050,        11025}, 
   {        48000,        24000,        12000}, 
   {        32000,        16000,        8000}, 
   {        0,        0,        0}};
#line 524 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
static frame_info empty_frame___0  ;
#line 525 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
static int inited___0  =    0;
#line 810 "/home/wslee/benchmarks/sound/checkmp3-1.98/mp3_check_misc.c"
static short crc_table___0[256]  = 
#line 810
  {      (short)0,      (short)-16191,      (short)-15999,      (short)320, 
        (short)-15615,      (short)960,      (short)640,      (short)-15807, 
        (short)-14847,      (short)1728,      (short)1920,      (short)-14527, 
        (short)1280,      (short)-14911,      (short)-15231,      (short)1088, 
        (short)-13311,      (short)3264,      (short)3456,      (short)-12991, 
        (short)3840,      (short)-12351,      (short)-12671,      (short)3648, 
        (short)2560,      (short)-13631,      (short)-13439,      (short)2880, 
        (short)-14079,      (short)2496,      (short)2176,      (short)-14271, 
        (short)-10239,      (short)6336,      (short)6528,      (short)-9919, 
        (short)6912,      (short)-9279,      (short)-9599,      (short)6720, 
        (short)7680,      (short)-8511,      (short)-8319,      (short)8000, 
        (short)-8959,      (short)7616,      (short)7296,      (short)-9151, 
        (short)5120,      (short)-11071,      (short)-10879,      (short)5440, 
        (short)-10495,      (short)6080,      (short)5760,      (short)-10687, 
        (short)-11775,      (short)4800,      (short)4992,      (short)-11455, 
        (short)4352,      (short)-11839,      (short)-12159,      (short)4160, 
        (short)-4095,      (short)12480,      (short)12672,      (short)-3775, 
        (short)13056,      (short)-3135,      (short)-3455,      (short)12864, 
        (short)13824,      (short)-2367,      (short)-2175,      (short)14144, 
        (short)-2815,      (short)13760,      (short)13440,      (short)-3007, 
        (short)15360,      (short)-831,      (short)-639,      (short)15680, 
        (short)-255,      (short)16320,      (short)16000,      (short)-447, 
        (short)-1535,      (short)15040,      (short)15232,      (short)-1215, 
        (short)14592,      (short)-1599,      (short)-1919,      (short)14400, 
        (short)10240,      (short)-5951,      (short)-5759,      (short)10560, 
        (short)-5375,      (short)11200,      (short)10880,      (short)-5567, 
        (short)-4607,      (short)11968,      (short)12160,      (short)-4287, 
        (short)11520,      (short)-4671,      (short)-4991,      (short)11328, 
        (short)-7167,      (short)9408,      (short)9600,      (short)-6847, 
        (short)9984,      (short)-6207,      (short)-6527,      (short)9792, 
        (short)8704,      (short)-7487,      (short)-7295,      (short)9024, 
        (short)-7935,      (short)8640,      (short)8320,      (short)-8127, 
        (short)-24575,      (short)24768,      (short)24960,      (short)-24255, 
        (short)25344,      (short)-23615,      (short)-23935,      (short)25152, 
        (short)26112,      (short)-22847,      (short)-22655,      (short)26432, 
        (short)-23295,      (short)26048,      (short)25728,      (short)-23487, 
        (short)27648,      (short)-21311,      (short)-21119,      (short)27968, 
        (short)-20735,      (short)28608,      (short)28288,      (short)-20927, 
        (short)-22015,      (short)27328,      (short)27520,      (short)-21695, 
        (short)26880,      (short)-22079,      (short)-22399,      (short)26688, 
        (short)30720,      (short)-18239,      (short)-18047,      (short)31040, 
        (short)-17663,      (short)31680,      (short)31360,      (short)-17855, 
        (short)-16895,      (short)32448,      (short)32640,      (short)-16575, 
        (short)32000,      (short)-16959,      (short)-17279,      (short)31808, 
        (short)-19455,      (short)29888,      (short)30080,      (short)-19135, 
        (short)30464,      (short)-18495,      (short)-18815,      (short)30272, 
        (short)29184,      (short)-19775,      (short)-19583,      (short)29504, 
        (short)-20223,      (short)29120,      (short)28800,      (short)-20415, 
        (short)20480,      (short)-28479,      (short)-28287,      (short)20800, 
        (short)-27903,      (short)21440,      (short)21120,      (short)-28095, 
        (short)-27135,      (short)22208,      (short)22400,      (short)-26815, 
        (short)21760,      (short)-27199,      (short)-27519,      (short)21568, 
        (short)-25599,      (short)23744,      (short)23936,      (short)-25279, 
        (short)24320,      (short)-24639,      (short)-24959,      (short)24128, 
        (short)23040,      (short)-25919,      (short)-25727,      (short)23360, 
        (short)-26367,      (short)22976,      (short)22656,      (short)-26559, 
        (short)-30719,      (short)18624,      (short)18816,      (short)-30399, 
        (short)19200,      (short)-29759,      (short)-30079,      (short)19008, 
        (short)19968,      (short)-28991,      (short)-28799,      (short)20288, 
        (short)-29439,      (short)19904,      (short)19584,      (short)-29631, 
        (short)17408,      (short)-31551,      (short)-31359,      (short)17728, 
        (short)-30975,      (short)18368,      (short)18048,      (short)-31167, 
        (short)-32255,      (short)17088,      (short)17280,      (short)-31935, 
        (short)16640,      (short)-32319,      (short)-32639,      (short)16448};
