/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 11 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.h"
struct dict_radix;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 347 "/usr/include/zconf.h"
typedef void *voidp;
#line 1078 "/usr/include/zlib.h"
typedef voidp gzFile;
#line 32 "/home/wslee/benchmarks/textformat/hspell-1.0/gzbuffered.h"
struct __anonstruct_gzbFile_27 {
   gzFile gz ;
   char buf[4096] ;
   char *b ;
   int n ;
};
#line 32 "/home/wslee/benchmarks/textformat/hspell-1.0/gzbuffered.h"
typedef struct __anonstruct_gzbFile_27 gzbFile;
#line 110 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
struct node_index {
   uint32_t val_or_index ;
};
#line 117 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
struct node {
   uint32_t value ;
   struct node_index children[29] ;
};
#line 121 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
struct node_small {
   uint32_t value ;
   char chars[2] ;
   struct node_index children[2] ;
};
#line 126 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
struct node_medium {
   uint32_t value ;
   char chars[8] ;
   struct node_index children[8] ;
};
#line 224 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
struct dict_radix {
   int nnodes_small ;
   int size_nodes_small ;
   struct node_small *nodes_small ;
   int nnodes_medium ;
   int size_nodes_medium ;
   struct node_medium *nodes_medium ;
   int nnodes ;
   int size_nodes ;
   struct node *nodes ;
   struct node_index head ;
   int free_nodes_small[16] ;
   int nfree_nodes_small ;
   int free_nodes_medium[16] ;
   int nfree_nodes_medium ;
   int nwords ;
};
#line 20 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.h"
struct corlist;
#line 50 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.h"
struct corlist {
   char correction[50][30] ;
   int n ;
};
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 60 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 68 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.h"
typedef int hspell_word_split_callback_func(char const   *word , char const   *baseword ,
                                            int preflen , int prefspec );
#line 80 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
struct prefix_node {
   int mask ;
   struct prefix_node *next[27] ;
};
#line 21 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef void *ClientData;
#line 22
struct Tcl_Obj;
#line 23 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef struct Tcl_Obj Tcl_Obj;
#line 28
struct Tcl_HashKeyType;
#line 28 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef struct Tcl_HashKeyType Tcl_HashKeyType;
#line 29
struct Tcl_HashTable;
#line 29 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef struct Tcl_HashTable Tcl_HashTable;
#line 30
struct Tcl_HashEntry;
#line 30 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef struct Tcl_HashEntry Tcl_HashEntry;
#line 31
struct Tcl_HashSearch;
#line 31 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef struct Tcl_HashSearch Tcl_HashSearch;
#line 33 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef unsigned int Tcl_HashKeyProc(Tcl_HashTable *tablePtr , void *keyPtr );
#line 35 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef int Tcl_CompareHashKeysProc(void *keyPtr , Tcl_HashEntry *hPtr );
#line 37 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef Tcl_HashEntry *Tcl_AllocHashEntryProc(Tcl_HashTable *tablePtr , void *keyPtr );
#line 39 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
typedef void Tcl_FreeHashEntryProc(Tcl_HashEntry *hPtr );
#line 47 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
union __anonunion_key_23 {
   char *oneWordValue ;
   Tcl_Obj *objPtr ;
   int words[1] ;
   char string[4] ;
};
#line 47 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
struct Tcl_HashEntry {
   Tcl_HashEntry *nextPtr ;
   Tcl_HashTable *tablePtr ;
   unsigned int hash ;
   ClientData clientData ;
   union __anonunion_key_23 key ;
};
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
struct Tcl_HashTable {
   Tcl_HashEntry **buckets ;
   Tcl_HashEntry *staticBuckets[4] ;
   int numBuckets ;
   int numEntries ;
   int rebuildSize ;
   int downShift ;
   int mask ;
   int keyType ;
   Tcl_HashKeyType *typePtr ;
};
#line 127 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
struct Tcl_HashSearch {
   Tcl_HashTable *tablePtr ;
   int nextIndex ;
   Tcl_HashEntry *nextEntryPtr ;
};
#line 86 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
struct Tcl_HashKeyType {
   int version ;
   int flags ;
   Tcl_HashKeyProc *hashKeyProc ;
   Tcl_CompareHashKeysProc *compareKeysProc ;
   Tcl_AllocHashEntryProc *allocEntryProc ;
   Tcl_FreeHashEntryProc *freeEntryProc ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 31 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
typedef Tcl_HashTable hspell_hash;
#line 66 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
struct __anonstruct_hspell_hash_keyvalue_27 {
   char const   *key ;
   int value ;
};
#line 66 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
typedef struct __anonstruct_hspell_hash_keyvalue_27 hspell_hash_keyvalue;
#line 13 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.h"
struct dict_radix *new_dict_radix(void) ;
#line 15
int allocate_nodes(struct dict_radix *dict , int nsmall , int nmedium , int nfull ) ;
#line 17
int read_dict(struct dict_radix *dict , char const   *dir ) ;
#line 19
void print_sizes(struct dict_radix *dict ) ;
#line 20
void print_stats(struct dict_radix *dict ) ;
#line 11 "/home/wslee/benchmarks/textformat/hspell-1.0/find_sizes.c"
int main(int argc , char **argv ) 
{ 
  struct dict_radix *dict ;
  struct dict_radix *tmp ;

  {
  {
  {
#line 14
  tmp = new_dict_radix();
  }
#line 14
  dict = tmp;
  {
#line 16
  allocate_nodes(dict, 200000, 100000, 10000);
  }
  {
#line 18
  read_dict(dict, (char const   *)((void *)0));
  }
  {
#line 19
  print_sizes(dict);
  }
  {
#line 20
  print_stats(dict);
  }
  }
#line 21
  return (0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 34 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.h"
int hspell_is_canonic_gimatria(char const   *w ) ;
#line 41
int hspell_debug ;
#line 11 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static int gim2int(char const   *w ) 
{ 
  int n ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 13
  n = 0;
#line 14
  if (hspell_debug) {
    {
    {
#line 14
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gim2int got %s ",
            w);
    }
    }
  }
  {
  {
#line 15
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 15
    if (! *w) {
#line 15
      goto while_break;
    }
    {
#line 17
    if ((int const   )*w == 39) {
#line 17
      goto case_39;
    }
#line 28
    if ((int const   )*w == -32) {
#line 28
      goto case_neg_32;
    }
#line 29
    if ((int const   )*w == -31) {
#line 29
      goto case_neg_31;
    }
#line 30
    if ((int const   )*w == -30) {
#line 30
      goto case_neg_30;
    }
#line 31
    if ((int const   )*w == -29) {
#line 31
      goto case_neg_29;
    }
#line 32
    if ((int const   )*w == -28) {
#line 32
      goto case_neg_28;
    }
#line 33
    if ((int const   )*w == -27) {
#line 33
      goto case_neg_27;
    }
#line 34
    if ((int const   )*w == -26) {
#line 34
      goto case_neg_26;
    }
#line 35
    if ((int const   )*w == -25) {
#line 35
      goto case_neg_25;
    }
#line 36
    if ((int const   )*w == -24) {
#line 36
      goto case_neg_24;
    }
#line 37
    if ((int const   )*w == -23) {
#line 37
      goto case_neg_23;
    }
#line 38
    if ((int const   )*w == -22) {
#line 38
      goto case_neg_22;
    }
#line 38
    if ((int const   )*w == -21) {
#line 38
      goto case_neg_22;
    }
#line 39
    if ((int const   )*w == -20) {
#line 39
      goto case_neg_20;
    }
#line 40
    if ((int const   )*w == -19) {
#line 40
      goto case_neg_19;
    }
#line 40
    if ((int const   )*w == -18) {
#line 40
      goto case_neg_19;
    }
#line 41
    if ((int const   )*w == -17) {
#line 41
      goto case_neg_17;
    }
#line 41
    if ((int const   )*w == -16) {
#line 41
      goto case_neg_17;
    }
#line 42
    if ((int const   )*w == -15) {
#line 42
      goto case_neg_15;
    }
#line 43
    if ((int const   )*w == -14) {
#line 43
      goto case_neg_14;
    }
#line 44
    if ((int const   )*w == -13) {
#line 44
      goto case_neg_13;
    }
#line 44
    if ((int const   )*w == -12) {
#line 44
      goto case_neg_13;
    }
#line 45
    if ((int const   )*w == -11) {
#line 45
      goto case_neg_11;
    }
#line 45
    if ((int const   )*w == -10) {
#line 45
      goto case_neg_11;
    }
#line 46
    if ((int const   )*w == -9) {
#line 46
      goto case_neg_9;
    }
#line 47
    if ((int const   )*w == -8) {
#line 47
      goto case_neg_8;
    }
#line 48
    if ((int const   )*w == -7) {
#line 48
      goto case_neg_7;
    }
#line 49
    if ((int const   )*w == -6) {
#line 49
      goto case_neg_6;
    }
#line 16
    goto switch_break;
    case_39: /* CIL Label */ 
#line 25
    if (*(w + 1)) {
#line 26
      n *= 1000;
    }
#line 27
    goto switch_break;
    case_neg_32: /* CIL Label */ 
#line 28
    n ++;
#line 28
    goto switch_break;
    case_neg_31: /* CIL Label */ 
#line 29
    n += 2;
#line 29
    goto switch_break;
    case_neg_30: /* CIL Label */ 
#line 30
    n += 3;
#line 30
    goto switch_break;
    case_neg_29: /* CIL Label */ 
#line 31
    n += 4;
#line 31
    goto switch_break;
    case_neg_28: /* CIL Label */ 
#line 32
    n += 5;
#line 32
    goto switch_break;
    case_neg_27: /* CIL Label */ 
#line 33
    n += 6;
#line 33
    goto switch_break;
    case_neg_26: /* CIL Label */ 
#line 34
    n += 7;
#line 34
    goto switch_break;
    case_neg_25: /* CIL Label */ 
#line 35
    n += 8;
#line 35
    goto switch_break;
    case_neg_24: /* CIL Label */ 
#line 36
    n += 9;
#line 36
    goto switch_break;
    case_neg_23: /* CIL Label */ 
#line 37
    n += 10;
#line 37
    goto switch_break;
    case_neg_22: /* CIL Label */ 
    case_neg_21: /* CIL Label */ 
#line 38
    n += 20;
#line 38
    goto switch_break;
    case_neg_20: /* CIL Label */ 
#line 39
    n += 30;
#line 39
    goto switch_break;
    case_neg_19: /* CIL Label */ 
    case_neg_18: /* CIL Label */ 
#line 40
    n += 40;
#line 40
    goto switch_break;
    case_neg_17: /* CIL Label */ 
    case_neg_16: /* CIL Label */ 
#line 41
    n += 50;
#line 41
    goto switch_break;
    case_neg_15: /* CIL Label */ 
#line 42
    n += 60;
#line 42
    goto switch_break;
    case_neg_14: /* CIL Label */ 
#line 43
    n += 70;
#line 43
    goto switch_break;
    case_neg_13: /* CIL Label */ 
    case_neg_12: /* CIL Label */ 
#line 44
    n += 80;
#line 44
    goto switch_break;
    case_neg_11: /* CIL Label */ 
    case_neg_10: /* CIL Label */ 
#line 45
    n += 90;
#line 45
    goto switch_break;
    case_neg_9: /* CIL Label */ 
#line 46
    n += 100;
#line 46
    goto switch_break;
    case_neg_8: /* CIL Label */ 
#line 47
    n += 200;
#line 47
    goto switch_break;
    case_neg_7: /* CIL Label */ 
#line 48
    n += 300;
#line 48
    goto switch_break;
    case_neg_6: /* CIL Label */ 
#line 49
    n += 400;
#line 49
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 52
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (hspell_debug) {
    {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %d\n",
            n);
    }
    }
  }
#line 55
  return (n);
}
}
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *appendStr(char *src , char *dst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! *src) {
#line 99
      goto while_break;
    }
#line 100
    tmp = dst;
#line 100
    dst ++;
#line 100
    tmp___0 = src;
#line 100
    src ++;
#line 100
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  *dst = (char )'\000';
#line 103
  return (dst);
}
}
#line 108
static void int2gim(int n , char *buf ) ;
#line 108 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *digits[3][9]  = { {        (char *)"\340",        (char *)"\341",        (char *)"\342",        (char *)"\343", 
            (char *)"\344",        (char *)"\345",        (char *)"\346",        (char *)"\347", 
            (char *)"\350"}, 
   {        (char *)"\351",        (char *)"\353",        (char *)"\354",        (char *)"\356", 
            (char *)"\360",        (char *)"\361",        (char *)"\362",        (char *)"\364", 
            (char *)"\366"}, 
   {        (char *)"\367",        (char *)"\370",        (char *)"\371",        (char *)"\372", 
            (char *)"\367\372",        (char *)"\370\372",        (char *)"\371\372",        (char *)"\372\372", 
            (char *)"\367\372\372"}};
#line 113 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *special[2]  = {      (char *)"\345\350",      (char *)"\346\350"};
#line 105 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static void int2gim(int n , char *buf ) 
{ 
  int i ;
  char *b ;
  char *bleft ;
  char *bright ;
  char tmp ;
  char save ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 114
  i = 0;
#line 115
  b = buf;
#line 116
  *b = (char )'\000';
#line 118
  if (hspell_debug) {
    {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"int2gim got %d ",
            n);
    }
    }
  }
  {
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (n > 0)) {
#line 119
      goto while_break;
    }
#line 120
    if (i == 3) {
      {
#line 120
      i = 0;
      {
#line 120
      b = appendStr((char *)"\'", b);
      }
      }
    }
#line 121
    if (! i) {
#line 121
      if (n % 100 == 15) {
        {
        {
#line 122
        b = appendStr(special[n % 100 - 15], b);
        }
#line 123
        n /= 100;
#line 124
        i = 2;
        }
      } else
#line 121
      if (n % 100 == 16) {
        {
        {
#line 122
        b = appendStr(special[n % 100 - 15], b);
        }
#line 123
        n /= 100;
#line 124
        i = 2;
        }
      } else {
#line 121
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 126
      if (n % 10) {
        {
        {
#line 126
        b = appendStr(digits[i][n % 10 - 1], b);
        }
        }
      }
#line 128
      n /= 10;
#line 129
      i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (hspell_debug) {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"before %s\n",
            buf);
    }
    }
  }
#line 134
  if ((int )*(buf + 0) != 0) {
#line 135
    bleft = buf;
#line 135
    bright = b - 1;
    {
    {
#line 135
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! ((unsigned long )bright > (unsigned long )bleft)) {
#line 135
        goto while_break___0;
      }
#line 137
      tmp = *bleft;
#line 138
      *bleft = *bright;
#line 139
      *bright = tmp;
#line 135
      bleft ++;
#line 135
      bright --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 141
  if (hspell_debug) {
    {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"after %s\n",
            buf);
    }
    }
  }
#line 143
  if (*(buf + 0)) {
    {
#line 145
    if ((int )*(b + -1) == -21) {
#line 145
      goto case_neg_21;
    }
#line 146
    if ((int )*(b + -1) == -18) {
#line 146
      goto case_neg_18;
    }
#line 147
    if ((int )*(b + -1) == -16) {
#line 147
      goto case_neg_16;
    }
#line 148
    if ((int )*(b + -1) == -10) {
#line 148
      goto case_neg_10;
    }
#line 149
    if ((int )*(b + -1) == -12) {
#line 149
      goto case_neg_12;
    }
#line 144
    goto switch_break;
    case_neg_21: /* CIL Label */ 
#line 145
    *(b + -1) = (char )'\352';
#line 145
    goto switch_break;
    case_neg_18: /* CIL Label */ 
#line 146
    *(b + -1) = (char )'\355';
#line 146
    goto switch_break;
    case_neg_16: /* CIL Label */ 
#line 147
    *(b + -1) = (char )'\357';
#line 147
    goto switch_break;
    case_neg_10: /* CIL Label */ 
#line 148
    *(b + -1) = (char )'\365';
#line 148
    goto switch_break;
    case_neg_12: /* CIL Label */ 
#line 149
    *(b + -1) = (char )'\363';
#line 149
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 155
  if ((int )*(buf + 0) != 0) {
#line 156
    if ((int )*(buf + 1) == 0) {
#line 157
      *(buf + 1) = (char )'\'';
#line 158
      *(buf + 2) = (char )'\000';
    } else
#line 163
    if ((int )*(b + -2) == 39) {
#line 163
      if ((int )*(b + -1) != 39) {
#line 164
        *(b + 0) = (char )'\'';
#line 165
        *(b + 1) = (char )'\000';
      } else {
#line 163
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 166
    if ((int )*(b + -1) != 39) {
#line 167
      save = *(b + -1);
#line 168
      *(b + -1) = (char )'\"';
#line 169
      *(b + 0) = save;
#line 170
      *(b + 1) = (char )'\000';
    }
  }
#line 173
  if (hspell_debug) {
    {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %s\n",
            buf);
    }
    }
  }
#line 174
  return;
}
}
#line 179 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
int hspell_is_canonic_gimatria(char const   *w ) 
{ 
  char const   *p ;
  char buf[50] ;
  int val ;
  int tmp ;
  void *__cil_tmp6 ;

  {
#line 187
  p = w;
  {
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 187
    if (*p) {
#line 187
      if ((int const   )*p != 34) {
#line 187
        if (! ((int const   )*p != 39)) {
#line 187
          goto while_break;
        }
      } else {
#line 187
        goto while_break;
      }
    } else {
#line 187
      goto while_break;
    }
#line 187
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (! *p) {
#line 190
    return (0);
  }
  {
  {
#line 192
  val = gim2int(w);
  }
  {
#line 192
  int2gim(val, buf);
  }
  {
#line 193
  tmp = strcmp(w, (char const   *)(buf));
  }
  }
#line 193
  if (tmp) {
#line 193
    val = 0;
  }
#line 194
  return (val);
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 1098 "/usr/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1119
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1244
extern int gzclose(gzFile file ) ;
#line 1387
extern gzFile gzopen(char const   * , char const   * ) ;
#line 39 "/home/wslee/benchmarks/textformat/hspell-1.0/gzbuffered.h"
__inline static gzbFile *gzb_open(char const   *path , char const   *mode ) 
{ 
  gzbFile *ret ;
  void *tmp ;
  void *__cil_tmp5 ;

  {
  {
  {
#line 42
  tmp = malloc((size_t )sizeof(gzbFile ));
  }
#line 42
  ret = (gzbFile *)tmp;
  }
#line 43
  if (! ret) {
#line 44
    return ((gzbFile *)((void *)0));
  }
  {
#line 45
  ret->n = 0;
  {
#line 46
  ret->gz = gzopen(path, mode);
  }
  }
#line 47
  if (! ret->gz) {
    {
    {
#line 48
    free((void *)ret);
    }
    }
#line 49
    return ((gzbFile *)((void *)0));
  }
#line 52
  return (ret);
}
}
#line 55 "/home/wslee/benchmarks/textformat/hspell-1.0/gzbuffered.h"
__inline static gzbFile *gzb_dopen(int fd , char const   *mode ) 
{ 
  gzbFile *ret ;
  void *tmp ;
  void *__cil_tmp5 ;

  {
  {
  {
#line 58
  tmp = malloc((size_t )sizeof(gzbFile ));
  }
#line 58
  ret = (gzbFile *)tmp;
  }
#line 59
  if (! ret) {
#line 60
    return ((gzbFile *)((void *)0));
  }
  {
#line 61
  ret->n = 0;
  {
#line 62
  ret->gz = gzdopen(fd, mode);
  }
  }
#line 63
  if (! ret->gz) {
    {
    {
#line 64
    free((void *)ret);
    }
    }
#line 65
    return ((gzbFile *)((void *)0));
  }
#line 67
  return (ret);
}
}
#line 70 "/home/wslee/benchmarks/textformat/hspell-1.0/gzbuffered.h"
__inline static int gzb_close(gzbFile *f ) 
{ 
  int ret ;

  {
  {
  {
#line 74
  ret = gzclose(f->gz);
  }
  {
#line 75
  free((void *)f);
  }
  }
#line 76
  return (ret);
}
}
#line 79 "/home/wslee/benchmarks/textformat/hspell-1.0/gzbuffered.h"
__inline static int gzb_getc(gzbFile *gzbp ) 
{ 
  char *tmp ;

  {
#line 81
  if (! gzbp->n) {
    {
    {
#line 83
    gzbp->n = gzread(gzbp->gz, (voidp )(gzbp->buf), (unsigned int )sizeof(gzbp->buf));
    }
    }
#line 84
    if (gzbp->n <= 0) {
#line 85
      gzbp->n = 0;
#line 86
      return (-1);
    }
#line 88
    gzbp->b = gzbp->buf;
  }
#line 91
  (gzbp->n) --;
#line 92
  tmp = gzbp->b;
#line 92
  (gzbp->b) ++;
#line 92
  return ((int )*tmp);
}
}
#line 138 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
__inline static int char_to_letter(unsigned char c ) 
{ 
  char *__cil_tmp2 ;

  {
#line 140
  if ((int )c >= 224) {
#line 140
    if ((int )c < 251) {
#line 141
      return (((int )c - 224) + 2);
    } else {
#line 140
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 142
  if ((int )c == 34) {
#line 143
    return (0);
  } else
#line 144
  if ((int )c == 39) {
#line 145
    return (1);
  } else {
    {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: unknown letter %c...\n",
            (int )c);
    }
    }
#line 149
    return (0);
  }
}
}
#line 153 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
__inline static unsigned char letter_to_char(int l ) 
{ 
  char *__cil_tmp2 ;

  {
#line 155
  if (l >= 2) {
#line 155
    if (l < 29) {
#line 156
      return ((unsigned char )((l + 224) - 2));
    } else {
#line 155
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 157
  if (l == 0) {
#line 158
    return ((unsigned char )'\"');
  } else
#line 159
  if (l == 1) {
#line 160
    return ((unsigned char )'\'');
  } else {
    {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: internal error: unknown letter %d... exiting.\n",
            l);
    }
    {
#line 165
    exit(1);
    }
    }
  }
}
}
#line 172 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static void do_print_tree(struct node *nodes , struct node_small *nodes_small , struct node_medium *nodes_medium ,
                          struct node_index head , char *word , int len , int maxlen ) 
{ 
  int i ;
  struct node *n ;
  unsigned char tmp ;
  struct node_small *n___0 ;
  struct node_medium *n___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 177
  if (len >= maxlen) {
    {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_print_tree(): warning: buffer overflow.\n");
    }
    }
#line 179
    return;
  }
#line 181
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 182
    n = nodes + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 183
    if (n->value) {
      {
#line 184
      *(word + len) = (char )'\000';
      {
#line 185
      printf((char const   */* __restrict  */)"%s %d\n", word, n->value);
      }
      }
    }
#line 187
    i = 0;
    {
    {
#line 187
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 187
      if (! (i < 29)) {
#line 187
        goto while_break;
      }
      {
      {
#line 188
      tmp = letter_to_char(i);
      }
#line 188
      *(word + len) = (char )tmp;
      {
#line 189
      do_print_tree(nodes, nodes_small, nodes_medium, n->children[i], word, len + 1,
                    maxlen);
      }
#line 187
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 192
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 193
    n___0 = nodes_small + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 194
    if (n___0->value) {
      {
#line 195
      *(word + len) = (char )'\000';
      {
#line 196
      printf((char const   */* __restrict  */)"%s %d\n", word, n___0->value);
      }
      }
    }
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 2)) {
#line 198
        goto while_break___0;
      }
#line 199
      if (n___0->chars[i]) {
        {
#line 200
        *(word + len) = n___0->chars[i];
        {
#line 201
        do_print_tree(nodes, nodes_small, nodes_medium, n___0->children[i], word,
                      len + 1, maxlen);
        }
        }
      }
#line 198
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 205
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 206
    n___1 = nodes_medium + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 207
    if (n___1->value) {
      {
#line 208
      *(word + len) = (char )'\000';
      {
#line 209
      printf((char const   */* __restrict  */)"%s %d\n", word, n___1->value);
      }
      }
    }
#line 211
    i = 0;
    {
    {
#line 211
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 211
      if (! (i < 8)) {
#line 211
        goto while_break___1;
      }
#line 212
      if (n___1->chars[i]) {
        {
#line 213
        *(word + len) = n___1->chars[i];
        {
#line 214
        do_print_tree(nodes, nodes_small, nodes_medium, n___1->children[i], word,
                      len + 1, maxlen);
        }
        }
      }
#line 211
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if (head.val_or_index) {
    {
#line 219
    *(word + len) = (char )'\000';
    {
#line 220
    printf((char const   */* __restrict  */)"%s %d\n", word, head.val_or_index);
    }
    }
  }
#line 222
  return;
}
}
#line 253 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
struct dict_radix *new_dict_radix(void) 
{ 
  struct dict_radix *dict ;
  void *tmp ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
  {
#line 257
  tmp = malloc((size_t )sizeof(struct dict_radix ));
  }
#line 257
  dict = (struct dict_radix *)tmp;
  }
#line 259
  if (dict) {
    {
    {
#line 260
    memset((void *)dict, 0, (size_t )sizeof(*dict));
    }
    }
  }
#line 261
  return (dict);
}
}
#line 268 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
void delete_dict_radix(struct dict_radix *dict ) 
{ 


  {
#line 271
  if (! dict) {
#line 272
    return;
  }
#line 273
  if (dict->nodes_small) {
    {
    {
#line 274
    free((void *)dict->nodes_small);
    }
    }
  }
#line 275
  if (dict->nodes_medium) {
    {
    {
#line 276
    free((void *)dict->nodes_medium);
    }
    }
  }
#line 277
  if (dict->nodes) {
    {
    {
#line 278
    free((void *)dict->nodes);
    }
    }
  }
  {
  {
#line 279
  free((void *)dict);
  }
  }
#line 280
  return;
}
}
#line 282 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
int allocate_nodes(struct dict_radix *dict , int nsmall , int nmedium , int nfull ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 286
  if (dict->nodes) {
#line 287
    return (-1);
  }
  {
  {
#line 289
  tmp = malloc((size_t )(sizeof(struct node_small ) * (unsigned long )nsmall));
  }
#line 289
  dict->nodes_small = (struct node_small *)tmp;
#line 290
  dict->size_nodes_small = nsmall;
  {
#line 292
  tmp___0 = malloc((size_t )(sizeof(struct node_medium ) * (unsigned long )nmedium));
  }
#line 292
  dict->nodes_medium = (struct node_medium *)tmp___0;
#line 293
  dict->size_nodes_medium = nmedium;
  {
#line 295
  tmp___1 = malloc((size_t )(sizeof(struct node ) * (unsigned long )nfull));
  }
#line 295
  dict->nodes = (struct node *)tmp___1;
#line 296
  dict->size_nodes = nfull;
  }
#line 298
  if ((unsigned long )dict->nodes_small == (unsigned long )((void *)0)) {
#line 300
    return (-2);
  } else
#line 298
  if ((unsigned long )dict->nodes_medium == (unsigned long )((void *)0)) {
#line 300
    return (-2);
  } else
#line 298
  if ((unsigned long )dict->nodes == (unsigned long )((void *)0)) {
#line 300
    return (-2);
  }
#line 302
  return (0);
}
}
#line 318
static int do_read_dict(void *fp , void *prefixes , struct dict_radix *dict ) ;
#line 323 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
int read_dict(struct dict_radix *dict , char const   *dir ) 
{ 
  void *fp ;
  char s[1024] ;
  int small ;
  int medium ;
  int full ;
  int ret ;
  void *prefixes ;
  FILE *tmp ;
  int tmp___0 ;
  gzbFile *tmp___1 ;
  gzbFile *tmp___2 ;
  void *in ;
  int tmp___3 ;
  gzbFile *tmp___4 ;
  void *zero ;
  gzbFile *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 326
  if (dir) {
    {
    {
#line 334
    snprintf((char */* __restrict  */)(s), (size_t )sizeof(s), (char const   */* __restrict  */)"%s.sizes",
             dir);
    }
    {
#line 335
    tmp = fopen((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"r");
    }
#line 335
    fp = (void *)tmp;
    }
#line 335
    if (! fp) {
      {
      {
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t open %s.\n",
              s);
      }
      }
#line 337
      return (0);
    }
    {
    {
#line 339
    tmp___0 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d %d %d",
                     & small, & medium, & full);
    }
    }
#line 339
    if (tmp___0 != 3) {
      {
      {
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t read from %s.\n",
              s);
      }
      }
#line 341
      return (0);
    }
    {
    {
#line 343
    fclose((FILE *)fp);
    }
    {
#line 346
    tmp___1 = gzb_open(dir, "r");
    }
#line 346
    fp = (void *)tmp___1;
    }
#line 346
    if (! fp) {
      {
      {
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t open %s.\n",
              dir);
      }
      }
#line 348
      return (0);
    }
    {
    {
#line 360
    snprintf((char */* __restrict  */)(s), (size_t )sizeof(s), (char const   */* __restrict  */)"%s.prefixes",
             dir);
    }
    {
#line 361
    tmp___2 = gzb_open((char const   *)(s), "r");
    }
#line 361
    prefixes = (void *)tmp___2;
    }
#line 361
    if (! prefixes) {
      {
      {
#line 362
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t open %s.\n",
              s);
      }
      }
#line 363
      return (0);
    }
    {
    {
#line 374
    allocate_nodes(dict, small, medium, full);
    }
    {
#line 376
    ret = do_read_dict(fp, prefixes, dict);
    }
    {
#line 377
    gzb_close((gzbFile *)prefixes);
    }
    {
#line 381
    gzb_close((gzbFile *)fp);
    }
    }
#line 382
    return (ret);
  } else {
    {
    {
#line 386
    tmp___3 = fileno(stdin);
    }
    {
#line 386
    tmp___4 = gzb_dopen(tmp___3, "r");
    }
#line 386
    in = (void *)tmp___4;
    {
#line 388
    tmp___5 = gzb_open("/dev/zero", "r");
    }
#line 388
    zero = (void *)tmp___5;
    {
#line 398
    tmp___6 = do_read_dict(in, zero, dict);
    }
    }
#line 398
    return (tmp___6);
  }
}
}
#line 406 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static int do_read_dict(void *fp , void *prefixes , struct dict_radix *dict ) 
{ 
  struct node_index *stack[256] ;
  int sdepth ;
  int c ;
  int n ;
  int cc ;
  int nwords ;
  struct node *nodes ;
  struct node_small *nodes_small ;
  struct node_medium *nodes_medium ;
  int nnodes_small ;
  int nnodes_medium ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;
  int chosen ;
  int j ;
  struct node_small *n___0 ;
  int chosen___0 ;
  int tmp___1 ;
  int j___0 ;
  struct node_medium *n___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 412
  sdepth = 0;
#line 415
  nwords = 0;
#line 416
  nodes = dict->nodes;
#line 417
  nodes_small = dict->nodes_small;
#line 418
  nodes_medium = dict->nodes_medium;
#line 419
  nnodes_small = 0;
#line 419
  nnodes_medium = 0;
#line 419
  nnodes = 0;
#line 421
  if (dict->nnodes) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_small) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_medium) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nwords) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  }
#line 427
  if (! nodes) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_small) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_medium) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  }
  {
  {
#line 433
  memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
  }
#line 434
  tmp = nnodes;
#line 434
  nnodes ++;
#line 434
  dict->head.val_or_index = (unsigned int )tmp | (3U << 30);
#line 435
  stack[0] = & dict->head;
#line 436
  sdepth = 0;
  }
  {
  {
#line 437
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 437
    c = gzb_getc((gzbFile *)fp);
    }
    }
#line 437
    if (! (c != -1)) {
#line 437
      goto while_break;
    }
#line 438
    if (c >= 48) {
#line 438
      if (c <= 57) {
        {
#line 440
        nwords ++;
        {
#line 443
        tmp___0 = gzb_getc((gzbFile *)prefixes);
        }
#line 443
        (stack[sdepth])->val_or_index = (uint32_t )tmp___0;
#line 448
        n = 0;
        }
        {
        {
#line 449
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
#line 451
          n *= 10;
#line 452
          n += c - 48;
          {
#line 449
          c = gzb_getc((gzbFile *)fp);
          }
          }
#line 449
          if (c != -1) {
#line 449
            if (c >= 48) {
#line 449
              if (! (c <= 57)) {
#line 449
                goto while_break___0;
              }
            } else {
#line 449
              goto while_break___0;
            }
          } else {
#line 449
            goto while_break___0;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 454
        sdepth -= n;
#line 455
        if (sdepth < 0) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        } else
#line 455
        if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        }
      }
    }
#line 462
    if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
      {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: word too long... giving up\n");
      }
      }
#line 464
      return (0);
    }
    {
    {
#line 466
    cc = char_to_letter((unsigned char )c);
    }
    }
#line 469
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 471
      if (dict->nfree_nodes_small) {
#line 472
        (dict->nfree_nodes_small) --;
#line 472
        chosen = dict->free_nodes_small[dict->nfree_nodes_small];
      } else {
#line 475
        chosen = nnodes_small;
#line 476
        if (nnodes_small >= dict->size_nodes_small) {
          {
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (small) - failing.\n");
          }
          }
#line 478
          return (0);
        }
#line 480
        nnodes_small ++;
      }
      {
      {
#line 482
      memset((void *)(nodes_small + chosen), 0, (size_t )sizeof(*(nodes_small + chosen)));
      }
#line 483
      (nodes_small + chosen)->value = (stack[sdepth])->val_or_index;
#line 484
      (stack[sdepth])->val_or_index = (unsigned int )chosen | (1U << 30);
#line 486
      (nodes_small + chosen)->chars[0] = (char )c;
#line 487
      stack[sdepth + 1] = & (nodes_small + chosen)->children[0];
      }
    } else
#line 488
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 490
      n___0 = nodes_small + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 493
      j = 0;
      {
      {
#line 493
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 493
        if (! (j < 2)) {
#line 493
          goto while_break___1;
        }
#line 494
        if (! n___0->chars[j]) {
#line 495
          n___0->chars[j] = (char )c;
#line 496
          stack[sdepth + 1] = & n___0->children[j];
#line 497
          goto while_break___1;
        }
#line 493
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (j == 2) {
#line 502
        if (dict->nfree_nodes_medium) {
#line 503
          (dict->nfree_nodes_medium) --;
#line 503
          chosen___0 = dict->free_nodes_medium[dict->nfree_nodes_medium];
        } else {
#line 506
          chosen___0 = nnodes_medium;
#line 507
          if (nnodes_medium >= dict->size_nodes_medium) {
            {
            {
#line 508
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (medium) - failing.\n");
            }
            }
#line 509
            return (0);
          }
#line 511
          nnodes_medium ++;
        }
        {
        {
#line 513
        memset((void *)(nodes_medium + chosen___0), 0, (size_t )sizeof(*(nodes_medium + chosen___0)));
        }
        }
#line 514
        if ((unsigned long )dict->nfree_nodes_small >= sizeof(dict->free_nodes_small) / sizeof(dict->free_nodes_small[0])) {
          {
          {
#line 517
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_small.\n");
          }
          }
#line 518
          return (0);
        }
#line 520
        tmp___1 = dict->nfree_nodes_small;
#line 520
        (dict->nfree_nodes_small) ++;
#line 520
        dict->free_nodes_small[tmp___1] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 523
        (stack[sdepth])->val_or_index = (unsigned int )chosen___0 | (2U << 30);
#line 526
        (nodes_medium + chosen___0)->value = n___0->value;
#line 527
        j = 0;
        {
        {
#line 527
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 527
          if (! (j < 2)) {
#line 527
            goto while_break___2;
          }
#line 528
          (nodes_medium + chosen___0)->chars[j] = n___0->chars[j];
#line 530
          (nodes_medium + chosen___0)->children[j] = n___0->children[j];
#line 527
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        (nodes_medium + chosen___0)->chars[2] = (char )c;
#line 536
        stack[sdepth + 1] = & (nodes_medium + chosen___0)->children[2];
      }
    } else
#line 539
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 541
      n___1 = nodes_medium + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 544
      j___0 = 0;
      {
      {
#line 544
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! (j___0 < 8)) {
#line 544
          goto while_break___3;
        }
#line 545
        if (! n___1->chars[j___0]) {
#line 546
          n___1->chars[j___0] = (char )c;
#line 547
          stack[sdepth + 1] = & n___1->children[j___0];
#line 548
          goto while_break___3;
        }
#line 544
        j___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      if (j___0 == 8) {
#line 552
        if (nnodes >= dict->size_nodes) {
          {
          {
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (full) - failing.\n");
          }
          }
#line 554
          return (0);
        }
        {
        {
#line 556
        memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
        }
#line 557
        (nodes + nnodes)->value = n___1->value;
        }
#line 558
        if ((unsigned long )dict->nfree_nodes_medium >= sizeof(dict->free_nodes_medium) / sizeof(dict->free_nodes_medium[0])) {
          {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_medium.\n");
          }
          }
#line 562
          return (0);
        }
#line 564
        tmp___2 = dict->nfree_nodes_medium;
#line 564
        (dict->nfree_nodes_medium) ++;
#line 564
        dict->free_nodes_medium[tmp___2] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 567
        (stack[sdepth])->val_or_index = (unsigned int )nnodes | (3U << 30);
#line 569
        j___0 = 0;
        {
        {
#line 569
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 569
          if (! (j___0 < 8)) {
#line 569
            goto while_break___4;
          }
          {
          {
#line 570
          tmp___3 = char_to_letter((unsigned char )n___1->chars[j___0]);
          }
#line 570
          (nodes + nnodes)->children[tmp___3] = n___1->children[j___0];
#line 569
          j___0 ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 574
        stack[sdepth + 1] = & (nodes + nnodes)->children[cc];
#line 575
        nnodes ++;
      }
    } else {
#line 578
      stack[sdepth + 1] = & (nodes + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30))))->children[cc];
    }
#line 581
    sdepth ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  nwords ++;
  {
#line 586
  tmp___4 = gzb_getc((gzbFile *)prefixes);
  }
#line 586
  (stack[sdepth])->val_or_index = (uint32_t )tmp___4;
#line 592
  dict->nwords = nwords;
#line 593
  dict->nnodes_small = nnodes_small;
#line 594
  dict->nnodes_medium = nnodes_medium;
#line 595
  dict->nnodes = nnodes;
  }
#line 597
  return (1);
}
}
#line 600 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
void print_stats(struct dict_radix *dict ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d words in %d full nodes, %d medium nodes, %d small nodes.\n",
          dict->nwords, dict->nnodes, dict->nnodes_medium, dict->nnodes_small);
  }
  {
#line 606
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d nfree_nodes_small %d nfree_nodes_medium.\n",
          dict->nfree_nodes_small, dict->nfree_nodes_medium);
  }
  {
#line 608
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"node memory filled: %d K\n",
          (((unsigned long )dict->nnodes * sizeof(struct node ) + (unsigned long )dict->nnodes_small * sizeof(struct node_small )) + (unsigned long )dict->nnodes_medium * sizeof(struct node_medium )) / 1024UL);
  }
  }
#line 613
  return;
}
}
#line 615 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
void print_tree(struct dict_radix *dict ) 
{ 
  char word[256] ;
  void *__cil_tmp3 ;

  {
  {
  {
#line 619
  do_print_tree(dict->nodes, dict->nodes_small, dict->nodes_medium, dict->head, word,
                0, (int )sizeof(word));
  }
  }
#line 622
  return;
}
}
#line 624 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
void print_sizes(struct dict_radix *dict ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 627
  printf((char const   */* __restrict  */)"%d %d %d\n", dict->nnodes_small, dict->nnodes_medium,
         dict->nnodes);
  }
  }
#line 629
  return;
}
}
#line 631 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
int lookup(struct dict_radix  const  *dict , char const   *word ) 
{ 
  struct node_index current ;
  struct node_small *n ;
  struct node_medium *n___0 ;
  register char c ;
  register char *cs ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  register int ind ;
  register unsigned char c___0 ;

  {
#line 634
  current = dict->head;
  {
  {
#line 635
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 637
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 637
      goto case_0;
    }
#line 646
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 646
      goto case_exp;
    }
#line 667
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 667
      goto case_exp___0;
    }
#line 696
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 696
      goto case_exp___1;
    }
#line 636
    goto switch_break;
    case_0: /* CIL Label */ 
#line 638
    if (*word) {
#line 641
      return (0);
    } else {
#line 643
      return ((int )(current.val_or_index & ~ ((1U << 31) | (1U << 30))));
    }
#line 645
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 647
    if (*word) {
#line 648
      n = dict->nodes_small + (current.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 652
      if ((int )n->chars[0] == (int )*word) {
#line 653
        current = n->children[0];
      } else
#line 654
      if ((int )n->chars[1] == (int )*word) {
#line 655
        current = n->children[1];
      } else {
#line 657
        return (0);
      }
    } else {
#line 662
      return ((int )(dict->nodes_small + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->value);
    }
#line 666
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 668
    if (*word) {
#line 669
      n___0 = dict->nodes_medium + (current.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 673
      c = (char )*word;
#line 673
      cs = n___0->chars;
#line 677
      tmp___6 = cs;
#line 677
      cs ++;
#line 677
      if ((int )*tmp___6 == (int )c) {
#line 677
        current = n___0->children[0];
      } else {
#line 678
        tmp___5 = cs;
#line 678
        cs ++;
#line 678
        if ((int )*tmp___5 == (int )c) {
#line 678
          current = n___0->children[1];
        } else {
#line 679
          tmp___4 = cs;
#line 679
          cs ++;
#line 679
          if ((int )*tmp___4 == (int )c) {
#line 679
            current = n___0->children[2];
          } else {
#line 680
            tmp___3 = cs;
#line 680
            cs ++;
#line 680
            if ((int )*tmp___3 == (int )c) {
#line 680
              current = n___0->children[3];
            } else {
#line 681
              tmp___2 = cs;
#line 681
              cs ++;
#line 681
              if ((int )*tmp___2 == (int )c) {
#line 681
                current = n___0->children[4];
              } else {
#line 682
                tmp___1 = cs;
#line 682
                cs ++;
#line 682
                if ((int )*tmp___1 == (int )c) {
#line 682
                  current = n___0->children[5];
                } else {
#line 683
                  tmp___0 = cs;
#line 683
                  cs ++;
#line 683
                  if ((int )*tmp___0 == (int )c) {
#line 683
                    current = n___0->children[6];
                  } else {
#line 684
                    tmp = cs;
#line 684
                    cs ++;
#line 684
                    if ((int )*tmp == (int )c) {
#line 684
                      current = n___0->children[7];
                    } else {
#line 686
                      return (0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
#line 691
      return ((int )(dict->nodes_medium + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->value);
    }
#line 695
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 697
    if (*word) {
#line 700
      c___0 = (unsigned char )*word;
#line 701
      if ((int )c___0 >= 224) {
#line 701
        if ((int )c___0 < 251) {
#line 703
          ind = ((int )c___0 - 224) + 2;
        } else {
#line 701
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 704
      if ((int )c___0 == 34) {
#line 705
        ind = 0;
      } else
#line 706
      if ((int )c___0 == 39) {
#line 707
        ind = 1;
      } else {
#line 709
        return (0);
      }
#line 710
      current = (dict->nodes + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->children[ind];
    } else {
#line 714
      return ((int )(dict->nodes + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->value);
    }
#line 717
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 719
    word ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 11 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static int gim2int___0(char const   *w ) 
{ 
  int n ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 13
  n = 0;
#line 14
  if (hspell_debug) {
    {
    {
#line 14
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gim2int got %s ",
            w);
    }
    }
  }
  {
  {
#line 15
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 15
    if (! *w) {
#line 15
      goto while_break;
    }
    {
#line 17
    if ((int const   )*w == 39) {
#line 17
      goto case_39;
    }
#line 28
    if ((int const   )*w == -32) {
#line 28
      goto case_neg_32;
    }
#line 29
    if ((int const   )*w == -31) {
#line 29
      goto case_neg_31;
    }
#line 30
    if ((int const   )*w == -30) {
#line 30
      goto case_neg_30;
    }
#line 31
    if ((int const   )*w == -29) {
#line 31
      goto case_neg_29;
    }
#line 32
    if ((int const   )*w == -28) {
#line 32
      goto case_neg_28;
    }
#line 33
    if ((int const   )*w == -27) {
#line 33
      goto case_neg_27;
    }
#line 34
    if ((int const   )*w == -26) {
#line 34
      goto case_neg_26;
    }
#line 35
    if ((int const   )*w == -25) {
#line 35
      goto case_neg_25;
    }
#line 36
    if ((int const   )*w == -24) {
#line 36
      goto case_neg_24;
    }
#line 37
    if ((int const   )*w == -23) {
#line 37
      goto case_neg_23;
    }
#line 38
    if ((int const   )*w == -22) {
#line 38
      goto case_neg_22;
    }
#line 38
    if ((int const   )*w == -21) {
#line 38
      goto case_neg_22;
    }
#line 39
    if ((int const   )*w == -20) {
#line 39
      goto case_neg_20;
    }
#line 40
    if ((int const   )*w == -19) {
#line 40
      goto case_neg_19;
    }
#line 40
    if ((int const   )*w == -18) {
#line 40
      goto case_neg_19;
    }
#line 41
    if ((int const   )*w == -17) {
#line 41
      goto case_neg_17;
    }
#line 41
    if ((int const   )*w == -16) {
#line 41
      goto case_neg_17;
    }
#line 42
    if ((int const   )*w == -15) {
#line 42
      goto case_neg_15;
    }
#line 43
    if ((int const   )*w == -14) {
#line 43
      goto case_neg_14;
    }
#line 44
    if ((int const   )*w == -13) {
#line 44
      goto case_neg_13;
    }
#line 44
    if ((int const   )*w == -12) {
#line 44
      goto case_neg_13;
    }
#line 45
    if ((int const   )*w == -11) {
#line 45
      goto case_neg_11;
    }
#line 45
    if ((int const   )*w == -10) {
#line 45
      goto case_neg_11;
    }
#line 46
    if ((int const   )*w == -9) {
#line 46
      goto case_neg_9;
    }
#line 47
    if ((int const   )*w == -8) {
#line 47
      goto case_neg_8;
    }
#line 48
    if ((int const   )*w == -7) {
#line 48
      goto case_neg_7;
    }
#line 49
    if ((int const   )*w == -6) {
#line 49
      goto case_neg_6;
    }
#line 16
    goto switch_break;
    case_39: /* CIL Label */ 
#line 25
    if (*(w + 1)) {
#line 26
      n *= 1000;
    }
#line 27
    goto switch_break;
    case_neg_32: /* CIL Label */ 
#line 28
    n ++;
#line 28
    goto switch_break;
    case_neg_31: /* CIL Label */ 
#line 29
    n += 2;
#line 29
    goto switch_break;
    case_neg_30: /* CIL Label */ 
#line 30
    n += 3;
#line 30
    goto switch_break;
    case_neg_29: /* CIL Label */ 
#line 31
    n += 4;
#line 31
    goto switch_break;
    case_neg_28: /* CIL Label */ 
#line 32
    n += 5;
#line 32
    goto switch_break;
    case_neg_27: /* CIL Label */ 
#line 33
    n += 6;
#line 33
    goto switch_break;
    case_neg_26: /* CIL Label */ 
#line 34
    n += 7;
#line 34
    goto switch_break;
    case_neg_25: /* CIL Label */ 
#line 35
    n += 8;
#line 35
    goto switch_break;
    case_neg_24: /* CIL Label */ 
#line 36
    n += 9;
#line 36
    goto switch_break;
    case_neg_23: /* CIL Label */ 
#line 37
    n += 10;
#line 37
    goto switch_break;
    case_neg_22: /* CIL Label */ 
    case_neg_21: /* CIL Label */ 
#line 38
    n += 20;
#line 38
    goto switch_break;
    case_neg_20: /* CIL Label */ 
#line 39
    n += 30;
#line 39
    goto switch_break;
    case_neg_19: /* CIL Label */ 
    case_neg_18: /* CIL Label */ 
#line 40
    n += 40;
#line 40
    goto switch_break;
    case_neg_17: /* CIL Label */ 
    case_neg_16: /* CIL Label */ 
#line 41
    n += 50;
#line 41
    goto switch_break;
    case_neg_15: /* CIL Label */ 
#line 42
    n += 60;
#line 42
    goto switch_break;
    case_neg_14: /* CIL Label */ 
#line 43
    n += 70;
#line 43
    goto switch_break;
    case_neg_13: /* CIL Label */ 
    case_neg_12: /* CIL Label */ 
#line 44
    n += 80;
#line 44
    goto switch_break;
    case_neg_11: /* CIL Label */ 
    case_neg_10: /* CIL Label */ 
#line 45
    n += 90;
#line 45
    goto switch_break;
    case_neg_9: /* CIL Label */ 
#line 46
    n += 100;
#line 46
    goto switch_break;
    case_neg_8: /* CIL Label */ 
#line 47
    n += 200;
#line 47
    goto switch_break;
    case_neg_7: /* CIL Label */ 
#line 48
    n += 300;
#line 48
    goto switch_break;
    case_neg_6: /* CIL Label */ 
#line 49
    n += 400;
#line 49
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 52
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (hspell_debug) {
    {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %d\n",
            n);
    }
    }
  }
#line 55
  return (n);
}
}
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *appendStr___0(char *src , char *dst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! *src) {
#line 99
      goto while_break;
    }
#line 100
    tmp = dst;
#line 100
    dst ++;
#line 100
    tmp___0 = src;
#line 100
    src ++;
#line 100
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  *dst = (char )'\000';
#line 103
  return (dst);
}
}
#line 108
static void int2gim___0(int n , char *buf ) ;
#line 108 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *digits___0[3][9]  = { {        (char *)"\340",        (char *)"\341",        (char *)"\342",        (char *)"\343", 
            (char *)"\344",        (char *)"\345",        (char *)"\346",        (char *)"\347", 
            (char *)"\350"}, 
   {        (char *)"\351",        (char *)"\353",        (char *)"\354",        (char *)"\356", 
            (char *)"\360",        (char *)"\361",        (char *)"\362",        (char *)"\364", 
            (char *)"\366"}, 
   {        (char *)"\367",        (char *)"\370",        (char *)"\371",        (char *)"\372", 
            (char *)"\367\372",        (char *)"\370\372",        (char *)"\371\372",        (char *)"\372\372", 
            (char *)"\367\372\372"}};
#line 113 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *special___0[2]  = {      (char *)"\345\350",      (char *)"\346\350"};
#line 105 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static void int2gim___0(int n , char *buf ) 
{ 
  int i ;
  char *b ;
  char *bleft ;
  char *bright ;
  char tmp ;
  char save ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 114
  i = 0;
#line 115
  b = buf;
#line 116
  *b = (char )'\000';
#line 118
  if (hspell_debug) {
    {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"int2gim got %d ",
            n);
    }
    }
  }
  {
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (n > 0)) {
#line 119
      goto while_break;
    }
#line 120
    if (i == 3) {
      {
#line 120
      i = 0;
      {
#line 120
      b = appendStr___0((char *)"\'", b);
      }
      }
    }
#line 121
    if (! i) {
#line 121
      if (n % 100 == 15) {
        {
        {
#line 122
        b = appendStr___0(special___0[n % 100 - 15], b);
        }
#line 123
        n /= 100;
#line 124
        i = 2;
        }
      } else
#line 121
      if (n % 100 == 16) {
        {
        {
#line 122
        b = appendStr___0(special___0[n % 100 - 15], b);
        }
#line 123
        n /= 100;
#line 124
        i = 2;
        }
      } else {
#line 121
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 126
      if (n % 10) {
        {
        {
#line 126
        b = appendStr___0(digits___0[i][n % 10 - 1], b);
        }
        }
      }
#line 128
      n /= 10;
#line 129
      i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (hspell_debug) {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"before %s\n",
            buf);
    }
    }
  }
#line 134
  if ((int )*(buf + 0) != 0) {
#line 135
    bleft = buf;
#line 135
    bright = b - 1;
    {
    {
#line 135
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! ((unsigned long )bright > (unsigned long )bleft)) {
#line 135
        goto while_break___0;
      }
#line 137
      tmp = *bleft;
#line 138
      *bleft = *bright;
#line 139
      *bright = tmp;
#line 135
      bleft ++;
#line 135
      bright --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 141
  if (hspell_debug) {
    {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"after %s\n",
            buf);
    }
    }
  }
#line 143
  if (*(buf + 0)) {
    {
#line 145
    if ((int )*(b + -1) == -21) {
#line 145
      goto case_neg_21;
    }
#line 146
    if ((int )*(b + -1) == -18) {
#line 146
      goto case_neg_18;
    }
#line 147
    if ((int )*(b + -1) == -16) {
#line 147
      goto case_neg_16;
    }
#line 148
    if ((int )*(b + -1) == -10) {
#line 148
      goto case_neg_10;
    }
#line 149
    if ((int )*(b + -1) == -12) {
#line 149
      goto case_neg_12;
    }
#line 144
    goto switch_break;
    case_neg_21: /* CIL Label */ 
#line 145
    *(b + -1) = (char )'\352';
#line 145
    goto switch_break;
    case_neg_18: /* CIL Label */ 
#line 146
    *(b + -1) = (char )'\355';
#line 146
    goto switch_break;
    case_neg_16: /* CIL Label */ 
#line 147
    *(b + -1) = (char )'\357';
#line 147
    goto switch_break;
    case_neg_10: /* CIL Label */ 
#line 148
    *(b + -1) = (char )'\365';
#line 148
    goto switch_break;
    case_neg_12: /* CIL Label */ 
#line 149
    *(b + -1) = (char )'\363';
#line 149
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 155
  if ((int )*(buf + 0) != 0) {
#line 156
    if ((int )*(buf + 1) == 0) {
#line 157
      *(buf + 1) = (char )'\'';
#line 158
      *(buf + 2) = (char )'\000';
    } else
#line 163
    if ((int )*(b + -2) == 39) {
#line 163
      if ((int )*(b + -1) != 39) {
#line 164
        *(b + 0) = (char )'\'';
#line 165
        *(b + 1) = (char )'\000';
      } else {
#line 163
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 166
    if ((int )*(b + -1) != 39) {
#line 167
      save = *(b + -1);
#line 168
      *(b + -1) = (char )'\"';
#line 169
      *(b + 0) = save;
#line 170
      *(b + 1) = (char )'\000';
    }
  }
#line 173
  if (hspell_debug) {
    {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %s\n",
            buf);
    }
    }
  }
#line 174
  return;
}
}
#line 172 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static void do_print_tree___0(struct node *nodes , struct node_small *nodes_small ,
                              struct node_medium *nodes_medium , struct node_index head ,
                              char *word , int len , int maxlen ) 
{ 
  int i ;
  struct node *n ;
  unsigned char tmp ;
  struct node_small *n___0 ;
  struct node_medium *n___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 177
  if (len >= maxlen) {
    {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_print_tree(): warning: buffer overflow.\n");
    }
    }
#line 179
    return;
  }
#line 181
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 182
    n = nodes + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 183
    if (n->value) {
      {
#line 184
      *(word + len) = (char )'\000';
      {
#line 185
      printf((char const   */* __restrict  */)"%s %d\n", word, n->value);
      }
      }
    }
#line 187
    i = 0;
    {
    {
#line 187
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 187
      if (! (i < 29)) {
#line 187
        goto while_break;
      }
      {
      {
#line 188
      tmp = letter_to_char(i);
      }
#line 188
      *(word + len) = (char )tmp;
      {
#line 189
      do_print_tree___0(nodes, nodes_small, nodes_medium, n->children[i], word, len + 1,
                        maxlen);
      }
#line 187
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 192
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 193
    n___0 = nodes_small + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 194
    if (n___0->value) {
      {
#line 195
      *(word + len) = (char )'\000';
      {
#line 196
      printf((char const   */* __restrict  */)"%s %d\n", word, n___0->value);
      }
      }
    }
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 2)) {
#line 198
        goto while_break___0;
      }
#line 199
      if (n___0->chars[i]) {
        {
#line 200
        *(word + len) = n___0->chars[i];
        {
#line 201
        do_print_tree___0(nodes, nodes_small, nodes_medium, n___0->children[i], word,
                          len + 1, maxlen);
        }
        }
      }
#line 198
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 205
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 206
    n___1 = nodes_medium + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 207
    if (n___1->value) {
      {
#line 208
      *(word + len) = (char )'\000';
      {
#line 209
      printf((char const   */* __restrict  */)"%s %d\n", word, n___1->value);
      }
      }
    }
#line 211
    i = 0;
    {
    {
#line 211
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 211
      if (! (i < 8)) {
#line 211
        goto while_break___1;
      }
#line 212
      if (n___1->chars[i]) {
        {
#line 213
        *(word + len) = n___1->chars[i];
        {
#line 214
        do_print_tree___0(nodes, nodes_small, nodes_medium, n___1->children[i], word,
                          len + 1, maxlen);
        }
        }
      }
#line 211
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if (head.val_or_index) {
    {
#line 219
    *(word + len) = (char )'\000';
    {
#line 220
    printf((char const   */* __restrict  */)"%s %d\n", word, head.val_or_index);
    }
    }
  }
#line 222
  return;
}
}
#line 318
static int do_read_dict___0(void *fp , void *prefixes , struct dict_radix *dict ) ;
#line 406 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static int do_read_dict___0(void *fp , void *prefixes , struct dict_radix *dict ) 
{ 
  struct node_index *stack[256] ;
  int sdepth ;
  int c ;
  int n ;
  int cc ;
  int nwords ;
  struct node *nodes ;
  struct node_small *nodes_small ;
  struct node_medium *nodes_medium ;
  int nnodes_small ;
  int nnodes_medium ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;
  int chosen ;
  int j ;
  struct node_small *n___0 ;
  int chosen___0 ;
  int tmp___1 ;
  int j___0 ;
  struct node_medium *n___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 412
  sdepth = 0;
#line 415
  nwords = 0;
#line 416
  nodes = dict->nodes;
#line 417
  nodes_small = dict->nodes_small;
#line 418
  nodes_medium = dict->nodes_medium;
#line 419
  nnodes_small = 0;
#line 419
  nnodes_medium = 0;
#line 419
  nnodes = 0;
#line 421
  if (dict->nnodes) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_small) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_medium) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nwords) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  }
#line 427
  if (! nodes) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_small) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_medium) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  }
  {
  {
#line 433
  memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
  }
#line 434
  tmp = nnodes;
#line 434
  nnodes ++;
#line 434
  dict->head.val_or_index = (unsigned int )tmp | (3U << 30);
#line 435
  stack[0] = & dict->head;
#line 436
  sdepth = 0;
  }
  {
  {
#line 437
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 437
    c = gzb_getc((gzbFile *)fp);
    }
    }
#line 437
    if (! (c != -1)) {
#line 437
      goto while_break;
    }
#line 438
    if (c >= 48) {
#line 438
      if (c <= 57) {
        {
#line 440
        nwords ++;
        {
#line 443
        tmp___0 = gzb_getc((gzbFile *)prefixes);
        }
#line 443
        (stack[sdepth])->val_or_index = (uint32_t )tmp___0;
#line 448
        n = 0;
        }
        {
        {
#line 449
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
#line 451
          n *= 10;
#line 452
          n += c - 48;
          {
#line 449
          c = gzb_getc((gzbFile *)fp);
          }
          }
#line 449
          if (c != -1) {
#line 449
            if (c >= 48) {
#line 449
              if (! (c <= 57)) {
#line 449
                goto while_break___0;
              }
            } else {
#line 449
              goto while_break___0;
            }
          } else {
#line 449
            goto while_break___0;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 454
        sdepth -= n;
#line 455
        if (sdepth < 0) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        } else
#line 455
        if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        }
      }
    }
#line 462
    if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
      {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: word too long... giving up\n");
      }
      }
#line 464
      return (0);
    }
    {
    {
#line 466
    cc = char_to_letter((unsigned char )c);
    }
    }
#line 469
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 471
      if (dict->nfree_nodes_small) {
#line 472
        (dict->nfree_nodes_small) --;
#line 472
        chosen = dict->free_nodes_small[dict->nfree_nodes_small];
      } else {
#line 475
        chosen = nnodes_small;
#line 476
        if (nnodes_small >= dict->size_nodes_small) {
          {
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (small) - failing.\n");
          }
          }
#line 478
          return (0);
        }
#line 480
        nnodes_small ++;
      }
      {
      {
#line 482
      memset((void *)(nodes_small + chosen), 0, (size_t )sizeof(*(nodes_small + chosen)));
      }
#line 483
      (nodes_small + chosen)->value = (stack[sdepth])->val_or_index;
#line 484
      (stack[sdepth])->val_or_index = (unsigned int )chosen | (1U << 30);
#line 486
      (nodes_small + chosen)->chars[0] = (char )c;
#line 487
      stack[sdepth + 1] = & (nodes_small + chosen)->children[0];
      }
    } else
#line 488
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 490
      n___0 = nodes_small + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 493
      j = 0;
      {
      {
#line 493
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 493
        if (! (j < 2)) {
#line 493
          goto while_break___1;
        }
#line 494
        if (! n___0->chars[j]) {
#line 495
          n___0->chars[j] = (char )c;
#line 496
          stack[sdepth + 1] = & n___0->children[j];
#line 497
          goto while_break___1;
        }
#line 493
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (j == 2) {
#line 502
        if (dict->nfree_nodes_medium) {
#line 503
          (dict->nfree_nodes_medium) --;
#line 503
          chosen___0 = dict->free_nodes_medium[dict->nfree_nodes_medium];
        } else {
#line 506
          chosen___0 = nnodes_medium;
#line 507
          if (nnodes_medium >= dict->size_nodes_medium) {
            {
            {
#line 508
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (medium) - failing.\n");
            }
            }
#line 509
            return (0);
          }
#line 511
          nnodes_medium ++;
        }
        {
        {
#line 513
        memset((void *)(nodes_medium + chosen___0), 0, (size_t )sizeof(*(nodes_medium + chosen___0)));
        }
        }
#line 514
        if ((unsigned long )dict->nfree_nodes_small >= sizeof(dict->free_nodes_small) / sizeof(dict->free_nodes_small[0])) {
          {
          {
#line 517
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_small.\n");
          }
          }
#line 518
          return (0);
        }
#line 520
        tmp___1 = dict->nfree_nodes_small;
#line 520
        (dict->nfree_nodes_small) ++;
#line 520
        dict->free_nodes_small[tmp___1] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 523
        (stack[sdepth])->val_or_index = (unsigned int )chosen___0 | (2U << 30);
#line 526
        (nodes_medium + chosen___0)->value = n___0->value;
#line 527
        j = 0;
        {
        {
#line 527
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 527
          if (! (j < 2)) {
#line 527
            goto while_break___2;
          }
#line 528
          (nodes_medium + chosen___0)->chars[j] = n___0->chars[j];
#line 530
          (nodes_medium + chosen___0)->children[j] = n___0->children[j];
#line 527
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        (nodes_medium + chosen___0)->chars[2] = (char )c;
#line 536
        stack[sdepth + 1] = & (nodes_medium + chosen___0)->children[2];
      }
    } else
#line 539
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 541
      n___1 = nodes_medium + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 544
      j___0 = 0;
      {
      {
#line 544
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! (j___0 < 8)) {
#line 544
          goto while_break___3;
        }
#line 545
        if (! n___1->chars[j___0]) {
#line 546
          n___1->chars[j___0] = (char )c;
#line 547
          stack[sdepth + 1] = & n___1->children[j___0];
#line 548
          goto while_break___3;
        }
#line 544
        j___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      if (j___0 == 8) {
#line 552
        if (nnodes >= dict->size_nodes) {
          {
          {
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (full) - failing.\n");
          }
          }
#line 554
          return (0);
        }
        {
        {
#line 556
        memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
        }
#line 557
        (nodes + nnodes)->value = n___1->value;
        }
#line 558
        if ((unsigned long )dict->nfree_nodes_medium >= sizeof(dict->free_nodes_medium) / sizeof(dict->free_nodes_medium[0])) {
          {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_medium.\n");
          }
          }
#line 562
          return (0);
        }
#line 564
        tmp___2 = dict->nfree_nodes_medium;
#line 564
        (dict->nfree_nodes_medium) ++;
#line 564
        dict->free_nodes_medium[tmp___2] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 567
        (stack[sdepth])->val_or_index = (unsigned int )nnodes | (3U << 30);
#line 569
        j___0 = 0;
        {
        {
#line 569
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 569
          if (! (j___0 < 8)) {
#line 569
            goto while_break___4;
          }
          {
          {
#line 570
          tmp___3 = char_to_letter((unsigned char )n___1->chars[j___0]);
          }
#line 570
          (nodes + nnodes)->children[tmp___3] = n___1->children[j___0];
#line 569
          j___0 ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 574
        stack[sdepth + 1] = & (nodes + nnodes)->children[cc];
#line 575
        nnodes ++;
      }
    } else {
#line 578
      stack[sdepth + 1] = & (nodes + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30))))->children[cc];
    }
#line 581
    sdepth ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  nwords ++;
  {
#line 586
  tmp___4 = gzb_getc((gzbFile *)prefixes);
  }
#line 586
  (stack[sdepth])->val_or_index = (uint32_t )tmp___4;
#line 592
  dict->nwords = nwords;
#line 593
  dict->nnodes_small = nnodes_small;
#line 594
  dict->nnodes_medium = nnodes_medium;
#line 595
  dict->nnodes = nnodes;
  }
#line 597
  return (1);
}
}
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 54 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.h"
int corlist_add(struct corlist *cl , char const   *s ) ;
#line 55
int corlist_init(struct corlist *cl ) ;
#line 56
int corlist_free(struct corlist *cl ) ;
#line 9 "/home/wslee/benchmarks/textformat/hspell-1.0/corlist.c"
int corlist_init(struct corlist *cl ) 
{ 


  {
#line 12
  cl->n = 0;
#line 13
  return (1);
}
}
#line 16 "/home/wslee/benchmarks/textformat/hspell-1.0/corlist.c"
int corlist_free(struct corlist *cl ) 
{ 


  {
#line 20
  cl->n = 0;
#line 21
  return (1);
}
}
#line 24 "/home/wslee/benchmarks/textformat/hspell-1.0/corlist.c"
int corlist_add(struct corlist *cl , char const   *s ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 28
  i = 0;
  {
  {
#line 28
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < cl->n)) {
#line 28
      goto while_break;
    }
    {
    {
#line 29
    tmp = strcmp((char const   *)(cl->correction[i]), s);
    }
    }
#line 29
    if (! tmp) {
#line 30
      return (1);
    }
#line 28
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  if ((unsigned long )cl->n == sizeof(cl->correction) / sizeof(cl->correction[0])) {
#line 33
    return (0);
  }
  {
#line 34
  tmp___0 = cl->n;
#line 34
  (cl->n) ++;
  {
#line 34
  strncpy((char */* __restrict  */)(cl->correction[tmp___0]), (char const   */* __restrict  */)s,
          (size_t )sizeof(cl->correction[0]));
  }
  }
#line 35
  return (1);
}
}
#line 183 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 28 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.h"
int hspell_init(struct dict_radix **dictp , int flags ) ;
#line 30
int hspell_check_word(struct dict_radix *dict , char const   *word , int *preflen ) ;
#line 32
void hspell_trycorrect(struct dict_radix *dict , char const   *w , struct corlist *cl ) ;
#line 36
void hspell_uninit(struct dict_radix *dict ) ;
#line 38
char const   *hspell_get_dictionary_path(void) ;
#line 39
void hspell_set_dictionary_path(char const   *path ) ;
#line 73
int hspell_enum_splits(struct dict_radix *dict , char const   *word , hspell_word_split_callback_func *enumf ) ;
#line 23 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static char const   *hspell_dictionary  =    "/usr/local/share/hspell/hebrew.wgz";
#line 25 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
char const   *hspell_get_dictionary_path(void) 
{ 


  {
#line 28
  return (hspell_dictionary);
}
}
#line 31 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
void hspell_set_dictionary_path(char const   *path ) 
{ 


  {
#line 35
  hspell_dictionary = path;
#line 36
  return;
}
}
#line 40 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
int hspell_debug  =    0;
#line 45 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static int load_data(struct dict_radix **dictp ) 
{ 
  clock_t t1 ;
  clock_t t2 ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 49
  if (hspell_debug) {
    {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading data files... ");
    }
    {
#line 51
    t1 = clock();
    }
    }
  }
  {
  {
#line 54
  *dictp = new_dict_radix();
  }
  {
#line 55
  tmp = read_dict(*dictp, hspell_dictionary);
  }
  }
#line 55
  if (! tmp) {
    {
    {
#line 56
    delete_dict_radix(*dictp);
    }
    }
#line 57
    return (-1);
  }
#line 60
  if (hspell_debug) {
    {
    {
#line 61
    t2 = clock();
    }
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done (%d ms).\n",
            (int )((t2 - t1) / 1000L));
    }
    }
  }
#line 65
  return (0);
}
}
#line 5 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static char *prefixes_noH[243]  = 
#line 5 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\345",      (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344", 
        (char *)"\345\353",      (char *)"\345\353\341",      (char *)"\345\353\353",      (char *)"\345\353\354", 
        (char *)"\345\353\356",      (char *)"\345\353\356\344",      (char *)"\345\353\371",      (char *)"\345\353\371\341", 
        (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344",      (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341", 
        (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354",      (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344", 
        (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353",      (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344", 
        (char *)"\345\353\371\356\353",      (char *)"\345\354",      (char *)"\345\354\353",      (char *)"\345\354\353\371", 
        (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353",      (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353", 
        (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353",      (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356", 
        (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354",      (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356", 
        (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353",      (char *)"\345\356",      (char *)"\345\356\344", 
        (char *)"\345\356\353",      (char *)"\345\356\371",      (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353", 
        (char *)"\345\356\371\344",      (char *)"\345\356\371\353",      (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353", 
        (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356",      (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354", 
        (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356",      (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353", 
        (char *)"\345\371",      (char *)"\345\371\341",      (char *)"\345\371\341\353",      (char *)"\345\371\344", 
        (char *)"\345\371\353",      (char *)"\345\371\353\341",      (char *)"\345\371\353\353",      (char *)"\345\371\353\354", 
        (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344",      (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341", 
        (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344",      (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341", 
        (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354",      (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344", 
        (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353",      (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344", 
        (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354",      (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371", 
        (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353",      (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353", 
        (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353",      (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356", 
        (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354",      (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356", 
        (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353",      (char *)"\345\371\356",      (char *)"\345\371\356\344", 
        (char *)"\345\371\356\353",      (char *)"\345\371\356\371",      (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353", 
        (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353",      (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353", 
        (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356",      (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354", 
        (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356",      (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353", 
        (char *)"\353",      (char *)"\353\341",      (char *)"\353\353",      (char *)"\353\354", 
        (char *)"\353\356",      (char *)"\353\356\344",      (char *)"\353\371",      (char *)"\353\371\341", 
        (char *)"\353\371\341\353",      (char *)"\353\371\344",      (char *)"\353\371\353",      (char *)"\353\371\353\341", 
        (char *)"\353\371\353\353",      (char *)"\353\371\353\354",      (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344", 
        (char *)"\353\371\354",      (char *)"\353\371\354\353",      (char *)"\353\371\356",      (char *)"\353\371\356\344", 
        (char *)"\353\371\356\353",      (char *)"\354",      (char *)"\354\353",      (char *)"\354\353\371", 
        (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353",      (char *)"\354\353\371\344",      (char *)"\354\353\371\353", 
        (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353",      (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356", 
        (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354",      (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356", 
        (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353",      (char *)"\356",      (char *)"\356\341", 
        (char *)"\356\344",      (char *)"\356\353",      (char *)"\356\354",      (char *)"\356\371", 
        (char *)"\356\371\341",      (char *)"\356\371\341\353",      (char *)"\356\371\344",      (char *)"\356\371\353", 
        (char *)"\356\371\353\341",      (char *)"\356\371\353\353",      (char *)"\356\371\353\354",      (char *)"\356\371\353\356", 
        (char *)"\356\371\353\356\344",      (char *)"\356\371\354",      (char *)"\356\371\354\353",      (char *)"\356\371\356", 
        (char *)"\356\371\356\344",      (char *)"\356\371\356\353",      (char *)"\371",      (char *)"\371\341", 
        (char *)"\371\341\353",      (char *)"\371\344",      (char *)"\371\353",      (char *)"\371\353\341", 
        (char *)"\371\353\353",      (char *)"\371\353\354",      (char *)"\371\353\356",      (char *)"\371\353\356\344", 
        (char *)"\371\353\371",      (char *)"\371\353\371\341",      (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344", 
        (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341",      (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354", 
        (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344",      (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353", 
        (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344",      (char *)"\371\353\371\356\353",      (char *)"\371\354", 
        (char *)"\371\354\353",      (char *)"\371\354\353\371",      (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353", 
        (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353",      (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353", 
        (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356",      (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354", 
        (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356",      (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353", 
        (char *)"\371\356",      (char *)"\371\356\344",      (char *)"\371\356\353",      (char *)"\371\356\371", 
        (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353",      (char *)"\371\356\371\344",      (char *)"\371\356\371\353", 
        (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353",      (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356", 
        (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354",      (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356", 
        (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353",      (char *)0};
#line 248 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static int masks_noH[243]  = 
#line 248
  {      60,      43,      42,      32, 
        60,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      -1};
#line 491 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static char *prefixes_H[361]  = 
#line 491
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\344\341",      (char *)"\344\341\353",      (char *)"\344\344",      (char *)"\344\353", 
        (char *)"\344\353\341",      (char *)"\344\353\353",      (char *)"\344\353\354",      (char *)"\344\353\356", 
        (char *)"\344\353\356\344",      (char *)"\344\353\371",      (char *)"\344\353\371\341",      (char *)"\344\353\371\341\353", 
        (char *)"\344\353\371\344",      (char *)"\344\353\371\353",      (char *)"\344\353\371\353\341",      (char *)"\344\353\371\353\353", 
        (char *)"\344\353\371\353\354",      (char *)"\344\353\371\353\356",      (char *)"\344\353\371\353\356\344",      (char *)"\344\353\371\354", 
        (char *)"\344\353\371\354\353",      (char *)"\344\353\371\356",      (char *)"\344\353\371\356\344",      (char *)"\344\353\371\356\353", 
        (char *)"\344\354",      (char *)"\344\354\353",      (char *)"\344\354\353\371",      (char *)"\344\354\353\371\341", 
        (char *)"\344\354\353\371\341\353",      (char *)"\344\354\353\371\344",      (char *)"\344\354\353\371\353",      (char *)"\344\354\353\371\353\341", 
        (char *)"\344\354\353\371\353\353",      (char *)"\344\354\353\371\353\354",      (char *)"\344\354\353\371\353\356",      (char *)"\344\354\353\371\353\356\344", 
        (char *)"\344\354\353\371\354",      (char *)"\344\354\353\371\354\353",      (char *)"\344\354\353\371\356",      (char *)"\344\354\353\371\356\344", 
        (char *)"\344\354\353\371\356\353",      (char *)"\344\356",      (char *)"\344\356\344",      (char *)"\344\356\353", 
        (char *)"\344\356\371",      (char *)"\344\356\371\341",      (char *)"\344\356\371\341\353",      (char *)"\344\356\371\344", 
        (char *)"\344\356\371\353",      (char *)"\344\356\371\353\341",      (char *)"\344\356\371\353\353",      (char *)"\344\356\371\353\354", 
        (char *)"\344\356\371\353\356",      (char *)"\344\356\371\353\356\344",      (char *)"\344\356\371\354",      (char *)"\344\356\371\354\353", 
        (char *)"\344\356\371\356",      (char *)"\344\356\371\356\344",      (char *)"\344\356\371\356\353",      (char *)"\345", 
        (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344",      (char *)"\345\344\341", 
        (char *)"\345\344\341\353",      (char *)"\345\344\344",      (char *)"\345\344\353",      (char *)"\345\344\353\341", 
        (char *)"\345\344\353\353",      (char *)"\345\344\353\354",      (char *)"\345\344\353\356",      (char *)"\345\344\353\356\344", 
        (char *)"\345\344\353\371",      (char *)"\345\344\353\371\341",      (char *)"\345\344\353\371\341\353",      (char *)"\345\344\353\371\344", 
        (char *)"\345\344\353\371\353",      (char *)"\345\344\353\371\353\341",      (char *)"\345\344\353\371\353\353",      (char *)"\345\344\353\371\353\354", 
        (char *)"\345\344\353\371\353\356",      (char *)"\345\344\353\371\353\356\344",      (char *)"\345\344\353\371\354",      (char *)"\345\344\353\371\354\353", 
        (char *)"\345\344\353\371\356",      (char *)"\345\344\353\371\356\344",      (char *)"\345\344\353\371\356\353",      (char *)"\345\344\354", 
        (char *)"\345\344\354\353",      (char *)"\345\344\354\353\371",      (char *)"\345\344\354\353\371\341",      (char *)"\345\344\354\353\371\341\353", 
        (char *)"\345\344\354\353\371\344",      (char *)"\345\344\354\353\371\353",      (char *)"\345\344\354\353\371\353\341",      (char *)"\345\344\354\353\371\353\353", 
        (char *)"\345\344\354\353\371\353\354",      (char *)"\345\344\354\353\371\353\356",      (char *)"\345\344\354\353\371\353\356\344",      (char *)"\345\344\354\353\371\354", 
        (char *)"\345\344\354\353\371\354\353",      (char *)"\345\344\354\353\371\356",      (char *)"\345\344\354\353\371\356\344",      (char *)"\345\344\354\353\371\356\353", 
        (char *)"\345\344\356",      (char *)"\345\344\356\344",      (char *)"\345\344\356\353",      (char *)"\345\344\356\371", 
        (char *)"\345\344\356\371\341",      (char *)"\345\344\356\371\341\353",      (char *)"\345\344\356\371\344",      (char *)"\345\344\356\371\353", 
        (char *)"\345\344\356\371\353\341",      (char *)"\345\344\356\371\353\353",      (char *)"\345\344\356\371\353\354",      (char *)"\345\344\356\371\353\356", 
        (char *)"\345\344\356\371\353\356\344",      (char *)"\345\344\356\371\354",      (char *)"\345\344\356\371\354\353",      (char *)"\345\344\356\371\356", 
        (char *)"\345\344\356\371\356\344",      (char *)"\345\344\356\371\356\353",      (char *)"\345\353",      (char *)"\345\353\341", 
        (char *)"\345\353\353",      (char *)"\345\353\354",      (char *)"\345\353\356",      (char *)"\345\353\356\344", 
        (char *)"\345\353\371",      (char *)"\345\353\371\341",      (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344", 
        (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341",      (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354", 
        (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344",      (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353", 
        (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344",      (char *)"\345\353\371\356\353",      (char *)"\345\354", 
        (char *)"\345\354\353",      (char *)"\345\354\353\371",      (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353", 
        (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353",      (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353", 
        (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356",      (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354", 
        (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356",      (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353", 
        (char *)"\345\356",      (char *)"\345\356\344",      (char *)"\345\356\353",      (char *)"\345\356\371", 
        (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353",      (char *)"\345\356\371\344",      (char *)"\345\356\371\353", 
        (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353",      (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356", 
        (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354",      (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356", 
        (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353",      (char *)"\345\371",      (char *)"\345\371\341", 
        (char *)"\345\371\341\353",      (char *)"\345\371\344",      (char *)"\345\371\353",      (char *)"\345\371\353\341", 
        (char *)"\345\371\353\353",      (char *)"\345\371\353\354",      (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344", 
        (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341",      (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344", 
        (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341",      (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354", 
        (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344",      (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353", 
        (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344",      (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354", 
        (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371",      (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353", 
        (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353",      (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353", 
        (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356",      (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354", 
        (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356",      (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353", 
        (char *)"\345\371\356",      (char *)"\345\371\356\344",      (char *)"\345\371\356\353",      (char *)"\345\371\356\371", 
        (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353",      (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353", 
        (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353",      (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356", 
        (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354",      (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356", 
        (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353",      (char *)"\353",      (char *)"\353\341", 
        (char *)"\353\353",      (char *)"\353\354",      (char *)"\353\356",      (char *)"\353\356\344", 
        (char *)"\353\371",      (char *)"\353\371\341",      (char *)"\353\371\341\353",      (char *)"\353\371\344", 
        (char *)"\353\371\353",      (char *)"\353\371\353\341",      (char *)"\353\371\353\353",      (char *)"\353\371\353\354", 
        (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344",      (char *)"\353\371\354",      (char *)"\353\371\354\353", 
        (char *)"\353\371\356",      (char *)"\353\371\356\344",      (char *)"\353\371\356\353",      (char *)"\354", 
        (char *)"\354\353",      (char *)"\354\353\371",      (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353", 
        (char *)"\354\353\371\344",      (char *)"\354\353\371\353",      (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353", 
        (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356",      (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354", 
        (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356",      (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353", 
        (char *)"\356",      (char *)"\356\341",      (char *)"\356\344",      (char *)"\356\353", 
        (char *)"\356\354",      (char *)"\356\371",      (char *)"\356\371\341",      (char *)"\356\371\341\353", 
        (char *)"\356\371\344",      (char *)"\356\371\353",      (char *)"\356\371\353\341",      (char *)"\356\371\353\353", 
        (char *)"\356\371\353\354",      (char *)"\356\371\353\356",      (char *)"\356\371\353\356\344",      (char *)"\356\371\354", 
        (char *)"\356\371\354\353",      (char *)"\356\371\356",      (char *)"\356\371\356\344",      (char *)"\356\371\356\353", 
        (char *)"\371",      (char *)"\371\341",      (char *)"\371\341\353",      (char *)"\371\344", 
        (char *)"\371\353",      (char *)"\371\353\341",      (char *)"\371\353\353",      (char *)"\371\353\354", 
        (char *)"\371\353\356",      (char *)"\371\353\356\344",      (char *)"\371\353\371",      (char *)"\371\353\371\341", 
        (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344",      (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341", 
        (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354",      (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344", 
        (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353",      (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344", 
        (char *)"\371\353\371\356\353",      (char *)"\371\354",      (char *)"\371\354\353",      (char *)"\371\354\353\371", 
        (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353",      (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353", 
        (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353",      (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356", 
        (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354",      (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356", 
        (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353",      (char *)"\371\356",      (char *)"\371\356\344", 
        (char *)"\371\356\353",      (char *)"\371\356\371",      (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353", 
        (char *)"\371\356\371\344",      (char *)"\371\356\371\353",      (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353", 
        (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356",      (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354", 
        (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356",      (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353", 
        (char *)0};
#line 852 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static int masks_H[361]  = 
#line 852
  {      60,      43,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      32,      42, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      60, 
        43,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        -1};
#line 93 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static struct prefix_node *prefix_tree  =    (struct prefix_node *)0;
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static void build_prefix_tree(int allow_he_hasheela ) 
{ 
  int i ;
  char const   *p ;
  struct prefix_node **n ;
  char **prefixes ;
  int *masks ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 102
  if (allow_he_hasheela) {
#line 103
    prefixes = prefixes_H;
#line 104
    masks = masks_H;
  } else {
#line 106
    prefixes = prefixes_noH;
#line 107
    masks = masks_noH;
  }
#line 110
  i = 0;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! *(prefixes + i)) {
#line 110
      goto while_break;
    }
#line 111
    p = (char const   *)*(prefixes + i);
#line 112
    n = & prefix_tree;
#line 113
    if (hspell_debug) {
      {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prefix %s ",
              p);
      }
      }
    }
    {
    {
#line 115
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! *p) {
#line 115
        goto while_break___0;
      }
#line 116
      if (! *n) {
        {
        {
#line 117
        tmp = calloc((size_t )1, (size_t )sizeof(struct prefix_node ));
        }
#line 117
        *n = (struct prefix_node *)tmp;
        }
      }
#line 119
      n = & (*n)->next[(int const   )*p - -32];
#line 120
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if (! *n) {
      {
      {
#line 124
      tmp___0 = calloc((size_t )1, (size_t )sizeof(struct prefix_node ));
      }
#line 124
      *n = (struct prefix_node *)tmp___0;
      }
    }
#line 126
    (*n)->mask = *(masks + i);
#line 128
    if (hspell_debug) {
      {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mask=%d\n",
              (*n)->mask);
      }
      }
    }
#line 110
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static void free_prefix_tree(struct prefix_node *n ) 
{ 
  int i ;

  {
#line 138
  if (! n) {
#line 139
    return;
  }
#line 140
  i = 0;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )i < sizeof(n->next) / sizeof(n->next[0]))) {
#line 140
      goto while_break;
    }
    {
    {
#line 141
    free_prefix_tree(n->next[i]);
    }
#line 140
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 142
  free((void *)n);
  }
  }
#line 143
  return;
}
}
#line 146 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
int hspell_check_word(struct dict_radix *dict , char const   *word , int *preflen ) 
{ 
  int hashebrew ;
  char const   *w ;
  struct prefix_node *n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 150
  w = word;
#line 152
  *preflen = 0;
#line 155
  hashebrew = 0;
  {
  {
#line 156
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 156
    if (! *w) {
#line 156
      goto while_break;
    }
#line 157
    if ((int const   )*w >= -32) {
#line 157
      if ((int const   )*w <= -6) {
#line 158
        hashebrew = 1;
#line 159
        goto while_break;
      }
    }
#line 161
    (*preflen) ++;
#line 162
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (! hashebrew) {
#line 165
    return (1);
  }
#line 168
  n = prefix_tree;
#line 169
  if (hspell_debug) {
    {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"looking %s\n",
            w);
    }
    }
  }
  {
  {
#line 171
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 171
    if (*w) {
#line 171
      if (! n) {
#line 171
        goto while_break___0;
      }
    } else {
#line 171
      goto while_break___0;
    }
#line 179
    if ((int const   )*w == 34) {
#line 180
      (*preflen) ++;
#line 181
      w ++;
#line 182
      goto while_continue___0;
    }
#line 191
    if ((unsigned long )n != (unsigned long )prefix_tree) {
#line 191
      if ((int const   )*w == -27) {
#line 191
        if ((int const   )*(w + -1) != -27) {
#line 192
          if ((int const   )*(w + 1) == -27) {
#line 193
            if ((int const   )*(w + 2) != -27) {
              {
              {
#line 193
              tmp___0 = lookup((struct dict_radix  const  *)dict, w + 1);
              }
              }
#line 193
              if (tmp___0 & n->mask) {
#line 195
                if (hspell_debug) {
                  {
                  {
#line 196
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: double waw.\n",
                          w);
                  }
                  }
                }
#line 197
                return (1);
              } else {
#line 193
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
              {
#line 198
              tmp = lookup((struct dict_radix  const  *)dict, w);
              }
              }
#line 198
              if (tmp & n->mask) {
#line 200
                if (hspell_debug) {
                  {
                  {
#line 201
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: nondouble waw.\n",
                          w);
                  }
                  }
                }
#line 202
                return (1);
              }
            }
          }
        } else {
#line 191
          goto _L___1;
        }
      } else {
#line 191
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 206
      if (hspell_debug) {
        {
        {
#line 206
        tmp___1 = lookup((struct dict_radix  const  *)dict, w);
        }
        {
#line 206
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tried %s mask %d prefmask %d\n",
                w, tmp___1, n->mask);
        }
        }
      }
      {
      {
#line 207
      tmp___2 = lookup((struct dict_radix  const  *)dict, w);
      }
      }
#line 207
      if (tmp___2 & n->mask) {
#line 207
        return (1);
      }
    }
#line 211
    if ((int const   )*w >= -32) {
#line 211
      if ((int const   )*w <= -6) {
#line 212
        n = n->next[(int const   )*w - -32];
#line 213
        (*preflen) ++;
#line 214
        w ++;
      } else {
#line 216
        goto while_break___0;
      }
    } else {
#line 216
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 219
  if (n) {
#line 219
    if (! *w) {
#line 222
      if (hspell_debug) {
        {
        {
#line 222
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting empty word\n");
        }
        }
      }
#line 223
      return (1);
    } else {
#line 225
      return (0);
    }
  } else {
#line 225
    return (0);
  }
}
}
#line 230 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
int hspell_enum_splits(struct dict_radix *dict , char const   *word , hspell_word_split_callback_func *enumf ) 
{ 
  int preflen ;
  int count ;
  int hashebrew ;
  char const   *w ;
  struct prefix_node *n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 233
  preflen = 0;
#line 233
  count = 0;
#line 236
  w = word;
#line 240
  hashebrew = 0;
  {
  {
#line 241
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 241
    if (! *w) {
#line 241
      goto while_break;
    }
#line 242
    if ((int const   )*w >= -32) {
#line 242
      if ((int const   )*w <= -6) {
#line 243
        hashebrew = 1;
#line 244
        goto while_break;
      }
    }
#line 246
    preflen ++;
#line 247
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  if (! hashebrew) {
#line 250
    return (-1);
  }
#line 252
  n = prefix_tree;
#line 253
  if (hspell_debug) {
    {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enum_splits looking %s\n",
            w);
    }
    }
  }
  {
  {
#line 255
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 255
    if (*w) {
#line 255
      if (! n) {
#line 255
        goto while_break___0;
      }
    } else {
#line 255
      goto while_break___0;
    }
#line 263
    if ((int const   )*w == 34) {
#line 264
      preflen ++;
#line 265
      w ++;
#line 266
      goto while_continue___0;
    }
#line 275
    if ((unsigned long )n != (unsigned long )prefix_tree) {
#line 275
      if ((int const   )*w == -27) {
#line 275
        if ((int const   )*(w + -1) != -27) {
#line 276
          if ((int const   )*(w + 1) == -27) {
#line 277
            if ((int const   )*(w + 2) != -27) {
              {
              {
#line 277
              tmp___2 = lookup((struct dict_radix  const  *)dict, w + 1);
              }
              }
#line 277
              if (tmp___2 & n->mask) {
#line 278
                w ++;
#line 280
                if (hspell_debug) {
                  {
                  {
#line 281
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: double waw.\n",
                          w);
                  }
                  }
                }
                {
#line 282
                tmp = preflen;
#line 282
                preflen ++;
                {
#line 282
                (*enumf)(word, w, tmp, n->mask);
                }
#line 283
                n = n->next[(int const   )*w - -32];
#line 283
                w ++;
#line 284
                count ++;
                }
#line 285
                goto while_continue___0;
              } else {
#line 277
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
              {
#line 286
              tmp___1 = lookup((struct dict_radix  const  *)dict, w);
              }
              }
#line 286
              if (tmp___1 & n->mask) {
#line 288
                if (hspell_debug) {
                  {
                  {
#line 289
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: nondouble waw.\n",
                          w);
                  }
                  }
                }
                {
#line 290
                tmp___0 = preflen;
#line 290
                preflen ++;
                {
#line 290
                (*enumf)(word, w, tmp___0, n->mask);
                }
#line 291
                n = n->next[(int const   )*w - -32];
#line 291
                w ++;
#line 292
                count ++;
                }
#line 293
                goto while_continue___0;
              }
            }
          }
        } else {
#line 275
          goto _L___1;
        }
      } else {
#line 275
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 297
      if (hspell_debug) {
        {
        {
#line 297
        tmp___3 = lookup((struct dict_radix  const  *)dict, w);
        }
        {
#line 297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enum_splits: tried %s mask %d prefmask %d\n",
                w, tmp___3, n->mask);
        }
        }
      }
      {
      {
#line 298
      tmp___5 = lookup((struct dict_radix  const  *)dict, w);
      }
      }
#line 298
      if (tmp___5 & n->mask) {
        {
#line 299
        tmp___4 = preflen;
#line 299
        preflen ++;
        {
#line 299
        (*enumf)(word, w, tmp___4, n->mask);
        }
#line 300
        n = n->next[(int const   )*w - -32];
#line 300
        w ++;
#line 301
        count ++;
        }
#line 302
        goto while_continue___0;
      }
    }
#line 307
    if ((int const   )*w >= -32) {
#line 307
      if ((int const   )*w <= -6) {
#line 308
        n = n->next[(int const   )*w - -32];
#line 309
        preflen ++;
#line 310
        w ++;
      } else {
#line 312
        goto while_break___0;
      }
    } else {
#line 312
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 315
  if (n) {
#line 315
    if (! *w) {
#line 318
      if (hspell_debug) {
        {
        {
#line 318
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting empty word\n");
        }
        }
      }
      {
      {
#line 319
      (*enumf)(word, w, preflen, n->mask);
      }
#line 320
      count ++;
      }
    }
  }
#line 323
  if (hspell_debug) {
    {
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enum_splits found %d splits\n",
            count);
    }
    }
  }
#line 324
  return (count);
}
}
#line 337 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
__inline static int splice(char *buf , int size , char const   *s1 , int s1len , char c1 ,
                           char c2 , char const   *s2 ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 340
  len = s1len;
#line 341
  if (len >= size) {
#line 342
    len = size - 1;
  }
  {
  {
#line 343
  strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)s1, (size_t )len);
  }
  }
#line 344
  if (len + 1 >= size) {
#line 345
    *(buf + len) = (char )'\000';
#line 346
    return;
  } else
#line 347
  if (c1) {
#line 348
    tmp = len;
#line 348
    len ++;
#line 348
    *(buf + tmp) = c1;
  }
#line 350
  if (len + 1 >= size) {
#line 351
    *(buf + len) = (char )'\000';
#line 352
    return;
  } else
#line 353
  if (c2) {
#line 354
    tmp___0 = len;
#line 354
    len ++;
#line 354
    *(buf + tmp___0) = c2;
  }
#line 356
  if (s2) {
    {
    {
#line 357
    strncpy((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)s2,
            (size_t )((size - len) - 1));
    }
#line 358
    *(buf + (size - 1)) = (char )'\000';
    }
  } else {
#line 360
    *(buf + len) = (char )'\000';
  }
#line 362
  return (0);
}
}
#line 371 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static char *similar[9]  = 
#line 371
  {      (char *)"\344\362\340",      (char *)"\342\344",      (char *)"\353\347",      (char *)"\372\350", 
        (char *)"\366\361",      (char *)"\371\361",      (char *)"\353\367",      (char *)"\341\345", 
        (char *)"\364\341"};
#line 365 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
void hspell_trycorrect(struct dict_radix *dict , char const   *w , struct corlist *cl ) 
{ 
  char buf[30] ;
  int i ;
  int len ;
  size_t tmp ;
  int preflen ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int group ;
  char *g ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 370
  tmp = strlen(w);
  }
#line 370
  len = (int )tmp;
#line 376
  i = 1;
  }
  {
  {
#line 376
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < len)) {
#line 376
      goto while_break;
    }
    {
    {
#line 377
    splice(buf, (int )sizeof(buf), w, i, (char )'\351', (char)0, w + i);
    }
    {
#line 378
    tmp___0 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
    }
#line 378
    if (tmp___0) {
      {
      {
#line 378
      corlist_add(cl, (char const   *)(buf));
      }
      }
    }
    {
    {
#line 379
    splice(buf, (int )sizeof(buf), w, i, (char )'\345', (char)0, w + i);
    }
    {
#line 380
    tmp___1 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
    }
#line 380
    if (tmp___1) {
      {
      {
#line 380
      corlist_add(cl, (char const   *)(buf));
      }
      }
    }
#line 376
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  i = 1;
  {
  {
#line 384
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! (i < len - 1)) {
#line 384
      goto while_break___0;
    }
#line 385
    if ((int const   )*(w + i) == -23) {
#line 385
      goto _L;
    } else
#line 385
    if ((int const   )*(w + i) == -27) {
      _L: /* CIL Label */ 
      {
      {
#line 386
      splice(buf, (int )sizeof(buf), w, i, (char)0, (char)0, (w + i) + 1);
      }
      {
#line 387
      tmp___2 = hspell_check_word(dict, (char const   *)(buf), & preflen);
      }
      }
#line 387
      if (tmp___2) {
        {
        {
#line 387
        corlist_add(cl, (char const   *)(buf));
        }
        }
      }
    }
#line 384
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 393
  i = 1;
  {
  {
#line 393
  while (1) {
    while_continue___9: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 393
    if (! (i < len)) {
#line 393
      goto while_break___1;
    }
    {
    {
#line 394
    splice(buf, (int )sizeof(buf), w, i, (char )'\340', (char)0, w + i);
    }
    {
#line 395
    tmp___3 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
    }
#line 395
    if (tmp___3) {
      {
      {
#line 395
      corlist_add(cl, (char const   *)(buf));
      }
      }
    }
#line 393
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 397
  i = 1;
  {
  {
#line 397
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 397
    if (! (i < len - 1)) {
#line 397
      goto while_break___2;
    }
#line 398
    if ((int const   )*(w + i) == -32) {
      {
      {
#line 399
      splice(buf, (int )sizeof(buf), w, i, (char)0, (char)0, (w + i) + 1);
      }
      {
#line 400
      tmp___4 = hspell_check_word(dict, (char const   *)(buf), & preflen);
      }
      }
#line 400
      if (tmp___4) {
        {
        {
#line 400
        corlist_add(cl, (char const   *)(buf));
        }
        }
      }
    }
#line 397
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 405
  i = 0;
  {
  {
#line 405
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 405
    if (! (i < len)) {
#line 405
      goto while_break___3;
    }
#line 408
    group = 0;
    {
    {
#line 408
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 408
      if (! ((unsigned long )group < sizeof(similar) / sizeof(similar[0]))) {
#line 408
        goto while_break___4;
      }
#line 410
      g = similar[group];
      {
      {
#line 410
      while (1) {
        while_continue___13: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 410
        if (*g) {
#line 410
          if (! ((int )*g != (int )*(w + i))) {
#line 410
            goto while_break___5;
          }
        } else {
#line 410
          goto while_break___5;
        }
#line 410
        g ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 412
      if (*g) {
#line 415
        g = similar[group];
        {
        {
#line 415
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 415
          if (! *g) {
#line 415
            goto while_break___6;
          }
#line 416
          if ((int )*g == (int )*(w + i)) {
#line 416
            goto __Cont;
          }
#line 417
          if (i > 0) {
#line 417
            if ((int const   )*(w + i) == -27) {
#line 417
              if ((int const   )*(w + (i + 1)) == -27) {
                {
                {
#line 418
                splice(buf, (int )sizeof(buf), w, i, *g, (char)0, (w + i) + 2);
                }
                }
              } else {
#line 417
                goto _L___1;
              }
            } else {
#line 417
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 419
          if ((int )*g == -27) {
            {
            {
#line 420
            splice(buf, (int )sizeof(buf), w, i, (char )'\345', (char )'\345', (w + i) + 1);
            }
            }
          } else {
            {
            {
#line 422
            splice(buf, (int )sizeof(buf), w, i, *g, (char)0, (w + i) + 1);
            }
            }
          }
          {
          {
#line 423
          tmp___5 = hspell_check_word(dict, (char const   *)(buf), & preflen);
          }
          }
#line 423
          if (tmp___5) {
            {
            {
#line 423
            corlist_add(cl, (char const   *)(buf));
            }
            }
          }
          __Cont: /* CIL Label */ 
#line 415
          g ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 408
      group ++;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 405
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 430
  strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)w, (size_t )sizeof(buf));
  }
  }
  {
#line 432
  if ((int const   )*(w + (len - 1)) == -22) {
#line 432
    goto case_neg_22;
  }
#line 433
  if ((int const   )*(w + (len - 1)) == -19) {
#line 433
    goto case_neg_19;
  }
#line 434
  if ((int const   )*(w + (len - 1)) == -17) {
#line 434
    goto case_neg_17;
  }
#line 435
  if ((int const   )*(w + (len - 1)) == -11) {
#line 435
    goto case_neg_11;
  }
#line 436
  if ((int const   )*(w + (len - 1)) == -13) {
#line 436
    goto case_neg_13;
  }
#line 437
  if ((int const   )*(w + (len - 1)) == -21) {
#line 437
    goto case_neg_21;
  }
#line 438
  if ((int const   )*(w + (len - 1)) == -18) {
#line 438
    goto case_neg_18;
  }
#line 439
  if ((int const   )*(w + (len - 1)) == -16) {
#line 439
    goto case_neg_16;
  }
#line 440
  if ((int const   )*(w + (len - 1)) == -10) {
#line 440
    goto case_neg_10;
  }
#line 441
  if ((int const   )*(w + (len - 1)) == -12) {
#line 441
    goto case_neg_12;
  }
#line 431
  goto switch_break;
  case_neg_22: /* CIL Label */ 
#line 432
  buf[len - 1] = (char )'\353';
#line 432
  goto switch_break;
  case_neg_19: /* CIL Label */ 
#line 433
  buf[len - 1] = (char )'\356';
#line 433
  goto switch_break;
  case_neg_17: /* CIL Label */ 
#line 434
  buf[len - 1] = (char )'\360';
#line 434
  goto switch_break;
  case_neg_11: /* CIL Label */ 
#line 435
  buf[len - 1] = (char )'\366';
#line 435
  goto switch_break;
  case_neg_13: /* CIL Label */ 
#line 436
  buf[len - 1] = (char )'\364';
#line 436
  goto switch_break;
  case_neg_21: /* CIL Label */ 
#line 437
  buf[len - 1] = (char )'\352';
#line 437
  goto switch_break;
  case_neg_18: /* CIL Label */ 
#line 438
  buf[len - 1] = (char )'\355';
#line 438
  goto switch_break;
  case_neg_16: /* CIL Label */ 
#line 439
  buf[len - 1] = (char )'\357';
#line 439
  goto switch_break;
  case_neg_10: /* CIL Label */ 
#line 440
  buf[len - 1] = (char )'\365';
#line 440
  goto switch_break;
  case_neg_12: /* CIL Label */ 
#line 441
  buf[len - 1] = (char )'\363';
#line 441
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 443
  if ((int )buf[len - 1] != (int )*(w + (len - 1))) {
    {
    {
#line 443
    tmp___6 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
    }
#line 443
    if (tmp___6) {
      {
      {
#line 443
      corlist_add(cl, (char const   *)(buf));
      }
      }
    }
  }
#line 445
  if (len >= 2) {
    {
    {
#line 446
    splice(buf, (int )sizeof(buf), w, len - 1, (char )'\"', (char )*(w + (len - 1)),
           (char const   *)0);
    }
    {
#line 447
    tmp___7 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
    }
#line 447
    if (tmp___7) {
      {
      {
#line 447
      corlist_add(cl, (char const   *)(buf));
      }
      }
    }
  }
  {
  {
#line 450
  snprintf((char */* __restrict  */)(buf), (size_t )sizeof(buf), (char const   */* __restrict  */)"%s\'",
           w);
  }
  {
#line 451
  tmp___8 = hspell_check_word(dict, (char const   *)(buf), & preflen);
  }
  }
#line 451
  if (tmp___8) {
    {
    {
#line 451
    corlist_add(cl, (char const   *)(buf));
    }
    }
  }
#line 452
  return;
}
}
#line 460 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
int hspell_init(struct dict_radix **dictp , int flags ) 
{ 
  int ret ;

  {
  {
  {
#line 463
  ret = load_data(dictp);
  }
  }
#line 464
  if (ret < 0) {
#line 464
    return (ret);
  }
  {
  {
#line 465
  build_prefix_tree(flags & 1);
  }
  }
#line 471
  return (0);
}
}
#line 488 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
void hspell_uninit(struct dict_radix *dict ) 
{ 


  {
  {
  {
#line 491
  delete_dict_radix(dict);
  }
  {
#line 494
  free_prefix_tree(prefix_tree);
  }
#line 495
  prefix_tree = (struct prefix_node *)0;
  }
#line 499
  return;
}
}
#line 172 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static void do_print_tree___1(struct node *nodes , struct node_small *nodes_small ,
                              struct node_medium *nodes_medium , struct node_index head ,
                              char *word , int len , int maxlen ) 
{ 
  int i ;
  struct node *n ;
  unsigned char tmp ;
  struct node_small *n___0 ;
  struct node_medium *n___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 177
  if (len >= maxlen) {
    {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_print_tree(): warning: buffer overflow.\n");
    }
    }
#line 179
    return;
  }
#line 181
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 182
    n = nodes + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 183
    if (n->value) {
      {
#line 184
      *(word + len) = (char )'\000';
      {
#line 185
      printf((char const   */* __restrict  */)"%s %d\n", word, n->value);
      }
      }
    }
#line 187
    i = 0;
    {
    {
#line 187
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 187
      if (! (i < 29)) {
#line 187
        goto while_break;
      }
      {
      {
#line 188
      tmp = letter_to_char(i);
      }
#line 188
      *(word + len) = (char )tmp;
      {
#line 189
      do_print_tree___1(nodes, nodes_small, nodes_medium, n->children[i], word, len + 1,
                        maxlen);
      }
#line 187
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 192
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 193
    n___0 = nodes_small + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 194
    if (n___0->value) {
      {
#line 195
      *(word + len) = (char )'\000';
      {
#line 196
      printf((char const   */* __restrict  */)"%s %d\n", word, n___0->value);
      }
      }
    }
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 2)) {
#line 198
        goto while_break___0;
      }
#line 199
      if (n___0->chars[i]) {
        {
#line 200
        *(word + len) = n___0->chars[i];
        {
#line 201
        do_print_tree___1(nodes, nodes_small, nodes_medium, n___0->children[i], word,
                          len + 1, maxlen);
        }
        }
      }
#line 198
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 205
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 206
    n___1 = nodes_medium + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 207
    if (n___1->value) {
      {
#line 208
      *(word + len) = (char )'\000';
      {
#line 209
      printf((char const   */* __restrict  */)"%s %d\n", word, n___1->value);
      }
      }
    }
#line 211
    i = 0;
    {
    {
#line 211
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 211
      if (! (i < 8)) {
#line 211
        goto while_break___1;
      }
#line 212
      if (n___1->chars[i]) {
        {
#line 213
        *(word + len) = n___1->chars[i];
        {
#line 214
        do_print_tree___1(nodes, nodes_small, nodes_medium, n___1->children[i], word,
                          len + 1, maxlen);
        }
        }
      }
#line 211
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if (head.val_or_index) {
    {
#line 219
    *(word + len) = (char )'\000';
    {
#line 220
    printf((char const   */* __restrict  */)"%s %d\n", word, head.val_or_index);
    }
    }
  }
#line 222
  return;
}
}
#line 318
static int do_read_dict___1(void *fp , void *prefixes , struct dict_radix *dict ) ;
#line 406 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static int do_read_dict___1(void *fp , void *prefixes , struct dict_radix *dict ) 
{ 
  struct node_index *stack[256] ;
  int sdepth ;
  int c ;
  int n ;
  int cc ;
  int nwords ;
  struct node *nodes ;
  struct node_small *nodes_small ;
  struct node_medium *nodes_medium ;
  int nnodes_small ;
  int nnodes_medium ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;
  int chosen ;
  int j ;
  struct node_small *n___0 ;
  int chosen___0 ;
  int tmp___1 ;
  int j___0 ;
  struct node_medium *n___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 412
  sdepth = 0;
#line 415
  nwords = 0;
#line 416
  nodes = dict->nodes;
#line 417
  nodes_small = dict->nodes_small;
#line 418
  nodes_medium = dict->nodes_medium;
#line 419
  nnodes_small = 0;
#line 419
  nnodes_medium = 0;
#line 419
  nnodes = 0;
#line 421
  if (dict->nnodes) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_small) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_medium) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nwords) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  }
#line 427
  if (! nodes) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_small) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_medium) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  }
  {
  {
#line 433
  memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
  }
#line 434
  tmp = nnodes;
#line 434
  nnodes ++;
#line 434
  dict->head.val_or_index = (unsigned int )tmp | (3U << 30);
#line 435
  stack[0] = & dict->head;
#line 436
  sdepth = 0;
  }
  {
  {
#line 437
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 437
    c = gzb_getc((gzbFile *)fp);
    }
    }
#line 437
    if (! (c != -1)) {
#line 437
      goto while_break;
    }
#line 438
    if (c >= 48) {
#line 438
      if (c <= 57) {
        {
#line 440
        nwords ++;
        {
#line 443
        tmp___0 = gzb_getc((gzbFile *)prefixes);
        }
#line 443
        (stack[sdepth])->val_or_index = (uint32_t )tmp___0;
#line 448
        n = 0;
        }
        {
        {
#line 449
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
#line 451
          n *= 10;
#line 452
          n += c - 48;
          {
#line 449
          c = gzb_getc((gzbFile *)fp);
          }
          }
#line 449
          if (c != -1) {
#line 449
            if (c >= 48) {
#line 449
              if (! (c <= 57)) {
#line 449
                goto while_break___0;
              }
            } else {
#line 449
              goto while_break___0;
            }
          } else {
#line 449
            goto while_break___0;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 454
        sdepth -= n;
#line 455
        if (sdepth < 0) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        } else
#line 455
        if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        }
      }
    }
#line 462
    if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
      {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: word too long... giving up\n");
      }
      }
#line 464
      return (0);
    }
    {
    {
#line 466
    cc = char_to_letter((unsigned char )c);
    }
    }
#line 469
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 471
      if (dict->nfree_nodes_small) {
#line 472
        (dict->nfree_nodes_small) --;
#line 472
        chosen = dict->free_nodes_small[dict->nfree_nodes_small];
      } else {
#line 475
        chosen = nnodes_small;
#line 476
        if (nnodes_small >= dict->size_nodes_small) {
          {
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (small) - failing.\n");
          }
          }
#line 478
          return (0);
        }
#line 480
        nnodes_small ++;
      }
      {
      {
#line 482
      memset((void *)(nodes_small + chosen), 0, (size_t )sizeof(*(nodes_small + chosen)));
      }
#line 483
      (nodes_small + chosen)->value = (stack[sdepth])->val_or_index;
#line 484
      (stack[sdepth])->val_or_index = (unsigned int )chosen | (1U << 30);
#line 486
      (nodes_small + chosen)->chars[0] = (char )c;
#line 487
      stack[sdepth + 1] = & (nodes_small + chosen)->children[0];
      }
    } else
#line 488
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 490
      n___0 = nodes_small + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 493
      j = 0;
      {
      {
#line 493
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 493
        if (! (j < 2)) {
#line 493
          goto while_break___1;
        }
#line 494
        if (! n___0->chars[j]) {
#line 495
          n___0->chars[j] = (char )c;
#line 496
          stack[sdepth + 1] = & n___0->children[j];
#line 497
          goto while_break___1;
        }
#line 493
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (j == 2) {
#line 502
        if (dict->nfree_nodes_medium) {
#line 503
          (dict->nfree_nodes_medium) --;
#line 503
          chosen___0 = dict->free_nodes_medium[dict->nfree_nodes_medium];
        } else {
#line 506
          chosen___0 = nnodes_medium;
#line 507
          if (nnodes_medium >= dict->size_nodes_medium) {
            {
            {
#line 508
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (medium) - failing.\n");
            }
            }
#line 509
            return (0);
          }
#line 511
          nnodes_medium ++;
        }
        {
        {
#line 513
        memset((void *)(nodes_medium + chosen___0), 0, (size_t )sizeof(*(nodes_medium + chosen___0)));
        }
        }
#line 514
        if ((unsigned long )dict->nfree_nodes_small >= sizeof(dict->free_nodes_small) / sizeof(dict->free_nodes_small[0])) {
          {
          {
#line 517
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_small.\n");
          }
          }
#line 518
          return (0);
        }
#line 520
        tmp___1 = dict->nfree_nodes_small;
#line 520
        (dict->nfree_nodes_small) ++;
#line 520
        dict->free_nodes_small[tmp___1] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 523
        (stack[sdepth])->val_or_index = (unsigned int )chosen___0 | (2U << 30);
#line 526
        (nodes_medium + chosen___0)->value = n___0->value;
#line 527
        j = 0;
        {
        {
#line 527
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 527
          if (! (j < 2)) {
#line 527
            goto while_break___2;
          }
#line 528
          (nodes_medium + chosen___0)->chars[j] = n___0->chars[j];
#line 530
          (nodes_medium + chosen___0)->children[j] = n___0->children[j];
#line 527
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        (nodes_medium + chosen___0)->chars[2] = (char )c;
#line 536
        stack[sdepth + 1] = & (nodes_medium + chosen___0)->children[2];
      }
    } else
#line 539
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 541
      n___1 = nodes_medium + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 544
      j___0 = 0;
      {
      {
#line 544
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! (j___0 < 8)) {
#line 544
          goto while_break___3;
        }
#line 545
        if (! n___1->chars[j___0]) {
#line 546
          n___1->chars[j___0] = (char )c;
#line 547
          stack[sdepth + 1] = & n___1->children[j___0];
#line 548
          goto while_break___3;
        }
#line 544
        j___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      if (j___0 == 8) {
#line 552
        if (nnodes >= dict->size_nodes) {
          {
          {
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (full) - failing.\n");
          }
          }
#line 554
          return (0);
        }
        {
        {
#line 556
        memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
        }
#line 557
        (nodes + nnodes)->value = n___1->value;
        }
#line 558
        if ((unsigned long )dict->nfree_nodes_medium >= sizeof(dict->free_nodes_medium) / sizeof(dict->free_nodes_medium[0])) {
          {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_medium.\n");
          }
          }
#line 562
          return (0);
        }
#line 564
        tmp___2 = dict->nfree_nodes_medium;
#line 564
        (dict->nfree_nodes_medium) ++;
#line 564
        dict->free_nodes_medium[tmp___2] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 567
        (stack[sdepth])->val_or_index = (unsigned int )nnodes | (3U << 30);
#line 569
        j___0 = 0;
        {
        {
#line 569
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 569
          if (! (j___0 < 8)) {
#line 569
            goto while_break___4;
          }
          {
          {
#line 570
          tmp___3 = char_to_letter((unsigned char )n___1->chars[j___0]);
          }
#line 570
          (nodes + nnodes)->children[tmp___3] = n___1->children[j___0];
#line 569
          j___0 ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 574
        stack[sdepth + 1] = & (nodes + nnodes)->children[cc];
#line 575
        nnodes ++;
      }
    } else {
#line 578
      stack[sdepth + 1] = & (nodes + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30))))->children[cc];
    }
#line 581
    sdepth ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  nwords ++;
  {
#line 586
  tmp___4 = gzb_getc((gzbFile *)prefixes);
  }
#line 586
  (stack[sdepth])->val_or_index = (uint32_t )tmp___4;
#line 592
  dict->nwords = nwords;
#line 593
  dict->nnodes_small = nnodes_small;
#line 594
  dict->nnodes_medium = nnodes_medium;
#line 595
  dict->nnodes = nnodes;
  }
#line 597
  return (1);
}
}
#line 513 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 80 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.h"
Tcl_HashEntry *Tcl_NextHashEntry(Tcl_HashSearch *searchPtr ) ;
#line 82
Tcl_HashEntry *Tcl_FirstHashEntry(Tcl_HashTable *tablePtr , Tcl_HashSearch *searchPtr ) ;
#line 84
void Tcl_InitHashTable(Tcl_HashTable *tablePtr , int keyType ) ;
#line 85
Tcl_HashEntry *Tcl_CreateHashEntry(Tcl_HashTable *tablePtr , char const   *key , int *newPtr ) ;
#line 86
Tcl_HashEntry *Tcl_FindHashEntry(Tcl_HashTable *tablePtr , char const   *key ) ;
#line 149 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static Tcl_HashEntry *AllocStringEntry(Tcl_HashTable *tablePtr , void *keyPtr ) ;
#line 152
static int CompareStringKeys(void *keyPtr , Tcl_HashEntry *hPtr ) ;
#line 154
static unsigned int HashStringKey(Tcl_HashTable *tablePtr , void *keyPtr ) ;
#line 162
static void RebuildTable(Tcl_HashTable *tablePtr ) ;
#line 164 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
Tcl_HashKeyType tclStringHashKeyType  =    {1, 0, & HashStringKey, & CompareStringKeys, & AllocStringEntry, (Tcl_FreeHashEntryProc *)((void *)0)};
#line 193 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
void Tcl_InitHashTable(Tcl_HashTable *tablePtr , int keyType ) 
{ 
  Tcl_HashEntry *tmp ;
  Tcl_HashEntry *tmp___0 ;

  {
#line 206
  tablePtr->buckets = tablePtr->staticBuckets;
#line 207
  tmp = (Tcl_HashEntry *)0;
#line 207
  tablePtr->staticBuckets[1] = tmp;
#line 207
  tablePtr->staticBuckets[0] = tmp;
#line 208
  tmp___0 = (Tcl_HashEntry *)0;
#line 208
  tablePtr->staticBuckets[3] = tmp___0;
#line 208
  tablePtr->staticBuckets[2] = tmp___0;
#line 209
  tablePtr->numBuckets = 4;
#line 210
  tablePtr->numEntries = 0;
#line 211
  tablePtr->rebuildSize = 12;
#line 212
  tablePtr->downShift = 28;
#line 213
  tablePtr->mask = 3;
#line 214
  tablePtr->keyType = keyType;
#line 218
  if (keyType == 0) {
#line 219
    tablePtr->typePtr = & tclStringHashKeyType;
  } else {
    {
    {
#line 222
    abort();
    }
    }
  }
#line 224
  return;
}
}
#line 243 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
Tcl_HashEntry *Tcl_FindHashEntry(Tcl_HashTable *tablePtr , char const   *key ) 
{ 
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  unsigned int hash ;
  int index___0 ;
  int tmp ;

  {
#line 253
  typePtr = tablePtr->typePtr;
#line 254
  if ((unsigned long )typePtr == (unsigned long )((void *)0)) {
#line 256
    return ((Tcl_HashEntry *)((void *)0));
  }
#line 259
  if (typePtr->hashKeyProc) {
    {
    {
#line 260
    hash = (*(typePtr->hashKeyProc))(tablePtr, (void *)key);
    }
    }
#line 261
    if (typePtr->flags & 1) {
#line 262
      index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
    } else {
#line 264
      index___0 = (int )(hash & (unsigned int )tablePtr->mask);
    }
  } else {
#line 267
    hash = (unsigned int )key;
#line 268
    index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  }
#line 275
  if (typePtr->compareKeysProc) {
#line 276
    hPtr = *(tablePtr->buckets + index___0);
    {
    {
#line 276
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 276
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 276
        goto while_break;
      }
#line 278
      if (hash != hPtr->hash) {
#line 279
        goto __Cont;
      }
      {
      {
#line 281
      tmp = (*(typePtr->compareKeysProc))((void *)key, hPtr);
      }
      }
#line 281
      if (tmp) {
#line 282
        return (hPtr);
      }
      __Cont: /* CIL Label */ 
#line 276
      hPtr = hPtr->nextPtr;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 286
    hPtr = *(tablePtr->buckets + index___0);
    {
    {
#line 286
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 286
        goto while_break___0;
      }
#line 288
      if (hash != hPtr->hash) {
#line 289
        goto __Cont___0;
      }
#line 291
      if ((unsigned long )key == (unsigned long )hPtr->key.oneWordValue) {
#line 292
        return (hPtr);
      }
      __Cont___0: /* CIL Label */ 
#line 286
      hPtr = hPtr->nextPtr;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 297
  return ((Tcl_HashEntry *)((void *)0));
}
}
#line 321 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
Tcl_HashEntry *Tcl_CreateHashEntry(Tcl_HashTable *tablePtr , char const   *key , int *newPtr ) 
{ 
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  unsigned int hash ;
  int index___0 ;
  int tmp ;
  void *tmp___0 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 334
  typePtr = tablePtr->typePtr;
#line 335
  if ((unsigned long )typePtr == (unsigned long )((void *)0)) {
#line 337
    return ((Tcl_HashEntry *)((void *)0));
  }
#line 340
  if (typePtr->hashKeyProc) {
    {
    {
#line 341
    hash = (*(typePtr->hashKeyProc))(tablePtr, (void *)key);
    }
    }
#line 342
    if (typePtr->flags & 1) {
#line 343
      index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
    } else {
#line 345
      index___0 = (int )(hash & (unsigned int )tablePtr->mask);
    }
  } else {
#line 348
    hash = (unsigned int )key;
#line 349
    index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  }
#line 356
  if (typePtr->compareKeysProc) {
#line 357
    hPtr = *(tablePtr->buckets + index___0);
    {
    {
#line 357
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 357
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 357
        goto while_break;
      }
#line 359
      if (hash != hPtr->hash) {
#line 360
        goto __Cont;
      }
      {
      {
#line 362
      tmp = (*(typePtr->compareKeysProc))((void *)key, hPtr);
      }
      }
#line 362
      if (tmp) {
#line 363
        *newPtr = 0;
#line 364
        return (hPtr);
      }
      __Cont: /* CIL Label */ 
#line 357
      hPtr = hPtr->nextPtr;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 368
    hPtr = *(tablePtr->buckets + index___0);
    {
    {
#line 368
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 368
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 368
        goto while_break___0;
      }
#line 370
      if (hash != hPtr->hash) {
#line 371
        goto __Cont___0;
      }
#line 373
      if ((unsigned long )key == (unsigned long )hPtr->key.oneWordValue) {
#line 374
        *newPtr = 0;
#line 375
        return (hPtr);
      }
      __Cont___0: /* CIL Label */ 
#line 368
      hPtr = hPtr->nextPtr;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 384
  *newPtr = 1;
#line 385
  if (typePtr->allocEntryProc) {
    {
    {
#line 386
    hPtr = (*(typePtr->allocEntryProc))(tablePtr, (void *)key);
    }
    }
  } else {
    {
    {
#line 388
    tmp___0 = malloc((unsigned int )sizeof(Tcl_HashEntry ));
    }
#line 388
    hPtr = (Tcl_HashEntry *)tmp___0;
#line 389
    hPtr->key.oneWordValue = (char *)key;
    }
  }
#line 392
  hPtr->tablePtr = tablePtr;
#line 393
  hPtr->hash = hash;
#line 394
  hPtr->nextPtr = *(tablePtr->buckets + index___0);
#line 395
  *(tablePtr->buckets + index___0) = hPtr;
#line 396
  hPtr->clientData = (ClientData )0;
#line 397
  (tablePtr->numEntries) ++;
#line 404
  if (tablePtr->numEntries >= tablePtr->rebuildSize) {
    {
    {
#line 405
    RebuildTable(tablePtr);
    }
    }
  }
#line 407
  return (hPtr);
}
}
#line 429 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
void Tcl_DeleteHashEntry(Tcl_HashEntry *entryPtr ) 
{ 
  register Tcl_HashEntry *prevPtr ;
  Tcl_HashKeyType *typePtr ;
  Tcl_HashTable *tablePtr ;
  Tcl_HashEntry **bucketPtr ;
  int index___0 ;

  {
#line 439
  tablePtr = entryPtr->tablePtr;
#line 440
  typePtr = tablePtr->typePtr;
#line 443
  if ((unsigned long )typePtr->hashKeyProc == (unsigned long )((void *)0)) {
#line 445
    index___0 = (int )(((long )entryPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  } else
#line 443
  if (typePtr->flags & 1) {
#line 445
    index___0 = (int )(((long )entryPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  } else {
#line 447
    index___0 = (int )(entryPtr->hash & (unsigned int )tablePtr->mask);
  }
#line 450
  bucketPtr = tablePtr->buckets + index___0;
#line 452
  if ((unsigned long )*bucketPtr == (unsigned long )entryPtr) {
#line 453
    *bucketPtr = entryPtr->nextPtr;
  } else {
#line 455
    prevPtr = *bucketPtr;
    {
    {
#line 455
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 459
      if ((unsigned long )prevPtr->nextPtr == (unsigned long )entryPtr) {
#line 460
        prevPtr->nextPtr = entryPtr->nextPtr;
#line 461
        goto while_break;
      }
#line 455
      prevPtr = prevPtr->nextPtr;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 466
  (tablePtr->numEntries) --;
#line 467
  if (typePtr->freeEntryProc) {
    {
    {
#line 468
    (*(typePtr->freeEntryProc))(entryPtr);
    }
    }
  } else {
    {
    {
#line 470
    free((void *)((char *)entryPtr));
    }
    }
  }
#line 472
  return;
}
}
#line 491 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
void Tcl_DeleteHashTable(Tcl_HashTable *tablePtr ) 
{ 
  register Tcl_HashEntry *hPtr ;
  register Tcl_HashEntry *nextPtr ;
  Tcl_HashKeyType *typePtr ;
  int i ;

  {
#line 499
  typePtr = tablePtr->typePtr;
#line 505
  i = 0;
  {
  {
#line 505
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 505
    if (! (i < tablePtr->numBuckets)) {
#line 505
      goto while_break;
    }
#line 506
    hPtr = *(tablePtr->buckets + i);
    {
    {
#line 507
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 507
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 507
        goto while_break___0;
      }
#line 508
      nextPtr = hPtr->nextPtr;
#line 509
      if (typePtr->freeEntryProc) {
        {
        {
#line 510
        (*(typePtr->freeEntryProc))(hPtr);
        }
        }
      } else {
        {
        {
#line 512
        free((void *)((char *)hPtr));
        }
        }
      }
#line 514
      hPtr = nextPtr;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 505
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  if ((unsigned long )tablePtr->buckets != (unsigned long )(tablePtr->staticBuckets)) {
    {
    {
#line 523
    free((void *)((char *)tablePtr->buckets));
    }
    }
  }
#line 531
  tablePtr->typePtr = (Tcl_HashKeyType *)((void *)0);
#line 532
  return;
}
}
#line 556 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
Tcl_HashEntry *Tcl_FirstHashEntry(Tcl_HashTable *tablePtr , Tcl_HashSearch *searchPtr ) 
{ 
  Tcl_HashEntry *tmp ;

  {
  {
#line 562
  searchPtr->tablePtr = tablePtr;
#line 563
  searchPtr->nextIndex = 0;
#line 564
  searchPtr->nextEntryPtr = (Tcl_HashEntry *)((void *)0);
  {
#line 565
  tmp = Tcl_NextHashEntry(searchPtr);
  }
  }
#line 565
  return (tmp);
}
}
#line 587 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
Tcl_HashEntry *Tcl_NextHashEntry(Tcl_HashSearch *searchPtr ) 
{ 
  Tcl_HashEntry *hPtr ;

  {
  {
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 596
    if (! ((unsigned long )searchPtr->nextEntryPtr == (unsigned long )((void *)0))) {
#line 596
      goto while_break;
    }
#line 597
    if (searchPtr->nextIndex >= (searchPtr->tablePtr)->numBuckets) {
#line 598
      return ((Tcl_HashEntry *)((void *)0));
    }
#line 600
    searchPtr->nextEntryPtr = *((searchPtr->tablePtr)->buckets + searchPtr->nextIndex);
#line 602
    (searchPtr->nextIndex) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  hPtr = searchPtr->nextEntryPtr;
#line 605
  searchPtr->nextEntryPtr = hPtr->nextPtr;
#line 606
  return (hPtr);
}
}
#line 625 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static Tcl_HashEntry *AllocStringEntry(Tcl_HashTable *tablePtr , void *keyPtr ) 
{ 
  char const   *string ;
  Tcl_HashEntry *hPtr ;
  unsigned int size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 630
  string = (char const   *)keyPtr;
  {
#line 634
  tmp = strlen(string);
  }
#line 634
  size = (unsigned int )(((sizeof(Tcl_HashEntry ) + (unsigned long )tmp) + 1UL) - sizeof(hPtr->key));
  }
#line 635
  if ((unsigned long )size < sizeof(Tcl_HashEntry )) {
#line 636
    size = (unsigned int )sizeof(Tcl_HashEntry );
  }
  {
  {
#line 637
  tmp___0 = malloc(size);
  }
#line 637
  hPtr = (Tcl_HashEntry *)tmp___0;
  {
#line 638
  strcpy((char */* __restrict  */)(hPtr->key.string), (char const   */* __restrict  */)string);
  }
  }
#line 640
  return (hPtr);
}
}
#line 660 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static int CompareStringKeys(void *keyPtr , Tcl_HashEntry *hPtr ) 
{ 
  register char const   *p1 ;
  register char const   *p2 ;

  {
#line 665
  p1 = (char const   *)keyPtr;
#line 666
  p2 = (char const   *)(hPtr->key.string);
  {
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 669
    if ((int const   )*p1 != (int const   )*p2) {
#line 670
      goto while_break;
    }
#line 672
    if ((int const   )*p1 == 0) {
#line 673
      return (1);
    }
#line 668
    p1 ++;
#line 668
    p2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  return (0);
}
}
#line 697 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static unsigned int HashStringKey(Tcl_HashTable *tablePtr , void *keyPtr ) 
{ 
  register char const   *string ;
  register unsigned int result ;
  register int c ;

  {
#line 702
  string = (char const   *)keyPtr;
#line 722
  result = 0U;
  {
  {
#line 723
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 724
    c = (int )*string;
#line 725
    if (c == 0) {
#line 726
      goto while_break;
    }
#line 728
    result += (result << 3) + (unsigned int )c;
#line 729
    string ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  return (result);
}
}
#line 754 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static void RebuildTable(Tcl_HashTable *tablePtr ) 
{ 
  int oldSize ;
  int count ;
  int index___0 ;
  Tcl_HashEntry **oldBuckets ;
  register Tcl_HashEntry **oldChainPtr ;
  register Tcl_HashEntry **newChainPtr ;
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  void *key ;
  void *tmp ;

  {
  {
#line 765
  oldSize = tablePtr->numBuckets;
#line 766
  oldBuckets = tablePtr->buckets;
#line 773
  tablePtr->numBuckets *= 4;
  {
#line 774
  tmp = malloc((unsigned int )((unsigned long )tablePtr->numBuckets * sizeof(Tcl_HashEntry *)));
  }
#line 774
  tablePtr->buckets = (Tcl_HashEntry **)tmp;
#line 776
  count = tablePtr->numBuckets;
#line 776
  newChainPtr = tablePtr->buckets;
  }
  {
  {
#line 776
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 776
    if (! (count > 0)) {
#line 776
      goto while_break;
    }
#line 778
    *newChainPtr = (Tcl_HashEntry *)((void *)0);
#line 776
    count --;
#line 776
    newChainPtr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  tablePtr->rebuildSize *= 4;
#line 781
  tablePtr->downShift -= 2;
#line 782
  tablePtr->mask = (tablePtr->mask << 2) + 3;
#line 784
  typePtr = tablePtr->typePtr;
#line 790
  oldChainPtr = oldBuckets;
  {
  {
#line 790
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 790
    if (! (oldSize > 0)) {
#line 790
      goto while_break___0;
    }
#line 791
    hPtr = *oldChainPtr;
    {
    {
#line 791
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 791
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 791
        goto while_break___1;
      }
#line 792
      *oldChainPtr = hPtr->nextPtr;
#line 794
      key = (void *)(hPtr->key.string);
#line 796
      if ((unsigned long )typePtr->hashKeyProc == (unsigned long )((void *)0)) {
#line 798
        index___0 = (int )(((long )hPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
      } else
#line 796
      if (typePtr->flags & 1) {
#line 798
        index___0 = (int )(((long )hPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
      } else {
#line 800
        index___0 = (int )(hPtr->hash & (unsigned int )tablePtr->mask);
      }
#line 802
      hPtr->nextPtr = *(tablePtr->buckets + index___0);
#line 803
      *(tablePtr->buckets + index___0) = hPtr;
#line 791
      hPtr = *oldChainPtr;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 790
    oldSize --;
#line 790
    oldChainPtr ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 811
  if ((unsigned long )oldBuckets != (unsigned long )(tablePtr->staticBuckets)) {
    {
    {
#line 812
    free((void *)((char *)oldBuckets));
    }
    }
  }
#line 814
  return;
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 461
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 324
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 846
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 852
extern int pclose(FILE *__stream ) ;
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 756
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 33 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static void hspell_hash_init(hspell_hash *p ) 
{ 


  {
  {
  {
#line 35
  Tcl_InitHashTable(p, 0);
  }
  }
#line 36
  return;
}
}
#line 42 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static void hspell_hash_incr_int(hspell_hash *hashp , char const   *key ) 
{ 
  Tcl_HashEntry *e ;
  int isnew ;

  {
  {
  {
#line 47
  e = Tcl_CreateHashEntry(hashp, key, & isnew);
  }
#line 53
  e->clientData = (ClientData )((int )e->clientData + 1);
  }
#line 54
  return;
}
}
#line 59 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static int hspell_hash_exists(hspell_hash *hashp , char const   *key ) 
{ 
  Tcl_HashEntry *e ;
  int tmp ;

  {
  {
  {
#line 62
  e = Tcl_FindHashEntry(hashp, key);
  }
  }
#line 63
  if (e) {
#line 63
    tmp = 1;
  } else {
#line 63
    tmp = 0;
  }
#line 63
  return (tmp);
}
}
#line 79 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static hspell_hash_keyvalue *hspell_hash_build_keyvalue_array(hspell_hash *h ,
                                                                       int *size ) 
{ 
  Tcl_HashEntry *e ;
  Tcl_HashSearch s ;
  hspell_hash_keyvalue *array ;
  hspell_hash_keyvalue *arrayp ;
  hspell_hash_keyvalue *arrayend ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 86
  if (! h->numEntries) {
#line 87
    *size = 0;
#line 88
    return ((hspell_hash_keyvalue *)0);
  }
  {
  {
#line 91
  tmp = malloc((size_t )((unsigned long )h->numEntries * sizeof(hspell_hash_keyvalue )));
  }
#line 91
  array = (hspell_hash_keyvalue *)tmp;
#line 94
  arrayp = array;
#line 95
  arrayend = array + h->numEntries;
  {
#line 97
  e = Tcl_FirstHashEntry(h, & s);
  }
  }
  {
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 97
    if (! e) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )arrayp >= (unsigned long )arrayend) {
      {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Internal error: allocated array of incorrect size. Truncating it.\n");
      }
      }
#line 102
      goto while_break;
    }
    {
#line 104
    arrayp->key = (char const   *)(e->key.string);
#line 105
    arrayp->value = (int )e->clientData;
#line 106
    arrayp ++;
    {
#line 97
    e = Tcl_NextHashEntry(& s);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((unsigned long )arrayp != (unsigned long )arrayend) {
    {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Internal error: allocated array of incorrect size. Wasted space.\n");
    }
#line 112
    *size = (int )(arrayp - array);
    }
  } else {
#line 114
    *size = h->numEntries;
  }
#line 116
  return (array);
}
}
#line 119 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static void hspell_hash_free_keyvalue_array(hspell_hash *h , int size , hspell_hash_keyvalue *p ) 
{ 


  {
#line 122
  if (p) {
    {
    {
#line 123
    free((void *)p);
    }
    }
  }
#line 124
  return;
}
}
#line 134 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static int hspell_hash_get_int(hspell_hash *hashp , char const   *key , int *value ) 
{ 
  Tcl_HashEntry *e ;

  {
  {
  {
#line 139
  e = Tcl_FindHashEntry(hashp, key);
  }
  }
#line 139
  if (! e) {
#line 140
    return (0);
  }
#line 141
  *value = (int )e->clientData;
#line 142
  return (1);
}
}
#line 145 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static void hspell_hash_set_int(hspell_hash *hashp , char const   *key ,
                                         int value ) 
{ 
  Tcl_HashEntry *e ;
  int isnew ;

  {
  {
  {
#line 151
  e = Tcl_CreateHashEntry(hashp, key, & isnew);
  }
#line 152
  e->clientData = (ClientData )value;
  }
#line 153
  return;
}
}
#line 158 "/home/wslee/benchmarks/textformat/hspell-1.0/hash.h"
__inline static void hspell_hash_destroy(hspell_hash *p ) 
{ 


  {
  {
  {
#line 160
  Tcl_DeleteHashTable(p, 0);
  }
  }
#line 161
  return;
}
}
#line 30 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static void load_personal_dict(hspell_hash *personaldict , int *currentdir_dictfile ) 
{ 
  int i ;
  char buf[512] ;
  FILE *fp ;
  char *home ;
  char *tmp ;
  int l ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 34
  hspell_hash_init(personaldict);
  }
  }
#line 35
  if (currentdir_dictfile) {
#line 36
    *currentdir_dictfile = 0;
  }
#line 37
  i = 0;
  {
  {
#line 37
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i <= 1)) {
#line 37
      goto while_break;
    }
#line 40
    if (i == 0) {
      {
      {
#line 41
      tmp = getenv("HOME");
      }
#line 41
      home = tmp;
      }
#line 42
      if (! home) {
#line 42
        goto __Cont;
      }
      {
      {
#line 43
      snprintf((char */* __restrict  */)(buf), (size_t )sizeof(buf), (char const   */* __restrict  */)"%s/.hspell_words",
               home);
      }
      }
    } else {
      {
      {
#line 46
      snprintf((char */* __restrict  */)(buf), (size_t )sizeof(buf), (char const   */* __restrict  */)"./hspell_words");
      }
      }
    }
    {
    {
#line 47
    fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
    }
    }
#line 48
    if (! fp) {
#line 48
      goto __Cont;
    }
#line 49
    if (i == 1) {
#line 49
      if (currentdir_dictfile) {
#line 50
        *currentdir_dictfile = 1;
      }
    }
    {
    {
#line 51
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 51
      tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
      }
#line 51
      if (! tmp___1) {
#line 51
        goto while_break___0;
      }
      {
      {
#line 52
      tmp___0 = strlen((char const   *)(buf));
      }
#line 52
      l = (int )tmp___0;
      }
#line 53
      if ((int )buf[l - 1] == 10) {
#line 54
        buf[l - 1] = (char )'\000';
      }
#line 55
      if ((int )buf[0] != 35) {
#line 55
        if ((int )buf[0] != 0) {
          {
          {
#line 56
          hspell_hash_incr_int(personaldict, (char const   *)(buf));
          }
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 58
    fclose(fp);
    }
    }
    __Cont: /* CIL Label */ 
#line 37
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 68 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int save_personal_dict(hspell_hash *personaldict , hspell_hash *personaldict_new_words ,
                              int currentdir_dictfile ) 
{ 
  FILE *fp ;
  hspell_hash_keyvalue *new_words_array ;
  int new_words_number ;
  int i ;
  char dict_filename[512] ;
  char *home ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 78
  tmp = getenv("HOME");
  }
#line 78
  home = tmp;
  }
#line 79
  if (currentdir_dictfile) {
    {
    {
#line 80
    snprintf((char */* __restrict  */)(dict_filename), (size_t )sizeof(dict_filename),
             (char const   */* __restrict  */)"./hspell_words");
    }
    }
  } else
#line 79
  if (! home) {
    {
    {
#line 80
    snprintf((char */* __restrict  */)(dict_filename), (size_t )sizeof(dict_filename),
             (char const   */* __restrict  */)"./hspell_words");
    }
    }
  } else {
    {
    {
#line 83
    snprintf((char */* __restrict  */)(dict_filename), (size_t )sizeof(dict_filename),
             (char const   */* __restrict  */)"%s/.hspell_words", home);
    }
    }
  }
  {
  {
#line 86
  fp = fopen((char const   */* __restrict  */)(dict_filename), (char const   */* __restrict  */)"a");
  }
  }
#line 87
  if (! fp) {
#line 88
    return (0);
  }
  {
  {
#line 105
  new_words_array = hspell_hash_build_keyvalue_array(personaldict_new_words, & new_words_number);
  }
  }
#line 107
  if (hspell_debug) {
    {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Saving %d words to %s\n",
            new_words_number, dict_filename);
    }
    }
  }
#line 111
  i = 0;
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < new_words_number)) {
#line 111
      goto while_break;
    }
    {
    {
#line 112
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            (new_words_array + i)->key);
    }
    {
#line 113
    hspell_hash_incr_int(personaldict, (new_words_array + i)->key);
    }
#line 111
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 115
  hspell_hash_free_keyvalue_array(personaldict_new_words, new_words_number, new_words_array);
  }
  {
#line 118
  hspell_hash_destroy(personaldict_new_words);
  }
  {
#line 119
  hspell_hash_init(personaldict_new_words);
  }
  {
#line 121
  tmp___0 = fclose(fp);
  }
  }
#line 121
  return (tmp___0 == 0);
}
}
#line 128 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
char *flathints  ;
#line 129 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
int flathints_size  ;
#line 130 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
void load_spelling_hints(hspell_hash *spellinghints ) 
{ 
  FILE *fp ;
  char s[1000] ;
  int len ;
  int thishint ;
  void *tmp ;
  char const   *tmp___0 ;
  int l ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 133
  len = 0;
#line 134
  thishint = 0;
  {
#line 136
  hspell_hash_init(spellinghints);
  }
#line 138
  flathints_size = 8192;
  {
#line 139
  tmp = malloc((size_t )flathints_size);
  }
#line 139
  flathints = (char *)tmp;
  {
#line 142
  tmp___0 = hspell_get_dictionary_path();
  }
  {
#line 142
  snprintf((char */* __restrict  */)(s), (size_t )sizeof(s), (char const   */* __restrict  */)"gzip -dc \'%s.hints\'",
           tmp___0);
  }
  {
#line 144
  fp = popen((char const   *)(s), "r");
  }
  }
#line 145
  if (! fp) {
    {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s\n",
            s);
    }
    }
#line 147
    return;
  }
  {
  {
#line 149
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 149
    tmp___3 = fgets((char */* __restrict  */)(s), (int )sizeof(s), (FILE */* __restrict  */)fp);
    }
    }
#line 149
    if (! tmp___3) {
#line 149
      goto while_break;
    }
    {
    {
#line 150
    tmp___1 = strlen((char const   *)(s));
    }
#line 150
    l = (int )tmp___1;
    }
#line 151
    if ((int )s[0] == 43) {
#line 152
      if (! thishint) {
#line 153
        thishint = len;
      }
      {
      {
#line 156
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 156
        if (! (len + l >= flathints_size)) {
#line 156
          goto while_break___0;
        }
        {
#line 157
        flathints_size *= 2;
        {
#line 158
        tmp___2 = realloc((void *)flathints, (size_t )flathints_size);
        }
#line 158
        flathints = (char *)tmp___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 164
      s[0] = (char )' ';
      {
#line 166
      strcpy((char */* __restrict  */)(flathints + len), (char const   */* __restrict  */)(s));
      }
#line 167
      len += l;
      }
    } else
#line 168
    if ((int )s[0] == 10) {
#line 169
      thishint = 0;
#line 170
      len ++;
    } else {
      {
#line 172
      s[l - 1] = (char)0;
      {
#line 173
      hspell_hash_set_int(spellinghints, (char const   *)(s), thishint);
      }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 176
  pclose(fp);
  }
  }
#line 177
  return;
}
}
#line 181 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int compare_key(void const   *a , void const   *b ) 
{ 
  register hspell_hash_keyvalue *aa ;
  register hspell_hash_keyvalue *bb ;
  int tmp ;

  {
  {
#line 183
  aa = (hspell_hash_keyvalue *)a;
#line 184
  bb = (hspell_hash_keyvalue *)b;
  {
#line 185
  tmp = strcmp(aa->key, bb->key);
  }
  }
#line 185
  return (tmp);
}
}
#line 187 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int compare_value_reverse(void const   *a , void const   *b ) 
{ 
  register hspell_hash_keyvalue *aa ;
  register hspell_hash_keyvalue *bb ;

  {
#line 189
  aa = (hspell_hash_keyvalue *)a;
#line 190
  bb = (hspell_hash_keyvalue *)b;
#line 191
  if (aa->value < bb->value) {
#line 192
    return (1);
  } else
#line 193
  if (aa->value > bb->value) {
#line 194
    return (-1);
  } else {
#line 195
    return (0);
  }
}
}
#line 198 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static FILE *next_file(int *argcp , char ***argvp ) 
{ 
  FILE *ret ;
  char *__cil_tmp4 ;

  {
#line 201
  ret = (FILE *)0;
#line 202
  if (*argcp <= 0) {
#line 203
    return ((FILE *)0);
  }
  {
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 204
    if (*argcp) {
#line 204
      if (! (! ret)) {
#line 204
        goto while_break;
      }
    } else {
#line 204
      goto while_break;
    }
    {
    {
#line 205
    ret = fopen((char const   */* __restrict  */)*(*argvp + 0), (char const   */* __restrict  */)"r");
    }
    }
#line 206
    if (! ret) {
      {
      {
#line 207
      perror((char const   *)*(*argvp + 0));
      }
      }
    }
#line 208
    (*argvp) ++;
#line 209
    (*argcp) --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (ret);
}
}
#line 231 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int uglyuglyflag  =    0;
#line 233 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
int notify_split(char const   *w , char const   *baseword , int preflen , int prefspec ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 236
  if (preflen > 0) {
    {
    {
#line 237
    printf((char const   */* __restrict  */)"\366\351\370\345\363 \347\345\367\351: %.*s+%s\n",
           preflen, w, baseword);
    }
    }
  } else
#line 238
  if (! preflen) {
    {
    {
#line 239
    printf((char const   */* __restrict  */)"\356\351\354\344 \347\345\367\351\372: %s\n",
           w);
    }
    }
  }
#line 255
  return (1);
}
}
#line 23 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static char const   *hspell_dictionary___0  =    "/usr/local/share/hspell/hebrew.wgz";
#line 45 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static int load_data___0(struct dict_radix **dictp ) 
{ 
  clock_t t1 ;
  clock_t t2 ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 49
  if (hspell_debug) {
    {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading data files... ");
    }
    {
#line 51
    t1 = clock();
    }
    }
  }
  {
  {
#line 54
  *dictp = new_dict_radix();
  }
  {
#line 55
  tmp = read_dict(*dictp, hspell_dictionary___0);
  }
  }
#line 55
  if (! tmp) {
    {
    {
#line 56
    delete_dict_radix(*dictp);
    }
    }
#line 57
    return (-1);
  }
#line 60
  if (hspell_debug) {
    {
    {
#line 61
    t2 = clock();
    }
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done (%d ms).\n",
            (int )((t2 - t1) / 1000L));
    }
    }
  }
#line 65
  return (0);
}
}
#line 5 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static char *prefixes_noH___0[243]  = 
#line 5 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\345",      (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344", 
        (char *)"\345\353",      (char *)"\345\353\341",      (char *)"\345\353\353",      (char *)"\345\353\354", 
        (char *)"\345\353\356",      (char *)"\345\353\356\344",      (char *)"\345\353\371",      (char *)"\345\353\371\341", 
        (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344",      (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341", 
        (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354",      (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344", 
        (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353",      (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344", 
        (char *)"\345\353\371\356\353",      (char *)"\345\354",      (char *)"\345\354\353",      (char *)"\345\354\353\371", 
        (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353",      (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353", 
        (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353",      (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356", 
        (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354",      (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356", 
        (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353",      (char *)"\345\356",      (char *)"\345\356\344", 
        (char *)"\345\356\353",      (char *)"\345\356\371",      (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353", 
        (char *)"\345\356\371\344",      (char *)"\345\356\371\353",      (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353", 
        (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356",      (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354", 
        (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356",      (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353", 
        (char *)"\345\371",      (char *)"\345\371\341",      (char *)"\345\371\341\353",      (char *)"\345\371\344", 
        (char *)"\345\371\353",      (char *)"\345\371\353\341",      (char *)"\345\371\353\353",      (char *)"\345\371\353\354", 
        (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344",      (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341", 
        (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344",      (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341", 
        (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354",      (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344", 
        (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353",      (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344", 
        (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354",      (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371", 
        (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353",      (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353", 
        (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353",      (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356", 
        (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354",      (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356", 
        (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353",      (char *)"\345\371\356",      (char *)"\345\371\356\344", 
        (char *)"\345\371\356\353",      (char *)"\345\371\356\371",      (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353", 
        (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353",      (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353", 
        (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356",      (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354", 
        (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356",      (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353", 
        (char *)"\353",      (char *)"\353\341",      (char *)"\353\353",      (char *)"\353\354", 
        (char *)"\353\356",      (char *)"\353\356\344",      (char *)"\353\371",      (char *)"\353\371\341", 
        (char *)"\353\371\341\353",      (char *)"\353\371\344",      (char *)"\353\371\353",      (char *)"\353\371\353\341", 
        (char *)"\353\371\353\353",      (char *)"\353\371\353\354",      (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344", 
        (char *)"\353\371\354",      (char *)"\353\371\354\353",      (char *)"\353\371\356",      (char *)"\353\371\356\344", 
        (char *)"\353\371\356\353",      (char *)"\354",      (char *)"\354\353",      (char *)"\354\353\371", 
        (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353",      (char *)"\354\353\371\344",      (char *)"\354\353\371\353", 
        (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353",      (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356", 
        (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354",      (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356", 
        (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353",      (char *)"\356",      (char *)"\356\341", 
        (char *)"\356\344",      (char *)"\356\353",      (char *)"\356\354",      (char *)"\356\371", 
        (char *)"\356\371\341",      (char *)"\356\371\341\353",      (char *)"\356\371\344",      (char *)"\356\371\353", 
        (char *)"\356\371\353\341",      (char *)"\356\371\353\353",      (char *)"\356\371\353\354",      (char *)"\356\371\353\356", 
        (char *)"\356\371\353\356\344",      (char *)"\356\371\354",      (char *)"\356\371\354\353",      (char *)"\356\371\356", 
        (char *)"\356\371\356\344",      (char *)"\356\371\356\353",      (char *)"\371",      (char *)"\371\341", 
        (char *)"\371\341\353",      (char *)"\371\344",      (char *)"\371\353",      (char *)"\371\353\341", 
        (char *)"\371\353\353",      (char *)"\371\353\354",      (char *)"\371\353\356",      (char *)"\371\353\356\344", 
        (char *)"\371\353\371",      (char *)"\371\353\371\341",      (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344", 
        (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341",      (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354", 
        (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344",      (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353", 
        (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344",      (char *)"\371\353\371\356\353",      (char *)"\371\354", 
        (char *)"\371\354\353",      (char *)"\371\354\353\371",      (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353", 
        (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353",      (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353", 
        (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356",      (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354", 
        (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356",      (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353", 
        (char *)"\371\356",      (char *)"\371\356\344",      (char *)"\371\356\353",      (char *)"\371\356\371", 
        (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353",      (char *)"\371\356\371\344",      (char *)"\371\356\371\353", 
        (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353",      (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356", 
        (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354",      (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356", 
        (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353",      (char *)0};
#line 248 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static int masks_noH___0[243]  = 
#line 248
  {      60,      43,      42,      32, 
        60,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      -1};
#line 491 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static char *prefixes_H___0[361]  = 
#line 491
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\344\341",      (char *)"\344\341\353",      (char *)"\344\344",      (char *)"\344\353", 
        (char *)"\344\353\341",      (char *)"\344\353\353",      (char *)"\344\353\354",      (char *)"\344\353\356", 
        (char *)"\344\353\356\344",      (char *)"\344\353\371",      (char *)"\344\353\371\341",      (char *)"\344\353\371\341\353", 
        (char *)"\344\353\371\344",      (char *)"\344\353\371\353",      (char *)"\344\353\371\353\341",      (char *)"\344\353\371\353\353", 
        (char *)"\344\353\371\353\354",      (char *)"\344\353\371\353\356",      (char *)"\344\353\371\353\356\344",      (char *)"\344\353\371\354", 
        (char *)"\344\353\371\354\353",      (char *)"\344\353\371\356",      (char *)"\344\353\371\356\344",      (char *)"\344\353\371\356\353", 
        (char *)"\344\354",      (char *)"\344\354\353",      (char *)"\344\354\353\371",      (char *)"\344\354\353\371\341", 
        (char *)"\344\354\353\371\341\353",      (char *)"\344\354\353\371\344",      (char *)"\344\354\353\371\353",      (char *)"\344\354\353\371\353\341", 
        (char *)"\344\354\353\371\353\353",      (char *)"\344\354\353\371\353\354",      (char *)"\344\354\353\371\353\356",      (char *)"\344\354\353\371\353\356\344", 
        (char *)"\344\354\353\371\354",      (char *)"\344\354\353\371\354\353",      (char *)"\344\354\353\371\356",      (char *)"\344\354\353\371\356\344", 
        (char *)"\344\354\353\371\356\353",      (char *)"\344\356",      (char *)"\344\356\344",      (char *)"\344\356\353", 
        (char *)"\344\356\371",      (char *)"\344\356\371\341",      (char *)"\344\356\371\341\353",      (char *)"\344\356\371\344", 
        (char *)"\344\356\371\353",      (char *)"\344\356\371\353\341",      (char *)"\344\356\371\353\353",      (char *)"\344\356\371\353\354", 
        (char *)"\344\356\371\353\356",      (char *)"\344\356\371\353\356\344",      (char *)"\344\356\371\354",      (char *)"\344\356\371\354\353", 
        (char *)"\344\356\371\356",      (char *)"\344\356\371\356\344",      (char *)"\344\356\371\356\353",      (char *)"\345", 
        (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344",      (char *)"\345\344\341", 
        (char *)"\345\344\341\353",      (char *)"\345\344\344",      (char *)"\345\344\353",      (char *)"\345\344\353\341", 
        (char *)"\345\344\353\353",      (char *)"\345\344\353\354",      (char *)"\345\344\353\356",      (char *)"\345\344\353\356\344", 
        (char *)"\345\344\353\371",      (char *)"\345\344\353\371\341",      (char *)"\345\344\353\371\341\353",      (char *)"\345\344\353\371\344", 
        (char *)"\345\344\353\371\353",      (char *)"\345\344\353\371\353\341",      (char *)"\345\344\353\371\353\353",      (char *)"\345\344\353\371\353\354", 
        (char *)"\345\344\353\371\353\356",      (char *)"\345\344\353\371\353\356\344",      (char *)"\345\344\353\371\354",      (char *)"\345\344\353\371\354\353", 
        (char *)"\345\344\353\371\356",      (char *)"\345\344\353\371\356\344",      (char *)"\345\344\353\371\356\353",      (char *)"\345\344\354", 
        (char *)"\345\344\354\353",      (char *)"\345\344\354\353\371",      (char *)"\345\344\354\353\371\341",      (char *)"\345\344\354\353\371\341\353", 
        (char *)"\345\344\354\353\371\344",      (char *)"\345\344\354\353\371\353",      (char *)"\345\344\354\353\371\353\341",      (char *)"\345\344\354\353\371\353\353", 
        (char *)"\345\344\354\353\371\353\354",      (char *)"\345\344\354\353\371\353\356",      (char *)"\345\344\354\353\371\353\356\344",      (char *)"\345\344\354\353\371\354", 
        (char *)"\345\344\354\353\371\354\353",      (char *)"\345\344\354\353\371\356",      (char *)"\345\344\354\353\371\356\344",      (char *)"\345\344\354\353\371\356\353", 
        (char *)"\345\344\356",      (char *)"\345\344\356\344",      (char *)"\345\344\356\353",      (char *)"\345\344\356\371", 
        (char *)"\345\344\356\371\341",      (char *)"\345\344\356\371\341\353",      (char *)"\345\344\356\371\344",      (char *)"\345\344\356\371\353", 
        (char *)"\345\344\356\371\353\341",      (char *)"\345\344\356\371\353\353",      (char *)"\345\344\356\371\353\354",      (char *)"\345\344\356\371\353\356", 
        (char *)"\345\344\356\371\353\356\344",      (char *)"\345\344\356\371\354",      (char *)"\345\344\356\371\354\353",      (char *)"\345\344\356\371\356", 
        (char *)"\345\344\356\371\356\344",      (char *)"\345\344\356\371\356\353",      (char *)"\345\353",      (char *)"\345\353\341", 
        (char *)"\345\353\353",      (char *)"\345\353\354",      (char *)"\345\353\356",      (char *)"\345\353\356\344", 
        (char *)"\345\353\371",      (char *)"\345\353\371\341",      (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344", 
        (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341",      (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354", 
        (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344",      (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353", 
        (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344",      (char *)"\345\353\371\356\353",      (char *)"\345\354", 
        (char *)"\345\354\353",      (char *)"\345\354\353\371",      (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353", 
        (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353",      (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353", 
        (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356",      (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354", 
        (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356",      (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353", 
        (char *)"\345\356",      (char *)"\345\356\344",      (char *)"\345\356\353",      (char *)"\345\356\371", 
        (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353",      (char *)"\345\356\371\344",      (char *)"\345\356\371\353", 
        (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353",      (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356", 
        (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354",      (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356", 
        (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353",      (char *)"\345\371",      (char *)"\345\371\341", 
        (char *)"\345\371\341\353",      (char *)"\345\371\344",      (char *)"\345\371\353",      (char *)"\345\371\353\341", 
        (char *)"\345\371\353\353",      (char *)"\345\371\353\354",      (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344", 
        (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341",      (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344", 
        (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341",      (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354", 
        (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344",      (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353", 
        (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344",      (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354", 
        (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371",      (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353", 
        (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353",      (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353", 
        (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356",      (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354", 
        (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356",      (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353", 
        (char *)"\345\371\356",      (char *)"\345\371\356\344",      (char *)"\345\371\356\353",      (char *)"\345\371\356\371", 
        (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353",      (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353", 
        (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353",      (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356", 
        (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354",      (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356", 
        (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353",      (char *)"\353",      (char *)"\353\341", 
        (char *)"\353\353",      (char *)"\353\354",      (char *)"\353\356",      (char *)"\353\356\344", 
        (char *)"\353\371",      (char *)"\353\371\341",      (char *)"\353\371\341\353",      (char *)"\353\371\344", 
        (char *)"\353\371\353",      (char *)"\353\371\353\341",      (char *)"\353\371\353\353",      (char *)"\353\371\353\354", 
        (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344",      (char *)"\353\371\354",      (char *)"\353\371\354\353", 
        (char *)"\353\371\356",      (char *)"\353\371\356\344",      (char *)"\353\371\356\353",      (char *)"\354", 
        (char *)"\354\353",      (char *)"\354\353\371",      (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353", 
        (char *)"\354\353\371\344",      (char *)"\354\353\371\353",      (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353", 
        (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356",      (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354", 
        (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356",      (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353", 
        (char *)"\356",      (char *)"\356\341",      (char *)"\356\344",      (char *)"\356\353", 
        (char *)"\356\354",      (char *)"\356\371",      (char *)"\356\371\341",      (char *)"\356\371\341\353", 
        (char *)"\356\371\344",      (char *)"\356\371\353",      (char *)"\356\371\353\341",      (char *)"\356\371\353\353", 
        (char *)"\356\371\353\354",      (char *)"\356\371\353\356",      (char *)"\356\371\353\356\344",      (char *)"\356\371\354", 
        (char *)"\356\371\354\353",      (char *)"\356\371\356",      (char *)"\356\371\356\344",      (char *)"\356\371\356\353", 
        (char *)"\371",      (char *)"\371\341",      (char *)"\371\341\353",      (char *)"\371\344", 
        (char *)"\371\353",      (char *)"\371\353\341",      (char *)"\371\353\353",      (char *)"\371\353\354", 
        (char *)"\371\353\356",      (char *)"\371\353\356\344",      (char *)"\371\353\371",      (char *)"\371\353\371\341", 
        (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344",      (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341", 
        (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354",      (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344", 
        (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353",      (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344", 
        (char *)"\371\353\371\356\353",      (char *)"\371\354",      (char *)"\371\354\353",      (char *)"\371\354\353\371", 
        (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353",      (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353", 
        (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353",      (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356", 
        (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354",      (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356", 
        (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353",      (char *)"\371\356",      (char *)"\371\356\344", 
        (char *)"\371\356\353",      (char *)"\371\356\371",      (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353", 
        (char *)"\371\356\371\344",      (char *)"\371\356\371\353",      (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353", 
        (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356",      (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354", 
        (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356",      (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353", 
        (char *)0};
#line 852 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static int masks_H___0[361]  = 
#line 852
  {      60,      43,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      32,      42, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      60, 
        43,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        -1};
#line 93 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static struct prefix_node *prefix_tree___0  =    (struct prefix_node *)0;
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static void build_prefix_tree___0(int allow_he_hasheela ) 
{ 
  int i ;
  char const   *p ;
  struct prefix_node **n ;
  char **prefixes ;
  int *masks ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 102
  if (allow_he_hasheela) {
#line 103
    prefixes = prefixes_H___0;
#line 104
    masks = masks_H___0;
  } else {
#line 106
    prefixes = prefixes_noH___0;
#line 107
    masks = masks_noH___0;
  }
#line 110
  i = 0;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! *(prefixes + i)) {
#line 110
      goto while_break;
    }
#line 111
    p = (char const   *)*(prefixes + i);
#line 112
    n = & prefix_tree___0;
#line 113
    if (hspell_debug) {
      {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prefix %s ",
              p);
      }
      }
    }
    {
    {
#line 115
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! *p) {
#line 115
        goto while_break___0;
      }
#line 116
      if (! *n) {
        {
        {
#line 117
        tmp = calloc((size_t )1, (size_t )sizeof(struct prefix_node ));
        }
#line 117
        *n = (struct prefix_node *)tmp;
        }
      }
#line 119
      n = & (*n)->next[(int const   )*p - -32];
#line 120
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if (! *n) {
      {
      {
#line 124
      tmp___0 = calloc((size_t )1, (size_t )sizeof(struct prefix_node ));
      }
#line 124
      *n = (struct prefix_node *)tmp___0;
      }
    }
#line 126
    (*n)->mask = *(masks + i);
#line 128
    if (hspell_debug) {
      {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mask=%d\n",
              (*n)->mask);
      }
      }
    }
#line 110
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static void free_prefix_tree___0(struct prefix_node *n ) 
{ 
  int i ;

  {
#line 138
  if (! n) {
#line 139
    return;
  }
#line 140
  i = 0;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )i < sizeof(n->next) / sizeof(n->next[0]))) {
#line 140
      goto while_break;
    }
    {
    {
#line 141
    free_prefix_tree___0(n->next[i]);
    }
#line 140
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 142
  free((void *)n);
  }
  }
#line 143
  return;
}
}
#line 371 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static char *similar___0[9]  = 
#line 371
  {      (char *)"\344\362\340",      (char *)"\342\344",      (char *)"\353\347",      (char *)"\372\350", 
        (char *)"\366\361",      (char *)"\371\361",      (char *)"\353\367",      (char *)"\341\345", 
        (char *)"\364\341"};
#line 149 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static Tcl_HashEntry *AllocStringEntry___0(Tcl_HashTable *tablePtr , void *keyPtr ) ;
#line 152
static int CompareStringKeys___0(void *keyPtr , Tcl_HashEntry *hPtr ) ;
#line 154
static unsigned int HashStringKey___0(Tcl_HashTable *tablePtr , void *keyPtr ) ;
#line 162
static void RebuildTable___0(Tcl_HashTable *tablePtr ) ;
#line 625 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static Tcl_HashEntry *AllocStringEntry___0(Tcl_HashTable *tablePtr , void *keyPtr ) 
{ 
  char const   *string ;
  Tcl_HashEntry *hPtr ;
  unsigned int size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 630
  string = (char const   *)keyPtr;
  {
#line 634
  tmp = strlen(string);
  }
#line 634
  size = (unsigned int )(((sizeof(Tcl_HashEntry ) + (unsigned long )tmp) + 1UL) - sizeof(hPtr->key));
  }
#line 635
  if ((unsigned long )size < sizeof(Tcl_HashEntry )) {
#line 636
    size = (unsigned int )sizeof(Tcl_HashEntry );
  }
  {
  {
#line 637
  tmp___0 = malloc(size);
  }
#line 637
  hPtr = (Tcl_HashEntry *)tmp___0;
  {
#line 638
  strcpy((char */* __restrict  */)(hPtr->key.string), (char const   */* __restrict  */)string);
  }
  }
#line 640
  return (hPtr);
}
}
#line 660 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static int CompareStringKeys___0(void *keyPtr , Tcl_HashEntry *hPtr ) 
{ 
  register char const   *p1 ;
  register char const   *p2 ;

  {
#line 665
  p1 = (char const   *)keyPtr;
#line 666
  p2 = (char const   *)(hPtr->key.string);
  {
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 669
    if ((int const   )*p1 != (int const   )*p2) {
#line 670
      goto while_break;
    }
#line 672
    if ((int const   )*p1 == 0) {
#line 673
      return (1);
    }
#line 668
    p1 ++;
#line 668
    p2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  return (0);
}
}
#line 697 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static unsigned int HashStringKey___0(Tcl_HashTable *tablePtr , void *keyPtr ) 
{ 
  register char const   *string ;
  register unsigned int result ;
  register int c ;

  {
#line 702
  string = (char const   *)keyPtr;
#line 722
  result = 0U;
  {
  {
#line 723
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 724
    c = (int )*string;
#line 725
    if (c == 0) {
#line 726
      goto while_break;
    }
#line 728
    result += (result << 3) + (unsigned int )c;
#line 729
    string ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  return (result);
}
}
#line 754 "/home/wslee/benchmarks/textformat/hspell-1.0/tclHash.c"
static void RebuildTable___0(Tcl_HashTable *tablePtr ) 
{ 
  int oldSize ;
  int count ;
  int index___0 ;
  Tcl_HashEntry **oldBuckets ;
  register Tcl_HashEntry **oldChainPtr ;
  register Tcl_HashEntry **newChainPtr ;
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  void *key ;
  void *tmp ;

  {
  {
#line 765
  oldSize = tablePtr->numBuckets;
#line 766
  oldBuckets = tablePtr->buckets;
#line 773
  tablePtr->numBuckets *= 4;
  {
#line 774
  tmp = malloc((unsigned int )((unsigned long )tablePtr->numBuckets * sizeof(Tcl_HashEntry *)));
  }
#line 774
  tablePtr->buckets = (Tcl_HashEntry **)tmp;
#line 776
  count = tablePtr->numBuckets;
#line 776
  newChainPtr = tablePtr->buckets;
  }
  {
  {
#line 776
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 776
    if (! (count > 0)) {
#line 776
      goto while_break;
    }
#line 778
    *newChainPtr = (Tcl_HashEntry *)((void *)0);
#line 776
    count --;
#line 776
    newChainPtr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  tablePtr->rebuildSize *= 4;
#line 781
  tablePtr->downShift -= 2;
#line 782
  tablePtr->mask = (tablePtr->mask << 2) + 3;
#line 784
  typePtr = tablePtr->typePtr;
#line 790
  oldChainPtr = oldBuckets;
  {
  {
#line 790
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 790
    if (! (oldSize > 0)) {
#line 790
      goto while_break___0;
    }
#line 791
    hPtr = *oldChainPtr;
    {
    {
#line 791
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 791
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 791
        goto while_break___1;
      }
#line 792
      *oldChainPtr = hPtr->nextPtr;
#line 794
      key = (void *)(hPtr->key.string);
#line 796
      if ((unsigned long )typePtr->hashKeyProc == (unsigned long )((void *)0)) {
#line 798
        index___0 = (int )(((long )hPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
      } else
#line 796
      if (typePtr->flags & 1) {
#line 798
        index___0 = (int )(((long )hPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
      } else {
#line 800
        index___0 = (int )(hPtr->hash & (unsigned int )tablePtr->mask);
      }
#line 802
      hPtr->nextPtr = *(tablePtr->buckets + index___0);
#line 803
      *(tablePtr->buckets + index___0) = hPtr;
#line 791
      hPtr = *oldChainPtr;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 790
    oldSize --;
#line 790
    oldChainPtr ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 811
  if ((unsigned long )oldBuckets != (unsigned long )(tablePtr->staticBuckets)) {
    {
    {
#line 812
    free((void *)((char *)oldBuckets));
    }
    }
  }
#line 814
  return;
}
}
#line 172 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static void do_print_tree___2(struct node *nodes , struct node_small *nodes_small ,
                              struct node_medium *nodes_medium , struct node_index head ,
                              char *word , int len , int maxlen ) 
{ 
  int i ;
  struct node *n ;
  unsigned char tmp ;
  struct node_small *n___0 ;
  struct node_medium *n___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 177
  if (len >= maxlen) {
    {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_print_tree(): warning: buffer overflow.\n");
    }
    }
#line 179
    return;
  }
#line 181
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 182
    n = nodes + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 183
    if (n->value) {
      {
#line 184
      *(word + len) = (char )'\000';
      {
#line 185
      printf((char const   */* __restrict  */)"%s %d\n", word, n->value);
      }
      }
    }
#line 187
    i = 0;
    {
    {
#line 187
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 187
      if (! (i < 29)) {
#line 187
        goto while_break;
      }
      {
      {
#line 188
      tmp = letter_to_char(i);
      }
#line 188
      *(word + len) = (char )tmp;
      {
#line 189
      do_print_tree___2(nodes, nodes_small, nodes_medium, n->children[i], word, len + 1,
                        maxlen);
      }
#line 187
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 192
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 193
    n___0 = nodes_small + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 194
    if (n___0->value) {
      {
#line 195
      *(word + len) = (char )'\000';
      {
#line 196
      printf((char const   */* __restrict  */)"%s %d\n", word, n___0->value);
      }
      }
    }
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 2)) {
#line 198
        goto while_break___0;
      }
#line 199
      if (n___0->chars[i]) {
        {
#line 200
        *(word + len) = n___0->chars[i];
        {
#line 201
        do_print_tree___2(nodes, nodes_small, nodes_medium, n___0->children[i], word,
                          len + 1, maxlen);
        }
        }
      }
#line 198
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 205
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 206
    n___1 = nodes_medium + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 207
    if (n___1->value) {
      {
#line 208
      *(word + len) = (char )'\000';
      {
#line 209
      printf((char const   */* __restrict  */)"%s %d\n", word, n___1->value);
      }
      }
    }
#line 211
    i = 0;
    {
    {
#line 211
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 211
      if (! (i < 8)) {
#line 211
        goto while_break___1;
      }
#line 212
      if (n___1->chars[i]) {
        {
#line 213
        *(word + len) = n___1->chars[i];
        {
#line 214
        do_print_tree___2(nodes, nodes_small, nodes_medium, n___1->children[i], word,
                          len + 1, maxlen);
        }
        }
      }
#line 211
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if (head.val_or_index) {
    {
#line 219
    *(word + len) = (char )'\000';
    {
#line 220
    printf((char const   */* __restrict  */)"%s %d\n", word, head.val_or_index);
    }
    }
  }
#line 222
  return;
}
}
#line 318
static int do_read_dict___2(void *fp , void *prefixes , struct dict_radix *dict ) ;
#line 406 "/home/wslee/benchmarks/textformat/hspell-1.0/dict_radix.c"
static int do_read_dict___2(void *fp , void *prefixes , struct dict_radix *dict ) 
{ 
  struct node_index *stack[256] ;
  int sdepth ;
  int c ;
  int n ;
  int cc ;
  int nwords ;
  struct node *nodes ;
  struct node_small *nodes_small ;
  struct node_medium *nodes_medium ;
  int nnodes_small ;
  int nnodes_medium ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;
  int chosen ;
  int j ;
  struct node_small *n___0 ;
  int chosen___0 ;
  int tmp___1 ;
  int j___0 ;
  struct node_medium *n___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 412
  sdepth = 0;
#line 415
  nwords = 0;
#line 416
  nodes = dict->nodes;
#line 417
  nodes_small = dict->nodes_small;
#line 418
  nodes_medium = dict->nodes_medium;
#line 419
  nnodes_small = 0;
#line 419
  nnodes_medium = 0;
#line 419
  nnodes = 0;
#line 421
  if (dict->nnodes) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_small) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_medium) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nwords) {
    {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
    }
#line 425
    return (0);
  }
#line 427
  if (! nodes) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_small) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_medium) {
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
    }
#line 430
    return (0);
  }
  {
  {
#line 433
  memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
  }
#line 434
  tmp = nnodes;
#line 434
  nnodes ++;
#line 434
  dict->head.val_or_index = (unsigned int )tmp | (3U << 30);
#line 435
  stack[0] = & dict->head;
#line 436
  sdepth = 0;
  }
  {
  {
#line 437
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 437
    c = gzb_getc((gzbFile *)fp);
    }
    }
#line 437
    if (! (c != -1)) {
#line 437
      goto while_break;
    }
#line 438
    if (c >= 48) {
#line 438
      if (c <= 57) {
        {
#line 440
        nwords ++;
        {
#line 443
        tmp___0 = gzb_getc((gzbFile *)prefixes);
        }
#line 443
        (stack[sdepth])->val_or_index = (uint32_t )tmp___0;
#line 448
        n = 0;
        }
        {
        {
#line 449
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
#line 451
          n *= 10;
#line 452
          n += c - 48;
          {
#line 449
          c = gzb_getc((gzbFile *)fp);
          }
          }
#line 449
          if (c != -1) {
#line 449
            if (c >= 48) {
#line 449
              if (! (c <= 57)) {
#line 449
                goto while_break___0;
              }
            } else {
#line 449
              goto while_break___0;
            }
          } else {
#line 449
            goto while_break___0;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 454
        sdepth -= n;
#line 455
        if (sdepth < 0) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        } else
#line 455
        if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
          {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
          }
#line 457
          return (0);
        }
      }
    }
#line 462
    if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
      {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: word too long... giving up\n");
      }
      }
#line 464
      return (0);
    }
    {
    {
#line 466
    cc = char_to_letter((unsigned char )c);
    }
    }
#line 469
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 471
      if (dict->nfree_nodes_small) {
#line 472
        (dict->nfree_nodes_small) --;
#line 472
        chosen = dict->free_nodes_small[dict->nfree_nodes_small];
      } else {
#line 475
        chosen = nnodes_small;
#line 476
        if (nnodes_small >= dict->size_nodes_small) {
          {
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (small) - failing.\n");
          }
          }
#line 478
          return (0);
        }
#line 480
        nnodes_small ++;
      }
      {
      {
#line 482
      memset((void *)(nodes_small + chosen), 0, (size_t )sizeof(*(nodes_small + chosen)));
      }
#line 483
      (nodes_small + chosen)->value = (stack[sdepth])->val_or_index;
#line 484
      (stack[sdepth])->val_or_index = (unsigned int )chosen | (1U << 30);
#line 486
      (nodes_small + chosen)->chars[0] = (char )c;
#line 487
      stack[sdepth + 1] = & (nodes_small + chosen)->children[0];
      }
    } else
#line 488
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 490
      n___0 = nodes_small + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 493
      j = 0;
      {
      {
#line 493
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 493
        if (! (j < 2)) {
#line 493
          goto while_break___1;
        }
#line 494
        if (! n___0->chars[j]) {
#line 495
          n___0->chars[j] = (char )c;
#line 496
          stack[sdepth + 1] = & n___0->children[j];
#line 497
          goto while_break___1;
        }
#line 493
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (j == 2) {
#line 502
        if (dict->nfree_nodes_medium) {
#line 503
          (dict->nfree_nodes_medium) --;
#line 503
          chosen___0 = dict->free_nodes_medium[dict->nfree_nodes_medium];
        } else {
#line 506
          chosen___0 = nnodes_medium;
#line 507
          if (nnodes_medium >= dict->size_nodes_medium) {
            {
            {
#line 508
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (medium) - failing.\n");
            }
            }
#line 509
            return (0);
          }
#line 511
          nnodes_medium ++;
        }
        {
        {
#line 513
        memset((void *)(nodes_medium + chosen___0), 0, (size_t )sizeof(*(nodes_medium + chosen___0)));
        }
        }
#line 514
        if ((unsigned long )dict->nfree_nodes_small >= sizeof(dict->free_nodes_small) / sizeof(dict->free_nodes_small[0])) {
          {
          {
#line 517
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_small.\n");
          }
          }
#line 518
          return (0);
        }
#line 520
        tmp___1 = dict->nfree_nodes_small;
#line 520
        (dict->nfree_nodes_small) ++;
#line 520
        dict->free_nodes_small[tmp___1] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 523
        (stack[sdepth])->val_or_index = (unsigned int )chosen___0 | (2U << 30);
#line 526
        (nodes_medium + chosen___0)->value = n___0->value;
#line 527
        j = 0;
        {
        {
#line 527
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 527
          if (! (j < 2)) {
#line 527
            goto while_break___2;
          }
#line 528
          (nodes_medium + chosen___0)->chars[j] = n___0->chars[j];
#line 530
          (nodes_medium + chosen___0)->children[j] = n___0->children[j];
#line 527
          j ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        (nodes_medium + chosen___0)->chars[2] = (char )c;
#line 536
        stack[sdepth + 1] = & (nodes_medium + chosen___0)->children[2];
      }
    } else
#line 539
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 541
      n___1 = nodes_medium + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 544
      j___0 = 0;
      {
      {
#line 544
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! (j___0 < 8)) {
#line 544
          goto while_break___3;
        }
#line 545
        if (! n___1->chars[j___0]) {
#line 546
          n___1->chars[j___0] = (char )c;
#line 547
          stack[sdepth + 1] = & n___1->children[j___0];
#line 548
          goto while_break___3;
        }
#line 544
        j___0 ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      if (j___0 == 8) {
#line 552
        if (nnodes >= dict->size_nodes) {
          {
          {
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (full) - failing.\n");
          }
          }
#line 554
          return (0);
        }
        {
        {
#line 556
        memset((void *)(nodes + nnodes), 0, (size_t )sizeof(*(nodes + nnodes)));
        }
#line 557
        (nodes + nnodes)->value = n___1->value;
        }
#line 558
        if ((unsigned long )dict->nfree_nodes_medium >= sizeof(dict->free_nodes_medium) / sizeof(dict->free_nodes_medium[0])) {
          {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_medium.\n");
          }
          }
#line 562
          return (0);
        }
#line 564
        tmp___2 = dict->nfree_nodes_medium;
#line 564
        (dict->nfree_nodes_medium) ++;
#line 564
        dict->free_nodes_medium[tmp___2] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 567
        (stack[sdepth])->val_or_index = (unsigned int )nnodes | (3U << 30);
#line 569
        j___0 = 0;
        {
        {
#line 569
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 569
          if (! (j___0 < 8)) {
#line 569
            goto while_break___4;
          }
          {
          {
#line 570
          tmp___3 = char_to_letter((unsigned char )n___1->chars[j___0]);
          }
#line 570
          (nodes + nnodes)->children[tmp___3] = n___1->children[j___0];
#line 569
          j___0 ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 574
        stack[sdepth + 1] = & (nodes + nnodes)->children[cc];
#line 575
        nnodes ++;
      }
    } else {
#line 578
      stack[sdepth + 1] = & (nodes + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30))))->children[cc];
    }
#line 581
    sdepth ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  nwords ++;
  {
#line 586
  tmp___4 = gzb_getc((gzbFile *)prefixes);
  }
#line 586
  (stack[sdepth])->val_or_index = (uint32_t )tmp___4;
#line 592
  dict->nwords = nwords;
#line 593
  dict->nnodes_small = nnodes_small;
#line 594
  dict->nnodes_medium = nnodes_medium;
#line 595
  dict->nnodes = nnodes;
  }
#line 597
  return (1);
}
}
#line 11 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static int gim2int___1(char const   *w ) 
{ 
  int n ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 13
  n = 0;
#line 14
  if (hspell_debug) {
    {
    {
#line 14
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gim2int got %s ",
            w);
    }
    }
  }
  {
  {
#line 15
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 15
    if (! *w) {
#line 15
      goto while_break;
    }
    {
#line 17
    if ((int const   )*w == 39) {
#line 17
      goto case_39;
    }
#line 28
    if ((int const   )*w == -32) {
#line 28
      goto case_neg_32;
    }
#line 29
    if ((int const   )*w == -31) {
#line 29
      goto case_neg_31;
    }
#line 30
    if ((int const   )*w == -30) {
#line 30
      goto case_neg_30;
    }
#line 31
    if ((int const   )*w == -29) {
#line 31
      goto case_neg_29;
    }
#line 32
    if ((int const   )*w == -28) {
#line 32
      goto case_neg_28;
    }
#line 33
    if ((int const   )*w == -27) {
#line 33
      goto case_neg_27;
    }
#line 34
    if ((int const   )*w == -26) {
#line 34
      goto case_neg_26;
    }
#line 35
    if ((int const   )*w == -25) {
#line 35
      goto case_neg_25;
    }
#line 36
    if ((int const   )*w == -24) {
#line 36
      goto case_neg_24;
    }
#line 37
    if ((int const   )*w == -23) {
#line 37
      goto case_neg_23;
    }
#line 38
    if ((int const   )*w == -22) {
#line 38
      goto case_neg_22;
    }
#line 38
    if ((int const   )*w == -21) {
#line 38
      goto case_neg_22;
    }
#line 39
    if ((int const   )*w == -20) {
#line 39
      goto case_neg_20;
    }
#line 40
    if ((int const   )*w == -19) {
#line 40
      goto case_neg_19;
    }
#line 40
    if ((int const   )*w == -18) {
#line 40
      goto case_neg_19;
    }
#line 41
    if ((int const   )*w == -17) {
#line 41
      goto case_neg_17;
    }
#line 41
    if ((int const   )*w == -16) {
#line 41
      goto case_neg_17;
    }
#line 42
    if ((int const   )*w == -15) {
#line 42
      goto case_neg_15;
    }
#line 43
    if ((int const   )*w == -14) {
#line 43
      goto case_neg_14;
    }
#line 44
    if ((int const   )*w == -13) {
#line 44
      goto case_neg_13;
    }
#line 44
    if ((int const   )*w == -12) {
#line 44
      goto case_neg_13;
    }
#line 45
    if ((int const   )*w == -11) {
#line 45
      goto case_neg_11;
    }
#line 45
    if ((int const   )*w == -10) {
#line 45
      goto case_neg_11;
    }
#line 46
    if ((int const   )*w == -9) {
#line 46
      goto case_neg_9;
    }
#line 47
    if ((int const   )*w == -8) {
#line 47
      goto case_neg_8;
    }
#line 48
    if ((int const   )*w == -7) {
#line 48
      goto case_neg_7;
    }
#line 49
    if ((int const   )*w == -6) {
#line 49
      goto case_neg_6;
    }
#line 16
    goto switch_break;
    case_39: /* CIL Label */ 
#line 25
    if (*(w + 1)) {
#line 26
      n *= 1000;
    }
#line 27
    goto switch_break;
    case_neg_32: /* CIL Label */ 
#line 28
    n ++;
#line 28
    goto switch_break;
    case_neg_31: /* CIL Label */ 
#line 29
    n += 2;
#line 29
    goto switch_break;
    case_neg_30: /* CIL Label */ 
#line 30
    n += 3;
#line 30
    goto switch_break;
    case_neg_29: /* CIL Label */ 
#line 31
    n += 4;
#line 31
    goto switch_break;
    case_neg_28: /* CIL Label */ 
#line 32
    n += 5;
#line 32
    goto switch_break;
    case_neg_27: /* CIL Label */ 
#line 33
    n += 6;
#line 33
    goto switch_break;
    case_neg_26: /* CIL Label */ 
#line 34
    n += 7;
#line 34
    goto switch_break;
    case_neg_25: /* CIL Label */ 
#line 35
    n += 8;
#line 35
    goto switch_break;
    case_neg_24: /* CIL Label */ 
#line 36
    n += 9;
#line 36
    goto switch_break;
    case_neg_23: /* CIL Label */ 
#line 37
    n += 10;
#line 37
    goto switch_break;
    case_neg_22: /* CIL Label */ 
    case_neg_21: /* CIL Label */ 
#line 38
    n += 20;
#line 38
    goto switch_break;
    case_neg_20: /* CIL Label */ 
#line 39
    n += 30;
#line 39
    goto switch_break;
    case_neg_19: /* CIL Label */ 
    case_neg_18: /* CIL Label */ 
#line 40
    n += 40;
#line 40
    goto switch_break;
    case_neg_17: /* CIL Label */ 
    case_neg_16: /* CIL Label */ 
#line 41
    n += 50;
#line 41
    goto switch_break;
    case_neg_15: /* CIL Label */ 
#line 42
    n += 60;
#line 42
    goto switch_break;
    case_neg_14: /* CIL Label */ 
#line 43
    n += 70;
#line 43
    goto switch_break;
    case_neg_13: /* CIL Label */ 
    case_neg_12: /* CIL Label */ 
#line 44
    n += 80;
#line 44
    goto switch_break;
    case_neg_11: /* CIL Label */ 
    case_neg_10: /* CIL Label */ 
#line 45
    n += 90;
#line 45
    goto switch_break;
    case_neg_9: /* CIL Label */ 
#line 46
    n += 100;
#line 46
    goto switch_break;
    case_neg_8: /* CIL Label */ 
#line 47
    n += 200;
#line 47
    goto switch_break;
    case_neg_7: /* CIL Label */ 
#line 48
    n += 300;
#line 48
    goto switch_break;
    case_neg_6: /* CIL Label */ 
#line 49
    n += 400;
#line 49
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 52
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (hspell_debug) {
    {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %d\n",
            n);
    }
    }
  }
#line 55
  return (n);
}
}
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *appendStr___1(char *src , char *dst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! *src) {
#line 99
      goto while_break;
    }
#line 100
    tmp = dst;
#line 100
    dst ++;
#line 100
    tmp___0 = src;
#line 100
    src ++;
#line 100
    *tmp = *tmp___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  *dst = (char )'\000';
#line 103
  return (dst);
}
}
#line 108
static void int2gim___1(int n , char *buf ) ;
#line 108 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *digits___1[3][9]  = { {        (char *)"\340",        (char *)"\341",        (char *)"\342",        (char *)"\343", 
            (char *)"\344",        (char *)"\345",        (char *)"\346",        (char *)"\347", 
            (char *)"\350"}, 
   {        (char *)"\351",        (char *)"\353",        (char *)"\354",        (char *)"\356", 
            (char *)"\360",        (char *)"\361",        (char *)"\362",        (char *)"\364", 
            (char *)"\366"}, 
   {        (char *)"\367",        (char *)"\370",        (char *)"\371",        (char *)"\372", 
            (char *)"\367\372",        (char *)"\370\372",        (char *)"\371\372",        (char *)"\372\372", 
            (char *)"\367\372\372"}};
#line 113 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static char *special___1[2]  = {      (char *)"\345\350",      (char *)"\346\350"};
#line 105 "/home/wslee/benchmarks/textformat/hspell-1.0/gimatria.c"
static void int2gim___1(int n , char *buf ) 
{ 
  int i ;
  char *b ;
  char *bleft ;
  char *bright ;
  char tmp ;
  char save ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 114
  i = 0;
#line 115
  b = buf;
#line 116
  *b = (char )'\000';
#line 118
  if (hspell_debug) {
    {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"int2gim got %d ",
            n);
    }
    }
  }
  {
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 119
    if (! (n > 0)) {
#line 119
      goto while_break;
    }
#line 120
    if (i == 3) {
      {
#line 120
      i = 0;
      {
#line 120
      b = appendStr___1((char *)"\'", b);
      }
      }
    }
#line 121
    if (! i) {
#line 121
      if (n % 100 == 15) {
        {
        {
#line 122
        b = appendStr___1(special___1[n % 100 - 15], b);
        }
#line 123
        n /= 100;
#line 124
        i = 2;
        }
      } else
#line 121
      if (n % 100 == 16) {
        {
        {
#line 122
        b = appendStr___1(special___1[n % 100 - 15], b);
        }
#line 123
        n /= 100;
#line 124
        i = 2;
        }
      } else {
#line 121
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 126
      if (n % 10) {
        {
        {
#line 126
        b = appendStr___1(digits___1[i][n % 10 - 1], b);
        }
        }
      }
#line 128
      n /= 10;
#line 129
      i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (hspell_debug) {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"before %s\n",
            buf);
    }
    }
  }
#line 134
  if ((int )*(buf + 0) != 0) {
#line 135
    bleft = buf;
#line 135
    bright = b - 1;
    {
    {
#line 135
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! ((unsigned long )bright > (unsigned long )bleft)) {
#line 135
        goto while_break___0;
      }
#line 137
      tmp = *bleft;
#line 138
      *bleft = *bright;
#line 139
      *bright = tmp;
#line 135
      bleft ++;
#line 135
      bright --;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 141
  if (hspell_debug) {
    {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"after %s\n",
            buf);
    }
    }
  }
#line 143
  if (*(buf + 0)) {
    {
#line 145
    if ((int )*(b + -1) == -21) {
#line 145
      goto case_neg_21;
    }
#line 146
    if ((int )*(b + -1) == -18) {
#line 146
      goto case_neg_18;
    }
#line 147
    if ((int )*(b + -1) == -16) {
#line 147
      goto case_neg_16;
    }
#line 148
    if ((int )*(b + -1) == -10) {
#line 148
      goto case_neg_10;
    }
#line 149
    if ((int )*(b + -1) == -12) {
#line 149
      goto case_neg_12;
    }
#line 144
    goto switch_break;
    case_neg_21: /* CIL Label */ 
#line 145
    *(b + -1) = (char )'\352';
#line 145
    goto switch_break;
    case_neg_18: /* CIL Label */ 
#line 146
    *(b + -1) = (char )'\355';
#line 146
    goto switch_break;
    case_neg_16: /* CIL Label */ 
#line 147
    *(b + -1) = (char )'\357';
#line 147
    goto switch_break;
    case_neg_10: /* CIL Label */ 
#line 148
    *(b + -1) = (char )'\365';
#line 148
    goto switch_break;
    case_neg_12: /* CIL Label */ 
#line 149
    *(b + -1) = (char )'\363';
#line 149
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 155
  if ((int )*(buf + 0) != 0) {
#line 156
    if ((int )*(buf + 1) == 0) {
#line 157
      *(buf + 1) = (char )'\'';
#line 158
      *(buf + 2) = (char )'\000';
    } else
#line 163
    if ((int )*(b + -2) == 39) {
#line 163
      if ((int )*(b + -1) != 39) {
#line 164
        *(b + 0) = (char )'\'';
#line 165
        *(b + 1) = (char )'\000';
      } else {
#line 163
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 166
    if ((int )*(b + -1) != 39) {
#line 167
      save = *(b + -1);
#line 168
      *(b + -1) = (char )'\"';
#line 169
      *(b + 0) = save;
#line 170
      *(b + 1) = (char )'\000';
    }
  }
#line 173
  if (hspell_debug) {
    {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %s\n",
            buf);
    }
    }
  }
#line 174
  return;
}
}
#line 23 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static char const   *hspell_dictionary___1  =    "/usr/local/share/hspell/hebrew.wgz";
#line 45 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static int load_data___1(struct dict_radix **dictp ) 
{ 
  clock_t t1 ;
  clock_t t2 ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 49
  if (hspell_debug) {
    {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading data files... ");
    }
    {
#line 51
    t1 = clock();
    }
    }
  }
  {
  {
#line 54
  *dictp = new_dict_radix();
  }
  {
#line 55
  tmp = read_dict(*dictp, hspell_dictionary___1);
  }
  }
#line 55
  if (! tmp) {
    {
    {
#line 56
    delete_dict_radix(*dictp);
    }
    }
#line 57
    return (-1);
  }
#line 60
  if (hspell_debug) {
    {
    {
#line 61
    t2 = clock();
    }
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done (%d ms).\n",
            (int )((t2 - t1) / 1000L));
    }
    }
  }
#line 65
  return (0);
}
}
#line 5 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static char *prefixes_noH___1[243]  = 
#line 5 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\345",      (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344", 
        (char *)"\345\353",      (char *)"\345\353\341",      (char *)"\345\353\353",      (char *)"\345\353\354", 
        (char *)"\345\353\356",      (char *)"\345\353\356\344",      (char *)"\345\353\371",      (char *)"\345\353\371\341", 
        (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344",      (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341", 
        (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354",      (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344", 
        (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353",      (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344", 
        (char *)"\345\353\371\356\353",      (char *)"\345\354",      (char *)"\345\354\353",      (char *)"\345\354\353\371", 
        (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353",      (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353", 
        (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353",      (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356", 
        (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354",      (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356", 
        (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353",      (char *)"\345\356",      (char *)"\345\356\344", 
        (char *)"\345\356\353",      (char *)"\345\356\371",      (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353", 
        (char *)"\345\356\371\344",      (char *)"\345\356\371\353",      (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353", 
        (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356",      (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354", 
        (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356",      (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353", 
        (char *)"\345\371",      (char *)"\345\371\341",      (char *)"\345\371\341\353",      (char *)"\345\371\344", 
        (char *)"\345\371\353",      (char *)"\345\371\353\341",      (char *)"\345\371\353\353",      (char *)"\345\371\353\354", 
        (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344",      (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341", 
        (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344",      (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341", 
        (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354",      (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344", 
        (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353",      (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344", 
        (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354",      (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371", 
        (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353",      (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353", 
        (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353",      (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356", 
        (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354",      (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356", 
        (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353",      (char *)"\345\371\356",      (char *)"\345\371\356\344", 
        (char *)"\345\371\356\353",      (char *)"\345\371\356\371",      (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353", 
        (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353",      (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353", 
        (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356",      (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354", 
        (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356",      (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353", 
        (char *)"\353",      (char *)"\353\341",      (char *)"\353\353",      (char *)"\353\354", 
        (char *)"\353\356",      (char *)"\353\356\344",      (char *)"\353\371",      (char *)"\353\371\341", 
        (char *)"\353\371\341\353",      (char *)"\353\371\344",      (char *)"\353\371\353",      (char *)"\353\371\353\341", 
        (char *)"\353\371\353\353",      (char *)"\353\371\353\354",      (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344", 
        (char *)"\353\371\354",      (char *)"\353\371\354\353",      (char *)"\353\371\356",      (char *)"\353\371\356\344", 
        (char *)"\353\371\356\353",      (char *)"\354",      (char *)"\354\353",      (char *)"\354\353\371", 
        (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353",      (char *)"\354\353\371\344",      (char *)"\354\353\371\353", 
        (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353",      (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356", 
        (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354",      (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356", 
        (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353",      (char *)"\356",      (char *)"\356\341", 
        (char *)"\356\344",      (char *)"\356\353",      (char *)"\356\354",      (char *)"\356\371", 
        (char *)"\356\371\341",      (char *)"\356\371\341\353",      (char *)"\356\371\344",      (char *)"\356\371\353", 
        (char *)"\356\371\353\341",      (char *)"\356\371\353\353",      (char *)"\356\371\353\354",      (char *)"\356\371\353\356", 
        (char *)"\356\371\353\356\344",      (char *)"\356\371\354",      (char *)"\356\371\354\353",      (char *)"\356\371\356", 
        (char *)"\356\371\356\344",      (char *)"\356\371\356\353",      (char *)"\371",      (char *)"\371\341", 
        (char *)"\371\341\353",      (char *)"\371\344",      (char *)"\371\353",      (char *)"\371\353\341", 
        (char *)"\371\353\353",      (char *)"\371\353\354",      (char *)"\371\353\356",      (char *)"\371\353\356\344", 
        (char *)"\371\353\371",      (char *)"\371\353\371\341",      (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344", 
        (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341",      (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354", 
        (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344",      (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353", 
        (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344",      (char *)"\371\353\371\356\353",      (char *)"\371\354", 
        (char *)"\371\354\353",      (char *)"\371\354\353\371",      (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353", 
        (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353",      (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353", 
        (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356",      (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354", 
        (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356",      (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353", 
        (char *)"\371\356",      (char *)"\371\356\344",      (char *)"\371\356\353",      (char *)"\371\356\371", 
        (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353",      (char *)"\371\356\371\344",      (char *)"\371\356\371\353", 
        (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353",      (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356", 
        (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354",      (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356", 
        (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353",      (char *)0};
#line 248 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static int masks_noH___1[243]  = 
#line 248
  {      60,      43,      42,      32, 
        60,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      -1};
#line 491 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static char *prefixes_H___1[361]  = 
#line 491
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\344\341",      (char *)"\344\341\353",      (char *)"\344\344",      (char *)"\344\353", 
        (char *)"\344\353\341",      (char *)"\344\353\353",      (char *)"\344\353\354",      (char *)"\344\353\356", 
        (char *)"\344\353\356\344",      (char *)"\344\353\371",      (char *)"\344\353\371\341",      (char *)"\344\353\371\341\353", 
        (char *)"\344\353\371\344",      (char *)"\344\353\371\353",      (char *)"\344\353\371\353\341",      (char *)"\344\353\371\353\353", 
        (char *)"\344\353\371\353\354",      (char *)"\344\353\371\353\356",      (char *)"\344\353\371\353\356\344",      (char *)"\344\353\371\354", 
        (char *)"\344\353\371\354\353",      (char *)"\344\353\371\356",      (char *)"\344\353\371\356\344",      (char *)"\344\353\371\356\353", 
        (char *)"\344\354",      (char *)"\344\354\353",      (char *)"\344\354\353\371",      (char *)"\344\354\353\371\341", 
        (char *)"\344\354\353\371\341\353",      (char *)"\344\354\353\371\344",      (char *)"\344\354\353\371\353",      (char *)"\344\354\353\371\353\341", 
        (char *)"\344\354\353\371\353\353",      (char *)"\344\354\353\371\353\354",      (char *)"\344\354\353\371\353\356",      (char *)"\344\354\353\371\353\356\344", 
        (char *)"\344\354\353\371\354",      (char *)"\344\354\353\371\354\353",      (char *)"\344\354\353\371\356",      (char *)"\344\354\353\371\356\344", 
        (char *)"\344\354\353\371\356\353",      (char *)"\344\356",      (char *)"\344\356\344",      (char *)"\344\356\353", 
        (char *)"\344\356\371",      (char *)"\344\356\371\341",      (char *)"\344\356\371\341\353",      (char *)"\344\356\371\344", 
        (char *)"\344\356\371\353",      (char *)"\344\356\371\353\341",      (char *)"\344\356\371\353\353",      (char *)"\344\356\371\353\354", 
        (char *)"\344\356\371\353\356",      (char *)"\344\356\371\353\356\344",      (char *)"\344\356\371\354",      (char *)"\344\356\371\354\353", 
        (char *)"\344\356\371\356",      (char *)"\344\356\371\356\344",      (char *)"\344\356\371\356\353",      (char *)"\345", 
        (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344",      (char *)"\345\344\341", 
        (char *)"\345\344\341\353",      (char *)"\345\344\344",      (char *)"\345\344\353",      (char *)"\345\344\353\341", 
        (char *)"\345\344\353\353",      (char *)"\345\344\353\354",      (char *)"\345\344\353\356",      (char *)"\345\344\353\356\344", 
        (char *)"\345\344\353\371",      (char *)"\345\344\353\371\341",      (char *)"\345\344\353\371\341\353",      (char *)"\345\344\353\371\344", 
        (char *)"\345\344\353\371\353",      (char *)"\345\344\353\371\353\341",      (char *)"\345\344\353\371\353\353",      (char *)"\345\344\353\371\353\354", 
        (char *)"\345\344\353\371\353\356",      (char *)"\345\344\353\371\353\356\344",      (char *)"\345\344\353\371\354",      (char *)"\345\344\353\371\354\353", 
        (char *)"\345\344\353\371\356",      (char *)"\345\344\353\371\356\344",      (char *)"\345\344\353\371\356\353",      (char *)"\345\344\354", 
        (char *)"\345\344\354\353",      (char *)"\345\344\354\353\371",      (char *)"\345\344\354\353\371\341",      (char *)"\345\344\354\353\371\341\353", 
        (char *)"\345\344\354\353\371\344",      (char *)"\345\344\354\353\371\353",      (char *)"\345\344\354\353\371\353\341",      (char *)"\345\344\354\353\371\353\353", 
        (char *)"\345\344\354\353\371\353\354",      (char *)"\345\344\354\353\371\353\356",      (char *)"\345\344\354\353\371\353\356\344",      (char *)"\345\344\354\353\371\354", 
        (char *)"\345\344\354\353\371\354\353",      (char *)"\345\344\354\353\371\356",      (char *)"\345\344\354\353\371\356\344",      (char *)"\345\344\354\353\371\356\353", 
        (char *)"\345\344\356",      (char *)"\345\344\356\344",      (char *)"\345\344\356\353",      (char *)"\345\344\356\371", 
        (char *)"\345\344\356\371\341",      (char *)"\345\344\356\371\341\353",      (char *)"\345\344\356\371\344",      (char *)"\345\344\356\371\353", 
        (char *)"\345\344\356\371\353\341",      (char *)"\345\344\356\371\353\353",      (char *)"\345\344\356\371\353\354",      (char *)"\345\344\356\371\353\356", 
        (char *)"\345\344\356\371\353\356\344",      (char *)"\345\344\356\371\354",      (char *)"\345\344\356\371\354\353",      (char *)"\345\344\356\371\356", 
        (char *)"\345\344\356\371\356\344",      (char *)"\345\344\356\371\356\353",      (char *)"\345\353",      (char *)"\345\353\341", 
        (char *)"\345\353\353",      (char *)"\345\353\354",      (char *)"\345\353\356",      (char *)"\345\353\356\344", 
        (char *)"\345\353\371",      (char *)"\345\353\371\341",      (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344", 
        (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341",      (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354", 
        (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344",      (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353", 
        (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344",      (char *)"\345\353\371\356\353",      (char *)"\345\354", 
        (char *)"\345\354\353",      (char *)"\345\354\353\371",      (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353", 
        (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353",      (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353", 
        (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356",      (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354", 
        (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356",      (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353", 
        (char *)"\345\356",      (char *)"\345\356\344",      (char *)"\345\356\353",      (char *)"\345\356\371", 
        (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353",      (char *)"\345\356\371\344",      (char *)"\345\356\371\353", 
        (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353",      (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356", 
        (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354",      (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356", 
        (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353",      (char *)"\345\371",      (char *)"\345\371\341", 
        (char *)"\345\371\341\353",      (char *)"\345\371\344",      (char *)"\345\371\353",      (char *)"\345\371\353\341", 
        (char *)"\345\371\353\353",      (char *)"\345\371\353\354",      (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344", 
        (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341",      (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344", 
        (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341",      (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354", 
        (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344",      (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353", 
        (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344",      (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354", 
        (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371",      (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353", 
        (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353",      (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353", 
        (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356",      (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354", 
        (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356",      (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353", 
        (char *)"\345\371\356",      (char *)"\345\371\356\344",      (char *)"\345\371\356\353",      (char *)"\345\371\356\371", 
        (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353",      (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353", 
        (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353",      (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356", 
        (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354",      (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356", 
        (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353",      (char *)"\353",      (char *)"\353\341", 
        (char *)"\353\353",      (char *)"\353\354",      (char *)"\353\356",      (char *)"\353\356\344", 
        (char *)"\353\371",      (char *)"\353\371\341",      (char *)"\353\371\341\353",      (char *)"\353\371\344", 
        (char *)"\353\371\353",      (char *)"\353\371\353\341",      (char *)"\353\371\353\353",      (char *)"\353\371\353\354", 
        (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344",      (char *)"\353\371\354",      (char *)"\353\371\354\353", 
        (char *)"\353\371\356",      (char *)"\353\371\356\344",      (char *)"\353\371\356\353",      (char *)"\354", 
        (char *)"\354\353",      (char *)"\354\353\371",      (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353", 
        (char *)"\354\353\371\344",      (char *)"\354\353\371\353",      (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353", 
        (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356",      (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354", 
        (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356",      (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353", 
        (char *)"\356",      (char *)"\356\341",      (char *)"\356\344",      (char *)"\356\353", 
        (char *)"\356\354",      (char *)"\356\371",      (char *)"\356\371\341",      (char *)"\356\371\341\353", 
        (char *)"\356\371\344",      (char *)"\356\371\353",      (char *)"\356\371\353\341",      (char *)"\356\371\353\353", 
        (char *)"\356\371\353\354",      (char *)"\356\371\353\356",      (char *)"\356\371\353\356\344",      (char *)"\356\371\354", 
        (char *)"\356\371\354\353",      (char *)"\356\371\356",      (char *)"\356\371\356\344",      (char *)"\356\371\356\353", 
        (char *)"\371",      (char *)"\371\341",      (char *)"\371\341\353",      (char *)"\371\344", 
        (char *)"\371\353",      (char *)"\371\353\341",      (char *)"\371\353\353",      (char *)"\371\353\354", 
        (char *)"\371\353\356",      (char *)"\371\353\356\344",      (char *)"\371\353\371",      (char *)"\371\353\371\341", 
        (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344",      (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341", 
        (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354",      (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344", 
        (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353",      (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344", 
        (char *)"\371\353\371\356\353",      (char *)"\371\354",      (char *)"\371\354\353",      (char *)"\371\354\353\371", 
        (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353",      (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353", 
        (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353",      (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356", 
        (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354",      (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356", 
        (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353",      (char *)"\371\356",      (char *)"\371\356\344", 
        (char *)"\371\356\353",      (char *)"\371\356\371",      (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353", 
        (char *)"\371\356\371\344",      (char *)"\371\356\371\353",      (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353", 
        (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356",      (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354", 
        (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356",      (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353", 
        (char *)0};
#line 852 "/home/wslee/benchmarks/textformat/hspell-1.0/prefixes.c"
static int masks_H___1[361]  = 
#line 852
  {      60,      43,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      32,      42, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      60, 
        43,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        -1};
#line 93 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static struct prefix_node *prefix_tree___1  =    (struct prefix_node *)0;
#line 95 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static void build_prefix_tree___1(int allow_he_hasheela ) 
{ 
  int i ;
  char const   *p ;
  struct prefix_node **n ;
  char **prefixes ;
  int *masks ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 102
  if (allow_he_hasheela) {
#line 103
    prefixes = prefixes_H___1;
#line 104
    masks = masks_H___1;
  } else {
#line 106
    prefixes = prefixes_noH___1;
#line 107
    masks = masks_noH___1;
  }
#line 110
  i = 0;
  {
  {
#line 110
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if (! *(prefixes + i)) {
#line 110
      goto while_break;
    }
#line 111
    p = (char const   *)*(prefixes + i);
#line 112
    n = & prefix_tree___1;
#line 113
    if (hspell_debug) {
      {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prefix %s ",
              p);
      }
      }
    }
    {
    {
#line 115
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! *p) {
#line 115
        goto while_break___0;
      }
#line 116
      if (! *n) {
        {
        {
#line 117
        tmp = calloc((size_t )1, (size_t )sizeof(struct prefix_node ));
        }
#line 117
        *n = (struct prefix_node *)tmp;
        }
      }
#line 119
      n = & (*n)->next[(int const   )*p - -32];
#line 120
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if (! *n) {
      {
      {
#line 124
      tmp___0 = calloc((size_t )1, (size_t )sizeof(struct prefix_node ));
      }
#line 124
      *n = (struct prefix_node *)tmp___0;
      }
    }
#line 126
    (*n)->mask = *(masks + i);
#line 128
    if (hspell_debug) {
      {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mask=%d\n",
              (*n)->mask);
      }
      }
    }
#line 110
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static void free_prefix_tree___1(struct prefix_node *n ) 
{ 
  int i ;

  {
#line 138
  if (! n) {
#line 139
    return;
  }
#line 140
  i = 0;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )i < sizeof(n->next) / sizeof(n->next[0]))) {
#line 140
      goto while_break;
    }
    {
    {
#line 141
    free_prefix_tree___1(n->next[i]);
    }
#line 140
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 142
  free((void *)n);
  }
  }
#line 143
  return;
}
}
#line 371 "/home/wslee/benchmarks/textformat/hspell-1.0/libhspell.c"
static char *similar___1[9]  = 
#line 371
  {      (char *)"\344\362\340",      (char *)"\342\344",      (char *)"\353\347",      (char *)"\372\350", 
        (char *)"\366\361",      (char *)"\371\361",      (char *)"\353\367",      (char *)"\341\345", 
        (char *)"\364\341"};
#line 30 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static void load_personal_dict___0(hspell_hash *personaldict , int *currentdir_dictfile ) 
{ 
  int i ;
  char buf[512] ;
  FILE *fp ;
  char *home ;
  char *tmp ;
  int l ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 34
  hspell_hash_init(personaldict);
  }
  }
#line 35
  if (currentdir_dictfile) {
#line 36
    *currentdir_dictfile = 0;
  }
#line 37
  i = 0;
  {
  {
#line 37
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i <= 1)) {
#line 37
      goto while_break;
    }
#line 40
    if (i == 0) {
      {
      {
#line 41
      tmp = getenv("HOME");
      }
#line 41
      home = tmp;
      }
#line 42
      if (! home) {
#line 42
        goto __Cont;
      }
      {
      {
#line 43
      snprintf((char */* __restrict  */)(buf), (size_t )sizeof(buf), (char const   */* __restrict  */)"%s/.hspell_words",
               home);
      }
      }
    } else {
      {
      {
#line 46
      snprintf((char */* __restrict  */)(buf), (size_t )sizeof(buf), (char const   */* __restrict  */)"./hspell_words");
      }
      }
    }
    {
    {
#line 47
    fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
    }
    }
#line 48
    if (! fp) {
#line 48
      goto __Cont;
    }
#line 49
    if (i == 1) {
#line 49
      if (currentdir_dictfile) {
#line 50
        *currentdir_dictfile = 1;
      }
    }
    {
    {
#line 51
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 51
      tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
      }
#line 51
      if (! tmp___1) {
#line 51
        goto while_break___0;
      }
      {
      {
#line 52
      tmp___0 = strlen((char const   *)(buf));
      }
#line 52
      l = (int )tmp___0;
      }
#line 53
      if ((int )buf[l - 1] == 10) {
#line 54
        buf[l - 1] = (char )'\000';
      }
#line 55
      if ((int )buf[0] != 35) {
#line 55
        if ((int )buf[0] != 0) {
          {
          {
#line 56
          hspell_hash_incr_int(personaldict, (char const   *)(buf));
          }
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 58
    fclose(fp);
    }
    }
    __Cont: /* CIL Label */ 
#line 37
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 68 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int save_personal_dict___0(hspell_hash *personaldict , hspell_hash *personaldict_new_words ,
                                  int currentdir_dictfile ) 
{ 
  FILE *fp ;
  hspell_hash_keyvalue *new_words_array ;
  int new_words_number ;
  int i ;
  char dict_filename[512] ;
  char *home ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 78
  tmp = getenv("HOME");
  }
#line 78
  home = tmp;
  }
#line 79
  if (currentdir_dictfile) {
    {
    {
#line 80
    snprintf((char */* __restrict  */)(dict_filename), (size_t )sizeof(dict_filename),
             (char const   */* __restrict  */)"./hspell_words");
    }
    }
  } else
#line 79
  if (! home) {
    {
    {
#line 80
    snprintf((char */* __restrict  */)(dict_filename), (size_t )sizeof(dict_filename),
             (char const   */* __restrict  */)"./hspell_words");
    }
    }
  } else {
    {
    {
#line 83
    snprintf((char */* __restrict  */)(dict_filename), (size_t )sizeof(dict_filename),
             (char const   */* __restrict  */)"%s/.hspell_words", home);
    }
    }
  }
  {
  {
#line 86
  fp = fopen((char const   */* __restrict  */)(dict_filename), (char const   */* __restrict  */)"a");
  }
  }
#line 87
  if (! fp) {
#line 88
    return (0);
  }
  {
  {
#line 105
  new_words_array = hspell_hash_build_keyvalue_array(personaldict_new_words, & new_words_number);
  }
  }
#line 107
  if (hspell_debug) {
    {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Saving %d words to %s\n",
            new_words_number, dict_filename);
    }
    }
  }
#line 111
  i = 0;
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < new_words_number)) {
#line 111
      goto while_break;
    }
    {
    {
#line 112
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            (new_words_array + i)->key);
    }
    {
#line 113
    hspell_hash_incr_int(personaldict, (new_words_array + i)->key);
    }
#line 111
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 115
  hspell_hash_free_keyvalue_array(personaldict_new_words, new_words_number, new_words_array);
  }
  {
#line 118
  hspell_hash_destroy(personaldict_new_words);
  }
  {
#line 119
  hspell_hash_init(personaldict_new_words);
  }
  {
#line 121
  tmp___0 = fclose(fp);
  }
  }
#line 121
  return (tmp___0 == 0);
}
}
#line 181 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int compare_key___0(void const   *a , void const   *b ) 
{ 
  register hspell_hash_keyvalue *aa ;
  register hspell_hash_keyvalue *bb ;
  int tmp ;

  {
  {
#line 183
  aa = (hspell_hash_keyvalue *)a;
#line 184
  bb = (hspell_hash_keyvalue *)b;
  {
#line 185
  tmp = strcmp(aa->key, bb->key);
  }
  }
#line 185
  return (tmp);
}
}
#line 187 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int compare_value_reverse___0(void const   *a , void const   *b ) 
{ 
  register hspell_hash_keyvalue *aa ;
  register hspell_hash_keyvalue *bb ;

  {
#line 189
  aa = (hspell_hash_keyvalue *)a;
#line 190
  bb = (hspell_hash_keyvalue *)b;
#line 191
  if (aa->value < bb->value) {
#line 192
    return (1);
  } else
#line 193
  if (aa->value > bb->value) {
#line 194
    return (-1);
  } else {
#line 195
    return (0);
  }
}
}
#line 198 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static FILE *next_file___0(int *argcp , char ***argvp ) 
{ 
  FILE *ret ;
  char *__cil_tmp4 ;

  {
#line 201
  ret = (FILE *)0;
#line 202
  if (*argcp <= 0) {
#line 203
    return ((FILE *)0);
  }
  {
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 204
    if (*argcp) {
#line 204
      if (! (! ret)) {
#line 204
        goto while_break;
      }
    } else {
#line 204
      goto while_break;
    }
    {
    {
#line 205
    ret = fopen((char const   */* __restrict  */)*(*argvp + 0), (char const   */* __restrict  */)"r");
    }
    }
#line 206
    if (! ret) {
      {
      {
#line 207
      perror((char const   *)*(*argvp + 0));
      }
      }
    }
#line 208
    (*argvp) ++;
#line 209
    (*argcp) --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (ret);
}
}
#line 231 "/home/wslee/benchmarks/textformat/hspell-1.0/hspell.c"
static int uglyuglyflag___0  =    0;
