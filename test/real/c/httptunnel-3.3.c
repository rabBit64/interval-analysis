/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 105 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 11 "http.h"
enum __anonenum_Http_method_18 {
    HTTP_GET = 0,
    HTTP_PUT = 1,
    HTTP_POST = 2,
    HTTP_OPTIONS = 3,
    HTTP_HEAD = 4,
    HTTP_DELETE = 5,
    HTTP_TRACE = 6
} ;
#line 11 "http.h"
typedef enum __anonenum_Http_method_18 Http_method;
#line 22
struct http_header;
#line 22 "http.h"
typedef struct http_header Http_header;
#line 23 "http.h"
struct http_header {
   char const   *name ;
   char const   *value ;
   Http_header *next ;
};
#line 30 "http.h"
struct __anonstruct_Http_request_19 {
   Http_method method ;
   char const   *uri ;
   int major_version ;
   int minor_version ;
   Http_header *header ;
};
#line 30 "http.h"
typedef struct __anonstruct_Http_request_19 Http_request;
#line 39 "http.h"
struct __anonstruct_Http_response_20 {
   int major_version ;
   int minor_version ;
   int status_code ;
   char const   *status_message ;
   Http_header *header ;
};
#line 39 "http.h"
typedef struct __anonstruct_Http_response_20 Http_response;
#line 48 "http.h"
struct __anonstruct_Http_destination_21 {
   char const   *host_name ;
   int host_port ;
   char const   *proxy_name ;
   int proxy_port ;
   char const   *proxy_authorization ;
   char const   *user_agent ;
};
#line 48 "http.h"
typedef struct __anonstruct_Http_destination_21 Http_destination;
#line 194 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 309 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 321 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 30 "/usr/include/sys/poll.h"
typedef unsigned long nfds_t;
#line 33 "/usr/include/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 68 "tunnel.h"
struct tunnel;
#line 68 "tunnel.h"
typedef struct tunnel Tunnel;
#line 34 "tunnel.c"
typedef unsigned char Request;
#line 40 "tunnel.c"
typedef unsigned short Length;
#line 45
enum tunnel_request {
    TUNNEL_SIMPLE = 64,
    TUNNEL_OPEN = 1,
    TUNNEL_DATA = 2,
    TUNNEL_PADDING = 3,
    TUNNEL_ERROR = 4,
    TUNNEL_PAD1 = 69,
    TUNNEL_CLOSE = 70,
    TUNNEL_DISCONNECT = 71
} ;
#line 73 "tunnel.c"
struct tunnel {
   int in_fd ;
   int out_fd ;
   int server_socket ;
   Http_destination dest ;
   struct sockaddr_in address ;
   size_t bytes ;
   size_t content_length ;
   char buf[65536] ;
   char *buf_ptr ;
   size_t buf_len ;
   int padding_only ;
   size_t in_total_raw ;
   size_t in_total_data ;
   size_t out_total_raw ;
   size_t out_total_data ;
   time_t out_connect_time ;
   int strict_content_length ;
   int keep_alive ;
   int max_connection_age ;
};
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 83 "port/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 73 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 24 "htc.c"
struct __anonstruct_Arguments_47 {
   char *me ;
   char *device ;
   char *host_name ;
   int host_port ;
   char *proxy_name ;
   int proxy_port ;
   size_t proxy_buffer_size ;
   int proxy_buffer_timeout ;
   size_t content_length ;
   int forward_port ;
   int use_std ;
   int use_daemon ;
   int strict_content_length ;
   int keep_alive ;
   int max_connection_age ;
   char *proxy_authorization ;
   char *user_agent ;
};
#line 24 "htc.c"
typedef struct __anonstruct_Arguments_47 Arguments;
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 336
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 344
extern int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 16 "stdio_.h"
int vsmprintf(char **s , char const   *format , va_list ap ) ;
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 18 "vsnprintf.c"
int vsmprintf(char **s , char const   *format , va_list ap ) 
{ 
  size_t n ;
  FILE *f ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 24
  f = fopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w");
  }
#line 25
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 26
    return (-1);
  }
  {
#line 28
  tmp = vfprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)format,
                 ap);
#line 28
  n = (size_t )tmp;
#line 29
  fclose(f);
#line 31
  tmp___0 = malloc(n + 1U);
#line 31
  *s = (char *)tmp___0;
  }
#line 32
  if ((unsigned long )*s == (unsigned long )((void *)0)) {
#line 33
    return (-1);
  }
  {
#line 35
  tmp___1 = vsprintf((char */* __restrict  */)*s, (char const   */* __restrict  */)format,
                     ap);
  }
#line 35
  return (tmp___1);
}
}
#line 8 "base64.h"
ssize_t encode_base64(void const   *data , size_t length , char **code ) ;
#line 13 "base64.c"
static int encode[64]  = 
#line 13 "base64.c"
  {      'A',      'B',      'C',      'D', 
        'E',      'F',      'G',      'H', 
        'I',      'J',      'K',      'L', 
        'M',      'N',      'O',      'P', 
        'Q',      'R',      'S',      'T', 
        'U',      'V',      'W',      'X', 
        'Y',      'Z',      'a',      'b', 
        'c',      'd',      'e',      'f', 
        'g',      'h',      'i',      'j', 
        'k',      'l',      'm',      'n', 
        'o',      'p',      'q',      'r', 
        's',      't',      'u',      'v', 
        'w',      'x',      'y',      'z', 
        '0',      '1',      '2',      '3', 
        '4',      '5',      '6',      '7', 
        '8',      '9',      '+',      '/'};
#line 32 "base64.c"
ssize_t encode_base64(void const   *data , size_t length , char **code ) 
{ 
  unsigned char const   *s ;
  unsigned char const   *end ;
  unsigned char *buf ;
  unsigned int x ;
  ssize_t n ;
  int i ;
  int j ;
  void *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;

  {
#line 41
  if (length == 0U) {
#line 42
    return (0);
  }
  {
#line 44
  end = (unsigned char const   *)(((char *)data + length) - 3);
#line 46
  tmp = malloc(4U * ((length + 2U) / 3U) + 1U);
#line 46
  buf = (unsigned char *)tmp;
  }
#line 47
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 48
    return (-1);
  }
#line 50
  n = 0;
#line 52
  s = (unsigned char const   *)data;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((unsigned long )s < (unsigned long )end)) {
#line 52
      goto while_break;
    }
#line 54
    tmp___0 = s;
#line 54
    s ++;
#line 54
    x = (unsigned int )((int const   )*tmp___0 << 24);
#line 55
    tmp___1 = s;
#line 55
    s ++;
#line 55
    x |= (unsigned int )((int const   )*tmp___1 << 16);
#line 56
    tmp___2 = s;
#line 56
    s ++;
#line 56
    x |= (unsigned int )((int const   )*tmp___2 << 8);
#line 58
    tmp___3 = buf;
#line 58
    buf ++;
#line 58
    *tmp___3 = (unsigned char )encode[x >> 26];
#line 59
    x <<= 6;
#line 60
    tmp___4 = buf;
#line 60
    buf ++;
#line 60
    *tmp___4 = (unsigned char )encode[x >> 26];
#line 61
    x <<= 6;
#line 62
    tmp___5 = buf;
#line 62
    buf ++;
#line 62
    *tmp___5 = (unsigned char )encode[x >> 26];
#line 63
    x <<= 6;
#line 64
    tmp___6 = buf;
#line 64
    buf ++;
#line 64
    *tmp___6 = (unsigned char )encode[x >> 26];
#line 65
    n += 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  end += 3;
#line 70
  x = 0U;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! ((unsigned long )s < (unsigned long )end)) {
#line 71
      goto while_break___0;
    }
#line 72
    tmp___7 = s;
#line 72
    s ++;
#line 72
    x |= (unsigned int )((int const   )*tmp___7 << (24 - 8 * i));
#line 71
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 74
  j = 0;
  {
#line 74
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 74
    if (! (j < 4)) {
#line 74
      goto while_break___1;
    }
#line 76
    if (8 * i >= 6 * j) {
#line 78
      tmp___8 = buf;
#line 78
      buf ++;
#line 78
      *tmp___8 = (unsigned char )encode[x >> 26];
#line 79
      x <<= 6;
#line 80
      n ++;
    } else {
#line 84
      tmp___9 = buf;
#line 84
      buf ++;
#line 84
      *tmp___9 = (unsigned char )'=';
#line 85
      n ++;
    }
#line 74
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 89
  *buf = (unsigned char)0;
#line 91
  *code = (char *)(buf - n);
#line 92
  return (n);
}
}
#line 184 "/usr/include/time.h"
extern time_t time(time_t *__timer ) ;
#line 329 "/usr/include/stdio.h"
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 567
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 569
extern void free(void *__ptr ) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 42
extern void *memmove(void *__dest , void const   *__src , size_t __n ) ;
#line 61
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 96
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 126
extern char *strdup(char const   *__s )  __attribute__((__malloc__)) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 243
extern char *strerror(int __errnum ) ;
#line 58 "http.h"
ssize_t http_get(int fd , Http_destination *dest ) ;
#line 59
ssize_t http_put(int fd , Http_destination *dest , size_t length ) ;
#line 61
ssize_t http_post(int fd , Http_destination *dest , size_t length ) ;
#line 63
int http_error_to_errno(int err ) ;
#line 65
Http_response *http_create_response(int major_version , int minor_version , int status_code ,
                                    char const   *status_message ) ;
#line 69
ssize_t http_parse_response(int fd , Http_response **response_ ) ;
#line 70
void http_destroy_response(Http_response *response ) ;
#line 72
Http_header *http_add_header(Http_header **header , char const   *name , char const   *value ) ;
#line 76
Http_request *http_create_request(Http_method method , char const   *uri , int major_version ,
                                  int minor_version ) ;
#line 80
ssize_t http_parse_request(int fd , Http_request **request_ ) ;
#line 81
ssize_t http_write_request(int fd , Http_request *request ) ;
#line 82
void http_destroy_request(Http_request *request ) ;
#line 84
char const   *http_header_get(Http_header *header , char const   *name ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 63 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 312 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 318
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 46 "common.h"
void log_error(char *fmt0  , ...) ;
#line 53 "common.h"
__inline static void log_verbose(void) 
{ 


  {
#line 53
  return;
}
}
#line 68 "common.h"
__inline static ssize_t read_all(int fd , void *buf , size_t len ) 
{ 
  ssize_t n ;
  ssize_t m ;
  ssize_t r ;
  long flags ;
  char *rbuf ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 73
  rbuf = (char *)buf;
#line 75
  tmp = fcntl(fd, 3);
#line 75
  flags = (long )tmp;
#line 76
  fcntl(fd, 4, flags & -2049L);
#line 78
  r = (ssize_t )len;
#line 79
  n = 0;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((size_t )n < len)) {
#line 79
      goto while_break;
    }
    {
#line 81
    log_verbose("read (%d, %p, %d) ...", fd, rbuf + n, len - (size_t )n);
#line 82
    m = read(fd, (void *)(rbuf + n), len - (size_t )n);
#line 83
    log_verbose("... = %d", m);
    }
#line 84
    if (m == 0) {
#line 86
      r = 0;
#line 87
      goto while_break;
    } else
#line 89
    if (m == -1) {
      {
#line 91
      tmp___0 = __errno_location();
      }
#line 91
      if (*tmp___0 != 11) {
#line 93
        r = -1;
#line 94
        goto while_break;
      } else {
#line 97
        m = 0;
      }
    }
#line 79
    n += m;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 101
  fcntl(fd, 4, flags);
  }
#line 102
  return (r);
}
}
#line 105 "common.h"
__inline static ssize_t write_all(int fd , void *data , size_t len ) 
{ 
  ssize_t n ;
  ssize_t m ;
  char *wdata ;
  int *tmp ;

  {
#line 109
  wdata = (char *)data;
#line 111
  n = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((size_t )n < len)) {
#line 111
      goto while_break;
    }
    {
#line 113
    log_verbose("write (%d, %p, %d) ...", fd, wdata + n, len - (size_t )n);
#line 114
    m = write(fd, (void const   *)(wdata + n), len - (size_t )n);
#line 115
    log_verbose("... = %d", m);
    }
#line 116
    if (m == 0) {
#line 117
      return (0);
    } else
#line 118
    if (m == -1) {
      {
#line 120
      tmp = __errno_location();
      }
#line 120
      if (*tmp != 11) {
#line 121
        return (-1);
      } else {
#line 123
        m = 0;
      }
    }
#line 111
    n += m;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((ssize_t )len);
}
}
#line 17 "http.c"
__inline static ssize_t http_method(int fd , Http_destination *dest , Http_method method ,
                                    ssize_t length ) 
{ 
  char str[1024] ;
  Http_request *request ;
  ssize_t n ;
  time_t tmp ;

  {
#line 25
  if (fd == -1) {
    {
#line 27
    log_error((char *)"http_method: fd == -1");
    }
#line 28
    return (-1);
  }
#line 31
  n = 0;
#line 32
  if ((unsigned long )dest->proxy_name != (unsigned long )((void *)0)) {
    {
#line 33
    n = sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"http://%s:%d",
                dest->host_name, dest->host_port);
    }
  }
  {
#line 34
  tmp = time((time_t *)((void *)0));
#line 34
  sprintf((char */* __restrict  */)(str + n), (char const   */* __restrict  */)"/index.html?crap=%ld",
          tmp);
#line 36
  request = http_create_request(method, (char const   *)(str), 1, 1);
  }
#line 37
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 38
    return (-1);
  }
  {
#line 40
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%s:%d",
          dest->host_name, dest->host_port);
#line 41
  http_add_header(& request->header, "Host", (char const   *)(str));
  }
#line 43
  if (length >= 0) {
    {
#line 45
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%d",
            length);
#line 46
    http_add_header(& request->header, "Content-Length", (char const   *)(str));
    }
  }
  {
#line 49
  http_add_header(& request->header, "Connection", "close");
  }
#line 51
  if (dest->proxy_authorization) {
    {
#line 53
    http_add_header(& request->header, "Proxy-Authorization", dest->proxy_authorization);
    }
  }
#line 58
  if (dest->user_agent) {
    {
#line 60
    http_add_header(& request->header, "User-Agent", dest->user_agent);
    }
  }
  {
#line 65
  n = http_write_request(fd, request);
#line 66
  http_destroy_request(request);
  }
#line 67
  return (n);
}
}
#line 70 "http.c"
ssize_t http_get(int fd , Http_destination *dest ) 
{ 
  ssize_t tmp ;

  {
  {
#line 73
  tmp = http_method(fd, dest, (Http_method )0, -1);
  }
#line 73
  return (tmp);
}
}
#line 76 "http.c"
ssize_t http_put(int fd , Http_destination *dest , size_t length ) 
{ 
  ssize_t tmp ;

  {
  {
#line 79
  tmp = http_method(fd, dest, (Http_method )1, (ssize_t )length);
  }
#line 79
  return (tmp);
}
}
#line 82 "http.c"
ssize_t http_post(int fd , Http_destination *dest , size_t length ) 
{ 
  ssize_t tmp ;

  {
  {
#line 85
  tmp = http_method(fd, dest, (Http_method )2, (ssize_t )length);
  }
#line 85
  return (tmp);
}
}
#line 88 "http.c"
int http_error_to_errno(int err ) 
{ 
  int *tmp ;

  {
  {
#line 94
  if (err == -1) {
#line 94
    goto case_neg_1;
  }
#line 102
  if (err == -206) {
#line 102
    goto case_neg_206;
  }
#line 102
  if (err == -205) {
#line 102
    goto case_neg_206;
  }
#line 102
  if (err == -204) {
#line 102
    goto case_neg_206;
  }
#line 102
  if (err == -203) {
#line 102
    goto case_neg_206;
  }
#line 102
  if (err == -202) {
#line 102
    goto case_neg_206;
  }
#line 102
  if (err == -201) {
#line 102
    goto case_neg_206;
  }
#line 102
  if (err == -200) {
#line 102
    goto case_neg_206;
  }
#line 104
  if (err == -400) {
#line 104
    goto case_neg_400;
  }
#line 107
  if (err == -401) {
#line 107
    goto case_neg_401;
  }
#line 110
  if (err == -403) {
#line 110
    goto case_neg_403;
  }
#line 113
  if (err == -404) {
#line 113
    goto case_neg_404;
  }
#line 116
  if (err == -411) {
#line 116
    goto case_neg_411;
  }
#line 119
  if (err == -413) {
#line 119
    goto case_neg_413;
  }
#line 122
  if (err == -505) {
#line 122
    goto case_neg_505;
  }
#line 147
  if (err == -504) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -503) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -502) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -501) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -500) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -415) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -414) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -412) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -410) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -409) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -408) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -407) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -406) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -405) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -402) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -305) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -304) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -303) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -302) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -301) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -300) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -101) {
#line 147
    goto case_neg_504;
  }
#line 147
  if (err == -100) {
#line 147
    goto case_neg_504;
  }
#line 150
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 95
  tmp = __errno_location();
  }
#line 95
  return (*tmp);
  case_neg_206: /* CIL Label */ 
  case_neg_205: /* CIL Label */ 
  case_neg_204: /* CIL Label */ 
  case_neg_203: /* CIL Label */ 
  case_neg_202: /* CIL Label */ 
  case_neg_201: /* CIL Label */ 
  case_neg_200: /* CIL Label */ 
#line 103
  return (0);
  case_neg_400: /* CIL Label */ 
  {
#line 105
  log_error((char *)"http_error_to_errno: 400 bad request");
  }
#line 106
  return (5);
  case_neg_401: /* CIL Label */ 
  {
#line 108
  log_error((char *)"http_error_to_errno: 401 unauthorized");
  }
#line 109
  return (13);
  case_neg_403: /* CIL Label */ 
  {
#line 111
  log_error((char *)"http_error_to_errno: 403 forbidden");
  }
#line 112
  return (13);
  case_neg_404: /* CIL Label */ 
  {
#line 114
  log_error((char *)"http_error_to_errno: 404 not found");
  }
#line 115
  return (2);
  case_neg_411: /* CIL Label */ 
  {
#line 117
  log_error((char *)"http_error_to_errno: 411 length required");
  }
#line 118
  return (5);
  case_neg_413: /* CIL Label */ 
  {
#line 120
  log_error((char *)"http_error_to_errno: 413 request entity too large");
  }
#line 121
  return (5);
  case_neg_505: /* CIL Label */ 
  {
#line 123
  log_error((char *)"http_error_to_errno: 413 HTTP version not supported");
  }
#line 124
  return (5);
  case_neg_504: /* CIL Label */ 
  case_neg_503: /* CIL Label */ 
  case_neg_502: /* CIL Label */ 
  case_neg_501: /* CIL Label */ 
  case_neg_500: /* CIL Label */ 
  case_neg_415: /* CIL Label */ 
  case_neg_414: /* CIL Label */ 
  case_neg_412: /* CIL Label */ 
  case_neg_410: /* CIL Label */ 
  case_neg_409: /* CIL Label */ 
  case_neg_408: /* CIL Label */ 
  case_neg_407: /* CIL Label */ 
  case_neg_406: /* CIL Label */ 
  case_neg_405: /* CIL Label */ 
  case_neg_402: /* CIL Label */ 
  case_neg_305: /* CIL Label */ 
  case_neg_304: /* CIL Label */ 
  case_neg_303: /* CIL Label */ 
  case_neg_302: /* CIL Label */ 
  case_neg_301: /* CIL Label */ 
  case_neg_300: /* CIL Label */ 
  case_neg_101: /* CIL Label */ 
  case_neg_100: /* CIL Label */ 
  {
#line 148
  log_error((char *)"http_error_to_errno: HTTP error %d", err);
  }
#line 149
  return (5);
  switch_default: /* CIL Label */ 
  {
#line 151
  log_error((char *)"http_error_to_errno: unknown error %d", err);
  }
#line 152
  return (5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 156 "http.c"
static Http_method http_string_to_method(char const   *method , size_t n ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 159
  tmp = strncmp(method, "GET", n);
  }
#line 159
  if (tmp == 0) {
#line 160
    return ((Http_method )0);
  }
  {
#line 161
  tmp___0 = strncmp(method, "PUT", n);
  }
#line 161
  if (tmp___0 == 0) {
#line 162
    return ((Http_method )1);
  }
  {
#line 163
  tmp___1 = strncmp(method, "POST", n);
  }
#line 163
  if (tmp___1 == 0) {
#line 164
    return ((Http_method )2);
  }
  {
#line 165
  tmp___2 = strncmp(method, "OPTIONS", n);
  }
#line 165
  if (tmp___2 == 0) {
#line 166
    return ((Http_method )3);
  }
  {
#line 167
  tmp___3 = strncmp(method, "HEAD", n);
  }
#line 167
  if (tmp___3 == 0) {
#line 168
    return ((Http_method )4);
  }
  {
#line 169
  tmp___4 = strncmp(method, "DELETE", n);
  }
#line 169
  if (tmp___4 == 0) {
#line 170
    return ((Http_method )5);
  }
  {
#line 171
  tmp___5 = strncmp(method, "TRACE", n);
  }
#line 171
  if (tmp___5 == 0) {
#line 172
    return ((Http_method )6);
  }
#line 173
  return ((Http_method )-1);
}
}
#line 176 "http.c"
static char const   *http_method_to_string(Http_method method ) 
{ 


  {
  {
#line 181
  if ((unsigned int )method == 0U) {
#line 181
    goto case_0;
  }
#line 182
  if ((unsigned int )method == 1U) {
#line 182
    goto case_1;
  }
#line 183
  if ((unsigned int )method == 2U) {
#line 183
    goto case_2;
  }
#line 184
  if ((unsigned int )method == 3U) {
#line 184
    goto case_3;
  }
#line 185
  if ((unsigned int )method == 4U) {
#line 185
    goto case_4;
  }
#line 186
  if ((unsigned int )method == 5U) {
#line 186
    goto case_5;
  }
#line 187
  if ((unsigned int )method == 6U) {
#line 187
    goto case_6;
  }
#line 179
  goto switch_break;
  case_0: /* CIL Label */ 
#line 181
  return ("GET");
  case_1: /* CIL Label */ 
#line 182
  return ("PUT");
  case_2: /* CIL Label */ 
#line 183
  return ("POST");
  case_3: /* CIL Label */ 
#line 184
  return ("OPTIONS");
  case_4: /* CIL Label */ 
#line 185
  return ("HEAD");
  case_5: /* CIL Label */ 
#line 186
  return ("DELETE");
  case_6: /* CIL Label */ 
#line 187
  return ("TRACE");
  switch_break: /* CIL Label */ ;
  }
#line 189
  return ("(uknown)");
}
}
#line 192 "http.c"
static ssize_t read_until(int fd , int ch , unsigned char **data ) 
{ 
  unsigned char *buf ;
  unsigned char *buf2 ;
  ssize_t n ;
  ssize_t len ;
  ssize_t buf_size ;
  void *tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 198
  *data = (unsigned char *)((void *)0);
#line 200
  buf_size = 100;
#line 201
  tmp = malloc((size_t )buf_size);
#line 201
  buf = (unsigned char *)tmp;
  }
#line 202
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 204
    log_error((char *)"read_until: out of memory");
    }
#line 205
    return (-1);
  }
#line 208
  len = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    n = read_all(fd, (void *)(buf + len), (size_t )1);
    }
#line 209
    if (! (n == 1)) {
#line 209
      goto while_break;
    }
#line 211
    tmp___0 = len;
#line 211
    len ++;
#line 211
    if ((int )*(buf + tmp___0) == ch) {
#line 212
      goto while_break;
    }
#line 213
    if (len + 1 == buf_size) {
      {
#line 215
      buf_size *= 2;
#line 216
      tmp___1 = realloc((void *)buf, (size_t )buf_size);
#line 216
      buf2 = (unsigned char *)tmp___1;
      }
#line 217
      if ((unsigned long )buf2 == (unsigned long )((void *)0)) {
        {
#line 219
        log_error((char *)"read_until: realloc failed");
#line 220
        free((void *)buf);
        }
#line 221
        return (-1);
      }
#line 223
      buf = buf2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if (n <= 0) {
    {
#line 228
    free((void *)buf);
    }
#line 229
    if (n == 0) {
      {
#line 230
      log_error((char *)"read_until: closed");
      }
    } else {
      {
#line 232
      tmp___2 = __errno_location();
#line 232
      tmp___3 = strerror(*tmp___2);
#line 232
      log_error((char *)"read_until: read error: %s", tmp___3);
      }
    }
#line 233
    return (n);
  }
  {
#line 237
  tmp___4 = realloc((void *)buf, (size_t )(len + 1));
#line 237
  buf2 = (unsigned char *)tmp___4;
  }
#line 238
  if ((unsigned long )buf2 == (unsigned long )((void *)0)) {
    {
#line 239
    log_error((char *)"read_until: realloc: shrink failed");
    }
  } else {
#line 241
    buf = buf2;
  }
#line 243
  *data = buf;
#line 244
  return (len);
}
}
#line 247 "http.c"
__inline static Http_header *http_alloc_header(char const   *name , char const   *value ) 
{ 
  Http_header *header ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 252
  tmp = malloc((size_t )sizeof(Http_header ));
#line 252
  header = (Http_header *)tmp;
  }
#line 253
  if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 254
    return ((Http_header *)((void *)0));
  }
  {
#line 256
  tmp___0 = (char const   *)((void *)0);
#line 256
  header->value = tmp___0;
#line 256
  header->name = tmp___0;
#line 257
  tmp___1 = strdup(name);
#line 257
  header->name = (char const   *)tmp___1;
#line 258
  tmp___2 = strdup(value);
#line 258
  header->value = (char const   *)tmp___2;
  }
#line 259
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 259
    goto _L;
  } else
#line 259
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 261
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 262
      free((void *)((char *)name));
      }
    }
#line 263
    if ((unsigned long )value == (unsigned long )((void *)0)) {
      {
#line 264
      free((void *)((char *)value));
      }
    }
    {
#line 265
    free((void *)header);
    }
#line 266
    return ((Http_header *)((void *)0));
  }
#line 269
  return (header);
}
}
#line 272 "http.c"
Http_header *http_add_header(Http_header **header , char const   *name , char const   *value ) 
{ 
  Http_header *new_header ;

  {
  {
#line 277
  new_header = http_alloc_header(name, value);
  }
#line 278
  if ((unsigned long )new_header == (unsigned long )((void *)0)) {
#line 279
    return ((Http_header *)((void *)0));
  }
#line 281
  new_header->next = (Http_header *)((void *)0);
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! *header) {
#line 282
      goto while_break;
    }
#line 283
    header = & (*header)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  *header = new_header;
#line 286
  return (new_header);
}
}
#line 289 "http.c"
static ssize_t parse_header(int fd , Http_header **header ) 
{ 
  unsigned char buf[2] ;
  unsigned char *data ;
  Http_header *h ;
  size_t len ;
  ssize_t n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 298
  *header = (Http_header *)((void *)0);
#line 300
  n = read_all(fd, (void *)(buf), (size_t )2);
  }
#line 301
  if (n <= 0) {
#line 302
    return (n);
  }
#line 303
  if ((int )buf[0] == 13) {
#line 303
    if ((int )buf[1] == 10) {
#line 304
      return (n);
    }
  }
  {
#line 306
  tmp = malloc((size_t )sizeof(Http_header ));
#line 306
  h = (Http_header *)tmp;
  }
#line 307
  if ((unsigned long )h == (unsigned long )((void *)0)) {
    {
#line 309
    log_error((char *)"parse_header: malloc failed");
    }
#line 310
    return (-1);
  }
  {
#line 312
  *header = h;
#line 313
  h->name = (char const   *)((void *)0);
#line 314
  h->value = (char const   *)((void *)0);
#line 316
  n = read_until(fd, ':', & data);
  }
#line 317
  if (n <= 0) {
#line 318
    return (n);
  }
  {
#line 319
  tmp___0 = realloc((void *)data, (size_t )(n + 2));
#line 319
  data = (unsigned char *)tmp___0;
  }
#line 320
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 322
    log_error((char *)"parse_header: realloc failed");
    }
#line 323
    return (-1);
  }
  {
#line 325
  memmove((void *)(data + 2), (void const   *)data, (size_t )n);
#line 326
  memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)(buf), (size_t )2);
#line 327
  n += 2;
#line 328
  *(data + (n - 1)) = (unsigned char)0;
#line 329
  h->name = (char const   *)data;
#line 330
  len = (size_t )n;
#line 332
  n = read_until(fd, '\r', & data);
  }
#line 333
  if (n <= 0) {
#line 334
    return (n);
  }
  {
#line 335
  *(data + (n - 1)) = (unsigned char)0;
#line 336
  h->value = (char const   *)data;
#line 337
  len += (size_t )n;
#line 339
  n = read_until(fd, '\n', & data);
  }
#line 340
  if (n <= 0) {
#line 341
    return (n);
  }
  {
#line 342
  free((void *)data);
  }
#line 343
  if (n != 1) {
    {
#line 345
    log_error((char *)"parse_header: invalid line ending");
    }
#line 346
    return (-1);
  }
  {
#line 348
  len += (size_t )n;
#line 350
  log_verbose("parse_header: %s:%s", h->name, h->value);
#line 352
  n = parse_header(fd, & h->next);
  }
#line 353
  if (n <= 0) {
#line 354
    return (n);
  }
#line 355
  len += (size_t )n;
#line 357
  return ((ssize_t )len);
}
}
#line 360 "http.c"
static ssize_t http_write_header(int fd , Http_header *header ) 
{ 
  ssize_t n ;
  ssize_t m ;
  ssize_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 363
  n = 0;
#line 365
  if ((unsigned long )header == (unsigned long )((void *)0)) {
    {
#line 366
    tmp = write_all(fd, (void *)"\r\n", (size_t )2);
    }
#line 366
    return (tmp);
  }
  {
#line 368
  tmp___0 = strlen(header->name);
#line 368
  m = write_all(fd, (void *)header->name, tmp___0);
  }
#line 369
  if (m == -1) {
#line 371
    return (-1);
  }
  {
#line 373
  n += m;
#line 375
  m = write_all(fd, (void *)": ", (size_t )2);
  }
#line 376
  if (m == -1) {
#line 378
    return (-1);
  }
  {
#line 380
  n += m;
#line 382
  tmp___1 = strlen(header->value);
#line 382
  m = write_all(fd, (void *)header->value, tmp___1);
  }
#line 383
  if (m == -1) {
#line 385
    return (-1);
  }
  {
#line 387
  n += m;
#line 389
  m = write_all(fd, (void *)"\r\n", (size_t )2);
  }
#line 390
  if (m == -1) {
#line 392
    return (-1);
  }
  {
#line 394
  n += m;
#line 396
  m = http_write_header(fd, header->next);
  }
#line 397
  if (m == -1) {
#line 399
    return (-1);
  }
#line 401
  n += m;
#line 403
  return (n);
}
}
#line 406 "http.c"
static void http_destroy_header(Http_header *header ) 
{ 


  {
#line 409
  if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 410
    return;
  }
  {
#line 412
  http_destroy_header(header->next);
  }
#line 414
  if (header->name) {
    {
#line 415
    free((void *)((char *)header->name));
    }
  }
#line 416
  if (header->value) {
    {
#line 417
    free((void *)((char *)header->value));
    }
  }
  {
#line 418
  free((void *)header);
  }
#line 419
  return;
}
}
#line 421 "http.c"
__inline static Http_response *http_allocate_response(char const   *status_message ) 
{ 
  Http_response *response ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 426
  tmp = malloc((size_t )sizeof(Http_response ));
#line 426
  response = (Http_response *)tmp;
  }
#line 427
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 428
    return ((Http_response *)((void *)0));
  }
  {
#line 430
  tmp___0 = strdup(status_message);
#line 430
  response->status_message = (char const   *)tmp___0;
  }
#line 431
  if ((unsigned long )response->status_message == (unsigned long )((void *)0)) {
    {
#line 433
    free((void *)response);
    }
#line 434
    return ((Http_response *)((void *)0));
  }
#line 437
  return (response);
}
}
#line 440 "http.c"
Http_response *http_create_response(int major_version , int minor_version , int status_code ,
                                    char const   *status_message ) 
{ 
  Http_response *response ;

  {
  {
#line 448
  response = http_allocate_response(status_message);
  }
#line 449
  if ((unsigned long )response == (unsigned long )((void *)0)) {
#line 450
    return ((Http_response *)((void *)0));
  }
#line 452
  response->major_version = major_version;
#line 453
  response->minor_version = minor_version;
#line 454
  response->status_code = status_code;
#line 455
  response->header = (Http_header *)((void *)0);
#line 457
  return (response);
}
}
#line 460 "http.c"
ssize_t http_parse_response(int fd , Http_response **response_ ) 
{ 
  Http_response *response ;
  unsigned char *data ;
  size_t len ;
  ssize_t n ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 468
  *response_ = (Http_response *)((void *)0);
#line 470
  tmp = malloc((size_t )sizeof(Http_response ));
#line 470
  response = (Http_response *)tmp;
  }
#line 471
  if ((unsigned long )response == (unsigned long )((void *)0)) {
    {
#line 473
    log_error((char *)"http_parse_response: out of memory");
    }
#line 474
    return (-1);
  }
  {
#line 477
  response->major_version = -1;
#line 478
  response->minor_version = -1;
#line 479
  response->status_code = -1;
#line 480
  response->status_message = (char const   *)((void *)0);
#line 481
  response->header = (Http_header *)((void *)0);
#line 483
  n = read_until(fd, '/', & data);
  }
#line 484
  if (n <= 0) {
    {
#line 486
    free((void *)response);
    }
#line 487
    return (n);
  } else
#line 489
  if (n != 5) {
    {
#line 491
    log_error((char *)"http_parse_response: expected \"HTTP\"");
#line 492
    free((void *)data);
#line 493
    free((void *)response);
    }
#line 494
    return (-1);
  } else {
    {
#line 489
    tmp___0 = memcmp((void const   *)data, (void const   *)"HTTP", (size_t )4);
    }
#line 489
    if (tmp___0 != 0) {
      {
#line 491
      log_error((char *)"http_parse_response: expected \"HTTP\"");
#line 492
      free((void *)data);
#line 493
      free((void *)response);
      }
#line 494
      return (-1);
    }
  }
  {
#line 496
  free((void *)data);
#line 497
  len = (size_t )n;
#line 499
  n = read_until(fd, '.', & data);
  }
#line 500
  if (n <= 0) {
    {
#line 502
    free((void *)response);
    }
#line 503
    return (n);
  }
  {
#line 505
  *(data + (n - 1)) = (unsigned char)0;
#line 506
  response->major_version = atoi((char const   *)data);
#line 507
  log_verbose("http_parse_response: major version = %d", response->major_version);
#line 509
  free((void *)data);
#line 510
  len += (size_t )n;
#line 512
  n = read_until(fd, ' ', & data);
  }
#line 513
  if (n <= 0) {
    {
#line 515
    free((void *)response);
    }
#line 516
    return (n);
  }
  {
#line 518
  *(data + (n - 1)) = (unsigned char)0;
#line 519
  response->minor_version = atoi((char const   *)data);
#line 520
  log_verbose("http_parse_response: minor version = %d", response->minor_version);
#line 522
  free((void *)data);
#line 523
  len += (size_t )n;
#line 525
  n = read_until(fd, ' ', & data);
  }
#line 526
  if (n <= 0) {
    {
#line 528
    free((void *)response);
    }
#line 529
    return (n);
  }
  {
#line 531
  *(data + (n - 1)) = (unsigned char)0;
#line 532
  response->status_code = atoi((char const   *)data);
#line 533
  log_verbose("http_parse_response: status code = %d", response->status_code);
#line 535
  free((void *)data);
#line 536
  len += (size_t )n;
#line 538
  n = read_until(fd, '\r', & data);
  }
#line 539
  if (n <= 0) {
    {
#line 541
    free((void *)response);
    }
#line 542
    return (n);
  }
  {
#line 544
  *(data + (n - 1)) = (unsigned char)0;
#line 545
  response->status_message = (char const   *)data;
#line 546
  log_verbose("http_parse_response: status message = \"%s\"", response->status_message);
#line 548
  len += (size_t )n;
#line 550
  n = read_until(fd, '\n', & data);
  }
#line 551
  if (n <= 0) {
    {
#line 553
    http_destroy_response(response);
    }
#line 554
    return (n);
  }
  {
#line 556
  free((void *)data);
  }
#line 557
  if (n != 1) {
    {
#line 559
    log_error((char *)"http_parse_request: invalid line ending");
#line 560
    http_destroy_response(response);
    }
#line 561
    return (-1);
  }
  {
#line 563
  len += (size_t )n;
#line 565
  n = parse_header(fd, & response->header);
  }
#line 566
  if (n <= 0) {
    {
#line 568
    http_destroy_response(response);
    }
#line 569
    return (n);
  }
#line 571
  len += (size_t )n;
#line 573
  *response_ = response;
#line 574
  return ((ssize_t )len);
}
}
#line 577 "http.c"
void http_destroy_response(Http_response *response ) 
{ 


  {
#line 580
  if (response->status_message) {
    {
#line 581
    free((void *)((char *)response->status_message));
    }
  }
  {
#line 582
  http_destroy_header(response->header);
#line 583
  free((void *)response);
  }
#line 584
  return;
}
}
#line 586 "http.c"
__inline static Http_request *http_allocate_request(char const   *uri ) 
{ 
  Http_request *request ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 591
  tmp = malloc((size_t )sizeof(Http_request ));
#line 591
  request = (Http_request *)tmp;
  }
#line 592
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 593
    return ((Http_request *)((void *)0));
  }
  {
#line 595
  tmp___0 = strdup(uri);
#line 595
  request->uri = (char const   *)tmp___0;
  }
#line 596
  if ((unsigned long )request->uri == (unsigned long )((void *)0)) {
    {
#line 598
    free((void *)request);
    }
#line 599
    return ((Http_request *)((void *)0));
  }
#line 602
  return (request);
}
}
#line 605 "http.c"
Http_request *http_create_request(Http_method method , char const   *uri , int major_version ,
                                  int minor_version ) 
{ 
  Http_request *request ;

  {
  {
#line 613
  request = http_allocate_request(uri);
  }
#line 614
  if ((unsigned long )request == (unsigned long )((void *)0)) {
#line 615
    return ((Http_request *)((void *)0));
  }
#line 617
  request->method = method;
#line 618
  request->major_version = major_version;
#line 619
  request->minor_version = minor_version;
#line 620
  request->header = (Http_header *)((void *)0);
#line 622
  return (request);
}
}
#line 625 "http.c"
ssize_t http_parse_request(int fd , Http_request **request_ ) 
{ 
  Http_request *request ;
  unsigned char *data ;
  size_t len ;
  ssize_t n ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 633
  *request_ = (Http_request *)((void *)0);
#line 635
  tmp = malloc((size_t )sizeof(Http_request ));
#line 635
  request = (Http_request *)tmp;
  }
#line 636
  if ((unsigned long )request == (unsigned long )((void *)0)) {
    {
#line 638
    log_error((char *)"http_parse_request: out of memory");
    }
#line 639
    return (-1);
  }
  {
#line 642
  request->method = (Http_method )-1;
#line 643
  request->uri = (char const   *)((void *)0);
#line 644
  request->major_version = -1;
#line 645
  request->minor_version = -1;
#line 646
  request->header = (Http_header *)((void *)0);
#line 648
  n = read_until(fd, ' ', & data);
  }
#line 649
  if (n <= 0) {
    {
#line 651
    free((void *)request);
    }
#line 652
    return (n);
  }
  {
#line 654
  request->method = http_string_to_method((char const   *)data, (size_t )(n - 1));
  }
#line 655
  if ((unsigned int )request->method == 4294967295U) {
    {
#line 657
    log_error((char *)"http_parse_request: expected an HTTP method");
#line 658
    free((void *)data);
#line 659
    free((void *)request);
    }
#line 660
    return (-1);
  }
  {
#line 662
  *(data + (n - 1)) = (unsigned char)0;
#line 663
  log_verbose("http_parse_request: method = \"%s\"", data);
#line 664
  free((void *)data);
#line 665
  len = (size_t )n;
#line 667
  n = read_until(fd, ' ', & data);
  }
#line 668
  if (n <= 0) {
    {
#line 670
    free((void *)request);
    }
#line 671
    return (n);
  }
  {
#line 673
  *(data + (n - 1)) = (unsigned char)0;
#line 674
  request->uri = (char const   *)data;
#line 675
  len += (size_t )n;
#line 676
  log_verbose("http_parse_request: uri = \"%s\"", request->uri);
#line 678
  n = read_until(fd, '/', & data);
  }
#line 679
  if (n <= 0) {
    {
#line 681
    http_destroy_request(request);
    }
#line 682
    return (n);
  } else
#line 684
  if (n != 5) {
    {
#line 686
    log_error((char *)"http_parse_request: expected \"HTTP\"");
#line 687
    free((void *)data);
#line 688
    http_destroy_request(request);
    }
#line 689
    return (-1);
  } else {
    {
#line 684
    tmp___0 = memcmp((void const   *)data, (void const   *)"HTTP", (size_t )4);
    }
#line 684
    if (tmp___0 != 0) {
      {
#line 686
      log_error((char *)"http_parse_request: expected \"HTTP\"");
#line 687
      free((void *)data);
#line 688
      http_destroy_request(request);
      }
#line 689
      return (-1);
    }
  }
  {
#line 691
  free((void *)data);
#line 692
  len = (size_t )n;
#line 694
  n = read_until(fd, '.', & data);
  }
#line 695
  if (n <= 0) {
    {
#line 697
    http_destroy_request(request);
    }
#line 698
    return (n);
  }
  {
#line 700
  *(data + (n - 1)) = (unsigned char)0;
#line 701
  request->major_version = atoi((char const   *)data);
#line 702
  log_verbose("http_parse_request: major version = %d", request->major_version);
#line 704
  free((void *)data);
#line 705
  len += (size_t )n;
#line 707
  n = read_until(fd, '\r', & data);
  }
#line 708
  if (n <= 0) {
    {
#line 710
    http_destroy_request(request);
    }
#line 711
    return (n);
  }
  {
#line 713
  *(data + (n - 1)) = (unsigned char)0;
#line 714
  request->minor_version = atoi((char const   *)data);
#line 715
  log_verbose("http_parse_request: minor version = %d", request->minor_version);
#line 717
  free((void *)data);
#line 718
  len += (size_t )n;
#line 720
  n = read_until(fd, '\n', & data);
  }
#line 721
  if (n <= 0) {
    {
#line 723
    http_destroy_request(request);
    }
#line 724
    return (n);
  }
  {
#line 726
  free((void *)data);
  }
#line 727
  if (n != 1) {
    {
#line 729
    log_error((char *)"http_parse_request: invalid line ending");
#line 730
    http_destroy_request(request);
    }
#line 731
    return (-1);
  }
  {
#line 733
  len += (size_t )n;
#line 735
  n = parse_header(fd, & request->header);
  }
#line 736
  if (n <= 0) {
    {
#line 738
    http_destroy_request(request);
    }
#line 739
    return (n);
  }
#line 741
  len += (size_t )n;
#line 743
  *request_ = request;
#line 744
  return ((ssize_t )len);
}
}
#line 747 "http.c"
ssize_t http_write_request(int fd , Http_request *request ) 
{ 
  char str[1024] ;
  ssize_t n ;
  size_t m ;
  char const   *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 751
  n = 0;
#line 754
  tmp = http_method_to_string(request->method);
#line 754
  tmp___0 = sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%s %s HTTP/%d.%d\r\n",
                    tmp, request->uri, request->major_version, request->minor_version);
#line 754
  m = (size_t )tmp___0;
#line 759
  tmp___1 = write_all(fd, (void *)(str), m);
#line 759
  m = (size_t )tmp___1;
#line 760
  log_verbose("http_write_request: %s", str);
  }
#line 761
  if (m == 4294967295U) {
    {
#line 763
    tmp___2 = __errno_location();
#line 763
    tmp___3 = strerror(*tmp___2);
#line 763
    log_error((char *)"http_write_request: write error: %s", tmp___3);
    }
#line 764
    return (-1);
  }
  {
#line 766
  n = (ssize_t )((size_t )n + m);
#line 768
  tmp___4 = http_write_header(fd, request->header);
#line 768
  m = (size_t )tmp___4;
  }
#line 769
  if (m == 4294967295U) {
#line 771
    return (-1);
  }
#line 773
  n = (ssize_t )((size_t )n + m);
#line 775
  return (n);
}
}
#line 778 "http.c"
void http_destroy_request(Http_request *request ) 
{ 


  {
#line 781
  if (request->uri) {
    {
#line 782
    free((void *)((char *)request->uri));
    }
  }
  {
#line 783
  http_destroy_header(request->header);
#line 784
  free((void *)request);
  }
#line 785
  return;
}
}
#line 787 "http.c"
static Http_header *http_header_find(Http_header *header , char const   *name ) 
{ 
  int tmp ;
  Http_header *tmp___0 ;

  {
#line 790
  if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 791
    return ((Http_header *)((void *)0));
  }
  {
#line 793
  tmp = strcmp(header->name, name);
  }
#line 793
  if (tmp == 0) {
#line 794
    return (header);
  }
  {
#line 796
  tmp___0 = http_header_find(header->next, name);
  }
#line 796
  return (tmp___0);
}
}
#line 799 "http.c"
char const   *http_header_get(Http_header *header , char const   *name ) 
{ 
  Http_header *h ;

  {
  {
#line 804
  h = http_header_find(header, name);
  }
#line 805
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 806
    return ((char const   *)((void *)0));
  }
#line 808
  return (h->value);
}
}
#line 100 "/usr/include/sys/socket.h"
extern int socket(int __domain , int __type , int __protocol ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 185
extern int getsockopt(int __fd , int __level , int __optname , void * __restrict  __optval ,
                      socklen_t * __restrict  __optlen ) ;
#line 192
extern int setsockopt(int __fd , int __level , int __optname , void const   *__optval ,
                      socklen_t __optlen ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 262 "/usr/include/netinet/in.h"
extern uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
#line 263
extern uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
#line 267
extern uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 138 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 339
extern void endprotoent(void) ;
#line 352
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 48 "/usr/include/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 70 "tunnel.h"
Tunnel *tunnel_new_client(char const   *host , int host_port , char const   *proxy ,
                          int proxy_port , size_t content_length ) ;
#line 73
Tunnel *tunnel_new_server(char const   *host , int port , size_t content_length ) ;
#line 75
int tunnel_connect(Tunnel *tunnel ) ;
#line 76
int tunnel_accept(Tunnel *tunnel ) ;
#line 77
int tunnel_pollin_fd(Tunnel *tunnel ) ;
#line 78
ssize_t tunnel_read(Tunnel *tunnel , void *data , size_t length ) ;
#line 79
ssize_t tunnel_write(Tunnel *tunnel , void *data , size_t length ) ;
#line 80
ssize_t tunnel_padding(Tunnel *tunnel , size_t length ) ;
#line 81
int tunnel_maybe_pad(Tunnel *tunnel , size_t length ) ;
#line 82
int tunnel_setopt(Tunnel *tunnel , char const   *opt , void *data ) ;
#line 83
int tunnel_getopt(Tunnel *tunnel , char const   *opt , void *data ) ;
#line 84
int tunnel_close(Tunnel *tunnel ) ;
#line 85
void tunnel_destroy(Tunnel *tunnel ) ;
#line 305 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 35 "/usr/include/arpa/inet.h"
extern in_addr_t inet_addr(char const   *__cp ) ;
#line 45 "common.h"
void log_notice(char *fmt0  , ...) ;
#line 57
int server_socket(struct in_addr addr , int port , int backlog ) ;
#line 58
int set_address(struct sockaddr_in *address , char const   *host , int port ) ;
#line 130 "common.h"
__inline static int do_connect(struct sockaddr_in *address ) 
{ 
  int fd ;
  int tmp ;

  {
  {
#line 135
  fd = socket(2, 1, 0);
  }
#line 136
  if (fd == -1) {
#line 137
    return (-1);
  }
  {
#line 139
  tmp = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)address), (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 139
  if (tmp == -1) {
    {
#line 142
    close(fd);
    }
#line 143
    return (-1);
  }
#line 146
  return (fd);
}
}
#line 57 "tunnel.c"
__inline static char const   *REQ_TO_STRING(Request request ) 
{ 


  {
  {
#line 62
  if ((int )request == 1) {
#line 62
    goto case_1;
  }
#line 63
  if ((int )request == 2) {
#line 63
    goto case_2;
  }
#line 64
  if ((int )request == 3) {
#line 64
    goto case_3;
  }
#line 65
  if ((int )request == 4) {
#line 65
    goto case_4;
  }
#line 66
  if ((int )request == 69) {
#line 66
    goto case_69;
  }
#line 67
  if ((int )request == 70) {
#line 67
    goto case_70;
  }
#line 68
  if ((int )request == 71) {
#line 68
    goto case_71;
  }
#line 69
  goto switch_default;
  case_1: /* CIL Label */ 
#line 62
  return ("TUNNEL_OPEN");
  case_2: /* CIL Label */ 
#line 63
  return ("TUNNEL_DATA");
  case_3: /* CIL Label */ 
#line 64
  return ("TUNNEL_PADDING");
  case_4: /* CIL Label */ 
#line 65
  return ("TUNNEL_ERROR");
  case_69: /* CIL Label */ 
#line 66
  return ("TUNNEL_PAD1");
  case_70: /* CIL Label */ 
#line 67
  return ("TUNNEL_CLOSE");
  case_71: /* CIL Label */ 
#line 68
  return ("TUNNEL_DISCONNECT");
  switch_default: /* CIL Label */ 
#line 69
  return ("(unknown)");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 95 "tunnel.c"
static unsigned int const   sizeof_header  =    (size_t const   )(sizeof(Request ) + sizeof(Length ));
#line 97 "tunnel.c"
__inline static int tunnel_is_disconnected(Tunnel *tunnel ) 
{ 


  {
#line 100
  return (tunnel->out_fd == -1);
}
}
#line 103 "tunnel.c"
__inline static int tunnel_is_connected(Tunnel *tunnel ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 106
  tmp = tunnel_is_disconnected(tunnel);
  }
#line 106
  if (tmp) {
#line 106
    tmp___0 = 0;
  } else {
#line 106
    tmp___0 = 1;
  }
#line 106
  return (tmp___0);
}
}
#line 109 "tunnel.c"
__inline static int tunnel_is_server(Tunnel *tunnel ) 
{ 


  {
#line 112
  return (tunnel->server_socket != -1);
}
}
#line 115 "tunnel.c"
__inline static int tunnel_is_client(Tunnel *tunnel ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 118
  tmp = tunnel_is_server(tunnel);
  }
#line 118
  if (tmp) {
#line 118
    tmp___0 = 0;
  } else {
#line 118
    tmp___0 = 1;
  }
#line 118
  return (tmp___0);
}
}
#line 122 "tunnel.c"
static int get_proto_number(char const   *name ) 
{ 
  struct protoent *p ;
  int number ;

  {
  {
#line 128
  p = getprotobyname(name);
  }
#line 129
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 130
    number = -1;
  } else {
#line 132
    number = p->p_proto;
  }
  {
#line 133
  endprotoent();
  }
#line 135
  return (number);
}
}
#line 139 "tunnel.c"
static int tunnel_in_setsockopts(int fd ) 
{ 
  int tcp ;
  int tmp ;
  int i ;
  int n ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 143
  tmp = get_proto_number("tcp");
#line 143
  tcp = tmp;
  }
#line 145
  if (tcp != -1) {
    {
#line 149
    i = 1;
#line 150
    tmp___2 = setsockopt(fd, tcp, 18, (void const   *)((void *)(& i)), (socklen_t )sizeof(i));
    }
#line 150
    if (tmp___2 == -1) {
      {
#line 156
      tmp___0 = __errno_location();
#line 156
      tmp___1 = strerror(*tmp___0);
#line 156
      log_verbose("tunnel_in_setsockopts: non-fatal SO_RCVLOWAT error: %s", tmp___1);
      }
    }
    {
#line 159
    n = (int )sizeof(i);
#line 160
    getsockopt(fd, tcp, 18, (void */* __restrict  */)((void *)(& i)), (socklen_t */* __restrict  */)(& n));
#line 165
    log_verbose("tunnel_out_setsockopts: SO_RCVLOWAT: %d", i);
    }
  }
#line 169
  return (0);
}
}
#line 172 "tunnel.c"
static int tunnel_out_setsockopts(int fd ) 
{ 
  int tcp ;
  int tmp ;
  int i ;
  int n ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct linger l ;
  int n___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tcp___0 ;
  int tmp___6 ;
  int i___0 ;
  int n___1 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int i___1 ;
  int n___2 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 177
  tmp = get_proto_number("tcp");
#line 177
  tcp = tmp;
  }
#line 180
  if (tcp != -1) {
    {
#line 182
    i = 1;
#line 183
    tmp___2 = setsockopt(fd, tcp, 19, (void const   *)((void *)(& i)), (socklen_t )sizeof(i));
    }
#line 183
    if (tmp___2 == -1) {
      {
#line 189
      tmp___0 = __errno_location();
#line 189
      tmp___1 = strerror(*tmp___0);
#line 189
      log_verbose("tunnel_out_setsockopts: non-fatal SO_SNDLOWAT error: %s", tmp___1);
      }
    }
    {
#line 193
    n = (int )sizeof(i);
#line 194
    getsockopt(fd, tcp, 19, (void */* __restrict  */)((void *)(& i)), (socklen_t */* __restrict  */)(& n));
#line 199
    log_verbose("tunnel_out_setsockopts: non-fatal SO_SNDLOWAT: %d", i);
    }
  }
  {
#line 209
  l.l_onoff = 1;
#line 210
  l.l_linger = 2000;
#line 211
  tmp___5 = setsockopt(fd, 1, 13, (void const   *)((void *)(& l)), (socklen_t )sizeof(l));
  }
#line 211
  if (tmp___5 == -1) {
    {
#line 217
    tmp___3 = __errno_location();
#line 217
    tmp___4 = strerror(*tmp___3);
#line 217
    log_verbose("tunnel_out_setsockopts: non-fatal SO_LINGER error: %s", tmp___4);
    }
  }
  {
#line 220
  n___0 = (int )sizeof(l);
#line 221
  getsockopt(fd, 1, 13, (void */* __restrict  */)((void *)(& l)), (socklen_t */* __restrict  */)(& n___0));
#line 226
  log_verbose("tunnel_out_setsockopts: SO_LINGER: onoff=%d linger=%d", l.l_onoff,
              l.l_linger);
#line 233
  tmp___6 = get_proto_number("tcp");
#line 233
  tcp___0 = tmp___6;
  }
#line 236
  if (tcp___0 != -1) {
    {
#line 238
    i___0 = 1;
#line 239
    tmp___9 = setsockopt(fd, tcp___0, 1, (void const   *)((void *)(& i___0)), (socklen_t )sizeof(i___0));
    }
#line 239
    if (tmp___9 == -1) {
      {
#line 245
      tmp___7 = __errno_location();
#line 245
      tmp___8 = strerror(*tmp___7);
#line 245
      log_verbose("tunnel_out_setsockopts: non-fatal TCP_NODELAY error: %s", tmp___8);
      }
    }
    {
#line 249
    n___1 = (int )sizeof(i___0);
#line 250
    getsockopt(fd, tcp___0, 1, (void */* __restrict  */)((void *)(& i___0)), (socklen_t */* __restrict  */)(& n___1));
#line 255
    log_verbose("tunnel_out_setsockopts: non-fatal TCP_NODELAY: %d", i___0);
    }
  }
  {
#line 288
  i___1 = 1;
#line 289
  tmp___12 = setsockopt(fd, 1, 9, (void const   *)((void *)(& i___1)), (socklen_t )sizeof(i___1));
  }
#line 289
  if (tmp___12 == -1) {
    {
#line 295
    tmp___10 = __errno_location();
#line 295
    tmp___11 = strerror(*tmp___10);
#line 295
    log_verbose("tunnel_out_setsockopts: non-fatal SO_KEEPALIVE error: %s", tmp___11);
    }
  }
  {
#line 298
  n___2 = (int )sizeof(i___1);
#line 299
  getsockopt(fd, 1, 9, (void */* __restrict  */)((void *)(& i___1)), (socklen_t */* __restrict  */)(& n___2));
#line 304
  log_verbose("tunnel_out_setsockopts: SO_KEEPALIVE: %d", i___1);
  }
#line 308
  return (0);
}
}
#line 311 "tunnel.c"
static void tunnel_out_disconnect(Tunnel *tunnel ) 
{ 
  int tmp ;

  {
  {
#line 314
  tmp = tunnel_is_disconnected(tunnel);
  }
#line 314
  if (tmp) {
#line 315
    return;
  }
  {
#line 325
  close(tunnel->out_fd);
#line 326
  tunnel->out_fd = -1;
#line 327
  tunnel->bytes = (size_t )0;
#line 328
  tunnel->buf_ptr = tunnel->buf;
#line 329
  tunnel->buf_len = (size_t )0;
#line 331
  log_verbose("tunnel_out_disconnect: output disconnected");
  }
#line 332
  return;
}
}
#line 334 "tunnel.c"
static void tunnel_in_disconnect(Tunnel *tunnel ) 
{ 


  {
#line 337
  if (tunnel->in_fd == -1) {
#line 338
    return;
  }
  {
#line 340
  close(tunnel->in_fd);
#line 341
  tunnel->in_fd = -1;
#line 343
  log_verbose("tunnel_in_disconnect: input disconnected");
  }
#line 344
  return;
}
}
#line 346 "tunnel.c"
static int tunnel_out_connect(Tunnel *tunnel ) 
{ 
  ssize_t n ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  uint16_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
  {
#line 351
  tmp = tunnel_is_connected(tunnel);
  }
#line 351
  if (tmp) {
    {
#line 353
    log_verbose("tunnel_out_connect: already connected");
#line 354
    tunnel_out_disconnect(tunnel);
    }
  }
  {
#line 357
  tunnel->out_fd = do_connect(& tunnel->address);
  }
#line 358
  if (tunnel->out_fd == -1) {
    {
#line 360
    tmp___0 = __errno_location();
#line 360
    tmp___1 = strerror(*tmp___0);
#line 360
    tmp___2 = ntohs(tunnel->address.sin_port);
#line 360
    tmp___3 = ntohl(tunnel->address.sin_addr.s_addr);
#line 360
    tmp___4 = ntohl(tunnel->address.sin_addr.s_addr);
#line 360
    tmp___5 = ntohl(tunnel->address.sin_addr.s_addr);
#line 360
    tmp___6 = ntohl(tunnel->address.sin_addr.s_addr);
#line 360
    log_error((char *)"tunnel_out_connect: do_connect (%d.%d.%d.%d:%u) error: %s",
              tmp___6 >> 24, (tmp___5 >> 16) & 255U, (tmp___4 >> 8) & 255U, tmp___3 & 255U,
              (int )tmp___2, tmp___1);
    }
#line 367
    return (-1);
  }
  {
#line 370
  tunnel_out_setsockopts(tunnel->out_fd);
#line 377
  n = http_post(tunnel->out_fd, & tunnel->dest, tunnel->content_length + 1U);
  }
#line 380
  if (n == -1) {
#line 381
    return (-1);
  }
  {
#line 388
  tunnel->bytes = (size_t )0;
#line 389
  tunnel->buf_ptr = tunnel->buf;
#line 390
  tunnel->buf_len = (size_t )0;
#line 391
  tunnel->padding_only = 1;
#line 392
  time(& tunnel->out_connect_time);
#line 394
  log_verbose("tunnel_out_connect: output connected");
  }
#line 396
  return (0);
}
}
#line 399 "tunnel.c"
static int tunnel_in_connect(Tunnel *tunnel ) 
{ 
  Http_response *response ;
  ssize_t n ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 405
  log_verbose("tunnel_in_connect()");
  }
#line 407
  if (tunnel->in_fd != -1) {
    {
#line 409
    log_error((char *)"tunnel_in_connect: already connected");
    }
#line 410
    return (-1);
  }
  {
#line 413
  tunnel->in_fd = do_connect(& tunnel->address);
  }
#line 414
  if (tunnel->in_fd == -1) {
    {
#line 416
    tmp = __errno_location();
#line 416
    tmp___0 = strerror(*tmp);
#line 416
    log_error((char *)"tunnel_in_connect: do_connect() error: %s", tmp___0);
    }
#line 418
    return (-1);
  }
  {
#line 421
  tunnel_in_setsockopts(tunnel->in_fd);
#line 423
  tmp___1 = http_get(tunnel->in_fd, & tunnel->dest);
  }
#line 423
  if (tmp___1 == -1) {
#line 424
    return (-1);
  }
  {
#line 435
  n = http_parse_response(tunnel->in_fd, & response);
  }
#line 436
  if (n <= 0) {
#line 438
    if (n == 0) {
      {
#line 439
      log_error((char *)"tunnel_in_connect: no response; peer closed connection");
      }
    } else {
      {
#line 442
      tmp___2 = __errno_location();
#line 442
      tmp___3 = strerror(*tmp___2);
#line 442
      log_error((char *)"tunnel_in_connect: no response; error: %s", tmp___3);
      }
    }
  } else
#line 445
  if (response->major_version != 1) {
    {
#line 449
    log_error((char *)"tunnel_in_connect: unknown HTTP version: %d.%d", response->major_version,
              response->minor_version);
#line 451
    n = -1;
    }
  } else
#line 445
  if (response->minor_version != 1) {
#line 445
    if (response->minor_version != 0) {
      {
#line 449
      log_error((char *)"tunnel_in_connect: unknown HTTP version: %d.%d", response->major_version,
                response->minor_version);
#line 451
      n = -1;
      }
    } else {
#line 445
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 453
  if (response->status_code != 200) {
    {
#line 455
    log_error((char *)"tunnel_in_connect: HTTP error %d", response->status_code);
#line 456
    tmp___4 = __errno_location();
#line 456
    *tmp___4 = http_error_to_errno(- response->status_code);
#line 457
    n = -1;
    }
  }
#line 460
  if (response) {
    {
#line 461
    http_destroy_response(response);
    }
  }
#line 463
  if (! (n > 0)) {
#line 473
    return (n);
  }
  {
#line 476
  log_verbose("tunnel_in_connect: input connected");
  }
#line 477
  return (1);
}
}
#line 480 "tunnel.c"
__inline static ssize_t tunnel_write_data(Tunnel *tunnel , void *data , size_t length ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 483
  tmp___1 = write_all(tunnel->out_fd, data, length);
  }
#line 483
  if (tmp___1 == -1) {
    {
#line 485
    tmp = __errno_location();
#line 485
    tmp___0 = strerror(*tmp);
#line 485
    log_error((char *)"tunnel_write_data: write error: %s", tmp___0);
    }
#line 486
    return (-1);
  }
#line 488
  tunnel->bytes += length;
#line 489
  return ((ssize_t )length);
}
}
#line 492 "tunnel.c"
static int tunnel_write_request(Tunnel *tunnel , Request request , void *data , Length length ) 
{ 
  unsigned long tmp ;
  time_t t ;
  char c ;
  int l ;
  char c___0 ;
  short s ;
  int i ;
  uint16_t tmp___0 ;
  char c___1 ;
  int i___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  ssize_t tmp___11 ;
  ssize_t tmp___12 ;
  Length network_length ;
  uint16_t tmp___13 ;
  ssize_t tmp___14 ;
  ssize_t tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char c___2 ;

  {
#line 496
  if (data) {
#line 496
    tmp = sizeof(length) + (unsigned long )length;
  } else {
#line 496
    tmp = 0UL;
  }
#line 496
  if (((unsigned long )tunnel->bytes + sizeof(request)) + tmp > (unsigned long )tunnel->content_length) {
    {
#line 498
    tunnel_padding(tunnel, tunnel->content_length - tunnel->bytes);
    }
  }
  {
#line 504
  time(& t);
#line 505
  tmp___2 = tunnel_is_client(tunnel);
  }
#line 505
  if (tmp___2) {
    {
#line 505
    tmp___3 = tunnel_is_connected(tunnel);
    }
#line 505
    if (tmp___3) {
#line 505
      if (t - tunnel->out_connect_time > (time_t )tunnel->max_connection_age) {
        {
#line 509
        c = (char)71;
#line 511
        log_verbose("tunnel_write_request: connection > %d seconds old", tunnel->max_connection_age);
        }
#line 514
        if (tunnel->strict_content_length) {
          {
#line 516
          l = (int )((tunnel->content_length - tunnel->bytes) - 1U);
#line 518
          log_verbose("tunnel_write_request: write padding (%d bytes)", (tunnel->content_length - tunnel->bytes) - 1U);
          }
#line 520
          if (l > 3) {
            {
#line 526
            c___0 = (char)3;
#line 527
            tunnel_write_data(tunnel, (void *)(& c___0), (size_t )sizeof(c___0));
#line 529
            tmp___0 = htons((uint16_t )(l - 2));
#line 529
            s = (short )tmp___0;
#line 530
            tunnel_write_data(tunnel, (void *)(& s), (size_t )sizeof(s));
#line 532
            l -= 2;
#line 533
            c___0 = (char)0;
#line 534
            i = 0;
            }
            {
#line 534
            while (1) {
              while_continue: /* CIL Label */ ;
#line 534
              if (! (i < l)) {
#line 534
                goto while_break;
              }
              {
#line 535
              tunnel_write_data(tunnel, (void *)(& c___0), (size_t )sizeof(c___0));
#line 534
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 539
            c___1 = (char)69;
#line 542
            i___0 = 0;
            {
#line 542
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 542
              if (! (i___0 < l)) {
#line 542
                goto while_break___0;
              }
              {
#line 543
              tunnel_write_data(tunnel, (void *)(& c___1), (size_t )sizeof(c___1));
#line 542
              i___0 ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
        {
#line 547
        log_verbose("tunnel_write_request: closing old connection");
#line 548
        tmp___1 = tunnel_write_data(tunnel, (void *)(& c), (size_t )sizeof(c));
        }
#line 548
        if (tmp___1 <= 0) {
#line 549
          return (-1);
        }
        {
#line 550
        tunnel_out_disconnect(tunnel);
        }
      }
    }
  }
  {
#line 555
  tmp___7 = tunnel_is_disconnected(tunnel);
  }
#line 555
  if (tmp___7) {
    {
#line 557
    tmp___6 = tunnel_is_client(tunnel);
    }
#line 557
    if (tmp___6) {
      {
#line 559
      tmp___4 = tunnel_out_connect(tunnel);
      }
#line 559
      if (tmp___4 == -1) {
#line 560
        return (-1);
      }
    } else {
      {
#line 569
      tmp___5 = tunnel_accept(tunnel);
      }
#line 569
      if (tmp___5 == -1) {
#line 570
        return (-1);
      }
    }
  }
#line 575
  if ((int )request != 3) {
#line 575
    if ((int )request != 69) {
#line 576
      tunnel->padding_only = 0;
    }
  }
  {
#line 578
  tmp___12 = tunnel_write_data(tunnel, (void *)(& request), (size_t )sizeof(request));
  }
#line 578
  if (tmp___12 == -1) {
    {
#line 580
    tmp___8 = __errno_location();
    }
#line 580
    if (*tmp___8 != 32) {
#line 581
      return (-1);
    }
    {
#line 583
    tunnel_out_disconnect(tunnel);
#line 584
    tmp___10 = tunnel_is_client(tunnel);
    }
#line 584
    if (tmp___10) {
      {
#line 585
      tunnel_out_connect(tunnel);
      }
    } else {
      {
#line 588
      log_error((char *)"tunnel_write_request: couldn\'t write request: output is disconnected");
#line 590
      tmp___9 = __errno_location();
#line 590
      *tmp___9 = 5;
      }
#line 591
      return (-1);
    }
    {
#line 594
    tmp___11 = tunnel_write_data(tunnel, (void *)(& request), (size_t )sizeof(request));
    }
#line 594
    if (tmp___11 == -1) {
#line 595
      return (-1);
    }
  }
#line 598
  if (data) {
    {
#line 600
    tmp___13 = htons((uint16_t )((short )length));
#line 600
    network_length = tmp___13;
#line 601
    tmp___14 = tunnel_write_data(tunnel, (void *)(& network_length), (size_t )sizeof(network_length));
    }
#line 601
    if (tmp___14 == -1) {
#line 604
      return (-1);
    }
    {
#line 614
    tmp___15 = tunnel_write_data(tunnel, data, (size_t )length);
    }
#line 614
    if (tmp___15 == -1) {
#line 615
      return (-1);
    }
  }
#line 618
  if (data) {
#line 620
    tunnel->out_total_raw += (size_t )(3 + (int )length);
#line 622
    if ((int )request == 2) {
      {
#line 623
      tmp___16 = REQ_TO_STRING(request);
#line 623
      log_verbose("tunnel_write_request: %s (%d)", tmp___16, (int )length);
      }
    } else {
      {
#line 626
      tmp___17 = REQ_TO_STRING(request);
#line 626
      log_verbose("tunnel_write_request: %s (%d)", tmp___17, (int )length);
      }
    }
  } else {
    {
#line 631
    (tunnel->out_total_raw) ++;
#line 632
    tmp___18 = REQ_TO_STRING(request);
#line 632
    log_verbose("tunnel_write_request: %s", tmp___18);
    }
  }
  {
#line 635
  log_verbose("tunnel_write_data: out_total_raw = %u", tunnel->out_total_raw);
  }
#line 643
  if (tunnel->bytes >= tunnel->content_length) {
    {
#line 645
    c___2 = (char)71;
#line 646
    tunnel_write_data(tunnel, (void *)(& c___2), (size_t )sizeof(c___2));
#line 647
    tunnel_out_disconnect(tunnel);
    }
  }
#line 654
  return (0);
}
}
#line 657 "tunnel.c"
int tunnel_connect(Tunnel *tunnel ) 
{ 
  char auth_data[1] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 660
  auth_data[0] = (char)42;
#line 662
  log_verbose("tunnel_connect()");
#line 664
  tmp___0 = tunnel_is_connected(tunnel);
  }
#line 664
  if (tmp___0) {
    {
#line 666
    log_error((char *)"tunnel_connect: already connected");
#line 667
    tmp = __errno_location();
#line 667
    *tmp = 22;
    }
#line 668
    return (-1);
  }
  {
#line 671
  tmp___1 = tunnel_write_request(tunnel, (Request )1, (void *)(auth_data), (Length )sizeof(auth_data));
  }
#line 671
  if (tmp___1 == -1) {
#line 673
    return (-1);
  }
  {
#line 675
  tmp___2 = tunnel_in_connect(tunnel);
  }
#line 675
  if (tmp___2 <= 0) {
#line 676
    return (-1);
  }
#line 678
  return (0);
}
}
#line 685 "tunnel.c"
static char padding[65536]  ;
#line 681 "tunnel.c"
__inline static int tunnel_write_or_padding(Tunnel *tunnel , Request request , void *data ,
                                            size_t length ) 
{ 
  size_t n ;
  size_t remaining ;
  char *wdata ;
  int tmp ;
  int tmp___0 ;

  {
#line 687
  wdata = (char *)data;
#line 689
  remaining = length;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! (remaining > 0U)) {
#line 689
      goto while_break;
    }
#line 691
    if (tunnel->bytes + remaining > tunnel->content_length - (size_t )sizeof_header) {
#line 691
      if (tunnel->content_length - tunnel->bytes > (size_t )sizeof_header) {
#line 693
        n = (tunnel->content_length - (size_t )sizeof_header) - tunnel->bytes;
      } else {
#line 691
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 694
    if (remaining > tunnel->content_length - (size_t )sizeof_header) {
#line 695
      n = tunnel->content_length - (size_t )sizeof_header;
    } else {
#line 697
      n = remaining;
    }
#line 699
    if (n > 65535U) {
#line 700
      n = (size_t )65535;
    }
#line 702
    if ((int )request == 3) {
#line 704
      if (n + (size_t )sizeof_header > remaining) {
#line 705
        n = remaining - (size_t )sizeof_header;
      }
      {
#line 706
      tmp = tunnel_write_request(tunnel, request, (void *)(padding), (Length )n);
      }
#line 706
      if (tmp == -1) {
#line 707
        goto while_break;
      }
#line 708
      n += (size_t )sizeof_header;
    } else {
      {
#line 712
      tmp___0 = tunnel_write_request(tunnel, request, (void *)wdata, (Length )n);
      }
#line 712
      if (tmp___0 == -1) {
#line 713
        goto while_break;
      }
    }
#line 689
    remaining -= n;
#line 689
    wdata += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return ((int )(length - remaining));
}
}
#line 720 "tunnel.c"
ssize_t tunnel_write(Tunnel *tunnel , void *data , size_t length ) 
{ 
  ssize_t n ;

  {
  {
#line 725
  n = tunnel_write_or_padding(tunnel, (Request )2, data, length);
#line 726
  tunnel->out_total_data += length;
#line 727
  log_verbose("tunnel_write: out_total_data = %u", tunnel->out_total_data);
  }
#line 728
  return (n);
}
}
#line 731 "tunnel.c"
ssize_t tunnel_padding(Tunnel *tunnel , size_t length ) 
{ 
  int i ;
  int tmp ;

  {
#line 734
  if (length < (size_t )(sizeof_header + 1U)) {
#line 738
    i = 0;
    {
#line 738
    while (1) {
      while_continue: /* CIL Label */ ;
#line 738
      if (! ((size_t )i < length)) {
#line 738
        goto while_break;
      }
      {
#line 739
      tunnel_write_request(tunnel, (Request )69, (void *)0, (Length )0);
#line 738
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 740
    return ((ssize_t )length);
  }
  {
#line 743
  tmp = tunnel_write_or_padding(tunnel, (Request )3, (void *)0, length);
  }
#line 743
  return (tmp);
}
}
#line 746 "tunnel.c"
int tunnel_close(Tunnel *tunnel ) 
{ 
  struct pollfd p ;
  char buf[10240] ;
  ssize_t n ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 753
  if (tunnel->strict_content_length) {
    {
#line 755
    log_verbose("tunnel_close: write padding (%d bytes)", (tunnel->content_length - tunnel->bytes) - 1U);
#line 757
    tunnel_padding(tunnel, (tunnel->content_length - tunnel->bytes) - 1U);
    }
  }
  {
#line 760
  log_verbose("tunnel_close: write TUNNEL_CLOSE request");
#line 761
  tunnel_write_request(tunnel, (Request )70, (void *)0, (Length )0);
#line 763
  tunnel_out_disconnect(tunnel);
#line 765
  log_verbose("tunnel_close: reading trailing data from input ...");
#line 766
  p.fd = tunnel->in_fd;
#line 767
  p.events = (short)1;
  }
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 768
    tmp___2 = poll(& p, (nfds_t )1, 1000);
    }
#line 768
    if (! (tmp___2 > 0)) {
#line 768
      goto while_break;
    }
#line 770
    if ((int )p.revents & 1) {
      {
#line 772
      n = read(tunnel->in_fd, (void *)(buf), (size_t )sizeof(buf));
      }
#line 773
      if (n > 0) {
        {
#line 775
        log_verbose("read (%d, %p, %d) = %d", tunnel->in_fd, buf, sizeof(buf), n);
        }
#line 777
        goto while_continue;
      } else
#line 779
      if (n == -1) {
        {
#line 779
        tmp___1 = __errno_location();
        }
#line 779
        if (*tmp___1 == 11) {
#line 780
          goto while_continue;
        } else {
#line 779
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 781
      if (n == -1) {
        {
#line 782
        tmp = __errno_location();
#line 782
        tmp___0 = strerror(*tmp);
#line 782
        log_verbose("tunnel_close: ... error: %s", tmp___0);
        }
      } else {
        {
#line 784
        log_verbose("tunnel_close: ... done (tunnel closed)");
        }
      }
    }
#line 786
    if ((int )p.revents & 16) {
      {
#line 787
      log_verbose("POLLHUP");
      }
    }
#line 788
    if ((int )p.revents & 8) {
      {
#line 789
      log_verbose("POLLERR");
      }
    }
#line 790
    if ((int )p.revents & 32) {
      {
#line 791
      log_verbose("POLLNVAL");
      }
    }
#line 792
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 795
  tunnel_in_disconnect(tunnel);
#line 797
  tunnel->buf_len = (size_t )0;
#line 798
  tunnel->in_total_raw = (size_t )0;
#line 799
  tunnel->in_total_data = (size_t )0;
#line 800
  tunnel->out_total_raw = (size_t )0;
#line 801
  tunnel->out_total_data = (size_t )0;
  }
#line 803
  return (0);
}
}
#line 806 "tunnel.c"
static int tunnel_read_request(Tunnel *tunnel , enum tunnel_request *request , unsigned char *buf ,
                               size_t *length ) 
{ 
  Request req ;
  Length len ;
  ssize_t n ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 814
  log_verbose("read (%d, %p, %d) ...", tunnel->in_fd, & req, 1);
#line 815
  n = read(tunnel->in_fd, (void *)(& req), (size_t )1);
#line 816
  log_verbose("... = %d", n);
  }
#line 817
  if (n == -1) {
    {
#line 819
    tmp___1 = __errno_location();
    }
#line 819
    if (*tmp___1 != 11) {
      {
#line 820
      tmp = __errno_location();
#line 820
      tmp___0 = strerror(*tmp);
#line 820
      log_error((char *)"tunnel_read_request: error reading request: %s", tmp___0);
      }
    }
#line 822
    return (n);
  } else
#line 824
  if (n == 0) {
    {
#line 826
    log_verbose("tunnel_read_request: connection closed by peer");
#line 827
    tunnel_in_disconnect(tunnel);
#line 829
    tmp___2 = tunnel_is_client(tunnel);
    }
#line 829
    if (tmp___2) {
      {
#line 829
      tmp___3 = tunnel_in_connect(tunnel);
      }
#line 829
      if (tmp___3 == -1) {
#line 831
        return (-1);
      }
    }
    {
#line 833
    tmp___4 = __errno_location();
#line 833
    *tmp___4 = 11;
    }
#line 834
    return (-1);
  }
  {
#line 836
  *request = (enum tunnel_request )req;
#line 837
  tunnel->in_total_raw += (size_t )n;
#line 838
  tmp___5 = REQ_TO_STRING(req);
#line 838
  log_verbose("request = 0x%x (%s)", (int )req, tmp___5);
  }
#line 840
  if ((int )req & 64) {
    {
#line 842
    log_verbose("tunnel_read_request: in_total_raw = %u", tunnel->in_total_raw);
#line 844
    tmp___6 = REQ_TO_STRING(req);
#line 844
    log_verbose("tunnel_read_request:  %s", tmp___6);
#line 845
    *length = (size_t )0;
    }
#line 846
    return (1);
  }
  {
#line 849
  n = read_all(tunnel->in_fd, (void *)(& len), (size_t )2);
  }
#line 850
  if (n <= 0) {
    {
#line 852
    tmp___7 = __errno_location();
#line 852
    tmp___8 = strerror(*tmp___7);
#line 852
    log_error((char *)"tunnel_read_request: error reading request length: %s", tmp___8);
    }
#line 854
    if (n == 0) {
      {
#line 855
      tmp___9 = __errno_location();
#line 855
      *tmp___9 = 5;
      }
    }
#line 856
    return (-1);
  }
  {
#line 858
  len = ntohs(len);
#line 859
  *length = (size_t )len;
#line 860
  tunnel->in_total_raw += (size_t )n;
#line 861
  log_verbose("length = %d", (int )len);
  }
#line 863
  if ((int )len > 0) {
    {
#line 865
    n = read_all(tunnel->in_fd, (void *)buf, (size_t )len);
    }
#line 866
    if (n <= 0) {
      {
#line 868
      tmp___10 = __errno_location();
#line 868
      tmp___11 = strerror(*tmp___10);
#line 868
      log_error((char *)"tunnel_read_request: error reading request data: %s", tmp___11);
      }
#line 870
      if (n == 0) {
        {
#line 871
        tmp___12 = __errno_location();
#line 871
        *tmp___12 = 5;
        }
      }
#line 872
      return (-1);
    }
    {
#line 874
    tunnel->in_total_raw += (size_t )n;
#line 875
    log_verbose("tunnel_read_request: in_total_raw = %u", tunnel->in_total_raw);
    }
  }
#line 879
  if ((int )req == 2) {
    {
#line 880
    tmp___13 = REQ_TO_STRING(req);
#line 880
    log_verbose("tunnel_read_request:  %s (%d)", tmp___13, (int )len);
    }
  } else {
    {
#line 883
    tmp___14 = REQ_TO_STRING(req);
#line 883
    log_verbose("tunnel_read_request:  %s (%d)", tmp___14, (int )len);
    }
  }
#line 886
  return (1);
}
}
#line 889 "tunnel.c"
ssize_t tunnel_read(Tunnel *tunnel , void *data , size_t length ) 
{ 
  enum tunnel_request req ;
  size_t len ;
  ssize_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 896
  if (tunnel->buf_len > 0U) {
#line 898
    if (tunnel->buf_len < length) {
#line 898
      n = (ssize_t )tunnel->buf_len;
    } else {
#line 898
      n = (ssize_t )length;
    }
    {
#line 899
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)tunnel->buf_ptr,
           (size_t )n);
#line 900
    tunnel->buf_ptr += n;
#line 901
    tunnel->buf_len -= (size_t )n;
    }
#line 902
    return (n);
  }
#line 905
  if (tunnel->in_fd == -1) {
    {
#line 907
    tmp___1 = tunnel_is_client(tunnel);
    }
#line 907
    if (tmp___1) {
      {
#line 909
      tmp = tunnel_in_connect(tunnel);
      }
#line 909
      if (tmp == -1) {
#line 910
        return (-1);
      }
    } else {
      {
#line 915
      tmp___0 = tunnel_accept(tunnel);
      }
#line 915
      if (tmp___0 == -1) {
#line 916
        return (-1);
      }
    }
    {
#line 923
    tmp___2 = __errno_location();
#line 923
    *tmp___2 = 11;
    }
#line 924
    return (-1);
  }
#line 927
  if (tunnel->out_fd == -1) {
    {
#line 927
    tmp___4 = tunnel_is_server(tunnel);
    }
#line 927
    if (tmp___4) {
      {
#line 929
      tunnel_accept(tunnel);
#line 930
      tmp___3 = __errno_location();
#line 930
      *tmp___3 = 11;
      }
#line 931
      return (-1);
    }
  }
  {
#line 934
  tmp___5 = tunnel_read_request(tunnel, & req, (unsigned char *)(tunnel->buf), & len);
  }
#line 934
  if (tmp___5 <= 0) {
    {
#line 936
    log_verbose("tunnel_read_request returned <= 0, returning -1");
    }
#line 937
    return (-1);
  }
  {
#line 942
  if ((unsigned int )req == 1U) {
#line 942
    goto case_1;
  }
#line 946
  if ((unsigned int )req == 2U) {
#line 946
    goto case_2;
  }
#line 953
  if ((unsigned int )req == 3U) {
#line 953
    goto case_3;
  }
#line 957
  if ((unsigned int )req == 69U) {
#line 957
    goto case_69;
  }
#line 961
  if ((unsigned int )req == 4U) {
#line 961
    goto case_4;
  }
#line 967
  if ((unsigned int )req == 70U) {
#line 967
    goto case_70;
  }
#line 970
  if ((unsigned int )req == 71U) {
#line 970
    goto case_71;
  }
#line 980
  goto switch_default;
  case_1: /* CIL Label */ 
#line 944
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 947
  tunnel->buf_ptr = tunnel->buf;
#line 948
  tunnel->buf_len = len;
#line 949
  tunnel->in_total_data += len;
#line 950
  log_verbose("tunnel_read: in_total_data = %u", tunnel->in_total_data);
#line 951
  tmp___6 = tunnel_read(tunnel, data, length);
  }
#line 951
  return (tmp___6);
  case_3: /* CIL Label */ 
#line 955
  goto switch_break;
  case_69: /* CIL Label */ 
#line 959
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 962
  tunnel->buf[len] = (char)0;
#line 963
  log_error((char *)"tunnel_read: received error: %s", tunnel->buf);
#line 964
  tmp___7 = __errno_location();
#line 964
  *tmp___7 = 5;
  }
#line 965
  return (-1);
  case_70: /* CIL Label */ 
#line 968
  return (0);
  case_71: /* CIL Label */ 
  {
#line 971
  tunnel_in_disconnect(tunnel);
#line 973
  tmp___8 = tunnel_is_client(tunnel);
  }
#line 973
  if (tmp___8) {
    {
#line 973
    tmp___9 = tunnel_in_connect(tunnel);
    }
#line 973
    if (tmp___9 == -1) {
#line 975
      return (-1);
    }
  }
  {
#line 977
  tmp___10 = __errno_location();
#line 977
  *tmp___10 = 11;
  }
#line 978
  return (-1);
  switch_default: /* CIL Label */ 
  {
#line 981
  log_error((char *)"tunnel_read: protocol error: unknown request 0x%02x", (unsigned int )req);
#line 982
  tmp___11 = __errno_location();
#line 982
  *tmp___11 = 22;
  }
#line 983
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 986
  tmp___12 = __errno_location();
#line 986
  *tmp___12 = 11;
  }
#line 987
  return (-1);
}
}
#line 990 "tunnel.c"
int tunnel_pollin_fd(Tunnel *tunnel ) 
{ 
  int tmp ;

  {
  {
#line 993
  tmp = tunnel_is_server(tunnel);
  }
#line 993
  if (tmp) {
#line 993
    if (tunnel->in_fd == -1) {
#line 993
      goto _L___0;
    } else
#line 993
    if (tunnel->out_fd == -1) {
      _L___0: /* CIL Label */ 
#line 996
      if (tunnel->in_fd == -1) {
        {
#line 997
        log_verbose("tunnel_pollin_fd: in_fd = -1; returning server_socket = %d",
                    tunnel->server_socket);
        }
      } else {
        {
#line 1000
        log_verbose("tunnel_pollin_fd: out_fd = -1; returning server_socket = %d",
                    tunnel->server_socket);
        }
      }
#line 1002
      return (tunnel->server_socket);
    } else {
#line 993
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1004
  if (tunnel->in_fd != -1) {
#line 1005
    return (tunnel->in_fd);
  } else {
    {
#line 1008
    log_error((char *)"tunnel_pollin_fd: returning -1");
    }
#line 1009
    return (-1);
  }
}
}
#line 1018 "tunnel.c"
int tunnel_maybe_pad(Tunnel *tunnel , size_t length ) 
{ 
  size_t padding___0 ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 1023
  tmp = tunnel_is_disconnected(tunnel);
  }
#line 1023
  if (tmp) {
#line 1026
    return (0);
  } else
#line 1023
  if (tunnel->bytes % length == 0U) {
#line 1026
    return (0);
  } else
#line 1023
  if (tunnel->padding_only) {
#line 1026
    return (0);
  }
#line 1028
  padding___0 = length - tunnel->bytes % length;
#line 1029
  if (padding___0 > tunnel->content_length - tunnel->bytes) {
#line 1030
    padding___0 = tunnel->content_length - tunnel->bytes;
  }
  {
#line 1032
  tmp___0 = tunnel_padding(tunnel, padding___0);
  }
#line 1032
  return (tmp___0);
}
}
#line 1080 "tunnel.c"
int tunnel_accept(Tunnel *tunnel ) 
{ 
  struct sockaddr_in addr ;
  Http_request *request ;
  struct pollfd p ;
  ssize_t m ;
  int len ;
  int n ;
  int s ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  uint16_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char str[1024] ;
  int *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  ssize_t tmp___15 ;

  {
#line 1083
  if (tunnel->in_fd != -1) {
#line 1083
    if (tunnel->out_fd != -1) {
      {
#line 1085
      log_verbose("tunnel_accept: tunnel already established");
      }
#line 1086
      return (0);
    }
  }
  {
#line 1089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1089
    if (! (tunnel->in_fd == -1)) {
#line 1089
      if (! (tunnel->out_fd == -1)) {
#line 1089
        goto while_break;
      }
    }
#line 1099
    p.fd = tunnel->server_socket;
#line 1100
    p.events = (short)1;
#line 1101
    if (tunnel->in_fd != -1) {
#line 1101
      tmp = 10000;
    } else
#line 1101
    if (tunnel->out_fd != -1) {
#line 1101
      tmp = 10000;
    } else {
#line 1101
      tmp = -1;
    }
    {
#line 1101
    n = poll(& p, (nfds_t )1, tmp);
    }
#line 1103
    if (n == -1) {
      {
#line 1105
      tmp___0 = __errno_location();
#line 1105
      tmp___1 = strerror(*tmp___0);
#line 1105
      log_error((char *)"tunnel_accept: poll error: %s", tmp___1);
      }
#line 1106
      return (-1);
    } else
#line 1108
    if (n == 0) {
      {
#line 1110
      log_error((char *)"tunnel_accept: poll timed out");
      }
#line 1111
      goto while_break;
    }
    {
#line 1114
    len = (int )sizeof(addr);
#line 1115
    s = accept(tunnel->server_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
               (socklen_t */* __restrict  */)(& len));
    }
#line 1116
    if (s == -1) {
      {
#line 1118
      tmp___2 = __errno_location();
#line 1118
      tmp___3 = strerror(*tmp___2);
#line 1118
      log_error((char *)"tunnel_accept: accept error: %s", tmp___3);
      }
#line 1119
      return (-1);
    }
    {
#line 1122
    tmp___4 = ntohs(addr.sin_port);
#line 1122
    tmp___5 = ntohl(addr.sin_addr.s_addr);
#line 1122
    tmp___6 = ntohl(addr.sin_addr.s_addr);
#line 1122
    tmp___7 = ntohl(addr.sin_addr.s_addr);
#line 1122
    tmp___8 = ntohl(addr.sin_addr.s_addr);
#line 1122
    log_notice((char *)"connection from %d.%d.%d.%d:%u", tmp___8 >> 24, (tmp___7 >> 16) & 255U,
               (tmp___6 >> 8) & 255U, tmp___5 & 255U, (int )tmp___4);
#line 1129
    m = http_parse_request(s, & request);
    }
#line 1130
    if (m <= 0) {
#line 1131
      return (m);
    }
#line 1133
    if ((unsigned int )request->method == 4294967295U) {
      {
#line 1135
      tmp___9 = __errno_location();
#line 1135
      tmp___10 = strerror(*tmp___9);
#line 1135
      log_error((char *)"tunnel_accept: error parsing header: %s", tmp___10);
#line 1137
      close(s);
      }
    } else
#line 1139
    if ((unsigned int )request->method == 2U) {
#line 1139
      goto _L;
    } else
#line 1139
    if ((unsigned int )request->method == 1U) {
      _L: /* CIL Label */ 
#line 1142
      if (tunnel->in_fd == -1) {
        {
#line 1144
        tunnel->in_fd = s;
#line 1152
        tmp___11 = fcntl(tunnel->in_fd, 3);
#line 1152
        fcntl(tunnel->in_fd, 4, tmp___11 | 2048);
#line 1156
        tunnel_in_setsockopts(tunnel->in_fd);
#line 1158
        log_verbose("tunnel_accept: input connected");
        }
      } else {
        {
#line 1162
        log_error((char *)"rejected tunnel_in: already got a connection");
#line 1163
        close(s);
        }
      }
    } else
#line 1166
    if ((unsigned int )request->method == 0U) {
#line 1168
      if (tunnel->out_fd == -1) {
        {
#line 1172
        tunnel->out_fd = s;
#line 1174
        tunnel_out_setsockopts(tunnel->out_fd);
#line 1176
        sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"HTTP/1.1 200 OK\r\nContent-Length: %d\r\nConnection: close\r\nPragma: no-cache\r\nCache-Control: no-cache, no-store, must-revalidate\r\nExpires: 0\r\nContent-Type: text/html\r\n\r\n",
                tunnel->content_length + 1U);
#line 1192
        tmp___14 = strlen((char const   *)(str));
#line 1192
        tmp___15 = write_all(tunnel->out_fd, (void *)(str), tmp___14);
        }
#line 1192
        if (tmp___15 <= 0) {
          {
#line 1194
          tmp___12 = __errno_location();
#line 1194
          tmp___13 = strerror(*tmp___12);
#line 1194
          log_error((char *)"tunnel_accept: couldn\'t write GET header: %s", tmp___13);
#line 1196
          close(tunnel->out_fd);
#line 1197
          tunnel->out_fd = -1;
          }
        } else {
          {
#line 1201
          tunnel->bytes = (size_t )0;
#line 1202
          tunnel->buf_len = (size_t )0;
#line 1203
          tunnel->buf_ptr = tunnel->buf;
#line 1209
          log_verbose("tunnel_accept: output connected");
          }
        }
      } else {
        {
#line 1214
        log_error((char *)"tunnel_accept: rejected tunnel_out: already got a connection");
#line 1216
        close(s);
        }
      }
    } else {
      {
#line 1221
      log_error((char *)"tunnel_accept: unknown header type");
#line 1222
      log_verbose("tunnel_accept: closing connection");
#line 1223
      close(s);
      }
    }
    {
#line 1226
    http_destroy_request(request);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  if (tunnel->in_fd == -1) {
#line 1229
    goto _L___0;
  } else
#line 1229
  if (tunnel->out_fd == -1) {
    _L___0: /* CIL Label */ 
    {
#line 1231
    log_error((char *)"tunnel_accept: in_fd = %d, out_fd = %d", tunnel->in_fd, tunnel->out_fd);
    }
#line 1234
    if (tunnel->in_fd != -1) {
      {
#line 1235
      close(tunnel->in_fd);
      }
    }
    {
#line 1236
    tunnel->in_fd = -1;
#line 1237
    log_verbose("tunnel_accept: input disconnected");
#line 1239
    tunnel_out_disconnect(tunnel);
    }
#line 1241
    return (-1);
  }
#line 1244
  return (0);
}
}
#line 1247 "tunnel.c"
Tunnel *tunnel_new_server(char const   *host , int port , size_t content_length ) 
{ 
  Tunnel *tunnel ;
  struct in_addr addr ;
  struct hostent *hp ;
  void *tmp ;

  {
#line 1254
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1255
    addr.s_addr = (in_addr_t )0;
  } else {
    {
#line 1256
    addr.s_addr = inet_addr(host);
    }
#line 1256
    if (addr.s_addr == 4294967295U) {
      {
#line 1258
      hp = gethostbyname(host);
      }
#line 1259
      if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 1260
        return ((Tunnel *)((void *)0));
      } else
#line 1259
      if (hp->h_addrtype != 2) {
#line 1260
        return ((Tunnel *)((void *)0));
      }
      {
#line 1261
      memcpy((void */* __restrict  */)(& addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
             (size_t )hp->h_length);
      }
    }
  }
  {
#line 1264
  tmp = malloc((size_t )sizeof(Tunnel ));
#line 1264
  tunnel = (Tunnel *)tmp;
  }
#line 1265
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
#line 1266
    return ((Tunnel *)((void *)0));
  }
#line 1270
  if (content_length == 0U) {
#line 1271
    content_length = (size_t )102400;
  }
  {
#line 1273
  tunnel->in_fd = -1;
#line 1274
  tunnel->out_fd = -1;
#line 1275
  tunnel->server_socket = -1;
#line 1276
  tunnel->dest.host_name = host;
#line 1277
  tunnel->dest.host_port = port;
#line 1278
  tunnel->buf_ptr = tunnel->buf;
#line 1279
  tunnel->buf_len = (size_t )0;
#line 1281
  tunnel->content_length = content_length - 1U;
#line 1282
  tunnel->in_total_raw = (size_t )0;
#line 1283
  tunnel->in_total_data = (size_t )0;
#line 1284
  tunnel->out_total_raw = (size_t )0;
#line 1285
  tunnel->out_total_data = (size_t )0;
#line 1286
  tunnel->strict_content_length = 0;
#line 1287
  tunnel->bytes = (size_t )0;
#line 1289
  tunnel->server_socket = server_socket(addr, tunnel->dest.host_port, 1);
  }
#line 1290
  if (tunnel->server_socket == -1) {
    {
#line 1292
    log_error((char *)"tunnel_new_server: server_socket (%d) = -1", tunnel->dest.host_port);
#line 1294
    tunnel_destroy(tunnel);
    }
#line 1295
    return ((Tunnel *)((void *)0));
  }
#line 1298
  return (tunnel);
}
}
#line 1301 "tunnel.c"
Tunnel *tunnel_new_client(char const   *host , int host_port , char const   *proxy ,
                          int proxy_port , size_t content_length ) 
{ 
  char const   *remote ;
  int remote_port ;
  Tunnel *tunnel ;
  char const   *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1310
  if (proxy) {
#line 1310
    tmp = proxy;
  } else {
#line 1310
    tmp = "(null)";
  }
  {
#line 1310
  log_verbose("tunnel_new_client (\"%s\", %d, \"%s\", %d, %d)", host, host_port, tmp,
              proxy_port, content_length);
#line 1314
  tmp___0 = malloc((size_t )sizeof(Tunnel ));
#line 1314
  tunnel = (Tunnel *)tmp___0;
  }
#line 1315
  if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
    {
#line 1317
    log_error((char *)"tunnel_new_client: out of memory");
    }
#line 1318
    return ((Tunnel *)((void *)0));
  }
#line 1321
  tunnel->in_fd = -1;
#line 1322
  tunnel->out_fd = -1;
#line 1323
  tunnel->server_socket = -1;
#line 1324
  tunnel->dest.host_name = host;
#line 1325
  tunnel->dest.host_port = host_port;
#line 1326
  tunnel->dest.proxy_name = proxy;
#line 1327
  tunnel->dest.proxy_port = proxy_port;
#line 1328
  tunnel->dest.proxy_authorization = (char const   *)((void *)0);
#line 1329
  tunnel->dest.user_agent = (char const   *)((void *)0);
#line 1331
  tunnel->content_length = content_length - 1U;
#line 1332
  tunnel->buf_ptr = tunnel->buf;
#line 1333
  tunnel->buf_len = (size_t )0;
#line 1334
  tunnel->in_total_raw = (size_t )0;
#line 1335
  tunnel->in_total_data = (size_t )0;
#line 1336
  tunnel->out_total_raw = (size_t )0;
#line 1337
  tunnel->out_total_data = (size_t )0;
#line 1338
  tunnel->strict_content_length = 0;
#line 1339
  tunnel->bytes = (size_t )0;
#line 1341
  if ((unsigned long )tunnel->dest.proxy_name == (unsigned long )((void *)0)) {
#line 1343
    remote = tunnel->dest.host_name;
#line 1344
    remote_port = tunnel->dest.host_port;
  } else {
#line 1348
    remote = tunnel->dest.proxy_name;
#line 1349
    remote_port = tunnel->dest.proxy_port;
  }
  {
#line 1352
  tmp___3 = set_address(& tunnel->address, remote, remote_port);
  }
#line 1352
  if (tmp___3 == -1) {
    {
#line 1354
    tmp___1 = __errno_location();
#line 1354
    tmp___2 = strerror(*tmp___1);
#line 1354
    log_error((char *)"tunnel_new_client: set_address: %s", tmp___2);
#line 1355
    free((void *)tunnel);
    }
#line 1356
    return ((Tunnel *)((void *)0));
  }
#line 1359
  return (tunnel);
}
}
#line 1362 "tunnel.c"
void tunnel_destroy(Tunnel *tunnel ) 
{ 
  int tmp ;

  {
  {
#line 1365
  tmp = tunnel_is_connected(tunnel);
  }
#line 1365
  if (tmp) {
    {
#line 1366
    tunnel_close(tunnel);
    }
  } else
#line 1365
  if (tunnel->in_fd != -1) {
    {
#line 1366
    tunnel_close(tunnel);
    }
  }
#line 1368
  if (tunnel->server_socket != -1) {
    {
#line 1369
    close(tunnel->server_socket);
    }
  }
  {
#line 1371
  free((void *)tunnel);
  }
#line 1372
  return;
}
}
#line 1374 "tunnel.c"
static int tunnel_opt(Tunnel *tunnel , char const   *opt , void *data , int get_flag ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1377
  tmp___6 = strcmp(opt, "strict_content_length");
  }
#line 1377
  if (tmp___6 == 0) {
#line 1379
    if (get_flag) {
#line 1380
      *((int *)data) = tunnel->strict_content_length;
    } else {
#line 1382
      tunnel->strict_content_length = *((int *)data);
    }
  } else {
    {
#line 1384
    tmp___5 = strcmp(opt, "keep_alive");
    }
#line 1384
    if (tmp___5 == 0) {
#line 1386
      if (get_flag) {
#line 1387
        *((int *)data) = tunnel->keep_alive;
      } else {
#line 1389
        tunnel->keep_alive = *((int *)data);
      }
    } else {
      {
#line 1391
      tmp___4 = strcmp(opt, "max_connection_age");
      }
#line 1391
      if (tmp___4 == 0) {
#line 1393
        if (get_flag) {
#line 1394
          *((int *)data) = tunnel->max_connection_age;
        } else {
#line 1396
          tunnel->max_connection_age = *((int *)data);
        }
      } else {
        {
#line 1398
        tmp___3 = strcmp(opt, "proxy_authorization");
        }
#line 1398
        if (tmp___3 == 0) {
#line 1400
          if (get_flag) {
#line 1402
            if ((unsigned long )tunnel->dest.proxy_authorization == (unsigned long )((void *)0)) {
#line 1403
              *((char **)data) = (char *)((void *)0);
            } else {
              {
#line 1405
              *((char **)data) = strdup(tunnel->dest.proxy_authorization);
              }
            }
          } else {
#line 1409
            if ((unsigned long )tunnel->dest.proxy_authorization != (unsigned long )((void *)0)) {
              {
#line 1410
              free((void *)((char *)tunnel->dest.proxy_authorization));
              }
            }
            {
#line 1411
            tmp = strdup((char const   *)((char *)data));
#line 1411
            tunnel->dest.proxy_authorization = (char const   *)tmp;
            }
#line 1412
            if ((unsigned long )tunnel->dest.proxy_authorization == (unsigned long )((void *)0)) {
#line 1413
              return (-1);
            }
          }
        } else {
          {
#line 1416
          tmp___2 = strcmp(opt, "user_agent");
          }
#line 1416
          if (tmp___2 == 0) {
#line 1418
            if (get_flag) {
#line 1420
              if ((unsigned long )tunnel->dest.user_agent == (unsigned long )((void *)0)) {
#line 1421
                *((char **)data) = (char *)((void *)0);
              } else {
                {
#line 1423
                *((char **)data) = strdup(tunnel->dest.user_agent);
                }
              }
            } else {
#line 1427
              if ((unsigned long )tunnel->dest.user_agent != (unsigned long )((void *)0)) {
                {
#line 1428
                free((void *)((char *)tunnel->dest.user_agent));
                }
              }
              {
#line 1429
              tmp___0 = strdup((char const   *)((char *)data));
#line 1429
              tunnel->dest.user_agent = (char const   *)tmp___0;
              }
#line 1430
              if ((unsigned long )tunnel->dest.user_agent == (unsigned long )((void *)0)) {
#line 1431
                return (-1);
              }
            }
          } else {
            {
#line 1436
            tmp___1 = __errno_location();
#line 1436
            *tmp___1 = 22;
            }
#line 1437
            return (-1);
          }
        }
      }
    }
  }
#line 1440
  return (0);
}
}
#line 1443 "tunnel.c"
int tunnel_setopt(Tunnel *tunnel , char const   *opt , void *data ) 
{ 
  int tmp ;

  {
  {
#line 1446
  tmp = tunnel_opt(tunnel, opt, data, 0);
  }
#line 1446
  return (tmp);
}
}
#line 1449 "tunnel.c"
int tunnel_getopt(Tunnel *tunnel , char const   *opt , void *data ) 
{ 
  int tmp ;

  {
  {
#line 1452
  tmp = tunnel_opt(tunnel, opt, data, 1);
  }
#line 1452
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 110 "/usr/include/sys/socket.h"
extern int bind(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 199
extern int listen(int __fd , int __n ) ;
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 612 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 200 "/usr/include/sys/syslog.h"
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 67 "/usr/include/termios.h"
extern int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern int tcsetattr(int __fd , int __optional_actions , struct termios  const  *__termios_p ) ;
#line 390 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 58 "/usr/include/string.h"
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 162
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 44 "common.h"
void log_exit(int status ) ;
#line 60
int open_device(char *device ) ;
#line 61
int handle_device_input(Tunnel *tunnel , int fd , int events ) ;
#line 62
int handle_tunnel_input(Tunnel *tunnel , int fd , int events ) ;
#line 63
void name_and_port(char const   *nameport , char **name , int *port ) ;
#line 64
int atoi_with_postfix(char const   *s_ ) ;
#line 51 "common.c"
void log_exit(int status ) 
{ 


  {
  {
#line 54
  log_notice((char *)"exit with status = %d", status);
#line 55
  exit(status);
  }
}
}
#line 58 "common.c"
void log_notice(char *fmt0  , ...) 
{ 
  va_list ap ;

  {
  {
#line 62
  __builtin_va_start(ap, fmt0);
#line 66
  vsyslog(5, (char const   *)fmt0, ap);
#line 68
  __builtin_va_end(ap);
  }
#line 69
  return;
}
}
#line 71 "common.c"
void log_error(char *fmt0  , ...) 
{ 
  va_list ap ;

  {
  {
#line 75
  __builtin_va_start(ap, fmt0);
#line 79
  vsyslog(3, (char const   *)fmt0, ap);
#line 81
  __builtin_va_end(ap);
  }
#line 82
  return;
}
}
#line 117 "common.c"
int server_socket(struct in_addr addr , int port , int backlog ) 
{ 
  struct sockaddr_in address ;
  int i ;
  int s ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 123
  s = socket(2, 1, 0);
  }
#line 124
  if (s == -1) {
#line 125
    return (-1);
  }
  {
#line 127
  i = 1;
#line 128
  tmp___1 = setsockopt(s, 1, 2, (void const   *)((void *)(& i)), (socklen_t )sizeof(i));
  }
#line 128
  if (tmp___1 == -1) {
    {
#line 130
    tmp = __errno_location();
#line 130
    tmp___0 = strerror(*tmp);
#line 130
    log_error((char *)"server_socket: setsockopt SO_REUSEADDR: %s", tmp___0);
    }
  }
  {
#line 134
  memset((void *)(& address), '\000', (size_t )sizeof(address));
#line 138
  address.sin_family = (sa_family_t )2;
#line 139
  address.sin_port = htons((uint16_t )((short )port));
#line 140
  address.sin_addr = addr;
#line 142
  tmp___2 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& address)), (socklen_t )sizeof(address));
  }
#line 142
  if (tmp___2 == -1) {
    {
#line 144
    close(s);
    }
#line 145
    return (-1);
  }
  {
#line 148
  tmp___3 = listen(s, (int )((unsigned int )backlog));
  }
#line 148
  if (tmp___3 == -1) {
    {
#line 150
    close(s);
    }
#line 151
    return (-1);
  }
#line 154
  return (s);
}
}
#line 157 "common.c"
int set_address(struct sockaddr_in *address , char const   *host , int port ) 
{ 
  struct hostent *ent ;
  unsigned int ip ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  {
#line 160
  memset((void *)address, '\000', (size_t )sizeof(*address));
#line 164
  address->sin_family = (sa_family_t )2;
#line 165
  address->sin_port = htons((u_short )port);
#line 166
  address->sin_addr.s_addr = inet_addr(host);
  }
#line 168
  if (address->sin_addr.s_addr == 4294967295U) {
    {
#line 173
    log_verbose("set_address: gethostbyname (\"%s\")", host);
#line 174
    ent = gethostbyname(host);
#line 175
    log_verbose("set_address: ent = %p", ent);
    }
#line 176
    if ((unsigned long )ent == (unsigned long )((struct hostent *)0)) {
#line 177
      return (-1);
    }
    {
#line 179
    memcpy((void */* __restrict  */)(& address->sin_addr.s_addr), (void const   */* __restrict  */)*(ent->h_addr_list + 0),
           (unsigned int )ent->h_length);
#line 180
    ip = ntohl(address->sin_addr.s_addr);
#line 181
    tmp = ntohl(ip);
#line 181
    tmp___0 = ntohl(ip);
#line 181
    tmp___1 = ntohl(ip);
#line 181
    tmp___2 = ntohl(ip);
#line 181
    log_verbose("set_address: host = %d.%d.%d.%d", tmp___2 >> 24, (tmp___1 >> 16) & 255U,
                (tmp___0 >> 8) & 255U, tmp & 255U);
    }
  }
#line 188
  return (0);
}
}
#line 191 "common.c"
int open_device(char *device ) 
{ 
  struct termios t ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 197
  fd = open((char const   *)device, 2050);
  }
#line 198
  if (fd == -1) {
#line 199
    return (-1);
  }
  {
#line 201
  tmp___1 = tcgetattr(fd, & t);
  }
#line 201
  if (tmp___1 == -1) {
    {
#line 203
    tmp = __errno_location();
    }
#line 203
    if (*tmp == 25) {
#line 204
      return (fd);
    } else {
      {
#line 203
      tmp___0 = __errno_location();
      }
#line 203
      if (*tmp___0 == 22) {
#line 204
        return (fd);
      } else {
#line 206
        return (-1);
      }
    }
  }
  {
#line 208
  t.c_iflag = (tcflag_t )0;
#line 209
  t.c_oflag = (tcflag_t )0;
#line 210
  t.c_lflag = (tcflag_t )0;
#line 211
  tmp___2 = tcsetattr(fd, 0, (struct termios  const  *)(& t));
  }
#line 211
  if (tmp___2 == -1) {
#line 212
    return (-1);
  }
#line 214
  return (fd);
}
}
#line 248 "common.c"
int handle_device_input(Tunnel *tunnel , int fd , int events ) 
{ 
  unsigned char buf[10240] ;
  ssize_t n ;
  ssize_t m ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 254
  if (events & 1) {
    {
#line 256
    n = read(fd, (void *)(buf), (size_t )sizeof(buf));
    }
#line 257
    if (n == 0) {
#line 257
      goto _L;
    } else
#line 257
    if (n == -1) {
      _L: /* CIL Label */ 
#line 259
      if (n == -1) {
        {
#line 259
        tmp___1 = __errno_location();
        }
#line 259
        if (*tmp___1 != 11) {
          {
#line 260
          tmp = __errno_location();
#line 260
          tmp___0 = strerror(*tmp);
#line 260
          log_error((char *)"handle_device_input: read() error: %s", tmp___0);
          }
        }
      }
#line 262
      return (n);
    }
    {
#line 271
    m = tunnel_write(tunnel, (void *)(buf), (size_t )n);
#line 272
    log_verbose("tunnel_write (%p, %p, %d) = %d", tunnel, buf, n, m);
    }
#line 273
    return (m);
  } else
#line 275
  if (events & 16) {
    {
#line 277
    log_error((char *)"handle_device_input: POLLHUP");
#line 278
    sleep(5U);
    }
  } else
#line 280
  if (events & 8) {
    {
#line 281
    log_error((char *)"handle_device_input: POLLERR");
    }
  } else
#line 282
  if (events & 32) {
    {
#line 283
    log_error((char *)"handle_device_input: POLLINVAL");
    }
  } else {
    {
#line 285
    log_error((char *)"handle_device_input: none of the above");
    }
  }
  {
#line 287
  tmp___2 = __errno_location();
#line 287
  *tmp___2 = 5;
  }
#line 288
  return (-1);
}
}
#line 291 "common.c"
int handle_tunnel_input(Tunnel *tunnel , int fd , int events ) 
{ 
  unsigned char buf[10240] ;
  ssize_t n ;
  ssize_t m ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
#line 297
  if (events & 1) {
    {
#line 299
    n = tunnel_read(tunnel, (void *)(buf), (size_t )sizeof(buf));
    }
#line 300
    if (n <= 0) {
      {
#line 302
      log_verbose("handle_tunnel_input: tunnel_read() = %d\n", n);
      }
#line 303
      if (n == -1) {
        {
#line 303
        tmp___1 = __errno_location();
        }
#line 303
        if (*tmp___1 != 11) {
          {
#line 304
          tmp = __errno_location();
#line 304
          tmp___0 = strerror(*tmp);
#line 304
          log_error((char *)"handle_tunnel_input: tunnel_read() error: %s", tmp___0);
          }
        }
      }
#line 306
      return (n);
    }
#line 317
    if (fd) {
#line 317
      tmp___2 = fd;
    } else {
#line 317
      tmp___2 = 0;
    }
    {
#line 317
    m = write_all(tmp___2, (void *)(buf), (size_t )n);
    }
#line 318
    if (fd) {
#line 318
      tmp___3 = fd;
    } else {
#line 318
      tmp___3 = 1;
    }
    {
#line 318
    log_verbose("write_all (%d, %p, %d) = %d", tmp___3, buf, n, m);
    }
#line 319
    return (m);
  } else
#line 321
  if (events & 16) {
    {
#line 322
    log_error((char *)"handle_device_input: POLLHUP");
    }
  } else
#line 323
  if (events & 8) {
    {
#line 324
    log_error((char *)"handle_device_input: PULLERR");
    }
  } else
#line 325
  if (events & 32) {
    {
#line 326
    log_error((char *)"handle_device_input: PULLINVAL");
    }
  } else {
    {
#line 328
    log_error((char *)"handle_device_input: none of the above");
    }
  }
  {
#line 330
  tmp___4 = __errno_location();
#line 330
  *tmp___4 = 5;
  }
#line 331
  return (-1);
}
}
#line 334 "common.c"
void name_and_port(char const   *nameport , char **name , int *port ) 
{ 
  char *p ;

  {
  {
#line 339
  *name = strdup(nameport);
  }
#line 340
  if ((unsigned long )*name == (unsigned long )((void *)0)) {
    {
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
#line 343
    exit(1);
    }
  }
  {
#line 346
  p = strchr((char const   *)*name, ':');
  }
#line 347
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 349
    *port = atoi((char const   *)(p + 1));
#line 350
    *p = (char )'\000';
    }
  }
#line 352
  return;
}
}
#line 354 "common.c"
int atoi_with_postfix(char const   *s_ ) 
{ 
  char *s ;
  char *tmp ;
  int n ;
  size_t tmp___0 ;
  int factor ;
  int x ;
  int tmp___1 ;

  {
  {
#line 357
  tmp = strdup(s_);
#line 357
  s = tmp;
#line 358
  tmp___0 = strlen((char const   *)s);
#line 358
  n = (int )tmp___0;
#line 359
  factor = 1;
  }
#line 362
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
#line 365
    exit(1);
    }
  }
  {
#line 371
  if ((int )*(s + (n - 1)) == 57) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 56) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 55) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 54) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 53) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 52) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 51) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 50) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 49) {
#line 371
    goto case_57;
  }
#line 371
  if ((int )*(s + (n - 1)) == 48) {
#line 371
    goto case_57;
  }
#line 374
  if ((int )*(s + (n - 1)) == 75) {
#line 374
    goto case_75;
  }
#line 374
  if ((int )*(s + (n - 1)) == 107) {
#line 374
    goto case_75;
  }
#line 377
  if ((int )*(s + (n - 1)) == 77) {
#line 377
    goto case_77;
  }
#line 380
  if ((int )*(s + (n - 1)) == 71) {
#line 380
    goto case_71;
  }
#line 383
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 372
  goto switch_break;
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 375
  factor = 1024;
#line 376
  goto switch_break;
  case_77: /* CIL Label */ 
#line 378
  factor = 1048576;
#line 379
  goto switch_break;
  case_71: /* CIL Label */ 
#line 381
  factor = 1073741824;
#line 382
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 384
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown postfix: %c\n",
          (int )*(s + (n - 1)));
#line 385
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 388
  if (factor != 1) {
#line 389
    *(s + (n - 1)) = (char )'\000';
  }
  {
#line 391
  tmp___1 = atoi((char const   *)s);
#line 391
  x = factor * tmp___1;
#line 392
  free((void *)s);
  }
#line 393
  return (x);
}
}
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 469 "/usr/include/unistd.h"
extern int dup2(int __fd , int __fd2 ) ;
#line 37 "port/getopt.h"
extern char *optarg ;
#line 51
extern int optind ;
#line 112
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 837 "/usr/include/unistd.h"
extern int daemon(int __nochdir , int __noclose ) ;
#line 90 "/usr/include/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 207 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern int fstat(int __fd , struct stat *__statbuf ) ;
#line 235
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 319
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 320
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 322
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 359
  return (tmp);
}
}
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 379
  return (tmp);
}
}
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 89
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 181 "/usr/include/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 41 "common.h"
int debug_level ;
#line 42
FILE *debug_file ;
#line 149 "common.h"
__inline static void handle_input(char const   *type , Tunnel *tunnel , int fd , int events ,
                                  int (*handler)(Tunnel *tunnel , int fd , int events ) ,
                                  int *closed ) 
{ 
  ssize_t n ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 154
  if (events) {
    {
#line 158
    n = (*handler)(tunnel, fd, events);
    }
#line 159
    if (n == 0) {
#line 159
      goto _L;
    } else
#line 159
    if (n == -1) {
      {
#line 159
      tmp___1 = __errno_location();
      }
#line 159
      if (*tmp___1 != 11) {
        _L: /* CIL Label */ 
#line 161
        if (n == 0) {
          {
#line 162
          log_verbose("%s closed", type);
          }
        } else {
          {
#line 164
          tmp = __errno_location();
#line 164
          tmp___0 = strerror(*tmp);
#line 164
          log_error((char *)"%s read error: %s", type, tmp___0);
          }
        }
#line 165
        *closed = 1;
      }
    }
  }
#line 168
  return;
}
}
#line 48 "htc.c"
int debug_level  =    0;
#line 49 "htc.c"
FILE *debug_file  =    (FILE *)((void *)0);
#line 51 "htc.c"
static void usage(FILE *f , char const   *me ) 
{ 


  {
  {
#line 54
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Usage: %s [OPTION]... HOST[:PORT]\nSet up a httptunnel connection to PORT at HOST (default port is %d).\nWhen a connection is made, I/O is redirected from the source specified\nby the --device, --forward-port or --stdin-stdout switch to the tunnel.\n\n  -A, --proxy-authorization USER:PASSWORD  proxy authorization\n  -z, --proxy-authorization-file FILE      proxy authorization file\n  -B, --proxy-buffer-size BYTES  assume a proxy buffer size of BYTES bytes\n                                 (k, M, and G postfixes recognized)\n  -c, --content-length BYTES     use HTTP PUT requests of BYTES size\n                                 (k, M, and G postfixes recognized)\n  -d, --device DEVICE            use DEVICE for input and output\n  -F, --forward-port PORT        use TCP port PORT for input and output\n  -h, --help                     display this help and exit\n  -k, --keep-alive SECONDS       send keepalive bytes every SECONDS seconds\n                                 (default is %d)\n  -M, --max-connection-age SEC   maximum time a connection will stay\n                                 open is SEC seconds (default is %d)\n  -P, --proxy HOSTNAME[:PORT]    use a HTTP proxy (default port is %d)\n  -s, --stdin-stdout             use stdin/stdout for communication\n                                 (implies --no-daemon)\n  -S, --strict-content-length    always write Content-Length bytes in requests\n  -T, --timeout TIME             timeout, in milliseconds, before sending\n                                 padding to a buffering proxy\n  -U, --user-agent STRING        specify User-Agent value in HTTP requests\n  -V, --version                  output version information and exit\n  -w, --no-daemon                don\'t fork into the background\n\nReport bugs to %s.\n",
          me, 8888, 5, 300, 8080, "bug-httptunnel@gnu.org");
  }
#line 93
  return;
}
}
#line 95 "htc.c"
static int wait_for_connection_on_socket(int s ) 
{ 
  struct sockaddr addr ;
  socklen_t len ;
  int t ;

  {
  {
#line 102
  len = (socklen_t )sizeof(addr);
#line 103
  t = accept(s, (struct sockaddr */* __restrict  */)(& addr), (socklen_t */* __restrict  */)(& len));
  }
#line 104
  if (t == -1) {
#line 105
    return (-1);
  }
#line 107
  return (t);
}
}
#line 138
static void parse_arguments(int argc , char **argv , Arguments *arg ) ;
#line 138 "htc.c"
static struct option long_options[17]  = 
#line 138
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"no-daemon", 0, (int *)0, 'w'}, 
        {"stdin-stdout", 0, (int *)0, 's'}, 
        {"proxy", 1, (int *)0, 'P'}, 
        {"device", 1, (int *)0, 'd'}, 
        {"timeout", 1, (int *)0, 'T'}, 
        {"keep-alive", 1, (int *)0, 'k'}, 
        {"user-agent", 1, (int *)0, 'U'}, 
        {"forward-port", 1, (int *)0, 'F'}, 
        {"content-length", 1, (int *)0, 'c'}, 
        {"strict-content-length", 0, (int *)0, 'S'}, 
        {"proxy-buffer-size", 1, (int *)0, 'B'}, 
        {"proxy-authorization", 1, (int *)0, 'A'}, 
        {"max-connection-age", 1, (int *)0, 'M'}, 
        {"proxy-authorization-file", 1, (int *)0, 'z'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 163 "htc.c"
static char const   *short_options  =    "A:B:c:d:F:hk:M:P:sST:U:Vwz:";
#line 110 "htc.c"
static void parse_arguments(int argc , char **argv , Arguments *arg ) 
{ 
  int c ;
  int option_index ;
  int tmp ;
  int tmp___0 ;
  struct stat s ;
  char *auth ;
  int f ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;
  int tmp___10 ;

  {
#line 117
  arg->me = *(argv + 0);
#line 118
  arg->device = (char *)((void *)0);
#line 119
  arg->forward_port = -1;
#line 120
  arg->host_name = (char *)((void *)0);
#line 121
  arg->host_port = 8888;
#line 122
  arg->proxy_name = (char *)((void *)0);
#line 123
  arg->proxy_port = 8080;
#line 124
  arg->proxy_buffer_size = (size_t )0;
#line 125
  arg->proxy_buffer_timeout = -1;
#line 126
  arg->content_length = (size_t )102400;
#line 127
  arg->use_std = 0;
#line 128
  arg->use_daemon = 1;
#line 129
  arg->strict_content_length = 0;
#line 130
  arg->keep_alive = 5;
#line 131
  arg->max_connection_age = 300;
#line 132
  arg->proxy_authorization = (char *)((void *)0);
#line 133
  arg->user_agent = (char *)((void *)0);
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 137
    option_index = 0;
#line 169
    c = getopt_long(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                    & option_index);
    }
#line 171
    if (c == -1) {
#line 172
      goto while_break;
    }
    {
#line 176
    if (c == 0) {
#line 176
      goto case_0;
    }
#line 183
    if (c == 65) {
#line 183
      goto case_65;
    }
#line 187
    if (c == 66) {
#line 187
      goto case_66;
    }
#line 191
    if (c == 99) {
#line 191
      goto case_99;
    }
#line 195
    if (c == 100) {
#line 195
      goto case_100;
    }
#line 218
    if (c == 70) {
#line 218
      goto case_70;
    }
#line 222
    if (c == 107) {
#line 222
      goto case_107;
    }
#line 226
    if (c == 77) {
#line 226
      goto case_77;
    }
#line 230
    if (c == 104) {
#line 230
      goto case_104;
    }
#line 234
    if (c == 80) {
#line 234
      goto case_80;
    }
#line 242
    if (c == 115) {
#line 242
      goto case_115;
    }
#line 247
    if (c == 83) {
#line 247
      goto case_83;
    }
#line 251
    if (c == 84) {
#line 251
      goto case_84;
    }
#line 255
    if (c == 85) {
#line 255
      goto case_85;
    }
#line 259
    if (c == 86) {
#line 259
      goto case_86;
    }
#line 263
    if (c == 119) {
#line 263
      goto case_119;
    }
#line 267
    if (c == 122) {
#line 267
      goto case_122;
    }
#line 314
    if (c == 63) {
#line 314
      goto case_63;
    }
#line 317
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 177
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"option %s",
            long_options[option_index].name);
    }
#line 178
    if (optarg) {
      {
#line 179
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" with arg %s",
              optarg);
      }
    }
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 181
    goto switch_break;
    case_65: /* CIL Label */ 
#line 184
    arg->proxy_authorization = optarg;
#line 185
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 188
    tmp = atoi_with_postfix((char const   *)optarg);
#line 188
    arg->proxy_buffer_size = (size_t )tmp;
    }
#line 189
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 192
    tmp___0 = atoi_with_postfix((char const   *)optarg);
#line 192
    arg->content_length = (size_t )tmp___0;
    }
#line 193
    goto switch_break;
    case_100: /* CIL Label */ 
#line 196
    arg->device = optarg;
#line 197
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 219
    arg->forward_port = atoi((char const   *)optarg);
    }
#line 220
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 223
    arg->keep_alive = atoi((char const   *)optarg);
    }
#line 224
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 227
    arg->max_connection_age = atoi((char const   *)optarg);
    }
#line 228
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 231
    usage(stdout, (char const   *)arg->me);
#line 232
    exit(0);
    }
    case_80: /* CIL Label */ 
    {
#line 235
    name_and_port((char const   *)optarg, & arg->proxy_name, & arg->proxy_port);
    }
#line 236
    if (arg->proxy_port == -1) {
#line 237
      arg->proxy_port = 8080;
    }
#line 238
    if (arg->proxy_buffer_timeout == -1) {
#line 239
      arg->proxy_buffer_timeout = 500;
    }
#line 240
    goto switch_break;
    case_115: /* CIL Label */ 
#line 243
    arg->use_std = 1;
#line 244
    arg->use_daemon = 0;
#line 245
    goto switch_break;
    case_83: /* CIL Label */ 
#line 248
    arg->strict_content_length = 1;
#line 249
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 252
    arg->proxy_buffer_timeout = atoi((char const   *)optarg);
    }
#line 253
    goto switch_break;
    case_85: /* CIL Label */ 
#line 256
    arg->user_agent = optarg;
#line 257
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 260
    printf((char const   */* __restrict  */)"htc (%s) %s\n", "httptunnel", "3.3");
#line 261
    exit(0);
    }
    case_119: /* CIL Label */ 
#line 264
    arg->use_daemon = 0;
#line 265
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 273
    f = open((char const   *)optarg, 0);
    }
#line 274
    if (f == -1) {
      {
#line 276
      tmp___1 = __errno_location();
#line 276
      tmp___2 = strerror(*tmp___1);
#line 276
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t open %s: %s\n",
              optarg, tmp___2);
#line 277
      exit(1);
      }
    }
    {
#line 280
    tmp___5 = fstat(f, & s);
    }
#line 280
    if (tmp___5 == -1) {
      {
#line 282
      tmp___3 = __errno_location();
#line 282
      tmp___4 = strerror(*tmp___3);
#line 282
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error fstating %s: %s\n",
              optarg, tmp___4);
#line 283
      exit(1);
      }
    }
    {
#line 286
    tmp___6 = malloc((size_t )(s.st_size + 1L));
#line 286
    auth = (char *)tmp___6;
    }
#line 287
    if ((unsigned long )auth == (unsigned long )((void *)0)) {
      {
#line 289
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory whilst allocating authentication string\n");
#line 291
      exit(1);
      }
    }
    {
#line 294
    tmp___9 = read_all(f, (void *)auth, (size_t )s.st_size);
    }
#line 294
    if (tmp___9 == -1) {
      {
#line 296
      tmp___7 = __errno_location();
#line 296
      tmp___8 = strerror(*tmp___7);
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error reading %s: %s\n",
              optarg, tmp___8);
#line 297
      exit(1);
      }
    }
#line 303
    if (s.st_size >= 1L) {
#line 303
      if ((int )*(auth + (s.st_size - 1L)) == 10) {
#line 305
        if (s.st_size >= 2L) {
#line 305
          if ((int )*(auth + (s.st_size - 2L)) == 13) {
#line 305
            tmp___10 = 2;
          } else {
#line 305
            tmp___10 = 1;
          }
        } else {
#line 305
          tmp___10 = 1;
        }
#line 305
        s.st_size -= (__off_t )tmp___10;
      }
    }
#line 309
    *(auth + s.st_size) = (char)0;
#line 310
    arg->proxy_authorization = auth;
#line 312
    goto switch_break;
    case_63: /* CIL Label */ 
#line 315
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 318
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"?? getopt returned character code 0%o ??\n",
            c);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (optind == argc - 1) {
    {
#line 324
    name_and_port((char const   *)*(argv + optind), & arg->host_name, & arg->host_port);
    }
#line 325
    if (arg->host_port == -1) {
#line 326
      arg->host_port = 8888;
    }
  } else {
    {
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: the destination of the tunnel must be specified.\n%s: try \'%s --help\' for help.\n",
            arg->me, arg->me, arg->me);
#line 333
    exit(1);
    }
  }
#line 336
  if ((unsigned long )arg->device == (unsigned long )((void *)0)) {
#line 336
    if (arg->forward_port == -1) {
#line 336
      if (! arg->use_std) {
        {
#line 338
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: one of --device, --forward-port or --stdin-stdout must be used.\n%s: try \'%s -help\' for help.\n",
                arg->me, arg->me, arg->me);
#line 341
        exit(1);
        }
      }
    }
  }
#line 344
  if ((unsigned long )arg->device != (unsigned long )((void *)0)) {
#line 344
    if (arg->forward_port != -1) {
      {
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: only one of --device, --forward-port or --stdin-stdout can be used.\n%s: try \'%s --help\' for help.\n",
              arg->me, arg->me, arg->me);
#line 351
      exit(1);
      }
    } else {
#line 344
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 344
  if ((unsigned long )arg->device != (unsigned long )((void *)0)) {
#line 344
    if (arg->use_std) {
      {
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: only one of --device, --forward-port or --stdin-stdout can be used.\n%s: try \'%s --help\' for help.\n",
              arg->me, arg->me, arg->me);
#line 351
      exit(1);
      }
    } else {
#line 344
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 344
  if (arg->forward_port != -1) {
#line 344
    if (arg->use_std) {
      {
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: only one of --device, --forward-port or --stdin-stdout can be used.\n%s: try \'%s --help\' for help.\n",
              arg->me, arg->me, arg->me);
#line 351
      exit(1);
      }
    }
  }
#line 356
  if ((unsigned long )arg->host_name == (unsigned long )((void *)0)) {
    {
#line 360
    usage(stderr, (char const   *)arg->me);
#line 361
    exit(1);
    }
  } else
#line 356
  if (arg->host_port == -1) {
    {
#line 360
    usage(stderr, (char const   *)arg->me);
#line 361
    exit(1);
    }
  } else
#line 356
  if ((unsigned long )arg->proxy_name != (unsigned long )((void *)0)) {
#line 356
    if (arg->proxy_port == -1) {
      {
#line 360
      usage(stderr, (char const   *)arg->me);
#line 361
      exit(1);
      }
    }
  }
#line 364
  if (debug_level == 0) {
#line 364
    if ((unsigned long )debug_file != (unsigned long )((void *)0)) {
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: --logfile can\'t be used without debugging\n",
              arg->me);
#line 368
      exit(1);
      }
    }
  }
#line 371
  if ((unsigned long )arg->proxy_name == (unsigned long )((void *)0)) {
#line 373
    if (arg->proxy_buffer_size != 0U) {
      {
#line 375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: --proxy-buffer-size can\'t be used without --proxy\n",
              arg->me);
#line 377
      arg->proxy_buffer_size = (size_t )0;
      }
    }
#line 380
    if (arg->proxy_buffer_timeout != -1) {
      {
#line 382
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: --proxy-buffer-timeout can\'t be used without --proxy\n",
              arg->me);
#line 384
      arg->proxy_buffer_timeout = -1;
      }
    }
#line 387
    if ((unsigned long )arg->proxy_authorization != (unsigned long )((void *)0)) {
      {
#line 389
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: --proxy-authorization can\'t be used without --proxy\n",
              arg->me);
#line 391
      arg->proxy_authorization = (char *)((void *)0);
      }
    }
  } else
#line 394
  if (arg->proxy_buffer_size == 0U) {
#line 395
    arg->proxy_buffer_timeout = -1;
  }
#line 396
  return;
}
}
#line 398 "htc.c"
int main(int argc , char **argv ) 
{ 
  int s ;
  int fd ;
  Arguments arg ;
  Tunnel *tunnel ;
  int closed ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  struct in_addr addr ;
  int *tmp___4 ;
  char *tmp___5 ;
  time_t last_tunnel_write ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  ssize_t len ;
  char *auth ;
  size_t tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  char *str ;
  void *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  struct pollfd pollfd[2] ;
  int keep_alive_timeout ;
  int timeout ;
  time_t t ;
  int n ;
  int *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;

  {
  {
#line 401
  s = -1;
#line 402
  fd = -1;
#line 407
  parse_arguments(argc, argv, & arg);
  }
#line 409
  if (debug_level == 0) {
#line 409
    goto _L;
  } else
#line 409
  if ((unsigned long )debug_file != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 409
    if (arg.use_daemon) {
      {
#line 410
      daemon(0, 1);
      }
    }
  }
  {
#line 416
  openlog("htc", 1, 3 << 3);
#line 419
  log_notice((char *)"htc (%s) %s started with arguments:", "httptunnel", "3.3");
#line 420
  log_notice((char *)"  me = %s", arg.me);
  }
#line 421
  if (arg.device) {
#line 421
    tmp = (char const   *)arg.device;
  } else {
#line 421
    tmp = "(null)";
  }
  {
#line 421
  log_notice((char *)"  device = %s", tmp);
  }
#line 422
  if (arg.host_name) {
#line 422
    tmp___0 = (char const   *)arg.host_name;
  } else {
#line 422
    tmp___0 = "(null)";
  }
  {
#line 422
  log_notice((char *)"  host_name = %s", tmp___0);
#line 423
  log_notice((char *)"  host_port = %d", arg.host_port);
  }
#line 424
  if (arg.proxy_name) {
#line 424
    tmp___1 = (char const   *)arg.proxy_name;
  } else {
#line 424
    tmp___1 = "(null)";
  }
  {
#line 424
  log_notice((char *)"  proxy_name = %s", tmp___1);
#line 425
  log_notice((char *)"  proxy_port = %d", arg.proxy_port);
#line 426
  log_notice((char *)"  proxy_buffer_size = %d", arg.proxy_buffer_size);
#line 427
  log_notice((char *)"  proxy_buffer_timeout = %d", arg.proxy_buffer_timeout);
#line 428
  log_notice((char *)"  content_length = %d", arg.content_length);
#line 429
  log_notice((char *)"  forward_port = %d", arg.forward_port);
#line 430
  log_notice((char *)"  max_connection_age = %d", arg.max_connection_age);
#line 431
  log_notice((char *)"  use_std = %d", arg.use_std);
#line 432
  log_notice((char *)"  strict_content_length = %d", arg.strict_content_length);
#line 433
  log_notice((char *)"  keep_alive = %d", arg.keep_alive);
  }
#line 434
  if (arg.proxy_authorization) {
#line 434
    tmp___2 = (char const   *)arg.proxy_authorization;
  } else {
#line 434
    tmp___2 = "(null)";
  }
  {
#line 434
  log_notice((char *)"  proxy_authorization = %s", tmp___2);
  }
#line 436
  if (arg.user_agent) {
#line 436
    tmp___3 = (char const   *)arg.user_agent;
  } else {
#line 436
    tmp___3 = "(null)";
  }
  {
#line 436
  log_notice((char *)"  user_agent = %s", tmp___3);
#line 437
  log_notice((char *)"  debug_level = %d", debug_level);
  }
#line 440
  if (arg.forward_port != -1) {
    {
#line 444
    addr.s_addr = (in_addr_t )0;
#line 445
    s = server_socket(addr, arg.forward_port, 0);
#line 446
    log_verbose("server_socket (%d) = %d", arg.forward_port, s);
    }
#line 447
    if (s == -1) {
      {
#line 449
      tmp___4 = __errno_location();
#line 449
      tmp___5 = strerror(*tmp___4);
#line 449
      log_error((char *)"couldn\'t create server socket: %s", tmp___5);
#line 450
      log_exit(1);
      }
    }
  }
  {
#line 457
  signal(13, (void (*)(int  ))1);
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (arg.device) {
      {
#line 466
      fd = open_device(arg.device);
#line 467
      log_verbose("open_device (\"%s\") = %d", arg.device, fd);
      }
#line 468
      if (fd == -1) {
        {
#line 470
        tmp___6 = __errno_location();
#line 470
        tmp___7 = strerror(*tmp___6);
#line 470
        log_error((char *)"couldn\'t open %s: %s", arg.device, tmp___7);
#line 472
        log_exit(1);
        }
      }
#line 475
      if (fd == 0) {
        {
#line 477
        log_notice((char *)"changing fd from %d to 3", fd);
#line 478
        tmp___10 = dup2(fd, 3);
        }
#line 478
        if (tmp___10 != 3) {
          {
#line 480
          tmp___8 = __errno_location();
#line 480
          tmp___9 = strerror(*tmp___8);
#line 480
          log_error((char *)"couldn\'t dup2(%d,3): %s", fd, tmp___9);
#line 481
          log_exit(1);
          }
        }
      }
    } else
#line 485
    if (arg.forward_port != -1) {
      {
#line 487
      log_verbose("waiting for connection on port %d", arg.forward_port);
#line 488
      fd = wait_for_connection_on_socket(s);
#line 489
      log_verbose("wait_for_connection_on_socket (%d) = %d", s, fd);
      }
#line 490
      if (fd == -1) {
        {
#line 492
        tmp___11 = __errno_location();
#line 492
        tmp___12 = strerror(*tmp___11);
#line 492
        log_error((char *)"couldn\'t forward port %d: %s", arg.forward_port, tmp___12);
#line 494
        log_exit(1);
        }
      }
#line 497
      if (fd == 0) {
        {
#line 499
        log_notice((char *)"changing fd from %d to 3", fd);
#line 500
        tmp___15 = dup2(fd, 3);
        }
#line 500
        if (tmp___15 != 3) {
          {
#line 502
          tmp___13 = __errno_location();
#line 502
          tmp___14 = strerror(*tmp___13);
#line 502
          log_error((char *)"couldn\'t dup2(%d,3): %s", fd, tmp___14);
#line 503
          log_exit(1);
          }
        }
      }
    } else
#line 506
    if (arg.use_std) {
      {
#line 507
      log_verbose("using stdin as fd");
#line 508
      fd = 0;
#line 509
      tmp___18 = fcntl(fd, 4, 2048);
      }
#line 509
      if (tmp___18 == -1) {
        {
#line 511
        tmp___16 = __errno_location();
#line 511
        tmp___17 = strerror(*tmp___16);
#line 511
        log_error((char *)"couldn\'t set stdin to non-blocking mode: %s", tmp___17);
#line 513
        log_exit(1);
        }
      }
    }
    {
#line 518
    log_verbose("creating a new tunnel");
#line 519
    tunnel = tunnel_new_client((char const   *)arg.host_name, arg.host_port, (char const   *)arg.proxy_name,
                               arg.proxy_port, arg.content_length);
    }
#line 522
    if ((unsigned long )tunnel == (unsigned long )((void *)0)) {
      {
#line 524
      log_error((char *)"couldn\'t create tunnel");
#line 525
      log_exit(1);
      }
    }
    {
#line 528
    tmp___21 = tunnel_setopt(tunnel, "strict_content_length", (void *)(& arg.strict_content_length));
    }
#line 528
    if (tmp___21 == -1) {
      {
#line 530
      tmp___19 = __errno_location();
#line 530
      tmp___20 = strerror(*tmp___19);
#line 530
      log_verbose("tunnel_setopt strict_content_length error: %s", tmp___20);
      }
    }
    {
#line 533
    tmp___24 = tunnel_setopt(tunnel, "keep_alive", (void *)(& arg.keep_alive));
    }
#line 533
    if (tmp___24 == -1) {
      {
#line 535
      tmp___22 = __errno_location();
#line 535
      tmp___23 = strerror(*tmp___22);
#line 535
      log_verbose("tunnel_setopt keep_alive error: %s", tmp___23);
      }
    }
    {
#line 537
    tmp___27 = tunnel_setopt(tunnel, "max_connection_age", (void *)(& arg.max_connection_age));
    }
#line 537
    if (tmp___27 == -1) {
      {
#line 539
      tmp___25 = __errno_location();
#line 539
      tmp___26 = strerror(*tmp___25);
#line 539
      log_verbose("tunnel_setopt max_connection_age error: %s", tmp___26);
      }
    }
#line 542
    if ((unsigned long )arg.proxy_authorization != (unsigned long )((void *)0)) {
      {
#line 547
      tmp___28 = strlen((char const   *)arg.proxy_authorization);
#line 547
      len = encode_base64((void const   *)arg.proxy_authorization, tmp___28, & auth);
      }
#line 550
      if (len == -1) {
        {
#line 552
        tmp___29 = __errno_location();
#line 552
        tmp___30 = strerror(*tmp___29);
#line 552
        log_error((char *)"encode_base64 error: %s", tmp___30);
        }
      } else {
        {
#line 556
        tmp___31 = malloc((size_t )(len + 7));
#line 556
        str = (char *)tmp___31;
        }
#line 558
        if ((unsigned long )str == (unsigned long )((void *)0)) {
          {
#line 560
          log_error((char *)"out of memory when encoding authorization string");
#line 562
          log_exit(1);
          }
        }
        {
#line 565
        strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)"Basic ");
#line 566
        strcat((char */* __restrict  */)str, (char const   */* __restrict  */)auth);
#line 567
        free((void *)auth);
#line 569
        tmp___34 = tunnel_setopt(tunnel, "proxy_authorization", (void *)str);
        }
#line 569
        if (tmp___34 == -1) {
          {
#line 570
          tmp___32 = __errno_location();
#line 570
          tmp___33 = strerror(*tmp___32);
#line 570
          log_error((char *)"tunnel_setopt proxy_authorization error: %s", tmp___33);
          }
        }
        {
#line 573
        free((void *)str);
        }
      }
    }
#line 577
    if ((unsigned long )arg.user_agent != (unsigned long )((void *)0)) {
      {
#line 579
      tmp___37 = tunnel_setopt(tunnel, "user_agent", (void *)arg.user_agent);
      }
#line 579
      if (tmp___37 == -1) {
        {
#line 580
        tmp___35 = __errno_location();
#line 580
        tmp___36 = strerror(*tmp___35);
#line 580
        log_error((char *)"tunnel_setopt user_agent error: %s", tmp___36);
        }
      }
    }
    {
#line 584
    tmp___40 = tunnel_connect(tunnel);
    }
#line 584
    if (tmp___40 == -1) {
      {
#line 586
      tmp___38 = __errno_location();
#line 586
      tmp___39 = strerror(*tmp___38);
#line 586
      log_error((char *)"couldn\'t open tunnel: %s", tmp___39);
#line 587
      log_exit(1);
      }
    }
#line 589
    if (arg.proxy_name) {
      {
#line 590
      log_notice((char *)"connected to %s:%d via %s:%d", arg.host_name, arg.host_port,
                 arg.proxy_name, arg.proxy_port);
      }
    } else {
      {
#line 594
      log_notice((char *)"connected to %s:%d", arg.host_name, arg.host_port);
      }
    }
    {
#line 596
    closed = 0;
#line 597
    time(& last_tunnel_write);
    }
    {
#line 598
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 598
      if (! (! closed)) {
#line 598
        goto while_break___0;
      }
      {
#line 606
      pollfd[0].fd = fd;
#line 607
      pollfd[0].events = (short)1;
#line 608
      pollfd[1].fd = tunnel_pollin_fd(tunnel);
#line 609
      pollfd[1].events = (short)1;
#line 611
      time(& t);
#line 612
      timeout = (int )(1000L * ((time_t )arg.keep_alive - (t - last_tunnel_write)));
#line 613
      keep_alive_timeout = 1;
      }
#line 614
      if (timeout < 0) {
#line 615
        timeout = 0;
      }
#line 616
      if (arg.proxy_buffer_timeout != -1) {
#line 616
        if (arg.proxy_buffer_timeout < timeout) {
#line 619
          timeout = arg.proxy_buffer_timeout;
#line 620
          keep_alive_timeout = 0;
        }
      }
      {
#line 623
      log_verbose("poll () ...");
#line 624
      n = poll(pollfd, (nfds_t )2, timeout);
#line 625
      log_verbose("... = %d", n);
      }
#line 626
      if (n == -1) {
        {
#line 628
        tmp___41 = __errno_location();
#line 628
        tmp___42 = strerror(*tmp___41);
#line 628
        log_error((char *)"poll error: %s", tmp___42);
#line 629
        log_exit(1);
        }
      } else
#line 631
      if (n == 0) {
        {
#line 633
        log_verbose("poll() timed out");
        }
#line 634
        if (keep_alive_timeout) {
          {
#line 636
          tunnel_padding(tunnel, (size_t )1);
#line 637
          time(& last_tunnel_write);
          }
        } else {
          {
#line 641
          tmp___43 = tunnel_maybe_pad(tunnel, arg.proxy_buffer_size);
          }
#line 641
          if (tmp___43 > 0) {
            {
#line 642
            time(& last_tunnel_write);
            }
          }
        }
#line 644
        goto while_continue___0;
      }
      {
#line 647
      handle_input("device or port", tunnel, fd, (int )pollfd[0].revents, & handle_device_input,
                   & closed);
#line 649
      handle_input("tunnel", tunnel, fd, (int )pollfd[1].revents, & handle_tunnel_input,
                   & closed);
      }
#line 652
      if ((int )pollfd[0].revents & 1) {
        {
#line 653
        time(& last_tunnel_write);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 656
    log_verbose("destroying tunnel");
    }
#line 657
    if (fd != 0) {
      {
#line 659
      close(fd);
      }
    }
    {
#line 661
    tunnel_destroy(tunnel);
    }
#line 662
    if (arg.proxy_name) {
      {
#line 663
      log_notice((char *)"disconnected from %s:%d via %s:%d", arg.host_name, arg.host_port,
                 arg.proxy_name, arg.proxy_port);
      }
    } else {
      {
#line 667
      log_notice((char *)"disconnected from %s%d", arg.host_name, arg.host_port);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 670
  log_verbose("closing server socket");
#line 671
  close(s);
#line 673
  log_exit(0);
  }
}
}
