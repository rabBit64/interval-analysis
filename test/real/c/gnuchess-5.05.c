/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 56 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 49 "/home/khheo/testset/chess/src/common.h"
typedef uint64_t BitBoard;
#line 53 "/home/khheo/testset/chess/src/common.h"
struct __anonstruct_Board_38 {
   BitBoard b[2][7] ;
   BitBoard friends[2] ;
   BitBoard blocker ;
   BitBoard blockerr90 ;
   BitBoard blockerr45 ;
   BitBoard blockerr315 ;
   int ep ;
   int flag ;
   int side ;
   int material[2] ;
   int pmaterial[2] ;
   int castled[2] ;
   int king[2] ;
};
#line 53 "/home/khheo/testset/chess/src/common.h"
typedef struct __anonstruct_Board_38 Board;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 50 "/home/khheo/testset/chess/src/common.h"
typedef uint64_t HashType;
#line 51 "/home/khheo/testset/chess/src/common.h"
typedef uint32_t KeyType;
#line 89 "/home/khheo/testset/chess/src/common.h"
struct __anonstruct_HashSlot_9 {
   KeyType key ;
   int move ;
   int score ;
   int flag ;
   int depth ;
};
#line 89 "/home/khheo/testset/chess/src/common.h"
typedef struct __anonstruct_HashSlot_9 HashSlot;
#line 98 "/home/khheo/testset/chess/src/common.h"
struct __anonstruct_PawnSlot_10 {
   KeyType pkey ;
   BitBoard passed ;
   BitBoard weaked ;
   int score ;
   int phase ;
};
#line 98 "/home/khheo/testset/chess/src/common.h"
typedef struct __anonstruct_PawnSlot_10 PawnSlot;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 70 "/home/khheo/testset/chess/src/common.h"
struct __anonstruct_leaf_9 {
   int move ;
   int score ;
};
#line 70 "/home/khheo/testset/chess/src/common.h"
typedef struct __anonstruct_leaf_9 leaf;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 76 "/home/khheo/testset/chess/src/common.h"
struct __anonstruct_GameRec_24 {
   int move ;
   int epsq ;
   int bflag ;
   int Game50 ;
   int mvboard ;
   float et ;
   HashType hashkey ;
   HashType phashkey ;
   char SANmv[8] ;
};
#line 76 "/home/khheo/testset/chess/src/common.h"
typedef struct __anonstruct_GameRec_24 GameRec;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 38 "/home/khheo/testset/chess/src/players.c"
struct __anonstruct_playerentry_29 {
   char player[100] ;
   int wins ;
   int losses ;
   int draws ;
};
#line 38 "/home/khheo/testset/chess/src/players.c"
typedef struct __anonstruct_playerentry_29 playerentry;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 131 "/home/khheo/testset/chess/src/book.c"
struct hashtype {
   uint16_t wins ;
   uint16_t losses ;
   uint16_t draws ;
   HashType key ;
};
#line 480 "/home/khheo/testset/chess/src/book.c"
struct __anonstruct_r_32 {
   uint16_t wins ;
   uint16_t losses ;
   uint16_t draws ;
};
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 311 "/home/khheo/testset/chess/src/common.h"
unsigned int flags ;
#line 640
void ShowVersion(void) ;
#line 29 "/home/khheo/testset/chess/src/version.c"
void ShowVersion(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 31
  if (! (flags & 1024U)) {
    {
    {
#line 32
    printf((char const   */* __restrict  */)"%s %s\n\n", "GNU Chess", "5.05");
    }
    }
  } else {
    {
    {
#line 34
    printf((char const   */* __restrict  */)"Chess\n");
    }
    }
  }
#line 35
  return;
}
}
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 272 "/home/khheo/testset/chess/src/common.h"
int lzArray[65536] ;
#line 278
BitBoard BitPosArray[64] ;
#line 279
BitBoard NotBitPosArray[64] ;
#line 304
int BitCount[65536] ;
#line 312
Board board ;
#line 313
int cboard[64] ;
#line 314
int Mvboard[64] ;
#line 521
int SqAtakd(int sq , int side ) ;
#line 558
void UpdateFriends(void) ;
#line 559
void UpdateCBoard(void) ;
#line 560
void UpdateMvboard(void) ;
#line 561
void EndSearch(int sig  __attribute__((__unused__)) ) ;
#line 562
int ValidateBoard(void) ;
#line 34 "/home/khheo/testset/chess/src/inlines.h"
__inline static int leadz(BitBoard b ) 
{ 


  {
#line 42
  if (b >> 48) {
#line 42
    return (lzArray[b >> 48]);
  }
#line 43
  if (b >> 32) {
#line 43
    return (lzArray[b >> 32] + 16);
  }
#line 44
  if (b >> 16) {
#line 44
    return (lzArray[b >> 16] + 32);
  }
#line 45
  return (lzArray[b] + 48);
}
}
#line 49 "/home/khheo/testset/chess/src/inlines.h"
__inline static int nbits(BitBoard b ) 
{ 


  {
#line 56
  return (((BitCount[b >> 48] + BitCount[(b >> 32) & 65535UL]) + BitCount[(b >> 16) & 65535UL]) + BitCount[b & 65535UL]);
}
}
#line 77 "/home/khheo/testset/chess/src/util.c"
void UpdateFriends(void) 
{ 
  register BitBoard *w ;
  register BitBoard *b ;

  {
#line 86
  w = board.b[0];
#line 87
  b = board.b[1];
#line 88
  board.friends[0] = ((((*(w + 1) | *(w + 2)) | *(w + 3)) | *(w + 4)) | *(w + 5)) | *(w + 6);
#line 90
  board.friends[1] = ((((*(b + 1) | *(b + 2)) | *(b + 3)) | *(b + 4)) | *(b + 5)) | *(b + 6);
#line 92
  board.blocker = board.friends[0] | board.friends[1];
#line 93
  return;
}
}
#line 96 "/home/khheo/testset/chess/src/util.c"
void UpdateCBoard(void) 
{ 
  BitBoard b ;
  int piece ;
  int sq ;

  {
  {
  {
#line 106
  memset((void *)(cboard), 0, sizeof(cboard));
  }
#line 107
  piece = 1;
  }
  {
  {
#line 107
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 107
    if (! (piece <= 6)) {
#line 107
      goto while_break;
    }
#line 109
    b = board.b[0][piece] | board.b[1][piece];
    {
    {
#line 110
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! b) {
#line 110
        goto while_break___0;
      }
      {
      {
#line 112
      sq = leadz(b);
      }
#line 113
      b &= NotBitPosArray[sq];
#line 114
      cboard[sq] = piece;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 107
    piece ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return;
}
}
#line 120 "/home/khheo/testset/chess/src/util.c"
static int const   OrigCboard[64]  = 
#line 120
  {      (int const   )4,      (int const   )2,      (int const   )3,      (int const   )5, 
        (int const   )6,      (int const   )3,      (int const   )2,      (int const   )4, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )4,      (int const   )2,      (int const   )3,      (int const   )5, 
        (int const   )6,      (int const   )3,      (int const   )2,      (int const   )4};
#line 130 "/home/khheo/testset/chess/src/util.c"
void UpdateMvboard(void) 
{ 
  int sq ;

  {
#line 141
  sq = 0;
  {
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 141
    if (! (sq < 64)) {
#line 141
      goto while_break;
    }
#line 143
    if (cboard[sq] == 0) {
#line 144
      Mvboard[sq] = 0;
    } else
#line 143
    if (cboard[sq] == (int )OrigCboard[sq]) {
#line 144
      Mvboard[sq] = 0;
    } else {
#line 146
      Mvboard[sq] = 1;
    }
#line 141
    sq ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return;
}
}
#line 151 "/home/khheo/testset/chess/src/util.c"
void EndSearch(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 158
  flags |= 16U;
  {
#line 159
  signal(2, & EndSearch);
  }
  }
#line 160
  return;
}
}
#line 163 "/home/khheo/testset/chess/src/util.c"
int ValidateBoard(void) 
{ 
  int side ;
  int xside ;
  int sq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 176
  tmp = nbits(board.b[0][6]);
  }
  }
#line 176
  if (tmp != 1) {
#line 177
    return (0);
  }
  {
  {
#line 178
  tmp___0 = nbits(board.b[1][6]);
  }
  }
#line 178
  if (tmp___0 != 1) {
#line 179
    return (0);
  }
  {
#line 181
  side = board.side;
#line 182
  xside = 1 ^ side;
  {
#line 183
  tmp___1 = SqAtakd(board.king[xside], side);
  }
  }
#line 183
  if (tmp___1) {
#line 184
    return (0);
  }
#line 186
  if (board.ep > -1) {
#line 188
    if (xside == 0) {
#line 188
      tmp___2 = 8;
    } else {
#line 188
      tmp___2 = -8;
    }
#line 188
    sq = board.ep + tmp___2;
#line 189
    if (! (BitPosArray[sq] & board.b[xside][1])) {
#line 190
      return (0);
    }
  }
#line 193
  if (board.flag & 1) {
#line 195
    if (! (BitPosArray[4] & board.b[0][6])) {
#line 196
      return (0);
    }
#line 197
    if (! (BitPosArray[7] & board.b[0][4])) {
#line 198
      return (0);
    }
  }
#line 200
  if (board.flag & 2) {
#line 202
    if (! (BitPosArray[4] & board.b[0][6])) {
#line 203
      return (0);
    }
#line 204
    if (! (BitPosArray[0] & board.b[0][4])) {
#line 205
      return (0);
    }
  }
#line 207
  if (board.flag & 4) {
#line 209
    if (! (BitPosArray[60] & board.b[1][6])) {
#line 210
      return (0);
    }
#line 211
    if (! (BitPosArray[63] & board.b[1][4])) {
#line 212
      return (0);
    }
  }
#line 214
  if (board.flag & 8) {
#line 216
    if (! (BitPosArray[60] & board.b[1][6])) {
#line 217
      return (0);
    }
#line 218
    if (! (BitPosArray[56] & board.b[1][4])) {
#line 219
      return (0);
    }
  }
#line 222
  return (1);
}
}
#line 322 "/home/khheo/testset/chess/src/common.h"
HashType HashKey ;
#line 324
HashSlot *HashTab[2] ;
#line 325
PawnSlot *PawnTab[2] ;
#line 348
unsigned long TotalGetHashCnt ;
#line 349
unsigned long GoodGetHashCnt ;
#line 350
unsigned long TotalPutHashCnt ;
#line 351
unsigned long CollHashCnt ;
#line 355
unsigned int HashSize ;
#line 356
unsigned long TTHashMask ;
#line 598
void TTPut(int side , int depth , int ply , int alpha , int beta , int score , int move ) ;
#line 599
int TTGet(int side , int depth , int ply , int alpha  __attribute__((__unused__)) ,
          int beta  __attribute__((__unused__)) , int *score , int *move ) ;
#line 600
int TTGetPV(int side , int ply , int score , int *move ) ;
#line 601
void TTClear(void) ;
#line 602
void PTClear(void) ;
#line 33 "/home/khheo/testset/chess/src/ttable.c"
void TTPut(int side , int depth , int ply , int alpha , int beta , int score , int move ) 
{ 
  HashSlot *t ;
  int tmp ;

  {
#line 50
  depth /= 12;
#line 51
  t = HashTab[side] + ((HashKey & TTHashMask) & 0xfffffffffffffffeUL);
#line 52
  if (depth < t->depth) {
#line 52
    if (score > 32512) {
#line 52
      goto _L;
    } else
#line 52
    if (score < -32512) {
#line 52
      goto _L;
    } else {
#line 53
      t ++;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (t->flag) {
#line 54
    if ((HashType )t->key != HashKey >> 32) {
#line 55
      *(t + 1) = *t;
    }
  }
#line 57
  if (t->flag) {
#line 58
    CollHashCnt ++;
  }
#line 59
  TotalPutHashCnt ++;
#line 60
  t->move = move;
#line 61
  t->key = (KeyType )(HashKey >> 32);
#line 62
  t->depth = depth;
#line 63
  if (t->depth == 0) {
#line 64
    t->flag = 5;
  } else
#line 65
  if (score >= beta) {
#line 66
    t->flag = 2;
  } else
#line 67
  if (score <= alpha) {
#line 68
    t->flag = 3;
  } else {
#line 70
    t->flag = 1;
  }
#line 72
  if (score > 32512) {
#line 72
    goto _L___0;
  } else
#line 72
  if (score < -32512) {
    _L___0: /* CIL Label */ 
#line 73
    if (score > 0) {
#line 73
      tmp = ply;
    } else {
#line 73
      tmp = - ply;
    }
#line 73
    t->score = score + tmp;
  } else {
#line 75
    t->score = score;
  }
#line 76
  return;
}
}
#line 79 "/home/khheo/testset/chess/src/ttable.c"
int TTGet(int side , int depth , int ply , int alpha  __attribute__((__unused__)) ,
          int beta  __attribute__((__unused__)) , int *score , int *move ) 
{ 
  HashSlot *t ;
  KeyType Key ;
  int tmp ;

  {
#line 93
  TotalGetHashCnt ++;
#line 94
  t = HashTab[side] + ((HashKey & TTHashMask) & 0xfffffffffffffffeUL);
#line 95
  Key = (KeyType )(HashKey >> 32);
#line 96
  if (Key != t->key) {
#line 96
    t ++;
#line 96
    if (Key != t->key) {
#line 97
      return (0);
    }
  }
#line 99
  depth /= 12;
#line 100
  GoodGetHashCnt ++;
#line 101
  *move = t->move;
#line 102
  *score = t->score;
#line 103
  if (t->depth == 0) {
#line 104
    return (5);
  }
#line 105
  if (t->depth < depth) {
#line 105
    if (! (t->score > 32512)) {
#line 105
      if (! (t->score < -32512)) {
#line 106
        return (4);
      }
    }
  }
#line 107
  if (*score > 32512) {
#line 107
    goto _L;
  } else
#line 107
  if (*score < -32512) {
    _L: /* CIL Label */ 
#line 108
    if (*score > 0) {
#line 108
      tmp = ply;
    } else {
#line 108
      tmp = - ply;
    }
#line 108
    *score -= tmp;
  }
#line 109
  return (t->flag);
}
}
#line 113 "/home/khheo/testset/chess/src/ttable.c"
int TTGetPV(int side , int ply , int score , int *move ) 
{ 
  HashSlot *t ;
  KeyType Key ;
  int s___1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  t = HashTab[side] + ((HashKey & TTHashMask) & 0xfffffffffffffffeUL);
#line 127
  Key = (KeyType )(HashKey >> 32);
#line 128
  s___1 = t->score;
#line 129
  if (s___1 > 32512) {
#line 129
    goto _L;
  } else
#line 129
  if (s___1 < -32512) {
    _L: /* CIL Label */ 
#line 130
    if (s___1 > 0) {
#line 130
      tmp = ply;
    } else {
#line 130
      tmp = - ply;
    }
#line 130
    s___1 -= tmp;
  }
#line 131
  if (Key == t->key) {
#line 131
    if (ply & 1) {
#line 131
      if (score == s___1) {
#line 133
        *move = t->move;
#line 134
        return (1);
      } else {
#line 131
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 131
    if (! (ply & 1)) {
#line 131
      if (score == - s___1) {
#line 133
        *move = t->move;
#line 134
        return (1);
      }
    }
  }
#line 136
  t ++;
#line 137
  s___1 = t->score;
#line 138
  if (s___1 > 32512) {
#line 138
    goto _L___1;
  } else
#line 138
  if (s___1 < -32512) {
    _L___1: /* CIL Label */ 
#line 139
    if (s___1 > 0) {
#line 139
      tmp___0 = ply;
    } else {
#line 139
      tmp___0 = - ply;
    }
#line 139
    s___1 -= tmp___0;
  }
#line 140
  if (Key == t->key) {
#line 140
    if (ply & 1) {
#line 140
      if (score == s___1) {
#line 142
        *move = t->move;
#line 143
        return (1);
      } else {
#line 140
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 140
    if (! (ply & 1)) {
#line 140
      if (score == - s___1) {
#line 142
        *move = t->move;
#line 143
        return (1);
      }
    }
  }
#line 145
  return (0);
}
}
#line 149 "/home/khheo/testset/chess/src/ttable.c"
void TTClear(void) 
{ 


  {
  {
  {
#line 156
  memset((void *)HashTab[0], 0, (unsigned long )HashSize * sizeof(HashSlot ));
  }
  {
#line 157
  memset((void *)HashTab[1], 0, (unsigned long )HashSize * sizeof(HashSlot ));
  }
  }
#line 158
  return;
}
}
#line 161 "/home/khheo/testset/chess/src/ttable.c"
void PTClear(void) 
{ 


  {
  {
  {
#line 168
  memset((void *)PawnTab[0], 0, 512UL * sizeof(PawnSlot ));
  }
  {
#line 169
  memset((void *)PawnTab[1], 0, 512UL * sizeof(PawnSlot ));
  }
  }
#line 170
  return;
}
}
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 306 "/home/khheo/testset/chess/src/common.h"
leaf *TreePtr[65] ;
#line 333
unsigned long GenCnt ;
#line 336
unsigned long EvalCnt ;
#line 503
void GenMoves(int ply ) ;
#line 504
void GenCaptures(int ply ) ;
#line 505
void GenNonCaptures(int ply ) ;
#line 507
void FilterIllegalMoves(int ply ) ;
#line 536
int ReadEPDFile(char const   *file___0 , int op ) ;
#line 581
int Evaluate(int alpha , int beta ) ;
#line 612
void ShowMoveList(int ply ) ;
#line 614
void ShowBoard(void) ;
#line 630
void TestMoveGenSpeed(void) ;
#line 631
void TestNonCaptureGenSpeed(void) ;
#line 632
void TestCaptureGenSpeed(void) ;
#line 633
void TestMoveList(void) ;
#line 634
void TestNonCaptureList(void) ;
#line 635
void TestCaptureList(void) ;
#line 636
void TestEvalSpeed(void) ;
#line 637
void TestEval(void) ;
#line 31 "/home/khheo/testset/chess/src/test.c"
void TestMoveGenSpeed(void) 
{ 
  unsigned long i ;
  struct timeval t1___0 ;
  struct timeval t2___0 ;
  double et___0 ;
  int side ;
  int xside ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 45
  GenCnt = 0UL;
#line 46
  et___0 = (double )0;
  {
#line 51
  gettimeofday((struct timeval */* __restrict  */)(& t1___0), (__timezone_ptr_t )((void *)0));
  }
#line 52
  side = board.side;
#line 53
  xside = 1 ^ side;
#line 54
  i = 0UL;
  }
  {
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < 2000000UL)) {
#line 54
      goto while_break;
    }
    {
#line 56
    TreePtr[2] = TreePtr[1];
    {
#line 57
    GenMoves(1);
    }
#line 54
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 59
  gettimeofday((struct timeval */* __restrict  */)(& t2___0), (__timezone_ptr_t )((void *)0));
  }
#line 60
  et___0 += (double )(t2___0.tv_sec - t1___0.tv_sec) + (double )(t2___0.tv_usec - t1___0.tv_usec) / 1e6;
  {
#line 61
  printf((char const   */* __restrict  */)"Time = %f\n", et___0);
  }
  {
#line 65
  printf((char const   */* __restrict  */)"No. of moves generated = %lu\n", GenCnt);
  }
  {
#line 66
  printf((char const   */* __restrict  */)"Time taken = %f secs\n", et___0);
  }
  }
#line 67
  if (et___0 > (double )0) {
    {
    {
#line 68
    printf((char const   */* __restrict  */)"Rate = %f moves/sec.\n", (double )GenCnt / et___0);
    }
    }
  }
#line 69
  return;
}
}
#line 73 "/home/khheo/testset/chess/src/test.c"
void TestNonCaptureGenSpeed(void) 
{ 
  unsigned long i ;
  struct timeval t1___0 ;
  struct timeval t2___0 ;
  double et___0 ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 87
  GenCnt = 0UL;
#line 88
  et___0 = (double )0;
  {
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 89
    tmp = ReadEPDFile("../test/wac.epd", 0);
    }
    }
#line 89
    if (! tmp) {
#line 89
      goto while_break;
    }
    {
    {
#line 91
    gettimeofday((struct timeval */* __restrict  */)(& t1___0), (__timezone_ptr_t )((void *)0));
    }
#line 92
    i = 0UL;
    }
    {
    {
#line 92
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 92
      if (! (i < 100000UL)) {
#line 92
        goto while_break___0;
      }
      {
#line 94
      TreePtr[2] = TreePtr[1];
      {
#line 95
      GenNonCaptures(1);
      }
#line 92
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 97
    gettimeofday((struct timeval */* __restrict  */)(& t2___0), (__timezone_ptr_t )((void *)0));
    }
#line 98
    et___0 += (double )(t2___0.tv_sec - t1___0.tv_sec) + (double )(t2___0.tv_usec - t1___0.tv_usec) / 1e6;
    {
#line 99
    printf((char const   */* __restrict  */)"Time = %f\n", et___0);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 101
  printf((char const   */* __restrict  */)"No. of moves generated = %lu\n", GenCnt);
  }
  {
#line 102
  printf((char const   */* __restrict  */)"Time taken = %f\n", et___0);
  }
  }
#line 103
  if (et___0 > (double )0) {
    {
    {
#line 104
    printf((char const   */* __restrict  */)"Rate = %f\n", (double )GenCnt / et___0);
    }
    }
  }
#line 105
  return;
}
}
#line 108 "/home/khheo/testset/chess/src/test.c"
void TestCaptureGenSpeed(void) 
{ 
  unsigned long i ;
  struct timeval t1___0 ;
  struct timeval t2___0 ;
  double et___0 ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 122
  GenCnt = 0UL;
#line 123
  et___0 = (double )0;
  {
  {
#line 124
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 124
    tmp = ReadEPDFile("../test/wac.epd", 0);
    }
    }
#line 124
    if (! tmp) {
#line 124
      goto while_break;
    }
    {
    {
#line 126
    gettimeofday((struct timeval */* __restrict  */)(& t1___0), (__timezone_ptr_t )((void *)0));
    }
#line 127
    i = 0UL;
    }
    {
    {
#line 127
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 127
      if (! (i < 200000UL)) {
#line 127
        goto while_break___0;
      }
      {
#line 129
      TreePtr[2] = TreePtr[1];
      {
#line 130
      GenCaptures(1);
      }
#line 127
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 132
    gettimeofday((struct timeval */* __restrict  */)(& t2___0), (__timezone_ptr_t )((void *)0));
    }
#line 133
    et___0 += (double )(t2___0.tv_sec - t1___0.tv_sec) + (double )(t2___0.tv_usec - t1___0.tv_usec) / 1e6;
    {
#line 134
    printf((char const   */* __restrict  */)"Time = %f\n", et___0);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 136
  printf((char const   */* __restrict  */)"No. of moves generated = %lu\n", GenCnt);
  }
  {
#line 137
  printf((char const   */* __restrict  */)"Time taken = %f\n", et___0);
  }
  }
#line 138
  if (et___0 > (double )0) {
    {
    {
#line 139
    printf((char const   */* __restrict  */)"Rate = %f\n", (double )GenCnt / et___0);
    }
    }
  }
#line 140
  return;
}
}
#line 143 "/home/khheo/testset/chess/src/test.c"
void TestMoveList(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 151
    tmp = ReadEPDFile("TEST/GMG1.epd", 0);
    }
    }
#line 151
    if (! tmp) {
#line 151
      goto while_break;
    }
    {
    {
#line 153
    ShowBoard();
    }
#line 154
    GenCnt = 0UL;
#line 155
    TreePtr[2] = TreePtr[1];
    {
#line 156
    GenMoves(1);
    }
    {
#line 157
    FilterIllegalMoves(1);
    }
    {
#line 158
    ShowMoveList(1);
    }
    {
#line 159
    printf((char const   */* __restrict  */)"No. of moves generated = %lu\n\n", GenCnt);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 164 "/home/khheo/testset/chess/src/test.c"
void TestNonCaptureList(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 172
    tmp = ReadEPDFile("TEST/GMG1.epd", 0);
    }
    }
#line 172
    if (! tmp) {
#line 172
      goto while_break;
    }
    {
    {
#line 174
    ShowBoard();
    }
#line 175
    GenCnt = 0UL;
#line 176
    TreePtr[2] = TreePtr[1];
    {
#line 177
    GenNonCaptures(1);
    }
    {
#line 178
    FilterIllegalMoves(1);
    }
    {
#line 179
    ShowMoveList(1);
    }
    {
#line 180
    printf((char const   */* __restrict  */)"No. of moves generated = %lu\n\n", GenCnt);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 185 "/home/khheo/testset/chess/src/test.c"
void TestCaptureList(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 193
    tmp = ReadEPDFile("TEST/GMG1.epd", 0);
    }
    }
#line 193
    if (! tmp) {
#line 193
      goto while_break;
    }
    {
    {
#line 195
    ShowBoard();
    }
#line 196
    GenCnt = 0UL;
#line 197
    TreePtr[2] = TreePtr[1];
    {
#line 198
    GenCaptures(1);
    }
    {
#line 199
    FilterIllegalMoves(1);
    }
    {
#line 200
    ShowMoveList(1);
    }
    {
#line 201
    printf((char const   */* __restrict  */)"No. of moves generated = %lu\n\n", GenCnt);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 208 "/home/khheo/testset/chess/src/test.c"
void TestEvalSpeed(void) 
{ 
  unsigned long i ;
  struct timeval t1___0 ;
  struct timeval t2___0 ;
  double et___0 ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 220
  et___0 = (double )0;
#line 221
  EvalCnt = 0UL;
  {
  {
#line 222
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 222
    tmp = ReadEPDFile("../test/wac.epd", 0);
    }
    }
#line 222
    if (! tmp) {
#line 222
      goto while_break;
    }
    {
    {
#line 224
    gettimeofday((struct timeval */* __restrict  */)(& t1___0), (__timezone_ptr_t )((void *)0));
    }
#line 225
    i = 0UL;
    }
    {
    {
#line 225
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! (i < 30000UL)) {
#line 225
        goto while_break___0;
      }
      {
      {
#line 227
      Evaluate(-32767, 32767);
      }
#line 225
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 229
    gettimeofday((struct timeval */* __restrict  */)(& t2___0), (__timezone_ptr_t )((void *)0));
    }
#line 230
    et___0 += (double )(t2___0.tv_sec - t1___0.tv_sec) + (double )(t2___0.tv_usec - t1___0.tv_usec) / 1e6;
    {
#line 231
    printf((char const   */* __restrict  */)"Time = %f\n", et___0);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 233
  printf((char const   */* __restrict  */)"No. of positions evaluated = %lu\n", EvalCnt);
  }
  {
#line 234
  printf((char const   */* __restrict  */)"Time taken = %f\n", et___0);
  }
  }
#line 235
  if (et___0 > (double )0) {
    {
    {
#line 236
    printf((char const   */* __restrict  */)"Rate = %f\n", (double )EvalCnt / et___0);
    }
    }
  }
#line 237
  return;
}
}
#line 241 "/home/khheo/testset/chess/src/test.c"
void TestEval(void) 
{ 
  int score ;
  char const   *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 254
  flags |= 2U;
  {
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 255
    tmp___0 = ReadEPDFile("../test/wac.epd", 0);
    }
    }
#line 255
    if (! tmp___0) {
#line 255
      goto while_break;
    }
    {
    {
#line 257
    ShowBoard();
    }
    {
#line 258
    score = Evaluate(-32767, 32767);
    }
    }
#line 259
    if (board.side == 0) {
#line 259
      tmp = "W : ";
    } else {
#line 259
      tmp = "B : ";
    }
    {
    {
#line 259
    printf((char const   */* __restrict  */)tmp);
    }
    {
#line 260
    printf((char const   */* __restrict  */)"score = %d\n\n", score);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  flags &= 4294967293U;
#line 263
  return;
}
}
#line 281 "/home/khheo/testset/chess/src/common.h"
BitBoard Ray[64][8] ;
#line 303
int directions[64][64] ;
#line 359
int Value[7] ;
#line 523
BitBoard AttackTo(int sq , int side ) ;
#line 532
int SwapOff(int move ) ;
#line 533
void AddXrayPiece(int t , int sq , int side , BitBoard *b , BitBoard *c ) ;
#line 31 "/home/khheo/testset/chess/src/swap.c"
static int const   xray[7]  = {      (int const   )0,      (int const   )1,      (int const   )0,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )0};
#line 33 "/home/khheo/testset/chess/src/swap.c"
int SwapOff(int move ) 
{ 
  int f ;
  int t ;
  int sq ;
  int piece ;
  int lastval ;
  int side ;
  int xside ;
  int swaplist[65] ;
  int n___0 ;
  BitBoard b ;
  BitBoard c ;
  BitBoard *d ;
  BitBoard *e ;
  BitBoard r ;
  void *__cil_tmp16 ;

  {
#line 52
  f = (move >> 6) & 63;
#line 53
  t = move & 63;
#line 54
  if (board.friends[0] & BitPosArray[f]) {
#line 54
    side = 0;
  } else {
#line 54
    side = 1;
  }
  {
#line 55
  xside = 1 ^ side;
  {
#line 58
  b = AttackTo(t, side);
  }
  {
#line 59
  c = AttackTo(t, xside);
  }
#line 60
  b &= NotBitPosArray[f];
  }
#line 61
  if (xray[cboard[f]]) {
    {
    {
#line 62
    AddXrayPiece(t, f, side, & b, & c);
    }
    }
  }
#line 64
  d = board.b[side];
#line 65
  e = board.b[xside];
#line 66
  if (move & 28672) {
#line 68
    swaplist[0] = Value[(move >> 12) & 7] - 100;
#line 69
    lastval = - Value[(move >> 12) & 7];
  } else {
#line 73
    if (move & 4194304) {
#line 73
      swaplist[0] = 100;
    } else {
#line 73
      swaplist[0] = Value[cboard[t]];
    }
#line 74
    lastval = - Value[cboard[f]];
  }
#line 76
  n___0 = 1;
  {
  {
#line 77
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 79
    if ((unsigned long long )c == 0ULL) {
#line 80
      goto while_break;
    }
#line 81
    piece = 1;
    {
    {
#line 81
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 81
      if (! (piece <= 6)) {
#line 81
        goto while_break___0;
      }
#line 83
      r = c & *(e + piece);
#line 84
      if (r) {
        {
        {
#line 86
        sq = leadz(r);
        }
#line 87
        c &= NotBitPosArray[sq];
        }
#line 88
        if (xray[piece]) {
          {
          {
#line 89
          AddXrayPiece(t, sq, xside, & c, & b);
          }
          }
        }
#line 90
        swaplist[n___0] = swaplist[n___0 - 1] + lastval;
#line 91
        n___0 ++;
#line 92
        lastval = Value[piece];
#line 93
        goto while_break___0;
      }
#line 81
      piece ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 97
    if ((unsigned long long )b == 0ULL) {
#line 98
      goto while_break;
    }
#line 99
    piece = 1;
    {
    {
#line 99
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 99
      if (! (piece <= 6)) {
#line 99
        goto while_break___1;
      }
#line 101
      r = b & *(d + piece);
#line 102
      if (r) {
        {
        {
#line 104
        sq = leadz(r);
        }
#line 105
        b &= NotBitPosArray[sq];
        }
#line 106
        if (xray[piece]) {
          {
          {
#line 107
          AddXrayPiece(t, sq, side, & b, & c);
          }
          }
        }
#line 108
        swaplist[n___0] = swaplist[n___0 - 1] + lastval;
#line 109
        n___0 ++;
#line 110
        lastval = - Value[piece];
#line 111
        goto while_break___1;
      }
#line 99
      piece ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  n___0 --;
  {
  {
#line 123
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 123
    if (! n___0) {
#line 123
      goto while_break___2;
    }
#line 125
    if (n___0 & 1) {
#line 127
      if (swaplist[n___0] <= swaplist[n___0 - 1]) {
#line 128
        swaplist[n___0 - 1] = swaplist[n___0];
      }
    } else
#line 132
    if (swaplist[n___0] >= swaplist[n___0 - 1]) {
#line 133
      swaplist[n___0 - 1] = swaplist[n___0];
    }
#line 135
    n___0 --;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 137
  return (swaplist[0]);
}
}
#line 141 "/home/khheo/testset/chess/src/swap.c"
void AddXrayPiece(int t , int sq , int side , BitBoard *b , BitBoard *c ) 
{ 
  int dir___0 ;
  int nsq ;
  int piece ;
  BitBoard a ;
  int tmp ;
  int tmp___0 ;

  {
#line 153
  dir___0 = directions[t][sq];
#line 154
  a = Ray[sq][dir___0] & board.blocker;
#line 155
  if ((unsigned long long )a == 0ULL) {
#line 156
    return;
  }
#line 157
  if (t < sq) {
    {
    {
#line 157
    tmp = leadz(a);
    }
#line 157
    nsq = tmp;
    }
  } else {
    {
    {
#line 157
    tmp___0 = leadz(a & (~ a + 1UL));
    }
#line 157
    nsq = tmp___0;
    }
  }
#line 158
  piece = cboard[nsq];
#line 159
  if (piece == 5) {
#line 159
    goto _L;
  } else
#line 159
  if (piece == 4) {
#line 159
    if (dir___0 > 3) {
#line 159
      goto _L;
    } else {
#line 159
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 159
  if (piece == 3) {
#line 159
    if (dir___0 < 4) {
      _L: /* CIL Label */ 
#line 162
      if (BitPosArray[nsq] & board.friends[side]) {
#line 163
        *b |= BitPosArray[nsq];
      } else {
#line 165
        *c |= BitPosArray[nsq];
      }
    }
  }
#line 167
  return;
}
}
#line 271 "/home/khheo/testset/chess/src/common.h"
int taxicab[64][64] ;
#line 286
BitBoard PassedPawnMask[2][64] ;
#line 361
unsigned long history[2][4096] ;
#line 362
int killer1[65] ;
#line 363
int killer2[65] ;
#line 383
int Hashmv[65] ;
#line 391
int pickphase[65] ;
#line 517
int IsLegalMove(int move ) ;
#line 592
void pick(leaf *head , int ply ) ;
#line 605
void SortCaptures(int ply ) ;
#line 606
void SortMoves(int ply ) ;
#line 607
void SortRoot(void) ;
#line 608
int PhasePick(leaf **p1 , int ply ) ;
#line 609
int PhasePick1(leaf **p1 , int ply ) ;
#line 38 "/home/khheo/testset/chess/src/sort.c"
void SortCaptures(int ply ) 
{ 
  leaf *p___1 ;
  int temp ;
  int f ;
  int t ;

  {
#line 51
  p___1 = TreePtr[ply];
  {
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[ply + 1])) {
#line 51
      goto while_break;
    }
#line 53
    f = Value[cboard[(p___1->move >> 6) & 63]];
#line 54
    t = Value[cboard[p___1->move & 63]];
#line 55
    if (f < t) {
#line 56
      p___1->score = t - f;
    } else {
      {
      {
#line 59
      temp = SwapOff(p___1->move);
      }
      }
#line 60
      if (temp < 0) {
#line 60
        p___1->score = -32767;
      } else {
#line 60
        p___1->score = temp;
      }
    }
#line 51
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  return;
}
}
#line 67 "/home/khheo/testset/chess/src/sort.c"
void SortMoves(int ply ) 
{ 
  leaf *p___1 ;
  int f ;
  int t ;
  int m ;
  int tovalue ;
  int side ;
  int xside ;
  BitBoard enemyP ;

  {
#line 84
  side = board.side;
#line 85
  xside = 1 ^ side;
#line 86
  enemyP = board.b[xside][1];
#line 88
  p___1 = TreePtr[ply];
  {
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 88
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[ply + 1])) {
#line 88
      goto while_break;
    }
#line 90
    p___1->score = -32767;
#line 91
    f = (p___1->move >> 6) & 63;
#line 92
    t = p___1->move & 63;
#line 93
    m = p___1->move & 6324223;
#line 96
    if (m == Hashmv[ply]) {
#line 97
      p___1->score += 32767;
    } else
#line 99
    if (cboard[t] != 0) {
#line 119
      tovalue = Value[cboard[t]] + Value[(p___1->move >> 12) & 7];
#line 120
      p___1->score += (tovalue + 2000) - Value[cboard[f]];
    } else
#line 99
    if (p___1->move & 28672) {
#line 119
      tovalue = Value[cboard[t]] + Value[(p___1->move >> 12) & 7];
#line 120
      p___1->score += (tovalue + 2000) - Value[cboard[f]];
    } else
#line 125
    if (m == killer1[ply]) {
#line 126
      p___1->score += 1000;
    } else
#line 125
    if (m == killer2[ply]) {
#line 126
      p___1->score += 1000;
    } else
#line 127
    if (ply > 2) {
#line 127
      if (m == killer1[ply - 2]) {
#line 128
        p___1->score += 1000;
      } else
#line 127
      if (m == killer2[ply - 2]) {
#line 128
        p___1->score += 1000;
      }
    }
#line 130
    p___1->score = (int )((unsigned long )p___1->score + ((history[side][p___1->move & 4095] + (unsigned long )taxicab[f][35]) - (unsigned long )taxicab[t][28]));
#line 132
    if (cboard[f] == 1) {
#line 134
      if ((unsigned long long )(enemyP & PassedPawnMask[side][t]) == 0ULL) {
#line 135
        p___1->score += 50;
      }
    }
#line 88
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 141 "/home/khheo/testset/chess/src/sort.c"
void SortRoot(void) 
{ 
  leaf *p___1 ;
  int f ;
  int t ;
  int side ;
  int xside ;
  BitBoard enemyP ;
  int tmp ;
  int tmp___0 ;

  {
#line 154
  side = board.side;
#line 155
  xside = 1 ^ side;
#line 156
  enemyP = board.b[xside][1];
#line 158
  p___1 = TreePtr[1];
  {
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[2])) {
#line 158
      goto while_break;
    }
#line 160
    f = Value[cboard[(p___1->move >> 6) & 63]];
#line 161
    if (cboard[p___1->move & 63] != 0) {
#line 161
      goto _L;
    } else
#line 161
    if (p___1->move & 28672) {
      _L: /* CIL Label */ 
#line 163
      t = Value[cboard[p___1->move & 63]];
#line 164
      if (f < t) {
#line 165
        p___1->score = (-1000 + t) - f;
      } else {
        {
        {
#line 167
        tmp = SwapOff(p___1->move);
        }
#line 167
        p___1->score = -1000 + tmp;
        }
      }
    } else {
      {
      {
#line 170
      tmp___0 = SwapOff(p___1->move);
      }
#line 170
      p___1->score = -3000 + tmp___0;
      }
    }
#line 172
    p___1->score += taxicab[(p___1->move >> 6) & 63][35] - taxicab[p___1->move & 63][28];
#line 174
    if (f == 100) {
#line 176
      if ((unsigned long long )(enemyP & PassedPawnMask[side][p___1->move & 63]) == 0ULL) {
#line 177
        p___1->score += 50;
      }
    }
#line 158
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 183 "/home/khheo/testset/chess/src/sort.c"
void pick(leaf *head , int ply ) 
{ 
  int best ;
  leaf *p___1 ;
  leaf *pbest ;
  leaf tmp ;

  {
#line 194
  best = head->score;
#line 195
  pbest = head;
#line 196
  p___1 = head + 1;
  {
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[ply + 1])) {
#line 196
      goto while_break;
    }
#line 198
    if (p___1->score > best) {
#line 200
      pbest = p___1;
#line 201
      best = p___1->score;
    }
#line 196
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  tmp = *head;
#line 207
  *head = *pbest;
#line 208
  *pbest = tmp;
#line 209
  return;
}
}
#line 229 "/home/khheo/testset/chess/src/sort.c"
static leaf *p[65]  ;
#line 212 "/home/khheo/testset/chess/src/sort.c"
int PhasePick(leaf **p1 , int ply ) 
{ 
  leaf *p2 ;
  int mv ;
  int side ;
  leaf *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  leaf *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  leaf *tmp___5 ;

  {
#line 234
  side = board.side;
  {
#line 237
  if (pickphase[ply] == 1) {
#line 237
    goto case_1;
  }
#line 247
  if (pickphase[ply] == 2) {
#line 247
    goto case_2;
  }
#line 255
  if (pickphase[ply] == 3) {
#line 255
    goto case_3;
  }
#line 268
  if (pickphase[ply] == 4) {
#line 268
    goto case_4;
  }
#line 279
  if (pickphase[ply] == 5) {
#line 279
    goto case_5;
  }
#line 290
  if (pickphase[ply] == 6) {
#line 290
    goto case_6;
  }
#line 302
  if (pickphase[ply] == 8) {
#line 302
    goto case_8;
  }
#line 235
  goto switch_break;
  case_1: /* CIL Label */ 
#line 238
  TreePtr[ply + 1] = TreePtr[ply];
#line 239
  pickphase[ply] = 2;
#line 240
  if (Hashmv[ply]) {
    {
    {
#line 240
    tmp___0 = IsLegalMove(Hashmv[ply]);
    }
    }
#line 240
    if (tmp___0) {
#line 242
      (TreePtr[ply + 1])->move = Hashmv[ply];
#line 243
      tmp = TreePtr[ply + 1];
#line 243
      (TreePtr[ply + 1]) ++;
#line 243
      *p1 = tmp;
#line 244
      return (1);
    }
  }
  case_2: /* CIL Label */ 
  {
#line 248
  pickphase[ply] = 3;
#line 249
  p[ply] = TreePtr[ply + 1];
  {
#line 250
  GenCaptures(ply);
  }
#line 251
  p2 = p[ply];
  }
  {
  {
#line 251
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )p2 < (unsigned long )TreePtr[ply + 1])) {
#line 251
      goto while_break;
    }
    {
    {
#line 252
    tmp___1 = SwapOff(p2->move);
    }
#line 252
    p2->score = tmp___1 * 12 + Value[cboard[p2->move & 63]];
#line 251
    p2 ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  case_3: /* CIL Label */ 
  {
  {
#line 256
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! ((unsigned long )p[ply] < (unsigned long )TreePtr[ply + 1])) {
#line 256
      goto while_break___0;
    }
    {
    {
#line 258
    pick(p[ply], ply);
    }
    }
#line 259
    if (((p[ply])->move & 6324223) == Hashmv[ply]) {
#line 261
      (p[ply]) ++;
#line 262
      goto while_continue___0;
    }
#line 264
    tmp___2 = p[ply];
#line 264
    (p[ply]) ++;
#line 264
    *p1 = tmp___2;
#line 265
    return (1);
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  case_4: /* CIL Label */ 
#line 269
  pickphase[ply] = 5;
#line 270
  if (killer1[ply]) {
#line 270
    if (killer1[ply] != Hashmv[ply]) {
      {
      {
#line 270
      tmp___3 = IsLegalMove(killer1[ply]);
      }
      }
#line 270
      if (tmp___3) {
#line 273
        (TreePtr[ply + 1])->move = killer1[ply];
#line 274
        *p1 = TreePtr[ply + 1];
#line 275
        (TreePtr[ply + 1]) ++;
#line 276
        return (1);
      }
    }
  }
  case_5: /* CIL Label */ 
#line 280
  pickphase[ply] = 6;
#line 281
  if (killer2[ply]) {
#line 281
    if (killer2[ply] != Hashmv[ply]) {
      {
      {
#line 281
      tmp___4 = IsLegalMove(killer2[ply]);
      }
      }
#line 281
      if (tmp___4) {
#line 284
        (TreePtr[ply + 1])->move = killer2[ply];
#line 285
        *p1 = TreePtr[ply + 1];
#line 286
        (TreePtr[ply + 1]) ++;
#line 287
        return (1);
      }
    }
  }
  case_6: /* CIL Label */ 
  {
#line 291
  pickphase[ply] = 8;
#line 292
  p[ply] = TreePtr[ply + 1];
  {
#line 293
  GenNonCaptures(ply);
  }
#line 294
  p2 = p[ply];
  }
  {
  {
#line 294
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! ((unsigned long )p2 < (unsigned long )TreePtr[ply + 1])) {
#line 294
      goto while_break___1;
    }
#line 296
    p2->score = (int )((history[side][p2->move & 4095] + (unsigned long )taxicab[(p2->move >> 6) & 63][35]) - (unsigned long )taxicab[p2->move & 63][28]);
#line 298
    if (p2->move & 2097152) {
#line 299
      p2->score += 500;
    }
#line 294
    p2 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  case_8: /* CIL Label */ 
  {
  {
#line 303
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 303
    if (! ((unsigned long )p[ply] < (unsigned long )TreePtr[ply + 1])) {
#line 303
      goto while_break___2;
    }
    {
    {
#line 305
    pick(p[ply], ply);
    }
#line 306
    mv = (p[ply])->move & 6324223;
    }
#line 307
    if (mv == Hashmv[ply]) {
#line 310
      (p[ply]) ++;
#line 311
      goto while_continue___2;
    } else
#line 307
    if (mv == killer1[ply]) {
#line 310
      (p[ply]) ++;
#line 311
      goto while_continue___2;
    } else
#line 307
    if (mv == killer2[ply]) {
#line 310
      (p[ply]) ++;
#line 311
      goto while_continue___2;
    }
#line 313
    tmp___5 = p[ply];
#line 313
    (p[ply]) ++;
#line 313
    *p1 = tmp___5;
#line 314
    return (1);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 317
  return (0);
}
}
#line 328 "/home/khheo/testset/chess/src/sort.c"
static leaf *p___0[65]  ;
#line 321 "/home/khheo/testset/chess/src/sort.c"
int PhasePick1(leaf **p1 , int ply ) 
{ 
  leaf *tmp ;

  {
  {
#line 332
  if (pickphase[ply] == 1) {
#line 332
    goto case_1;
  }
#line 336
  if (pickphase[ply] == 8) {
#line 336
    goto case_8;
  }
#line 330
  goto switch_break;
  case_1: /* CIL Label */ 
#line 333
  pickphase[ply] = 8;
#line 334
  p___0[ply] = TreePtr[ply];
  case_8: /* CIL Label */ 
  {
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 337
    if (! ((unsigned long )p___0[ply] < (unsigned long )TreePtr[ply + 1])) {
#line 337
      goto while_break;
    }
    {
    {
#line 339
    pick(p___0[ply], ply);
    }
#line 340
    tmp = p___0[ply];
#line 340
    (p___0[ply]) ++;
#line 340
    *p1 = tmp;
    }
#line 341
    return (1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 344
  return (0);
}
}
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 334 "/home/khheo/testset/chess/src/common.h"
unsigned long NodeCnt ;
#line 335
unsigned long QuiesCnt ;
#line 360
char SANmv[10] ;
#line 366
char id[32] ;
#line 367
char solution[64] ;
#line 477
void NewPosition(void) ;
#line 588
void Iterate(void) ;
#line 627
void Solve(char *file___0 ) ;
#line 34 "/home/khheo/testset/chess/src/solve.c"
void Solve(char *file___0 ) 
{ 
  int total ;
  int correct ;
  int found ;
  long TotalNodes ;
  char *p___1 ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 45
  correct = 0;
#line 45
  total = correct;
#line 46
  TotalNodes = 0L;
#line 47
  flags |= 256U;
  {
  {
#line 48
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 48
    tmp___2 = ReadEPDFile((char const   *)file___0, 0);
    }
    }
#line 48
    if (! tmp___2) {
#line 48
      goto while_break;
    }
    {
    {
#line 50
    NewPosition();
    }
#line 51
    total ++;
    {
#line 52
    ShowBoard();
    }
    {
#line 53
    Iterate();
    }
#line 54
    TotalNodes = (long )((unsigned long )TotalNodes + (NodeCnt + QuiesCnt));
#line 55
    p___1 = solution;
#line 56
    found = 0;
    }
    {
    {
#line 57
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 57
      if (! ((int )*p___1 != 0)) {
#line 57
        goto while_break___0;
      }
      {
      {
#line 59
      tmp = strlen((char const   *)(SANmv));
      }
      {
#line 59
      tmp___0 = strncmp((char const   *)p___1, (char const   *)(SANmv), tmp);
      }
      }
#line 59
      if (! tmp___0) {
#line 61
        correct ++;
#line 62
        found = 1;
#line 63
        goto while_break___0;
      }
      {
      {
#line 65
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 65
        if ((int )*p___1 != 32) {
#line 65
          if (! ((int )*p___1 != 0)) {
#line 65
            goto while_break___1;
          }
        } else {
#line 65
          goto while_break___1;
        }
#line 65
        p___1 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 66
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 66
        if ((int )*p___1 == 32) {
#line 66
          if (! ((int )*p___1 != 0)) {
#line 66
            goto while_break___2;
          }
        } else {
#line 66
          goto while_break___2;
        }
#line 66
        p___1 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 68
    printf((char const   */* __restrict  */)"%s : ", id);
    }
    }
#line 69
    if (found) {
#line 69
      tmp___1 = "Correct:  ";
    } else {
#line 69
      tmp___1 = "Incorrect:  ";
    }
    {
    {
#line 69
    printf((char const   */* __restrict  */)tmp___1);
    }
    {
#line 70
    printf((char const   */* __restrict  */)"%s %s\n", SANmv, solution);
    }
    {
#line 71
    printf((char const   */* __restrict  */)"Correct=%d Total=%d\n", correct, total);
    }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 73
  printf((char const   */* __restrict  */)"\nTotal nodes = %ld\n", TotalNodes);
  }
#line 74
  flags &= 4294967039U;
  }
#line 75
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 766 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 307 "/home/khheo/testset/chess/src/common.h"
int RootPV ;
#line 308
GameRec Game[600] ;
#line 309
int GameCnt ;
#line 310
int computer ;
#line 326
int Idepth ;
#line 328
int Game50 ;
#line 330
int maxposnscore[2] ;
#line 331
int rootscore ;
#line 332
int lastrootscore ;
#line 338
unsigned long ChkExtCnt ;
#line 339
unsigned long OneRepCnt ;
#line 340
unsigned long RcpExtCnt ;
#line 341
unsigned long PawnExtCnt ;
#line 342
unsigned long HorzExtCnt ;
#line 344
unsigned long KingExtCnt ;
#line 345
unsigned long NullCutCnt ;
#line 346
unsigned long FutlCutCnt ;
#line 347
unsigned long RazrCutCnt ;
#line 354
unsigned long RepeatCnt ;
#line 364
int ChkCnt[65] ;
#line 365
int ThrtCnt[65] ;
#line 373
double et ;
#line 374
float SearchTime ;
#line 375
int SearchDepth ;
#line 388
int RootMaterial ;
#line 392
int InChk[65] ;
#line 393
int KingThrt[2][65] ;
#line 395
int threatply ;
#line 414
int rank6[2] ;
#line 415
int rank7[2] ;
#line 418
FILE *ofp ;
#line 419
int myrating ;
#line 419
int opprating ;
#line 421
int computerplays ;
#line 424
float maxtime ;
#line 506
void GenCheckEscapes(int ply ) ;
#line 510
void MakeMove(int side , int *move ) ;
#line 511
void UnmakeMove(int side , int *move ) ;
#line 512
void MakeNullMove(int side ) ;
#line 513
void UnmakeNullMove(int side ) ;
#line 514
void SANMove(int move , int ply ) ;
#line 529
int MateScan(int side ) ;
#line 582
int EvaluateDraw(void) ;
#line 589
int Search(int ply , int depth , int alpha , int beta , int nodetype ) ;
#line 590
int SearchRoot(int depth , int alpha , int beta ) ;
#line 591
int Quiesce(int ply , int alpha , int beta ) ;
#line 593
int Repeat(void) ;
#line 594
void ShowLine(int move  __attribute__((__unused__)) , int score , char c ) ;
#line 595
void GetElapsed(void) ;
#line 42 "/home/khheo/testset/chess/src/search.c"
__inline void ShowThinking(leaf *p___1 , int ply ) ;
#line 43 "/home/khheo/testset/chess/src/search.c"
__inline void ShowThinking(leaf *p___1 , int ply ) 
{ 
  char *__cil_tmp3 ;

  {
#line 45
  if (flags & 1024U) {
#line 46
    return;
  }
#line 47
  if (! (flags & 4096U)) {
#line 48
    return;
  }
#line 49
  if (NodeCnt < 500000UL) {
#line 49
    if (flags & 256U) {
#line 51
      return;
    }
  }
  {
  {
#line 53
  SANMove(p___1->move, ply);
  }
  {
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%2d.         %2d/%2d%10s    ",
          Idepth / 12, (int )((p___1 - TreePtr[ply]) + 1L), (int )(TreePtr[ply + 1] - TreePtr[ply]),
          SANmv);
  }
  {
#line 56
  fflush(stderr);
  }
  }
#line 57
  return;
}
}
#line 59 "/home/khheo/testset/chess/src/search.c"
static int ply1score  ;
#line 61 "/home/khheo/testset/chess/src/search.c"
int SearchRoot(int depth , int alpha , int beta ) 
{ 
  int best ;
  int score ;
  int savealpha ;
  int side ;
  int xside ;
  int ply ;
  int nodetype ;
  leaf *p___1 ;
  leaf *pbest ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 76
  ply = 1;
#line 77
  side = board.side;
#line 78
  xside = 1 ^ side;
#line 79
  ChkCnt[2] = ChkCnt[1];
#line 80
  ThrtCnt[2] = ThrtCnt[1];
  {
#line 81
  KingThrt[0][ply] = MateScan(0);
  }
  {
#line 82
  KingThrt[1][ply] = MateScan(1);
  }
  {
#line 83
  InChk[ply] = SqAtakd(board.king[side], xside);
  }
  }
#line 84
  if (InChk[ply]) {
#line 84
    if (ChkCnt[ply] < (3 * Idepth) / 12) {
#line 86
      ChkExtCnt ++;
#line 87
      (ChkCnt[ply + 1]) ++;
#line 88
      depth += 12;
    }
  }
#line 90
  best = -32767;
#line 91
  savealpha = alpha;
#line 92
  nodetype = 0;
#line 93
  pbest = (leaf *)((void *)0);
#line 95
  p___1 = TreePtr[1];
  {
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[2])) {
#line 95
      goto while_break;
    }
    {
    {
#line 97
    pick(p___1, 1);
    }
    {
#line 98
    ShowThinking(p___1, ply);
    }
    {
#line 99
    MakeMove(side, & p___1->move);
    }
#line 100
    NodeCnt ++;
    }
#line 103
    if ((unsigned long )p___1 == (unsigned long )TreePtr[1]) {
      {
      {
#line 105
      tmp = Search(2, depth - 12, - beta, - alpha, nodetype);
      }
#line 105
      score = - tmp;
      }
#line 111
      if (beta == 32767) {
#line 111
        if (score <= alpha) {
          {
#line 113
          alpha = -32767;
          {
#line 114
          tmp___0 = Search(2, depth - 12, - beta, - alpha, nodetype);
          }
#line 114
          score = - tmp___0;
          }
        }
      }
    } else {
#line 121
      nodetype = 2;
#line 122
      if (best > alpha) {
#line 122
        alpha = best;
      } else {
#line 122
        alpha = alpha;
      }
      {
      {
#line 123
      tmp___1 = Search(2, depth - 12, - alpha - 1, - alpha, nodetype);
      }
#line 123
      score = - tmp___1;
      }
#line 124
      if (score > best) {
#line 126
        if (alpha < score) {
#line 126
          if (score < beta) {
            {
#line 128
            nodetype = 0;
            {
#line 129
            tmp___2 = Search(2, depth - 12, - beta, - score, nodetype);
            }
#line 129
            score = - tmp___2;
            }
          }
        }
      }
    }
    {
    {
#line 133
    UnmakeMove(xside, & p___1->move);
    }
#line 135
    tmp___3 = score;
#line 135
    p___1->score = tmp___3;
#line 135
    ply1score = tmp___3;
    }
#line 136
    if (score > best) {
#line 138
      best = score;
#line 139
      pbest = p___1;
#line 140
      if (best > alpha) {
#line 142
        rootscore = best;
#line 143
        RootPV = p___1->move;
#line 144
        if (best >= beta) {
#line 145
          goto done;
        }
        {
        {
#line 146
        ShowLine(RootPV, best, (char )'&');
        }
        }
      }
    }
#line 150
    if (flags & 16U) {
#line 153
      if (ply & 1) {
#line 153
        best = rootscore;
      } else {
#line 153
        best = - rootscore;
      }
#line 154
      return (best);
    }
#line 157
    if (SearchDepth == 0) {
#line 157
      if ((NodeCnt & 1023UL) == 0UL) {
        {
        {
#line 159
        GetElapsed();
        }
        }
#line 160
        if (et >= (double )SearchTime) {
#line 160
          if (rootscore == -32768) {
#line 163
            flags |= 16U;
          } else
#line 160
          if (ply1score > lastrootscore - 25) {
#line 163
            flags |= 16U;
          } else
#line 160
          if (flags & 256U) {
#line 163
            flags |= 16U;
          } else {
#line 160
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 160
        if (et >= (double )maxtime) {
#line 163
          flags |= 16U;
        }
      }
    }
#line 166
    if (32768 == best + 1) {
#line 167
      return (best);
    }
#line 95
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (best <= savealpha) {
#line 172
    (TreePtr[1])->score = savealpha;
  }
  done: 
#line 182
  if (best > savealpha) {
#line 183
    history[side][pbest->move & 4095] += (unsigned long )((depth / 12) * (depth / 12));
  }
#line 185
  rootscore = best;
#line 186
  return (best);
}
}
#line 190 "/home/khheo/testset/chess/src/search.c"
int Search(int ply , int depth , int alpha , int beta , int nodetype ) 
{ 
  int best ;
  int score ;
  int nullscore ;
  int savealpha ;
  int side ;
  int xside ;
  int rc ;
  int t0 ;
  int t1___0 ;
  int firstmove ;
  int fcut ;
  int fdel ;
  int donull ;
  int savenode ;
  int nullthreatdone ;
  int extend ;
  leaf *p___1 ;
  leaf *pbest ;
  int g0 ;
  int g1 ;
  int upperbound ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
  {
  {
#line 209
  tmp___0 = EvaluateDraw();
  }
  }
#line 209
  if (tmp___0) {
#line 210
    if (computerplays == board.side) {
#line 210
      tmp = (opprating - myrating) / 4;
    } else {
#line 210
      tmp = (myrating - opprating) / 4;
    }
#line 210
    return (tmp);
  }
#line 211
  if (GameCnt >= Game50 + 3) {
    {
    {
#line 211
    tmp___2 = Repeat();
    }
    }
#line 211
    if (tmp___2) {
#line 213
      RepeatCnt ++;
#line 214
      if (computerplays == board.side) {
#line 214
        tmp___1 = (opprating - myrating) / 4;
      } else {
#line 214
        tmp___1 = (myrating - opprating) / 4;
      }
#line 214
      return (tmp___1);
    }
  }
  {
#line 217
  side = board.side;
#line 218
  xside = 1 ^ side;
#line 219
  donull = 1;
#line 231
  extend = 0;
  {
#line 232
  InChk[ply] = SqAtakd(board.king[side], xside);
  }
  }
#line 233
  if (InChk[ply]) {
    {
#line 235
    TreePtr[ply + 1] = TreePtr[ply];
    {
#line 236
    GenCheckEscapes(ply);
    }
    }
#line 237
    if ((unsigned long )TreePtr[ply] == (unsigned long )TreePtr[ply + 1]) {
#line 238
      return ((-32767 + ply) - 2);
    }
#line 239
    if ((unsigned long )(TreePtr[ply] + 1) == (unsigned long )TreePtr[ply + 1]) {
#line 241
      depth += 12;
#line 242
      extend = 1;
#line 243
      OneRepCnt ++;
    }
  }
#line 251
  if (rootscore + ply >= 32767) {
#line 252
    return (board.material[side] - board.material[1 ^ side]);
  }
#line 254
  g0 = Game[GameCnt].move;
#line 255
  if (GameCnt > 0) {
#line 255
    g1 = Game[GameCnt - 1].move;
  } else {
#line 255
    g1 = 0;
  }
  {
#line 256
  t0 = g0 & 63;
#line 257
  t1___0 = g1 & 63;
#line 258
  ChkCnt[ply + 1] = ChkCnt[ply];
#line 259
  ThrtCnt[ply + 1] = ThrtCnt[ply];
  {
#line 260
  KingThrt[0][ply] = MateScan(0);
  }
  {
#line 261
  KingThrt[1][ply] = MateScan(1);
  }
  }
#line 262
  if (InChk[ply]) {
#line 262
    if (ply <= (2 * Idepth) / 12) {
#line 264
      ChkExtCnt ++;
#line 265
      (ChkCnt[ply + 1]) ++;
#line 266
      depth += 12;
#line 267
      extend = 1;
    } else {
#line 262
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 269
  if (! KingThrt[side][ply - 1]) {
#line 269
    if (KingThrt[side][ply]) {
#line 269
      if (ply <= (2 * Idepth) / 12) {
#line 271
        KingExtCnt ++;
#line 272
        extend = 1;
#line 273
        depth += 12;
#line 274
        extend = 1;
#line 275
        donull = 0;
      } else {
#line 269
        goto _L___1;
      }
    } else {
#line 269
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 278
  if (g0 & 28672) {
#line 280
    PawnExtCnt ++;
#line 281
    depth += 12;
#line 282
    extend = 1;
  } else
#line 285
  if (g0 & 229376) {
#line 285
    if (board.material[computer] - board.material[1 ^ computer] == RootMaterial) {
#line 288
      RcpExtCnt ++;
#line 289
      depth += 12;
#line 290
      extend = 1;
    } else {
#line 285
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 293
  if (depth <= 12) {
#line 293
    if (cboard[t0] == 1) {
#line 293
      if (t0 >> 3 == rank7[xside]) {
#line 295
        PawnExtCnt ++;
#line 296
        depth += 12;
#line 297
        extend = 1;
      } else
#line 293
      if (t0 >> 3 == rank6[xside]) {
#line 295
        PawnExtCnt ++;
#line 296
        depth += 12;
#line 297
        extend = 1;
      }
    }
  }
#line 306
  if (ply > 2) {
#line 306
    if (InChk[ply - 1]) {
#line 306
      if (cboard[t0] != 6) {
#line 306
        if (t0 != t1___0) {
          {
          {
#line 306
          tmp___3 = SqAtakd(t0, xside);
          }
          }
#line 306
          if (! tmp___3) {
#line 309
            HorzExtCnt ++;
#line 310
            depth += 12;
#line 311
            extend = 1;
          }
        }
      }
    }
  }
#line 321
  if (depth <= 0) {
    {
    {
#line 322
    tmp___4 = Quiesce(ply, alpha, beta);
    }
    }
#line 322
    return (tmp___4);
  }
#line 332
  Hashmv[ply] = 0;
#line 333
  upperbound = 32767;
#line 334
  if (flags & 128U) {
    {
    {
#line 336
    rc = TTGet(side, depth, ply, alpha, beta, & score, & g1);
    }
    }
#line 337
    if (rc) {
#line 339
      Hashmv[ply] = g1 & 6324223;
      {
#line 342
      if (rc == 4) {
#line 342
        goto case_4;
      }
#line 343
      if (rc == 1) {
#line 343
        goto case_1;
      }
#line 344
      if (rc == 3) {
#line 344
        goto case_3;
      }
#line 348
      if (rc == 2) {
#line 348
        goto case_2;
      }
#line 351
      if (rc == 5) {
#line 351
        goto case_5;
      }
#line 353
      goto switch_default;
      case_4: /* CIL Label */ 
#line 342
      goto switch_break;
      case_1: /* CIL Label */ 
#line 343
      return (score);
      case_3: /* CIL Label */ 
#line 344
      if (beta < score) {
#line 344
        beta = beta;
      } else {
#line 344
        beta = score;
      }
#line 345
      upperbound = score;
#line 346
      donull = 0;
#line 347
      goto switch_break;
      case_2: /* CIL Label */ 
#line 349
      alpha = score;
#line 350
      goto switch_break;
      case_5: /* CIL Label */ 
#line 351
      Hashmv[ply] = 0;
#line 352
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 353
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 355
      if (alpha >= beta) {
#line 356
        return (score);
      }
    }
  }
#line 376
  if (ply > 4) {
#line 376
    if (InChk[ply - 2]) {
#line 376
      if (InChk[ply - 4]) {
#line 377
        donull = 0;
      }
    }
  }
#line 378
  if (flags & 512U) {
#line 378
    if (g0 != 1048576) {
#line 378
      if (depth > 12) {
#line 378
        if (nodetype != 0) {
#line 378
          if (! InChk[ply]) {
#line 378
            if ((board.material[side] - board.material[1 ^ side]) + 100 > beta) {
#line 378
              if (beta > -32767 + ply) {
#line 378
                if (donull) {
#line 378
                  if (board.pmaterial[side] > 350) {
#line 378
                    if (! threatply) {
                      {
#line 382
                      TreePtr[ply + 1] = TreePtr[ply];
                      {
#line 383
                      MakeNullMove(side);
                      }
                      {
#line 384
                      tmp___5 = Search(ply + 1, (depth - 12) - 24, - beta, - beta + 1,
                                       nodetype);
                      }
#line 384
                      nullscore = - tmp___5;
                      {
#line 385
                      UnmakeNullMove(xside);
                      }
                      }
#line 386
                      if (nullscore >= beta) {
#line 388
                        NullCutCnt ++;
#line 389
                        return (nullscore);
                      }
#line 391
                      if ((depth - 12) - 24 >= 1) {
#line 391
                        if (board.material[side] - board.material[1 ^ side] > beta) {
#line 391
                          if (nullscore <= -32511) {
#line 393
                            depth += 12;
#line 394
                            extend = 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 398
  if (InChk[ply]) {
#line 398
    if ((unsigned long )(TreePtr[ply] + 1) < (unsigned long )TreePtr[ply + 1]) {
      {
      {
#line 399
      SortMoves(ply);
      }
      }
    }
  }
#line 401
  pickphase[ply] = 1;
#line 402
  if (InChk[ply]) {
    {
    {
#line 402
    PhasePick1(& p___1, ply);
    }
    }
  } else {
    {
    {
#line 402
    PhasePick(& p___1, ply);
    }
    }
  }
#line 415
  fcut = 0;
#line 416
  if (1100 > maxposnscore[side]) {
#line 416
    fdel = 1100;
  } else {
#line 416
    fdel = maxposnscore[side];
  }
#line 417
  if (! extend) {
#line 417
    if (nodetype != 0) {
#line 417
      if (depth == 36) {
#line 417
        if ((board.material[side] - board.material[1 ^ side]) + fdel <= alpha) {
#line 419
          depth = 24;
#line 420
          RazrCutCnt ++;
        }
      }
    }
  }
#line 422
  if (550 > maxposnscore[side]) {
#line 422
    fdel = 550;
  } else {
#line 422
    fdel = maxposnscore[side];
  }
#line 423
  if (! extend) {
#line 423
    if (nodetype != 0) {
#line 423
      if (depth == 24) {
#line 423
        if ((board.material[side] - board.material[1 ^ side]) + fdel <= alpha) {
#line 423
          tmp___6 = 1;
        } else {
#line 423
          tmp___6 = 0;
        }
      } else {
#line 423
        tmp___6 = 0;
      }
    } else {
#line 423
      tmp___6 = 0;
    }
  } else {
#line 423
    tmp___6 = 0;
  }
#line 423
  fcut = tmp___6;
#line 424
  if (! fcut) {
#line 426
    if (300 > maxposnscore[side]) {
#line 426
      fdel = 300;
    } else {
#line 426
      fdel = maxposnscore[side];
    }
#line 427
    if (nodetype != 0) {
#line 427
      if (depth == 12) {
#line 427
        if ((board.material[side] - board.material[1 ^ side]) + fdel <= alpha) {
#line 427
          tmp___7 = 1;
        } else {
#line 427
          tmp___7 = 0;
        }
      } else {
#line 427
        tmp___7 = 0;
      }
    } else {
#line 427
      tmp___7 = 0;
    }
#line 427
    fcut = tmp___7;
  }
  {
  {
#line 430
  MakeMove(side, & p___1->move);
  }
#line 431
  NodeCnt ++;
#line 432
  g1 = 0;
#line 432
  g0 = g1;
  }
  {
  {
#line 433
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 433
    g0 = SqAtakd(board.king[side], xside);
    }
    }
#line 433
    if (! (g0 > 0)) {
#line 433
      if (fcut) {
#line 433
        if ((board.material[side] - board.material[1 ^ side]) + fdel < alpha) {
          {
          {
#line 433
          tmp___14 = SqAtakd(board.king[xside], side);
          }
          }
#line 433
          if (tmp___14) {
#line 433
            goto while_break;
          } else {
            {
            {
#line 433
            tmp___15 = MateScan(xside);
            }
            }
#line 433
            if (tmp___15) {
#line 433
              goto while_break;
            }
          }
        } else {
#line 433
          goto while_break;
        }
      } else {
#line 433
        goto while_break;
      }
    }
#line 437
    if (g0 == 0) {
#line 437
      g1 ++;
    }
    {
    {
#line 438
    UnmakeMove(xside, & p___1->move);
    }
    }
#line 439
    if (InChk[ply]) {
      {
      {
#line 439
      tmp___11 = PhasePick1(& p___1, ply);
      }
#line 439
      tmp___13 = tmp___11;
      }
    } else {
      {
      {
#line 439
      tmp___12 = PhasePick(& p___1, ply);
      }
#line 439
      tmp___13 = tmp___12;
      }
    }
#line 439
    if (tmp___13 == 0) {
#line 440
      if (g1) {
        {
        {
#line 440
        tmp___8 = Evaluate(alpha, beta);
        }
#line 440
        tmp___10 = tmp___8;
        }
      } else {
#line 440
        if (computerplays == board.side) {
#line 440
          tmp___9 = (opprating - myrating) / 4;
        } else {
#line 440
          tmp___9 = (myrating - opprating) / 4;
        }
#line 440
        tmp___10 = tmp___9;
      }
#line 440
      return (tmp___10);
    }
    {
    {
#line 441
    MakeMove(side, & p___1->move);
    }
#line 442
    NodeCnt ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  firstmove = 1;
#line 445
  pbest = p___1;
#line 446
  best = -32767;
#line 447
  savealpha = alpha;
#line 448
  nullthreatdone = 0;
#line 449
  nullscore = 32767;
#line 450
  savenode = nodetype;
#line 451
  if (nodetype != 0) {
#line 452
    if (nodetype == 2) {
#line 452
      nodetype = 1;
    } else {
#line 452
      nodetype = 2;
    }
  }
  {
  {
#line 454
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 457
    if (firstmove) {
      {
#line 459
      firstmove = 0;
      {
#line 460
      tmp___16 = Search(ply + 1, depth - 12, - beta, - alpha, nodetype);
      }
#line 460
      score = - tmp___16;
      }
    } else {
#line 466
      if (InChk[ply]) {
        {
        {
#line 466
        tmp___17 = PhasePick1(& p___1, ply);
        }
#line 466
        tmp___19 = tmp___17;
        }
      } else {
        {
        {
#line 466
        tmp___18 = PhasePick(& p___1, ply);
        }
#line 466
        tmp___19 = tmp___18;
        }
      }
#line 466
      if (tmp___19 == 0) {
#line 467
        goto while_break___0;
      }
      {
      {
#line 491
      MakeMove(side, & p___1->move);
      }
#line 492
      NodeCnt ++;
      {
#line 493
      tmp___20 = SqAtakd(board.king[side], xside);
      }
      }
#line 493
      if (tmp___20) {
        {
        {
#line 495
        UnmakeMove(xside, & p___1->move);
        }
        }
#line 496
        goto while_continue___0;
      }
#line 508
      if (fcut) {
#line 508
        if ((board.material[side] - board.material[1 ^ side]) + fdel <= alpha) {
          {
          {
#line 508
          tmp___21 = SqAtakd(board.king[xside], side);
          }
          }
#line 508
          if (! tmp___21) {
            {
            {
#line 508
            tmp___22 = MateScan(xside);
            }
            }
#line 508
            if (! tmp___22) {
              {
              {
#line 512
              UnmakeMove(xside, & p___1->move);
              }
#line 513
              FutlCutCnt ++;
#line 514
              NodeCnt --;
              }
#line 515
              goto while_continue___0;
            }
          }
        }
      }
#line 517
      NodeCnt ++;
#line 519
      if (nodetype == 0) {
#line 520
        nodetype = 2;
      }
#line 521
      if (best > alpha) {
#line 521
        alpha = best;
      } else {
#line 521
        alpha = alpha;
      }
      {
      {
#line 522
      tmp___23 = Search(ply + 1, depth - 12, - alpha - 1, - alpha, nodetype);
      }
#line 522
      score = - tmp___23;
      }
#line 523
      if (score > best) {
#line 525
        if (savenode == 0) {
#line 526
          nodetype = 0;
        }
#line 527
        if (alpha < score) {
#line 527
          if (score < beta) {
            {
            {
#line 529
            tmp___24 = Search(ply + 1, depth - 12, - beta, - score, nodetype);
            }
#line 529
            score = - tmp___24;
            }
          }
        }
#line 531
        if (nodetype == 0) {
#line 531
          if (score <= alpha) {
#line 531
            if (Game[GameCnt + 1].move == 1048576) {
              {
              {
#line 534
              tmp___25 = Search(ply + 1, depth - 12, - alpha, 32767, nodetype);
              }
#line 534
              score = - tmp___25;
              }
            }
          }
        }
      }
    }
    {
    {
#line 538
    UnmakeMove(xside, & p___1->move);
    }
    }
#line 568
    if (score > best) {
#line 570
      best = score;
#line 571
      pbest = p___1;
#line 572
      if (best >= beta) {
#line 573
        goto done;
      }
    }
#line 576
    if (flags & 16U) {
#line 578
      if (ply & 1) {
#line 578
        best = rootscore;
      } else {
#line 578
        best = - rootscore;
      }
#line 579
      return (best);
    }
#line 582
    if (SearchDepth == 0) {
#line 582
      if ((NodeCnt & 1023UL) == 0UL) {
        {
        {
#line 584
        GetElapsed();
        }
        }
#line 585
        if (et >= (double )SearchTime) {
#line 585
          if (rootscore == -32768) {
#line 588
            flags |= 16U;
          } else
#line 585
          if (ply1score > lastrootscore - 25) {
#line 588
            flags |= 16U;
          } else
#line 585
          if (flags & 256U) {
#line 588
            flags |= 16U;
          } else {
#line 585
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 585
        if (et >= (double )maxtime) {
#line 588
          flags |= 16U;
        }
      }
    }
#line 594
    if (32768 == best + ply) {
#line 595
      goto done;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  done: 
#line 611
  if (flags & 128U) {
    {
    {
#line 612
    TTPut(side, depth, ply, savealpha, beta, best, pbest->move);
    }
    }
  }
#line 615
  if (best > savealpha) {
#line 616
    history[side][pbest->move & 4095] += (unsigned long )((depth / 12) * (depth / 12));
  }
#line 619
  if (! (pbest->move & 258048)) {
#line 619
    if (best > savealpha) {
#line 621
      if (killer1[ply] == 0) {
#line 622
        killer1[ply] = pbest->move & 6324223;
      } else
#line 623
      if ((pbest->move & 6324223) != killer1[ply]) {
#line 624
        killer2[ply] = pbest->move & 6324223;
      }
    }
  }
#line 627
  return (best);
}
}
#line 631 "/home/khheo/testset/chess/src/search.c"
void ShowLine(int move  __attribute__((__unused__)) , int score , char c ) 
{ 
  int i ;
  int len ;
  int pvar[65] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 645
  if (! (flags & 4096U)) {
#line 646
    return;
  }
#line 647
  if (NodeCnt < 500000UL) {
#line 647
    if (flags & 256U) {
#line 649
      return;
    }
  }
#line 651
  if (Idepth == 12) {
#line 651
    if ((int )c == 38) {
#line 652
      return;
    }
  }
#line 653
  if (flags & 1024U) {
#line 653
    if ((int )c == 38) {
#line 654
      return;
    }
  }
#line 655
  if (rootscore == -32768) {
#line 656
    return;
  }
  {
  {
#line 657
  GetElapsed();
  }
  }
#line 663
  if (flags & 1024U) {
#line 664
    if (score > 32512) {
      {
      {
#line 665
      tmp = abs(score);
      }
      {
#line 665
      printf((char const   */* __restrict  */)"%d%c Mat%d %d %lu\t", Idepth / 12,
             (int )c, (32769 - tmp) / 2, (int )(et * (double )100), NodeCnt + QuiesCnt);
      }
      }
#line 667
      if ((unsigned long )ofp != (unsigned long )stdout) {
        {
        {
#line 668
        tmp___0 = abs(score);
        }
        {
#line 668
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%2d%c%7.2f  Mat%02d%10lu\t",
                Idepth / 12, (int )c, et, (32769 - tmp___0) / 2, NodeCnt + QuiesCnt);
        }
        }
      }
    } else
#line 670
    if (score < -32512) {
      {
      {
#line 671
      tmp___1 = abs(score);
      }
      {
#line 671
      printf((char const   */* __restrict  */)"%d%c -Mat%2d %d %lu\t", Idepth / 12,
             (int )c, (32769 - tmp___1) / 2, (int )(et * (double )100), NodeCnt + QuiesCnt);
      }
      }
#line 673
      if ((unsigned long )ofp != (unsigned long )stdout) {
        {
        {
#line 674
        tmp___2 = abs(score);
        }
        {
#line 674
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%2d%c%7.2f -Mat%02d%10lu\t",
                Idepth / 12, (int )c, et, (32769 - tmp___2) / 2, NodeCnt + QuiesCnt);
        }
        }
      }
    } else {
      {
      {
#line 677
      printf((char const   */* __restrict  */)"%d%c %d %d %lu\t", Idepth / 12, (int )c,
             score, (int )(et * (double )100), NodeCnt + QuiesCnt);
      }
      }
#line 679
      if ((unsigned long )ofp != (unsigned long )stdout) {
        {
        {
#line 680
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%2d%c%7.2f%7d%10lu\t",
                Idepth / 12, (int )c, et, score, NodeCnt + QuiesCnt);
        }
        }
      }
    }
  } else
#line 684
  if (score > 32512) {
    {
    {
#line 685
    tmp___3 = abs(score);
    }
    {
#line 685
    printf((char const   */* __restrict  */)"\r%2d%c%7.2f  Mat%02d%10lu\t", Idepth / 12,
           (int )c, et, (32769 - tmp___3) / 2, NodeCnt + QuiesCnt);
    }
    }
#line 687
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 688
      tmp___4 = abs(score);
      }
      {
#line 688
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\r%2d%c%7.2f  Mat%02d%10lu\t",
              Idepth / 12, (int )c, et, (32769 - tmp___4) / 2, NodeCnt + QuiesCnt);
      }
      }
    }
  } else
#line 690
  if (score < -32512) {
    {
    {
#line 691
    tmp___5 = abs(score);
    }
    {
#line 691
    printf((char const   */* __restrict  */)"\r%2d%c%7.2f -Mat%02d%10lu\t", Idepth / 12,
           (int )c, et, (32769 - tmp___5) / 2, NodeCnt + QuiesCnt);
    }
    }
#line 693
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 694
      tmp___6 = abs(score);
      }
      {
#line 694
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\r%2d%c%7.2f -Mat%02d%10lu\t",
              Idepth / 12, (int )c, et, (32769 - tmp___6) / 2, NodeCnt + QuiesCnt);
      }
      }
    }
  } else {
    {
    {
#line 697
    printf((char const   */* __restrict  */)"\r%2d%c%7.2f%7d%10lu\t", Idepth / 12,
           (int )c, et, score, NodeCnt + QuiesCnt);
    }
    }
#line 698
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 699
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\r%2d%c%7.2f%7d%10lu\t",
              Idepth / 12, (int )c, et, score, NodeCnt + QuiesCnt);
      }
      }
    }
  }
#line 703
  if ((int )c == 45) {
    {
    {
#line 705
    printf((char const   */* __restrict  */)"\n");
    }
    }
#line 706
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 706
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n");
      }
      }
    }
#line 707
    return;
  } else
#line 709
  if ((int )c == 43) {
    {
    {
#line 711
    SANMove(RootPV, 1);
    }
    {
#line 712
    printf((char const   */* __restrict  */)" %s\n", SANmv);
    }
    }
#line 713
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 713
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" %s\n",
              SANmv);
      }
      }
    }
#line 714
    return;
  }
  {
  {
#line 717
  SANMove(RootPV, 1);
  }
  {
#line 718
  printf((char const   */* __restrict  */)" %s", SANmv);
  }
  }
#line 719
  if ((unsigned long )ofp != (unsigned long )stdout) {
    {
    {
#line 719
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" %s",
            SANmv);
    }
    }
  }
  {
  {
#line 720
  MakeMove(board.side, & RootPV);
  }
#line 721
  TreePtr[3] = TreePtr[2];
  {
#line 722
  GenMoves(2);
  }
  {
#line 723
  tmp___7 = strlen((char const   *)(SANmv));
  }
#line 723
  len = (int )tmp___7;
#line 724
  i = 2;
#line 725
  pvar[1] = RootPV;
  }
#line 728
  if (flags & 128U) {
    {
    {
#line 730
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 730
      tmp___11 = TTGetPV(board.side, i, rootscore, & pvar[i]);
      }
      }
#line 730
      if (! tmp___11) {
#line 730
        goto while_break;
      }
#line 732
      if (score > 32512) {
#line 732
        goto _L___0;
      } else
#line 732
      if (score < -32512) {
        _L___0: /* CIL Label */ 
        {
        {
#line 732
        tmp___8 = abs(score);
        }
        }
#line 732
        if (tmp___8 == 32769 - i) {
#line 733
          goto while_break;
        } else {
#line 732
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 732
        tmp___9 = Repeat();
        }
        }
#line 732
        if (tmp___9) {
#line 733
          goto while_break;
        }
      }
#line 735
      if (len >= 32) {
        {
        {
#line 737
        printf((char const   */* __restrict  */)"\n\t\t\t\t");
        }
        }
#line 738
        if ((unsigned long )ofp != (unsigned long )stdout) {
          {
          {
#line 738
          fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n\t\t\t\t");
          }
          }
        }
#line 739
        len = 0;
      }
      {
      {
#line 741
      SANMove(pvar[i], i);
      }
      {
#line 742
      printf((char const   */* __restrict  */)" %s", SANmv);
      }
      }
#line 743
      if ((unsigned long )ofp != (unsigned long )stdout) {
        {
        {
#line 743
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" %s",
                SANmv);
        }
        }
      }
      {
      {
#line 744
      MakeMove(board.side, & pvar[i]);
      }
#line 745
      TreePtr[i + 2] = TreePtr[i + 1];
#line 746
      i ++;
      {
#line 746
      GenMoves(i);
      }
      {
#line 747
      tmp___10 = strlen((char const   *)(SANmv));
      }
#line 747
      len = (int )((size_t )len + tmp___10);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 751
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 752
  if ((unsigned long )ofp != (unsigned long )stdout) {
    {
    {
#line 752
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n");
    }
    }
  }
#line 753
  i --;
  {
  {
#line 753
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 753
    if (! i) {
#line 753
      goto while_break___0;
    }
    {
    {
#line 754
    UnmakeMove(board.side, & pvar[i]);
    }
#line 753
    i --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 755
  fflush(stdout);
  }
  }
#line 756
  if ((unsigned long )ofp != (unsigned long )stdout) {
    {
    {
#line 756
    fflush(ofp);
    }
    }
  }
#line 757
  return;
}
}
#line 32 "/home/khheo/testset/chess/src/repeat.c"
int Repeat(void) 
{ 
  int i ;
  int k___0 ;

  {
#line 36
  k___0 = 0;
#line 37
  i = GameCnt - 3;
  {
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i >= Game50)) {
#line 37
      goto while_break;
    }
#line 39
    if (Game[i].hashkey == HashKey) {
#line 40
      k___0 ++;
    }
#line 37
    i -= 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return (k___0);
}
}
#line 623 "/home/khheo/testset/chess/src/common.h"
uint32_t Rand32(void) ;
#line 624
HashType Rand64(void) ;
#line 47 "/home/khheo/testset/chess/src/random.c"
static uint32_t x[55]  = 
#line 47 "/home/khheo/testset/chess/src/random.c"
  {      (uint32_t )1410651636UL,      (uint32_t )3012776752UL,      (uint32_t )3497475623UL,      (uint32_t )2892145026UL, 
        (uint32_t )1571949714UL,      (uint32_t )3253082284UL,      (uint32_t )3489895018UL,      (uint32_t )387949491UL, 
        (uint32_t )2597396737UL,      (uint32_t )1981903553UL,      (uint32_t )3160251843UL,      (uint32_t )129444464UL, 
        (uint32_t )1851443344UL,      (uint32_t )4156445905UL,      (uint32_t )224604922UL,      (uint32_t )1455067070UL, 
        (uint32_t )3953493484UL,      (uint32_t )1460937157UL,      (uint32_t )2528362617UL,      (uint32_t )317430674UL, 
        (uint32_t )3229354360UL,      (uint32_t )117491133UL,      (uint32_t )832845075UL,      (uint32_t )1961600170UL, 
        (uint32_t )1321557429UL,      (uint32_t )747750121UL,      (uint32_t )545747446UL,      (uint32_t )810476036UL, 
        (uint32_t )503334515UL,      (uint32_t )4088144633UL,      (uint32_t )2824216555UL,      (uint32_t )3738252341UL, 
        (uint32_t )3493754131UL,      (uint32_t )3672533954UL,      (uint32_t )29494241UL,      (uint32_t )1180928407UL, 
        (uint32_t )4213624418UL,      (uint32_t )33062851UL,      (uint32_t )3221315737UL,      (uint32_t )1145213552UL, 
        (uint32_t )2957984897UL,      (uint32_t )4078668503UL,      (uint32_t )2262661702UL,      (uint32_t )65478801UL, 
        (uint32_t )2527208841UL,      (uint32_t )1960622036UL,      (uint32_t )315685891UL,      (uint32_t )1196037864UL, 
        (uint32_t )804614524UL,      (uint32_t )1421733266UL,      (uint32_t )2017105031UL,      (uint32_t )3882325900UL, 
        (uint32_t )810735053UL,      (uint32_t )384606609UL,      (uint32_t )2393861397UL};
#line 105 "/home/khheo/testset/chess/src/random.c"
static int init  =    1;
#line 106 "/home/khheo/testset/chess/src/random.c"
static uint32_t y[55]  ;
#line 107 "/home/khheo/testset/chess/src/random.c"
static int j  ;
#line 107 "/home/khheo/testset/chess/src/random.c"
static int k  ;
#line 32 "/home/khheo/testset/chess/src/random.c"
uint32_t Rand32(void) 
{ 
  uint32_t ul ;
  int i ;
  uint32_t tmp ;

  {
#line 110
  if (init) {
#line 113
    init = 0;
#line 114
    i = 0;
    {
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 114
      if (! (i < 55)) {
#line 114
        goto while_break;
      }
#line 115
      y[i] = x[i];
#line 114
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 116
    j = 23;
#line 117
    k = 54;
  }
#line 119
  tmp = y[k] + y[j];
#line 119
  y[k] = tmp;
#line 119
  ul = tmp;
#line 120
  j --;
#line 120
  if (j < 0) {
#line 120
    j = 54;
  }
#line 121
  k --;
#line 121
  if (k < 0) {
#line 121
    k = 54;
  }
#line 122
  return (ul);
}
}
#line 125 "/home/khheo/testset/chess/src/random.c"
HashType Rand64(void) 
{ 
  HashType b ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 129
  tmp = Rand32();
  }
#line 129
  b = (HashType )tmp;
#line 130
  b <<= 32;
  {
#line 131
  tmp___0 = Rand32();
  }
#line 131
  b |= (unsigned long )tmp___0;
  }
#line 132
  return (b);
}
}
#line 32 "/home/khheo/testset/chess/src/quiesce.c"
int Quiesce(int ply , int alpha , int beta ) 
{ 
  int side ;
  int xside ;
  int best ;
  int delta ;
  int score ;
  int savealpha ;
  leaf *p___1 ;
  leaf *pbest ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 44
  tmp___0 = EvaluateDraw();
  }
  }
#line 44
  if (tmp___0) {
#line 45
    if (computerplays == board.side) {
#line 45
      tmp = (opprating - myrating) / 4;
    } else {
#line 45
      tmp = (myrating - opprating) / 4;
    }
#line 45
    return (tmp);
  }
  {
#line 47
  side = board.side;
#line 48
  xside = 1 ^ side;
  {
#line 49
  InChk[ply] = SqAtakd(board.king[side], xside);
  }
  {
#line 50
  best = Evaluate(alpha, beta);
  }
  }
#line 51
  if (best >= beta) {
#line 51
    if (! InChk[ply]) {
#line 52
      return (best);
    }
  }
#line 53
  TreePtr[ply + 1] = TreePtr[ply];
#line 54
  if (InChk[ply]) {
    {
    {
#line 56
    GenCheckEscapes(ply);
    }
    }
#line 57
    if ((unsigned long )TreePtr[ply] == (unsigned long )TreePtr[ply + 1]) {
#line 58
      return ((-32767 + ply) - 2);
    }
#line 59
    if (best >= beta) {
#line 60
      return (best);
    }
    {
    {
#line 61
    SortMoves(ply);
    }
    }
  } else {
    {
    {
#line 65
    GenCaptures(ply);
    }
    }
#line 66
    if ((unsigned long )TreePtr[ply] == (unsigned long )TreePtr[ply + 1]) {
#line 67
      return (best);
    }
    {
    {
#line 68
    SortCaptures(ply);
    }
    }
  }
#line 71
  savealpha = alpha;
#line 72
  pbest = (leaf *)((void *)0);
#line 73
  if (best > alpha) {
#line 73
    alpha = best;
  } else {
#line 73
    alpha = alpha;
  }
#line 74
  if ((alpha - 150) - best > 0) {
#line 74
    delta = (alpha - 150) - best;
  } else {
#line 74
    delta = 0;
  }
#line 76
  p___1 = TreePtr[ply];
  {
  {
#line 76
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[ply + 1])) {
#line 76
      goto while_break;
    }
    {
    {
#line 78
    pick(p___1, ply);
    }
    }
#line 81
    if (! InChk[ply]) {
      {
      {
#line 81
      tmp___1 = SwapOff(p___1->move);
      }
      }
#line 81
      if (tmp___1 < delta) {
#line 82
        goto __Cont;
      }
    }
#line 85
    if (p___1->score == -32767) {
#line 86
      goto __Cont;
    }
    {
    {
#line 100
    MakeMove(side, & p___1->move);
    }
#line 101
    QuiesCnt ++;
    {
#line 102
    tmp___2 = SqAtakd(board.king[side], xside);
    }
    }
#line 102
    if (tmp___2) {
      {
      {
#line 104
      UnmakeMove(xside, & p___1->move);
      }
      }
#line 105
      goto __Cont;
    }
    {
    {
#line 107
    tmp___3 = Quiesce(ply + 1, - beta, - alpha);
    }
#line 107
    score = - tmp___3;
    {
#line 108
    UnmakeMove(xside, & p___1->move);
    }
    }
#line 109
    if (score > best) {
#line 111
      best = score;
#line 112
      pbest = p___1;
#line 113
      if (best >= beta) {
#line 114
        goto done;
      }
#line 115
      if (alpha > best) {
#line 115
        alpha = alpha;
      } else {
#line 115
        alpha = best;
      }
    }
    __Cont: /* CIL Label */ 
#line 76
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 120
  if (flags & 128U) {
#line 120
    if ((unsigned long )pbest != (unsigned long )((void *)0)) {
      {
      {
#line 121
      TTPut(side, 0, ply, savealpha, beta, best, pbest->move);
      }
      }
    }
  }
#line 123
  return (best);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 407
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 562
extern int putchar(int __c ) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 668
extern int puts(char const   *__s ) ;
#line 675
extern int ungetc(int __c , FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 282
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 189
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 237
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 420 "/home/khheo/testset/chess/src/common.h"
char name[50] ;
#line 427
int newpos ;
#line 427
int existpos ;
#line 474
void InitVars(void) ;
#line 483
int BookBuilderOpen(void) ;
#line 484
int BookBuilder(int result , int side ) ;
#line 485
int BookBuilderClose(void) ;
#line 515
leaf *ValidateMove(char *s___1 ) ;
#line 565
void PGNSaveToFile(char const   *file___0 , char const   *resultstr ) ;
#line 566
void PGNReadFromFile(char const   *file___0 ) ;
#line 567
void BookPGNReadFromFile(char const   *file___0 ) ;
#line 37 "/home/khheo/testset/chess/src/pgn.c"
void PGNSaveToFile(char const   *file___0 , char const   *resultstr ) 
{ 
  FILE *fp___0 ;
  char s___1[100] ;
  int len ;
  char *p___1 ;
  int i ;
  time_t secs ;
  struct tm *timestruct ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
  {
#line 53
  fp___0 = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"a");
  }
  }
#line 54
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 56
    printf((char const   */* __restrict  */)"Cannot write to file %s\n", file___0);
    }
    }
#line 57
    return;
  }
  {
  {
#line 61
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Event \"\"]\n");
  }
  {
#line 62
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Site \"\"]\n");
  }
  {
#line 63
  secs = time((time_t *)0);
  }
  {
#line 64
  timestruct = localtime((time_t const   *)(& secs));
  }
  {
#line 65
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Date \"%4d.%02d.%02d\"]\n",
          timestruct->tm_year + 1900, timestruct->tm_mon + 1, timestruct->tm_mday);
  }
  {
#line 67
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Round \"\"]\n");
  }
  }
#line 68
  if (computerplays == 0) {
    {
    {
#line 69
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[White \"%s %s\"]\n",
            "GNU Chess", "5.05");
    }
    }
  } else {
    {
    {
#line 71
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[White \"%s\"]\n",
            name);
    }
    }
  }
#line 72
  if (computerplays == 1) {
    {
    {
#line 73
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Black \"%s %s\"]\n",
            "GNU Chess", "5.05");
    }
    }
  } else {
    {
    {
#line 75
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Black \"%s\"]\n",
            name);
    }
    }
  }
#line 76
  if (computer == 0) {
#line 76
    tmp = myrating;
  } else {
#line 76
    tmp = opprating;
  }
  {
  {
#line 76
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[WhiteELO \"%d\"]\n",
          tmp);
  }
  }
#line 77
  if (computer == 0) {
#line 77
    tmp___0 = opprating;
  } else {
#line 77
    tmp___0 = myrating;
  }
  {
  {
#line 77
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[BlackELO \"%d\"]\n",
          tmp___0);
  }
  {
#line 80
  tmp___1 = strcspn(resultstr, " {");
  }
#line 80
  len = (int )tmp___1;
  {
#line 81
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"[Result \"%.*s\"]\n",
          len, resultstr);
  }
  {
#line 82
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
  }
#line 84
  s___1[0] = (char )'\000';
#line 85
  i = 0;
  }
  {
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i <= GameCnt)) {
#line 85
      goto while_break;
    }
#line 87
    if (i == GameCnt) {
      {
      {
#line 94
      sprintf((char */* __restrict  */)(s___1), (char const   */* __restrict  */)"%s%d. %s ",
              s___1, i / 2 + 1, Game[i].SANmv);
      }
      }
    } else {
      {
      {
#line 98
      sprintf((char */* __restrict  */)(s___1), (char const   */* __restrict  */)"%s%d. %s %s ",
              s___1, i / 2 + 1, Game[i].SANmv, Game[i + 1].SANmv);
      }
      }
    }
    {
    {
#line 100
    tmp___3 = strlen((char const   *)(s___1));
    }
    }
#line 100
    if (tmp___3 > 80UL) {
#line 102
      p___1 = s___1 + 79;
      {
      {
#line 103
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 103
        tmp___2 = p___1;
#line 103
        p___1 --;
#line 103
        if (! ((int )*tmp___2 != 32)) {
#line 103
          goto while_break___0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 104
      p___1 ++;
#line 104
      *p___1 = (char )'\000';
      {
#line 105
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s\n",
              s___1);
      }
      {
#line 106
      strcpy((char */* __restrict  */)(s___1), (char const   */* __restrict  */)(p___1 + 1));
      }
      }
    }
#line 85
    i += 2;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 109
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s",
          s___1);
  }
  {
#line 110
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%s",
          resultstr);
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n\n");
  }
  {
#line 112
  fclose(fp___0);
  }
  }
#line 114
  return;
}
}
#line 117 "/home/khheo/testset/chess/src/pgn.c"
void PGNReadFromFile(char const   *file___0 ) 
{ 
  FILE *fp___0 ;
  char s___1[100] ;
  char c ;
  char wmv[8] ;
  char bmv[8] ;
  int moveno ;
  leaf *p___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 129
  fp___0 = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"r");
  }
  }
#line 130
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 132
    printf((char const   */* __restrict  */)"Cannot open file %s\n", file___0);
    }
    }
#line 133
    return;
  }
  {
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 139
    tmp = fgetc(fp___0);
    }
#line 139
    c = (char )tmp;
    }
#line 139
    if ((int )c == 91) {
      {
      {
#line 140
      fgets((char */* __restrict  */)(s___1), 100, (FILE */* __restrict  */)fp___0);
      }
      }
    }
#line 137
    if (! ((int )c == 91)) {
#line 137
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 142
  ungetc((int )c, fp___0);
  }
  {
#line 144
  InitVars();
  }
  }
  {
  {
#line 145
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 145
    tmp___1 = feof(fp___0);
    }
    }
#line 145
    if (tmp___1) {
#line 145
      goto while_break___0;
    }
    {
    {
#line 147
    tmp___0 = fgetc(fp___0);
    }
#line 147
    c = (char )tmp___0;
    }
#line 148
    if ((int )c == 42) {
#line 148
      goto while_break___0;
    }
    {
    {
#line 149
    ungetc((int )c, fp___0);
    }
    {
#line 150
    fscanf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%d. %7s %7s ",
           & moveno, wmv, bmv);
    }
    {
#line 151
    p___1 = ValidateMove(wmv);
    }
    }
#line 152
    if (! p___1) {
      {
      {
#line 154
      printf((char const   */* __restrict  */)"Illegal move %d. %s\n", moveno, wmv);
      }
      }
#line 155
      goto while_break___0;
    }
    {
    {
#line 157
    MakeMove(0, & p___1->move);
    }
    {
#line 158
    strcpy((char */* __restrict  */)(Game[GameCnt].SANmv), (char const   */* __restrict  */)(wmv));
    }
    }
#line 159
    if ((int )bmv[0] == 42) {
#line 159
      goto while_break___0;
    }
    {
    {
#line 160
    p___1 = ValidateMove(bmv);
    }
    }
#line 161
    if (! p___1) {
      {
      {
#line 163
      printf((char const   */* __restrict  */)"Illegal move %d. ... %s\n", moveno,
             bmv);
      }
      }
#line 164
      goto while_break___0;
    }
    {
    {
#line 166
    MakeMove(1, & p___1->move);
    }
    {
#line 167
    strcpy((char */* __restrict  */)(Game[GameCnt].SANmv), (char const   */* __restrict  */)(bmv));
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 169
  printf((char const   */* __restrict  */)"%d\n", GameCnt);
  }
  {
#line 170
  fclose(fp___0);
  }
  {
#line 171
  ShowBoard();
  }
  {
#line 172
  TTClear();
  }
  }
#line 173
  return;
}
}
#line 176 "/home/khheo/testset/chess/src/pgn.c"
void BookPGNReadFromFile(char const   *file___0 ) 
{ 
  FILE *fp___0 ;
  char s___1[100] ;
  char wmv[8] ;
  char bmv[8] ;
  int c ;
  unsigned int i ;
  char header[2000] ;
  int moveno ;
  int result ;
  int ngames ;
  leaf *p___1 ;
  time_t t1___0 ;
  time_t t2___0 ;
  double et___0 ;
  int examinecolor ;
  int playerfound[2] ;
  char const   *player[103] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;

  {
  {
#line 188
  ngames = 0;
#line 203
  player[0] = "Alekhine";
#line 203
  player[1] = "Adams";
#line 203
  player[2] = "Anand";
#line 203
  player[3] = "Anderssen";
#line 203
  player[4] = "Andersson";
#line 203
  player[5] = "Aronin";
#line 203
  player[6] = "Averbakh";
#line 203
  player[7] = "Balashov";
#line 203
  player[8] = "Beliavsky";
#line 203
  player[9] = "Benko";
#line 203
  player[10] = "Bernstein";
#line 203
  player[11] = "Bird";
#line 203
  player[12] = "Bogoljubow";
#line 203
  player[13] = "Bolbochan";
#line 203
  player[14] = "Boleslavsky";
#line 203
  player[15] = "Byrne";
#line 203
  player[16] = "Botvinnik";
#line 203
  player[17] = "Bronstein";
#line 203
  player[18] = "Browne";
#line 203
  player[19] = "Capablanca";
#line 203
  player[20] = "Chigorin";
#line 203
  player[21] = "Christiansen";
#line 203
  player[22] = "De Firmian";
#line 203
  player[23] = "Deep Blue";
#line 203
  player[24] = "Deep Thought";
#line 203
  player[25] = "Donner";
#line 203
  player[26] = "Dreev";
#line 203
  player[27] = "Duras";
#line 203
  player[28] = "Euwe";
#line 203
  player[29] = "Evans";
#line 203
  player[30] = "Filip";
#line 203
  player[31] = "Fine";
#line 203
  player[32] = "Fischer";
#line 203
  player[33] = "Flohr";
#line 203
  player[34] = "Furman";
#line 203
  player[35] = "Gelfand";
#line 203
  player[36] = "Geller";
#line 203
  player[37] = "Gereben";
#line 203
  player[38] = "Glek";
#line 203
  player[39] = "Gligoric";
#line 203
  player[40] = "GNU";
#line 203
  player[41] = "Golombek";
#line 203
  player[42] = "Gruenfeld";
#line 203
  player[43] = "Guimard";
#line 203
  player[44] = "Hodgson";
#line 203
  player[45] = "Ivanchuk";
#line 203
  player[46] = "Ivkov";
#line 203
  player[47] = "Janowsky";
#line 203
  player[48] = "Kamsky";
#line 203
  player[49] = "Kan";
#line 203
  player[50] = "Karpov";
#line 203
  player[51] = "Kasparov";
#line 203
  player[52] = "Keres";
#line 203
  player[53] = "Korchnoi";
#line 203
  player[54] = "Kortschnoj";
#line 203
  player[55] = "Kotov";
#line 203
  player[56] = "Kramnik";
#line 203
  player[57] = "Kupreich";
#line 203
  player[58] = "Lasker";
#line 203
  player[59] = "Lautier";
#line 203
  player[60] = "Letelier";
#line 203
  player[61] = "Lilienthal";
#line 203
  player[62] = "Ljubojevic";
#line 203
  player[63] = "Marshall";
#line 203
  player[64] = "Maroczy";
#line 203
  player[65] = "Mieses";
#line 203
  player[66] = "Miles";
#line 203
  player[67] = "Morphy";
#line 203
  player[68] = "Mueller";
#line 203
  player[69] = "Nimzowitsch";
#line 203
  player[70] = "Nunn";
#line 203
  player[71] = "Opocensky";
#line 203
  player[72] = "Pachman";
#line 203
  player[73] = "Petrosian";
#line 203
  player[74] = "Piket";
#line 203
  player[75] = "Pilnik";
#line 203
  player[76] = "Pirc";
#line 203
  player[77] = "Polgar";
#line 203
  player[78] = "Portisch";
#line 203
  player[79] = "Psakhis";
#line 203
  player[80] = "Ragozin";
#line 203
  player[81] = "Reshevsky";
#line 203
  player[82] = "Reti";
#line 203
  player[83] = "Romanish";
#line 203
  player[84] = "Rubinstein";
#line 203
  player[85] = "Saemisch";
#line 203
  player[86] = "Seirawan";
#line 203
  player[87] = "Shirov";
#line 203
  player[88] = "Short";
#line 203
  player[89] = "Silman";
#line 203
  player[90] = "Smyslov";
#line 203
  player[91] = "Sokolsky";
#line 203
  player[92] = "Spassky";
#line 203
  player[93] = "Sveshnikov";
#line 203
  player[94] = "Stahlberg";
#line 203
  player[95] = "Steinitz";
#line 203
  player[96] = "Tal";
#line 203
  player[97] = "Tarjan";
#line 203
  player[98] = "Tartakower";
#line 203
  player[99] = "Timman";
#line 203
  player[100] = "Topalov";
#line 203
  player[101] = "Torre";
#line 203
  player[102] = "Vidmar";
#line 310
  et___0 = 0.0;
  {
#line 311
  t1___0 = time((time_t *)((void *)0));
  }
#line 312
  result = -1;
  {
#line 313
  fp___0 = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"r");
  }
  }
#line 314
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 316
    tmp = __errno_location();
    }
    {
#line 316
    tmp___0 = strerror(*tmp);
    }
    {
#line 316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open file %s: %s\n",
            file___0, tmp___0);
    }
    }
#line 318
    return;
  }
  {
  {
#line 322
  tmp___1 = BookBuilderOpen();
  }
  }
#line 322
  if (tmp___1 != 0) {
#line 323
    return;
  }
#line 324
  existpos = 0;
#line 324
  newpos = existpos;
  nextgame: 
  {
#line 329
  header[0] = (char)0;
  {
#line 330
  InitVars();
  }
  {
#line 331
  NewPosition();
  }
#line 332
  flags &= 4294967287U;
#line 333
  flags &= 4294967291U;
#line 334
  opprating = 0;
#line 334
  myrating = opprating;
#line 336
  playerfound[0] = 0;
#line 336
  playerfound[1] = playerfound[0];
  }
  {
  {
#line 347
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 347
    c = fgetc(fp___0);
    }
    }
#line 347
    if (! (c != -1)) {
#line 347
      goto while_break;
    }
#line 348
    if (c != 32) {
#line 348
      if (c != 9) {
#line 348
        if (c != 10) {
          {
          {
#line 349
          ungetc(c, fp___0);
          }
          }
#line 350
          goto while_break;
        }
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 354
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 354
    c = fgetc(fp___0);
    }
    }
#line 354
    if (! (c == 91)) {
#line 354
      goto while_break___0;
    }
    {
    {
#line 355
    ungetc(c, fp___0);
    }
    {
#line 356
    fgets((char */* __restrict  */)(s___1), 100, (FILE */* __restrict  */)fp___0);
    }
    {
#line 357
    strcat((char */* __restrict  */)(header), (char const   */* __restrict  */)(s___1));
    }
    {
#line 358
    tmp___7 = strncmp((char const   *)(s___1 + 1), "White ", (size_t )6);
    }
    }
#line 358
    if (tmp___7 == 0) {
#line 359
      examinecolor = 0;
#line 360
      ngames ++;
    } else {
      {
      {
#line 361
      tmp___6 = strncmp((char const   *)(s___1 + 1), "Black ", (size_t )6);
      }
      }
#line 361
      if (tmp___6 == 0) {
#line 362
        examinecolor = 1;
      } else {
        {
        {
#line 363
        tmp___5 = strncmp((char const   *)(s___1 + 1), "Result", (size_t )6);
        }
        }
#line 363
        if (tmp___5 == 0) {
          {
          {
#line 364
          tmp___4 = strncmp((char const   *)(s___1 + 7), " \"1-0", (size_t )5);
          }
          }
#line 364
          if (tmp___4 == 0) {
#line 365
            result = 1;
          } else {
            {
            {
#line 366
            tmp___3 = strncmp((char const   *)(s___1 + 7), " \"0-1", (size_t )5);
            }
            }
#line 366
            if (tmp___3 == 0) {
#line 367
              result = 2;
            } else {
              {
              {
#line 368
              tmp___2 = strncmp((char const   *)(s___1 + 7), " \"1/2-1/2", (size_t )9);
              }
              }
#line 368
              if (tmp___2 == 0) {
#line 369
                result = 3;
              } else {
#line 371
                result = 4;
              }
            }
          }
#line 373
          goto while_continue___0;
        } else {
#line 374
          goto while_continue___0;
        }
      }
    }
#line 381
    i = 0U;
    {
    {
#line 381
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 381
      if (! ((unsigned long )i < sizeof(player) / sizeof(player[0]))) {
#line 381
        goto while_break___1;
      }
      {
      {
#line 382
      tmp___8 = strstr((char const   *)(s___1 + 7), player[i]);
      }
      }
#line 382
      if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 383
        playerfound[examinecolor] = 1;
      }
#line 381
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 387
  ungetc(c, fp___0);
  }
  }
  {
  {
#line 388
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 389
    tmp___9 = fscanf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%d. %7s ",
                     & moveno, wmv);
    }
    }
#line 389
    if (tmp___9 < 2) {
#line 389
      goto while_break___2;
    }
#line 391
    if ((int )wmv[0] == 49) {
#line 392
      goto while_break___2;
    } else
#line 391
    if ((int )wmv[0] == 91) {
#line 392
      goto while_break___2;
    } else
#line 391
    if ((int )wmv[0] == 42) {
#line 392
      goto while_break___2;
    } else {
      {
      {
#line 391
      tmp___10 = strcmp((char const   *)(wmv), "0-1");
      }
      }
#line 391
      if (tmp___10 == 0) {
#line 392
        goto while_break___2;
      }
    }
    {
    {
#line 394
    p___1 = ValidateMove(wmv);
    }
    }
#line 395
    if (! p___1) {
      {
      {
#line 396
      puts((char const   *)(header));
      }
      {
#line 397
      ShowBoard();
      }
      {
#line 398
      printf((char const   */* __restrict  */)"Illegal move %d. %s\n", moveno, wmv);
      }
      }
#line 399
      goto while_break___2;
    }
    {
    {
#line 401
    MakeMove(0, & p___1->move);
    }
    }
#line 402
    if (playerfound[0]) {
      {
      {
#line 403
      tmp___11 = BookBuilder(result, 0);
      }
      }
#line 403
      if (tmp___11 != 0) {
#line 403
        goto while_break___2;
      }
    }
    {
    {
#line 405
    strcpy((char */* __restrict  */)(Game[GameCnt].SANmv), (char const   */* __restrict  */)(wmv));
    }
    {
#line 407
    tmp___12 = fscanf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%7s ",
                      bmv);
    }
    }
#line 407
    if (tmp___12 < 1) {
#line 407
      goto while_break___2;
    }
#line 408
    if ((int )bmv[0] == 49) {
#line 409
      goto while_break___2;
    } else
#line 408
    if ((int )bmv[0] == 91) {
#line 409
      goto while_break___2;
    } else
#line 408
    if ((int )bmv[0] == 42) {
#line 409
      goto while_break___2;
    } else {
      {
      {
#line 408
      tmp___13 = strcmp((char const   *)(bmv), "0-1");
      }
      }
#line 408
      if (tmp___13 == 0) {
#line 409
        goto while_break___2;
      }
    }
    {
    {
#line 411
    p___1 = ValidateMove(bmv);
    }
    }
#line 412
    if (! p___1) {
      {
      {
#line 413
      puts((char const   *)(header));
      }
      {
#line 414
      ShowBoard();
      }
      {
#line 415
      printf((char const   */* __restrict  */)"Illegal move %d. ... %s\n", moveno,
             bmv);
      }
      }
#line 416
      goto while_break___2;
    }
    {
    {
#line 418
    MakeMove(1, & p___1->move);
    }
    }
#line 419
    if (playerfound[1]) {
      {
      {
#line 420
      tmp___14 = BookBuilder(result, 1);
      }
      }
#line 420
      if (tmp___14 != 0) {
#line 420
        goto while_break___2;
      }
    }
    {
    {
#line 422
    strcpy((char */* __restrict  */)(Game[GameCnt].SANmv), (char const   */* __restrict  */)(bmv));
    }
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 426
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 426
    tmp___15 = feof(fp___0);
    }
    }
#line 426
    if (tmp___15) {
#line 426
      goto while_break___3;
    }
    {
    {
#line 427
    fgets((char */* __restrict  */)(s___1), 100, (FILE */* __restrict  */)fp___0);
    }
    }
#line 428
    if ((int )s___1[0] == 10) {
#line 428
      goto while_break___3;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 431
  tmp___16 = feof(fp___0);
  }
  }
#line 431
  if (! tmp___16) {
#line 432
    if (ngames % 10 == 0) {
      {
      {
#line 432
      printf((char const   */* __restrict  */)"%d\r", ngames);
      }
      }
    }
    {
    {
#line 433
    fflush(stdout);
    }
    }
#line 434
    goto nextgame;
  }
  {
  {
#line 437
  fclose(fp___0);
  }
  {
#line 438
  tmp___17 = BookBuilderClose();
  }
  }
#line 438
  if (tmp___17 != 0) {
    {
    {
#line 439
    perror("Error writing opening book");
    }
    }
  }
  {
#line 444
  header[0] = (char)0;
  {
#line 445
  InitVars();
  }
  {
#line 446
  NewPosition();
  }
#line 447
  flags &= 4294967287U;
#line 448
  flags &= 4294967291U;
#line 449
  opprating = 0;
#line 449
  myrating = opprating;
  {
#line 451
  t2___0 = time((time_t *)((void *)0));
  }
  {
#line 452
  tmp___18 = difftime(t2___0, t1___0);
  }
#line 452
  et___0 += tmp___18;
  {
#line 453
  putchar('\n');
  }
  }
#line 456
  if (et___0 < 0.5) {
#line 456
    et___0 = 1.0;
  }
  {
  {
#line 458
  printf((char const   */* __restrict  */)"Time = %.0f seconds\n", et___0);
  }
  {
#line 459
  printf((char const   */* __restrict  */)"Games compiled: %d\n", ngames);
  }
  {
#line 460
  printf((char const   */* __restrict  */)"Games per second: %f\n", (double )ngames / et___0);
  }
  {
#line 461
  printf((char const   */* __restrict  */)"Positions scanned: %d\n", newpos + existpos);
  }
  {
#line 462
  printf((char const   */* __restrict  */)"Positions per second: %f\n", (double )(newpos + existpos) / et___0);
  }
  {
#line 463
  printf((char const   */* __restrict  */)"New & unique added: %d positions\n", newpos);
  }
  {
#line 464
  printf((char const   */* __restrict  */)"Duplicates not added: %d positions\n",
         existpos);
  }
  }
#line 465
  return;
}
}
#line 520 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 756 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 644 "/home/khheo/testset/chess/src/common.h"
void DBSortPlayer(char const   *style ) ;
#line 645
void DBListPlayer(char const   *style ) ;
#line 646
void DBReadPlayer(void) ;
#line 647
void DBWritePlayer(void) ;
#line 648
int DBSearchPlayer(char const   *player ) ;
#line 649
void DBUpdatePlayer(char const   *player , char const   *resultstr ) ;
#line 34 "/home/khheo/testset/chess/src/players.c"
int totalplayers  =    0;
#line 45 "/home/khheo/testset/chess/src/players.c"
playerentry playerdb[500]  ;
#line 46 "/home/khheo/testset/chess/src/players.c"
static char lname[100]  ;
#line 48 "/home/khheo/testset/chess/src/players.c"
static int rscorecompare(void const   *aa , void const   *bb___0 ) 
{ 
  playerentry const   *a ;
  playerentry const   *b ;
  float ascore ;
  float bscore ;

  {
#line 50
  a = (playerentry const   *)aa;
#line 51
  b = (playerentry const   *)bb___0;
#line 53
  ascore = (float )((a->wins + a->draws / 2) / ((a->wins + a->draws) + a->losses));
#line 54
  bscore = (float )((b->wins + b->draws / 2) / ((b->wins + b->draws) + b->losses));
#line 55
  if (ascore > bscore) {
#line 55
    return (-1);
  } else
#line 56
  if (bscore > ascore) {
#line 56
    return (1);
  } else {
#line 57
    return (0);
  }
}
}
#line 60 "/home/khheo/testset/chess/src/players.c"
static int scorecompare(void const   *aa , void const   *bb___0 ) 
{ 
  playerentry const   *a ;
  playerentry const   *b ;
  int ascore ;
  int bscore ;

  {
#line 62
  a = (playerentry const   *)aa;
#line 63
  b = (playerentry const   *)bb___0;
#line 65
  ascore = (100 * (int )(a->wins + a->draws / 2)) / (int )((a->wins + a->draws) + a->losses);
#line 66
  bscore = (100 * (int )(b->wins + b->draws / 2)) / (int )((b->wins + b->draws) + b->losses);
#line 67
  if (bscore > ascore) {
#line 67
    return (1);
  } else
#line 68
  if (bscore < ascore) {
#line 68
    return (-1);
  } else {
#line 69
    return (0);
  }
}
}
#line 72 "/home/khheo/testset/chess/src/players.c"
static int namecompare(void const   *aa , void const   *bb___0 ) 
{ 
  playerentry const   *a ;
  playerentry const   *b ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 74
  a = (playerentry const   *)aa;
#line 75
  b = (playerentry const   *)bb___0;
  {
#line 76
  tmp___0 = strcmp((char const   *)(a->player), (char const   *)(b->player));
  }
  }
#line 76
  if (tmp___0 > 0) {
#line 76
    return (1);
  } else {
    {
    {
#line 77
    tmp = strcmp((char const   *)(a->player), (char const   *)(b->player));
    }
    }
#line 77
    if (tmp < 0) {
#line 77
      return (-1);
    } else {
#line 78
      return (0);
    }
  }
}
}
#line 81 "/home/khheo/testset/chess/src/players.c"
void DBSortPlayer(char const   *style ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 83
  tmp___1 = strncmp(style, "score", (size_t )5);
  }
  }
#line 83
  if (tmp___1 == 0) {
    {
    {
#line 84
    qsort((void *)(& playerdb), (size_t )totalplayers, sizeof(playerentry ), & scorecompare);
    }
    }
  } else {
    {
    {
#line 85
    tmp___0 = strncmp(style, "name", (size_t )4);
    }
    }
#line 85
    if (tmp___0 == 0) {
      {
      {
#line 86
      qsort((void *)(& playerdb), (size_t )totalplayers, sizeof(playerentry ), & namecompare);
      }
      }
    } else {
      {
      {
#line 87
      tmp = strncmp(style, "reverse", (size_t )7);
      }
      }
#line 87
      if (tmp == 0) {
        {
        {
#line 88
        qsort((void *)(& playerdb), (size_t )totalplayers, sizeof(playerentry ), & rscorecompare);
        }
        }
      }
    }
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/testset/chess/src/players.c"
void DBListPlayer(char const   *style ) 
{ 
  int i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 96
  DBReadPlayer();
  }
  {
#line 97
  DBSortPlayer(style);
  }
#line 98
  i = 0;
  }
  {
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < totalplayers)) {
#line 98
      goto while_break;
    }
    {
    {
#line 99
    printf((char const   */* __restrict  */)"%s %2.0f%% %d %d %d\n", playerdb[i].player,
           (100.0 * (double )((float )playerdb[i].wins + (float )playerdb[i].draws / (float )2)) / (double )((playerdb[i].wins + playerdb[i].draws) + playerdb[i].losses),
           playerdb[i].wins, playerdb[i].losses, playerdb[i].draws);
    }
    }
#line 106
    if ((i + 1) % 10 == 0) {
      {
      {
#line 106
      printf((char const   */* __restrict  */)"[Type a character to continue.]\n");
      }
      {
#line 106
      getchar();
      }
      }
    }
#line 98
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/testset/chess/src/players.c"
void DBWritePlayer(void) 
{ 
  int i ;
  float result1 ;
  int result2 ;
  FILE *wfp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 116
  DBSortPlayer("reverse");
  }
  {
#line 117
  wfp = fopen((char const   */* __restrict  */)"players.dat", (char const   */* __restrict  */)"w");
  }
  }
#line 117
  if ((unsigned long )wfp != (unsigned long )((void *)0)) {
#line 118
    i = 0;
    {
    {
#line 118
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 118
      if (! (i < totalplayers)) {
#line 118
        goto while_break;
      }
      {
#line 119
      result1 = (float )((100.0 * (double )((float )playerdb[i].wins + (float )playerdb[i].draws / (float )2)) / (double )((playerdb[i].wins + playerdb[i].draws) + playerdb[i].losses));
#line 119
      result2 = (int )result1;
      {
#line 123
      fprintf((FILE */* __restrict  */)wfp, (char const   */* __restrict  */)"%s %d %d %d\n",
              playerdb[i].player, playerdb[i].wins, playerdb[i].losses, playerdb[i].draws);
      }
#line 118
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 130
  fclose(wfp);
  }
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/testset/chess/src/players.c"
void DBReadPlayer(void) 
{ 
  FILE *rfp ;
  int n___0 ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 137
  totalplayers = 0;
  {
#line 138
  rfp = fopen((char const   */* __restrict  */)"players.dat", (char const   */* __restrict  */)"r");
  }
  }
#line 138
  if ((unsigned long )rfp != (unsigned long )((void *)0)) {
    {
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 139
      tmp = feof(rfp);
      }
      }
#line 139
      if (tmp) {
#line 139
        goto while_break;
      }
      {
      {
#line 140
      n___0 = fscanf((FILE */* __restrict  */)rfp, (char const   */* __restrict  */)"%s %d %d %d\n",
                     playerdb[totalplayers].player, & playerdb[totalplayers].wins,
                     & playerdb[totalplayers].losses, & playerdb[totalplayers].draws);
      }
      }
#line 145
      if (n___0 == 4) {
#line 145
        totalplayers ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 147
    fclose(rfp);
    }
    }
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/testset/chess/src/players.c"
int DBSearchPlayer(char const   *player ) 
{ 
  int index___0 ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 153
  index___0 = -1;
#line 156
  i = 0;
  {
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < totalplayers)) {
#line 156
      goto while_break;
    }
    {
    {
#line 157
    tmp = strlen((char const   *)(playerdb[i].player));
    }
    {
#line 157
    tmp___0 = strncmp((char const   *)(playerdb[i].player), player, tmp);
    }
    }
#line 157
    if (tmp___0 == 0) {
#line 159
      index___0 = i;
#line 160
      goto while_break;
    }
#line 156
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (index___0);
}
}
#line 165 "/home/khheo/testset/chess/src/players.c"
void DBUpdatePlayer(char const   *player , char const   *resultstr ) 
{ 
  char const   *p___1 ;
  char *x___0 ;
  int index___0 ;
  int result ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 170
  result = 4;
  {
#line 172
  memset((void *)(lname), 0, sizeof(lname));
  }
#line 173
  p___1 = player;
#line 174
  x___0 = lname;
  {
#line 175
  strcpy((char */* __restrict  */)(lname), (char const   */* __restrict  */)player);
  }
  }
  {
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 177
    if ((int const   )*p___1 != 32) {
#line 178
      tmp = x___0;
#line 178
      x___0 ++;
#line 178
      tmp___0 = p___1;
#line 178
      p___1 ++;
#line 178
      *tmp = (char )*tmp___0;
    } else {
#line 180
      p___1 ++;
    }
#line 176
    if (! ((int const   )*p___1 != 0)) {
#line 176
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  *x___0 = (char )'\000';
  {
#line 183
  memset((void *)(playerdb), 0, sizeof(playerdb[500]));
  }
  {
#line 184
  DBReadPlayer();
  }
  {
#line 185
  index___0 = DBSearchPlayer((char const   *)(lname));
  }
  }
#line 186
  if (index___0 == -1) {
    {
    {
#line 187
    strcpy((char */* __restrict  */)(playerdb[totalplayers].player), (char const   */* __restrict  */)(lname));
    }
#line 188
    playerdb[totalplayers].wins = 0;
#line 189
    playerdb[totalplayers].losses = 0;
#line 190
    playerdb[totalplayers].draws = 0;
#line 191
    index___0 = totalplayers;
#line 192
    totalplayers ++;
    }
  }
  {
  {
#line 194
  tmp___3 = strncmp(resultstr, "1-0", (size_t )3);
  }
  }
#line 194
  if (tmp___3 == 0) {
#line 195
    result = 1;
  } else {
    {
    {
#line 196
    tmp___2 = strncmp(resultstr, "0-1", (size_t )3);
    }
    }
#line 196
    if (tmp___2 == 0) {
#line 197
      result = 2;
    } else {
      {
      {
#line 198
      tmp___1 = strncmp(resultstr, "1/2-1/2", (size_t )7);
      }
      }
#line 198
      if (tmp___1 == 0) {
#line 199
        result = 3;
      }
    }
  }
#line 201
  if (computerplays == 0) {
#line 201
    if (result == 1) {
#line 203
      (playerdb[index___0].wins) ++;
    } else {
#line 201
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 201
  if (computerplays == 1) {
#line 201
    if (result == 2) {
#line 203
      (playerdb[index___0].wins) ++;
    } else {
#line 201
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 204
  if (computerplays == 0) {
#line 204
    if (result == 2) {
#line 206
      (playerdb[index___0].losses) ++;
    } else {
#line 204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 204
  if (computerplays == 1) {
#line 204
    if (result == 1) {
#line 206
      (playerdb[index___0].losses) ++;
    } else {
#line 209
      (playerdb[index___0].draws) ++;
    }
  } else {
#line 209
    (playerdb[index___0].draws) ++;
  }
  {
  {
#line 210
  DBWritePlayer();
  }
  }
#line 211
  return;
}
}
#line 403 "/home/khheo/testset/chess/src/common.h"
char algbr[64][3] ;
#line 406
char notation[8] ;
#line 613
void ShowSmallBoard(void) ;
#line 615
void ShowBitBoard(BitBoard *b ) ;
#line 616
void ShowCBoard(void) ;
#line 617
void ShowMvboard(void) ;
#line 619
void ShowGame(void) ;
#line 620
void ShowTime(void) ;
#line 32 "/home/khheo/testset/chess/src/output.c"
void ShowTime(void) 
{ 


  {
#line 39
  return;
}
}
#line 41 "/home/khheo/testset/chess/src/output.c"
void ShowMoveList(int ply ) 
{ 
  leaf *node___0 ;
  int i ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 49
  i = 0;
#line 51
  node___0 = TreePtr[ply];
  {
  {
#line 51
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((unsigned long )node___0 < (unsigned long )TreePtr[ply + 1])) {
#line 51
      goto while_break;
    }
    {
    {
#line 53
    SANMove(node___0->move, ply);
    }
    {
#line 54
    tmp = SwapOff(node___0->move);
    }
    {
#line 54
    printf((char const   */* __restrict  */)"%5s %3d\t", SANmv, tmp);
    }
#line 55
    i ++;
    }
#line 55
    if (i == 5) {
      {
      {
#line 57
      printf((char const   */* __restrict  */)"\n");
      }
#line 58
      i = 0;
      }
    }
#line 51
    node___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 61
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 62
  return;
}
}
#line 65 "/home/khheo/testset/chess/src/output.c"
void ShowSmallBoard(void) 
{ 
  int r ;
  int c ;
  int sq ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
  {
#line 75
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 76
  if (board.side == 0) {
    {
    {
#line 77
    printf((char const   */* __restrict  */)"white  ");
    }
    }
  } else {
    {
    {
#line 79
    printf((char const   */* __restrict  */)"black  ");
    }
    }
  }
#line 81
  if (board.flag & 1) {
    {
    {
#line 82
    printf((char const   */* __restrict  */)"K");
    }
    }
  }
#line 83
  if (board.flag & 2) {
    {
    {
#line 84
    printf((char const   */* __restrict  */)"Q");
    }
    }
  }
#line 85
  if (board.flag & 4) {
    {
    {
#line 86
    printf((char const   */* __restrict  */)"k");
    }
    }
  }
#line 87
  if (board.flag & 8) {
    {
    {
#line 88
    printf((char const   */* __restrict  */)"q");
    }
    }
  }
#line 90
  if (board.ep > -1) {
    {
    {
#line 91
    printf((char const   */* __restrict  */)"  %s", algbr[board.ep]);
    }
    }
  }
  {
  {
#line 93
  printf((char const   */* __restrict  */)"\n");
  }
#line 94
  r = 56;
  }
  {
  {
#line 94
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 94
    if (! (r >= 0)) {
#line 94
      goto while_break;
    }
#line 96
    c = 0;
    {
    {
#line 96
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (c < 8)) {
#line 96
        goto while_break___0;
      }
#line 98
      sq = r + c;
#line 99
      if (board.b[0][1] & BitPosArray[sq]) {
        {
        {
#line 100
        printf((char const   */* __restrict  */)"P ");
        }
        }
      } else
#line 101
      if (board.b[0][2] & BitPosArray[sq]) {
        {
        {
#line 102
        printf((char const   */* __restrict  */)"N ");
        }
        }
      } else
#line 103
      if (board.b[0][3] & BitPosArray[sq]) {
        {
        {
#line 104
        printf((char const   */* __restrict  */)"B ");
        }
        }
      } else
#line 105
      if (board.b[0][4] & BitPosArray[sq]) {
        {
        {
#line 106
        printf((char const   */* __restrict  */)"R ");
        }
        }
      } else
#line 107
      if (board.b[0][5] & BitPosArray[sq]) {
        {
        {
#line 108
        printf((char const   */* __restrict  */)"Q ");
        }
        }
      } else
#line 109
      if (board.b[0][6] & BitPosArray[sq]) {
        {
        {
#line 110
        printf((char const   */* __restrict  */)"K ");
        }
        }
      } else
#line 111
      if (board.b[1][1] & BitPosArray[sq]) {
        {
        {
#line 112
        printf((char const   */* __restrict  */)"p ");
        }
        }
      } else
#line 113
      if (board.b[1][2] & BitPosArray[sq]) {
        {
        {
#line 114
        printf((char const   */* __restrict  */)"n ");
        }
        }
      } else
#line 115
      if (board.b[1][3] & BitPosArray[sq]) {
        {
        {
#line 116
        printf((char const   */* __restrict  */)"b ");
        }
        }
      } else
#line 117
      if (board.b[1][4] & BitPosArray[sq]) {
        {
        {
#line 118
        printf((char const   */* __restrict  */)"r ");
        }
        }
      } else
#line 119
      if (board.b[1][5] & BitPosArray[sq]) {
        {
        {
#line 120
        printf((char const   */* __restrict  */)"q ");
        }
        }
      } else
#line 121
      if (board.b[1][6] & BitPosArray[sq]) {
        {
        {
#line 122
        printf((char const   */* __restrict  */)"k ");
        }
        }
      } else {
        {
        {
#line 124
        printf((char const   */* __restrict  */)". ");
        }
        }
      }
#line 96
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 126
    printf((char const   */* __restrict  */)"\n");
    }
#line 94
    r -= 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 128
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 129
  return;
}
}
#line 133 "/home/khheo/testset/chess/src/output.c"
void ShowBitBoard(BitBoard *b ) 
{ 
  int r ;
  int c ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 142
  printf((char const   */* __restrict  */)"\n");
  }
#line 143
  r = 56;
  }
  {
  {
#line 143
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 143
    if (! (r >= 0)) {
#line 143
      goto while_break;
    }
#line 145
    c = 0;
    {
    {
#line 145
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 145
      if (! (c < 8)) {
#line 145
        goto while_break___0;
      }
#line 147
      if (*b & BitPosArray[r + c]) {
        {
        {
#line 148
        printf((char const   */* __restrict  */)"1 ");
        }
        }
      } else {
        {
        {
#line 150
        printf((char const   */* __restrict  */)". ");
        }
        }
      }
#line 145
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 152
    printf((char const   */* __restrict  */)"\n");
    }
#line 143
    r -= 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 154
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 155
  return;
}
}
#line 158 "/home/khheo/testset/chess/src/output.c"
void ShowBoard(void) 
{ 
  int r ;
  int c ;
  int sq ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
  {
#line 168
  fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n");
  }
  }
#line 169
  if (board.side == 0) {
    {
    {
#line 170
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"white  ");
    }
    }
  } else {
    {
    {
#line 172
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"black  ");
    }
    }
  }
#line 174
  if (board.flag & 1) {
    {
    {
#line 175
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"K");
    }
    }
  }
#line 176
  if (board.flag & 2) {
    {
    {
#line 177
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Q");
    }
    }
  }
#line 178
  if (board.flag & 4) {
    {
    {
#line 179
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"k");
    }
    }
  }
#line 180
  if (board.flag & 8) {
    {
    {
#line 181
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"q");
    }
    }
  }
#line 183
  if (board.ep > -1) {
    {
    {
#line 184
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"  %s",
            algbr[board.ep]);
    }
    }
  }
  {
  {
#line 186
  fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n");
  }
#line 187
  r = 56;
  }
  {
  {
#line 187
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 187
    if (! (r >= 0)) {
#line 187
      goto while_break;
    }
#line 189
    c = 0;
    {
    {
#line 189
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 189
      if (! (c < 8)) {
#line 189
        goto while_break___0;
      }
#line 191
      sq = r + c;
#line 192
      if (board.b[0][1] & BitPosArray[sq]) {
        {
        {
#line 193
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"P ");
        }
        }
      } else
#line 194
      if (board.b[0][2] & BitPosArray[sq]) {
        {
        {
#line 195
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"N ");
        }
        }
      } else
#line 196
      if (board.b[0][3] & BitPosArray[sq]) {
        {
        {
#line 197
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"B ");
        }
        }
      } else
#line 198
      if (board.b[0][4] & BitPosArray[sq]) {
        {
        {
#line 199
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"R ");
        }
        }
      } else
#line 200
      if (board.b[0][5] & BitPosArray[sq]) {
        {
        {
#line 201
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Q ");
        }
        }
      } else
#line 202
      if (board.b[0][6] & BitPosArray[sq]) {
        {
        {
#line 203
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"K ");
        }
        }
      } else
#line 204
      if (board.b[1][1] & BitPosArray[sq]) {
        {
        {
#line 205
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"p ");
        }
        }
      } else
#line 206
      if (board.b[1][2] & BitPosArray[sq]) {
        {
        {
#line 207
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"n ");
        }
        }
      } else
#line 208
      if (board.b[1][3] & BitPosArray[sq]) {
        {
        {
#line 209
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"b ");
        }
        }
      } else
#line 210
      if (board.b[1][4] & BitPosArray[sq]) {
        {
        {
#line 211
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"r ");
        }
        }
      } else
#line 212
      if (board.b[1][5] & BitPosArray[sq]) {
        {
        {
#line 213
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"q ");
        }
        }
      } else
#line 214
      if (board.b[1][6] & BitPosArray[sq]) {
        {
        {
#line 215
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"k ");
        }
        }
      } else {
        {
        {
#line 217
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)". ");
        }
        }
      }
#line 189
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 219
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n");
    }
#line 187
    r -= 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 221
  fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\n");
  }
  }
#line 222
  return;
}
}
#line 224 "/home/khheo/testset/chess/src/output.c"
void ShowCBoard(void) 
{ 
  int r ;
  int c ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 233
  r = 56;
  {
  {
#line 233
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 233
    if (! (r >= 0)) {
#line 233
      goto while_break;
    }
#line 235
    c = 0;
    {
    {
#line 235
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (c < 8)) {
#line 235
        goto while_break___0;
      }
#line 237
      if (cboard[r + c]) {
#line 237
        tmp = (int )notation[cboard[r + c]];
      } else {
#line 237
        tmp = '.';
      }
      {
      {
#line 237
      printf((char const   */* __restrict  */)"%2c ", tmp);
      }
#line 235
      c ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 239
    printf((char const   */* __restrict  */)"\n");
    }
#line 233
    r -= 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 241
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 242
  return;
}
}
#line 245 "/home/khheo/testset/chess/src/output.c"
void ShowMvboard(void) 
{ 
  int r ;
  int c ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 254
  r = 56;
  {
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 254
    if (! (r >= 0)) {
#line 254
      goto while_break;
    }
#line 256
    c = 0;
    {
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! (c < 8)) {
#line 256
        goto while_break___0;
      }
      {
      {
#line 258
      printf((char const   */* __restrict  */)"%2d ", Mvboard[r + c]);
      }
#line 256
      c ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 260
    printf((char const   */* __restrict  */)"\n");
    }
#line 254
    r -= 8;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 262
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 263
  return;
}
}
#line 265 "/home/khheo/testset/chess/src/output.c"
void ShowGame(void) 
{ 
  int i ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 274
  if (GameCnt >= 0) {
    {
    {
#line 277
    printf((char const   */* __restrict  */)"      White   Black\n");
    }
    }
#line 279
    if (board.side == 0) {
#line 279
      if (GameCnt % 2 == 1) {
#line 279
        goto _L;
      } else {
#line 279
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 279
    if (board.side == 1) {
#line 279
      if (GameCnt % 2 == 0) {
        _L: /* CIL Label */ 
#line 283
        i = 0;
        {
        {
#line 283
        while (1) {
          while_continue___1: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
#line 283
          if (! (i <= GameCnt)) {
#line 283
            goto while_break;
          }
          {
          {
#line 285
          printf((char const   */* __restrict  */)"%3d.  %-7s %-7s\n", i / 2 + 1,
                 Game[i].SANmv, Game[i + 1].SANmv);
          }
#line 283
          i += 2;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 279
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
      {
#line 291
      printf((char const   */* __restrict  */)"  1.          %-7s\n", Game[0].SANmv);
      }
#line 293
      i = 1;
      }
      {
      {
#line 293
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 293
        if (! (i <= GameCnt)) {
#line 293
          goto while_break___0;
        }
        {
        {
#line 295
        printf((char const   */* __restrict  */)"%3d.  %-7s %-7s\n", i / 2 + 2, Game[i].SANmv,
               Game[i + 1].SANmv);
        }
#line 293
        i += 2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 299
    printf((char const   */* __restrict  */)"\n");
    }
    }
  }
#line 301
  return;
}
}
#line 316 "/home/khheo/testset/chess/src/common.h"
HashType ephash[64] ;
#line 321
HashType Sidehash ;
#line 32 "/home/khheo/testset/chess/src/null.c"
void MakeNullMove(int side ) 
{ 
  GameRec *g ;

  {
#line 41
  GameCnt ++;
#line 42
  g = & Game[GameCnt];
#line 43
  g->epsq = board.ep;
#line 44
  g->bflag = board.flag;
#line 45
  g->hashkey = HashKey;
#line 46
  if (board.ep > -1) {
#line 47
    HashKey ^= ephash[board.ep];
  }
#line 48
  HashKey ^= Sidehash;
#line 49
  board.ep = -1;
#line 50
  board.side = 1 ^ side;
#line 53
  g->move = 1048576;
#line 54
  return;
}
}
#line 58 "/home/khheo/testset/chess/src/null.c"
void UnmakeNullMove(int side ) 
{ 
  GameRec *g ;

  {
#line 67
  side = 1 ^ side;
#line 68
  board.side = side;
#line 69
  g = & Game[GameCnt];
#line 70
  board.ep = g->epsq;
#line 71
  board.flag = g->bflag;
#line 72
  HashKey = g->hashkey;
#line 73
  GameCnt --;
#line 74
  return;
}
}
#line 233 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 280 "/home/khheo/testset/chess/src/common.h"
BitBoard MoveArray[8][64] ;
#line 282
BitBoard FromToRay[64][64] ;
#line 283
BitBoard RankBit[8] ;
#line 284
BitBoard FileBit[8] ;
#line 315
HashType hashcode[2][7][64] ;
#line 317
HashType WKCastlehash ;
#line 318
HashType WQCastlehash ;
#line 319
HashType BKCastlehash ;
#line 320
HashType BQCastlehash ;
#line 323
HashType PawnHashKey ;
#line 358
int slider[8] ;
#line 404
char algbrfile[9] ;
#line 405
char algbrrank[9] ;
#line 407
char lnotation[8] ;
#line 408
int r90[64] ;
#line 409
int r45[64] ;
#line 410
int r315[64] ;
#line 426
int ExchCnt[2] ;
#line 516
leaf *IsInMoveList(int ply , int f , int t , char piece ) ;
#line 518
char *AlgbrMove(int move ) ;
#line 35 "/home/khheo/testset/chess/src/move.c"
void MakeMove(int side , int *move ) 
{ 
  BitBoard *a ;
  int f ;
  int t ;
  int fpiece ;
  int tpiece ;
  int rookf ;
  int rookt ;
  int epsq ;
  int sq ;
  int xside ;
  GameRec *g ;
  int tmp ;
  int tmp___0 ;

  {
#line 48
  xside = 1 ^ side;
#line 49
  f = (*move >> 6) & 63;
#line 50
  t = *move & 63;
#line 51
  fpiece = cboard[f];
#line 52
  tpiece = cboard[t];
#line 53
  a = & board.b[side][fpiece];
#line 54
  *a &= NotBitPosArray[f];
#line 55
  *a |= BitPosArray[t];
#line 56
  board.blockerr90 &= NotBitPosArray[r90[f]];
#line 57
  board.blockerr90 |= BitPosArray[r90[t]];
#line 58
  board.blockerr45 &= NotBitPosArray[r45[f]];
#line 59
  board.blockerr45 |= BitPosArray[r45[t]];
#line 60
  board.blockerr315 &= NotBitPosArray[r315[f]];
#line 61
  board.blockerr315 |= BitPosArray[r315[t]];
#line 62
  cboard[f] = 0;
#line 63
  cboard[t] = fpiece;
#line 64
  GameCnt ++;
#line 65
  g = & Game[GameCnt];
#line 66
  g->epsq = board.ep;
#line 67
  g->bflag = board.flag;
#line 68
  g->Game50 = Game50;
#line 69
  g->hashkey = HashKey;
#line 70
  g->phashkey = PawnHashKey;
#line 71
  g->mvboard = Mvboard[t];
#line 72
  Mvboard[t] = Mvboard[f] + 1;
#line 73
  Mvboard[f] = 0;
#line 74
  if (board.ep > -1) {
#line 75
    HashKey ^= ephash[board.ep];
  }
#line 76
  HashKey ^= hashcode[side][fpiece][f];
#line 77
  HashKey ^= hashcode[side][fpiece][t];
#line 78
  if (fpiece == 6) {
#line 79
    board.king[side] = t;
  }
#line 80
  if (fpiece == 1) {
#line 82
    PawnHashKey ^= hashcode[side][1][f];
#line 83
    PawnHashKey ^= hashcode[side][1][t];
  }
#line 86
  if (tpiece != 0) {
#line 88
    (ExchCnt[side]) ++;
#line 89
    board.b[xside][tpiece] &= NotBitPosArray[t];
#line 90
    *move |= tpiece << 15;
#line 91
    HashKey ^= hashcode[xside][tpiece][t];
#line 92
    if (tpiece == 1) {
#line 93
      PawnHashKey ^= hashcode[xside][1][t];
    }
#line 94
    board.material[xside] -= Value[tpiece];
#line 95
    if (tpiece != 1) {
#line 96
      board.pmaterial[xside] -= Value[tpiece];
    }
  }
#line 99
  if (*move & 28672) {
#line 101
    board.b[side][(*move >> 12) & 7] |= BitPosArray[t];
#line 102
    *a &= NotBitPosArray[t];
#line 103
    cboard[t] = (*move >> 12) & 7;
#line 104
    HashKey ^= hashcode[side][1][t];
#line 105
    HashKey ^= hashcode[side][cboard[t]][t];
#line 106
    PawnHashKey ^= hashcode[side][1][t];
#line 107
    board.material[side] += Value[cboard[t]] - 100;
#line 108
    board.pmaterial[side] += Value[cboard[t]];
  }
#line 111
  if (*move & 4194304) {
#line 113
    (ExchCnt[side]) ++;
#line 114
    if (side == 0) {
#line 114
      tmp = -8;
    } else {
#line 114
      tmp = 8;
    }
#line 114
    epsq = board.ep + tmp;
#line 115
    board.b[xside][1] &= NotBitPosArray[epsq];
#line 116
    board.blockerr90 &= NotBitPosArray[r90[epsq]];
#line 117
    board.blockerr45 &= NotBitPosArray[r45[epsq]];
#line 118
    board.blockerr315 &= NotBitPosArray[r315[epsq]];
#line 119
    cboard[epsq] = 0;
#line 120
    HashKey ^= hashcode[xside][1][epsq];
#line 121
    PawnHashKey ^= hashcode[xside][1][epsq];
#line 122
    board.material[xside] -= 100;
  }
#line 124
  if (*move & 2326528) {
#line 125
    Game50 = GameCnt;
  } else
#line 124
  if (fpiece == 1) {
#line 125
    Game50 = GameCnt;
  }
#line 127
  if (*move & 2097152) {
#line 129
    if (t & 4) {
#line 131
      rookf = t + 1;
#line 132
      rookt = t - 1;
    } else {
#line 136
      rookf = t - 2;
#line 137
      rookt = t + 1;
    }
#line 139
    a = & board.b[side][4];
#line 140
    *a &= NotBitPosArray[rookf];
#line 141
    *a |= BitPosArray[rookt];
#line 142
    board.blockerr90 &= NotBitPosArray[r90[rookf]];
#line 143
    board.blockerr90 |= BitPosArray[r90[rookt]];
#line 144
    board.blockerr45 &= NotBitPosArray[r45[rookf]];
#line 145
    board.blockerr45 |= BitPosArray[r45[rookt]];
#line 146
    board.blockerr315 &= NotBitPosArray[r315[rookf]];
#line 147
    board.blockerr315 |= BitPosArray[r315[rookt]];
#line 148
    cboard[rookf] = 0;
#line 149
    cboard[rookt] = 4;
#line 150
    Mvboard[rookf] = 0;
#line 151
    Mvboard[rookt] = 1;
#line 152
    HashKey ^= hashcode[side][4][rookf];
#line 153
    HashKey ^= hashcode[side][4][rookt];
#line 154
    board.castled[side] = 1;
  }
#line 158
  if (side == 0) {
#line 160
    if (fpiece == 6) {
#line 160
      if (board.flag & 3) {
#line 162
        if (board.flag & 1) {
#line 163
          HashKey ^= WKCastlehash;
        }
#line 164
        if (board.flag & 2) {
#line 165
          HashKey ^= WQCastlehash;
        }
#line 166
        board.flag &= -4;
      } else {
#line 160
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 168
    if (fpiece == 4) {
#line 170
      if (f == 7) {
#line 172
        if (board.flag & 1) {
#line 173
          HashKey ^= WKCastlehash;
        }
#line 174
        board.flag &= -2;
      } else
#line 176
      if (f == 0) {
#line 178
        if (board.flag & 2) {
#line 179
          HashKey ^= WQCastlehash;
        }
#line 180
        board.flag &= -3;
      }
    }
#line 183
    if (tpiece == 4) {
#line 185
      if (t == 63) {
#line 187
        if (board.flag & 4) {
#line 188
          HashKey ^= BKCastlehash;
        }
#line 189
        board.flag &= -5;
      } else
#line 191
      if (t == 56) {
#line 193
        if (board.flag & 8) {
#line 194
          HashKey ^= BQCastlehash;
        }
#line 195
        board.flag &= -9;
      }
    }
  } else {
#line 201
    if (fpiece == 6) {
#line 201
      if (board.flag & 12) {
#line 203
        if (board.flag & 4) {
#line 204
          HashKey ^= BKCastlehash;
        }
#line 205
        if (board.flag & 8) {
#line 206
          HashKey ^= BQCastlehash;
        }
#line 207
        board.flag &= -13;
      } else {
#line 201
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 209
    if (fpiece == 4) {
#line 211
      if (f == 63) {
#line 213
        if (board.flag & 4) {
#line 214
          HashKey ^= BKCastlehash;
        }
#line 215
        board.flag &= -5;
      } else
#line 217
      if (f == 56) {
#line 219
        if (board.flag & 8) {
#line 220
          HashKey ^= BQCastlehash;
        }
#line 221
        board.flag &= -9;
      }
    }
#line 224
    if (tpiece == 4) {
#line 226
      if (t == 7) {
#line 228
        if (board.flag & 1) {
#line 229
          HashKey ^= WKCastlehash;
        }
#line 230
        board.flag &= -2;
      } else
#line 232
      if (t == 0) {
#line 234
        if (board.flag & 2) {
#line 235
          HashKey ^= WQCastlehash;
        }
#line 236
        board.flag &= -3;
      }
    }
  }
#line 243
  if (fpiece == 1) {
    {
    {
#line 243
    tmp___0 = abs(f - t);
    }
    }
#line 243
    if (tmp___0 == 16) {
#line 245
      sq = (f + t) / 2;
#line 246
      board.ep = sq;
#line 247
      HashKey ^= ephash[sq];
    } else {
#line 250
      board.ep = -1;
    }
  } else {
#line 250
    board.ep = -1;
  }
  {
#line 252
  board.side = xside;
#line 253
  HashKey ^= Sidehash;
  {
#line 254
  UpdateFriends();
  }
#line 257
  g->move = *move;
  }
#line 258
  return;
}
}
#line 263 "/home/khheo/testset/chess/src/move.c"
void UnmakeMove(int side , int *move ) 
{ 
  BitBoard *a ;
  int f ;
  int t ;
  int fpiece ;
  int cpiece ;
  int rookf ;
  int rookt ;
  int epsq ;
  int xside ;
  GameRec *g ;

  {
#line 278
  side = 1 ^ side;
#line 279
  xside = 1 ^ side;
#line 280
  f = (*move >> 6) & 63;
#line 281
  t = *move & 63;
#line 282
  fpiece = cboard[t];
#line 283
  cpiece = (*move >> 15) & 7;
#line 284
  a = & board.b[side][fpiece];
#line 285
  *a &= NotBitPosArray[t];
#line 286
  *a |= BitPosArray[f];
#line 287
  board.blockerr90 &= NotBitPosArray[r90[t]];
#line 288
  board.blockerr90 |= BitPosArray[r90[f]];
#line 289
  board.blockerr45 &= NotBitPosArray[r45[t]];
#line 290
  board.blockerr45 |= BitPosArray[r45[f]];
#line 291
  board.blockerr315 &= NotBitPosArray[r315[t]];
#line 292
  board.blockerr315 |= BitPosArray[r315[f]];
#line 293
  cboard[f] = cboard[t];
#line 294
  cboard[t] = 0;
#line 295
  g = & Game[GameCnt];
#line 296
  Mvboard[f] = Mvboard[t] - 1;
#line 297
  Mvboard[t] = g->mvboard;
#line 298
  if (fpiece == 6) {
#line 299
    board.king[side] = f;
  }
#line 302
  if (*move & 229376) {
#line 304
    (ExchCnt[side]) --;
#line 305
    board.b[xside][cpiece] |= BitPosArray[t];
#line 306
    board.blockerr90 |= BitPosArray[r90[t]];
#line 307
    board.blockerr45 |= BitPosArray[r45[t]];
#line 308
    board.blockerr315 |= BitPosArray[r315[t]];
#line 309
    cboard[t] = cpiece;
#line 310
    board.material[xside] += Value[cpiece];
#line 311
    if (cpiece != 1) {
#line 312
      board.pmaterial[xside] += Value[cpiece];
    }
  }
#line 316
  if (*move & 28672) {
#line 318
    *a &= NotBitPosArray[f];
#line 319
    board.b[side][1] |= BitPosArray[f];
#line 320
    cboard[f] = 1;
#line 321
    board.material[side] += 100 - Value[(*move >> 12) & 7];
#line 322
    board.pmaterial[side] -= Value[(*move >> 12) & 7];
  }
#line 326
  if (*move & 4194304) {
#line 328
    (ExchCnt[side]) --;
#line 329
    if (side == 0) {
#line 329
      epsq = g->epsq - 8;
    } else {
#line 329
      epsq = g->epsq + 8;
    }
#line 330
    board.b[xside][1] |= BitPosArray[epsq];
#line 331
    board.blockerr90 |= BitPosArray[r90[epsq]];
#line 332
    board.blockerr45 |= BitPosArray[r45[epsq]];
#line 333
    board.blockerr315 |= BitPosArray[r315[epsq]];
#line 334
    cboard[epsq] = 1;
#line 335
    board.material[xside] += 100;
  }
#line 339
  if (*move & 2097152) {
#line 341
    if (t & 4) {
#line 343
      rookf = t + 1;
#line 344
      rookt = t - 1;
    } else {
#line 348
      rookf = t - 2;
#line 349
      rookt = t + 1;
    }
#line 351
    a = & board.b[side][4];
#line 352
    *a &= NotBitPosArray[rookt];
#line 353
    *a |= BitPosArray[rookf];
#line 354
    board.blockerr90 &= NotBitPosArray[r90[rookt]];
#line 355
    board.blockerr90 |= BitPosArray[r90[rookf]];
#line 356
    board.blockerr45 &= NotBitPosArray[r45[rookt]];
#line 357
    board.blockerr45 |= BitPosArray[r45[rookf]];
#line 358
    board.blockerr315 &= NotBitPosArray[r315[rookt]];
#line 359
    board.blockerr315 |= BitPosArray[r315[rookf]];
#line 360
    cboard[rookf] = 4;
#line 361
    cboard[rookt] = 0;
#line 362
    Mvboard[rookf] = 0;
#line 363
    Mvboard[rookt] = 0;
#line 364
    board.castled[side] = 0;
  }
  {
  {
#line 367
  UpdateFriends();
  }
#line 368
  board.side = side;
#line 369
  board.ep = g->epsq;
#line 370
  board.flag = g->bflag;
#line 371
  HashKey = g->hashkey;
#line 372
  PawnHashKey = g->phashkey;
#line 373
  Game50 = g->Game50;
#line 374
  GameCnt --;
  }
#line 375
  return;
}
}
#line 379 "/home/khheo/testset/chess/src/move.c"
void SANMove(int move , int ply ) 
{ 
  int side ;
  int piece ;
  int ambiguous ;
  int f ;
  int t ;
  BitBoard b ;
  leaf *node1 ;
  char *s___1 ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 394
  side = board.side;
#line 395
  s___1 = SANmv;
#line 396
  f = (move >> 6) & 63;
#line 397
  t = move & 63;
#line 399
  if (move & 2097152) {
#line 401
    if (t == 6) {
      {
      {
#line 402
      strcpy((char */* __restrict  */)s___1, (char const   */* __restrict  */)"O-O");
      }
      }
    } else
#line 401
    if (t == 62) {
      {
      {
#line 402
      strcpy((char */* __restrict  */)s___1, (char const   */* __restrict  */)"O-O");
      }
      }
    } else {
      {
      {
#line 404
      strcpy((char */* __restrict  */)s___1, (char const   */* __restrict  */)"O-O-O");
      }
      }
    }
#line 405
    return;
  }
  {
#line 417
  piece = cboard[f];
#line 418
  side = board.side;
#line 419
  b = board.b[side][piece];
#line 420
  ambiguous = 0;
#line 421
  node1 = TreePtr[ply];
  {
#line 422
  tmp = nbits(b);
  }
  }
#line 422
  if (tmp > 1) {
#line 428
    node1 = TreePtr[ply];
    {
    {
#line 428
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 428
      if (! ((unsigned long )node1 < (unsigned long )TreePtr[ply + 1])) {
#line 428
        goto while_break;
      }
#line 430
      if (((node1->move >> 6) & 63) == f) {
#line 431
        goto __Cont;
      }
#line 432
      if ((node1->move & 63) != t) {
#line 433
        goto __Cont;
      }
#line 434
      if (cboard[(node1->move >> 6) & 63] != piece) {
#line 435
        goto __Cont;
      }
#line 436
      ambiguous = 1;
#line 437
      goto while_break;
      __Cont: /* CIL Label */ 
#line 428
      node1 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 441
  if (piece == 1) {
#line 444
    if (cboard[t] != 0) {
#line 444
      goto _L;
    } else
#line 444
    if (board.ep == t) {
      _L: /* CIL Label */ 
#line 446
      tmp___0 = s___1;
#line 446
      s___1 ++;
#line 446
      *tmp___0 = algbrfile[f & 7];
#line 447
      tmp___1 = s___1;
#line 447
      s___1 ++;
#line 447
      *tmp___1 = (char )'x';
    }
    {
    {
#line 449
    strcpy((char */* __restrict  */)s___1, (char const   */* __restrict  */)(algbr[t]));
    }
#line 450
    s___1 += 2;
    }
#line 453
    if (move & 28672) {
#line 455
      tmp___2 = s___1;
#line 455
      s___1 ++;
#line 455
      *tmp___2 = (char )'=';
#line 456
      tmp___3 = s___1;
#line 456
      s___1 ++;
#line 456
      *tmp___3 = notation[(move >> 12) & 7];
    }
  } else {
#line 461
    tmp___4 = s___1;
#line 461
    s___1 ++;
#line 461
    *tmp___4 = notation[piece];
#line 462
    if (ambiguous) {
#line 464
      if ((f & 7) == (((node1->move >> 6) & 63) & 7)) {
#line 465
        tmp___5 = s___1;
#line 465
        s___1 ++;
#line 465
        *tmp___5 = algbrrank[f >> 3];
      } else {
#line 467
        tmp___6 = s___1;
#line 467
        s___1 ++;
#line 467
        *tmp___6 = algbrfile[f & 7];
      }
    }
#line 469
    if (cboard[t] != 0) {
#line 470
      tmp___7 = s___1;
#line 470
      s___1 ++;
#line 470
      *tmp___7 = (char )'x';
    }
    {
    {
#line 471
    strcpy((char */* __restrict  */)s___1, (char const   */* __restrict  */)(algbr[t]));
    }
#line 472
    s___1 += 2;
    }
  }
  {
  {
#line 476
  MakeMove(side, & move);
  }
  {
#line 477
  tmp___10 = SqAtakd(board.king[1 ^ side], side);
  }
  }
#line 477
  if (tmp___10) {
    {
#line 479
    TreePtr[ply + 2] = TreePtr[ply + 1];
    {
#line 480
    GenCheckEscapes(ply + 1);
    }
    }
#line 481
    if ((unsigned long )TreePtr[ply + 1] == (unsigned long )TreePtr[ply + 2]) {
#line 482
      tmp___8 = s___1;
#line 482
      s___1 ++;
#line 482
      *tmp___8 = (char )'#';
    } else {
#line 484
      tmp___9 = s___1;
#line 484
      s___1 ++;
#line 484
      *tmp___9 = (char )'+';
    }
#line 485
    GenCnt -= (unsigned long )(TreePtr[ply + 2] - TreePtr[ply + 1]);
  }
  {
  {
#line 487
  UnmakeMove(1 ^ side, & move);
  }
#line 489
  *s___1 = (char )'\000';
  }
#line 490
  return;
}
}
#line 501 "/home/khheo/testset/chess/src/move.c"
leaf *ValidateMove(char *s___1 ) 
{ 
  int side ;
  int f ;
  int t ;
  int rank ;
  int file___0 ;
  int fileto ;
  int piece ;
  int kount ;
  char mvstr[128] ;
  char *p___1 ;
  BitBoard b ;
  leaf *n1 ;
  leaf *n2 ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  leaf *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  leaf *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___14 ;
  leaf *tmp___15 ;
  int tmp___16 ;
  leaf *tmp___17 ;
  leaf *tmp___18 ;
  int tmp___19 ;
  leaf *tmp___20 ;
  int tmp___21 ;
  size_t tmp___23 ;
  leaf *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___30 ;
  leaf *tmp___31 ;
  char *tmp___32 ;
  void *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
  {
#line 517
  TreePtr[2] = TreePtr[1];
  {
#line 518
  GenMoves(1);
  }
  {
#line 519
  FilterIllegalMoves(1);
  }
#line 520
  side = board.side;
#line 526
  p___1 = mvstr;
  }
  {
  {
#line 527
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 529
    if ((int )*s___1 != 120) {
#line 529
      if ((int )*s___1 != 43) {
#line 529
        if ((int )*s___1 != 61) {
#line 530
          tmp = p___1;
#line 530
          p___1 ++;
#line 530
          *tmp = *s___1;
        }
      }
    }
#line 527
    tmp___0 = s___1;
#line 527
    s___1 ++;
#line 527
    if (! ((int )*tmp___0 != 0)) {
#line 527
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 534
  tmp___2 = strlen((char const   *)(mvstr));
  }
  }
#line 534
  if ((int )mvstr[tmp___2 - 1UL] == 43) {
    {
    {
#line 535
    tmp___1 = strlen((char const   *)(mvstr));
    }
#line 535
    mvstr[tmp___1 - 1UL] = (char )'\000';
    }
  } else {
    {
    {
#line 534
    tmp___3 = strlen((char const   *)(mvstr));
    }
    }
#line 534
    if ((int )mvstr[tmp___3 - 1UL] == 35) {
      {
      {
#line 535
      tmp___1 = strlen((char const   *)(mvstr));
      }
#line 535
      mvstr[tmp___1 - 1UL] = (char )'\000';
      }
    } else {
      {
      {
#line 534
      tmp___4 = strlen((char const   *)(mvstr));
      }
      }
#line 534
      if ((int )mvstr[tmp___4 - 1UL] == 61) {
        {
        {
#line 535
        tmp___1 = strlen((char const   *)(mvstr));
        }
#line 535
        mvstr[tmp___1 - 1UL] = (char )'\000';
        }
      }
    }
  }
  {
  {
#line 538
  tmp___6 = strcmp((char const   *)(mvstr), "O-O");
  }
  }
#line 538
  if (tmp___6 == 0) {
#line 538
    goto _L;
  } else {
    {
    {
#line 538
    tmp___7 = strcmp((char const   *)(mvstr), "o-o");
    }
    }
#line 538
    if (tmp___7 == 0) {
#line 538
      goto _L;
    } else {
      {
      {
#line 538
      tmp___8 = strcmp((char const   *)(mvstr), "0-0");
      }
      }
#line 538
      if (tmp___8 == 0) {
        _L: /* CIL Label */ 
#line 541
        if (side == 0) {
#line 543
          f = 4;
#line 543
          t = 6;
        } else {
#line 547
          f = 60;
#line 547
          t = 62;
        }
        {
        {
#line 549
        tmp___5 = IsInMoveList(1, f, t, (char )' ');
        }
        }
#line 549
        return (tmp___5);
      }
    }
  }
  {
  {
#line 552
  tmp___10 = strcmp((char const   *)(mvstr), "O-O-O");
  }
  }
#line 552
  if (tmp___10 == 0) {
#line 552
    goto _L___0;
  } else {
    {
    {
#line 552
    tmp___11 = strcmp((char const   *)(mvstr), "o-o-o");
    }
    }
#line 552
    if (tmp___11 == 0) {
#line 552
      goto _L___0;
    } else {
      {
      {
#line 552
      tmp___12 = strcmp((char const   *)(mvstr), "0-0-0");
      }
      }
#line 552
      if (tmp___12 == 0) {
        _L___0: /* CIL Label */ 
#line 555
        if (side == 0) {
#line 557
          f = 4;
#line 557
          t = 2;
        } else {
#line 561
          f = 60;
#line 561
          t = 58;
        }
        {
        {
#line 563
        tmp___9 = IsInMoveList(1, f, t, (char )' ');
        }
        }
#line 563
        return (tmp___9);
      }
    }
  }
#line 567
  if ((int )mvstr[0] >= 97) {
#line 567
    if ((int )mvstr[0] <= 104) {
#line 567
      if ((int )mvstr[1] >= 49) {
#line 567
        if ((int )mvstr[1] <= 56) {
#line 567
          if ((int )mvstr[2] >= 97) {
#line 567
            if ((int )mvstr[2] <= 104) {
#line 567
              if ((int )mvstr[3] >= 49) {
#line 567
                if ((int )mvstr[3] <= 56) {
                  {
#line 570
                  f = ((int )mvstr[0] - 97) + ((int )mvstr[1] - 49) * 8;
#line 571
                  t = ((int )mvstr[2] - 97) + ((int )mvstr[3] - 49) * 8;
                  {
#line 572
                  tmp___14 = strlen((char const   *)(mvstr));
                  }
                  }
#line 572
                  if (tmp___14 == 5UL) {
#line 572
                    piece = (int )mvstr[4];
                  } else {
#line 572
                    piece = ' ';
                  }
                  {
                  {
#line 573
                  tmp___15 = IsInMoveList(1, f, t, (char )piece);
                  }
                  }
#line 573
                  return (tmp___15);
                }
              }
            }
          }
        }
      }
    }
  }
#line 582
  if ((int )mvstr[0] >= 97) {
#line 582
    if ((int )mvstr[0] <= 104) {
#line 584
      if ((int )mvstr[1] >= 49) {
#line 584
        if ((int )mvstr[1] <= 56) {
#line 586
          t = ((int )mvstr[0] - 97) + ((int )mvstr[1] - 49) * 8;
#line 587
          if (side == 0) {
#line 587
            tmp___16 = -8;
          } else {
#line 587
            tmp___16 = 8;
          }
#line 587
          f = t + tmp___16;
#line 589
          if (f > 0) {
#line 589
            if (f < 64) {
#line 590
              if (BitPosArray[f] & board.b[side][1]) {
#line 592
                if ((int )mvstr[2] != 0) {
                  {
                  {
#line 593
                  tmp___17 = IsInMoveList(1, f, t, mvstr[2]);
                  }
                  }
#line 593
                  return (tmp___17);
                } else {
                  {
                  {
#line 595
                  tmp___18 = IsInMoveList(1, f, t, (char )' ');
                  }
                  }
#line 595
                  return (tmp___18);
                }
              }
#line 597
              if (side == 0) {
#line 597
                tmp___19 = -16;
              } else {
#line 597
                tmp___19 = 16;
              }
#line 597
              f = t + tmp___19;
#line 598
              if (f > 0) {
#line 598
                if (f < 64) {
#line 599
                  if (BitPosArray[f] & board.b[side][1]) {
                    {
                    {
#line 600
                    tmp___20 = IsInMoveList(1, f, t, (char )' ');
                    }
                    }
#line 600
                    return (tmp___20);
                  }
                }
              }
            }
          }
        } else {
#line 584
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 604
      if ((int )mvstr[1] >= 97) {
#line 604
        if ((int )mvstr[1] <= 104) {
#line 604
          if ((int )mvstr[2] >= 49) {
#line 604
            if ((int )mvstr[2] <= 56) {
#line 606
              t = ((int )mvstr[1] - 97) + ((int )mvstr[2] - 49) * 8;
#line 607
              if (side == 0) {
#line 607
                tmp___21 = -1;
              } else {
#line 607
                tmp___21 = 1;
              }
              {
#line 607
              rank = ((int )mvstr[2] - 49) + tmp___21;
#line 608
              f = rank * 8 + ((int )mvstr[0] - 97);
              {
#line 609
              tmp___23 = strlen((char const   *)(mvstr));
              }
              }
#line 609
              if (tmp___23 == 4UL) {
#line 609
                piece = (int )mvstr[3];
              } else {
#line 609
                piece = ' ';
              }
              {
              {
#line 610
              tmp___24 = IsInMoveList(1, f, t, (char )piece);
              }
              }
#line 610
              return (tmp___24);
            } else {
#line 604
              goto _L___2;
            }
          } else {
#line 604
            goto _L___2;
          }
        } else {
#line 604
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 612
      if ((int )mvstr[1] >= 97) {
#line 612
        if ((int )mvstr[1] <= 104) {
#line 614
          file___0 = (int )mvstr[0] - 97;
#line 615
          fileto = (int )mvstr[1] - 97;
#line 616
          b = board.b[side][1] & FileBit[file___0];
#line 617
          if (side == 0) {
#line 618
            if (fileto < file___0) {
#line 618
              tmp___25 = 7;
            } else {
#line 618
              tmp___25 = 9;
            }
#line 618
            b >>= tmp___25;
          } else {
#line 620
            if (fileto < file___0) {
#line 620
              tmp___26 = 9;
            } else {
#line 620
              tmp___26 = 7;
            }
#line 620
            b <<= tmp___26;
          }
#line 621
          if (board.ep > -1) {
#line 622
            b &= board.friends[1 ^ side] | BitPosArray[board.ep];
          } else {
#line 624
            b &= board.friends[1 ^ side];
          }
          {
          {
#line 625
          tmp___27 = nbits(b);
          }
          }
          {
#line 627
          if (tmp___27 == 0) {
#line 627
            goto case_0;
          }
#line 628
          if (tmp___27 == 1) {
#line 628
            goto case_1;
          }
#line 632
          goto switch_default;
          case_0: /* CIL Label */ 
#line 627
          return ((leaf *)((void *)0));
          case_1: /* CIL Label */ 
          {
          {
#line 628
          t = leadz(b);
          }
          }
#line 629
          if (side == 0) {
#line 629
            tmp___28 = 8;
          } else {
#line 629
            tmp___28 = -8;
          }
          {
#line 629
          f = (t - tmp___28) + (file___0 - fileto);
          {
#line 630
          tmp___30 = strlen((char const   *)(mvstr));
          }
          }
#line 630
          if (tmp___30 == 3UL) {
#line 630
            piece = (int )mvstr[2];
          } else {
#line 630
            piece = ' ';
          }
          {
          {
#line 631
          tmp___31 = IsInMoveList(1, f, t, (char )piece);
          }
          }
#line 631
          return (tmp___31);
          switch_default: /* CIL Label */ 
          {
          {
#line 633
          printf((char const   */* __restrict  */)"Ambiguous move: %s %s\n", s___1,
                 mvstr);
          }
          {
#line 634
          ShowBoard();
          }
          }
#line 638
          return ((leaf *)((void *)0));
          switch_break: /* CIL Label */ ;
          }
        }
      }
    } else {
#line 582
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    {
    {
#line 643
    tmp___32 = strchr("NBRQK", (int )mvstr[0]);
    }
    }
#line 643
    if (tmp___32) {
#line 645
      piece = 0;
#line 646
      if ((int )mvstr[0] == 78) {
#line 646
        piece = 2;
      } else
#line 647
      if ((int )mvstr[0] == 66) {
#line 647
        piece = 3;
      } else
#line 648
      if ((int )mvstr[0] == 82) {
#line 648
        piece = 4;
      } else
#line 649
      if ((int )mvstr[0] == 81) {
#line 649
        piece = 5;
      } else
#line 650
      if ((int )mvstr[0] == 75) {
#line 650
        piece = 6;
      }
#line 652
      b = board.b[side][piece];
#line 653
      t = -1;
#line 654
      if ((int )mvstr[1] >= 49) {
#line 654
        if ((int )mvstr[1] <= 56) {
#line 656
          rank = (int )mvstr[1] - 49;
#line 657
          b &= RankBit[rank];
#line 658
          t = ((int )mvstr[2] - 97) + ((int )mvstr[3] - 49) * 8;
        } else {
#line 654
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 660
      if ((int )mvstr[1] >= 97) {
#line 660
        if ((int )mvstr[1] <= 104) {
#line 660
          if ((int )mvstr[2] >= 97) {
#line 660
            if ((int )mvstr[2] <= 104) {
#line 662
              file___0 = (int )mvstr[1] - 97;
#line 663
              b &= FileBit[file___0];
#line 664
              t = ((int )mvstr[2] - 97) + ((int )mvstr[3] - 49) * 8;
            } else {
#line 660
              goto _L___5;
            }
          } else {
#line 660
            goto _L___5;
          }
        } else {
#line 660
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 666
      if ((int )mvstr[1] >= 97) {
#line 666
        if ((int )mvstr[1] <= 104) {
#line 666
          if ((int )mvstr[2] >= 49) {
#line 666
            if ((int )mvstr[2] <= 56) {
#line 668
              t = ((int )mvstr[1] - 97) + ((int )mvstr[2] - 49) * 8;
            }
          }
        }
      }
#line 671
      kount = 0;
#line 672
      n2 = (leaf *)((void *)0);
#line 672
      n1 = n2;
      {
      {
#line 673
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 673
        if (! b) {
#line 673
          goto while_break___0;
        }
        {
        {
#line 675
        f = leadz(b);
        }
#line 676
        b &= NotBitPosArray[f];
        {
#line 677
        n1 = IsInMoveList(1, f, t, (char )' ');
        }
        }
#line 677
        if ((unsigned long )n1 != (unsigned long )((leaf *)((void *)0))) {
#line 679
          n2 = n1;
#line 680
          kount ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 683
      if (kount > 1) {
        {
        {
#line 685
        printf((char const   */* __restrict  */)"Ambiguous move: %s %s\n", s___1,
               mvstr);
        }
        {
#line 686
        ShowBoard();
        }
        }
#line 690
        return ((leaf *)((void *)0));
      } else
#line 692
      if (kount == 0) {
#line 693
        return ((leaf *)((void *)0));
      } else {
#line 695
        return (n2);
      }
    }
  }
#line 698
  return ((leaf *)((void *)0));
}
}
#line 702 "/home/khheo/testset/chess/src/move.c"
leaf *IsInMoveList(int ply , int f , int t , char piece ) 
{ 
  leaf *node___0 ;
  int tmp ;

  {
#line 712
  node___0 = TreePtr[ply];
  {
  {
#line 712
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 712
    if (! ((unsigned long )node___0 < (unsigned long )TreePtr[ply + 1])) {
#line 712
      goto while_break;
    }
#line 714
    if ((node___0->move & 4095) == ((f << 6) | t)) {
      {
      {
#line 714
      tmp = toupper((int )piece);
      }
      }
#line 714
      if (tmp == (int )notation[(node___0->move >> 12) & 7]) {
#line 716
        return (node___0);
      }
    }
#line 712
    node___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 718
  return ((leaf *)((void *)0));
}
}
#line 722 "/home/khheo/testset/chess/src/move.c"
int IsLegalMove(int move ) 
{ 
  int side ;
  int f ;
  int t ;
  int piece ;
  BitBoard blocker ;
  BitBoard enemy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 741
  f = (move >> 6) & 63;
#line 742
  t = move & 63;
#line 745
  if (cboard[f] == 0) {
#line 746
    return (0);
  }
#line 749
  side = board.side;
#line 750
  if (! (BitPosArray[f] & board.friends[side])) {
#line 751
    return (0);
  }
#line 754
  if (BitPosArray[t] & board.friends[side]) {
#line 755
    return (0);
  }
#line 757
  piece = cboard[f];
#line 759
  if (move & 4222976) {
#line 759
    if (piece != 1) {
#line 760
      return (0);
    }
  }
#line 763
  if (move & 4194304) {
#line 763
    if (t != board.ep) {
#line 764
      return (0);
    }
  }
#line 767
  if (move & 2097152) {
#line 767
    if (piece != 6) {
#line 768
      return (0);
    }
  }
#line 770
  blocker = board.blocker;
#line 772
  if (piece == 1) {
#line 774
    if (move & 4194304) {
#line 774
      if (board.ep > -1) {
#line 775
        enemy = board.friends[1 ^ side] | BitPosArray[board.ep];
      } else {
#line 777
        enemy = board.friends[1 ^ side];
      }
    } else {
#line 777
      enemy = board.friends[1 ^ side];
    }
#line 778
    if (side == 0) {
#line 780
      if (! ((MoveArray[1][f] & BitPosArray[t]) & enemy)) {
#line 780
        if (t - f == 8) {
#line 780
          if (! (cboard[t] == 0)) {
#line 780
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 780
        if (t - f == 16) {
#line 780
          if (f >> 3 == 1) {
#line 780
            if (! (! (FromToRay[f][t] & blocker))) {
#line 783
              return (0);
            }
          } else {
#line 783
            return (0);
          }
        } else {
#line 783
          return (0);
        }
      }
    } else
#line 785
    if (side == 1) {
#line 787
      if (! ((MoveArray[7][f] & BitPosArray[t]) & enemy)) {
#line 787
        if (t - f == -8) {
#line 787
          if (! (cboard[t] == 0)) {
#line 787
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 787
        if (t - f == -16) {
#line 787
          if (f >> 3 == 6) {
#line 787
            if (! (! (FromToRay[f][t] & blocker))) {
#line 790
              return (0);
            }
          } else {
#line 790
            return (0);
          }
        } else {
#line 790
          return (0);
        }
      }
    }
  } else
#line 794
  if (piece == 6) {
#line 796
    if (side == 0) {
#line 798
      if (! (MoveArray[piece][f] & BitPosArray[t])) {
#line 798
        if (f == 4) {
#line 798
          if (t == 6) {
#line 798
            if (board.flag & 1) {
#line 798
              if (! (FromToRay[4][6] & blocker)) {
                {
                {
#line 798
                tmp = SqAtakd(4, 1);
                }
                }
#line 798
                if (tmp) {
#line 798
                  goto _L___5;
                } else {
                  {
                  {
#line 798
                  tmp___0 = SqAtakd(5, 1);
                  }
                  }
#line 798
                  if (tmp___0) {
#line 798
                    goto _L___5;
                  }
                }
              } else {
#line 798
                goto _L___5;
              }
            } else {
#line 798
              goto _L___5;
            }
          } else {
#line 798
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 798
        if (f == 4) {
#line 798
          if (t == 2) {
#line 798
            if (board.flag & 2) {
#line 798
              if (! (FromToRay[4][1] & blocker)) {
                {
                {
#line 798
                tmp___1 = SqAtakd(4, 1);
                }
                }
#line 798
                if (tmp___1) {
#line 805
                  return (0);
                } else {
                  {
                  {
#line 798
                  tmp___2 = SqAtakd(3, 1);
                  }
                  }
#line 798
                  if (tmp___2) {
#line 805
                    return (0);
                  }
                }
              } else {
#line 805
                return (0);
              }
            } else {
#line 805
              return (0);
            }
          } else {
#line 805
            return (0);
          }
        } else {
#line 805
          return (0);
        }
      }
    }
#line 807
    if (side == 1) {
#line 809
      if (! (MoveArray[piece][f] & BitPosArray[t])) {
#line 809
        if (f == 60) {
#line 809
          if (t == 62) {
#line 809
            if (board.flag & 4) {
#line 809
              if (! (FromToRay[60][62] & blocker)) {
                {
                {
#line 809
                tmp___3 = SqAtakd(60, 0);
                }
                }
#line 809
                if (tmp___3) {
#line 809
                  goto _L___10;
                } else {
                  {
                  {
#line 809
                  tmp___4 = SqAtakd(61, 0);
                  }
                  }
#line 809
                  if (tmp___4) {
#line 809
                    goto _L___10;
                  }
                }
              } else {
#line 809
                goto _L___10;
              }
            } else {
#line 809
              goto _L___10;
            }
          } else {
#line 809
            goto _L___10;
          }
        } else
        _L___10: /* CIL Label */ 
#line 809
        if (f == 60) {
#line 809
          if (t == 58) {
#line 809
            if (board.flag & 8) {
#line 809
              if (! (FromToRay[60][57] & blocker)) {
                {
                {
#line 809
                tmp___5 = SqAtakd(60, 0);
                }
                }
#line 809
                if (tmp___5) {
#line 816
                  return (0);
                } else {
                  {
                  {
#line 809
                  tmp___6 = SqAtakd(59, 0);
                  }
                  }
#line 809
                  if (tmp___6) {
#line 816
                    return (0);
                  }
                }
              } else {
#line 816
                return (0);
              }
            } else {
#line 816
              return (0);
            }
          } else {
#line 816
            return (0);
          }
        } else {
#line 816
          return (0);
        }
      }
    }
  } else
#line 821
  if (! (MoveArray[piece][f] & BitPosArray[t])) {
#line 822
    return (0);
  }
#line 826
  if (slider[piece]) {
#line 828
    if ((FromToRay[f][t] & NotBitPosArray[t]) & blocker) {
#line 829
      return (0);
    }
  }
#line 832
  return (1);
}
}
#line 843 "/home/khheo/testset/chess/src/move.c"
static char s[6]  ;
#line 835 "/home/khheo/testset/chess/src/move.c"
char *AlgbrMove(int move ) 
{ 
  int f ;
  int t ;

  {
  {
#line 845
  f = (move >> 6) & 63;
#line 846
  t = move & 63;
  {
#line 847
  strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)(algbr[f]));
  }
  {
#line 848
  strcpy((char */* __restrict  */)(s + 2), (char const   */* __restrict  */)(algbr[t]));
  }
  }
#line 849
  if (move & 28672) {
#line 851
    if (flags & 1024U) {
#line 852
      s[4] = lnotation[(move >> 12) & 7];
    } else {
#line 854
      s[4] = notation[(move >> 12) & 7];
    }
#line 855
    s[5] = (char )'\000';
  } else {
#line 858
    s[4] = (char )'\000';
  }
#line 859
  return (s);
}
}
#line 382 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 270 "/home/khheo/testset/chess/src/common.h"
int distance[64][64]  ;
#line 271 "/home/khheo/testset/chess/src/common.h"
int taxicab[64][64]  ;
#line 272 "/home/khheo/testset/chess/src/common.h"
int lzArray[65536]  ;
#line 273
int Shift00[64] ;
#line 274
int Shift90[64] ;
#line 275
int Shift45[64] ;
#line 276
int Shift315[64] ;
#line 277 "/home/khheo/testset/chess/src/common.h"
BitBoard DistMap[64][8]  ;
#line 278 "/home/khheo/testset/chess/src/common.h"
BitBoard BitPosArray[64]  ;
#line 279 "/home/khheo/testset/chess/src/common.h"
BitBoard NotBitPosArray[64]  ;
#line 280 "/home/khheo/testset/chess/src/common.h"
BitBoard MoveArray[8][64]  ;
#line 281 "/home/khheo/testset/chess/src/common.h"
BitBoard Ray[64][8]  ;
#line 282 "/home/khheo/testset/chess/src/common.h"
BitBoard FromToRay[64][64]  ;
#line 283 "/home/khheo/testset/chess/src/common.h"
BitBoard RankBit[8]  ;
#line 284 "/home/khheo/testset/chess/src/common.h"
BitBoard FileBit[8]  ;
#line 285 "/home/khheo/testset/chess/src/common.h"
BitBoard Ataks[2][7]  ;
#line 286 "/home/khheo/testset/chess/src/common.h"
BitBoard PassedPawnMask[2][64]  ;
#line 287 "/home/khheo/testset/chess/src/common.h"
BitBoard IsolaniMask[8]  ;
#line 288 "/home/khheo/testset/chess/src/common.h"
BitBoard SquarePawnMask[2][64]  ;
#line 289 "/home/khheo/testset/chess/src/common.h"
BitBoard Rook00Atak[64][256]  ;
#line 290 "/home/khheo/testset/chess/src/common.h"
BitBoard Rook90Atak[64][256]  ;
#line 291 "/home/khheo/testset/chess/src/common.h"
BitBoard Bishop45Atak[64][256]  ;
#line 292 "/home/khheo/testset/chess/src/common.h"
BitBoard Bishop315Atak[64][256]  ;
#line 293 "/home/khheo/testset/chess/src/common.h"
BitBoard pinned  ;
#line 294 "/home/khheo/testset/chess/src/common.h"
BitBoard rings[4]  ;
#line 295 "/home/khheo/testset/chess/src/common.h"
BitBoard stonewall[2]  ;
#line 296 "/home/khheo/testset/chess/src/common.h"
BitBoard pieces[2]  ;
#line 297 "/home/khheo/testset/chess/src/common.h"
BitBoard mask_kr_trapped_w[3]  ;
#line 298 "/home/khheo/testset/chess/src/common.h"
BitBoard mask_kr_trapped_b[3]  ;
#line 299 "/home/khheo/testset/chess/src/common.h"
BitBoard mask_qr_trapped_w[3]  ;
#line 300 "/home/khheo/testset/chess/src/common.h"
BitBoard mask_qr_trapped_b[3]  ;
#line 301 "/home/khheo/testset/chess/src/common.h"
BitBoard boardhalf[2]  ;
#line 302 "/home/khheo/testset/chess/src/common.h"
BitBoard boardside[2]  ;
#line 303 "/home/khheo/testset/chess/src/common.h"
int directions[64][64]  ;
#line 304 "/home/khheo/testset/chess/src/common.h"
int BitCount[65536]  ;
#line 305 "/home/khheo/testset/chess/src/common.h"
leaf Tree[2000]  ;
#line 306 "/home/khheo/testset/chess/src/common.h"
leaf *TreePtr[65]  ;
#line 307 "/home/khheo/testset/chess/src/common.h"
int RootPV  ;
#line 308 "/home/khheo/testset/chess/src/common.h"
GameRec Game[600]  ;
#line 309 "/home/khheo/testset/chess/src/common.h"
int GameCnt  ;
#line 310 "/home/khheo/testset/chess/src/common.h"
int computer  ;
#line 311 "/home/khheo/testset/chess/src/common.h"
unsigned int flags  ;
#line 312 "/home/khheo/testset/chess/src/common.h"
Board board  ;
#line 313 "/home/khheo/testset/chess/src/common.h"
int cboard[64]  ;
#line 314 "/home/khheo/testset/chess/src/common.h"
int Mvboard[64]  ;
#line 315 "/home/khheo/testset/chess/src/common.h"
HashType hashcode[2][7][64]  ;
#line 316 "/home/khheo/testset/chess/src/common.h"
HashType ephash[64]  ;
#line 317 "/home/khheo/testset/chess/src/common.h"
HashType WKCastlehash  ;
#line 318 "/home/khheo/testset/chess/src/common.h"
HashType WQCastlehash  ;
#line 319 "/home/khheo/testset/chess/src/common.h"
HashType BKCastlehash  ;
#line 320 "/home/khheo/testset/chess/src/common.h"
HashType BQCastlehash  ;
#line 321 "/home/khheo/testset/chess/src/common.h"
HashType Sidehash  ;
#line 322 "/home/khheo/testset/chess/src/common.h"
HashType HashKey  ;
#line 323 "/home/khheo/testset/chess/src/common.h"
HashType PawnHashKey  ;
#line 324 "/home/khheo/testset/chess/src/common.h"
HashSlot *HashTab[2]  ;
#line 325 "/home/khheo/testset/chess/src/common.h"
PawnSlot *PawnTab[2]  ;
#line 326 "/home/khheo/testset/chess/src/common.h"
int Idepth  ;
#line 327 "/home/khheo/testset/chess/src/common.h"
int SxDec  ;
#line 328 "/home/khheo/testset/chess/src/common.h"
int Game50  ;
#line 329 "/home/khheo/testset/chess/src/common.h"
int lazyscore[2]  ;
#line 330 "/home/khheo/testset/chess/src/common.h"
int maxposnscore[2]  ;
#line 331 "/home/khheo/testset/chess/src/common.h"
int rootscore  ;
#line 332 "/home/khheo/testset/chess/src/common.h"
int lastrootscore  ;
#line 333 "/home/khheo/testset/chess/src/common.h"
unsigned long GenCnt  ;
#line 334 "/home/khheo/testset/chess/src/common.h"
unsigned long NodeCnt  ;
#line 335 "/home/khheo/testset/chess/src/common.h"
unsigned long QuiesCnt  ;
#line 336 "/home/khheo/testset/chess/src/common.h"
unsigned long EvalCnt  ;
#line 337 "/home/khheo/testset/chess/src/common.h"
unsigned long EvalCall  ;
#line 338 "/home/khheo/testset/chess/src/common.h"
unsigned long ChkExtCnt  ;
#line 339 "/home/khheo/testset/chess/src/common.h"
unsigned long OneRepCnt  ;
#line 340 "/home/khheo/testset/chess/src/common.h"
unsigned long RcpExtCnt  ;
#line 341 "/home/khheo/testset/chess/src/common.h"
unsigned long PawnExtCnt  ;
#line 342 "/home/khheo/testset/chess/src/common.h"
unsigned long HorzExtCnt  ;
#line 343 "/home/khheo/testset/chess/src/common.h"
unsigned long ThrtExtCnt  ;
#line 344 "/home/khheo/testset/chess/src/common.h"
unsigned long KingExtCnt  ;
#line 345 "/home/khheo/testset/chess/src/common.h"
unsigned long NullCutCnt  ;
#line 346 "/home/khheo/testset/chess/src/common.h"
unsigned long FutlCutCnt  ;
#line 347 "/home/khheo/testset/chess/src/common.h"
unsigned long RazrCutCnt  ;
#line 348 "/home/khheo/testset/chess/src/common.h"
unsigned long TotalGetHashCnt  ;
#line 349 "/home/khheo/testset/chess/src/common.h"
unsigned long GoodGetHashCnt  ;
#line 350 "/home/khheo/testset/chess/src/common.h"
unsigned long TotalPutHashCnt  ;
#line 351 "/home/khheo/testset/chess/src/common.h"
unsigned long CollHashCnt  ;
#line 352 "/home/khheo/testset/chess/src/common.h"
unsigned long TotalPawnHashCnt  ;
#line 353 "/home/khheo/testset/chess/src/common.h"
unsigned long GoodPawnHashCnt  ;
#line 354 "/home/khheo/testset/chess/src/common.h"
unsigned long RepeatCnt  ;
#line 355 "/home/khheo/testset/chess/src/common.h"
unsigned int HashSize  ;
#line 356 "/home/khheo/testset/chess/src/common.h"
unsigned long TTHashMask  ;
#line 357 "/home/khheo/testset/chess/src/common.h"
unsigned long PHashMask  ;
#line 360 "/home/khheo/testset/chess/src/common.h"
char SANmv[10]  ;
#line 361 "/home/khheo/testset/chess/src/common.h"
unsigned long history[2][4096]  ;
#line 362 "/home/khheo/testset/chess/src/common.h"
int killer1[65]  ;
#line 363 "/home/khheo/testset/chess/src/common.h"
int killer2[65]  ;
#line 364 "/home/khheo/testset/chess/src/common.h"
int ChkCnt[65]  ;
#line 365 "/home/khheo/testset/chess/src/common.h"
int ThrtCnt[65]  ;
#line 366 "/home/khheo/testset/chess/src/common.h"
char id[32]  ;
#line 367 "/home/khheo/testset/chess/src/common.h"
char solution[64]  ;
#line 373 "/home/khheo/testset/chess/src/common.h"
double et  ;
#line 374 "/home/khheo/testset/chess/src/common.h"
float SearchTime  ;
#line 375 "/home/khheo/testset/chess/src/common.h"
int SearchDepth  ;
#line 376 "/home/khheo/testset/chess/src/common.h"
int MoveLimit[2]  ;
#line 377 "/home/khheo/testset/chess/src/common.h"
float TimeLimit[2]  ;
#line 378 "/home/khheo/testset/chess/src/common.h"
int TCMove  ;
#line 379 "/home/khheo/testset/chess/src/common.h"
int TCinc  ;
#line 380 "/home/khheo/testset/chess/src/common.h"
float TCTime  ;
#line 381 "/home/khheo/testset/chess/src/common.h"
int hunged[2]  ;
#line 382 "/home/khheo/testset/chess/src/common.h"
int phase  ;
#line 383 "/home/khheo/testset/chess/src/common.h"
int Hashmv[65]  ;
#line 384 "/home/khheo/testset/chess/src/common.h"
int Debugmv[65]  ;
#line 385 "/home/khheo/testset/chess/src/common.h"
int Debugmvl  ;
#line 386 "/home/khheo/testset/chess/src/common.h"
int RootPieces  ;
#line 387 "/home/khheo/testset/chess/src/common.h"
int RootPawns  ;
#line 388 "/home/khheo/testset/chess/src/common.h"
int RootMaterial  ;
#line 389 "/home/khheo/testset/chess/src/common.h"
int RootAlpha  ;
#line 390 "/home/khheo/testset/chess/src/common.h"
int RootBeta  ;
#line 391 "/home/khheo/testset/chess/src/common.h"
int pickphase[65]  ;
#line 392 "/home/khheo/testset/chess/src/common.h"
int InChk[65]  ;
#line 393 "/home/khheo/testset/chess/src/common.h"
int KingThrt[2][65]  ;
#line 394 "/home/khheo/testset/chess/src/common.h"
int threatmv  ;
#line 395 "/home/khheo/testset/chess/src/common.h"
int threatply  ;
#line 396 "/home/khheo/testset/chess/src/common.h"
int KingSafety[2]  ;
#line 398 "/home/khheo/testset/chess/src/common.h"
int bookmode  ;
#line 399 "/home/khheo/testset/chess/src/common.h"
int bookfirstlast  ;
#line 401
int range[8] ;
#line 402
int ptype[2] ;
#line 411
int Mask45[64] ;
#line 412
int Mask315[64] ;
#line 416
int rank8[2] ;
#line 418 "/home/khheo/testset/chess/src/common.h"
FILE *ofp  ;
#line 419 "/home/khheo/testset/chess/src/common.h"
int myrating  ;
#line 419 "/home/khheo/testset/chess/src/common.h"
int opprating  ;
#line 419 "/home/khheo/testset/chess/src/common.h"
int suddendeath  ;
#line 420 "/home/khheo/testset/chess/src/common.h"
char name[50]  ;
#line 421 "/home/khheo/testset/chess/src/common.h"
int computerplays  ;
#line 422 "/home/khheo/testset/chess/src/common.h"
int wasbookmove  ;
#line 423 "/home/khheo/testset/chess/src/common.h"
int nmovesfrombook  ;
#line 424 "/home/khheo/testset/chess/src/common.h"
float maxtime  ;
#line 425 "/home/khheo/testset/chess/src/common.h"
int n  ;
#line 426 "/home/khheo/testset/chess/src/common.h"
int ExchCnt[2]  ;
#line 427 "/home/khheo/testset/chess/src/common.h"
int newpos  ;
#line 427 "/home/khheo/testset/chess/src/common.h"
int existpos  ;
#line 428
int bookloaded ;
#line 460
void Initialize(void) ;
#line 548
void InputCmd(void) ;
#line 135 "/home/khheo/testset/chess/src/main.c"
int castled[2]  ;
#line 155 "/home/khheo/testset/chess/src/main.c"
int TCionc  ;
#line 164 "/home/khheo/testset/chess/src/main.c"
int bookloaded  =    0;
#line 166 "/home/khheo/testset/chess/src/main.c"
int slider[8]  = 
#line 166
  {      0,      0,      0,      1, 
        1,      1,      0,      0};
#line 167 "/home/khheo/testset/chess/src/main.c"
int Value[7]  = {      0,      100,      350,      350, 
        550,      1100,      2000};
#line 168 "/home/khheo/testset/chess/src/main.c"
int range[8]  = 
#line 168
  {      0,      0,      0,      1, 
        1,      1,      0,      0};
#line 169 "/home/khheo/testset/chess/src/main.c"
int ptype[2]  = {      1,      7};
#line 170 "/home/khheo/testset/chess/src/main.c"
char algbr[64][3]  = 
#line 170
  { {        (char )'a',        (char )'1',        (char )'\000'}, 
   {        (char )'b',        (char )'1',        (char )'\000'}, 
   {        (char )'c',        (char )'1',        (char )'\000'}, 
   {        (char )'d',        (char )'1',        (char )'\000'}, 
   {        (char )'e',        (char )'1',        (char )'\000'}, 
   {        (char )'f',        (char )'1',        (char )'\000'}, 
   {        (char )'g',        (char )'1',        (char )'\000'}, 
   {        (char )'h',        (char )'1',        (char )'\000'}, 
   {        (char )'a',        (char )'2',        (char )'\000'}, 
   {        (char )'b',        (char )'2',        (char )'\000'}, 
   {        (char )'c',        (char )'2',        (char )'\000'}, 
   {        (char )'d',        (char )'2',        (char )'\000'}, 
   {        (char )'e',        (char )'2',        (char )'\000'}, 
   {        (char )'f',        (char )'2',        (char )'\000'}, 
   {        (char )'g',        (char )'2',        (char )'\000'}, 
   {        (char )'h',        (char )'2',        (char )'\000'}, 
   {        (char )'a',        (char )'3',        (char )'\000'}, 
   {        (char )'b',        (char )'3',        (char )'\000'}, 
   {        (char )'c',        (char )'3',        (char )'\000'}, 
   {        (char )'d',        (char )'3',        (char )'\000'}, 
   {        (char )'e',        (char )'3',        (char )'\000'}, 
   {        (char )'f',        (char )'3',        (char )'\000'}, 
   {        (char )'g',        (char )'3',        (char )'\000'}, 
   {        (char )'h',        (char )'3',        (char )'\000'}, 
   {        (char )'a',        (char )'4',        (char )'\000'}, 
   {        (char )'b',        (char )'4',        (char )'\000'}, 
   {        (char )'c',        (char )'4',        (char )'\000'}, 
   {        (char )'d',        (char )'4',        (char )'\000'}, 
   {        (char )'e',        (char )'4',        (char )'\000'}, 
   {        (char )'f',        (char )'4',        (char )'\000'}, 
   {        (char )'g',        (char )'4',        (char )'\000'}, 
   {        (char )'h',        (char )'4',        (char )'\000'}, 
   {        (char )'a',        (char )'5',        (char )'\000'}, 
   {        (char )'b',        (char )'5',        (char )'\000'}, 
   {        (char )'c',        (char )'5',        (char )'\000'}, 
   {        (char )'d',        (char )'5',        (char )'\000'}, 
   {        (char )'e',        (char )'5',        (char )'\000'}, 
   {        (char )'f',        (char )'5',        (char )'\000'}, 
   {        (char )'g',        (char )'5',        (char )'\000'}, 
   {        (char )'h',        (char )'5',        (char )'\000'}, 
   {        (char )'a',        (char )'6',        (char )'\000'}, 
   {        (char )'b',        (char )'6',        (char )'\000'}, 
   {        (char )'c',        (char )'6',        (char )'\000'}, 
   {        (char )'d',        (char )'6',        (char )'\000'}, 
   {        (char )'e',        (char )'6',        (char )'\000'}, 
   {        (char )'f',        (char )'6',        (char )'\000'}, 
   {        (char )'g',        (char )'6',        (char )'\000'}, 
   {        (char )'h',        (char )'6',        (char )'\000'}, 
   {        (char )'a',        (char )'7',        (char )'\000'}, 
   {        (char )'b',        (char )'7',        (char )'\000'}, 
   {        (char )'c',        (char )'7',        (char )'\000'}, 
   {        (char )'d',        (char )'7',        (char )'\000'}, 
   {        (char )'e',        (char )'7',        (char )'\000'}, 
   {        (char )'f',        (char )'7',        (char )'\000'}, 
   {        (char )'g',        (char )'7',        (char )'\000'}, 
   {        (char )'h',        (char )'7',        (char )'\000'}, 
   {        (char )'a',        (char )'8',        (char )'\000'}, 
   {        (char )'b',        (char )'8',        (char )'\000'}, 
   {        (char )'c',        (char )'8',        (char )'\000'}, 
   {        (char )'d',        (char )'8',        (char )'\000'}, 
   {        (char )'e',        (char )'8',        (char )'\000'}, 
   {        (char )'f',        (char )'8',        (char )'\000'}, 
   {        (char )'g',        (char )'8',        (char )'\000'}, 
   {        (char )'h',        (char )'8',        (char )'\000'}};
#line 180 "/home/khheo/testset/chess/src/main.c"
char algbrfile[9]  = 
#line 180
  {      (char )'a',      (char )'b',      (char )'c',      (char )'d', 
        (char )'e',      (char )'f',      (char )'g',      (char )'h', 
        (char )'\000'};
#line 181 "/home/khheo/testset/chess/src/main.c"
char algbrrank[9]  = 
#line 181
  {      (char )'1',      (char )'2',      (char )'3',      (char )'4', 
        (char )'5',      (char )'6',      (char )'7',      (char )'8', 
        (char )'\000'};
#line 183 "/home/khheo/testset/chess/src/main.c"
char notation[8]  = 
#line 183
  {      (char )' ',      (char )'P',      (char )'N',      (char )'B', 
        (char )'R',      (char )'Q',      (char )'K',      (char )'\000'};
#line 184 "/home/khheo/testset/chess/src/main.c"
char lnotation[8]  = 
#line 184
  {      (char )' ',      (char )'p',      (char )'n',      (char )'b', 
        (char )'r',      (char )'q',      (char )'k',      (char )'\000'};
#line 186 "/home/khheo/testset/chess/src/main.c"
int Shift00[64]  = 
#line 186
  {      56,      56,      56,      56, 
        56,      56,      56,      56, 
        48,      48,      48,      48, 
        48,      48,      48,      48, 
        40,      40,      40,      40, 
        40,      40,      40,      40, 
        32,      32,      32,      32, 
        32,      32,      32,      32, 
        24,      24,      24,      24, 
        24,      24,      24,      24, 
        16,      16,      16,      16, 
        16,      16,      16,      16, 
        8,      8,      8,      8, 
        8,      8,      8,      8, 
        0,      0,      0,      0, 
        0,      0,      0,      0};
#line 197 "/home/khheo/testset/chess/src/main.c"
int r90[64]  = 
#line 197
  {      56,      48,      40,      32, 
        24,      16,      8,      0, 
        57,      49,      41,      33, 
        25,      17,      9,      1, 
        58,      50,      42,      34, 
        26,      18,      10,      2, 
        59,      51,      43,      35, 
        27,      19,      11,      3, 
        60,      52,      44,      36, 
        28,      20,      12,      4, 
        61,      53,      45,      37, 
        29,      21,      13,      5, 
        62,      54,      46,      38, 
        30,      22,      14,      6, 
        63,      55,      47,      39, 
        31,      23,      15,      7};
#line 207 "/home/khheo/testset/chess/src/main.c"
int Shift90[64]  = 
#line 207
  {      0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56, 
        0,      8,      16,      24, 
        32,      40,      48,      56};
#line 218 "/home/khheo/testset/chess/src/main.c"
int r45[64]  = 
#line 218
  {      28,      21,      15,      10, 
        6,      3,      1,      0, 
        36,      29,      22,      16, 
        11,      7,      4,      2, 
        43,      37,      30,      23, 
        17,      12,      8,      5, 
        49,      44,      38,      31, 
        24,      18,      13,      9, 
        54,      50,      45,      39, 
        32,      25,      19,      14, 
        58,      55,      51,      46, 
        40,      33,      26,      20, 
        61,      59,      56,      52, 
        47,      41,      34,      27, 
        63,      62,      60,      57, 
        53,      48,      42,      35};
#line 228 "/home/khheo/testset/chess/src/main.c"
int Shift45[64]  = 
#line 228
  {      28,      36,      43,      49, 
        54,      58,      61,      63, 
        21,      28,      36,      43, 
        49,      54,      58,      61, 
        15,      21,      28,      36, 
        43,      49,      54,      58, 
        10,      15,      21,      28, 
        36,      43,      49,      54, 
        6,      10,      15,      21, 
        28,      36,      43,      49, 
        3,      6,      10,      15, 
        21,      28,      36,      43, 
        1,      3,      6,      10, 
        15,      21,      28,      36, 
        0,      1,      3,      6, 
        10,      15,      21,      28};
#line 238 "/home/khheo/testset/chess/src/main.c"
int Mask45[64]  = 
#line 238
  {      255,      127,      63,      31, 
        15,      7,      3,      1, 
        127,      255,      127,      63, 
        31,      15,      7,      3, 
        63,      127,      255,      127, 
        63,      31,      15,      7, 
        31,      63,      127,      255, 
        127,      63,      31,      15, 
        15,      31,      63,      127, 
        255,      127,      63,      31, 
        7,      15,      31,      63, 
        127,      255,      127,      63, 
        3,      7,      15,      31, 
        63,      127,      255,      127, 
        1,      3,      7,      15, 
        31,      63,      127,      255};
#line 248 "/home/khheo/testset/chess/src/main.c"
int r315[64]  = 
#line 248
  {      0,      2,      5,      9, 
        14,      20,      27,      35, 
        1,      4,      8,      13, 
        19,      26,      34,      42, 
        3,      7,      12,      18, 
        25,      33,      41,      48, 
        6,      11,      17,      24, 
        32,      40,      47,      53, 
        10,      16,      23,      31, 
        39,      46,      52,      57, 
        15,      22,      30,      38, 
        45,      51,      56,      60, 
        21,      29,      37,      44, 
        50,      55,      59,      62, 
        28,      36,      43,      49, 
        54,      58,      61,      63};
#line 258 "/home/khheo/testset/chess/src/main.c"
int Shift315[64]  = 
#line 258
  {      63,      61,      58,      54, 
        49,      43,      36,      28, 
        61,      58,      54,      49, 
        43,      36,      28,      21, 
        58,      54,      49,      43, 
        36,      28,      21,      15, 
        54,      49,      43,      36, 
        28,      21,      15,      10, 
        49,      43,      36,      28, 
        21,      15,      10,      6, 
        43,      36,      28,      21, 
        15,      10,      6,      3, 
        36,      28,      21,      15, 
        10,      6,      3,      1, 
        28,      21,      15,      10, 
        6,      3,      1,      0};
#line 268 "/home/khheo/testset/chess/src/main.c"
int Mask315[64]  = 
#line 268
  {      1,      3,      7,      15, 
        31,      63,      127,      255, 
        3,      7,      15,      31, 
        63,      127,      255,      127, 
        7,      15,      31,      63, 
        127,      255,      127,      63, 
        15,      31,      63,      127, 
        255,      127,      63,      31, 
        31,      63,      127,      255, 
        127,      63,      31,      15, 
        63,      127,      255,      127, 
        63,      31,      15,      7, 
        127,      255,      127,      63, 
        31,      15,      7,      3, 
        255,      127,      63,      31, 
        15,      7,      3,      1};
#line 278 "/home/khheo/testset/chess/src/main.c"
int rank6[2]  = {      5,      2};
#line 279 "/home/khheo/testset/chess/src/main.c"
int rank7[2]  = {      6,      1};
#line 280 "/home/khheo/testset/chess/src/main.c"
int rank8[2]  = {      7,      0};
#line 283 "/home/khheo/testset/chess/src/main.c"
int main(int argc , char **argv ) 
{ 
  int compilebook ;
  time_t now ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 285
  compilebook = 0;
  {
#line 290
  time(& now);
  }
  {
#line 291
  srand((unsigned int )now);
  }
#line 294
  flags = 0U;
#line 297
  ofp = stdout;
  }
#line 299
  if (argc > 1) {
#line 300
    i = 0;
    {
    {
#line 300
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 300
      if (! (i < argc)) {
#line 300
        goto while_break;
      }
      {
      {
#line 301
      tmp___1 = strcmp((char const   *)*(argv + i), "xboard");
      }
      }
#line 301
      if (tmp___1 == 0) {
#line 302
        flags |= 1024U;
      } else {
        {
        {
#line 303
        tmp___0 = strcmp((char const   *)*(argv + i), "post");
        }
        }
#line 303
        if (tmp___0 == 0) {
#line 304
          flags |= 4096U;
        } else {
          {
          {
#line 305
          tmp = strcmp((char const   *)*(argv + i), "compile");
          }
          }
#line 305
          if (tmp == 0) {
#line 306
            compilebook ++;
          }
        }
      }
#line 300
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 310
  if (! (flags & 1024U)) {
#line 311
    flags |= 4096U;
  }
  {
  {
#line 312
  ShowVersion();
  }
  {
#line 313
  Initialize();
  }
  }
#line 315
  if (argc > 1) {
#line 316
    i = 0;
    {
    {
#line 316
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! (i < argc)) {
#line 316
        goto while_break___0;
      }
      {
      {
#line 317
      tmp___3 = strcmp((char const   *)*(argv + i), "xboard");
      }
      }
#line 317
      if (tmp___3 == 0) {
#line 318
        flags |= 1024U;
      } else {
        {
        {
#line 319
        tmp___2 = strcmp((char const   *)*(argv + i), "post");
        }
        }
#line 319
        if (tmp___2 == 0) {
#line 320
          flags |= 4096U;
        }
      }
#line 316
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 325
  bookmode = 4;
#line 326
  bookfirstlast = 3;
  {
  {
#line 328
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 328
    if (! (! (flags & 1U))) {
#line 328
      goto while_break___1;
    }
    {
    {
#line 330
    InputCmd();
    }
    }
#line 331
    if (flags & 4U) {
#line 331
      if (! (flags & 8U)) {
#line 331
        if (! (flags & 64U)) {
#line 333
          if (! (flags & 1024U)) {
            {
            {
#line 333
            printf((char const   */* __restrict  */)"Thinking...\n");
            }
            }
          }
          {
          {
#line 334
          Iterate();
          }
          }
        }
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 339
  free((void *)HashTab[0]);
  }
  {
#line 340
  free((void *)HashTab[1]);
  }
  {
#line 341
  free((void *)PawnTab[0]);
  }
  {
#line 342
  free((void *)PawnTab[1]);
  }
  }
#line 343
  return (0);
}
}
#line 482 "/home/khheo/testset/chess/src/common.h"
int BookQuery(int BKquery ) ;
#line 33 "/home/khheo/testset/chess/src/iterate.c"
static struct timeval t1  ;
#line 33 "/home/khheo/testset/chess/src/iterate.c"
static struct timeval t2  ;
#line 35 "/home/khheo/testset/chess/src/iterate.c"
int InChkDummy  ;
#line 35 "/home/khheo/testset/chess/src/iterate.c"
int terminal  ;
#line 37 "/home/khheo/testset/chess/src/iterate.c"
void Iterate(void) 
{ 
  int side ;
  int score ;
  int RootAlpha___0 ;
  int RootBeta___0 ;
  int tmp ;
  char const   *color[2] ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
#line 48
  side = board.side;
#line 51
  computerplays = board.side;
#line 53
  lazyscore[1] = 150;
#line 53
  lazyscore[0] = lazyscore[1];
#line 54
  maxposnscore[1] = 150;
#line 54
  maxposnscore[0] = maxposnscore[1];
#line 55
  GenCnt = 0UL;
#line 56
  QuiesCnt = 0UL;
#line 56
  NodeCnt = QuiesCnt;
#line 57
  EvalCall = 0UL;
#line 57
  EvalCnt = EvalCall;
#line 58
  ThrtExtCnt = 0UL;
#line 58
  HorzExtCnt = ThrtExtCnt;
#line 58
  PawnExtCnt = HorzExtCnt;
#line 58
  RcpExtCnt = PawnExtCnt;
#line 58
  ChkExtCnt = RcpExtCnt;
#line 58
  OneRepCnt = ChkExtCnt;
#line 59
  KingExtCnt = 0UL;
#line 60
  FutlCutCnt = 0UL;
#line 60
  NullCutCnt = FutlCutCnt;
#line 61
  GoodGetHashCnt = 0UL;
#line 61
  TotalGetHashCnt = GoodGetHashCnt;
#line 62
  CollHashCnt = 0UL;
#line 62
  TotalPutHashCnt = CollHashCnt;
#line 63
  GoodPawnHashCnt = 0UL;
#line 63
  TotalPawnHashCnt = GoodPawnHashCnt;
  {
#line 64
  RootPawns = nbits(board.b[0][1] | board.b[1][1]);
  }
  {
#line 65
  tmp = nbits(board.friends[0] | board.friends[1]);
  }
#line 65
  RootPieces = tmp - RootPawns;
#line 67
  RootMaterial = board.material[side] - board.material[1 ^ side];
#line 68
  RepeatCnt = 0UL;
#line 69
  et = 0.0;
  {
#line 70
  memset((void *)(ChkCnt), 0, sizeof(ChkCnt));
  }
  {
#line 71
  memset((void *)(ThrtCnt), 0, sizeof(ThrtCnt));
  }
  {
#line 72
  memset((void *)(history), 0, sizeof(history));
  }
  {
#line 73
  memset((void *)(killer1), 0, sizeof(killer1));
  }
  {
#line 74
  memset((void *)(killer2), 0, sizeof(killer2));
  }
  {
#line 75
  TTClear();
  }
#line 76
  flags &= 4294967279U;
  }
#line 77
  if (flags & 2048U) {
#line 81
    SearchTime = (TimeLimit[side] - (float )2) / (float )MoveLimit[side];
#line 86
    SearchTime = ((float )95 * SearchTime) / (float )100;
#line 90
    if (suddendeath) {
#line 91
      SearchTime = ((float )92 * SearchTime) / (float )100;
    }
#line 96
    if (nmovesfrombook <= 3) {
      {
      {
#line 97
      printf((char const   */* __restrict  */)"Search time bonus near book\n");
      }
#line 98
      SearchTime = (float )(1.5 * (double )SearchTime);
      }
    }
#line 104
    if (TCinc != 0) {
#line 105
      if (SearchTime < (float )TCinc) {
        {
#line 106
        color[0] = "White";
#line 106
        color[1] = "Black";
        {
#line 107
        printf((char const   */* __restrict  */)"TimeLimit[%s] = %6.2f\n", color[side],
               (double )TimeLimit[side]);
        }
        }
#line 108
        if (TimeLimit[side] > (float )30) {
#line 109
          SearchTime = (float )TCinc;
        }
      }
    }
    {
    {
#line 112
    ShowTime();
    }
    }
  }
  {
#line 114
  Idepth = 0;
#line 115
  TreePtr[2] = TreePtr[1];
  {
#line 116
  GenMoves(1);
  }
  {
#line 117
  FilterIllegalMoves(1);
  }
  {
#line 118
  SortRoot();
  }
  {
#line 119
  gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
  }
  {
#line 120
  InChk[1] = SqAtakd(board.king[side], 1 ^ side);
  }
  }
#line 123
  if (GenCnt == 0UL) {
#line 125
    if (InChk[1]) {
#line 126
      if (computerplays == 1) {
        {
        {
#line 127
        printf((char const   */* __restrict  */)"1-0 {computer loses as black}\n");
        }
        }
      } else
#line 128
      if (computerplays == 0) {
        {
        {
#line 129
        printf((char const   */* __restrict  */)"0-1 {computer loses as white}\n");
        }
        }
      }
    } else {
      {
      {
#line 131
      printf((char const   */* __restrict  */)"1/2-1/2 {stalemate}\n");
      }
      }
    }
    {
    {
#line 132
    fflush(stdout);
    }
#line 133
    flags |= 80U;
    }
#line 134
    return;
  } else
#line 136
  if (GenCnt == 1UL) {
#line 138
    RootPV = (TreePtr[1])->move;
#line 139
    flags |= 16U;
  }
  {
  {
#line 141
  score = Evaluate(-32767, 32767);
  }
#line 141
  lastrootscore = score;
#line 143
  wasbookmove = 0;
  }
#line 144
  if (bookmode != 0) {
#line 144
    if (! (flags & 256U)) {
#line 144
      if (nmovesfrombook <= 3) {
        {
        {
#line 145
        tmp___0 = BookQuery(0);
        }
        }
#line 145
        if (tmp___0 == 0) {
#line 146
          nmovesfrombook = 0;
#line 147
          wasbookmove = 1;
#line 148
          flags |= 16U;
        } else {
#line 150
          nmovesfrombook ++;
        }
      } else {
#line 152
        nmovesfrombook ++;
      }
    } else {
#line 152
      nmovesfrombook ++;
    }
  } else {
#line 152
    nmovesfrombook ++;
  }
#line 157
  maxtime = (float )4 * SearchTime;
#line 159
  if (flags & 4096U) {
    {
    {
#line 160
    printf((char const   */* __restrict  */)"Root = %d, ", score);
    }
    {
#line 161
    printf((char const   */* __restrict  */)"Phase = %d ", phase);
    }
    }
  }
#line 163
  if ((unsigned long )ofp != (unsigned long )stdout) {
    {
    {
#line 164
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Root = %d\t",
            score);
    }
    {
#line 165
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Phase = %d\t",
            phase);
    }
    }
  }
#line 167
  if (SearchDepth == 0) {
#line 168
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 169
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\nTime = %.2f, Max = %.2f, Left = %.2f, Moves= %d\n",
              (double )SearchTime, (double )maxtime, (double )TimeLimit[side], MoveLimit[side]);
      }
      }
    }
#line 171
    if (flags & 4096U) {
      {
      {
#line 172
      printf((char const   */* __restrict  */)"\nTime = %.2f, Max = %.2f, Left = %.2f, Moves = %d\n",
             (double )SearchTime, (double )maxtime, (double )TimeLimit[side], MoveLimit[side]);
      }
      }
    }
  } else {
#line 175
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 176
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Depth = %d\n",
              SearchDepth);
      }
      }
    }
#line 177
    if (flags & 4096U) {
      {
      {
#line 178
      printf((char const   */* __restrict  */)"Depth = %d\n", SearchDepth);
      }
      }
    }
  }
#line 181
  if (flags & 4096U) {
    {
    {
#line 182
    printf((char const   */* __restrict  */)"Ply   Time     Eval      Nodes   Principal-Variation\n");
    }
    }
#line 183
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 184
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Ply   Time     Eval      Nodes   Principal-Variation\n");
      }
      }
    }
  }
  {
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 186
    if (! (! (flags & 16U))) {
#line 186
      goto while_break;
    }
#line 188
    threatply = 0;
#line 189
    if (score > 32512) {
#line 191
      RootAlpha___0 = score - 1;
#line 192
      RootBeta___0 = 32767;
    } else
#line 194
    if (score < -32512) {
#line 196
      RootAlpha___0 = -32767;
#line 197
      RootBeta___0 = score + 1;
    } else {
#line 201
      if (score - 75 > -32767) {
#line 201
        RootAlpha___0 = score - 75;
      } else {
#line 201
        RootAlpha___0 = -32767;
      }
#line 202
      if (score + 75 < 32767) {
#line 202
        RootBeta___0 = score + 75;
      } else {
#line 202
        RootBeta___0 = 32767;
      }
    }
    {
#line 204
    Idepth += 12;
#line 205
    rootscore = -32768;
    {
#line 206
    score = SearchRoot(Idepth, RootAlpha___0, RootBeta___0);
    }
    }
#line 207
    if (score >= RootBeta___0) {
#line 207
      if (score < 32767) {
#line 207
        if (! (flags & 16U)) {
          {
          {
#line 209
          ShowLine(RootPV, score, (char )'+');
          }
#line 210
          rootscore = -32768;
#line 211
          RootAlpha___0 = RootBeta___0;
#line 212
          RootBeta___0 = 32767;
          {
#line 213
          score = SearchRoot(Idepth, RootAlpha___0, RootBeta___0);
          }
          }
        } else {
#line 207
          goto _L___0;
        }
      } else {
#line 207
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 218
    if (score <= RootAlpha___0) {
#line 218
      if (! (flags & 16U)) {
        {
        {
#line 220
        ShowLine(RootPV, score, (char )'-');
        }
#line 221
        rootscore = -32768;
#line 222
        RootBeta___0 = RootAlpha___0;
#line 223
        RootAlpha___0 = -32767;
        {
#line 224
        score = SearchRoot(Idepth, RootAlpha___0, RootBeta___0);
        }
        }
      }
    }
    {
    {
#line 229
    ShowLine(RootPV, score, (char )'.');
    }
#line 230
    lastrootscore = score;
    }
#line 235
    if (SearchDepth == 0) {
#line 235
      if (flags & 2048U) {
#line 235
        if (et >= (double )(((float )2 * SearchTime) / (float )3)) {
#line 236
          flags |= 16U;
        }
      }
    }
    {
    {
#line 238
    tmp___1 = abs(score);
    }
    }
#line 238
    if (tmp___1 + Idepth >= 32768) {
#line 239
      flags |= 16U;
    }
#line 241
    if (Idepth == SearchDepth * 12) {
#line 242
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 251
  SANMove(RootPV, 1);
  }
  {
#line 252
  strcpy((char */* __restrict  */)(Game[GameCnt + 1].SANmv), (char const   */* __restrict  */)(SANmv));
  }
#line 253
  Game[GameCnt + 1].et = (float )et;
  {
#line 254
  MakeMove(side, & RootPV);
  }
  }
#line 255
  if (flags & 2048U) {
#line 257
    if (suddendeath) {
#line 258
      if (TimeLimit[side] > (float )0) {
#line 258
        if (TimeLimit[side] <= (float )60) {
#line 259
          MoveLimit[side] = 60;
        } else {
#line 261
          MoveLimit[side] = 35;
        }
      } else {
#line 261
        MoveLimit[side] = 35;
      }
      {
      {
#line 262
      printf((char const   */* __restrict  */)"MoveLimit is %d\n", MoveLimit[side]);
      }
      {
#line 263
      printf((char const   */* __restrict  */)"TimeLimit is %f\n", (double )TimeLimit[side]);
      }
      }
    } else {
#line 265
      (MoveLimit[side]) --;
    }
#line 266
    TimeLimit[side] -= (float )et;
#line 267
    if (TCinc != 0) {
#line 268
      TimeLimit[side] += (float )TCinc;
    }
#line 269
    if (MoveLimit[side] == 0) {
#line 271
      MoveLimit[side] = TCMove;
    }
  }
#line 275
  if (flags & 1024U) {
    {
    {
#line 277
    tmp___2 = AlgbrMove(RootPV);
    }
    {
#line 277
    printf((char const   */* __restrict  */)"%d. ... %s\n", GameCnt / 2 + 1, tmp___2);
    }
    {
#line 278
    tmp___3 = AlgbrMove(RootPV);
    }
    {
#line 278
    printf((char const   */* __restrict  */)"My move is: %s\n", tmp___3);
    }
    {
#line 279
    fflush(stdout);
    }
    }
#line 280
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 281
      tmp___4 = AlgbrMove(RootPV);
      }
      {
#line 281
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%d. ... %s\n",
              GameCnt / 2 + 1, tmp___4);
      }
      {
#line 282
      tmp___5 = AlgbrMove(RootPV);
      }
      {
#line 282
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"My move is: %s\n",
              tmp___5);
      }
      {
#line 283
      fflush(ofp);
      }
      }
    }
  } else {
#line 288
    if (! wasbookmove) {
#line 289
      if (et > (double )0) {
#line 289
        tmp___6 = (unsigned long )((double )(NodeCnt + QuiesCnt) / et);
      } else {
#line 289
        tmp___6 = 0UL;
      }
      {
      {
#line 289
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\nTime = %.1f Rate=%lu Nodes=[%lu/%lu/%lu] GenCnt=%lu\n",
              et, tmp___6, NodeCnt, QuiesCnt, NodeCnt + QuiesCnt, GenCnt);
      }
      {
#line 292
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Eval=[%lu/%lu] RptCnt=%lu NullCut=%lu FutlCut=%lu\n",
              EvalCnt, EvalCall, RepeatCnt, NullCutCnt, FutlCutCnt);
      }
      {
#line 294
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Ext: Chk=%lu Recap=%lu Pawn=%lu OneRep=%lu Horz=%lu Mate=%lu KThrt=%lu\n",
              ChkExtCnt, RcpExtCnt, PawnExtCnt, OneRepCnt, HorzExtCnt, ThrtExtCnt,
              KingExtCnt);
      }
      {
#line 297
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Material=[%d/%d : %d/%d] ",
              board.pmaterial[0], board.pmaterial[1], board.material[0], board.material[1]);
      }
      {
#line 302
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Lazy=[%d/%d] ",
              lazyscore[0], lazyscore[1]);
      }
      {
#line 303
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"MaxPosnScore=[%d/%d]\n",
              maxposnscore[0], maxposnscore[1]);
      }
      {
#line 304
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Hash: Success=%ld%% Collision=%ld%% Pawn=%ld%%\n",
              (GoodGetHashCnt * 100UL) / (TotalGetHashCnt + 1UL), (CollHashCnt * 100UL) / (TotalPutHashCnt + 1UL),
              (GoodPawnHashCnt * 100UL) / (TotalPawnHashCnt + 1UL));
      }
      }
    }
#line 309
    if (! (flags & 256U)) {
      {
      {
#line 309
      ShowBoard();
      }
      }
    }
    {
    {
#line 310
    printf((char const   */* __restrict  */)"\nMy move is : %s\n", SANmv);
    }
    {
#line 311
    fflush(stdout);
    }
    }
#line 312
    if ((unsigned long )ofp != (unsigned long )stdout) {
      {
      {
#line 313
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"\nMy move is : %s\n",
              SANmv);
      }
      {
#line 314
      fflush(ofp);
      }
      }
    }
  }
  {
#line 323
  TreePtr[2] = TreePtr[1];
  {
#line 324
  GenMoves(1);
  }
  {
#line 325
  FilterIllegalMoves(1);
  }
  }
#line 326
  if ((unsigned long )TreePtr[1] == (unsigned long )TreePtr[2]) {
    {
    {
#line 328
    tmp___7 = SqAtakd(board.king[board.side], 1 ^ board.side);
    }
    }
#line 328
    if (tmp___7) {
#line 329
      if (computerplays == 1) {
        {
        {
#line 330
        printf((char const   */* __restrict  */)"0-1 {computer wins as black}\n");
        }
        }
      } else {
        {
        {
#line 332
        printf((char const   */* __restrict  */)"1-0 {computer wins as white}\n");
        }
        }
      }
    } else {
      {
      {
#line 334
      printf((char const   */* __restrict  */)"1/2-1/2 {stalemate}\n");
      }
      }
    }
    {
    {
#line 335
    fflush(stdout);
    }
#line 336
    flags |= 64U;
    }
  }
  {
  {
#line 338
  tmp___8 = EvaluateDraw();
  }
  }
#line 338
  if (tmp___8) {
    {
    {
#line 340
    printf((char const   */* __restrict  */)"1/2-1/2 {draw}\n");
    }
    {
#line 341
    fflush(stdout);
    }
#line 342
    flags |= 64U;
    }
  } else {
    {
    {
#line 338
    tmp___9 = Repeat();
    }
    }
#line 338
    if (tmp___9 >= 2) {
      {
      {
#line 340
      printf((char const   */* __restrict  */)"1/2-1/2 {draw}\n");
      }
      {
#line 341
      fflush(stdout);
      }
#line 342
      flags |= 64U;
      }
    }
  }
#line 344
  return;
}
}
#line 348 "/home/khheo/testset/chess/src/iterate.c"
void GetElapsed(void) 
{ 


  {
  {
  {
#line 350
  gettimeofday((struct timeval */* __restrict  */)(& t2), (__timezone_ptr_t )((void *)0));
  }
#line 351
  et = (double )(t2.tv_sec - t1.tv_sec) + (double )(t2.tv_usec - t1.tv_usec) / 1000000.0;
  }
#line 352
  return;
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 461 "/home/khheo/testset/chess/src/common.h"
void InitLzArray(void) ;
#line 462
void InitBitPosArray(void) ;
#line 463
void InitMoveArray(void) ;
#line 464
void InitRay(void) ;
#line 465
void InitFromToRay(void) ;
#line 466
void InitRankFileBit(void) ;
#line 467
void InitBitCount(void) ;
#line 468
void InitPassedPawnMask(void) ;
#line 469
void InitIsolaniMask(void) ;
#line 470
void InitSquarePawnMask(void) ;
#line 471
void InitRandomMasks(void) ;
#line 472
void InitRotAtak(void) ;
#line 473
void InitDistance(void) ;
#line 475
void InitHashCode(void) ;
#line 476
void InitHashTable(void) ;
#line 478
void InitFICS(void) ;
#line 570
void CalcHashKey(void) ;
#line 72 "/usr/include/readline/history.h"
extern void using_history(void) ;
#line 42 "/home/khheo/testset/chess/src/init.c"
void Initialize(void) 
{ 


  {
  {
  {
#line 49
  InitLzArray();
  }
  {
#line 50
  InitBitPosArray();
  }
  {
#line 51
  InitMoveArray();
  }
  {
#line 52
  InitRay();
  }
  {
#line 53
  InitFromToRay();
  }
  {
#line 54
  InitRankFileBit();
  }
  {
#line 55
  InitPassedPawnMask();
  }
  {
#line 56
  InitIsolaniMask();
  }
  {
#line 57
  InitSquarePawnMask();
  }
  {
#line 58
  InitBitCount();
  }
  {
#line 59
  InitRotAtak();
  }
  {
#line 60
  InitRandomMasks();
  }
  {
#line 62
  InitDistance();
  }
  {
#line 63
  InitVars();
  }
  {
#line 64
  InitHashCode();
  }
  {
#line 65
  InitHashTable();
  }
  {
#line 66
  CalcHashKey();
  }
  {
#line 69
  using_history();
  }
  }
#line 71
  return;
}
}
#line 74 "/home/khheo/testset/chess/src/init.c"
void InitFICS(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 76
  if (flags & 1024U) {
    {
    {
#line 77
    printf((char const   */* __restrict  */)"tellics shout Greetings from %s %s. Ready for a game.\n",
           "GNU Chess", "5.05");
    }
    {
#line 78
    printf((char const   */* __restrict  */)"tellics set 1 %s %s.\n", "GNU Chess",
           "5.05");
    }
    }
  }
#line 81
  return;
}
}
#line 85 "/home/khheo/testset/chess/src/init.c"
void InitLzArray(void) 
{ 
  int i ;
  int j___0 ;
  int s___1 ;
  int n___0 ;

  {
#line 97
  n___0 = 1;
#line 97
  s___1 = n___0;
#line 98
  i = 0;
  {
  {
#line 98
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < 16)) {
#line 98
      goto while_break;
    }
#line 100
    j___0 = s___1;
    {
    {
#line 100
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j___0 < s___1 + n___0)) {
#line 100
        goto while_break___0;
      }
#line 101
      lzArray[j___0] = 15 - i;
#line 100
      j___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 102
    s___1 += n___0;
#line 103
    n___0 += n___0;
#line 98
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 108 "/home/khheo/testset/chess/src/init.c"
void InitBitPosArray(void) 
{ 
  BitBoard b ;
  int i ;

  {
#line 121
  b = (BitBoard )1;
#line 122
  i = 63;
  {
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i >= 0)) {
#line 122
      goto while_break;
    }
#line 124
    BitPosArray[i] = b;
#line 125
    NotBitPosArray[i] = ~ b;
#line 122
    i --;
#line 122
    b <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 133 "/home/khheo/testset/chess/src/init.c"
static int const   dir[8][8]  = 
#line 133
  { {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )9,        (int const   )11,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )-21,        (int const   )-19,        (int const   )-12,        (int const   )-8, 
            (int const   )8,        (int const   )12,        (int const   )19,        (int const   )21}, 
   {        (int const   )-11,        (int const   )-9,        (int const   )9,        (int const   )11, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )-10,        (int const   )-1,        (int const   )1,        (int const   )10, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )-11,        (int const   )-10,        (int const   )-9,        (int const   )-1, 
            (int const   )1,        (int const   )9,        (int const   )10,        (int const   )11}, 
   {        (int const   )-11,        (int const   )-10,        (int const   )-9,        (int const   )-1, 
            (int const   )1,        (int const   )9,        (int const   )10,        (int const   )11}, 
   {        (int const   )-9,        (int const   )-11,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}};
#line 144 "/home/khheo/testset/chess/src/init.c"
static int const   ndir[8]  = 
#line 144
  {      (int const   )0,      (int const   )2,      (int const   )8,      (int const   )4, 
        (int const   )4,      (int const   )8,      (int const   )8,      (int const   )2};
#line 147 "/home/khheo/testset/chess/src/init.c"
static int const   map[120]  = 
#line 147
  {      (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )6, 
        (int const   )7,      (int const   )-1,      (int const   )-1,      (int const   )8, 
        (int const   )9,      (int const   )10,      (int const   )11,      (int const   )12, 
        (int const   )13,      (int const   )14,      (int const   )15,      (int const   )-1, 
        (int const   )-1,      (int const   )16,      (int const   )17,      (int const   )18, 
        (int const   )19,      (int const   )20,      (int const   )21,      (int const   )22, 
        (int const   )23,      (int const   )-1,      (int const   )-1,      (int const   )24, 
        (int const   )25,      (int const   )26,      (int const   )27,      (int const   )28, 
        (int const   )29,      (int const   )30,      (int const   )31,      (int const   )-1, 
        (int const   )-1,      (int const   )32,      (int const   )33,      (int const   )34, 
        (int const   )35,      (int const   )36,      (int const   )37,      (int const   )38, 
        (int const   )39,      (int const   )-1,      (int const   )-1,      (int const   )40, 
        (int const   )41,      (int const   )42,      (int const   )43,      (int const   )44, 
        (int const   )45,      (int const   )46,      (int const   )47,      (int const   )-1, 
        (int const   )-1,      (int const   )48,      (int const   )49,      (int const   )50, 
        (int const   )51,      (int const   )52,      (int const   )53,      (int const   )54, 
        (int const   )55,      (int const   )-1,      (int const   )-1,      (int const   )56, 
        (int const   )57,      (int const   )58,      (int const   )59,      (int const   )60, 
        (int const   )61,      (int const   )62,      (int const   )63,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1, 
        (int const   )-1,      (int const   )-1,      (int const   )-1,      (int const   )-1};
#line 164 "/home/khheo/testset/chess/src/init.c"
void InitMoveArray(void) 
{ 
  int piece ;
  int fsq ;
  int tsq ;
  int f ;
  int t ;
  int n___0 ;
  BitBoard *b ;

  {
#line 175
  piece = 1;
  {
  {
#line 175
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 175
    if (! (piece <= 7)) {
#line 175
      goto while_break;
    }
#line 177
    fsq = 0;
    {
    {
#line 177
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! (fsq < 120)) {
#line 177
        goto while_break___0;
      }
#line 179
      f = (int )map[fsq];
#line 179
      if (f == -1) {
#line 179
        goto __Cont;
      }
#line 180
      b = & MoveArray[piece][f];
#line 181
      *b = (BitBoard )0ULL;
#line 182
      n___0 = 0;
      {
      {
#line 182
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 182
        if (! (n___0 < (int )ndir[piece])) {
#line 182
          goto while_break___1;
        }
#line 184
        tsq = fsq;
        {
        {
#line 185
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 187
          tsq += (int )dir[piece][n___0];
#line 188
          t = (int )map[tsq];
#line 188
          if (t != -1) {
#line 189
            *b |= BitPosArray[t];
          }
#line 185
          if (range[piece]) {
#line 185
            if (! (t != -1)) {
#line 185
              goto while_break___2;
            }
          } else {
#line 185
            goto while_break___2;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 182
        n___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 177
      fsq ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 175
    piece ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 197 "/home/khheo/testset/chess/src/init.c"
void InitRay(void) 
{ 
  int piece ;
  int fsq ;
  int tsq ;
  int f ;
  int t ;
  int n___0 ;
  int ray ;
  BitBoard *b ;

  {
  {
  {
#line 212
  memset((void *)(directions), -1, sizeof(directions));
  }
#line 213
  fsq = 0;
  }
  {
  {
#line 213
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 213
    if (! (fsq < 120)) {
#line 213
      goto while_break;
    }
#line 215
    f = (int )map[fsq];
#line 215
    if (f == -1) {
#line 215
      goto __Cont;
    }
#line 216
    ray = -1;
#line 217
    piece = 3;
    {
    {
#line 217
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (piece <= 4)) {
#line 217
        goto while_break___0;
      }
#line 219
      n___0 = 0;
      {
      {
#line 219
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 219
        if (! (n___0 < (int )ndir[piece])) {
#line 219
          goto while_break___1;
        }
#line 221
        ray ++;
#line 221
        b = & Ray[f][ray];
#line 222
        *b = (BitBoard )0ULL;
#line 223
        tsq = fsq;
        {
        {
#line 224
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 226
          tsq += (int )dir[piece][n___0];
#line 227
          t = (int )map[tsq];
#line 227
          if (t != -1) {
#line 229
            *b |= BitPosArray[t];
#line 230
            directions[f][t] = ray;
          }
#line 224
          if (! (t != -1)) {
#line 224
            goto while_break___2;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 219
        n___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 217
      piece ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 213
    fsq ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 239 "/home/khheo/testset/chess/src/init.c"
void InitFromToRay(void) 
{ 
  int piece ;
  int fsq ;
  int tsq ;
  int f ;
  int t ;
  int n___0 ;
  BitBoard *b ;

  {
  {
  {
#line 251
  memset((void *)(FromToRay), 0, sizeof(FromToRay));
  }
#line 252
  piece = 3;
  }
  {
  {
#line 252
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 252
    if (! (piece <= 4)) {
#line 252
      goto while_break;
    }
#line 254
    fsq = 0;
    {
    {
#line 254
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (fsq < 120)) {
#line 254
        goto while_break___0;
      }
#line 256
      f = (int )map[fsq];
#line 256
      if (f == -1) {
#line 256
        goto __Cont;
      }
#line 257
      n___0 = 0;
      {
      {
#line 257
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 257
        if (! (n___0 < (int )ndir[piece])) {
#line 257
          goto while_break___1;
        }
#line 259
        tsq = fsq;
#line 260
        t = (int )map[tsq];
        {
        {
#line 261
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 263
          b = & FromToRay[f][t];
#line 264
          tsq += (int )dir[piece][n___0];
#line 265
          t = (int )map[tsq];
#line 265
          if (t != -1) {
#line 267
            FromToRay[f][t] |= BitPosArray[t];
#line 268
            FromToRay[f][t] |= *b;
          }
#line 261
          if (! (t != -1)) {
#line 261
            goto while_break___2;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 257
        n___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 254
      fsq ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 252
    piece ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 277 "/home/khheo/testset/chess/src/init.c"
void InitRankFileBit(void) 
{ 
  BitBoard b ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 288
  i = 8;
#line 289
  b = (BitBoard )255;
  {
  {
#line 290
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 290
    tmp = i;
#line 290
    i --;
#line 290
    if (! tmp) {
#line 290
      goto while_break;
    }
#line 292
    RankBit[i] = b;
#line 293
    b <<= 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  i = 8;
#line 297
  b = (BitBoard )72340172838076673ULL;
  {
  {
#line 298
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 298
    tmp___0 = i;
#line 298
    i --;
#line 298
    if (! tmp___0) {
#line 298
      goto while_break___0;
    }
#line 300
    FileBit[i] = b;
#line 301
    b <<= 1;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  return;
}
}
#line 306 "/home/khheo/testset/chess/src/init.c"
void InitRandomMasks(void) 
{ 


  {
#line 308
  mask_kr_trapped_w[0] = BitPosArray[15];
#line 309
  mask_kr_trapped_w[1] = BitPosArray[7] | BitPosArray[15];
#line 310
  mask_kr_trapped_w[2] = (BitPosArray[6] | BitPosArray[7]) | BitPosArray[15];
#line 311
  mask_qr_trapped_w[0] = BitPosArray[8];
#line 312
  mask_qr_trapped_w[1] = BitPosArray[0] | BitPosArray[8];
#line 313
  mask_qr_trapped_w[2] = (BitPosArray[0] | BitPosArray[1]) | BitPosArray[8];
#line 314
  mask_kr_trapped_b[0] = BitPosArray[55];
#line 315
  mask_kr_trapped_b[1] = BitPosArray[63] | BitPosArray[55];
#line 316
  mask_kr_trapped_b[2] = (BitPosArray[63] | BitPosArray[62]) | BitPosArray[55];
#line 317
  mask_qr_trapped_b[0] = BitPosArray[48];
#line 318
  mask_qr_trapped_b[1] = BitPosArray[56] | BitPosArray[48];
#line 319
  mask_qr_trapped_b[2] = (BitPosArray[56] | BitPosArray[57]) | BitPosArray[48];
#line 320
  return;
}
}
#line 322 "/home/khheo/testset/chess/src/init.c"
void InitPassedPawnMask(void) 
{ 
  unsigned int sq ;

  {
  {
  {
#line 335
  memset((void *)(PassedPawnMask), 0, sizeof(PassedPawnMask));
  }
#line 338
  sq = 0U;
  }
  {
  {
#line 338
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 338
    if (! (sq < 64U)) {
#line 338
      goto while_break;
    }
#line 340
    PassedPawnMask[0][sq] = Ray[sq][7];
#line 341
    if ((sq & 7U) != 0U) {
#line 342
      PassedPawnMask[0][sq] |= Ray[sq - 1U][7];
    }
#line 343
    if ((sq & 7U) != 7U) {
#line 344
      PassedPawnMask[0][sq] |= Ray[sq + 1U][7];
    }
#line 338
    sq ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  sq = 0U;
  {
  {
#line 348
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 348
    if (! (sq < 64U)) {
#line 348
      goto while_break___0;
    }
#line 350
    PassedPawnMask[1][sq] = Ray[sq][4];
#line 351
    if ((sq & 7U) != 0U) {
#line 352
      PassedPawnMask[1][sq] |= Ray[sq - 1U][4];
    }
#line 353
    if ((sq & 7U) != 7U) {
#line 354
      PassedPawnMask[1][sq] |= Ray[sq + 1U][4];
    }
#line 348
    sq ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 356
  return;
}
}
#line 359 "/home/khheo/testset/chess/src/init.c"
void InitIsolaniMask(void) 
{ 
  int i ;

  {
#line 373
  IsolaniMask[0] = FileBit[1];
#line 374
  IsolaniMask[7] = FileBit[6];
#line 375
  i = 1;
  {
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 375
    if (! (i <= 6)) {
#line 375
      goto while_break;
    }
#line 376
    IsolaniMask[i] = FileBit[i - 1] | FileBit[i + 1];
#line 375
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 381 "/home/khheo/testset/chess/src/init.c"
void InitSquarePawnMask(void) 
{ 
  unsigned int sq ;
  int len ;
  int i ;
  int j___0 ;

  {
  {
  {
#line 394
  memset((void *)(SquarePawnMask), 0, sizeof(PassedPawnMask));
  }
#line 395
  sq = 0U;
  }
  {
  {
#line 395
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 395
    if (! (sq < 64U)) {
#line 395
      goto while_break;
    }
#line 398
    len = (int )(7U - (sq >> 3));
#line 399
    if ((sq & 56U) > sq - (unsigned int )len) {
#line 399
      i = (int )(sq & 56U);
    } else {
#line 399
      i = (int )(sq - (unsigned int )len);
    }
#line 400
    if ((sq | 7U) < sq + (unsigned int )len) {
#line 400
      j___0 = (int )(sq | 7U);
    } else {
#line 400
      j___0 = (int )(sq + (unsigned int )len);
    }
    {
    {
#line 401
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (i <= j___0)) {
#line 401
        goto while_break___0;
      }
#line 403
      SquarePawnMask[0][sq] |= BitPosArray[i] | FromToRay[i][i | 56];
#line 404
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 408
    len = (int )(sq >> 3);
#line 409
    if ((sq & 56U) > sq - (unsigned int )len) {
#line 409
      i = (int )(sq & 56U);
    } else {
#line 409
      i = (int )(sq - (unsigned int )len);
    }
#line 410
    if ((sq | 7U) < sq + (unsigned int )len) {
#line 410
      j___0 = (int )(sq | 7U);
    } else {
#line 410
      j___0 = (int )(sq + (unsigned int )len);
    }
    {
    {
#line 411
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 411
      if (! (i <= j___0)) {
#line 411
        goto while_break___1;
      }
#line 413
      SquarePawnMask[1][sq] |= BitPosArray[i] | FromToRay[i][i & 7];
#line 414
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 395
    sq ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  sq = 8U;
  {
  {
#line 419
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 419
    if (! (sq <= 15U)) {
#line 419
      goto while_break___2;
    }
#line 420
    SquarePawnMask[0][sq] = SquarePawnMask[0][sq + 8U];
#line 419
    sq ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 421
  sq = 48U;
  {
  {
#line 421
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 421
    if (! (sq <= 55U)) {
#line 421
      goto while_break___3;
    }
#line 422
    SquarePawnMask[1][sq] = SquarePawnMask[1][sq - 8U];
#line 421
    sq ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 423
  return;
}
}
#line 426 "/home/khheo/testset/chess/src/init.c"
void InitBitCount(void) 
{ 
  int i ;
  int j___0 ;
  int n___0 ;

  {
#line 437
  BitCount[0] = 0;
#line 438
  BitCount[1] = 1;
#line 439
  i = 1;
#line 440
  n___0 = 2;
  {
  {
#line 440
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 440
    if (! (n___0 <= 16)) {
#line 440
      goto while_break;
    }
#line 442
    i <<= 1;
#line 443
    j___0 = i;
    {
    {
#line 443
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 443
      if (! (j___0 <= i + (i - 1))) {
#line 443
        goto while_break___0;
      }
#line 444
      BitCount[j___0] = 1 + BitCount[j___0 - i];
#line 443
      j___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 440
    n___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return;
}
}
#line 449 "/home/khheo/testset/chess/src/init.c"
void InitRotAtak(void) 
{ 
  int sq ;
  int map___0 ;
  int sq1 ;
  int sq2 ;
  int cmap[8] ;
  int rot1[8] ;
  int rot2[8] ;
  int rot3[8] ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 458
  cmap[0] = 128;
#line 458
  cmap[1] = 64;
#line 458
  cmap[2] = 32;
#line 458
  cmap[3] = 16;
#line 458
  cmap[4] = 8;
#line 458
  cmap[5] = 4;
#line 458
  cmap[6] = 2;
#line 458
  cmap[7] = 1;
#line 459
  rot1[0] = 0;
#line 459
  rot1[1] = 8;
#line 459
  rot1[2] = 16;
#line 459
  rot1[3] = 24;
#line 459
  rot1[4] = 32;
#line 459
  rot1[5] = 40;
#line 459
  rot1[6] = 48;
#line 459
  rot1[7] = 56;
#line 460
  rot2[0] = 0;
#line 460
  rot2[1] = 9;
#line 460
  rot2[2] = 18;
#line 460
  rot2[3] = 27;
#line 460
  rot2[4] = 36;
#line 460
  rot2[5] = 45;
#line 460
  rot2[6] = 54;
#line 460
  rot2[7] = 63;
#line 461
  rot3[0] = 56;
#line 461
  rot3[1] = 49;
#line 461
  rot3[2] = 42;
#line 461
  rot3[3] = 35;
#line 461
  rot3[4] = 28;
#line 461
  rot3[5] = 21;
#line 461
  rot3[6] = 14;
#line 461
  rot3[7] = 7;
#line 463
  sq = 0;
  {
  {
#line 463
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 463
    if (! (sq <= 7)) {
#line 463
      goto while_break;
    }
#line 465
    map___0 = 0;
    {
    {
#line 465
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 465
      if (! (map___0 < 256)) {
#line 465
        goto while_break___0;
      }
#line 467
      Rook00Atak[sq][map___0] = (BitBoard )0;
#line 468
      Rook90Atak[rot1[sq]][map___0] = (BitBoard )0;
#line 469
      Bishop45Atak[rot2[sq]][map___0] = (BitBoard )0;
#line 470
      Bishop315Atak[rot3[sq]][map___0] = (BitBoard )0;
#line 471
      sq2 = sq;
#line 471
      sq1 = sq2;
      {
      {
#line 472
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 472
        if (! (sq1 > 0)) {
#line 472
          goto while_break___1;
        }
#line 474
        sq1 --;
#line 474
        if (cmap[sq1] & map___0) {
#line 475
          goto while_break___1;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 477
      while (1) {
        while_continue___18: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 477
        if (! (sq2 < 7)) {
#line 477
          goto while_break___2;
        }
#line 479
        sq2 ++;
#line 479
        if (cmap[sq2] & map___0) {
#line 480
          goto while_break___2;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 482
      Rook00Atak[sq][map___0] = FromToRay[sq][sq1] | FromToRay[sq][sq2];
#line 484
      Rook90Atak[rot1[sq]][map___0] = FromToRay[rot1[sq]][rot1[sq1]] | FromToRay[rot1[sq]][rot1[sq2]];
#line 487
      Bishop45Atak[rot2[sq]][map___0] = FromToRay[rot2[sq]][rot2[sq1]] | FromToRay[rot2[sq]][rot2[sq2]];
#line 490
      Bishop315Atak[rot3[sq]][map___0] = FromToRay[rot3[sq]][rot3[sq1]] | FromToRay[rot3[sq]][rot3[sq2]];
#line 465
      map___0 ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 463
    sq ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  map___0 = 0;
  {
  {
#line 496
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 496
    if (! (map___0 < 256)) {
#line 496
      goto while_break___3;
    }
#line 498
    sq = 8;
    {
    {
#line 498
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 498
      if (! (sq <= 63)) {
#line 498
        goto while_break___4;
      }
#line 500
      Rook00Atak[sq][map___0] = Rook00Atak[sq - 8][map___0] >> 8;
#line 498
      sq ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 503
    sq1 = 1;
    {
    {
#line 503
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 503
      if (! (sq1 <= 7)) {
#line 503
        goto while_break___5;
      }
#line 505
      sq2 = 0;
      {
      {
#line 505
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 505
        if (! (sq2 < 64)) {
#line 505
          goto while_break___6;
        }
#line 507
        sq = sq2 + sq1;
#line 508
        Rook90Atak[sq][map___0] = Rook90Atak[sq - 1][map___0] >> 1;
#line 505
        sq2 += 8;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 503
      sq1 ++;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 512
    sq1 = 1;
#line 512
    sq2 = 55;
    {
    {
#line 512
    while (1) {
      while_continue___23: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 512
      if (! (sq1 <= 7)) {
#line 512
        goto while_break___7;
      }
#line 514
      sq = sq1;
      {
      {
#line 514
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 514
        if (! (sq <= sq2)) {
#line 514
          goto while_break___8;
        }
#line 516
        Bishop45Atak[sq][map___0] = Bishop45Atak[sq + 8][map___0] << 8;
#line 514
        sq += 9;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 512
      sq1 ++;
#line 512
      sq2 -= 8;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 519
    sq1 = 8;
#line 519
    sq2 = 62;
    {
    {
#line 519
    while (1) {
      while_continue___25: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 519
      if (! (sq1 <= 56)) {
#line 519
        goto while_break___9;
      }
#line 521
      sq = sq1;
      {
      {
#line 521
      while (1) {
        while_continue___26: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 521
        if (! (sq <= sq2)) {
#line 521
          goto while_break___10;
        }
#line 523
        Bishop45Atak[sq][map___0] = (Bishop45Atak[sq + 1][map___0] & NotBitPosArray[sq1 - 8]) << 1;
#line 521
        sq += 9;
      }
      while_break___26: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 519
      sq1 += 8;
#line 519
      sq2 --;
    }
    while_break___25: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 528
    sq1 = 15;
#line 528
    sq2 = 57;
    {
    {
#line 528
    while (1) {
      while_continue___27: /* CIL Label */ ;
      while_continue___11: /* CIL Label */ ;
#line 528
      if (! (sq1 <= 63)) {
#line 528
        goto while_break___11;
      }
#line 530
      sq = sq1;
      {
      {
#line 530
      while (1) {
        while_continue___28: /* CIL Label */ ;
        while_continue___12: /* CIL Label */ ;
#line 530
        if (! (sq <= sq2)) {
#line 530
          goto while_break___12;
        }
#line 532
        Bishop315Atak[sq][map___0] = Bishop315Atak[sq - 8][map___0] >> 8;
#line 530
        sq += 7;
      }
      while_break___28: /* CIL Label */ ;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 528
      sq1 += 8;
#line 528
      sq2 ++;
    }
    while_break___27: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 535
    sq1 = 6;
#line 535
    sq2 = 48;
    {
    {
#line 535
    while (1) {
      while_continue___29: /* CIL Label */ ;
      while_continue___13: /* CIL Label */ ;
#line 535
      if (! (sq1 >= 0)) {
#line 535
        goto while_break___13;
      }
#line 537
      sq = sq1;
      {
      {
#line 537
      while (1) {
        while_continue___30: /* CIL Label */ ;
        while_continue___14: /* CIL Label */ ;
#line 537
        if (! (sq <= sq2)) {
#line 537
          goto while_break___14;
        }
#line 539
        Bishop315Atak[sq][map___0] = (Bishop315Atak[sq + 1][map___0] & NotBitPosArray[sq2 + 8]) << 1;
#line 537
        sq += 7;
      }
      while_break___30: /* CIL Label */ ;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 535
      sq1 --;
#line 535
      sq2 -= 8;
    }
    while_break___29: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 496
    map___0 ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 544
  return;
}
}
#line 547 "/home/khheo/testset/chess/src/init.c"
void InitDistance(void) 
{ 
  int f ;
  int t ;
  int j___0 ;
  int d1 ;
  int d2 ;

  {
#line 560
  f = 0;
  {
  {
#line 560
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 560
    if (! (f < 64)) {
#line 560
      goto while_break;
    }
#line 561
    t = 0;
    {
    {
#line 561
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 561
      if (! (t < 8)) {
#line 561
        goto while_break___0;
      }
#line 562
      DistMap[f][t] = (BitBoard )0ULL;
#line 561
      t ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 560
    f ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 565
  f = 0;
  {
  {
#line 565
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 565
    if (! (f < 64)) {
#line 565
      goto while_break___1;
    }
#line 566
    t = f;
    {
    {
#line 566
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 566
      if (! (t < 64)) {
#line 566
        goto while_break___2;
      }
#line 568
      d1 = (t & 7) - (f & 7);
#line 569
      if (d1 < 0) {
#line 569
        d1 = - d1;
      }
#line 570
      d2 = (t >> 3) - (f >> 3);
#line 571
      if (d2 < 0) {
#line 571
        d2 = - d2;
      }
#line 572
      if (d1 > d2) {
#line 572
        distance[f][t] = d1;
      } else {
#line 572
        distance[f][t] = d2;
      }
#line 573
      if (d1 > d2) {
#line 573
        distance[t][f] = d1;
      } else {
#line 573
        distance[t][f] = d2;
      }
#line 574
      taxicab[f][t] = d1 + d2;
#line 575
      taxicab[t][f] = d1 + d2;
#line 566
      t ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 565
    f ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 578
  f = 0;
  {
  {
#line 578
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 578
    if (! (f < 64)) {
#line 578
      goto while_break___3;
    }
#line 579
    t = 0;
    {
    {
#line 579
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 579
      if (! (t < 64)) {
#line 579
        goto while_break___4;
      }
#line 580
      DistMap[f][distance[t][f]] |= BitPosArray[t];
#line 579
      t ++;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 578
    f ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 582
  f = 0;
  {
  {
#line 582
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 582
    if (! (f < 64)) {
#line 582
      goto while_break___5;
    }
#line 583
    t = 0;
    {
    {
#line 583
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 583
      if (! (t < 8)) {
#line 583
        goto while_break___6;
      }
#line 584
      j___0 = 0;
      {
      {
#line 584
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 584
        if (! (j___0 < t)) {
#line 584
          goto while_break___7;
        }
#line 585
        DistMap[f][t] |= DistMap[f][j___0];
#line 584
        j___0 ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 583
      t ++;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 582
    f ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 586
  return;
}
}
#line 589 "/home/khheo/testset/chess/src/init.c"
void InitVars(void) 
{ 
  int i ;

  {
  {
  {
#line 599
  memset((void *)(& board), 0, sizeof(board));
  }
#line 600
  i = 8;
  }
  {
  {
#line 600
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 600
    if (! (i < 16)) {
#line 600
      goto while_break;
    }
#line 601
    board.b[0][1] |= BitPosArray[i];
#line 600
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  board.b[0][4] |= BitPosArray[0];
#line 603
  board.b[0][2] |= BitPosArray[1];
#line 604
  board.b[0][3] |= BitPosArray[2];
#line 605
  board.b[0][5] |= BitPosArray[3];
#line 606
  board.b[0][6] |= BitPosArray[4];
#line 607
  board.b[0][3] |= BitPosArray[5];
#line 608
  board.b[0][2] |= BitPosArray[6];
#line 609
  board.b[0][4] |= BitPosArray[7];
#line 610
  i = 48;
  {
  {
#line 610
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 610
    if (! (i < 56)) {
#line 610
      goto while_break___0;
    }
#line 611
    board.b[1][1] |= BitPosArray[i];
#line 610
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 612
  board.b[1][4] |= BitPosArray[56];
#line 613
  board.b[1][2] |= BitPosArray[57];
#line 614
  board.b[1][3] |= BitPosArray[58];
#line 615
  board.b[1][5] |= BitPosArray[59];
#line 616
  board.b[1][6] |= BitPosArray[60];
#line 617
  board.b[1][3] |= BitPosArray[61];
#line 618
  board.b[1][2] |= BitPosArray[62];
#line 619
  board.b[1][4] |= BitPosArray[63];
#line 621
  stonewall[0] |= BitPosArray[27];
#line 622
  stonewall[0] |= BitPosArray[20];
#line 623
  stonewall[0] |= BitPosArray[29];
#line 625
  stonewall[1] |= BitPosArray[35];
#line 626
  stonewall[1] |= BitPosArray[44];
#line 627
  stonewall[1] |= BitPosArray[37];
#line 629
  rings[0] = (BitBoard )103481868288ULL;
#line 630
  rings[1] = (BitBoard )66125924401152ULL;
#line 631
  rings[2] = (BitBoard )35538699412471296ULL;
#line 632
  rings[3] = (BitBoard )0xff818181818181ffULL;
#line 636
  boardhalf[0] = ((RankBit[0] | RankBit[1]) | RankBit[2]) | RankBit[3];
#line 637
  boardhalf[1] = ((RankBit[4] | RankBit[5]) | RankBit[6]) | RankBit[7];
#line 638
  boardside[0] = ((FileBit[4] | FileBit[5]) | FileBit[6]) | FileBit[7];
#line 639
  boardside[1] = ((FileBit[0] | FileBit[1]) | FileBit[2]) | FileBit[3];
#line 641
  board.flag |= 15;
#line 642
  board.side = 0;
#line 643
  board.ep = -1;
#line 644
  board.king[0] = 4;
#line 645
  board.king[1] = 60;
#line 646
  GameCnt = -1;
#line 647
  Game50 = 0;
#line 648
  computer = 1;
  {
#line 649
  CalcHashKey();
  }
#line 650
  Game[0].hashkey = HashKey;
#line 651
  board.pmaterial[1] = 3600;
#line 651
  board.pmaterial[0] = board.pmaterial[1];
#line 653
  board.material[1] = board.pmaterial[0] + 800;
#line 653
  board.material[0] = board.material[1];
  {
#line 656
  UpdateFriends();
  }
  {
#line 657
  UpdateCBoard();
  }
  {
#line 658
  UpdateMvboard();
  }
#line 660
  i = 0;
  }
  {
  {
#line 660
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 660
    if (! (i <= 63)) {
#line 660
      goto while_break___1;
    }
#line 662
    if (cboard[i]) {
#line 664
      board.blockerr90 |= BitPosArray[r90[i]];
#line 665
      board.blockerr45 |= BitPosArray[r45[i]];
#line 666
      board.blockerr315 |= BitPosArray[r315[i]];
    }
#line 660
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 673
  TreePtr[1] = Tree;
#line 673
  TreePtr[0] = TreePtr[1];
#line 676
  flags |= 128U;
#line 677
  flags |= 512U;
#line 678
  SearchTime = (float )5;
#line 679
  SearchDepth = 0;
#line 680
  board.castled[1] = 0;
#line 680
  board.castled[0] = board.castled[1];
#line 681
  phase = 8 - (board.material[0] + board.material[1]) / 1150;
#line 684
  i = 1024;
#line 685
  TTHashMask = 0UL;
  {
  {
#line 686
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 686
    i >>= 1;
#line 686
    if (! (i > 0)) {
#line 686
      goto while_break___2;
    }
#line 688
    TTHashMask <<= 1;
#line 689
    TTHashMask |= 1UL;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 691
  HashSize = (unsigned int )(TTHashMask + 1UL);
#line 692
  i = 512;
#line 693
  PHashMask = 0UL;
  {
  {
#line 694
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 694
    i >>= 1;
#line 694
    if (! (i > 0)) {
#line 694
      goto while_break___3;
    }
#line 696
    PHashMask <<= 1;
#line 697
    PHashMask |= 1UL;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 700
  signal(2, & EndSearch);
  }
#line 702
  nmovesfrombook = 0;
  }
#line 703
  return;
}
}
#line 706 "/home/khheo/testset/chess/src/init.c"
void InitHashCode(void) 
{ 
  int color ;
  int piece ;
  int sq ;

  {
#line 718
  color = 0;
  {
  {
#line 718
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 718
    if (! (color <= 1)) {
#line 718
      goto while_break;
    }
#line 720
    piece = 1;
    {
    {
#line 720
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 720
      if (! (piece <= 6)) {
#line 720
        goto while_break___0;
      }
#line 722
      sq = 0;
      {
      {
#line 722
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 722
        if (! (sq < 64)) {
#line 722
          goto while_break___1;
        }
        {
        {
#line 724
        hashcode[color][piece][sq] = Rand64();
        }
#line 722
        sq ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 720
      piece ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 718
    color ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  sq = 0;
  {
  {
#line 728
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 728
    if (! (sq < 64)) {
#line 728
      goto while_break___2;
    }
    {
    {
#line 729
    ephash[sq] = Rand64();
    }
#line 728
    sq ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 730
  WKCastlehash = Rand64();
  }
  {
#line 731
  WQCastlehash = Rand64();
  }
  {
#line 732
  BKCastlehash = Rand64();
  }
  {
#line 733
  BQCastlehash = Rand64();
  }
  {
#line 734
  Sidehash = Rand64();
  }
  }
#line 735
  return;
}
}
#line 738 "/home/khheo/testset/chess/src/init.c"
void InitHashTable(void) 
{ 
  unsigned int size ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 751
    free((void *)HashTab[0]);
    }
    {
#line 752
    free((void *)HashTab[1]);
    }
    {
#line 753
    tmp = malloc((unsigned long )HashSize * sizeof(HashSlot ));
    }
#line 753
    HashTab[0] = (HashSlot *)tmp;
    {
#line 754
    tmp___0 = malloc((unsigned long )HashSize * sizeof(HashSlot ));
    }
#line 754
    HashTab[1] = (HashSlot *)tmp___0;
    }
#line 755
    if ((unsigned long )HashTab[0] == (unsigned long )((void *)0)) {
#line 755
      goto _L;
    } else
#line 755
    if ((unsigned long )HashTab[1] == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
      {
#line 756
      printf((char const   */* __restrict  */)"Not enough memory for transposition table, trying again.\n");
      }
#line 757
      HashSize >>= 1;
#line 758
      TTHashMask >>= 1;
      }
#line 759
      if (HashSize == 0U) {
        {
        {
#line 760
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory exhausted, goodbye, my friend.\n");
        }
        {
#line 761
        exit(1);
        }
        }
      }
#line 763
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 750
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  size = (unsigned int )((unsigned long )(HashSize * 2U) * sizeof(HashSlot ) >> 10);
#line 767
  if (! (flags & 1024U)) {
    {
    {
#line 768
    printf((char const   */* __restrict  */)"Transposition table:  Entries=%uK Size=%uK\n",
           HashSize >> 10, size);
    }
    }
  }
  {
  {
#line 776
  tmp___1 = realloc((void *)PawnTab[0], 512UL * sizeof(PawnSlot ));
  }
#line 776
  PawnTab[0] = (PawnSlot *)tmp___1;
  {
#line 777
  tmp___2 = realloc((void *)PawnTab[1], 512UL * sizeof(PawnSlot ));
  }
#line 777
  PawnTab[1] = (PawnSlot *)tmp___2;
  }
#line 778
  if ((unsigned long )PawnTab[0] == (unsigned long )((void *)0)) {
    {
    {
#line 779
    printf((char const   */* __restrict  */)"Not enough memory for pawn table, goodbye.\n");
    }
    {
#line 780
    exit(1);
    }
    }
  } else
#line 778
  if ((unsigned long )PawnTab[1] == (unsigned long )((void *)0)) {
    {
    {
#line 779
    printf((char const   */* __restrict  */)"Not enough memory for pawn table, goodbye.\n");
    }
    {
#line 780
    exit(1);
    }
    }
  } else {
#line 782
    size = (unsigned int )(1024UL * sizeof(PawnSlot ) >> 10);
#line 783
    if (! (flags & 1024U)) {
      {
      {
#line 784
      printf((char const   */* __restrict  */)"Pawn hash table: Entries=%dK Size=%uK\n",
             512 >> 10, size);
      }
      }
    }
  }
#line 787
  return;
}
}
#line 790 "/home/khheo/testset/chess/src/init.c"
void NewPosition(void) 
{ 


  {
  {
#line 797
  flags &= 4294967231U;
#line 798
  Game50 = 0;
#line 799
  GameCnt = -1;
#line 800
  Game[0].hashkey = HashKey;
  {
#line 801
  TTClear();
  }
  {
#line 802
  PTClear();
  }
#line 803
  nmovesfrombook = 0;
#line 804
  ExchCnt[1] = 0;
#line 804
  ExchCnt[0] = ExchCnt[1];
  }
#line 805
  return;
}
}
#line 585 "/home/khheo/testset/chess/src/common.h"
int EvalHung(int side ) ;
#line 32 "/home/khheo/testset/chess/src/hung.c"
int EvalHung(int side ) 
{ 
  BitBoard c ;
  BitBoard n___0 ;
  BitBoard b ;
  BitBoard r ;
  BitBoard q ;
  int xside ;
  int tmp ;

  {
#line 42
  xside = 1 ^ side;
#line 43
  hunged[side] = 0;
#line 46
  n___0 = Ataks[xside][1] & board.b[side][2];
#line 47
  n___0 |= (Ataks[xside][0] & board.b[side][2]) & ~ Ataks[side][0];
#line 50
  b = Ataks[xside][1] & board.b[side][3];
#line 51
  b |= (Ataks[xside][0] & board.b[side][3]) & ~ Ataks[side][0];
#line 54
  r = (Ataks[xside][1] | Ataks[xside][2]) | Ataks[xside][3];
#line 55
  r &= board.b[side][4];
#line 56
  r |= (Ataks[xside][0] & board.b[side][4]) & ~ Ataks[side][0];
#line 59
  q = ((Ataks[xside][1] | Ataks[xside][2]) | Ataks[xside][3]) | Ataks[xside][4];
#line 61
  q &= board.b[side][5];
#line 62
  q |= (Ataks[xside][0] & board.b[side][5]) & ~ Ataks[side][0];
#line 64
  c = ((n___0 | b) | r) | q;
#line 66
  if (c) {
    {
    {
#line 67
    tmp = nbits(c);
    }
#line 67
    hunged[side] += tmp;
    }
  }
#line 70
  if (Ataks[xside][0] & board.b[side][6]) {
#line 71
    (hunged[side]) ++;
  }
#line 73
  return (hunged[side]);
}
}
#line 571 "/home/khheo/testset/chess/src/common.h"
void ShowHashKey(HashType HashKey___0 ) ;
#line 33 "/home/khheo/testset/chess/src/hash.c"
void CalcHashKey(void) 
{ 
  int sq ;
  int piece ;
  int color ;
  BitBoard b ;

  {
#line 46
  HashKey = (HashType )0;
#line 46
  PawnHashKey = HashKey;
#line 47
  color = 0;
  {
  {
#line 47
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (color <= 1)) {
#line 47
      goto while_break;
    }
#line 49
    piece = 1;
    {
    {
#line 49
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! (piece <= 6)) {
#line 49
        goto while_break___0;
      }
#line 51
      b = board.b[color][piece];
      {
      {
#line 52
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 52
        if (! b) {
#line 52
          goto while_break___1;
        }
        {
        {
#line 54
        sq = leadz(b);
        }
#line 55
        b &= NotBitPosArray[sq];
#line 56
        HashKey ^= hashcode[color][piece][sq];
        }
#line 57
        if (piece == 1) {
#line 58
          PawnHashKey ^= hashcode[color][piece][sq];
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 49
      piece ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 47
    color ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  if (board.ep > -1) {
#line 65
    HashKey ^= ephash[board.ep];
  }
#line 66
  if (board.flag & 1) {
#line 67
    HashKey ^= WKCastlehash;
  }
#line 68
  if (board.flag & 2) {
#line 69
    HashKey ^= WQCastlehash;
  }
#line 70
  if (board.flag & 4) {
#line 71
    HashKey ^= BKCastlehash;
  }
#line 72
  if (board.flag & 8) {
#line 73
    HashKey ^= BQCastlehash;
  }
#line 76
  if (board.side == 1) {
#line 77
    HashKey ^= Sidehash;
  }
#line 79
  return;
}
}
#line 82 "/home/khheo/testset/chess/src/hash.c"
void ShowHashKey(HashType HashKey___0 ) 
{ 
  unsigned long a1 ;
  unsigned long a2 ;
  char *__cil_tmp4 ;

  {
  {
#line 91
  a1 = HashKey___0 & 4294967295UL;
#line 92
  a2 = HashKey___0 >> 32;
  {
#line 93
  printf((char const   */* __restrict  */)"Hashkey = %lx%lx\n", a2, a1);
  }
  }
#line 94
  return;
}
}
#line 527 "/home/khheo/testset/chess/src/common.h"
int PinnedOnKing(int sq , int side ) ;
#line 30 "/home/khheo/testset/chess/src/genmove.c"
int const   raybeg[7]  = {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )4,      (int const   )0,      (int const   )0};
#line 31 "/home/khheo/testset/chess/src/genmove.c"
int const   rayend[7]  = {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )4, 
        (int const   )8,      (int const   )8,      (int const   )0};
#line 33 "/home/khheo/testset/chess/src/genmove.c"
static leaf *node  ;
#line 49 "/home/khheo/testset/chess/src/genmove.c"
__inline static void BitToMove(int f , BitBoard b ) 
{ 
  int t ;

  {
  {
  {
#line 59
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 59
    if (! b) {
#line 59
      goto while_break;
    }
    {
    {
#line 61
    t = leadz(b);
    }
#line 62
    b &= NotBitPosArray[t];
    }
    {
    {
#line 63
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 63
      node->move = (f << 6) | t;
#line 63
      node ++;
#line 63
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return;
}
}
#line 69 "/home/khheo/testset/chess/src/genmove.c"
void GenMoves(int ply ) 
{ 
  int side ;
  int piece ;
  int sq ;
  int t ;
  int ep ;
  BitBoard b ;
  BitBoard c ;
  BitBoard d ;
  BitBoard e ;
  BitBoard friends ;
  BitBoard notfriends ;
  BitBoard blocker ;
  BitBoard notblocker ;
  BitBoard *a ;
  unsigned long long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 82
  side = board.side;
#line 83
  a = board.b[side];
#line 84
  friends = board.friends[side];
#line 85
  notfriends = ~ friends;
#line 86
  blocker = board.blocker;
#line 87
  notblocker = ~ blocker;
#line 88
  node = TreePtr[ply + 1];
#line 89
  ep = board.ep;
#line 92
  piece = 2;
  {
  {
#line 92
  while (1) {
    while_continue___58: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 92
    if (! (piece <= 6)) {
#line 92
      goto while_break;
    }
#line 94
    b = *(a + piece);
    {
    {
#line 95
    while (1) {
      while_continue___59: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 95
      if (! b) {
#line 95
        goto while_break___0;
      }
      {
      {
#line 97
      sq = leadz(b);
      }
#line 98
      b &= NotBitPosArray[sq];
      {
#line 99
      BitToMove(sq, MoveArray[piece][sq] & notfriends);
      }
      }
    }
    while_break___59: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 92
    piece += 4;
  }
  while_break___58: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  b = *(a + 3);
  {
  {
#line 105
  while (1) {
    while_continue___60: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 105
    if (! b) {
#line 105
      goto while_break___1;
    }
    {
    {
#line 107
    sq = leadz(b);
    }
#line 108
    b &= NotBitPosArray[sq];
#line 109
    d = Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]];
    {
#line 110
    BitToMove(sq, d & notfriends);
    }
    }
  }
  while_break___60: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 114
  b = *(a + 4);
  {
  {
#line 115
  while (1) {
    while_continue___61: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 115
    if (! b) {
#line 115
      goto while_break___2;
    }
    {
    {
#line 117
    sq = leadz(b);
    }
#line 118
    b &= NotBitPosArray[sq];
#line 119
    d = Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL];
    {
#line 120
    BitToMove(sq, d & notfriends);
    }
    }
  }
  while_break___61: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 124
  b = *(a + 5);
  {
  {
#line 125
  while (1) {
    while_continue___62: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 125
    if (! b) {
#line 125
      goto while_break___3;
    }
    {
    {
#line 127
    sq = leadz(b);
    }
#line 128
    b &= NotBitPosArray[sq];
#line 129
    d = (Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) | (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]);
    {
#line 130
    BitToMove(sq, d & notfriends);
    }
    }
  }
  while_break___62: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 134
  if (ep > -1) {
#line 134
    tmp = (unsigned long long )BitPosArray[ep];
  } else {
#line 134
    tmp = 0ULL;
  }
#line 134
  e = (BitBoard )((unsigned long long )board.friends[1 ^ side] | tmp);
#line 135
  if (side == 0) {
#line 137
    c = (*(a + 1) >> 8) & notblocker;
    {
    {
#line 138
    while (1) {
      while_continue___63: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 138
      if (! c) {
#line 138
        goto while_break___4;
      }
      {
      {
#line 140
      t = leadz(c);
      }
#line 141
      c &= NotBitPosArray[t];
      }
#line 142
      if (t >= 56) {
        {
        {
#line 144
        while (1) {
          while_continue___64: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
          {
          {
#line 144
          while (1) {
            while_continue___65: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
#line 144
            node->move = (((t - 8) << 6) | t) | 20480;
#line 144
            node ++;
#line 144
            goto while_break___6;
          }
          while_break___65: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
          {
#line 144
          while (1) {
            while_continue___66: /* CIL Label */ ;
            while_continue___7: /* CIL Label */ ;
#line 144
            node->move = (((t - 8) << 6) | t) | 8192;
#line 144
            node ++;
#line 144
            goto while_break___7;
          }
          while_break___66: /* CIL Label */ ;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
          {
#line 144
          while (1) {
            while_continue___67: /* CIL Label */ ;
            while_continue___8: /* CIL Label */ ;
#line 144
            node->move = (((t - 8) << 6) | t) | 16384;
#line 144
            node ++;
#line 144
            goto while_break___8;
          }
          while_break___67: /* CIL Label */ ;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
          {
#line 144
          while (1) {
            while_continue___68: /* CIL Label */ ;
            while_continue___9: /* CIL Label */ ;
#line 144
            node->move = (((t - 8) << 6) | t) | 12288;
#line 144
            node ++;
#line 144
            goto while_break___9;
          }
          while_break___68: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 144
          goto while_break___5;
        }
        while_break___64: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 147
        while (1) {
          while_continue___69: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
#line 147
          node->move = ((t - 8) << 6) | t;
#line 147
          node ++;
#line 147
          goto while_break___10;
        }
        while_break___69: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
    while_break___63: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 150
    b = *(a + 1) & RankBit[1];
#line 151
    c = (b >> 8) & notblocker;
#line 152
    c = (c >> 8) & notblocker;
    {
    {
#line 153
    while (1) {
      while_continue___70: /* CIL Label */ ;
      while_continue___11: /* CIL Label */ ;
#line 153
      if (! c) {
#line 153
        goto while_break___11;
      }
      {
      {
#line 155
      t = leadz(c);
      }
#line 156
      c &= NotBitPosArray[t];
      }
      {
      {
#line 157
      while (1) {
        while_continue___71: /* CIL Label */ ;
        while_continue___12: /* CIL Label */ ;
#line 157
        node->move = ((t - 16) << 6) | t;
#line 157
        node ++;
#line 157
        goto while_break___12;
      }
      while_break___71: /* CIL Label */ ;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
    while_break___70: /* CIL Label */ ;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 160
    b = *(a + 1) & ~ FileBit[0];
#line 161
    c = (b >> 7) & e;
    {
    {
#line 162
    while (1) {
      while_continue___72: /* CIL Label */ ;
      while_continue___13: /* CIL Label */ ;
#line 162
      if (! c) {
#line 162
        goto while_break___13;
      }
      {
      {
#line 164
      t = leadz(c);
      }
#line 165
      c &= NotBitPosArray[t];
      }
#line 166
      if (t >= 56) {
        {
        {
#line 168
        while (1) {
          while_continue___73: /* CIL Label */ ;
          while_continue___14: /* CIL Label */ ;
          {
          {
#line 168
          while (1) {
            while_continue___74: /* CIL Label */ ;
            while_continue___15: /* CIL Label */ ;
#line 168
            node->move = (((t - 7) << 6) | t) | 20480;
#line 168
            node ++;
#line 168
            goto while_break___15;
          }
          while_break___74: /* CIL Label */ ;
          }
          while_break___15: /* CIL Label */ ;
          }
          {
          {
#line 168
          while (1) {
            while_continue___75: /* CIL Label */ ;
            while_continue___16: /* CIL Label */ ;
#line 168
            node->move = (((t - 7) << 6) | t) | 8192;
#line 168
            node ++;
#line 168
            goto while_break___16;
          }
          while_break___75: /* CIL Label */ ;
          }
          while_break___16: /* CIL Label */ ;
          }
          {
          {
#line 168
          while (1) {
            while_continue___76: /* CIL Label */ ;
            while_continue___17: /* CIL Label */ ;
#line 168
            node->move = (((t - 7) << 6) | t) | 16384;
#line 168
            node ++;
#line 168
            goto while_break___17;
          }
          while_break___76: /* CIL Label */ ;
          }
          while_break___17: /* CIL Label */ ;
          }
          {
          {
#line 168
          while (1) {
            while_continue___77: /* CIL Label */ ;
            while_continue___18: /* CIL Label */ ;
#line 168
            node->move = (((t - 7) << 6) | t) | 12288;
#line 168
            node ++;
#line 168
            goto while_break___18;
          }
          while_break___77: /* CIL Label */ ;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 168
          goto while_break___14;
        }
        while_break___73: /* CIL Label */ ;
        }
        while_break___14: /* CIL Label */ ;
        }
      } else
#line 170
      if (ep == t) {
        {
        {
#line 172
        while (1) {
          while_continue___78: /* CIL Label */ ;
          while_continue___19: /* CIL Label */ ;
#line 172
          node->move = (((t - 7) << 6) | t) | 4194304;
#line 172
          node ++;
#line 172
          goto while_break___19;
        }
        while_break___78: /* CIL Label */ ;
        }
        while_break___19: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 176
        while (1) {
          while_continue___79: /* CIL Label */ ;
          while_continue___20: /* CIL Label */ ;
#line 176
          node->move = ((t - 7) << 6) | t;
#line 176
          node ++;
#line 176
          goto while_break___20;
        }
        while_break___79: /* CIL Label */ ;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
    }
    while_break___72: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 180
    b = *(a + 1) & ~ FileBit[7];
#line 181
    c = (b >> 9) & e;
    {
    {
#line 182
    while (1) {
      while_continue___80: /* CIL Label */ ;
      while_continue___21: /* CIL Label */ ;
#line 182
      if (! c) {
#line 182
        goto while_break___21;
      }
      {
      {
#line 184
      t = leadz(c);
      }
#line 185
      c &= NotBitPosArray[t];
      }
#line 186
      if (t >= 56) {
        {
        {
#line 188
        while (1) {
          while_continue___81: /* CIL Label */ ;
          while_continue___22: /* CIL Label */ ;
          {
          {
#line 188
          while (1) {
            while_continue___82: /* CIL Label */ ;
            while_continue___23: /* CIL Label */ ;
#line 188
            node->move = (((t - 9) << 6) | t) | 20480;
#line 188
            node ++;
#line 188
            goto while_break___23;
          }
          while_break___82: /* CIL Label */ ;
          }
          while_break___23: /* CIL Label */ ;
          }
          {
          {
#line 188
          while (1) {
            while_continue___83: /* CIL Label */ ;
            while_continue___24: /* CIL Label */ ;
#line 188
            node->move = (((t - 9) << 6) | t) | 8192;
#line 188
            node ++;
#line 188
            goto while_break___24;
          }
          while_break___83: /* CIL Label */ ;
          }
          while_break___24: /* CIL Label */ ;
          }
          {
          {
#line 188
          while (1) {
            while_continue___84: /* CIL Label */ ;
            while_continue___25: /* CIL Label */ ;
#line 188
            node->move = (((t - 9) << 6) | t) | 16384;
#line 188
            node ++;
#line 188
            goto while_break___25;
          }
          while_break___84: /* CIL Label */ ;
          }
          while_break___25: /* CIL Label */ ;
          }
          {
          {
#line 188
          while (1) {
            while_continue___85: /* CIL Label */ ;
            while_continue___26: /* CIL Label */ ;
#line 188
            node->move = (((t - 9) << 6) | t) | 12288;
#line 188
            node ++;
#line 188
            goto while_break___26;
          }
          while_break___85: /* CIL Label */ ;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 188
          goto while_break___22;
        }
        while_break___81: /* CIL Label */ ;
        }
        while_break___22: /* CIL Label */ ;
        }
      } else
#line 190
      if (ep == t) {
        {
        {
#line 192
        while (1) {
          while_continue___86: /* CIL Label */ ;
          while_continue___27: /* CIL Label */ ;
#line 192
          node->move = (((t - 9) << 6) | t) | 4194304;
#line 192
          node ++;
#line 192
          goto while_break___27;
        }
        while_break___86: /* CIL Label */ ;
        }
        while_break___27: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 196
        while (1) {
          while_continue___87: /* CIL Label */ ;
          while_continue___28: /* CIL Label */ ;
#line 196
          node->move = ((t - 9) << 6) | t;
#line 196
          node ++;
#line 196
          goto while_break___28;
        }
        while_break___87: /* CIL Label */ ;
        }
        while_break___28: /* CIL Label */ ;
        }
      }
    }
    while_break___80: /* CIL Label */ ;
    }
    while_break___21: /* CIL Label */ ;
    }
  }
#line 203
  if (side == 1) {
#line 205
    c = (*(a + 1) << 8) & notblocker;
    {
    {
#line 206
    while (1) {
      while_continue___88: /* CIL Label */ ;
      while_continue___29: /* CIL Label */ ;
#line 206
      if (! c) {
#line 206
        goto while_break___29;
      }
      {
      {
#line 208
      t = leadz(c);
      }
#line 209
      c &= NotBitPosArray[t];
      }
#line 210
      if (t <= 7) {
        {
        {
#line 212
        while (1) {
          while_continue___89: /* CIL Label */ ;
          while_continue___30: /* CIL Label */ ;
          {
          {
#line 212
          while (1) {
            while_continue___90: /* CIL Label */ ;
            while_continue___31: /* CIL Label */ ;
#line 212
            node->move = (((t + 8) << 6) | t) | 20480;
#line 212
            node ++;
#line 212
            goto while_break___31;
          }
          while_break___90: /* CIL Label */ ;
          }
          while_break___31: /* CIL Label */ ;
          }
          {
          {
#line 212
          while (1) {
            while_continue___91: /* CIL Label */ ;
            while_continue___32: /* CIL Label */ ;
#line 212
            node->move = (((t + 8) << 6) | t) | 8192;
#line 212
            node ++;
#line 212
            goto while_break___32;
          }
          while_break___91: /* CIL Label */ ;
          }
          while_break___32: /* CIL Label */ ;
          }
          {
          {
#line 212
          while (1) {
            while_continue___92: /* CIL Label */ ;
            while_continue___33: /* CIL Label */ ;
#line 212
            node->move = (((t + 8) << 6) | t) | 16384;
#line 212
            node ++;
#line 212
            goto while_break___33;
          }
          while_break___92: /* CIL Label */ ;
          }
          while_break___33: /* CIL Label */ ;
          }
          {
          {
#line 212
          while (1) {
            while_continue___93: /* CIL Label */ ;
            while_continue___34: /* CIL Label */ ;
#line 212
            node->move = (((t + 8) << 6) | t) | 12288;
#line 212
            node ++;
#line 212
            goto while_break___34;
          }
          while_break___93: /* CIL Label */ ;
          }
          while_break___34: /* CIL Label */ ;
          }
#line 212
          goto while_break___30;
        }
        while_break___89: /* CIL Label */ ;
        }
        while_break___30: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 215
        while (1) {
          while_continue___94: /* CIL Label */ ;
          while_continue___35: /* CIL Label */ ;
#line 215
          node->move = ((t + 8) << 6) | t;
#line 215
          node ++;
#line 215
          goto while_break___35;
        }
        while_break___94: /* CIL Label */ ;
        }
        while_break___35: /* CIL Label */ ;
        }
      }
    }
    while_break___88: /* CIL Label */ ;
    }
    while_break___29: /* CIL Label */ ;
    }
#line 218
    b = *(a + 1) & RankBit[6];
#line 219
    c = (b << 8) & notblocker;
#line 220
    c = (c << 8) & notblocker;
    {
    {
#line 221
    while (1) {
      while_continue___95: /* CIL Label */ ;
      while_continue___36: /* CIL Label */ ;
#line 221
      if (! c) {
#line 221
        goto while_break___36;
      }
      {
      {
#line 223
      t = leadz(c);
      }
#line 224
      c &= NotBitPosArray[t];
      }
      {
      {
#line 225
      while (1) {
        while_continue___96: /* CIL Label */ ;
        while_continue___37: /* CIL Label */ ;
#line 225
        node->move = ((t + 16) << 6) | t;
#line 225
        node ++;
#line 225
        goto while_break___37;
      }
      while_break___96: /* CIL Label */ ;
      }
      while_break___37: /* CIL Label */ ;
      }
    }
    while_break___95: /* CIL Label */ ;
    }
    while_break___36: /* CIL Label */ ;
    }
#line 228
    b = *(a + 1) & ~ FileBit[7];
#line 229
    c = (b << 7) & e;
    {
    {
#line 230
    while (1) {
      while_continue___97: /* CIL Label */ ;
      while_continue___38: /* CIL Label */ ;
#line 230
      if (! c) {
#line 230
        goto while_break___38;
      }
      {
      {
#line 232
      t = leadz(c);
      }
#line 233
      c &= NotBitPosArray[t];
      }
#line 234
      if (t <= 7) {
        {
        {
#line 236
        while (1) {
          while_continue___98: /* CIL Label */ ;
          while_continue___39: /* CIL Label */ ;
          {
          {
#line 236
          while (1) {
            while_continue___99: /* CIL Label */ ;
            while_continue___40: /* CIL Label */ ;
#line 236
            node->move = (((t + 7) << 6) | t) | 20480;
#line 236
            node ++;
#line 236
            goto while_break___40;
          }
          while_break___99: /* CIL Label */ ;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
          {
#line 236
          while (1) {
            while_continue___100: /* CIL Label */ ;
            while_continue___41: /* CIL Label */ ;
#line 236
            node->move = (((t + 7) << 6) | t) | 8192;
#line 236
            node ++;
#line 236
            goto while_break___41;
          }
          while_break___100: /* CIL Label */ ;
          }
          while_break___41: /* CIL Label */ ;
          }
          {
          {
#line 236
          while (1) {
            while_continue___101: /* CIL Label */ ;
            while_continue___42: /* CIL Label */ ;
#line 236
            node->move = (((t + 7) << 6) | t) | 16384;
#line 236
            node ++;
#line 236
            goto while_break___42;
          }
          while_break___101: /* CIL Label */ ;
          }
          while_break___42: /* CIL Label */ ;
          }
          {
          {
#line 236
          while (1) {
            while_continue___102: /* CIL Label */ ;
            while_continue___43: /* CIL Label */ ;
#line 236
            node->move = (((t + 7) << 6) | t) | 12288;
#line 236
            node ++;
#line 236
            goto while_break___43;
          }
          while_break___102: /* CIL Label */ ;
          }
          while_break___43: /* CIL Label */ ;
          }
#line 236
          goto while_break___39;
        }
        while_break___98: /* CIL Label */ ;
        }
        while_break___39: /* CIL Label */ ;
        }
      } else
#line 238
      if (ep == t) {
        {
        {
#line 240
        while (1) {
          while_continue___103: /* CIL Label */ ;
          while_continue___44: /* CIL Label */ ;
#line 240
          node->move = (((t + 7) << 6) | t) | 4194304;
#line 240
          node ++;
#line 240
          goto while_break___44;
        }
        while_break___103: /* CIL Label */ ;
        }
        while_break___44: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 244
        while (1) {
          while_continue___104: /* CIL Label */ ;
          while_continue___45: /* CIL Label */ ;
#line 244
          node->move = ((t + 7) << 6) | t;
#line 244
          node ++;
#line 244
          goto while_break___45;
        }
        while_break___104: /* CIL Label */ ;
        }
        while_break___45: /* CIL Label */ ;
        }
      }
    }
    while_break___97: /* CIL Label */ ;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 248
    b = *(a + 1) & ~ FileBit[0];
#line 249
    c = (b << 9) & e;
    {
    {
#line 250
    while (1) {
      while_continue___105: /* CIL Label */ ;
      while_continue___46: /* CIL Label */ ;
#line 250
      if (! c) {
#line 250
        goto while_break___46;
      }
      {
      {
#line 252
      t = leadz(c);
      }
#line 253
      c &= NotBitPosArray[t];
      }
#line 254
      if (t <= 7) {
        {
        {
#line 256
        while (1) {
          while_continue___106: /* CIL Label */ ;
          while_continue___47: /* CIL Label */ ;
          {
          {
#line 256
          while (1) {
            while_continue___107: /* CIL Label */ ;
            while_continue___48: /* CIL Label */ ;
#line 256
            node->move = (((t + 9) << 6) | t) | 20480;
#line 256
            node ++;
#line 256
            goto while_break___48;
          }
          while_break___107: /* CIL Label */ ;
          }
          while_break___48: /* CIL Label */ ;
          }
          {
          {
#line 256
          while (1) {
            while_continue___108: /* CIL Label */ ;
            while_continue___49: /* CIL Label */ ;
#line 256
            node->move = (((t + 9) << 6) | t) | 8192;
#line 256
            node ++;
#line 256
            goto while_break___49;
          }
          while_break___108: /* CIL Label */ ;
          }
          while_break___49: /* CIL Label */ ;
          }
          {
          {
#line 256
          while (1) {
            while_continue___109: /* CIL Label */ ;
            while_continue___50: /* CIL Label */ ;
#line 256
            node->move = (((t + 9) << 6) | t) | 16384;
#line 256
            node ++;
#line 256
            goto while_break___50;
          }
          while_break___109: /* CIL Label */ ;
          }
          while_break___50: /* CIL Label */ ;
          }
          {
          {
#line 256
          while (1) {
            while_continue___110: /* CIL Label */ ;
            while_continue___51: /* CIL Label */ ;
#line 256
            node->move = (((t + 9) << 6) | t) | 12288;
#line 256
            node ++;
#line 256
            goto while_break___51;
          }
          while_break___110: /* CIL Label */ ;
          }
          while_break___51: /* CIL Label */ ;
          }
#line 256
          goto while_break___47;
        }
        while_break___106: /* CIL Label */ ;
        }
        while_break___47: /* CIL Label */ ;
        }
      } else
#line 258
      if (ep == t) {
        {
        {
#line 260
        while (1) {
          while_continue___111: /* CIL Label */ ;
          while_continue___52: /* CIL Label */ ;
#line 260
          node->move = (((t + 9) << 6) | t) | 4194304;
#line 260
          node ++;
#line 260
          goto while_break___52;
        }
        while_break___111: /* CIL Label */ ;
        }
        while_break___52: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 264
        while (1) {
          while_continue___112: /* CIL Label */ ;
          while_continue___53: /* CIL Label */ ;
#line 264
          node->move = ((t + 9) << 6) | t;
#line 264
          node ++;
#line 264
          goto while_break___53;
        }
        while_break___112: /* CIL Label */ ;
        }
        while_break___53: /* CIL Label */ ;
        }
      }
    }
    while_break___105: /* CIL Label */ ;
    }
    while_break___46: /* CIL Label */ ;
    }
  }
#line 270
  b = board.b[side][4];
#line 271
  if (side == 0) {
#line 271
    if (board.flag & 1) {
#line 271
      if (b & BitPosArray[7]) {
#line 271
        if (! (FromToRay[4][6] & blocker)) {
          {
          {
#line 271
          tmp___0 = SqAtakd(4, 1);
          }
          }
#line 271
          if (! tmp___0) {
            {
            {
#line 271
            tmp___1 = SqAtakd(5, 1);
            }
            }
#line 271
            if (! tmp___1) {
              {
              {
#line 271
              tmp___2 = SqAtakd(6, 1);
              }
              }
#line 271
              if (! tmp___2) {
                {
                {
#line 275
                while (1) {
                  while_continue___113: /* CIL Label */ ;
                  while_continue___54: /* CIL Label */ ;
#line 275
                  node->move = ((4 << 6) | 6) | 2097152;
#line 275
                  node ++;
#line 275
                  goto while_break___54;
                }
                while_break___113: /* CIL Label */ ;
                }
                while_break___54: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 277
  if (side == 0) {
#line 277
    if (board.flag & 2) {
#line 277
      if (b & BitPosArray[0]) {
#line 277
        if (! (FromToRay[4][1] & blocker)) {
          {
          {
#line 277
          tmp___3 = SqAtakd(4, 1);
          }
          }
#line 277
          if (! tmp___3) {
            {
            {
#line 277
            tmp___4 = SqAtakd(3, 1);
            }
            }
#line 277
            if (! tmp___4) {
              {
              {
#line 277
              tmp___5 = SqAtakd(2, 1);
              }
              }
#line 277
              if (! tmp___5) {
                {
                {
#line 281
                while (1) {
                  while_continue___114: /* CIL Label */ ;
                  while_continue___55: /* CIL Label */ ;
#line 281
                  node->move = ((4 << 6) | 2) | 2097152;
#line 281
                  node ++;
#line 281
                  goto while_break___55;
                }
                while_break___114: /* CIL Label */ ;
                }
                while_break___55: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 283
  if (side == 1) {
#line 283
    if (board.flag & 4) {
#line 283
      if (b & BitPosArray[63]) {
#line 283
        if (! (FromToRay[60][62] & blocker)) {
          {
          {
#line 283
          tmp___6 = SqAtakd(60, 0);
          }
          }
#line 283
          if (! tmp___6) {
            {
            {
#line 283
            tmp___7 = SqAtakd(61, 0);
            }
            }
#line 283
            if (! tmp___7) {
              {
              {
#line 283
              tmp___8 = SqAtakd(62, 0);
              }
              }
#line 283
              if (! tmp___8) {
                {
                {
#line 287
                while (1) {
                  while_continue___115: /* CIL Label */ ;
                  while_continue___56: /* CIL Label */ ;
#line 287
                  node->move = ((60 << 6) | 62) | 2097152;
#line 287
                  node ++;
#line 287
                  goto while_break___56;
                }
                while_break___115: /* CIL Label */ ;
                }
                while_break___56: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 289
  if (side == 1) {
#line 289
    if (board.flag & 8) {
#line 289
      if (b & BitPosArray[56]) {
#line 289
        if (! (FromToRay[60][57] & blocker)) {
          {
          {
#line 289
          tmp___9 = SqAtakd(60, 0);
          }
          }
#line 289
          if (! tmp___9) {
            {
            {
#line 289
            tmp___10 = SqAtakd(59, 0);
            }
            }
#line 289
            if (! tmp___10) {
              {
              {
#line 289
              tmp___11 = SqAtakd(58, 0);
              }
              }
#line 289
              if (! tmp___11) {
                {
                {
#line 293
                while (1) {
                  while_continue___116: /* CIL Label */ ;
                  while_continue___57: /* CIL Label */ ;
#line 293
                  node->move = ((60 << 6) | 58) | 2097152;
#line 293
                  node ++;
#line 293
                  goto while_break___57;
                }
                while_break___116: /* CIL Label */ ;
                }
                while_break___57: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 297
  TreePtr[ply + 1] = node;
#line 298
  GenCnt += (unsigned long )(TreePtr[ply + 1] - TreePtr[ply]);
#line 299
  return;
}
}
#line 302 "/home/khheo/testset/chess/src/genmove.c"
void GenNonCaptures(int ply ) 
{ 
  int side ;
  int piece ;
  int sq ;
  int t ;
  int ep ;
  BitBoard b ;
  BitBoard c ;
  BitBoard d ;
  BitBoard friends ;
  BitBoard notfriends ;
  BitBoard blocker ;
  BitBoard notblocker ;
  BitBoard *a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 315
  side = board.side;
#line 316
  a = board.b[side];
#line 317
  friends = board.friends[side];
#line 318
  notfriends = ~ friends;
#line 319
  blocker = board.blocker;
#line 320
  notblocker = ~ blocker;
#line 321
  node = TreePtr[ply + 1];
#line 322
  ep = board.ep;
#line 325
  piece = 2;
  {
  {
#line 325
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 325
    if (! (piece <= 6)) {
#line 325
      goto while_break;
    }
#line 327
    b = *(a + piece);
    {
    {
#line 328
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! b) {
#line 328
        goto while_break___0;
      }
      {
      {
#line 330
      sq = leadz(b);
      }
#line 331
      b &= NotBitPosArray[sq];
      {
#line 332
      BitToMove(sq, MoveArray[piece][sq] & notblocker);
      }
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 325
    piece += 4;
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  b = *(a + 3);
  {
  {
#line 338
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! b) {
#line 338
      goto while_break___1;
    }
    {
    {
#line 340
    sq = leadz(b);
    }
#line 341
    b &= NotBitPosArray[sq];
#line 342
    d = Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]];
    {
#line 343
    BitToMove(sq, d & notblocker);
    }
    }
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 347
  b = *(a + 4);
  {
  {
#line 348
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 348
    if (! b) {
#line 348
      goto while_break___2;
    }
    {
    {
#line 350
    sq = leadz(b);
    }
#line 351
    b &= NotBitPosArray[sq];
#line 352
    d = Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL];
    {
#line 353
    BitToMove(sq, d & notblocker);
    }
    }
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 357
  b = *(a + 5);
  {
  {
#line 358
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 358
    if (! b) {
#line 358
      goto while_break___3;
    }
    {
    {
#line 360
    sq = leadz(b);
    }
#line 361
    b &= NotBitPosArray[sq];
#line 362
    d = (Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) | (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]);
    {
#line 363
    BitToMove(sq, d & notblocker);
    }
    }
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 367
  if (side == 0) {
#line 369
    c = (*(a + 1) >> 8) & notblocker;
    {
    {
#line 370
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 370
      if (! c) {
#line 370
        goto while_break___4;
      }
      {
      {
#line 372
      t = leadz(c);
      }
#line 373
      c &= NotBitPosArray[t];
      }
#line 374
      if (t < 56) {
        {
        {
#line 375
        while (1) {
          while_continue___22: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 375
          node->move = ((t - 8) << 6) | t;
#line 375
          node ++;
#line 375
          goto while_break___5;
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 378
    b = *(a + 1) & RankBit[1];
#line 379
    c = (b >> 8) & notblocker;
#line 380
    c = (c >> 8) & notblocker;
    {
    {
#line 381
    while (1) {
      while_continue___23: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 381
      if (! c) {
#line 381
        goto while_break___6;
      }
      {
      {
#line 383
      t = leadz(c);
      }
#line 384
      c &= NotBitPosArray[t];
      }
      {
      {
#line 385
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 385
        node->move = ((t - 16) << 6) | t;
#line 385
        node ++;
#line 385
        goto while_break___7;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 391
  if (side == 1) {
#line 393
    c = (*(a + 1) << 8) & notblocker;
    {
    {
#line 394
    while (1) {
      while_continue___25: /* CIL Label */ ;
      while_continue___8: /* CIL Label */ ;
#line 394
      if (! c) {
#line 394
        goto while_break___8;
      }
      {
      {
#line 396
      t = leadz(c);
      }
#line 397
      c &= NotBitPosArray[t];
      }
#line 398
      if (t > 7) {
        {
        {
#line 399
        while (1) {
          while_continue___26: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
#line 399
          node->move = ((t + 8) << 6) | t;
#line 399
          node ++;
#line 399
          goto while_break___9;
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
    while_break___25: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 402
    b = *(a + 1) & RankBit[6];
#line 403
    c = (b << 8) & notblocker;
#line 404
    c = (c << 8) & notblocker;
    {
    {
#line 405
    while (1) {
      while_continue___27: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 405
      if (! c) {
#line 405
        goto while_break___10;
      }
      {
      {
#line 407
      t = leadz(c);
      }
#line 408
      c &= NotBitPosArray[t];
      }
      {
      {
#line 409
      while (1) {
        while_continue___28: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
#line 409
        node->move = ((t + 16) << 6) | t;
#line 409
        node ++;
#line 409
        goto while_break___11;
      }
      while_break___28: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    while_break___27: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 414
  b = board.b[side][4];
#line 415
  if (side == 0) {
#line 415
    if (board.flag & 1) {
#line 415
      if (b & BitPosArray[7]) {
#line 415
        if (! (FromToRay[4][6] & blocker)) {
          {
          {
#line 415
          tmp = SqAtakd(4, 1);
          }
          }
#line 415
          if (! tmp) {
            {
            {
#line 415
            tmp___0 = SqAtakd(5, 1);
            }
            }
#line 415
            if (! tmp___0) {
              {
              {
#line 415
              tmp___1 = SqAtakd(6, 1);
              }
              }
#line 415
              if (! tmp___1) {
                {
                {
#line 419
                while (1) {
                  while_continue___29: /* CIL Label */ ;
                  while_continue___12: /* CIL Label */ ;
#line 419
                  node->move = ((4 << 6) | 6) | 2097152;
#line 419
                  node ++;
#line 419
                  goto while_break___12;
                }
                while_break___29: /* CIL Label */ ;
                }
                while_break___12: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 421
  if (side == 0) {
#line 421
    if (board.flag & 2) {
#line 421
      if (b & BitPosArray[0]) {
#line 421
        if (! (FromToRay[4][1] & blocker)) {
          {
          {
#line 421
          tmp___2 = SqAtakd(4, 1);
          }
          }
#line 421
          if (! tmp___2) {
            {
            {
#line 421
            tmp___3 = SqAtakd(3, 1);
            }
            }
#line 421
            if (! tmp___3) {
              {
              {
#line 421
              tmp___4 = SqAtakd(2, 1);
              }
              }
#line 421
              if (! tmp___4) {
                {
                {
#line 425
                while (1) {
                  while_continue___30: /* CIL Label */ ;
                  while_continue___13: /* CIL Label */ ;
#line 425
                  node->move = ((4 << 6) | 2) | 2097152;
#line 425
                  node ++;
#line 425
                  goto while_break___13;
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 427
  if (side == 1) {
#line 427
    if (board.flag & 4) {
#line 427
      if (b & BitPosArray[63]) {
#line 427
        if (! (FromToRay[60][62] & blocker)) {
          {
          {
#line 427
          tmp___5 = SqAtakd(60, 0);
          }
          }
#line 427
          if (! tmp___5) {
            {
            {
#line 427
            tmp___6 = SqAtakd(61, 0);
            }
            }
#line 427
            if (! tmp___6) {
              {
              {
#line 427
              tmp___7 = SqAtakd(62, 0);
              }
              }
#line 427
              if (! tmp___7) {
                {
                {
#line 431
                while (1) {
                  while_continue___31: /* CIL Label */ ;
                  while_continue___14: /* CIL Label */ ;
#line 431
                  node->move = ((60 << 6) | 62) | 2097152;
#line 431
                  node ++;
#line 431
                  goto while_break___14;
                }
                while_break___31: /* CIL Label */ ;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 433
  if (side == 1) {
#line 433
    if (board.flag & 8) {
#line 433
      if (b & BitPosArray[56]) {
#line 433
        if (! (FromToRay[60][57] & blocker)) {
          {
          {
#line 433
          tmp___8 = SqAtakd(60, 0);
          }
          }
#line 433
          if (! tmp___8) {
            {
            {
#line 433
            tmp___9 = SqAtakd(59, 0);
            }
            }
#line 433
            if (! tmp___9) {
              {
              {
#line 433
              tmp___10 = SqAtakd(58, 0);
              }
              }
#line 433
              if (! tmp___10) {
                {
                {
#line 437
                while (1) {
                  while_continue___32: /* CIL Label */ ;
                  while_continue___15: /* CIL Label */ ;
#line 437
                  node->move = ((60 << 6) | 58) | 2097152;
#line 437
                  node ++;
#line 437
                  goto while_break___15;
                }
                while_break___32: /* CIL Label */ ;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 441
  TreePtr[ply + 1] = node;
#line 442
  GenCnt += (unsigned long )(TreePtr[ply + 1] - TreePtr[ply]);
#line 443
  return;
}
}
#line 446 "/home/khheo/testset/chess/src/genmove.c"
void GenCaptures(int ply ) 
{ 
  int side ;
  int piece ;
  int sq ;
  int t ;
  int ep ;
  BitBoard b ;
  BitBoard c ;
  BitBoard friends ;
  BitBoard notfriends ;
  BitBoard enemy ;
  BitBoard blocker ;
  BitBoard *a ;
  unsigned long long tmp ;
  unsigned long long tmp___0 ;
  unsigned long long tmp___1 ;
  unsigned long long tmp___2 ;

  {
#line 459
  side = board.side;
#line 460
  a = board.b[side];
#line 461
  friends = board.friends[side];
#line 462
  notfriends = ~ friends;
#line 463
  enemy = board.friends[1 ^ side];
#line 464
  blocker = board.blocker;
#line 465
  node = TreePtr[ply + 1];
#line 466
  ep = board.ep;
#line 469
  piece = 2;
  {
  {
#line 469
  while (1) {
    while_continue___48: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 469
    if (! (piece <= 6)) {
#line 469
      goto while_break;
    }
#line 471
    b = *(a + piece);
    {
    {
#line 472
    while (1) {
      while_continue___49: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! b) {
#line 472
        goto while_break___0;
      }
      {
      {
#line 474
      sq = leadz(b);
      }
#line 475
      b &= NotBitPosArray[sq];
      {
#line 476
      BitToMove(sq, MoveArray[piece][sq] & enemy);
      }
      }
    }
    while_break___49: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 469
    piece += 4;
  }
  while_break___48: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  b = *(a + 3);
  {
  {
#line 482
  while (1) {
    while_continue___50: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 482
    if (! b) {
#line 482
      goto while_break___1;
    }
    {
    {
#line 484
    sq = leadz(b);
    }
#line 485
    b &= NotBitPosArray[sq];
#line 486
    c = Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]];
    {
#line 487
    BitToMove(sq, c & enemy);
    }
    }
  }
  while_break___50: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 491
  b = *(a + 4);
  {
  {
#line 492
  while (1) {
    while_continue___51: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 492
    if (! b) {
#line 492
      goto while_break___2;
    }
    {
    {
#line 494
    sq = leadz(b);
    }
#line 495
    b &= NotBitPosArray[sq];
#line 496
    c = Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL];
    {
#line 497
    BitToMove(sq, c & enemy);
    }
    }
  }
  while_break___51: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 501
  b = *(a + 5);
  {
  {
#line 502
  while (1) {
    while_continue___52: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 502
    if (! b) {
#line 502
      goto while_break___3;
    }
    {
    {
#line 504
    sq = leadz(b);
    }
#line 505
    b &= NotBitPosArray[sq];
#line 506
    c = (Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) | (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]);
    {
#line 507
    BitToMove(sq, c & enemy);
    }
    }
  }
  while_break___52: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 511
  if (side == 0) {
#line 513
    b = *(a + 1) & RankBit[6];
#line 514
    c = (b >> 8) & ~ blocker;
    {
    {
#line 515
    while (1) {
      while_continue___53: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 515
      if (! c) {
#line 515
        goto while_break___4;
      }
      {
      {
#line 517
      t = leadz(c);
      }
#line 518
      c &= NotBitPosArray[t];
      }
      {
      {
#line 519
      while (1) {
        while_continue___54: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
        {
        {
#line 519
        while (1) {
          while_continue___55: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 519
          node->move = (((t - 8) << 6) | t) | 20480;
#line 519
          node ++;
#line 519
          goto while_break___6;
        }
        while_break___55: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
        {
#line 519
        while (1) {
          while_continue___56: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 519
          node->move = (((t - 8) << 6) | t) | 8192;
#line 519
          node ++;
#line 519
          goto while_break___7;
        }
        while_break___56: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
        {
#line 519
        while (1) {
          while_continue___57: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
#line 519
          node->move = (((t - 8) << 6) | t) | 16384;
#line 519
          node ++;
#line 519
          goto while_break___8;
        }
        while_break___57: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
        {
#line 519
        while (1) {
          while_continue___58: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
#line 519
          node->move = (((t - 8) << 6) | t) | 12288;
#line 519
          node ++;
#line 519
          goto while_break___9;
        }
        while_break___58: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 519
        goto while_break___5;
      }
      while_break___54: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___53: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 522
    b = *(a + 1) & ~ FileBit[0];
#line 523
    if (ep > -1) {
#line 523
      tmp = (unsigned long long )BitPosArray[ep];
    } else {
#line 523
      tmp = 0ULL;
    }
#line 523
    c = (BitBoard )((unsigned long long )(b >> 7) & ((unsigned long long )board.friends[1 ^ side] | tmp));
    {
    {
#line 524
    while (1) {
      while_continue___59: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 524
      if (! c) {
#line 524
        goto while_break___10;
      }
      {
      {
#line 526
      t = leadz(c);
      }
#line 527
      c &= NotBitPosArray[t];
      }
#line 528
      if (t >= 56) {
        {
        {
#line 530
        while (1) {
          while_continue___60: /* CIL Label */ ;
          while_continue___11: /* CIL Label */ ;
          {
          {
#line 530
          while (1) {
            while_continue___61: /* CIL Label */ ;
            while_continue___12: /* CIL Label */ ;
#line 530
            node->move = (((t - 7) << 6) | t) | 20480;
#line 530
            node ++;
#line 530
            goto while_break___12;
          }
          while_break___61: /* CIL Label */ ;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
          {
#line 530
          while (1) {
            while_continue___62: /* CIL Label */ ;
            while_continue___13: /* CIL Label */ ;
#line 530
            node->move = (((t - 7) << 6) | t) | 8192;
#line 530
            node ++;
#line 530
            goto while_break___13;
          }
          while_break___62: /* CIL Label */ ;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
          {
#line 530
          while (1) {
            while_continue___63: /* CIL Label */ ;
            while_continue___14: /* CIL Label */ ;
#line 530
            node->move = (((t - 7) << 6) | t) | 16384;
#line 530
            node ++;
#line 530
            goto while_break___14;
          }
          while_break___63: /* CIL Label */ ;
          }
          while_break___14: /* CIL Label */ ;
          }
          {
          {
#line 530
          while (1) {
            while_continue___64: /* CIL Label */ ;
            while_continue___15: /* CIL Label */ ;
#line 530
            node->move = (((t - 7) << 6) | t) | 12288;
#line 530
            node ++;
#line 530
            goto while_break___15;
          }
          while_break___64: /* CIL Label */ ;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 530
          goto while_break___11;
        }
        while_break___60: /* CIL Label */ ;
        }
        while_break___11: /* CIL Label */ ;
        }
      } else
#line 532
      if (ep == t) {
        {
        {
#line 534
        while (1) {
          while_continue___65: /* CIL Label */ ;
          while_continue___16: /* CIL Label */ ;
#line 534
          node->move = (((t - 7) << 6) | t) | 4194304;
#line 534
          node ++;
#line 534
          goto while_break___16;
        }
        while_break___65: /* CIL Label */ ;
        }
        while_break___16: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 538
        while (1) {
          while_continue___66: /* CIL Label */ ;
          while_continue___17: /* CIL Label */ ;
#line 538
          node->move = ((t - 7) << 6) | t;
#line 538
          node ++;
#line 538
          goto while_break___17;
        }
        while_break___66: /* CIL Label */ ;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
    }
    while_break___59: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 542
    b = *(a + 1) & ~ FileBit[7];
#line 543
    if (ep > -1) {
#line 543
      tmp___0 = (unsigned long long )BitPosArray[ep];
    } else {
#line 543
      tmp___0 = 0ULL;
    }
#line 543
    c = (BitBoard )((unsigned long long )(b >> 9) & ((unsigned long long )board.friends[1 ^ side] | tmp___0));
    {
    {
#line 544
    while (1) {
      while_continue___67: /* CIL Label */ ;
      while_continue___18: /* CIL Label */ ;
#line 544
      if (! c) {
#line 544
        goto while_break___18;
      }
      {
      {
#line 546
      t = leadz(c);
      }
#line 547
      c &= NotBitPosArray[t];
      }
#line 548
      if (t >= 56) {
        {
        {
#line 550
        while (1) {
          while_continue___68: /* CIL Label */ ;
          while_continue___19: /* CIL Label */ ;
          {
          {
#line 550
          while (1) {
            while_continue___69: /* CIL Label */ ;
            while_continue___20: /* CIL Label */ ;
#line 550
            node->move = (((t - 9) << 6) | t) | 20480;
#line 550
            node ++;
#line 550
            goto while_break___20;
          }
          while_break___69: /* CIL Label */ ;
          }
          while_break___20: /* CIL Label */ ;
          }
          {
          {
#line 550
          while (1) {
            while_continue___70: /* CIL Label */ ;
            while_continue___21: /* CIL Label */ ;
#line 550
            node->move = (((t - 9) << 6) | t) | 8192;
#line 550
            node ++;
#line 550
            goto while_break___21;
          }
          while_break___70: /* CIL Label */ ;
          }
          while_break___21: /* CIL Label */ ;
          }
          {
          {
#line 550
          while (1) {
            while_continue___71: /* CIL Label */ ;
            while_continue___22: /* CIL Label */ ;
#line 550
            node->move = (((t - 9) << 6) | t) | 16384;
#line 550
            node ++;
#line 550
            goto while_break___22;
          }
          while_break___71: /* CIL Label */ ;
          }
          while_break___22: /* CIL Label */ ;
          }
          {
          {
#line 550
          while (1) {
            while_continue___72: /* CIL Label */ ;
            while_continue___23: /* CIL Label */ ;
#line 550
            node->move = (((t - 9) << 6) | t) | 12288;
#line 550
            node ++;
#line 550
            goto while_break___23;
          }
          while_break___72: /* CIL Label */ ;
          }
          while_break___23: /* CIL Label */ ;
          }
#line 550
          goto while_break___19;
        }
        while_break___68: /* CIL Label */ ;
        }
        while_break___19: /* CIL Label */ ;
        }
      } else
#line 552
      if (ep == t) {
        {
        {
#line 554
        while (1) {
          while_continue___73: /* CIL Label */ ;
          while_continue___24: /* CIL Label */ ;
#line 554
          node->move = (((t - 9) << 6) | t) | 4194304;
#line 554
          node ++;
#line 554
          goto while_break___24;
        }
        while_break___73: /* CIL Label */ ;
        }
        while_break___24: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 558
        while (1) {
          while_continue___74: /* CIL Label */ ;
          while_continue___25: /* CIL Label */ ;
#line 558
          node->move = ((t - 9) << 6) | t;
#line 558
          node ++;
#line 558
          goto while_break___25;
        }
        while_break___74: /* CIL Label */ ;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
    }
    while_break___67: /* CIL Label */ ;
    }
    while_break___18: /* CIL Label */ ;
    }
  }
#line 564
  if (side == 1) {
#line 566
    b = *(a + 1) & RankBit[1];
#line 567
    c = (b << 8) & ~ blocker;
    {
    {
#line 568
    while (1) {
      while_continue___75: /* CIL Label */ ;
      while_continue___26: /* CIL Label */ ;
#line 568
      if (! c) {
#line 568
        goto while_break___26;
      }
      {
      {
#line 570
      t = leadz(c);
      }
#line 571
      c &= NotBitPosArray[t];
      }
      {
      {
#line 572
      while (1) {
        while_continue___76: /* CIL Label */ ;
        while_continue___27: /* CIL Label */ ;
        {
        {
#line 572
        while (1) {
          while_continue___77: /* CIL Label */ ;
          while_continue___28: /* CIL Label */ ;
#line 572
          node->move = (((t + 8) << 6) | t) | 20480;
#line 572
          node ++;
#line 572
          goto while_break___28;
        }
        while_break___77: /* CIL Label */ ;
        }
        while_break___28: /* CIL Label */ ;
        }
        {
        {
#line 572
        while (1) {
          while_continue___78: /* CIL Label */ ;
          while_continue___29: /* CIL Label */ ;
#line 572
          node->move = (((t + 8) << 6) | t) | 8192;
#line 572
          node ++;
#line 572
          goto while_break___29;
        }
        while_break___78: /* CIL Label */ ;
        }
        while_break___29: /* CIL Label */ ;
        }
        {
        {
#line 572
        while (1) {
          while_continue___79: /* CIL Label */ ;
          while_continue___30: /* CIL Label */ ;
#line 572
          node->move = (((t + 8) << 6) | t) | 16384;
#line 572
          node ++;
#line 572
          goto while_break___30;
        }
        while_break___79: /* CIL Label */ ;
        }
        while_break___30: /* CIL Label */ ;
        }
        {
        {
#line 572
        while (1) {
          while_continue___80: /* CIL Label */ ;
          while_continue___31: /* CIL Label */ ;
#line 572
          node->move = (((t + 8) << 6) | t) | 12288;
#line 572
          node ++;
#line 572
          goto while_break___31;
        }
        while_break___80: /* CIL Label */ ;
        }
        while_break___31: /* CIL Label */ ;
        }
#line 572
        goto while_break___27;
      }
      while_break___76: /* CIL Label */ ;
      }
      while_break___27: /* CIL Label */ ;
      }
    }
    while_break___75: /* CIL Label */ ;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 575
    b = *(a + 1) & ~ FileBit[7];
#line 576
    if (ep > -1) {
#line 576
      tmp___1 = (unsigned long long )BitPosArray[ep];
    } else {
#line 576
      tmp___1 = 0ULL;
    }
#line 576
    c = (BitBoard )((unsigned long long )(b << 7) & ((unsigned long long )board.friends[1 ^ side] | tmp___1));
    {
    {
#line 577
    while (1) {
      while_continue___81: /* CIL Label */ ;
      while_continue___32: /* CIL Label */ ;
#line 577
      if (! c) {
#line 577
        goto while_break___32;
      }
      {
      {
#line 579
      t = leadz(c);
      }
#line 580
      c &= NotBitPosArray[t];
      }
#line 581
      if (t <= 7) {
        {
        {
#line 583
        while (1) {
          while_continue___82: /* CIL Label */ ;
          while_continue___33: /* CIL Label */ ;
          {
          {
#line 583
          while (1) {
            while_continue___83: /* CIL Label */ ;
            while_continue___34: /* CIL Label */ ;
#line 583
            node->move = (((t + 7) << 6) | t) | 20480;
#line 583
            node ++;
#line 583
            goto while_break___34;
          }
          while_break___83: /* CIL Label */ ;
          }
          while_break___34: /* CIL Label */ ;
          }
          {
          {
#line 583
          while (1) {
            while_continue___84: /* CIL Label */ ;
            while_continue___35: /* CIL Label */ ;
#line 583
            node->move = (((t + 7) << 6) | t) | 8192;
#line 583
            node ++;
#line 583
            goto while_break___35;
          }
          while_break___84: /* CIL Label */ ;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
          {
#line 583
          while (1) {
            while_continue___85: /* CIL Label */ ;
            while_continue___36: /* CIL Label */ ;
#line 583
            node->move = (((t + 7) << 6) | t) | 16384;
#line 583
            node ++;
#line 583
            goto while_break___36;
          }
          while_break___85: /* CIL Label */ ;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
          {
#line 583
          while (1) {
            while_continue___86: /* CIL Label */ ;
            while_continue___37: /* CIL Label */ ;
#line 583
            node->move = (((t + 7) << 6) | t) | 12288;
#line 583
            node ++;
#line 583
            goto while_break___37;
          }
          while_break___86: /* CIL Label */ ;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 583
          goto while_break___33;
        }
        while_break___82: /* CIL Label */ ;
        }
        while_break___33: /* CIL Label */ ;
        }
      } else
#line 585
      if (ep == t) {
        {
        {
#line 587
        while (1) {
          while_continue___87: /* CIL Label */ ;
          while_continue___38: /* CIL Label */ ;
#line 587
          node->move = (((t + 7) << 6) | t) | 4194304;
#line 587
          node ++;
#line 587
          goto while_break___38;
        }
        while_break___87: /* CIL Label */ ;
        }
        while_break___38: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 591
        while (1) {
          while_continue___88: /* CIL Label */ ;
          while_continue___39: /* CIL Label */ ;
#line 591
          node->move = ((t + 7) << 6) | t;
#line 591
          node ++;
#line 591
          goto while_break___39;
        }
        while_break___88: /* CIL Label */ ;
        }
        while_break___39: /* CIL Label */ ;
        }
      }
    }
    while_break___81: /* CIL Label */ ;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 595
    b = *(a + 1) & ~ FileBit[0];
#line 596
    if (ep > -1) {
#line 596
      tmp___2 = (unsigned long long )BitPosArray[ep];
    } else {
#line 596
      tmp___2 = 0ULL;
    }
#line 596
    c = (BitBoard )((unsigned long long )(b << 9) & ((unsigned long long )board.friends[1 ^ side] | tmp___2));
    {
    {
#line 597
    while (1) {
      while_continue___89: /* CIL Label */ ;
      while_continue___40: /* CIL Label */ ;
#line 597
      if (! c) {
#line 597
        goto while_break___40;
      }
      {
      {
#line 599
      t = leadz(c);
      }
#line 600
      c &= NotBitPosArray[t];
      }
#line 601
      if (t <= 7) {
        {
        {
#line 603
        while (1) {
          while_continue___90: /* CIL Label */ ;
          while_continue___41: /* CIL Label */ ;
          {
          {
#line 603
          while (1) {
            while_continue___91: /* CIL Label */ ;
            while_continue___42: /* CIL Label */ ;
#line 603
            node->move = (((t + 9) << 6) | t) | 20480;
#line 603
            node ++;
#line 603
            goto while_break___42;
          }
          while_break___91: /* CIL Label */ ;
          }
          while_break___42: /* CIL Label */ ;
          }
          {
          {
#line 603
          while (1) {
            while_continue___92: /* CIL Label */ ;
            while_continue___43: /* CIL Label */ ;
#line 603
            node->move = (((t + 9) << 6) | t) | 8192;
#line 603
            node ++;
#line 603
            goto while_break___43;
          }
          while_break___92: /* CIL Label */ ;
          }
          while_break___43: /* CIL Label */ ;
          }
          {
          {
#line 603
          while (1) {
            while_continue___93: /* CIL Label */ ;
            while_continue___44: /* CIL Label */ ;
#line 603
            node->move = (((t + 9) << 6) | t) | 16384;
#line 603
            node ++;
#line 603
            goto while_break___44;
          }
          while_break___93: /* CIL Label */ ;
          }
          while_break___44: /* CIL Label */ ;
          }
          {
          {
#line 603
          while (1) {
            while_continue___94: /* CIL Label */ ;
            while_continue___45: /* CIL Label */ ;
#line 603
            node->move = (((t + 9) << 6) | t) | 12288;
#line 603
            node ++;
#line 603
            goto while_break___45;
          }
          while_break___94: /* CIL Label */ ;
          }
          while_break___45: /* CIL Label */ ;
          }
#line 603
          goto while_break___41;
        }
        while_break___90: /* CIL Label */ ;
        }
        while_break___41: /* CIL Label */ ;
        }
      } else
#line 605
      if (ep == t) {
        {
        {
#line 607
        while (1) {
          while_continue___95: /* CIL Label */ ;
          while_continue___46: /* CIL Label */ ;
#line 607
          node->move = (((t + 9) << 6) | t) | 4194304;
#line 607
          node ++;
#line 607
          goto while_break___46;
        }
        while_break___95: /* CIL Label */ ;
        }
        while_break___46: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 611
        while (1) {
          while_continue___96: /* CIL Label */ ;
          while_continue___47: /* CIL Label */ ;
#line 611
          node->move = ((t + 9) << 6) | t;
#line 611
          node ++;
#line 611
          goto while_break___47;
        }
        while_break___96: /* CIL Label */ ;
        }
        while_break___47: /* CIL Label */ ;
        }
      }
    }
    while_break___89: /* CIL Label */ ;
    }
    while_break___40: /* CIL Label */ ;
    }
  }
#line 618
  TreePtr[ply + 1] = node;
#line 619
  GenCnt += (unsigned long )(TreePtr[ply + 1] - TreePtr[ply]);
#line 620
  return;
}
}
#line 623 "/home/khheo/testset/chess/src/genmove.c"
void GenCheckEscapes(int ply ) 
{ 
  int side ;
  int xside ;
  int kingsq ;
  int chksq ;
  int sq ;
  int sq1 ;
  int epsq ;
  int dir___0 ;
  BitBoard checkers ;
  BitBoard b ;
  BitBoard c ;
  BitBoard p___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 637
  side = board.side;
#line 638
  xside = 1 ^ side;
#line 640
  node = TreePtr[ply + 1];
#line 641
  kingsq = board.king[side];
  {
#line 642
  checkers = AttackTo(kingsq, xside);
  }
#line 643
  p___1 = board.b[side][1];
  {
#line 645
  tmp___3 = nbits(checkers);
  }
  }
#line 645
  if (tmp___3 == 1) {
    {
    {
#line 648
    chksq = leadz(checkers);
    }
    {
#line 649
    b = AttackTo(chksq, side);
    }
#line 650
    b &= ~ board.b[side][6];
    }
    {
    {
#line 651
    while (1) {
      while_continue___19: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 651
      if (! b) {
#line 651
        goto while_break;
      }
      {
      {
#line 653
      sq = leadz(b);
      }
#line 654
      b &= NotBitPosArray[sq];
      {
#line 655
      tmp = PinnedOnKing(sq, side);
      }
      }
#line 655
      if (! tmp) {
#line 657
        if (cboard[sq] == 1) {
#line 657
          if (chksq <= 7) {
#line 657
            goto _L___0;
          } else
#line 657
          if (chksq >= 56) {
            _L___0: /* CIL Label */ 
            {
            {
#line 659
            while (1) {
              while_continue___20: /* CIL Label */ ;
              while_continue___0: /* CIL Label */ ;
              {
              {
#line 659
              while (1) {
                while_continue___21: /* CIL Label */ ;
                while_continue___1: /* CIL Label */ ;
#line 659
                node->move = ((sq << 6) | chksq) | 20480;
#line 659
                node ++;
#line 659
                goto while_break___1;
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
              {
#line 659
              while (1) {
                while_continue___22: /* CIL Label */ ;
                while_continue___2: /* CIL Label */ ;
#line 659
                node->move = ((sq << 6) | chksq) | 8192;
#line 659
                node ++;
#line 659
                goto while_break___2;
              }
              while_break___22: /* CIL Label */ ;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
              {
#line 659
              while (1) {
                while_continue___23: /* CIL Label */ ;
                while_continue___3: /* CIL Label */ ;
#line 659
                node->move = ((sq << 6) | chksq) | 16384;
#line 659
                node ++;
#line 659
                goto while_break___3;
              }
              while_break___23: /* CIL Label */ ;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
              {
#line 659
              while (1) {
                while_continue___24: /* CIL Label */ ;
                while_continue___4: /* CIL Label */ ;
#line 659
                node->move = ((sq << 6) | chksq) | 12288;
#line 659
                node ++;
#line 659
                goto while_break___4;
              }
              while_break___24: /* CIL Label */ ;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 659
              goto while_break___0;
            }
            while_break___20: /* CIL Label */ ;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
#line 657
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
          {
#line 662
          while (1) {
            while_continue___25: /* CIL Label */ ;
            while_continue___5: /* CIL Label */ ;
#line 662
            node->move = (sq << 6) | chksq;
#line 662
            node ++;
#line 662
            goto while_break___5;
          }
          while_break___25: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 667
    if (board.ep > -1) {
#line 669
      epsq = board.ep;
#line 670
      if (side == 0) {
#line 670
        tmp___1 = -8;
      } else {
#line 670
        tmp___1 = 8;
      }
#line 670
      if (epsq + tmp___1 == chksq) {
#line 672
        b = MoveArray[ptype[1 ^ side]][epsq] & p___1;
        {
        {
#line 673
        while (1) {
          while_continue___26: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 673
          if (! b) {
#line 673
            goto while_break___6;
          }
          {
          {
#line 675
          sq = leadz(b);
          }
#line 676
          b &= NotBitPosArray[sq];
          {
#line 677
          tmp___0 = PinnedOnKing(sq, side);
          }
          }
#line 677
          if (! tmp___0) {
            {
            {
#line 678
            while (1) {
              while_continue___27: /* CIL Label */ ;
              while_continue___7: /* CIL Label */ ;
#line 678
              node->move = ((sq << 6) | epsq) | 4194304;
#line 678
              node ++;
#line 678
              goto while_break___7;
            }
            while_break___27: /* CIL Label */ ;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
#line 684
    if (slider[cboard[chksq]]) {
#line 686
      c = FromToRay[kingsq][chksq] & NotBitPosArray[chksq];
      {
      {
#line 687
      while (1) {
        while_continue___28: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 687
        if (! c) {
#line 687
          goto while_break___8;
        }
        {
        {
#line 689
        sq = leadz(c);
        }
#line 690
        c &= NotBitPosArray[sq];
        {
#line 691
        b = AttackTo(sq, side);
        }
#line 692
        b &= ~ (board.b[side][6] | p___1);
        }
#line 695
        if (side == 0) {
#line 695
          if (sq > 15) {
#line 697
            if (BitPosArray[sq - 8] & p___1) {
#line 698
              b |= BitPosArray[sq - 8];
            }
#line 699
            if (sq >> 3 == 3) {
#line 699
              if (cboard[sq - 8] == 0) {
#line 699
                if (BitPosArray[sq - 16] & p___1) {
#line 701
                  b |= BitPosArray[sq - 16];
                }
              }
            }
          }
        }
#line 703
        if (side == 1) {
#line 703
          if (sq < 55) {
#line 705
            if (BitPosArray[sq + 8] & p___1) {
#line 706
              b |= BitPosArray[sq + 8];
            }
#line 707
            if (sq >> 3 == 4) {
#line 707
              if (cboard[sq + 8] == 0) {
#line 707
                if (BitPosArray[sq + 16] & p___1) {
#line 709
                  b |= BitPosArray[sq + 16];
                }
              }
            }
          }
        }
        {
        {
#line 711
        while (1) {
          while_continue___29: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
#line 711
          if (! b) {
#line 711
            goto while_break___9;
          }
          {
          {
#line 713
          sq1 = leadz(b);
          }
#line 714
          b &= NotBitPosArray[sq1];
          {
#line 715
          tmp___2 = PinnedOnKing(sq1, side);
          }
          }
#line 715
          if (! tmp___2) {
#line 717
            if (cboard[sq1] == 1) {
#line 717
              if (sq > 55) {
#line 717
                goto _L___2;
              } else
#line 717
              if (sq < 8) {
                _L___2: /* CIL Label */ 
                {
                {
#line 719
                while (1) {
                  while_continue___30: /* CIL Label */ ;
                  while_continue___10: /* CIL Label */ ;
                  {
                  {
#line 719
                  while (1) {
                    while_continue___31: /* CIL Label */ ;
                    while_continue___11: /* CIL Label */ ;
#line 719
                    node->move = ((sq1 << 6) | sq) | 20480;
#line 719
                    node ++;
#line 719
                    goto while_break___11;
                  }
                  while_break___31: /* CIL Label */ ;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                  {
                  {
#line 719
                  while (1) {
                    while_continue___32: /* CIL Label */ ;
                    while_continue___12: /* CIL Label */ ;
#line 719
                    node->move = ((sq1 << 6) | sq) | 8192;
#line 719
                    node ++;
#line 719
                    goto while_break___12;
                  }
                  while_break___32: /* CIL Label */ ;
                  }
                  while_break___12: /* CIL Label */ ;
                  }
                  {
                  {
#line 719
                  while (1) {
                    while_continue___33: /* CIL Label */ ;
                    while_continue___13: /* CIL Label */ ;
#line 719
                    node->move = ((sq1 << 6) | sq) | 16384;
#line 719
                    node ++;
#line 719
                    goto while_break___13;
                  }
                  while_break___33: /* CIL Label */ ;
                  }
                  while_break___13: /* CIL Label */ ;
                  }
                  {
                  {
#line 719
                  while (1) {
                    while_continue___34: /* CIL Label */ ;
                    while_continue___14: /* CIL Label */ ;
#line 719
                    node->move = ((sq1 << 6) | sq) | 12288;
#line 719
                    node ++;
#line 719
                    goto while_break___14;
                  }
                  while_break___34: /* CIL Label */ ;
                  }
                  while_break___14: /* CIL Label */ ;
                  }
#line 719
                  goto while_break___10;
                }
                while_break___30: /* CIL Label */ ;
                }
                while_break___10: /* CIL Label */ ;
                }
              } else {
#line 717
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
              {
#line 722
              while (1) {
                while_continue___35: /* CIL Label */ ;
                while_continue___15: /* CIL Label */ ;
#line 722
                node->move = (sq1 << 6) | sq;
#line 722
                node ++;
#line 722
                goto while_break___15;
              }
              while_break___35: /* CIL Label */ ;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        while_break___29: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      while_break___28: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
#line 730
  p___1 = MoveArray[6][kingsq] & ~ board.friends[side];
  {
  {
#line 731
  while (1) {
    while_continue___36: /* CIL Label */ ;
    while_continue___16: /* CIL Label */ ;
#line 731
    if (! checkers) {
#line 731
      goto while_break___16;
    }
    {
    {
#line 733
    chksq = leadz(checkers);
    }
#line 734
    checkers &= NotBitPosArray[chksq];
#line 735
    dir___0 = directions[chksq][kingsq];
    }
#line 736
    if (slider[cboard[chksq]]) {
#line 737
      p___1 &= ~ Ray[chksq][dir___0];
    }
  }
  while_break___36: /* CIL Label */ ;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
  {
#line 739
  while (1) {
    while_continue___37: /* CIL Label */ ;
    while_continue___17: /* CIL Label */ ;
#line 739
    if (! p___1) {
#line 739
      goto while_break___17;
    }
    {
    {
#line 741
    sq = leadz(p___1);
    }
#line 742
    p___1 &= NotBitPosArray[sq];
    {
#line 743
    tmp___4 = SqAtakd(sq, xside);
    }
    }
#line 743
    if (! tmp___4) {
      {
      {
#line 744
      while (1) {
        while_continue___38: /* CIL Label */ ;
        while_continue___18: /* CIL Label */ ;
#line 744
        node->move = (kingsq << 6) | sq;
#line 744
        node ++;
#line 744
        goto while_break___18;
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
  }
  while_break___37: /* CIL Label */ ;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 748
  TreePtr[ply + 1] = node;
#line 749
  GenCnt += (unsigned long )(TreePtr[ply + 1] - TreePtr[ply]);
#line 750
  return;
}
}
#line 754 "/home/khheo/testset/chess/src/genmove.c"
void FilterIllegalMoves(int ply ) 
{ 
  leaf *p___1 ;
  int side ;
  int xside ;
  int check ;
  int sq ;

  {
#line 765
  side = board.side;
#line 766
  xside = 1 ^ side;
#line 767
  sq = board.king[side];
#line 768
  p___1 = TreePtr[ply];
  {
  {
#line 768
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 768
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[ply + 1])) {
#line 768
      goto while_break;
    }
    {
    {
#line 770
    MakeMove(side, & p___1->move);
    }
    }
#line 771
    if (cboard[p___1->move & 63] != 6) {
      {
      {
#line 772
      check = SqAtakd(sq, xside);
      }
      }
    } else {
      {
      {
#line 774
      check = SqAtakd(p___1->move & 63, xside);
      }
      }
    }
    {
    {
#line 775
    UnmakeMove(xside, & p___1->move);
    }
    }
#line 777
    if (check) {
#line 779
      (TreePtr[ply + 1]) --;
#line 780
      *p___1 = *(TreePtr[ply + 1]);
#line 781
      p___1 --;
#line 782
      GenCnt --;
    }
#line 768
    p___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  return;
}
}
#line 522 "/home/khheo/testset/chess/src/common.h"
void GenAtaks(void) ;
#line 526
BitBoard AttackXFrom(int sq , int side ) ;
#line 528
void FindPins(BitBoard *pin ) ;
#line 574
int ScoreP(int side ) ;
#line 575
int ScoreN(int side ) ;
#line 576
int ScoreB(int side ) ;
#line 577
int ScoreR(int side ) ;
#line 578
int ScoreQ(int side ) ;
#line 579
int ScoreK(int side ) ;
#line 580
int ScoreDev(int side ) ;
#line 39 "/home/khheo/testset/chess/src/eval.c"
int LoneKing(int side , int loser ) ;
#line 40
int ScoreKBNK(int side , int loser ) ;
#line 41
int KPK(int side ) ;
#line 42
int BishopTrapped(int side ) ;
#line 43
int DoubleQR7(int side ) ;
#line 45 "/home/khheo/testset/chess/src/eval.c"
BitBoard passed[2]  ;
#line 46 "/home/khheo/testset/chess/src/eval.c"
BitBoard weaked[2]  ;
#line 48 "/home/khheo/testset/chess/src/eval.c"
static int PawnSq[2][64]  = { {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            5,        5,        5,        -10, 
            -10,        5,        5,        5, 
            -2,        -2,        -2,        6, 
            6,        -2,        -2,        -2, 
            0,        0,        0,        25, 
            25,        0,        0,        0, 
            2,        2,        12,        16, 
            16,        12,        2,        2, 
            4,        8,        12,        16, 
            16,        12,        4,        4, 
            4,        8,        12,        16, 
            16,        12,        4,        4, 
            0,        0,        0,        0, 
            0,        0,        0,        0}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            4,        8,        12,        16, 
            16,        12,        4,        4, 
            4,        8,        12,        16, 
            16,        12,        4,        4, 
            2,        2,        12,        16, 
            16,        12,        2,        2, 
            0,        0,        0,        25, 
            25,        0,        0,        0, 
            -2,        -2,        -2,        6, 
            6,        -2,        -2,        -2, 
            5,        5,        5,        -10, 
            -10,        5,        5,        5, 
            0,        0,        0,        0, 
            0,        0,        0,        0}};
#line 68 "/home/khheo/testset/chess/src/eval.c"
static int const   Passed[2][8]  = { {        (int const   )0,        (int const   )48,        (int const   )48,        (int const   )120, 
            (int const   )144,        (int const   )192,        (int const   )240,        (int const   )0}, 
   {        (int const   )0,        (int const   )240,        (int const   )192,        (int const   )144, 
            (int const   )120,        (int const   )48,        (int const   )48,        (int const   )0}};
#line 71 "/home/khheo/testset/chess/src/eval.c"
static int const   isolani_normal[8]  = 
#line 71
  {      (int const   )-8,      (int const   )-10,      (int const   )-12,      (int const   )-14, 
        (int const   )-14,      (int const   )-12,      (int const   )-10,      (int const   )-8};
#line 75 "/home/khheo/testset/chess/src/eval.c"
static int const   isolani_weaker[8]  = 
#line 75
  {      (int const   )-22,      (int const   )-24,      (int const   )-26,      (int const   )-28, 
        (int const   )-28,      (int const   )-26,      (int const   )-24,      (int const   )-22};
#line 79 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   d2e2[2]  = {      (BitBoard const   )6755399441055744ULL,      (BitBoard const   )6144ULL};
#line 81 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   brank7[2]  = {      (BitBoard const   )65280ULL,      (BitBoard const   )71776119061217280ULL};
#line 83 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   brank8[2]  = {      (BitBoard const   )255ULL,      (BitBoard const   )0xff00000000000000ULL};
#line 85 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   brank67[2]  = {      (BitBoard const   )16776960ULL,      (BitBoard const   )72056494526300160ULL};
#line 87 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   brank58[2]  = {      (BitBoard const   )4294967295ULL,      (BitBoard const   )0xffffffff00000000ULL};
#line 90 "/home/khheo/testset/chess/src/eval.c"
int ScoreP(int side ) 
{ 
  int xside ;
  int s___1 ;
  int sq ;
  int i ;
  int i1 ;
  int n1 ;
  int n2 ;
  int backward ;
  int nfile[8] ;
  int EnemyKing ;
  BitBoard c ;
  BitBoard t ;
  BitBoard p___1 ;
  BitBoard blocker ;
  BitBoard *e ;
  PawnSlot *ptable ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp22 ;

  {
#line 117
  if ((unsigned long long )board.b[side][1] == 0ULL) {
#line 118
    return (0);
  }
#line 119
  xside = 1 ^ side;
#line 120
  EnemyKing = board.king[xside];
#line 121
  p___1 = board.b[xside][1];
#line 122
  t = board.b[side][1];
#line 122
  c = t;
#line 123
  ptable = PawnTab[side] + (PawnHashKey & PHashMask);
#line 124
  TotalPawnHashCnt ++;
#line 125
  if (ptable->phase == phase) {
#line 125
    if ((HashType )ptable->pkey == PawnHashKey >> 32) {
#line 127
      GoodPawnHashCnt ++;
#line 128
      s___1 = ptable->score;
#line 129
      passed[side] = ptable->passed;
#line 130
      weaked[side] = ptable->weaked;
#line 131
      goto phase2;
    }
  }
  {
#line 134
  s___1 = 0;
#line 135
  passed[side] = (BitBoard )0ULL;
#line 136
  weaked[side] = (BitBoard )0ULL;
  {
#line 137
  memset((void *)(nfile), 0, sizeof(nfile));
  }
  }
  {
  {
#line 138
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 138
    if (! t) {
#line 138
      goto while_break;
    }
    {
    {
#line 140
    sq = leadz(t);
    }
#line 141
    t &= NotBitPosArray[sq];
#line 142
    s___1 += PawnSq[side][sq];
    }
#line 145
    if ((unsigned long long )(p___1 & PassedPawnMask[side][sq]) == 0ULL) {
#line 147
      if (side == 0) {
#line 147
        if ((FromToRay[sq][sq | 56] & c) == 0UL) {
#line 150
          passed[side] |= BitPosArray[sq];
#line 151
          s___1 += (int )((Passed[side][sq >> 3] * (int const   )phase) / 12);
        } else {
#line 147
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 147
      if (side == 1) {
#line 147
        if ((FromToRay[sq][sq & 7] & c) == 0UL) {
#line 150
          passed[side] |= BitPosArray[sq];
#line 151
          s___1 += (int )((Passed[side][sq >> 3] * (int const   )phase) / 12);
        }
      }
    }
#line 156
    backward = 0;
#line 158
    if (side == 0) {
#line 159
      i = sq + 8;
    } else {
#line 161
      i = sq - 8;
    }
#line 163
    if (! ((PassedPawnMask[xside][i] & ~ FileBit[sq & 7]) & c)) {
#line 163
      if (cboard[i] != 1) {
        {
        {
#line 166
        n1 = nbits(c & MoveArray[ptype[xside]][i]);
        }
        {
#line 167
        n2 = nbits(p___1 & MoveArray[ptype[side]][i]);
        }
        }
#line 168
        if (n1 < n2) {
#line 169
          backward = 1;
        }
      }
    }
#line 171
    if (! backward) {
#line 171
      if (BitPosArray[sq] & (unsigned long )brank7[xside]) {
#line 173
        i1 = 1;
#line 174
        if (side == 0) {
#line 174
          tmp = 8;
        } else {
#line 174
          tmp = -8;
        }
#line 174
        i += tmp;
#line 175
        if (! ((PassedPawnMask[xside][i] & ~ FileBit[i1 & 7]) & c)) {
          {
          {
#line 177
          n1 = nbits(c & MoveArray[ptype[xside]][i]);
          }
          {
#line 178
          n2 = nbits(p___1 & MoveArray[ptype[side]][i]);
          }
          }
#line 179
          if (n1 < n2) {
#line 180
            backward = 1;
          }
        }
      }
    }
#line 183
    if (backward) {
#line 185
      weaked[side] |= BitPosArray[sq];
#line 186
      s___1 += - (8 + phase);
    }
#line 190
    if (MoveArray[ptype[side]][sq] & p___1) {
#line 190
      if (MoveArray[ptype[side]][sq] & c) {
#line 191
        s___1 += -18;
      }
    }
#line 194
    (nfile[sq & 7]) ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  i = 0;
  {
  {
#line 197
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 197
    if (! (i <= 7)) {
#line 197
      goto while_break___0;
    }
#line 200
    if (nfile[i] > 1) {
#line 201
      s___1 += - (8 + phase);
    }
#line 204
    if (nfile[i]) {
#line 204
      if (! (c & IsolaniMask[i])) {
#line 207
        if (! (FileBit[i] & board.b[xside][1])) {
#line 208
          s___1 += (int )(isolani_weaker[i] * (int const   )nfile[i]);
        } else {
#line 210
          s___1 += (int )(isolani_normal[i] * (int const   )nfile[i]);
        }
#line 211
        weaked[side] |= c & FileBit[i];
      }
    }
#line 197
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  if (computerplays == side) {
    {
    {
#line 219
    tmp___0 = nbits(board.b[computerplays][1]);
    }
    }
#line 219
    if (tmp___0 == 8) {
#line 220
      s___1 += -10;
    }
    {
    {
#line 223
    tmp___1 = nbits(stonewall[xside] & board.b[xside][1]);
    }
    }
#line 223
    if (tmp___1 == 3) {
#line 224
      s___1 += -10;
    }
#line 227
    n = 0;
#line 228
    if (side == 0) {
      {
      {
#line 229
      n = nbits(((c >> 8) & board.b[xside][1]) & ((rings[0] | rings[1]) | rings[2]));
      }
      }
    } else {
      {
      {
#line 232
      n = nbits(((c << 8) & board.b[xside][1]) & ((rings[0] | rings[1]) | rings[2]));
      }
      }
    }
#line 234
    if (n > 1) {
#line 235
      s___1 += n * -10;
    }
  }
#line 240
  ptable->pkey = (KeyType )(PawnHashKey >> 32);
#line 241
  ptable->passed = passed[side];
#line 242
  ptable->weaked = weaked[side];
#line 243
  ptable->score = s___1;
#line 244
  ptable->phase = phase;
  phase2: 
#line 256
  c = board.b[side][1];
#line 257
  sq = board.king[xside];
#line 258
  if (side == 0) {
#line 258
    if (board.b[side][5]) {
#line 258
      if ((BitPosArray[42] | BitPosArray[45]) & c) {
#line 261
        if (c & BitPosArray[45]) {
#line 261
          if (sq > 47) {
#line 261
            if (distance[sq][54] == 1) {
#line 262
              s___1 += 40;
            }
          }
        }
#line 263
        if (c & BitPosArray[42]) {
#line 263
          if (sq > 47) {
#line 263
            if (distance[sq][49] == 1) {
#line 264
              s___1 += 40;
            }
          }
        }
      } else {
#line 258
        goto _L___1;
      }
    } else {
#line 258
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 266
  if (side == 1) {
#line 266
    if (board.b[side][5]) {
#line 266
      if ((BitPosArray[18] | BitPosArray[21]) & c) {
#line 269
        if (c & BitPosArray[21]) {
#line 269
          if (sq < 16) {
#line 269
            if (distance[sq][14] == 1) {
#line 270
              s___1 += 40;
            }
          }
        }
#line 271
        if (c & BitPosArray[18]) {
#line 271
          if (sq < 16) {
#line 271
            if (distance[sq][9] == 1) {
#line 272
              s___1 += 40;
            }
          }
        }
      }
    }
  }
#line 276
  t = passed[side] & (unsigned long )brank67[side];
#line 277
  if (t) {
#line 277
    if (board.pmaterial[xside] == 550) {
#line 277
      goto _L___3;
    } else
#line 277
    if (board.pmaterial[xside] == 350) {
#line 277
      if (pieces[xside] == board.b[xside][2]) {
        _L___3: /* CIL Label */ 
#line 281
        n1 = board.king[xside] & 7;
#line 282
        n2 = board.king[xside] >> 3;
#line 283
        i = 0;
        {
        {
#line 283
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 283
          if (! (i <= 6)) {
#line 283
            goto while_break___1;
          }
#line 285
          if (t & FileBit[i]) {
#line 285
            if (t & FileBit[i + 1]) {
#line 285
              if (n1 < i - 1) {
#line 287
                s___1 += 50;
              } else
#line 285
              if (n1 > i + 1) {
#line 287
                s___1 += 50;
              } else
#line 285
              if (side == 0) {
#line 285
                if (n2 < 4) {
#line 287
                  s___1 += 50;
                } else {
#line 285
                  goto _L___2;
                }
              } else
              _L___2: /* CIL Label */ 
#line 285
              if (side == 1) {
#line 285
                if (n2 > 3) {
#line 287
                  s___1 += 50;
                }
              }
            }
          }
#line 283
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 292
  blocker = board.friends[side] | board.friends[xside];
#line 293
  if (side == 0) {
#line 293
    if (((c & (unsigned long )d2e2[0]) >> 8) & blocker) {
#line 294
      s___1 += -48;
    }
  }
#line 295
  if (side == 1) {
#line 295
    if (((c & (unsigned long )d2e2[1]) << 8) & blocker) {
#line 296
      s___1 += -48;
    }
  }
#line 299
  if (passed[side]) {
#line 299
    if (board.pmaterial[xside] == 0) {
#line 301
      e = board.b[xside];
#line 302
      i1 = board.king[xside];
#line 303
      p___1 = passed[side];
      {
      {
#line 304
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 304
        if (! p___1) {
#line 304
          goto while_break___2;
        }
        {
        {
#line 306
        sq = leadz(p___1);
        }
#line 307
        p___1 &= NotBitPosArray[sq];
        }
#line 308
        if (board.side == side) {
#line 310
          if (! (SquarePawnMask[side][sq] & board.b[xside][6])) {
#line 311
            s___1 += (1100 * (int )Passed[side][sq >> 3]) / 550;
          }
        } else
#line 313
        if (! (MoveArray[6][i1] & SquarePawnMask[side][sq])) {
#line 314
          s___1 += (1100 * (int )Passed[side][sq >> 3]) / 550;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 319
  c = board.b[side][1];
  {
#line 320
  tmp___2 = abs((board.king[side] & 7) - (board.king[xside] & 7));
  }
  }
#line 320
  if (tmp___2 >= 4) {
#line 320
    if (8 - (board.material[0] + board.material[1]) / 1150 < 6) {
#line 323
      n1 = board.king[xside] & 7;
#line 324
      p___1 = (IsolaniMask[n1] | FileBit[n1]) & c;
      {
      {
#line 325
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 325
        if (! p___1) {
#line 325
          goto while_break___3;
        }
        {
        {
#line 327
        sq = leadz(p___1);
        }
#line 328
        p___1 &= NotBitPosArray[sq];
#line 329
        s___1 += 10 * (5 - distance[sq][board.king[xside]]);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 333
  return (s___1);
}
}
#line 336 "/home/khheo/testset/chess/src/eval.c"
static int const   Outpost[2][64]  = { {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )1, 
            (int const   )1,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}, 
   {        (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )1, 
            (int const   )1,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )1,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )1,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )1,        (int const   )1, 
            (int const   )1,        (int const   )1,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0, 
            (int const   )0,        (int const   )0,        (int const   )0,        (int const   )0}};
#line 357 "/home/khheo/testset/chess/src/eval.c"
__inline static int CTL(int sq , int piece  __attribute__((__unused__)) , int side ) 
{ 
  int s___1 ;
  int n___0 ;
  int EnemyKing ;
  int FriendlyKing ;
  BitBoard controlled ;

  {
  {
#line 370
  s___1 = 0;
#line 372
  EnemyKing = board.king[1 ^ side];
#line 373
  FriendlyKing = board.king[side];
  {
#line 375
  controlled = AttackXFrom(sq, side);
  }
  {
#line 378
  n___0 = nbits(controlled & (rings[0] | rings[1]));
  }
#line 379
  s___1 += 4 * n___0;
  {
#line 382
  n___0 = nbits(controlled & DistMap[EnemyKing][2]);
  }
#line 383
  s___1 += n___0;
  {
#line 386
  n___0 = nbits(controlled & DistMap[FriendlyKing][2]);
  }
#line 387
  s___1 += n___0;
  {
#line 390
  n___0 = nbits(controlled);
  }
#line 391
  s___1 += 4 * n___0;
  }
#line 393
  return (s___1);
}
}
#line 396 "/home/khheo/testset/chess/src/eval.c"
int ScoreN(int side ) 
{ 
  int xside ;
  int s___1 ;
  int s1 ;
  int sq ;
  int EnemyKing ;
  BitBoard c ;
  BitBoard t ;
  int tmp ;

  {
#line 411
  if ((unsigned long long )board.b[side][2] == 0ULL) {
#line 412
    return (0);
  }
#line 413
  xside = side ^ 1;
#line 414
  s1 = 0;
#line 414
  s___1 = s1;
#line 415
  c = board.b[side][2];
#line 416
  t = board.b[xside][1];
#line 417
  EnemyKing = board.king[xside];
#line 419
  if (c & pinned) {
    {
    {
#line 421
    tmp = nbits(c & pinned);
    }
#line 421
    s___1 += -30 * tmp;
    }
  }
  {
  {
#line 424
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 424
    if (! c) {
#line 424
      goto while_break;
    }
    {
    {
#line 426
    sq = leadz(c);
    }
#line 427
    c &= NotBitPosArray[sq];
    {
#line 430
    s1 = CTL(sq, 2, side);
    }
    }
#line 432
    if ((unsigned long long )(BitPosArray[sq] & rings[3]) != 0ULL) {
#line 433
      s1 += -13;
    }
#line 435
    if (Outpost[side][sq]) {
#line 435
      if (! ((t & IsolaniMask[sq & 7]) & PassedPawnMask[side][sq])) {
#line 438
        s1 += 10;
#line 441
        if (MoveArray[ptype[xside]][sq] & board.b[side][1]) {
#line 442
          s1 += 10;
        }
      }
    }
#line 446
    if (MoveArray[2][sq] & weaked[xside]) {
#line 447
      s1 += 2;
    }
#line 449
    s___1 += s1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return (s___1);
}
}
#line 456 "/home/khheo/testset/chess/src/eval.c"
int ScoreB(int side ) 
{ 
  int xside ;
  int s___1 ;
  int s1 ;
  int n___0 ;
  int sq ;
  int EnemyKing ;
  BitBoard c ;
  BitBoard t ;
  int tmp ;

  {
#line 471
  if ((unsigned long long )board.b[side][3] == 0ULL) {
#line 472
    return (0);
  }
#line 473
  s1 = 0;
#line 473
  s___1 = s1;
#line 474
  c = board.b[side][3];
#line 475
  xside = side ^ 1;
#line 476
  EnemyKing = board.king[xside];
#line 477
  n___0 = 0;
#line 478
  t = board.b[xside][1];
#line 480
  if (c & pinned) {
    {
    {
#line 482
    tmp = nbits(c & pinned);
    }
#line 482
    s___1 += -30 * tmp;
    }
  }
  {
  {
#line 485
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 485
    if (! c) {
#line 485
      goto while_break;
    }
    {
    {
#line 487
    sq = leadz(c);
    }
#line 488
    c &= NotBitPosArray[sq];
#line 489
    n___0 ++;
    {
#line 492
    s1 = CTL(sq, 3, side);
    }
    }
#line 495
    if (Outpost[side][sq]) {
#line 495
      if (! ((t & IsolaniMask[sq & 7]) & PassedPawnMask[side][sq])) {
#line 498
        s1 += 8;
#line 501
        if (MoveArray[ptype[xside]][sq] & board.b[side][1]) {
#line 502
          s1 += 8;
        }
      }
    }
#line 506
    if (side == 0) {
#line 508
      if (board.king[side] >= 5) {
#line 508
        if (board.king[side] <= 7) {
#line 508
          if (sq == 14) {
#line 509
            s1 += 8;
          }
        }
      }
#line 510
      if (board.king[side] >= 0) {
#line 510
        if (board.king[side] <= 2) {
#line 510
          if (sq == 9) {
#line 511
            s1 += 8;
          }
        }
      }
    } else
#line 513
    if (side == 1) {
#line 515
      if (board.king[side] >= 61) {
#line 515
        if (board.king[side] <= 63) {
#line 515
          if (sq == 54) {
#line 516
            s1 += 8;
          }
        }
      }
#line 517
      if (board.king[side] >= 56) {
#line 517
        if (board.king[side] <= 58) {
#line 517
          if (sq == 49) {
#line 518
            s1 += 8;
          }
        }
      }
    }
#line 522
    if ((Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) & weaked[xside]) {
#line 523
      s1 += 2;
    }
#line 525
    s___1 += s1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  if (n___0 > 1) {
#line 530
    s___1 += 18;
  }
#line 532
  return (s___1);
}
}
#line 537 "/home/khheo/testset/chess/src/eval.c"
int BishopTrapped(int side ) 
{ 
  int s___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 544
  s___1 = 0;
#line 546
  if (side == 0) {
#line 548
    if (board.b[0][3] & BitPosArray[48]) {
#line 548
      if (board.b[1][1] & BitPosArray[41]) {
        {
        {
#line 548
        tmp = SwapOff((48 << 6) | 41);
        }
        }
#line 548
        if (tmp < 0) {
#line 550
          s___1 += -250;
        }
      }
    }
#line 551
    if (board.b[0][3] & BitPosArray[55]) {
#line 551
      if (board.b[1][1] & BitPosArray[46]) {
        {
        {
#line 551
        tmp___0 = SwapOff((55 << 6) | 46);
        }
        }
#line 551
        if (tmp___0 < 0) {
#line 553
          s___1 += -250;
        }
      }
    }
  } else {
#line 557
    if (board.b[1][3] & BitPosArray[8]) {
#line 557
      if (board.b[0][1] & BitPosArray[17]) {
        {
        {
#line 557
        tmp___1 = SwapOff((8 << 6) | 17);
        }
        }
#line 557
        if (tmp___1 < 0) {
#line 559
          s___1 += -250;
        }
      }
    }
#line 560
    if (board.b[1][3] & BitPosArray[15]) {
#line 560
      if (board.b[0][1] & BitPosArray[22]) {
        {
        {
#line 560
        tmp___2 = SwapOff((15 << 6) | 22);
        }
        }
#line 560
        if (tmp___2 < 0) {
#line 562
          s___1 += -250;
        }
      }
    }
  }
#line 565
  return (s___1);
}
}
#line 568 "/home/khheo/testset/chess/src/eval.c"
int ScoreR(int side ) 
{ 
  int s___1 ;
  int s1 ;
  int sq ;
  int xside ;
  int fyle ;
  int EnemyKing ;
  BitBoard c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 580
  if ((unsigned long long )board.b[side][4] == 0ULL) {
#line 581
    return (0);
  }
#line 582
  s1 = 0;
#line 582
  s___1 = s1;
#line 583
  c = board.b[side][4];
#line 584
  xside = side ^ 1;
#line 585
  EnemyKing = board.king[xside];
#line 587
  if (c & pinned) {
    {
    {
#line 589
    tmp = nbits(c & pinned);
    }
#line 589
    s___1 += -50 * tmp;
    }
  }
  {
  {
#line 592
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 592
    if (! c) {
#line 592
      goto while_break;
    }
    {
    {
#line 594
    sq = leadz(c);
    }
#line 595
    c &= NotBitPosArray[sq];
    {
#line 598
    s1 = CTL(sq, 4, side);
    }
#line 600
    fyle = sq & 7;
    }
#line 601
    if (8 - (board.material[0] + board.material[1]) / 1150 < 7) {
#line 603
      if (! (board.b[side][1] & FileBit[fyle])) {
#line 605
        if (fyle == 5) {
#line 605
          if ((board.king[xside] & 7) >= 4) {
#line 606
            s1 += 40;
          }
        }
#line 607
        s1 += 5;
#line 608
        if (! (board.b[xside][1] & FileBit[fyle])) {
#line 609
          s1 += 6;
        }
      }
    }
#line 613
    if (phase > 6) {
#line 613
      if ((FileBit[fyle] & passed[0]) & (unsigned long )brank58[0]) {
        {
        {
#line 615
        tmp___0 = nbits(Ray[sq][7] & passed[0]);
        }
        }
#line 615
        if (tmp___0 == 1) {
#line 616
          s1 += 6;
        } else
#line 617
        if (Ray[sq][4] & passed[0]) {
#line 618
          s1 += -10;
        }
      }
    }
#line 620
    if ((FileBit[fyle] & passed[1]) & (unsigned long )brank58[1]) {
      {
      {
#line 622
      tmp___1 = nbits(Ray[sq][4] & passed[1]);
      }
      }
#line 622
      if (tmp___1 == 1) {
#line 623
        s1 += 6;
      } else
#line 624
      if (Ray[sq][7] & passed[1]) {
#line 625
        s1 += -10;
      }
    }
#line 629
    if ((Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]) & weaked[xside]) {
#line 630
      s1 += 2;
    }
#line 633
    if (sq >> 3 == rank7[side]) {
#line 633
      if (EnemyKing >> 3 == rank8[side]) {
#line 635
        s1 += 30;
      } else
#line 633
      if (board.b[xside][1] & RankBit[sq >> 3]) {
#line 635
        s1 += 30;
      }
    }
#line 637
    s___1 += s1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  return (s___1);
}
}
#line 643 "/home/khheo/testset/chess/src/eval.c"
int DoubleQR7(int side ) 
{ 
  int xside ;
  int tmp ;

  {
  {
#line 654
  xside = 1 ^ side;
  {
#line 655
  tmp = nbits((board.b[side][5] | board.b[side][4]) & (unsigned long )brank7[side]);
  }
  }
#line 655
  if (tmp > 1) {
#line 655
    if (board.b[xside][6] & (unsigned long )brank8[side]) {
#line 659
      return (30);
    } else
#line 655
    if (board.b[xside][1] & (unsigned long )brank7[side]) {
#line 659
      return (30);
    } else {
#line 661
      return (0);
    }
  } else {
#line 661
    return (0);
  }
}
}
#line 664 "/home/khheo/testset/chess/src/eval.c"
int ScoreQ(int side ) 
{ 
  int xside ;
  int s___1 ;
  int s1 ;
  int sq ;
  int EnemyKing ;
  BitBoard c ;
  int tmp ;

  {
#line 677
  if ((unsigned long long )board.b[side][5] == 0ULL) {
#line 678
    return (0);
  }
#line 679
  s1 = 0;
#line 679
  s___1 = s1;
#line 680
  xside = 1 ^ side;
#line 681
  c = board.b[side][5];
#line 682
  EnemyKing = board.king[xside];
#line 685
  if (side == computer) {
#line 686
    if ((unsigned long long )c == 0ULL) {
#line 687
      s___1 += -25;
    }
  }
#line 689
  if (c & pinned) {
    {
    {
#line 691
    tmp = nbits(c & pinned);
    }
#line 691
    s___1 += -90 * tmp;
    }
  }
  {
  {
#line 694
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 694
    if (! c) {
#line 694
      goto while_break;
    }
    {
    {
#line 696
    sq = leadz(c);
    }
#line 697
    c &= NotBitPosArray[sq];
    {
#line 700
    s1 = CTL(sq, 5, side);
    }
    }
#line 702
    if (distance[sq][EnemyKing] <= 2) {
#line 703
      s1 += 12;
    }
#line 706
    if (((Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) | (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL])) & weaked[xside]) {
#line 707
      s1 += 2;
    }
#line 709
    s___1 += s1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  return (s___1);
}
}
#line 716 "/home/khheo/testset/chess/src/eval.c"
static int const   KingSq[64]  = 
#line 716
  {      (int const   )24,      (int const   )24,      (int const   )24,      (int const   )16, 
        (int const   )16,      (int const   )0,      (int const   )32,      (int const   )32, 
        (int const   )24,      (int const   )20,      (int const   )16,      (int const   )12, 
        (int const   )12,      (int const   )16,      (int const   )20,      (int const   )24, 
        (int const   )16,      (int const   )12,      (int const   )8,      (int const   )4, 
        (int const   )4,      (int const   )8,      (int const   )12,      (int const   )16, 
        (int const   )12,      (int const   )8,      (int const   )4,      (int const   )0, 
        (int const   )0,      (int const   )4,      (int const   )8,      (int const   )12, 
        (int const   )12,      (int const   )8,      (int const   )4,      (int const   )0, 
        (int const   )0,      (int const   )4,      (int const   )8,      (int const   )12, 
        (int const   )16,      (int const   )12,      (int const   )8,      (int const   )4, 
        (int const   )4,      (int const   )8,      (int const   )12,      (int const   )16, 
        (int const   )24,      (int const   )20,      (int const   )16,      (int const   )12, 
        (int const   )12,      (int const   )16,      (int const   )20,      (int const   )24, 
        (int const   )24,      (int const   )24,      (int const   )24,      (int const   )16, 
        (int const   )16,      (int const   )0,      (int const   )32,      (int const   )32};
#line 728 "/home/khheo/testset/chess/src/eval.c"
static int const   EndingKing[64]  = 
#line 728
  {      (int const   )0,      (int const   )6,      (int const   )12,      (int const   )18, 
        (int const   )18,      (int const   )12,      (int const   )6,      (int const   )0, 
        (int const   )6,      (int const   )12,      (int const   )18,      (int const   )24, 
        (int const   )24,      (int const   )18,      (int const   )12,      (int const   )6, 
        (int const   )12,      (int const   )18,      (int const   )24,      (int const   )32, 
        (int const   )32,      (int const   )24,      (int const   )18,      (int const   )12, 
        (int const   )18,      (int const   )24,      (int const   )32,      (int const   )48, 
        (int const   )48,      (int const   )32,      (int const   )24,      (int const   )18, 
        (int const   )18,      (int const   )24,      (int const   )32,      (int const   )48, 
        (int const   )48,      (int const   )32,      (int const   )24,      (int const   )18, 
        (int const   )12,      (int const   )18,      (int const   )24,      (int const   )32, 
        (int const   )32,      (int const   )24,      (int const   )18,      (int const   )12, 
        (int const   )6,      (int const   )12,      (int const   )18,      (int const   )24, 
        (int const   )24,      (int const   )18,      (int const   )12,      (int const   )6, 
        (int const   )0,      (int const   )6,      (int const   )12,      (int const   )18, 
        (int const   )18,      (int const   )12,      (int const   )6,      (int const   )0};
#line 740 "/home/khheo/testset/chess/src/eval.c"
static int pawncover[9]  = 
#line 740
  {      -60,      -30,      0,      5, 
        30,      30,      30,      30, 
        30};
#line 741 "/home/khheo/testset/chess/src/eval.c"
static int const   factor[9]  = 
#line 741
  {      (int const   )7,      (int const   )8,      (int const   )8,      (int const   )7, 
        (int const   )6,      (int const   )5,      (int const   )4,      (int const   )2, 
        (int const   )0};
#line 743 "/home/khheo/testset/chess/src/eval.c"
int ScoreK(int side ) 
{ 
  int xside ;
  int s___1 ;
  int sq ;
  int sq1 ;
  int n___0 ;
  int n1 ;
  int n2 ;
  int file___0 ;
  int fsq ;
  int rank ;
  BitBoard b ;
  BitBoard x___0 ;
  int tmp ;

  {
#line 759
  s___1 = 0;
#line 760
  xside = 1 ^ side;
#line 761
  sq = board.king[side];
#line 762
  file___0 = sq & 7;
#line 763
  rank = sq >> 3;
#line 764
  KingSafety[side] = 0;
#line 765
  if (! (phase >= 6)) {
#line 768
    s___1 += ((6 - phase) * (int )KingSq[sq] + phase * (int )EndingKing[sq]) / 6;
#line 773
    if (side == 0) {
      {
      {
#line 774
      n___0 = nbits((MoveArray[6][sq] & board.b[side][1]) & RankBit[rank + 1]);
      }
      }
    } else {
      {
      {
#line 776
      n___0 = nbits((MoveArray[6][sq] & board.b[side][1]) & RankBit[rank - 1]);
      }
      }
    }
#line 777
    s___1 += pawncover[n___0];
#line 780
    if (! board.castled[side]) {
#line 781
      n___0 = -1;
#line 782
      if (side == 0) {
#line 784
        if (sq == 4) {
#line 784
          if (Mvboard[sq] == 0) {
#line 786
            if ((unsigned long long )(board.b[side][4] & BitPosArray[7]) != 0ULL) {
#line 786
              if (Mvboard[7] == 0) {
                {
                {
#line 788
                n___0 = nbits((MoveArray[6][6] & board.b[side][1]) & RankBit[rank + 1]);
                }
                }
              }
            }
#line 791
            if ((unsigned long long )(board.b[side][4] & BitPosArray[0]) != 0ULL) {
#line 791
              if (Mvboard[0] == 0) {
                {
                {
#line 793
                n___0 = nbits((MoveArray[6][2] & board.b[side][1]) & RankBit[rank + 1]);
                }
                }
              }
            }
          }
        }
      } else
#line 797
      if (sq == 60) {
#line 797
        if (Mvboard[sq] == 0) {
#line 799
          if ((unsigned long long )(board.b[side][4] & BitPosArray[63]) != 0ULL) {
#line 799
            if (Mvboard[63] == 0) {
              {
              {
#line 801
              n___0 = nbits((MoveArray[6][62] & board.b[side][1]) & RankBit[rank - 1]);
              }
              }
            }
          }
#line 804
          if ((unsigned long long )(board.b[side][4] & BitPosArray[56]) != 0ULL) {
#line 804
            if (Mvboard[56] == 0) {
              {
              {
#line 806
              n___0 = nbits((MoveArray[6][58] & board.b[side][1]) & RankBit[rank - 1]);
              }
              }
            }
          }
        }
      }
#line 810
      pawncover[3] = 30;
#line 812
      if (n___0 != -1) {
#line 812
        s___1 += pawncover[n___0];
      }
    }
#line 815
    if (side == computer) {
#line 815
      if (file___0 >= 5) {
#line 815
        if (! (FileBit[6] & board.b[side][1])) {
#line 818
          if (side == 0) {
#line 818
            if (cboard[13] == 1) {
#line 819
              s___1 += -30;
            } else {
#line 818
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 820
          if (side == 1) {
#line 820
            if (cboard[53] == 1) {
#line 821
              s___1 += -30;
            }
          }
        }
      }
    }
#line 825
    if (! (FileBit[file___0] & board.b[side][1])) {
#line 826
      s___1 += -10;
    }
#line 829
    if (! (FileBit[file___0] & board.b[xside][1])) {
#line 830
      s___1 += -6;
    }
    {
#line 837
    if (file___0 == 6) {
#line 837
      goto case_6;
    }
#line 837
    if (file___0 == 5) {
#line 837
      goto case_6;
    }
#line 837
    if (file___0 == 4) {
#line 837
      goto case_6;
    }
#line 837
    if (file___0 == 0) {
#line 837
      goto case_6;
    }
#line 845
    if (file___0 == 1) {
#line 845
      goto case_1;
    }
#line 845
    if (file___0 == 2) {
#line 845
      goto case_1;
    }
#line 845
    if (file___0 == 3) {
#line 845
      goto case_1;
    }
#line 845
    if (file___0 == 7) {
#line 845
      goto case_1;
    }
#line 850
    goto switch_default;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 837
    if (! (FileBit[file___0 + 1] & board.b[side][1])) {
#line 838
      s___1 += -10;
    }
#line 839
    if (! (FileBit[file___0 + 1] & board.b[xside][1])) {
#line 840
      s___1 += -6;
    }
#line 841
    goto switch_break;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 845
    if (! (FileBit[file___0 - 1] & board.b[side][1])) {
#line 846
      s___1 += -10;
    }
#line 847
    if (! (FileBit[file___0 - 1] & board.b[xside][1])) {
#line 848
      s___1 += -6;
    }
#line 849
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 851
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 854
    if (board.castled[side]) {
#line 855
      if (side == 0) {
#line 856
        if (file___0 > 4) {
#line 857
          if (! (BitPosArray[13] & board.b[side][1])) {
#line 860
            s___1 += -20;
          } else
#line 857
          if (! (BitPosArray[14] & board.b[side][1])) {
#line 860
            s___1 += -20;
          } else
#line 857
          if (! (BitPosArray[15] & board.b[side][1])) {
#line 860
            s___1 += -20;
          }
        } else
#line 861
        if (file___0 < 4) {
#line 862
          if (! (BitPosArray[8] & board.b[side][1])) {
#line 865
            s___1 += -20;
          } else
#line 862
          if (! (BitPosArray[9] & board.b[side][1])) {
#line 865
            s___1 += -20;
          } else
#line 862
          if (! (BitPosArray[10] & board.b[side][1])) {
#line 865
            s___1 += -20;
          }
        }
      } else
#line 868
      if (file___0 > 4) {
#line 869
        if (! (BitPosArray[53] & board.b[side][1])) {
#line 872
          s___1 += -20;
        } else
#line 869
        if (! (BitPosArray[54] & board.b[side][1])) {
#line 872
          s___1 += -20;
        } else
#line 869
        if (! (BitPosArray[55] & board.b[side][1])) {
#line 872
          s___1 += -20;
        }
      } else
#line 873
      if (file___0 < 4) {
#line 874
        if (! (BitPosArray[48] & board.b[side][1])) {
#line 877
          s___1 += -20;
        } else
#line 874
        if (! (BitPosArray[49] & board.b[side][1])) {
#line 877
          s___1 += -20;
        } else
#line 874
        if (! (BitPosArray[50] & board.b[side][1])) {
#line 877
          s___1 += -20;
        }
      }
    }
#line 881
    if (side == computer) {
#line 885
      if (file___0 >= 4) {
#line 885
        if (board.b[xside][5]) {
#line 885
          if (board.b[xside][4]) {
#line 885
            if (! ((board.b[side][1] | board.b[xside][1]) & FileBit[7])) {
#line 887
              s___1 += -600;
            }
          }
        }
      }
#line 890
      if (side == 0) {
#line 891
        if (file___0 > 4) {
#line 892
          if (board.b[side][4] & mask_kr_trapped_w[7 - file___0]) {
#line 893
            s___1 += -10;
          }
        } else
#line 895
        if (file___0 < 3) {
#line 896
          if (board.b[side][4] & mask_qr_trapped_w[file___0]) {
#line 897
            s___1 += -10;
          }
        }
      } else
#line 901
      if (file___0 > 4) {
#line 902
        if (board.b[side][4] & mask_kr_trapped_b[7 - file___0]) {
#line 903
          s___1 += -10;
        }
      } else
#line 905
      if (file___0 < 3) {
#line 906
        if (board.b[side][4] & mask_qr_trapped_b[file___0]) {
#line 907
          s___1 += -10;
        }
      }
    }
#line 914
    if (file___0 > 4) {
#line 914
      if ((board.king[xside] & 7) < 3) {
#line 915
        if (side == 0) {
#line 915
          fsq = 22;
        } else {
#line 915
          fsq = 46;
        }
#line 916
        if ((unsigned long long )(BitPosArray[fsq] & board.b[side][1]) != 0ULL) {
#line 917
          if ((unsigned long long )((((BitPosArray[29] | BitPosArray[31]) | BitPosArray[37]) | BitPosArray[39]) & board.b[xside][1]) != 0ULL) {
#line 920
            s___1 += -13;
          }
        }
      }
    }
#line 922
    if (file___0 < 4) {
#line 922
      if ((board.king[xside] & 7) > 4) {
#line 923
        if (side == 0) {
#line 923
          fsq = 17;
        } else {
#line 923
          fsq = 41;
        }
#line 924
        if ((unsigned long long )(BitPosArray[fsq] & board.b[side][1]) != 0ULL) {
#line 925
          if ((unsigned long long )((((BitPosArray[24] | BitPosArray[26]) | BitPosArray[32]) | BitPosArray[34]) & board.b[xside][1]) != 0ULL) {
#line 928
            s___1 += -13;
          }
        }
      }
    }
    {
#line 933
    x___0 = boardhalf[side] & boardside[file___0 <= 3];
    {
#line 935
    n1 = nbits(x___0 & board.friends[xside]);
    }
    }
#line 936
    if (n1 > 0) {
      {
      {
#line 938
      n2 = nbits(x___0 & ((board.friends[side] & ~ board.b[side][1]) & ~ board.b[side][6]));
      }
      }
#line 940
      if (n1 > n2) {
#line 941
        s___1 += (n1 - n2) * -50;
      }
    }
#line 944
    KingSafety[side] = s___1;
#line 945
    s___1 = (s___1 * (int )factor[phase]) / 8;
  } else {
    {
#line 949
    s___1 += (int )EndingKing[sq];
    {
#line 950
    tmp = CTL(sq, 6, side);
    }
#line 950
    s___1 += tmp;
#line 951
    b = board.b[0][1] | board.b[1][1];
    }
    {
    {
#line 952
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 952
      if (! b) {
#line 952
        goto while_break;
      }
      {
      {
#line 954
      sq1 = leadz(b);
      }
#line 955
      b &= NotBitPosArray[sq1];
      }
#line 956
      if (BitPosArray[sq1] & board.b[0][1]) {
#line 957
        s___1 -= distance[sq][sq1 + 8] * 10 - 5;
      } else
#line 958
      if (BitPosArray[sq1] & board.b[0][1]) {
#line 959
        s___1 -= distance[sq][sq1 - 8] * 10 - 5;
      } else {
#line 961
        s___1 -= distance[sq][sq1] - 5;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 965
    if (MoveArray[6][sq] & weaked[xside]) {
#line 966
      s___1 += 4;
    }
  }
#line 970
  if (phase >= 4) {
#line 972
    if (side == 0) {
#line 973
      if (sq < 8) {
#line 974
        if (! (MoveArray[6][sq] & (~ board.b[side][1] & RankBit[1]))) {
#line 975
          s___1 += -40;
        }
      }
    } else
#line 977
    if (sq > 55) {
#line 978
      if (! (MoveArray[6][sq] & (~ board.b[side][1] & RankBit[6]))) {
#line 979
        s___1 += -40;
      }
    }
  }
#line 983
  return (s___1);
}
}
#line 987 "/home/khheo/testset/chess/src/eval.c"
int LoneKing(int side , int loser ) 
{ 
  int s___1 ;
  int winer ;
  int sq1 ;
  int sq2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 998
  winer = 1 ^ loser;
#line 999
  if (board.material[winer] == 700) {
    {
    {
#line 999
    tmp___0 = nbits(board.b[winer][3]);
    }
    }
#line 999
    if (tmp___0 == 1) {
      {
      {
#line 999
      tmp___1 = nbits(board.b[winer][2]);
      }
      }
#line 999
      if (tmp___1 == 1) {
        {
        {
#line 1002
        tmp = ScoreKBNK(side, loser);
        }
        }
#line 1002
        return (tmp);
      }
    }
  }
#line 1004
  sq1 = board.king[winer];
#line 1005
  sq2 = board.king[loser];
#line 1006
  s___1 = (150 - 6 * taxicab[sq1][sq2]) - (int )EndingKing[sq2];
#line 1007
  if (side == loser) {
#line 1008
    s___1 = - s___1;
  }
#line 1009
  s___1 += board.material[side] - board.material[1 ^ side];
#line 1011
  return (s___1);
}
}
#line 1015 "/home/khheo/testset/chess/src/eval.c"
int KPK(int side ) 
{ 
  int winer ;
  int loser ;
  int sq ;
  int sqw ;
  int sql ;
  int s___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1028
  if (board.b[0][1]) {
#line 1028
    winer = 0;
  } else {
#line 1028
    winer = 1;
  }
  {
#line 1029
  loser = 1 ^ winer;
  {
#line 1030
  sq = leadz(board.b[winer][1]);
  }
#line 1031
  sqw = board.king[winer];
#line 1032
  sql = board.king[loser];
  }
#line 1033
  if (winer == 0) {
#line 1033
    tmp = sqw >> 3;
  } else {
#line 1033
    tmp = 7 - (sqw >> 3);
  }
#line 1033
  s___1 = (100 + (1100 * (int )Passed[winer][sq >> 3]) / 550) + 4 * tmp;
#line 1041
  if (~ SquarePawnMask[winer][sq] & board.b[loser][6]) {
#line 1043
    if (! (MoveArray[6][sql] & SquarePawnMask[winer][sq])) {
#line 1044
      if (winer == side) {
#line 1044
        tmp___0 = s___1;
      } else {
#line 1044
        tmp___0 = - s___1;
      }
#line 1044
      return (tmp___0);
    }
#line 1045
    if (winer == side) {
#line 1046
      return (s___1);
    }
  }
#line 1055
  if ((sq & 7) != 0) {
#line 1055
    if ((sq & 7) != 7) {
#line 1055
      if ((IsolaniMask[sq & 7] | FileBit[sq & 7]) & board.b[winer][6]) {
#line 1076
        if (winer == 0) {
#line 1078
          if (sqw >> 3 == (sq >> 3) + 2) {
#line 1079
            if (winer == side) {
#line 1079
              tmp___1 = s___1;
            } else {
#line 1079
              tmp___1 = - s___1;
            }
#line 1079
            return (tmp___1);
          }
#line 1080
          if (sqw >> 3 == (sq >> 3) + 1) {
#line 1082
            if (sqw >> 3 == 5) {
#line 1083
              if (winer == side) {
#line 1083
                tmp___2 = s___1;
              } else {
#line 1083
                tmp___2 = - s___1;
              }
#line 1083
              return (tmp___2);
            }
#line 1084
            if (sqw < 40) {
#line 1086
              if (sqw + 16 == sql) {
#line 1086
                if (winer == side) {
#line 1087
                  return (0);
                } else {
#line 1086
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 1089
                if (winer == side) {
#line 1089
                  tmp___3 = s___1;
                } else {
#line 1089
                  tmp___3 = - s___1;
                }
#line 1089
                return (tmp___3);
              }
            }
          }
#line 1092
          if (sqw >> 3 == sq >> 3) {
#line 1094
            if ((sql >> 3) - (sq >> 3) < 2) {
#line 1094
              goto _L___0;
            } else
#line 1094
            if ((sql >> 3) - (sq >> 3) > 4) {
              _L___0: /* CIL Label */ 
#line 1094
              if (winer == side) {
#line 1096
                return (s___1);
              }
            }
#line 1097
            if ((sql >> 3) - (sq >> 3) < 1) {
#line 1097
              goto _L___1;
            } else
#line 1097
            if ((sql >> 3) - (sq >> 3) > 5) {
              _L___1: /* CIL Label */ 
#line 1097
              if (loser == side) {
#line 1099
                return (- s___1);
              }
            }
#line 1100
            if (sq >> 3 == 5) {
#line 1100
              if (sqw + 16 != sql) {
#line 1101
                if (winer == side) {
#line 1101
                  tmp___4 = s___1;
                } else {
#line 1101
                  tmp___4 = 0;
                }
#line 1101
                return (tmp___4);
              }
            }
          }
#line 1103
          if (sq >> 3 == 6) {
#line 1103
            if (sqw >> 3 == 5) {
#line 1105
              if (sql != sq + 8) {
#line 1106
                if (winer == side) {
#line 1106
                  tmp___5 = s___1;
                } else {
#line 1106
                  tmp___5 = 0;
                }
#line 1106
                return (tmp___5);
              }
#line 1107
              if (sql == sq + 8) {
#line 1107
                if (sql == sqw + 16) {
#line 1108
                  if (winer == side) {
#line 1108
                    tmp___6 = s___1;
                  } else {
#line 1108
                    tmp___6 = 0;
                  }
#line 1108
                  return (tmp___6);
                }
              }
            }
          }
        } else {
#line 1113
          if (sqw >> 3 == (sq >> 3) - 2) {
#line 1114
            if (winer == side) {
#line 1114
              tmp___7 = s___1;
            } else {
#line 1114
              tmp___7 = - s___1;
            }
#line 1114
            return (tmp___7);
          }
#line 1115
          if (sqw >> 3 == (sq >> 3) - 1) {
#line 1117
            if (sqw >> 3 == 2) {
#line 1118
              if (winer == side) {
#line 1118
                tmp___8 = s___1;
              } else {
#line 1118
                tmp___8 = - s___1;
              }
#line 1118
              return (tmp___8);
            }
#line 1119
            if (sqw > 23) {
#line 1121
              if (sqw - 16 == sql) {
#line 1121
                if (winer == side) {
#line 1122
                  return (0);
                } else {
#line 1121
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
#line 1124
                if (winer == side) {
#line 1124
                  tmp___9 = s___1;
                } else {
#line 1124
                  tmp___9 = - s___1;
                }
#line 1124
                return (tmp___9);
              }
            }
          }
#line 1127
          if (sqw >> 3 == sq >> 3) {
#line 1129
            if ((sq >> 3) - (sql >> 3) < 2) {
#line 1129
              goto _L___3;
            } else
#line 1129
            if ((sq >> 3) - (sql >> 3) > 4) {
              _L___3: /* CIL Label */ 
#line 1129
              if (winer == side) {
#line 1131
                return (s___1);
              }
            }
#line 1132
            if ((sq >> 3) - (sql >> 3) < 1) {
#line 1132
              goto _L___4;
            } else
#line 1132
            if ((sq >> 3) - (sql >> 3) > 5) {
              _L___4: /* CIL Label */ 
#line 1132
              if (loser == side) {
#line 1134
                return (- s___1);
              }
            }
#line 1135
            if (sq >> 3 == 5) {
#line 1135
              if (sqw + 16 != sql) {
#line 1136
                if (winer == side) {
#line 1136
                  tmp___10 = s___1;
                } else {
#line 1136
                  tmp___10 = 0;
                }
#line 1136
                return (tmp___10);
              }
            }
          }
#line 1138
          if (sq >> 3 == 1) {
#line 1138
            if (sqw >> 3 == 2) {
#line 1140
              if (sql != sq - 8) {
#line 1141
                if (winer == side) {
#line 1141
                  tmp___11 = s___1;
                } else {
#line 1141
                  tmp___11 = 0;
                }
#line 1141
                return (tmp___11);
              }
#line 1142
              if (sql == sq - 8) {
#line 1142
                if (sql == sqw - 16) {
#line 1143
                  if (winer == side) {
#line 1143
                    tmp___12 = s___1;
                  } else {
#line 1143
                    tmp___12 = 0;
                  }
#line 1143
                  return (tmp___12);
                }
              }
            }
          }
        }
      }
    }
  }
#line 1148
  return (0);
}
}
#line 1152 "/home/khheo/testset/chess/src/eval.c"
int KBNK[64]  = 
#line 1152
  {      0,      10,      20,      30, 
        40,      50,      60,      70, 
        10,      20,      30,      40, 
        50,      60,      70,      60, 
        20,      30,      40,      50, 
        60,      70,      60,      50, 
        30,      40,      50,      60, 
        70,      60,      50,      40, 
        40,      50,      60,      70, 
        60,      50,      40,      30, 
        50,      60,      70,      60, 
        50,      40,      30,      20, 
        60,      70,      60,      50, 
        40,      30,      20,      10, 
        70,      60,      50,      40, 
        30,      20,      10,      0};
#line 1164 "/home/khheo/testset/chess/src/eval.c"
int ScoreKBNK(int side , int loser ) 
{ 
  int s___1 ;
  int winer ;
  int sq1 ;
  int sq2 ;
  int sqB ;
  int tmp ;
  int tmp___0 ;

  {
#line 1173
  winer = 1 ^ loser;
#line 1174
  sqB = board.king[loser];
#line 1175
  if ((unsigned long long )board.b[winer][3] & 6172840429334713770ULL) {
#line 1176
    sqB = ((sqB >> 3) * 8 + 7) - (sqB & 7);
  }
  {
#line 1177
  sq1 = board.king[winer];
#line 1178
  sq2 = board.king[loser];
#line 1179
  s___1 = 300 - 6 * taxicab[sq1][sq2];
#line 1180
  s___1 -= KBNK[sqB];
#line 1181
  s___1 -= (int )EndingKing[sq2];
  {
#line 1182
  tmp = leadz(board.b[winer][2]);
  }
#line 1182
  s___1 -= taxicab[tmp][sq2];
  {
#line 1183
  tmp___0 = leadz(board.b[winer][3]);
  }
#line 1183
  s___1 -= taxicab[tmp___0][sq2];
  }
#line 1186
  if ((unsigned long long )board.b[winer][6] & 66229406269440ULL) {
#line 1187
    s___1 += 20;
  }
#line 1188
  if (side == loser) {
#line 1189
    s___1 = - s___1;
  }
#line 1190
  s___1 += board.material[side] - board.material[1 ^ side];
#line 1192
  return (s___1);
}
}
#line 1196 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   nn[2]  = {      (BitBoard const   )4755801206503243776ULL,      (BitBoard const   )66ULL};
#line 1197 "/home/khheo/testset/chess/src/eval.c"
static BitBoard const   bb[2]  = {      (BitBoard const   )2594073385365405696ULL,      (BitBoard const   )36ULL};
#line 1199 "/home/khheo/testset/chess/src/eval.c"
int ScoreDev(int side ) 
{ 
  int s___1 ;
  int xside ;
  int sq ;
  BitBoard c ;
  int tmp ;

  {
  {
#line 1210
  s___1 = 0;
#line 1215
  xside = 1 ^ side;
#line 1218
  c = (board.b[side][2] & (unsigned long )nn[side]) | (board.b[side][3] & (unsigned long )bb[side]);
  {
#line 1219
  tmp = nbits(c);
  }
#line 1219
  s___1 += tmp * -8;
  }
#line 1222
  if (board.castled[side]) {
#line 1223
    return (s___1);
  } else
#line 1222
  if (GameCnt / 2 + 1 >= 20) {
#line 1223
    return (s___1);
  }
#line 1225
  s___1 += -8;
#line 1228
  if (Mvboard[board.king[side]] > 0) {
#line 1229
    s___1 += -20;
  }
#line 1232
  c = board.b[side][4];
  {
  {
#line 1233
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1233
    if (! c) {
#line 1233
      goto while_break;
    }
    {
    {
#line 1234
    sq = leadz(c);
    }
#line 1235
    c &= NotBitPosArray[sq];
    }
#line 1236
    if (Mvboard[sq] > 0) {
#line 1237
      s___1 += -20;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1241
  if (board.b[side][5]) {
    {
    {
#line 1243
    sq = leadz(board.b[side][5]);
    }
    }
#line 1244
    if (Mvboard[sq] > 0) {
#line 1245
      s___1 += -40;
    }
  }
#line 1250
  c = board.b[side][2] | board.b[side][3];
  {
  {
#line 1251
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1251
    if (! c) {
#line 1251
      goto while_break___0;
    }
    {
    {
#line 1252
    sq = leadz(c);
    }
#line 1253
    c &= NotBitPosArray[sq];
    }
#line 1254
    if (Mvboard[sq] > 1) {
#line 1255
      s___1 += -7;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1260
  c = board.b[side][1] & (((FileBit[0] | FileBit[1]) | FileBit[6]) | FileBit[7]);
  {
  {
#line 1261
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1261
    if (! c) {
#line 1261
      goto while_break___1;
    }
    {
    {
#line 1262
    sq = leadz(c);
    }
#line 1263
    c &= NotBitPosArray[sq];
    }
#line 1264
    if (Mvboard[sq] > 0) {
#line 1265
      s___1 += -6;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1269
  c = board.b[side][1] & (((FileBit[2] | FileBit[3]) | FileBit[4]) | FileBit[5]);
  {
  {
#line 1270
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 1270
    if (! c) {
#line 1270
      goto while_break___2;
    }
    {
    {
#line 1271
    sq = leadz(c);
    }
#line 1272
    c &= NotBitPosArray[sq];
    }
#line 1273
    if (Mvboard[sq] > 1) {
#line 1274
      s___1 += -6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1277
  return (s___1);
}
}
#line 1282 "/home/khheo/testset/chess/src/eval.c"
static int (*ScorePiece[7])(int  )  = {      (int (*)(int  ))((void *)0),      & ScoreP,      & ScoreN,      & ScoreB, 
        & ScoreR,      & ScoreQ,      & ScoreK};
#line 1286 "/home/khheo/testset/chess/src/eval.c"
int Evaluate(int alpha , int beta ) 
{ 
  int side ;
  int xside ;
  int piece ;
  int s___1 ;
  int s1 ;
  int score ;
  int npiece[2] ;
  BitBoard *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *__cil_tmp32 ;

  {
#line 1305
  side = board.side;
#line 1306
  xside = 1 ^ side;
#line 1309
  if (alpha > 32512) {
#line 1310
    return (board.material[side] - board.material[1 ^ side]);
  } else
#line 1309
  if (beta < -32512) {
#line 1310
    return (board.material[side] - board.material[1 ^ side]);
  }
#line 1313
  if (board.material[0] + board.material[1] == 100) {
    {
    {
#line 1314
    tmp = KPK(side);
    }
    }
#line 1314
    return (tmp);
  }
#line 1317
  if (board.material[xside] == 0) {
#line 1317
    if ((unsigned long long )board.b[side][1] == 0ULL) {
      {
      {
#line 1318
      tmp___0 = LoneKing(side, xside);
      }
      }
#line 1318
      return (tmp___0);
    }
  }
#line 1319
  if (board.material[side] == 0) {
#line 1319
    if ((unsigned long long )board.b[xside][1] == 0ULL) {
      {
      {
#line 1320
      tmp___1 = LoneKing(side, side);
      }
      }
#line 1320
      return (tmp___1);
    }
  }
  {
#line 1331
  EvalCall ++;
#line 1332
  phase = 8 - (board.material[0] + board.material[1]) / 1150;
#line 1333
  b = board.b[0];
#line 1334
  pieces[0] = ((*(b + 2) | *(b + 3)) | *(b + 4)) | *(b + 5);
  {
#line 1335
  npiece[0] = nbits(pieces[0]);
  }
#line 1336
  b = board.b[1];
#line 1337
  pieces[1] = ((*(b + 2) | *(b + 3)) | *(b + 4)) | *(b + 5);
  {
#line 1338
  npiece[1] = nbits(pieces[1]);
  }
#line 1339
  s1 = board.material[side] - board.material[1 ^ side];
  }
#line 1341
  if (s1 + maxposnscore[side] < alpha) {
#line 1341
    goto _L;
  } else
#line 1341
  if (s1 - maxposnscore[xside] > beta) {
    _L: /* CIL Label */ 
#line 1341
    if (phase <= 6) {
#line 1344
      score = s1;
#line 1345
      goto next;
    }
  }
  {
#line 1347
  s___1 = 0;
  {
#line 1348
  tmp___2 = ScoreDev(side);
  }
  {
#line 1348
  tmp___3 = ScoreDev(xside);
  }
#line 1348
  s___1 += tmp___2 - tmp___3;
  {
#line 1349
  tmp___4 = ScoreP(side);
  }
  {
#line 1349
  tmp___5 = ScoreP(xside);
  }
#line 1349
  s___1 += tmp___4 - tmp___5;
  {
#line 1350
  tmp___6 = ScoreK(side);
  }
  {
#line 1350
  tmp___7 = ScoreK(xside);
  }
#line 1350
  s___1 += tmp___6 - tmp___7;
  {
#line 1351
  tmp___8 = BishopTrapped(side);
  }
  {
#line 1351
  tmp___9 = BishopTrapped(xside);
  }
#line 1351
  s___1 += tmp___8 - tmp___9;
  {
#line 1352
  tmp___10 = DoubleQR7(side);
  }
  {
#line 1352
  tmp___11 = DoubleQR7(xside);
  }
#line 1352
  s___1 += tmp___10 - tmp___11;
#line 1354
  s1 = s___1 + (board.material[side] - board.material[1 ^ side]);
  }
#line 1362
  if (s1 + lazyscore[side] < alpha) {
#line 1364
    score = s1;
  } else
#line 1362
  if (s1 - lazyscore[side] > beta) {
#line 1364
    score = s1;
  } else {
    {
#line 1368
    EvalCnt ++;
    {
#line 1370
    GenAtaks();
    }
    {
#line 1371
    tmp___12 = EvalHung(side);
    }
    {
#line 1371
    tmp___13 = EvalHung(xside);
    }
#line 1371
    s1 = -20 * (tmp___12 - tmp___13);
    {
#line 1372
    FindPins(& pinned);
    }
#line 1374
    piece = 2;
    }
    {
    {
#line 1374
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1374
      if (! (piece < 6)) {
#line 1374
        goto while_break;
      }
      {
      {
#line 1376
      tmp___14 = (*(ScorePiece[piece]))(side);
      }
      {
#line 1376
      tmp___15 = (*(ScorePiece[piece]))(xside);
      }
#line 1376
      s1 += tmp___14 - tmp___15;
#line 1374
      piece ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1378
    if (s1 > lazyscore[side]) {
#line 1378
      lazyscore[side] = s1;
    } else {
#line 1378
      lazyscore[side] = lazyscore[side];
    }
#line 1379
    if (maxposnscore[side] > s___1 + s1) {
#line 1379
      maxposnscore[side] = maxposnscore[side];
    } else {
#line 1379
      maxposnscore[side] = s___1 + s1;
    }
#line 1380
    score = (s___1 + s1) + (board.material[side] - board.material[1 ^ side]);
  }
  next: 
#line 1389
  if (board.material[side] - board.material[1 ^ side] >= 200) {
    {
    {
#line 1391
    tmp___16 = nbits(pieces[0] | pieces[1]);
    }
#line 1391
    score += (RootPieces - tmp___16) * 4;
    {
#line 1392
    tmp___17 = nbits(board.b[0][1] | board.b[1][1]);
    }
#line 1392
    score -= (RootPawns - tmp___17) * 8;
    }
  } else
#line 1395
  if (board.material[side] - board.material[1 ^ side] <= -200) {
    {
    {
#line 1397
    tmp___18 = nbits(pieces[0] | pieces[1]);
    }
#line 1397
    score -= (RootPieces - tmp___18) * 4;
    {
#line 1398
    tmp___19 = nbits(board.b[0][1] | board.b[1][1]);
    }
#line 1398
    score += (RootPawns - tmp___19) * 8;
    }
  }
#line 1407
  if (phase >= 6) {
#line 1407
    if (pieces[0] == board.b[0][3]) {
#line 1407
      if (pieces[1] == board.b[1][3]) {
#line 1407
        if ((unsigned long long )pieces[0] & 6172840429334713770ULL) {
#line 1407
          if ((unsigned long long )pieces[1] & 0xaa55aa55aa55aa55ULL) {
#line 1412
            score /= 2;
          } else {
#line 1407
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1407
        if ((unsigned long long )pieces[0] & 0xaa55aa55aa55aa55ULL) {
#line 1407
          if ((unsigned long long )pieces[1] & 6172840429334713770ULL) {
#line 1412
            score /= 2;
          }
        }
      }
    }
  }
#line 1420
  if (score > 0) {
#line 1420
    if (! board.b[side][1]) {
#line 1420
      if (board.material[side] < 550) {
#line 1422
        score = 0;
      } else
#line 1420
      if (pieces[side] == board.b[side][2]) {
#line 1422
        score = 0;
      }
    }
  }
#line 1423
  if (score < 0) {
#line 1423
    if (! board.b[xside][1]) {
#line 1423
      if (board.material[xside] < 550) {
#line 1425
        score = 0;
      } else
#line 1423
      if (pieces[xside] == board.b[xside][2]) {
#line 1425
        score = 0;
      }
    }
  }
#line 1427
  return (score);
}
}
#line 1431 "/home/khheo/testset/chess/src/eval.c"
int EvaluateDraw(void) 
{ 
  BitBoard *w ;
  BitBoard *b ;
  int wm ;
  int bm ;
  int wn ;
  int bn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1447
  w = board.b[0];
#line 1448
  b = board.b[1];
#line 1449
  if (*(w + 1) != 0UL) {
#line 1450
    return (0);
  } else
#line 1449
  if (*(b + 1) != 0UL) {
#line 1450
    return (0);
  }
  {
#line 1452
  wm = board.material[0];
#line 1453
  bm = board.material[1];
  {
#line 1454
  wn = nbits(*(w + 2));
  }
  {
#line 1455
  bn = nbits(*(b + 2));
  }
  }
#line 1456
  if (wm < 550) {
#line 1456
    goto _L;
  } else
#line 1456
  if (wm == 700) {
#line 1456
    if (wn == 2) {
      _L: /* CIL Label */ 
#line 1456
      if (bm < 550) {
#line 1458
        return (1);
      } else
#line 1456
      if (bm == 700) {
#line 1456
        if (bn == 2) {
#line 1458
          return (1);
        }
      }
    }
  }
#line 1460
  if (wm < 550) {
#line 1462
    if (bm == 700) {
      {
      {
#line 1462
      tmp = nbits((BitBoard )((unsigned long long )board.b[1][3] & 6172840429334713770ULL));
      }
      }
#line 1462
      if (tmp == 2) {
#line 1465
        return (1);
      } else {
        {
        {
#line 1462
        tmp___0 = nbits((BitBoard )((unsigned long long )board.b[1][3] & 0xaa55aa55aa55aa55ULL));
        }
        }
#line 1462
        if (tmp___0 == 2) {
#line 1465
          return (1);
        }
      }
    }
  }
#line 1467
  if (bm < 550) {
#line 1469
    if (wm == 700) {
      {
      {
#line 1469
      tmp___1 = nbits((BitBoard )((unsigned long long )board.b[0][3] & 6172840429334713770ULL));
      }
      }
#line 1469
      if (tmp___1 == 2) {
#line 1472
        return (1);
      } else {
        {
        {
#line 1469
        tmp___2 = nbits((BitBoard )((unsigned long long )board.b[0][3] & 0xaa55aa55aa55aa55ULL));
        }
        }
#line 1469
        if (tmp___2 == 2) {
#line 1472
          return (1);
        }
      }
    }
  }
#line 1475
  return (0);
}
}
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 116
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 537 "/home/khheo/testset/chess/src/common.h"
int ParseEPD(char *p___1 ) ;
#line 538
void LoadEPD(char *p___1 ) ;
#line 539
void SaveEPD(char *p___1 ) ;
#line 49 "/home/khheo/testset/chess/src/epd.c"
static FILE *fp  =    (FILE *)((void *)0);
#line 36 "/home/khheo/testset/chess/src/epd.c"
int ReadEPDFile(char const   *file___0 , int op ) 
{ 
  char line[1025] ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 53
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 55
    fp = fopen((char const   */* __restrict  */)file___0, (char const   */* __restrict  */)"r");
    }
    }
#line 56
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
      {
#line 58
      printf((char const   */* __restrict  */)"Error opening file %s\n", file___0);
      }
      }
#line 59
      return (0);
    }
  }
#line 64
  if (op == 1) {
    {
    {
#line 66
    fclose(fp);
    }
#line 67
    fp = (FILE *)((void *)0);
    }
#line 68
    return (0);
  }
  next_line: 
  {
  {
#line 73
  fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)fp);
  }
  {
#line 74
  tmp___0 = feof(fp);
  }
  }
#line 74
  if (tmp___0) {
    {
    {
#line 87
    fclose(fp);
    }
#line 88
    fp = (FILE *)((void *)0);
    }
#line 89
    return (0);
  } else {
    {
    {
#line 76
    tmp = ParseEPD(line);
    }
#line 76
    ret = tmp;
    }
#line 79
    if (ret != 0) {
#line 79
      goto next_line;
    }
#line 80
    if (op != 2) {
      {
      {
#line 81
      printf((char const   */* __restrict  */)"\n%s : Best move = %s\n", id, solution);
      }
      }
    }
#line 82
    return (1);
  }
}
}
#line 100 "/home/khheo/testset/chess/src/epd.c"
int ParseEPD(char *p___1 ) 
{ 
  int r ;
  int c ;
  int sq ;
  char *str_p ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 111
  r = 56;
#line 112
  c = 0;
  {
#line 113
  memset((void *)(& board), 0, sizeof(board));
  }
  }
  {
  {
#line 115
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 115
    if (p___1) {
#line 115
      if (! ((int )*p___1 != 32)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 117
    sq = r + c;
    {
#line 120
    if ((int )*p___1 == 80) {
#line 120
      goto case_80;
    }
#line 126
    if ((int )*p___1 == 78) {
#line 126
      goto case_78;
    }
#line 132
    if ((int )*p___1 == 66) {
#line 132
      goto case_66;
    }
#line 138
    if ((int )*p___1 == 82) {
#line 138
      goto case_82;
    }
#line 144
    if ((int )*p___1 == 81) {
#line 144
      goto case_81;
    }
#line 150
    if ((int )*p___1 == 75) {
#line 150
      goto case_75;
    }
#line 155
    if ((int )*p___1 == 112) {
#line 155
      goto case_112;
    }
#line 161
    if ((int )*p___1 == 110) {
#line 161
      goto case_110;
    }
#line 167
    if ((int )*p___1 == 98) {
#line 167
      goto case_98;
    }
#line 173
    if ((int )*p___1 == 114) {
#line 173
      goto case_114;
    }
#line 179
    if ((int )*p___1 == 113) {
#line 179
      goto case_113;
    }
#line 185
    if ((int )*p___1 == 107) {
#line 185
      goto case_107;
    }
#line 190
    if ((int )*p___1 == 47) {
#line 190
      goto case_47;
    }
#line 193
    goto switch_default;
    case_80: /* CIL Label */ 
#line 120
    board.b[0][1] |= BitPosArray[sq];
#line 121
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 122
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 123
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 124
    board.material[0] += 100;
#line 125
    goto switch_break;
    case_78: /* CIL Label */ 
#line 126
    board.b[0][2] |= BitPosArray[sq];
#line 127
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 128
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 129
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 130
    board.material[0] += 350;
#line 131
    goto switch_break;
    case_66: /* CIL Label */ 
#line 132
    board.b[0][3] |= BitPosArray[sq];
#line 133
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 134
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 135
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 136
    board.material[0] += 350;
#line 137
    goto switch_break;
    case_82: /* CIL Label */ 
#line 138
    board.b[0][4] |= BitPosArray[sq];
#line 139
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 140
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 141
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 142
    board.material[0] += 550;
#line 143
    goto switch_break;
    case_81: /* CIL Label */ 
#line 144
    board.b[0][5] |= BitPosArray[sq];
#line 145
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 146
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 147
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 148
    board.material[0] += 1100;
#line 149
    goto switch_break;
    case_75: /* CIL Label */ 
#line 150
    board.b[0][6] |= BitPosArray[sq];
#line 151
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 152
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 153
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 154
    goto switch_break;
    case_112: /* CIL Label */ 
#line 155
    board.b[1][1] |= BitPosArray[sq];
#line 156
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 157
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 158
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 159
    board.material[1] += 100;
#line 160
    goto switch_break;
    case_110: /* CIL Label */ 
#line 161
    board.b[1][2] |= BitPosArray[sq];
#line 162
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 163
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 164
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 165
    board.material[1] += 350;
#line 166
    goto switch_break;
    case_98: /* CIL Label */ 
#line 167
    board.b[1][3] |= BitPosArray[sq];
#line 168
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 169
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 170
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 171
    board.material[1] += 350;
#line 172
    goto switch_break;
    case_114: /* CIL Label */ 
#line 173
    board.b[1][4] |= BitPosArray[sq];
#line 174
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 175
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 176
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 177
    board.material[1] += 550;
#line 178
    goto switch_break;
    case_113: /* CIL Label */ 
#line 179
    board.b[1][5] |= BitPosArray[sq];
#line 180
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 181
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 182
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 183
    board.material[1] += 1100;
#line 184
    goto switch_break;
    case_107: /* CIL Label */ 
#line 185
    board.b[1][6] |= BitPosArray[sq];
#line 186
    board.blockerr90 |= BitPosArray[r90[sq]];
#line 187
    board.blockerr45 |= BitPosArray[r45[sq]];
#line 188
    board.blockerr315 |= BitPosArray[r315[sq]];
#line 189
    goto switch_break;
    case_47: /* CIL Label */ 
#line 190
    r -= 8;
#line 191
    c = -1;
#line 192
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 193
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
    {
#line 195
    tmp = __ctype_b_loc();
    }
    }
#line 195
    if ((int const   )*(*tmp + (int )*p___1) & 2048) {
#line 196
      c += (int )*p___1 - 48;
    } else {
#line 198
      c ++;
    }
#line 199
    if (r < 0) {
#line 199
      return (1);
    } else
#line 199
    if (c > 8) {
#line 199
      return (1);
    }
#line 200
    if (c == 8) {
#line 200
      if ((int )*(p___1 + 1) != 47) {
#line 200
        if ((int )*(p___1 + 1) != 32) {
#line 200
          return (1);
        }
      }
    }
#line 201
    p___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 204
  tmp___0 = nbits(board.b[0][1]);
  }
#line 204
  board.pmaterial[0] = board.material[0] - tmp___0 * 100;
  {
#line 206
  tmp___1 = nbits(board.b[1][1]);
  }
#line 206
  board.pmaterial[1] = board.material[1] - tmp___1 * 100;
  {
#line 208
  board.king[0] = leadz(board.b[0][6]);
  }
  {
#line 209
  board.king[1] = leadz(board.b[1][6]);
  }
  {
#line 210
  UpdateFriends();
  }
  {
#line 211
  UpdateCBoard();
  }
  {
#line 212
  UpdateMvboard();
  }
#line 215
  p___1 ++;
  }
#line 215
  if (! p___1) {
#line 215
    return (1);
  }
#line 216
  if ((int )*p___1 == 119) {
#line 216
    board.side = 0;
  } else
#line 217
  if ((int )*p___1 == 98) {
#line 217
    board.side = 1;
  } else {
#line 218
    return (1);
  }
#line 221
  p___1 ++;
#line 221
  if (p___1) {
#line 221
    if ((int )*p___1 != 32) {
#line 221
      return (1);
    } else {
#line 221
      p___1 ++;
#line 221
      if (! p___1) {
#line 221
        return (1);
      }
    }
  } else {
#line 221
    return (1);
  }
  {
  {
#line 224
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 224
    if (p___1) {
#line 224
      if (! ((int )*p___1 != 32)) {
#line 224
        goto while_break___0;
      }
    } else {
#line 224
      goto while_break___0;
    }
#line 225
    if ((int )*p___1 == 75) {
#line 225
      board.flag |= 1;
    } else
#line 226
    if ((int )*p___1 == 81) {
#line 226
      board.flag |= 2;
    } else
#line 227
    if ((int )*p___1 == 107) {
#line 227
      board.flag |= 4;
    } else
#line 228
    if ((int )*p___1 == 113) {
#line 228
      board.flag |= 8;
    } else
#line 229
    if ((int )*p___1 == 45) {
#line 229
      p___1 ++;
#line 229
      goto while_break___0;
    } else {
#line 230
      return (1);
    }
#line 231
    p___1 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 233
  if (! p___1) {
#line 233
    return (1);
  } else
#line 233
  if ((int )*p___1 != 32) {
#line 233
    return (1);
  } else {
#line 233
    p___1 ++;
#line 233
    if (! p___1) {
#line 233
      return (1);
    }
  }
#line 239
  if ((int )*p___1 != 45) {
#line 240
    if (! *(p___1 + 1)) {
#line 241
      return (1);
    } else
#line 240
    if ((int )*p___1 < 97) {
#line 241
      return (1);
    } else
#line 240
    if ((int )*p___1 > 104) {
#line 241
      return (1);
    } else
#line 240
    if (! ((int )*(p___1 + 1) == 51)) {
#line 240
      if (! ((int )*(p___1 + 1) == 54)) {
#line 241
        return (1);
      }
    }
#line 242
    board.ep = ((int )*p___1 - 97) + ((int )*(p___1 + 1) - 49) * 8;
#line 243
    p___1 ++;
  } else {
#line 245
    board.ep = -1;
  }
#line 248
  solution[0] = (char )'\000';
#line 249
  id[0] = (char )'\000';
#line 251
  p___1 ++;
#line 251
  if (! p___1) {
#line 251
    return (0);
  }
  {
  {
#line 256
  str_p = strstr((char const   *)p___1, "bm");
  }
  }
#line 257
  if (str_p) {
    {
    {
#line 257
    sscanf((char const   */* __restrict  */)str_p, (char const   */* __restrict  */)"bm %63[^;];",
           solution);
    }
    }
  }
  {
  {
#line 260
  str_p = strstr((char const   *)p___1, "id");
  }
  }
#line 261
  if (str_p) {
    {
    {
#line 261
    sscanf((char const   */* __restrict  */)p___1, (char const   */* __restrict  */)"id %31[^;];",
           id);
    }
    }
  }
  {
  {
#line 263
  CalcHashKey();
  }
#line 264
  phase = 8 - (board.material[0] + board.material[1]) / 1150;
  }
#line 266
  return (0);
}
}
#line 270 "/home/khheo/testset/chess/src/epd.c"
void LoadEPD(char *p___1 ) 
{ 
  char file___0[128] ;
  int N ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 278
  N = 1;
  {
#line 280
  sscanf((char const   */* __restrict  */)p___1, (char const   */* __restrict  */)"%31s %d ",
         file___0, & N);
  }
  {
#line 281
  tmp___0 = strcmp((char const   *)(file___0), "next");
  }
  }
#line 281
  if (tmp___0 == 0) {
    {
    {
#line 283
    ReadEPDFile((char const   *)(file___0), 0);
    }
    }
  } else {
    {
    {
#line 287
    ReadEPDFile((char const   *)(file___0), 1);
    }
    }
    {
    {
#line 288
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 288
      N --;
#line 288
      if (! N) {
#line 288
        goto while_break;
      }
      {
      {
#line 290
      tmp = ReadEPDFile((char const   *)(file___0), 2);
      }
      }
#line 290
      if (tmp == 0) {
        {
        {
#line 292
        printf((char const   */* __restrict  */)"File position exceeded\n");
        }
        }
#line 293
        return;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 296
    ReadEPDFile((char const   *)(file___0), 0);
    }
    }
  }
  {
  {
#line 298
  ShowBoard();
  }
  {
#line 299
  NewPosition();
  }
  }
#line 300
  return;
}
}
#line 303 "/home/khheo/testset/chess/src/epd.c"
void SaveEPD(char *p___1 ) 
{ 
  char file___0[128] ;
  FILE *fp___0 ;
  int r ;
  int c ;
  int sq ;
  int k___0 ;
  char c1 ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
  {
#line 315
  sscanf((char const   */* __restrict  */)p___1, (char const   */* __restrict  */)"%s ",
         file___0);
  }
  {
#line 316
  fp___0 = fopen((char const   */* __restrict  */)(file___0), (char const   */* __restrict  */)"a");
  }
#line 317
  r = 56;
  }
  {
  {
#line 317
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 317
    if (! (r >= 0)) {
#line 317
      goto while_break;
    }
#line 319
    k___0 = 0;
#line 320
    c = 0;
    {
    {
#line 320
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 320
      if (! (c < 8)) {
#line 320
        goto while_break___0;
      }
#line 322
      sq = r + c;
#line 323
      if (cboard[sq] == 0) {
#line 324
        k___0 ++;
      } else {
#line 327
        if (k___0) {
          {
          {
#line 328
          fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%1d",
                  k___0);
          }
          }
        }
#line 329
        k___0 = 0;
#line 330
        c1 = notation[cboard[sq]];
#line 331
        if (BitPosArray[sq] & board.friends[1]) {
          {
          {
#line 332
          tmp = tolower((int )c1);
          }
#line 332
          c1 = (char )tmp;
          }
        }
        {
        {
#line 333
        fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%c",
                (int )c1);
        }
        }
      }
#line 320
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 336
    if (k___0) {
      {
      {
#line 337
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%1d",
              k___0);
      }
      }
    }
#line 338
    if (r > 0) {
      {
      {
#line 339
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"/");
      }
      }
    }
#line 317
    r -= 8;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (board.side == 0) {
#line 343
    tmp___0 = " w ";
  } else {
#line 343
    tmp___0 = " b ";
  }
  {
  {
#line 343
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)tmp___0);
  }
  }
#line 345
  if (board.flag & 1) {
    {
    {
#line 346
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"K");
    }
    }
  }
#line 347
  if (board.flag & 2) {
    {
    {
#line 348
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"Q");
    }
    }
  }
#line 349
  if (board.flag & 4) {
    {
    {
#line 350
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"k");
    }
    }
  }
#line 351
  if (board.flag & 8) {
    {
    {
#line 352
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"q");
    }
    }
  }
#line 353
  if (! (board.flag & 15)) {
    {
    {
#line 354
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"-");
    }
    }
  }
#line 356
  if (board.ep > -1) {
#line 356
    tmp___1 = (char const   *)(algbr[board.ep]);
  } else {
#line 356
    tmp___1 = "-";
  }
  {
  {
#line 356
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" %s",
          tmp___1);
  }
  {
#line 357
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)" bm 1; id 1;");
  }
  {
#line 358
  fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"\n");
  }
  {
#line 359
  fclose(fp___0);
  }
  }
#line 360
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 795
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 549 "/home/khheo/testset/chess/src/common.h"
void ShowCmd(char *subcmd___0 ) ;
#line 550
void TestCmd(char *subcmd___0 ) ;
#line 641
void ShowHelp(char const   *command ) ;
#line 285 "/usr/include/readline/readline.h"
extern char *readline(char const   * ) ;
#line 84 "/usr/include/readline/history.h"
extern void add_history(char const   * ) ;
#line 50 "/home/khheo/testset/chess/src/cmd.c"
static char *inputstr  ;
#line 55 "/home/khheo/testset/chess/src/cmd.c"
static char cmd[128]  ;
#line 55 "/home/khheo/testset/chess/src/cmd.c"
static char file[128]  ;
#line 55 "/home/khheo/testset/chess/src/cmd.c"
static char s___0[128]  ;
#line 55 "/home/khheo/testset/chess/src/cmd.c"
static char logfile[128]  ;
#line 55 "/home/khheo/testset/chess/src/cmd.c"
static char gamefile[128]  ;
#line 55 "/home/khheo/testset/chess/src/cmd.c"
static char userinput[128]  ;
#line 59 "/home/khheo/testset/chess/src/cmd.c"
char subcmd[128]  ;
#line 59 "/home/khheo/testset/chess/src/cmd.c"
char setting[128]  ;
#line 59 "/home/khheo/testset/chess/src/cmd.c"
char subsetting[128]  ;
#line 61 "/home/khheo/testset/chess/src/cmd.c"
void InputCmd(void) 
{ 
  char const   *color[2] ;
  int suffix ;
  int i ;
  leaf *ptr ;
  int ncmds ;
  char *x___0 ;
  char *trim ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  char const   *tmp___30 ;
  int pvar ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  void *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;

  {
  {
#line 68
  color[0] = "White";
#line 68
  color[1] = "Black";
#line 75
  flags &= 4294967291U;
  {
#line 76
  memset((void *)(userinput), 0, sizeof(userinput));
  }
  {
#line 77
  memset((void *)(cmd), 0, sizeof(cmd));
  }
  {
#line 83
  tmp___2 = isatty(0);
  }
  }
#line 83
  if (tmp___2) {
    {
    {
#line 84
    sprintf((char */* __restrict  */)(s___0), (char const   */* __restrict  */)"%s (%d) %c ",
            color[board.side], (GameCnt + 1) / 2 + 1, ':');
    }
    {
#line 85
    inputstr = readline((char const   *)(s___0));
    }
    }
#line 86
    if ((unsigned long )inputstr == (unsigned long )((void *)0)) {
#line 86
      return;
    }
#line 87
    if (*inputstr) {
      {
      {
#line 88
      add_history((char const   *)inputstr);
      }
      }
    }
    {
    {
#line 90
    tmp = strlen((char const   *)inputstr);
    }
    }
#line 90
    if (tmp > 127UL) {
      {
      {
#line 91
      printf((char const   */* __restrict  */)"Warning: Input line truncated to %d characters.\n",
             127);
      }
#line 92
      *(inputstr + 127) = (char )'\000';
      }
    }
  } else {
    {
    {
#line 95
    tmp___0 = malloc((size_t )128);
    }
#line 95
    inputstr = (char *)tmp___0;
    }
#line 96
    if ((unsigned long )inputstr == (unsigned long )((void *)0)) {
      {
      {
#line 97
      perror("InputCmd");
      }
      {
#line 98
      exit(1);
      }
      }
    }
    {
    {
#line 100
    fgets((char */* __restrict  */)inputstr, 128, (FILE */* __restrict  */)stdin);
    }
    }
#line 101
    if (*(inputstr + 0)) {
      {
      {
#line 102
      tmp___1 = strlen((char const   *)inputstr);
      }
#line 102
      *(inputstr + (tmp___1 - 1UL)) = (char)0;
      }
    }
  }
  {
#line 113
  cmd[0] = (char )'\n';
  {
#line 114
  strcpy((char */* __restrict  */)(userinput), (char const   */* __restrict  */)inputstr);
  }
  {
#line 115
  sscanf((char const   */* __restrict  */)inputstr, (char const   */* __restrict  */)"%s %[^\n]",
         cmd, inputstr);
  }
  }
#line 116
  if ((int )cmd[0] == 10) {
#line 117
    goto done;
  }
  {
#line 118
  subsetting[0] = (char )'\000';
#line 118
  setting[0] = subsetting[0];
#line 118
  subcmd[0] = setting[0];
#line 118
  cmd[0] = subcmd[0];
  {
#line 119
  ncmds = sscanf((char const   */* __restrict  */)(userinput), (char const   */* __restrict  */)"%s %s %s %[^\n]",
                 cmd, subcmd, setting, subsetting);
  }
  {
#line 123
  sprintf((char */* __restrict  */)inputstr, (char const   */* __restrict  */)"%s %s %s",
          subcmd, setting, subsetting);
  }
  {
#line 125
  tmp___3 = strlen((char const   *)inputstr);
  }
#line 125
  trim = (inputstr + tmp___3) - 1;
  }
  {
  {
#line 126
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 126
    if ((unsigned long )trim >= (unsigned long )inputstr) {
#line 126
      if (! ((int )*trim == 32)) {
#line 126
        goto while_break;
      }
    } else {
#line 126
      goto while_break;
    }
#line 127
    tmp___4 = trim;
#line 127
    trim --;
#line 127
    *tmp___4 = (char )'\000';
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 129
  tmp___89 = strcmp((char const   *)(cmd), "quit");
  }
  }
#line 129
  if (tmp___89 == 0) {
#line 130
    flags |= 1U;
  } else {
    {
    {
#line 129
    tmp___90 = strcmp((char const   *)(cmd), "exit");
    }
    }
#line 129
    if (tmp___90 == 0) {
#line 130
      flags |= 1U;
    } else {
      {
      {
#line 131
      tmp___88 = strcmp((char const   *)(cmd), "help");
      }
      }
#line 131
      if (tmp___88 == 0) {
        {
        {
#line 132
        ShowHelp((char const   *)inputstr);
        }
        }
      } else {
        {
        {
#line 133
        tmp___87 = strcmp((char const   *)(cmd), "show");
        }
        }
#line 133
        if (tmp___87 == 0) {
          {
          {
#line 134
          ShowCmd(inputstr);
          }
          }
        } else {
          {
          {
#line 135
          tmp___86 = strncmp((char const   *)(cmd), "book", (size_t )4);
          }
          }
#line 135
          if (tmp___86 == 0) {
            {
            {
#line 136
            tmp___12 = strncmp((char const   *)inputstr, "add", (size_t )3);
            }
            }
#line 136
            if (tmp___12 == 0) {
              {
              {
#line 137
              sscanf((char const   */* __restrict  */)inputstr, (char const   */* __restrict  */)"add %s",
                     file);
              }
              {
#line 138
              tmp___5 = access((char const   *)(file), 0);
              }
              }
#line 138
              if (tmp___5 < 0) {
                {
                {
#line 139
                printf((char const   */* __restrict  */)"The syntax to add a new book is:\n\n\tbook add file.pgn\n");
                }
                }
              } else {
                {
                {
#line 141
                BookPGNReadFromFile((char const   *)(file));
                }
                }
              }
            } else {
              {
              {
#line 143
              tmp___10 = strncmp((char const   *)inputstr, "on", (size_t )2);
              }
              }
#line 143
              if (tmp___10 == 0) {
                {
#line 144
                bookmode = 4;
                {
#line 145
                printf((char const   */* __restrict  */)"book now on.\n");
                }
                }
              } else {
                {
                {
#line 143
                tmp___11 = strncmp((char const   *)inputstr, "prefer", (size_t )6);
                }
                }
#line 143
                if (tmp___11 == 0) {
                  {
#line 144
                  bookmode = 4;
                  {
#line 145
                  printf((char const   */* __restrict  */)"book now on.\n");
                  }
                  }
                } else {
                  {
                  {
#line 146
                  tmp___9 = strncmp((char const   *)inputstr, "off", (size_t )3);
                  }
                  }
#line 146
                  if (tmp___9 == 0) {
                    {
#line 147
                    bookmode = 0;
                    {
#line 148
                    printf((char const   */* __restrict  */)"book now off.\n");
                    }
                    }
                  } else {
                    {
                    {
#line 149
                    tmp___8 = strncmp((char const   *)inputstr, "best", (size_t )4);
                    }
                    }
#line 149
                    if (tmp___8 == 0) {
                      {
#line 150
                      bookmode = 2;
                      {
#line 151
                      printf((char const   */* __restrict  */)"book now best.\n");
                      }
                      }
                    } else {
                      {
                      {
#line 152
                      tmp___7 = strncmp((char const   *)inputstr, "worst", (size_t )5);
                      }
                      }
#line 152
                      if (tmp___7 == 0) {
                        {
#line 153
                        bookmode = 3;
                        {
#line 154
                        printf((char const   */* __restrict  */)"book now worst.\n");
                        }
                        }
                      } else {
                        {
                        {
#line 155
                        tmp___6 = strncmp((char const   *)inputstr, "random", (size_t )6);
                        }
                        }
#line 155
                        if (tmp___6 == 0) {
                          {
#line 156
                          bookmode = 1;
                          {
#line 157
                          printf((char const   */* __restrict  */)"book now random.\n");
                          }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            {
            {
#line 159
            tmp___85 = strcmp((char const   *)(cmd), "test");
            }
            }
#line 159
            if (tmp___85 == 0) {
              {
              {
#line 160
              TestCmd(inputstr);
              }
              }
            } else {
              {
              {
#line 161
              tmp___84 = strcmp((char const   *)(cmd), "version");
              }
              }
#line 161
              if (tmp___84 == 0) {
                {
                {
#line 162
                ShowVersion();
                }
                }
              } else {
                {
                {
#line 163
                tmp___83 = strcmp((char const   *)(cmd), "pgnsave");
                }
                }
#line 163
                if (tmp___83 == 0) {
                  {
                  {
#line 165
                  tmp___13 = strlen((char const   *)inputstr);
                  }
                  }
#line 165
                  if (tmp___13 > 0UL) {
                    {
                    {
#line 165
                    tmp___14 = strlen((char const   *)inputstr);
                    }
                    }
#line 165
                    if (tmp___14 < 128UL) {
                      {
                      {
#line 166
                      PGNSaveToFile((char const   *)inputstr, "");
                      }
                      }
                    } else {
                      {
                      {
#line 168
                      printf((char const   */* __restrict  */)"Invalid filename.\n");
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 168
                    printf((char const   */* __restrict  */)"Invalid filename.\n");
                    }
                    }
                  }
                } else {
                  {
                  {
#line 170
                  tmp___82 = strcmp((char const   *)(cmd), "pgnload");
                  }
                  }
#line 170
                  if (tmp___82 == 0) {
                    {
                    {
#line 171
                    PGNReadFromFile((char const   *)inputstr);
                    }
                    }
                  } else {
                    {
                    {
#line 172
                    tmp___81 = strcmp((char const   *)(cmd), "manual");
                    }
                    }
#line 172
                    if (tmp___81 == 0) {
#line 173
                      flags |= 8U;
                    } else {
                      {
                      {
#line 174
                      tmp___80 = strcmp((char const   *)(cmd), "debug");
                      }
                      }
#line 174
                      if (tmp___80 == 0) {
                        {
#line 176
                        flags |= 32U;
#line 177
                        Debugmvl = 0;
                        {
#line 178
                        tmp___17 = strcmp((char const   *)inputstr, "debug");
                        }
                        }
#line 178
                        if (tmp___17 == 0) {
                          {
                          {
#line 180
                          while (1) {
                            while_continue___6: /* CIL Label */ ;
                            while_continue___0: /* CIL Label */ ;
                            {
                            {
#line 180
                            tmp___16 = strcmp((char const   *)inputstr, (char const   *)(s___0));
                            }
                            }
#line 180
                            if (! tmp___16) {
#line 180
                              goto while_break___0;
                            }
                            {
                            {
#line 182
                            sscanf((char const   */* __restrict  */)inputstr, (char const   */* __restrict  */)"%s %[^\n]",
                                   s___0, inputstr);
                            }
                            {
#line 183
                            ptr = ValidateMove(s___0);
                            }
#line 184
                            tmp___15 = Debugmvl;
#line 184
                            Debugmvl ++;
#line 184
                            Debugmv[tmp___15] = ptr->move;
                            {
#line 185
                            MakeMove(board.side, & ptr->move);
                            }
                            }
                          }
                          while_break___6: /* CIL Label */ ;
                          }
                          while_break___0: /* CIL Label */ ;
                          }
#line 187
                          i = Debugmvl;
                          {
                          {
#line 188
                          while (1) {
                            while_continue___7: /* CIL Label */ ;
                            while_continue___1: /* CIL Label */ ;
#line 188
                            if (! i) {
#line 188
                              goto while_break___1;
                            }
                            {
#line 190
                            i --;
                            {
#line 190
                            UnmakeMove(board.side, & Debugmv[i]);
                            }
                            }
                          }
                          while_break___7: /* CIL Label */ ;
                          }
                          while_break___1: /* CIL Label */ ;
                          }
                        }
                      } else {
                        {
                        {
#line 194
                        tmp___79 = strcmp((char const   *)(cmd), "force");
                        }
                        }
#line 194
                        if (tmp___79 == 0) {
#line 195
                          flags |= 8U;
                        } else {
                          {
                          {
#line 196
                          tmp___78 = strcmp((char const   *)(cmd), "white");
                          }
                          }
#line 196
                          if (! (tmp___78 == 0)) {
                            {
                            {
#line 198
                            tmp___77 = strcmp((char const   *)(cmd), "black");
                            }
                            }
#line 198
                            if (! (tmp___77 == 0)) {
                              {
                              {
#line 200
                              tmp___76 = strcmp((char const   *)(cmd), "hard");
                              }
                              }
#line 200
                              if (! (tmp___76 == 0)) {
                                {
                                {
#line 202
                                tmp___75 = strcmp((char const   *)(cmd), "easy");
                                }
                                }
#line 202
                                if (! (tmp___75 == 0)) {
                                  {
                                  {
#line 204
                                  tmp___74 = strcmp((char const   *)(cmd), "list");
                                  }
                                  }
#line 204
                                  if (tmp___74 == 0) {
#line 205
                                    if ((int )*(inputstr + 0) == 63) {
                                      {
                                      {
#line 207
                                      printf((char const   */* __restrict  */)"name    - list known players alphabetically\n");
                                      }
                                      {
#line 208
                                      printf((char const   */* __restrict  */)"score   - list by GNU best result first \n");
                                      }
                                      {
#line 209
                                      printf((char const   */* __restrict  */)"reverse - list by GNU worst result first\n");
                                      }
                                      }
                                    } else {
                                      {
                                      {
#line 211
                                      sscanf((char const   */* __restrict  */)inputstr,
                                             (char const   */* __restrict  */)"%s %[^\n]",
                                             cmd, inputstr);
                                      }
                                      }
#line 212
                                      if ((unsigned long )inputstr == (unsigned long )((char *)0)) {
                                        {
                                        {
#line 212
                                        DBListPlayer("rscore");
                                        }
                                        }
                                      } else {
                                        {
                                        {
#line 213
                                        DBListPlayer((char const   *)inputstr);
                                        }
                                        }
                                      }
                                    }
                                  } else {
                                    {
                                    {
#line 216
                                    tmp___73 = strcmp((char const   *)(cmd), "post");
                                    }
                                    }
#line 216
                                    if (tmp___73 == 0) {
#line 217
                                      flags |= 4096U;
                                    } else {
                                      {
                                      {
#line 218
                                      tmp___72 = strcmp((char const   *)(cmd), "nopost");
                                      }
                                      }
#line 218
                                      if (tmp___72 == 0) {
#line 219
                                        flags &= 4294963199U;
                                      } else {
                                        {
                                        {
#line 220
                                        tmp___71 = strcmp((char const   *)(cmd), "name");
                                        }
                                        }
#line 220
                                        if (tmp___71 == 0) {
                                          {
                                          {
#line 221
                                          strcpy((char */* __restrict  */)(name),
                                                 (char const   */* __restrict  */)inputstr);
                                          }
#line 222
                                          x___0 = name;
                                          }
                                          {
                                          {
#line 223
                                          while (1) {
                                            while_continue___8: /* CIL Label */ ;
                                            while_continue___2: /* CIL Label */ ;
#line 223
                                            if (! ((int )*x___0 != 0)) {
#line 223
                                              goto while_break___2;
                                            }
#line 224
                                            if ((int )*x___0 == 32) {
#line 225
                                              *x___0 = (char )'\000';
#line 226
                                              goto while_break___2;
                                            }
#line 228
                                            x___0 ++;
                                          }
                                          while_break___8: /* CIL Label */ ;
                                          }
                                          while_break___2: /* CIL Label */ ;
                                          }
#line 230
                                          suffix = 0;
                                          {
                                          {
#line 231
                                          while (1) {
                                            while_continue___9: /* CIL Label */ ;
                                            while_continue___3: /* CIL Label */ ;
                                            {
                                            {
#line 232
                                            sprintf((char */* __restrict  */)(logfile),
                                                    (char const   */* __restrict  */)"log.%03d",
                                                    suffix);
                                            }
                                            {
#line 233
                                            sprintf((char */* __restrict  */)(gamefile),
                                                    (char const   */* __restrict  */)"game.%03d",
                                                    suffix);
                                            }
                                            {
#line 234
                                            tmp___18 = access((char const   *)(logfile),
                                                              0);
                                            }
                                            }
#line 234
                                            if (tmp___18 < 0) {
                                              {
                                              {
#line 235
                                              ofp = fopen((char const   */* __restrict  */)(logfile),
                                                          (char const   */* __restrict  */)"w");
                                              }
                                              }
#line 236
                                              goto while_break___3;
                                            } else {
#line 238
                                              suffix ++;
                                            }
                                          }
                                          while_break___9: /* CIL Label */ ;
                                          }
                                          while_break___3: /* CIL Label */ ;
                                          }
                                        } else {
                                          {
                                          {
#line 241
                                          tmp___70 = strcmp((char const   *)(cmd),
                                                            "result");
                                          }
                                          }
#line 241
                                          if (tmp___70 == 0) {
#line 242
                                            if ((unsigned long )ofp != (unsigned long )stdout) {
                                              {
                                              {
#line 243
                                              fprintf((FILE */* __restrict  */)ofp,
                                                      (char const   */* __restrict  */)"result: %s\n",
                                                      inputstr);
                                              }
                                              {
#line 244
                                              fclose(ofp);
                                              }
#line 245
                                              ofp = stdout;
                                              {
#line 246
                                              printf((char const   */* __restrict  */)"Save to %s\n",
                                                     gamefile);
                                              }
                                              {
#line 247
                                              PGNSaveToFile((char const   *)(gamefile),
                                                            (char const   *)inputstr);
                                              }
                                              {
#line 248
                                              DBUpdatePlayer((char const   *)(name),
                                                             (char const   *)inputstr);
                                              }
                                              }
                                            }
                                          } else {
                                            {
                                            {
#line 251
                                            tmp___69 = strcmp((char const   *)(cmd),
                                                              "rating");
                                            }
                                            }
#line 251
                                            if (tmp___69 == 0) {
                                              {
                                              {
#line 252
                                              sscanf((char const   */* __restrict  */)inputstr,
                                                     (char const   */* __restrict  */)"%d %d",
                                                     & myrating, & opprating);
                                              }
                                              {
#line 253
                                              fprintf((FILE */* __restrict  */)ofp,
                                                      (char const   */* __restrict  */)"my rating = %d, opponent rating = %d\n",
                                                      myrating, opprating);
                                              }
                                              }
#line 256
                                              if (opprating >= 1700) {
#line 256
                                                bookfirstlast = 2;
                                              } else
#line 257
                                              if (opprating >= 1700) {
#line 257
                                                bookfirstlast = 2;
                                              } else {
#line 258
                                                bookfirstlast = 2;
                                              }
                                            } else {
                                              {
                                              {
#line 260
                                              tmp___68 = strcmp((char const   *)(cmd),
                                                                "activate");
                                              }
                                              }
#line 260
                                              if (tmp___68 == 0) {
#line 261
                                                flags &= 4294967279U;
#line 262
                                                flags &= 4294967231U;
                                              } else {
                                                {
                                                {
#line 264
                                                tmp___67 = strcmp((char const   *)(cmd),
                                                                  "new");
                                                }
                                                }
#line 264
                                                if (tmp___67 == 0) {
                                                  {
                                                  {
#line 265
                                                  InitVars();
                                                  }
                                                  {
#line 266
                                                  NewPosition();
                                                  }
#line 267
                                                  flags &= 4294967287U;
#line 268
                                                  flags &= 4294967291U;
#line 269
                                                  opprating = 0;
#line 269
                                                  myrating = opprating;
                                                  }
                                                } else {
                                                  {
                                                  {
#line 271
                                                  tmp___66 = strcmp((char const   *)(cmd),
                                                                    "time");
                                                  }
                                                  }
#line 271
                                                  if (tmp___66 == 0) {
                                                    {
                                                    {
#line 272
                                                    sscanf((char const   */* __restrict  */)inputstr,
                                                           (char const   */* __restrict  */)"%s %[^\n]",
                                                           s___0, inputstr);
                                                    }
                                                    {
#line 273
                                                    tmp___19 = atoi((char const   *)(s___0));
                                                    }
#line 273
                                                    TimeLimit[1 ^ board.side] = (float )tmp___19 / 100.0f;
                                                    }
                                                  } else {
                                                    {
                                                    {
#line 275
                                                    tmp___65 = strcmp((char const   *)(cmd),
                                                                      "otim");
                                                    }
                                                    }
#line 275
                                                    if (! (tmp___65 == 0)) {
                                                      {
                                                      {
#line 277
                                                      tmp___64 = strcmp((char const   *)(cmd),
                                                                        "random");
                                                      }
                                                      }
#line 277
                                                      if (! (tmp___64 == 0)) {
                                                        {
                                                        {
#line 279
                                                        tmp___63 = strcmp((char const   *)(cmd),
                                                                          "hash");
                                                        }
                                                        }
#line 279
                                                        if (tmp___63 == 0) {
                                                          {
                                                          {
#line 281
                                                          sscanf((char const   */* __restrict  */)inputstr,
                                                                 (char const   */* __restrict  */)"%s %[^\n]",
                                                                 cmd, inputstr);
                                                          }
                                                          {
#line 282
                                                          tmp___21 = strcmp((char const   *)(cmd),
                                                                            "off");
                                                          }
                                                          }
#line 282
                                                          if (tmp___21 == 0) {
#line 283
                                                            flags &= 4294967167U;
                                                          } else {
                                                            {
                                                            {
#line 284
                                                            tmp___20 = strcmp((char const   *)(cmd),
                                                                              "on");
                                                            }
                                                            }
#line 284
                                                            if (tmp___20 == 0) {
#line 285
                                                              flags |= 128U;
                                                            }
                                                          }
#line 286
                                                          if (flags & 128U) {
#line 286
                                                            tmp___22 = "on";
                                                          } else {
#line 286
                                                            tmp___22 = "off";
                                                          }
                                                          {
                                                          {
#line 286
                                                          printf((char const   */* __restrict  */)"Hashing %s\n",
                                                                 tmp___22);
                                                          }
                                                          }
                                                        } else {
                                                          {
                                                          {
#line 288
                                                          tmp___62 = strcmp((char const   *)(cmd),
                                                                            "hashsize");
                                                          }
                                                          }
#line 288
                                                          if (tmp___62 == 0) {
#line 290
                                                            if ((int )*(inputstr + 0) == 0) {
                                                              {
                                                              {
#line 291
                                                              printf((char const   */* __restrict  */)"Current HashSize is %u slots\n",
                                                                     HashSize);
                                                              }
                                                              }
                                                            } else {
                                                              {
                                                              {
#line 293
                                                              i = atoi((char const   *)inputstr);
                                                              }
#line 294
                                                              TTHashMask = 0UL;
                                                              }
                                                              {
                                                              {
#line 295
                                                              while (1) {
                                                                while_continue___10: /* CIL Label */ ;
                                                                while_continue___4: /* CIL Label */ ;
#line 295
                                                                i >>= 1;
#line 295
                                                                if (! (i > 0)) {
#line 295
                                                                  goto while_break___4;
                                                                }
#line 297
                                                                TTHashMask <<= 1;
#line 298
                                                                TTHashMask |= 1UL;
                                                              }
                                                              while_break___10: /* CIL Label */ ;
                                                              }
                                                              while_break___4: /* CIL Label */ ;
                                                              }
                                                              {
#line 300
                                                              HashSize = (unsigned int )(TTHashMask + 1UL);
                                                              {
#line 301
                                                              printf((char const   */* __restrict  */)"Adjusting HashSize to %u slots\n",
                                                                     HashSize);
                                                              }
                                                              {
#line 302
                                                              InitHashTable();
                                                              }
                                                              }
                                                            }
                                                          } else {
                                                            {
                                                            {
#line 305
                                                            tmp___61 = strcmp((char const   *)(cmd),
                                                                              "null");
                                                            }
                                                            }
#line 305
                                                            if (tmp___61 == 0) {
                                                              {
                                                              {
#line 307
                                                              sscanf((char const   */* __restrict  */)inputstr,
                                                                     (char const   */* __restrict  */)"%s %[^\n]",
                                                                     cmd, inputstr);
                                                              }
                                                              {
#line 308
                                                              tmp___24 = strcmp((char const   *)(cmd),
                                                                                "off");
                                                              }
                                                              }
#line 308
                                                              if (tmp___24 == 0) {
#line 309
                                                                flags &= 4294966783U;
                                                              } else {
                                                                {
                                                                {
#line 310
                                                                tmp___23 = strcmp((char const   *)(cmd),
                                                                                  "on");
                                                                }
                                                                }
#line 310
                                                                if (tmp___23 == 0) {
#line 311
                                                                  flags |= 512U;
                                                                }
                                                              }
#line 312
                                                              if (flags & 512U) {
#line 312
                                                                tmp___25 = "on";
                                                              } else {
#line 312
                                                                tmp___25 = "off";
                                                              }
                                                              {
                                                              {
#line 312
                                                              printf((char const   */* __restrict  */)"Null moves %s\n",
                                                                     tmp___25);
                                                              }
                                                              }
                                                            } else {
                                                              {
                                                              {
#line 314
                                                              tmp___60 = strcmp((char const   *)(cmd),
                                                                                "xboard");
                                                              }
                                                              }
#line 314
                                                              if (tmp___60 == 0) {
                                                                {
                                                                {
#line 316
                                                                sscanf((char const   */* __restrict  */)inputstr,
                                                                       (char const   */* __restrict  */)"%s %[^\n]",
                                                                       cmd, inputstr);
                                                                }
                                                                {
#line 317
                                                                tmp___27 = strcmp((char const   *)(cmd),
                                                                                  "off");
                                                                }
                                                                }
#line 317
                                                                if (tmp___27 == 0) {
#line 318
                                                                  flags &= 4294966271U;
                                                                } else {
                                                                  {
                                                                  {
#line 319
                                                                  tmp___26 = strcmp((char const   *)(cmd),
                                                                                    "on");
                                                                  }
                                                                  }
#line 319
                                                                  if (tmp___26 == 0) {
#line 320
                                                                    flags |= 1024U;
                                                                  } else
#line 321
                                                                  if (! (flags & 1024U)) {
#line 322
                                                                    flags |= 1024U;
                                                                  }
                                                                }
                                                              } else {
                                                                {
                                                                {
#line 325
                                                                tmp___59 = strcmp((char const   *)(cmd),
                                                                                  "protover");
                                                                }
                                                                }
#line 325
                                                                if (tmp___59 == 0) {
#line 327
                                                                  if (flags & 1024U) {
                                                                    {
                                                                    {
#line 329
                                                                    printf((char const   */* __restrict  */)"feature setboard=1 analyze=0 ping=1 draw=0 variants=\"normal\" myname=\"%s %s\" done=1\n",
                                                                           "GNU Chess",
                                                                           "5.05");
                                                                    }
                                                                    {
#line 332
                                                                    fflush(stdout);
                                                                    }
                                                                    }
                                                                  }
                                                                } else {
                                                                  {
                                                                  {
#line 335
                                                                  tmp___57 = strcmp((char const   *)(cmd),
                                                                                    "depth");
                                                                  }
                                                                  }
#line 335
                                                                  if (tmp___57 == 0) {
                                                                    {
                                                                    {
#line 336
                                                                    SearchDepth = atoi((char const   *)inputstr);
                                                                    }
                                                                    {
#line 337
                                                                    printf((char const   */* __restrict  */)"Search to a depth of %d\n",
                                                                           SearchDepth);
                                                                    }
                                                                    }
                                                                  } else {
                                                                    {
                                                                    {
#line 335
                                                                    tmp___58 = strcmp((char const   *)(cmd),
                                                                                      "sd");
                                                                    }
                                                                    }
#line 335
                                                                    if (tmp___58 == 0) {
                                                                      {
                                                                      {
#line 336
                                                                      SearchDepth = atoi((char const   *)inputstr);
                                                                      }
                                                                      {
#line 337
                                                                      printf((char const   */* __restrict  */)"Search to a depth of %d\n",
                                                                             SearchDepth);
                                                                      }
                                                                      }
                                                                    } else {
                                                                      {
                                                                      {
#line 339
                                                                      tmp___56 = strcmp((char const   *)(cmd),
                                                                                        "level");
                                                                      }
                                                                      }
#line 339
                                                                      if (tmp___56 == 0) {
                                                                        {
#line 341
                                                                        SearchDepth = 0;
                                                                        {
#line 342
                                                                        sscanf((char const   */* __restrict  */)inputstr,
                                                                               (char const   */* __restrict  */)"%d %f %d",
                                                                               & TCMove,
                                                                               & TCTime,
                                                                               & TCinc);
                                                                        }
                                                                        }
#line 343
                                                                        if (TCMove == 0) {
                                                                          {
#line 344
                                                                          TCMove = 35;
                                                                          {
#line 345
                                                                          printf((char const   */* __restrict  */)"TCMove = %d\n",
                                                                                 TCMove);
                                                                          }
#line 346
                                                                          suddendeath = 1;
                                                                          }
                                                                        } else {
#line 348
                                                                          suddendeath = 0;
                                                                        }
#line 349
                                                                        if (TCTime == (float )0) {
                                                                          {
#line 350
                                                                          flags |= 2048U;
#line 351
                                                                          SearchTime = (float )TCinc / 2.0f;
                                                                          {
#line 352
                                                                          printf((char const   */* __restrict  */)"Fischer increment of %d seconds\n",
                                                                                 TCinc);
                                                                          }
                                                                          }
                                                                        } else {
#line 356
                                                                          flags |= 2048U;
#line 357
                                                                          MoveLimit[1] = TCMove - (GameCnt + 1) / 2;
#line 357
                                                                          MoveLimit[0] = MoveLimit[1];
#line 358
                                                                          TimeLimit[1] = TCTime * (float )60;
#line 358
                                                                          TimeLimit[0] = TimeLimit[1];
#line 359
                                                                          if (! (flags & 1024U)) {
                                                                            {
                                                                            {
#line 360
                                                                            printf((char const   */* __restrict  */)"Time Control: %d moves in %.2f secs\n",
                                                                                   MoveLimit[0],
                                                                                   (double )TimeLimit[0]);
                                                                            }
                                                                            {
#line 362
                                                                            printf((char const   */* __restrict  */)"Fischer increment of %d seconds\n",
                                                                                   TCinc);
                                                                            }
                                                                            }
                                                                          }
                                                                        }
                                                                      } else {
                                                                        {
                                                                        {
#line 366
                                                                        tmp___54 = strcmp((char const   *)(cmd),
                                                                                          "load");
                                                                        }
                                                                        }
#line 366
                                                                        if (tmp___54 == 0) {
#line 366
                                                                          goto _L___0;
                                                                        } else {
                                                                          {
                                                                          {
#line 366
                                                                          tmp___55 = strcmp((char const   *)(cmd),
                                                                                            "epdload");
                                                                          }
                                                                          }
#line 366
                                                                          if (tmp___55 == 0) {
                                                                            _L___0: /* CIL Label */ 
                                                                            {
                                                                            {
#line 368
                                                                            LoadEPD(inputstr);
                                                                            }
                                                                            {
#line 369
                                                                            tmp___28 = ValidateBoard();
                                                                            }
                                                                            }
#line 369
                                                                            if (! tmp___28) {
                                                                              {
#line 371
                                                                              flags |= 64U;
                                                                              {
#line 372
                                                                              printf((char const   */* __restrict  */)"Board is wrong!\n");
                                                                              }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            {
                                                                            {
#line 375
                                                                            tmp___52 = strcmp((char const   *)(cmd),
                                                                                              "save");
                                                                            }
                                                                            }
#line 375
                                                                            if (tmp___52 == 0) {
#line 375
                                                                              goto _L;
                                                                            } else {
                                                                              {
                                                                              {
#line 375
                                                                              tmp___53 = strcmp((char const   *)(cmd),
                                                                                                "epdsave");
                                                                              }
                                                                              }
#line 375
                                                                              if (tmp___53 == 0) {
                                                                                _L: /* CIL Label */ 
                                                                                {
                                                                                {
#line 377
                                                                                tmp___29 = strlen((char const   *)inputstr);
                                                                                }
                                                                                }
#line 377
                                                                                if (tmp___29 > 0UL) {
                                                                                  {
                                                                                  {
#line 378
                                                                                  SaveEPD(inputstr);
                                                                                  }
                                                                                  }
                                                                                } else {
                                                                                  {
                                                                                  {
#line 380
                                                                                  printf((char const   */* __restrict  */)"Invalid filename.\n");
                                                                                  }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                {
                                                                                {
#line 382
                                                                                tmp___51 = strcmp((char const   *)(cmd),
                                                                                                  "epd");
                                                                                }
                                                                                }
#line 382
                                                                                if (tmp___51 == 0) {
                                                                                  {
                                                                                  {
#line 384
                                                                                  ParseEPD(inputstr);
                                                                                  }
                                                                                  {
#line 385
                                                                                  NewPosition();
                                                                                  }
                                                                                  {
#line 386
                                                                                  ShowBoard();
                                                                                  }
                                                                                  {
#line 387
                                                                                  printf((char const   */* __restrict  */)"\n%s : Best move = %s\n",
                                                                                         id,
                                                                                         solution);
                                                                                  }
                                                                                  }
                                                                                } else {
                                                                                  {
                                                                                  {
#line 389
                                                                                  tmp___50 = strcmp((char const   *)(cmd),
                                                                                                    "setboard");
                                                                                  }
                                                                                  }
#line 389
                                                                                  if (tmp___50 == 0) {
                                                                                    {
                                                                                    {
#line 392
                                                                                    ParseEPD(inputstr);
                                                                                    }
                                                                                    {
#line 393
                                                                                    NewPosition();
                                                                                    }
                                                                                    }
                                                                                  } else {
                                                                                    {
                                                                                    {
#line 395
                                                                                    tmp___49 = strcmp((char const   *)(cmd),
                                                                                                      "ping");
                                                                                    }
                                                                                    }
#line 395
                                                                                    if (tmp___49 == 0) {
                                                                                      {
                                                                                      {
#line 401
                                                                                      printf((char const   */* __restrict  */)"pong %s\n",
                                                                                             inputstr);
                                                                                      }
                                                                                      {
#line 402
                                                                                      fflush(stdout);
                                                                                      }
                                                                                      }
                                                                                    } else {
                                                                                      {
                                                                                      {
#line 404
                                                                                      tmp___48 = strcmp((char const   *)(cmd),
                                                                                                        "switch");
                                                                                      }
                                                                                      }
#line 404
                                                                                      if (tmp___48 == 0) {
#line 406
                                                                                        board.side = 1 ^ board.side;
#line 407
                                                                                        if (board.side == 0) {
#line 407
                                                                                          tmp___30 = "White";
                                                                                        } else {
#line 407
                                                                                          tmp___30 = "Black";
                                                                                        }
                                                                                        {
                                                                                        {
#line 407
                                                                                        printf((char const   */* __restrict  */)"%s to move\n",
                                                                                               tmp___30);
                                                                                        }
                                                                                        }
                                                                                      } else {
                                                                                        {
                                                                                        {
#line 409
                                                                                        tmp___47 = strcmp((char const   *)(cmd),
                                                                                                          "go");
                                                                                        }
                                                                                        }
#line 409
                                                                                        if (tmp___47 == 0) {
#line 411
                                                                                          flags |= 4U;
#line 412
                                                                                          flags &= 4294967287U;
#line 413
                                                                                          flags &= 4294967279U;
#line 414
                                                                                          flags &= 4294967231U;
#line 415
                                                                                          computer = board.side;
                                                                                        } else {
                                                                                          {
                                                                                          {
#line 417
                                                                                          tmp___45 = strcmp((char const   *)(cmd),
                                                                                                            "solve");
                                                                                          }
                                                                                          }
#line 417
                                                                                          if (tmp___45 == 0) {
                                                                                            {
                                                                                            {
#line 418
                                                                                            Solve(inputstr);
                                                                                            }
                                                                                            }
                                                                                          } else {
                                                                                            {
                                                                                            {
#line 417
                                                                                            tmp___46 = strcmp((char const   *)(cmd),
                                                                                                              "solveepd");
                                                                                            }
                                                                                            }
#line 417
                                                                                            if (tmp___46 == 0) {
                                                                                              {
                                                                                              {
#line 418
                                                                                              Solve(inputstr);
                                                                                              }
                                                                                              }
                                                                                            } else {
                                                                                              {
                                                                                              {
#line 419
                                                                                              tmp___44 = strcmp((char const   *)(cmd),
                                                                                                                "remove");
                                                                                              }
                                                                                              }
#line 419
                                                                                              if (tmp___44 == 0) {
#line 420
                                                                                                if (GameCnt >= 0) {
                                                                                                  {
#line 421
                                                                                                  flags &= 4294967231U;
#line 422
                                                                                                  flags &= 4294967279U;
                                                                                                  {
#line 423
                                                                                                  UnmakeMove(board.side,
                                                                                                             & Game[GameCnt].move);
                                                                                                  }
                                                                                                  }
#line 424
                                                                                                  if (GameCnt >= 0) {
                                                                                                    {
                                                                                                    {
#line 425
                                                                                                    UnmakeMove(board.side,
                                                                                                               & Game[GameCnt].move);
                                                                                                    }
                                                                                                    }
#line 426
                                                                                                    if (! (flags & 1024U)) {
                                                                                                      {
                                                                                                      {
#line 427
                                                                                                      ShowBoard();
                                                                                                      }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                  {
                                                                                                  {
#line 429
                                                                                                  PGNSaveToFile("game.log",
                                                                                                                "");
                                                                                                  }
                                                                                                  }
                                                                                                } else {
                                                                                                  {
                                                                                                  {
#line 431
                                                                                                  printf((char const   */* __restrict  */)"No moves to undo! \n");
                                                                                                  }
                                                                                                  }
                                                                                                }
                                                                                              } else {
                                                                                                {
                                                                                                {
#line 433
                                                                                                tmp___43 = strcmp((char const   *)(cmd),
                                                                                                                  "undo");
                                                                                                }
                                                                                                }
#line 433
                                                                                                if (tmp___43 == 0) {
#line 435
                                                                                                  if (GameCnt >= 0) {
                                                                                                    {
                                                                                                    {
#line 436
                                                                                                    UnmakeMove(board.side,
                                                                                                               & Game[GameCnt].move);
                                                                                                    }
                                                                                                    }
                                                                                                  } else {
                                                                                                    {
                                                                                                    {
#line 438
                                                                                                    printf((char const   */* __restrict  */)"No moves to undo! \n");
                                                                                                    }
                                                                                                    }
                                                                                                  }
#line 439
                                                                                                  (MoveLimit[board.side]) ++;
#line 440
                                                                                                  TimeLimit[board.side] += Game[GameCnt + 1].et;
#line 441
                                                                                                  if (! (flags & 1024U)) {
                                                                                                    {
                                                                                                    {
#line 441
                                                                                                    ShowBoard();
                                                                                                    }
                                                                                                    }
                                                                                                  }
                                                                                                } else {
                                                                                                  {
                                                                                                  {
#line 443
                                                                                                  tmp___42 = strcmp((char const   *)(cmd),
                                                                                                                    "bk");
                                                                                                  }
                                                                                                  }
#line 443
                                                                                                  if (tmp___42 == 0) {
                                                                                                    {
                                                                                                    {
#line 448
                                                                                                    BookQuery(1);
                                                                                                    }
                                                                                                    {
#line 449
                                                                                                    printf((char const   */* __restrict  */)"\n");
                                                                                                    }
                                                                                                    {
#line 450
                                                                                                    fflush(stdout);
                                                                                                    }
                                                                                                    }
                                                                                                  } else {
                                                                                                    {
                                                                                                    {
#line 454
                                                                                                    tmp___41 = strcmp((char const   *)(cmd),
                                                                                                                      "variant");
                                                                                                    }
                                                                                                    }
#line 454
                                                                                                    if (! (tmp___41 == 0)) {
                                                                                                      {
                                                                                                      {
#line 457
                                                                                                      tmp___40 = strcmp((char const   *)(cmd),
                                                                                                                        "accepted");
                                                                                                      }
                                                                                                      }
#line 457
                                                                                                      if (! (tmp___40 == 0)) {
                                                                                                        {
                                                                                                        {
#line 459
                                                                                                        tmp___39 = strcmp((char const   *)(cmd),
                                                                                                                          "rejected");
                                                                                                        }
                                                                                                        }
#line 459
                                                                                                        if (! (tmp___39 == 0)) {
                                                                                                          {
                                                                                                          {
#line 462
                                                                                                          tmp___38 = strcmp((char const   *)(cmd),
                                                                                                                            "st");
                                                                                                          }
                                                                                                          }
#line 462
                                                                                                          if (tmp___38 == 0) {
                                                                                                            {
                                                                                                            {
#line 465
                                                                                                            sscanf((char const   */* __restrict  */)inputstr,
                                                                                                                   (char const   */* __restrict  */)"%d",
                                                                                                                   & TCinc);
                                                                                                            }
#line 466
                                                                                                            suddendeath = 0;
#line 468
                                                                                                            SearchTime = (float )TCinc * 0.90f;
#line 469
                                                                                                            flags &= 4294965247U;
                                                                                                            }
                                                                                                          } else {
                                                                                                            {
                                                                                                            {
#line 472
                                                                                                            tmp___37 = strcmp((char const   *)(cmd),
                                                                                                                              "draw");
                                                                                                            }
                                                                                                            }
#line 472
                                                                                                            if (! (tmp___37 == 0)) {
                                                                                                              {
                                                                                                              {
#line 475
                                                                                                              tmp___36 = strcmp((char const   *)(cmd),
                                                                                                                                "edit");
                                                                                                              }
                                                                                                              }
#line 475
                                                                                                              if (tmp___36 == 0) {
#line 477
                                                                                                                if (flags & 1024U) {
                                                                                                                  {
                                                                                                                  {
#line 479
                                                                                                                  printf((char const   */* __restrict  */)"tellusererror command \'edit\' not implemented\n");
                                                                                                                  }
                                                                                                                  {
#line 480
                                                                                                                  fflush(stdout);
                                                                                                                  }
                                                                                                                  }
                                                                                                                }
                                                                                                              } else {
                                                                                                                {
                                                                                                                {
#line 484
                                                                                                                tmp___35 = strcmp((char const   *)(cmd),
                                                                                                                                  "hint");
                                                                                                                }
                                                                                                                }
#line 484
                                                                                                                if (tmp___35 == 0) {
#line 490
                                                                                                                  if (flags & 128U) {
                                                                                                                    {
                                                                                                                    {
#line 492
                                                                                                                    tmp___31 = TTGetPV(board.side,
                                                                                                                                       2,
                                                                                                                                       rootscore,
                                                                                                                                       & pvar);
                                                                                                                    }
                                                                                                                    }
#line 492
                                                                                                                    if (tmp___31) {
                                                                                                                      {
                                                                                                                      {
#line 496
                                                                                                                      GenMoves(2);
                                                                                                                      }
                                                                                                                      {
#line 498
                                                                                                                      SANMove(pvar,
                                                                                                                              2);
                                                                                                                      }
                                                                                                                      {
#line 499
                                                                                                                      printf((char const   */* __restrict  */)"Hint: %s\n",
                                                                                                                             SANmv);
                                                                                                                      }
                                                                                                                      {
#line 500
                                                                                                                      fflush(stdout);
                                                                                                                      }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                } else {
                                                                                                                  {
                                                                                                                  {
#line 505
                                                                                                                  tmp___34 = strcmp((char const   *)(cmd),
                                                                                                                                    "?");
                                                                                                                  }
                                                                                                                  }
#line 505
                                                                                                                  if (! (tmp___34 == 0)) {
                                                                                                                    {
                                                                                                                    {
#line 508
                                                                                                                    tmp___33 = strcmp((char const   *)(cmd),
                                                                                                                                      "analyze");
                                                                                                                    }
                                                                                                                    }
#line 508
                                                                                                                    if (tmp___33 == 0) {
                                                                                                                      {
                                                                                                                      {
#line 510
                                                                                                                      printf((char const   */* __restrict  */)"Error (unknown command): analyze\n");
                                                                                                                      }
                                                                                                                      {
#line 511
                                                                                                                      fflush(stdout);
                                                                                                                      }
                                                                                                                      }
                                                                                                                    } else {
                                                                                                                      {
                                                                                                                      {
#line 514
                                                                                                                      tmp___32 = strcmp((char const   *)(cmd),
                                                                                                                                        "computer");
                                                                                                                      }
                                                                                                                      }
#line 514
                                                                                                                      if (! (tmp___32 == 0)) {
                                                                                                                        {
                                                                                                                        {
#line 520
                                                                                                                        ptr = ValidateMove(cmd);
                                                                                                                        }
                                                                                                                        }
#line 521
                                                                                                                        if ((unsigned long )ptr != (unsigned long )((void *)0)) {
                                                                                                                          {
                                                                                                                          {
#line 523
                                                                                                                          SANMove(ptr->move,
                                                                                                                                  1);
                                                                                                                          }
                                                                                                                          {
#line 524
                                                                                                                          MakeMove(board.side,
                                                                                                                                   & ptr->move);
                                                                                                                          }
                                                                                                                          {
#line 525
                                                                                                                          strcpy((char */* __restrict  */)(Game[GameCnt].SANmv),
                                                                                                                                 (char const   */* __restrict  */)(SANmv));
                                                                                                                          }
                                                                                                                          {
#line 526
                                                                                                                          printf((char const   */* __restrict  */)"%d. ",
                                                                                                                                 GameCnt / 2 + 1);
                                                                                                                          }
                                                                                                                          {
#line 527
                                                                                                                          printf((char const   */* __restrict  */)"%s",
                                                                                                                                 cmd);
                                                                                                                          }
                                                                                                                          }
#line 528
                                                                                                                          if ((unsigned long )ofp != (unsigned long )stdout) {
                                                                                                                            {
                                                                                                                            {
#line 529
                                                                                                                            fprintf((FILE */* __restrict  */)ofp,
                                                                                                                                    (char const   */* __restrict  */)"%d. ",
                                                                                                                                    GameCnt / 2 + 1);
                                                                                                                            }
                                                                                                                            {
#line 530
                                                                                                                            fprintf((FILE */* __restrict  */)ofp,
                                                                                                                                    (char const   */* __restrict  */)"%s",
                                                                                                                                    cmd);
                                                                                                                            }
                                                                                                                            }
                                                                                                                          }
                                                                                                                          {
                                                                                                                          {
#line 532
                                                                                                                          putchar('\n');
                                                                                                                          }
                                                                                                                          {
#line 533
                                                                                                                          fflush(stdout);
                                                                                                                          }
                                                                                                                          }
#line 534
                                                                                                                          if ((unsigned long )ofp != (unsigned long )stdout) {
                                                                                                                            {
                                                                                                                            {
#line 535
                                                                                                                            fputc('\n',
                                                                                                                                  ofp);
                                                                                                                            }
                                                                                                                            {
#line 536
                                                                                                                            fflush(ofp);
                                                                                                                            }
                                                                                                                            }
                                                                                                                          }
#line 538
                                                                                                                          if (! (flags & 1024U)) {
                                                                                                                            {
                                                                                                                            {
#line 538
                                                                                                                            ShowBoard();
                                                                                                                            }
                                                                                                                            }
                                                                                                                          }
#line 539
                                                                                                                          flags |= 4U;
                                                                                                                        } else {
                                                                                                                          {
                                                                                                                          {
#line 546
                                                                                                                          printf((char const   */* __restrict  */)"Illegal move: %s\n",
                                                                                                                                 cmd);
                                                                                                                          }
                                                                                                                          {
#line 547
                                                                                                                          fflush(stdout);
                                                                                                                          }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  done: 
  {
  {
#line 552
  free((void *)inputstr);
  }
  }
#line 554
  return;
}
}
#line 559 "/home/khheo/testset/chess/src/cmd.c"
void ShowCmd(char *subcmd___0 ) 
{ 
  char cmd___0[128] ;
  int s___1 ;
  int wp ;
  int bp ;
  int wk ;
  int bk ;
  BitBoard *b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  BitBoard b___0 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;

  {
  {
  {
#line 568
  sscanf((char const   */* __restrict  */)subcmd___0, (char const   */* __restrict  */)"%s %[^\n]",
         cmd___0, subcmd___0);
  }
  {
#line 569
  tmp___23 = strcmp((char const   *)(cmd___0), "board");
  }
  }
#line 569
  if (tmp___23 == 0) {
    {
    {
#line 570
    ShowBoard();
    }
    }
  } else {
    {
    {
#line 571
    tmp___22 = strcmp((char const   *)(cmd___0), "rating");
    }
    }
#line 571
    if (tmp___22 == 0) {
      {
      {
#line 573
      printf((char const   */* __restrict  */)"My rating = %d\n", myrating);
      }
      {
#line 574
      printf((char const   */* __restrict  */)"Opponent rating = %d\n", opprating);
      }
      }
    } else {
      {
      {
#line 576
      tmp___21 = strcmp((char const   *)(cmd___0), "time");
      }
      }
#line 576
      if (tmp___21 == 0) {
        {
        {
#line 577
        ShowTime();
        }
        }
      } else {
        {
        {
#line 578
        tmp___20 = strcmp((char const   *)(cmd___0), "moves");
        }
        }
#line 578
        if (tmp___20 == 0) {
          {
#line 580
          GenCnt = 0UL;
#line 581
          TreePtr[2] = TreePtr[1];
          {
#line 582
          GenMoves(1);
          }
          {
#line 583
          ShowMoveList(1);
          }
          {
#line 584
          printf((char const   */* __restrict  */)"No. of moves generated = %lu\n",
                 GenCnt);
          }
          }
        } else {
          {
          {
#line 586
          tmp___19 = strcmp((char const   *)(cmd___0), "escape");
          }
          }
#line 586
          if (tmp___19 == 0) {
            {
#line 588
            GenCnt = 0UL;
#line 589
            TreePtr[2] = TreePtr[1];
            {
#line 590
            GenCheckEscapes(1);
            }
            {
#line 591
            ShowMoveList(1);
            }
            {
#line 592
            printf((char const   */* __restrict  */)"No. of moves generated = %lu\n",
                   GenCnt);
            }
            }
          } else {
            {
            {
#line 594
            tmp___18 = strcmp((char const   *)(cmd___0), "noncapture");
            }
            }
#line 594
            if (tmp___18 == 0) {
              {
#line 596
              GenCnt = 0UL;
#line 597
              TreePtr[2] = TreePtr[1];
              {
#line 598
              GenNonCaptures(1);
              }
              {
#line 599
              FilterIllegalMoves(1);
              }
              {
#line 600
              ShowMoveList(1);
              }
              {
#line 601
              printf((char const   */* __restrict  */)"No. of moves generated = %lu\n",
                     GenCnt);
              }
              }
            } else {
              {
              {
#line 603
              tmp___17 = strcmp((char const   *)(cmd___0), "capture");
              }
              }
#line 603
              if (tmp___17 == 0) {
                {
#line 605
                GenCnt = 0UL;
#line 606
                TreePtr[2] = TreePtr[1];
                {
#line 607
                GenCaptures(1);
                }
                {
#line 608
                FilterIllegalMoves(1);
                }
                {
#line 609
                ShowMoveList(1);
                }
                {
#line 610
                printf((char const   */* __restrict  */)"No. of moves generated = %lu\n",
                       GenCnt);
                }
                }
              } else {
                {
                {
#line 612
                tmp___15 = strcmp((char const   *)(cmd___0), "eval");
                }
                }
#line 612
                if (tmp___15 == 0) {
#line 612
                  goto _L;
                } else {
                  {
                  {
#line 612
                  tmp___16 = strcmp((char const   *)(cmd___0), "score");
                  }
                  }
#line 612
                  if (tmp___16 == 0) {
                    _L: /* CIL Label */ 
                    {
#line 617
                    phase = 8 - (board.material[0] + board.material[1]) / 1150;
                    {
#line 618
                    GenAtaks();
                    }
                    {
#line 619
                    FindPins(& pinned);
                    }
                    {
#line 620
                    hunged[0] = EvalHung(0);
                    }
                    {
#line 621
                    hunged[1] = EvalHung(1);
                    }
#line 622
                    b = board.b[0];
#line 623
                    pieces[0] = ((*(b + 2) | *(b + 3)) | *(b + 4)) | *(b + 5);
#line 624
                    b = board.b[1];
#line 625
                    pieces[1] = ((*(b + 2) | *(b + 3)) | *(b + 4)) | *(b + 5);
                    {
#line 626
                    wp = ScoreP(0);
                    }
                    {
#line 627
                    bp = ScoreP(1);
                    }
                    {
#line 628
                    wk = ScoreK(0);
                    }
                    {
#line 629
                    bk = ScoreK(1);
                    }
                    {
#line 630
                    tmp = ScoreDev(0);
                    }
                    {
#line 630
                    tmp___0 = ScoreQ(0);
                    }
                    {
#line 630
                    tmp___1 = ScoreR(0);
                    }
                    {
#line 630
                    tmp___2 = ScoreB(0);
                    }
                    {
#line 630
                    tmp___3 = ScoreN(0);
                    }
                    {
#line 630
                    printf((char const   */* __restrict  */)"White:  Mat:%4d/%4d  P:%d  N:%d  B:%d  R:%d  Q:%d  K:%d  Dev:%d  h:%d x:%d\n",
                           board.pmaterial[0], board.material[0], wp, tmp___3, tmp___2,
                           tmp___1, tmp___0, wk, tmp, hunged[0], ExchCnt[0]);
                    }
                    {
#line 634
                    tmp___4 = ScoreDev(1);
                    }
                    {
#line 634
                    tmp___5 = ScoreQ(1);
                    }
                    {
#line 634
                    tmp___6 = ScoreR(1);
                    }
                    {
#line 634
                    tmp___7 = ScoreB(1);
                    }
                    {
#line 634
                    tmp___8 = ScoreN(1);
                    }
                    {
#line 634
                    printf((char const   */* __restrict  */)"Black:  Mat:%4d/%4d  P:%d  N:%d  B:%d  R:%d  Q:%d  K:%d  Dev:%d  h:%d x:%d\n",
                           board.pmaterial[1], board.material[1], bp, tmp___8, tmp___7,
                           tmp___6, tmp___5, bk, tmp___4, hunged[1], ExchCnt[1]);
                    }
                    {
#line 638
                    printf((char const   */* __restrict  */)"Phase: %d\t", 8 - (board.material[0] + board.material[1]) / 1150);
                    }
                    {
#line 639
                    tmp___12 = EvaluateDraw();
                    }
                    }
#line 639
                    if (tmp___12) {
#line 639
                      if (computerplays == board.side) {
#line 639
                        tmp___10 = (opprating - myrating) / 4;
                      } else {
#line 639
                        tmp___10 = (myrating - opprating) / 4;
                      }
#line 639
                      s___1 = tmp___10;
                    } else {
                      {
                      {
#line 639
                      tmp___11 = Evaluate(-32767, 32767);
                      }
#line 639
                      s___1 = tmp___11;
                      }
                    }
                    {
                    {
#line 640
                    printf((char const   */* __restrict  */)"score = %d\n", s___1);
                    }
                    {
#line 641
                    printf((char const   */* __restrict  */)"\n");
                    }
                    }
#line 642
                    return;
                  } else {
                    {
                    {
#line 644
                    tmp___14 = strcmp((char const   *)(cmd___0), "game");
                    }
                    }
#line 644
                    if (tmp___14 == 0) {
                      {
                      {
#line 645
                      ShowGame();
                      }
                      }
                    } else {
                      {
                      {
#line 646
                      tmp___13 = strcmp((char const   *)(cmd___0), "pin");
                      }
                      }
#line 646
                      if (tmp___13 == 0) {
                        {
                        {
#line 649
                        GenAtaks();
                        }
                        {
#line 650
                        FindPins(& b___0);
                        }
                        {
#line 651
                        ShowBitBoard(& b___0);
                        }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 653
  return;
}
}
#line 655 "/home/khheo/testset/chess/src/cmd.c"
void TestCmd(char *subcmd___0 ) 
{ 
  char cmd___0[128] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 664
  sscanf((char const   */* __restrict  */)subcmd___0, (char const   */* __restrict  */)"%s %[^\n]",
         cmd___0, subcmd___0);
  }
  {
#line 665
  tmp___4 = strcmp((char const   *)(cmd___0), "movelist");
  }
  }
#line 665
  if (tmp___4 == 0) {
    {
    {
#line 666
    TestMoveList();
    }
    }
  } else {
    {
    {
#line 667
    tmp___3 = strcmp((char const   *)(cmd___0), "capture");
    }
    }
#line 667
    if (tmp___3 == 0) {
      {
      {
#line 668
      TestCaptureList();
      }
      }
    } else {
      {
      {
#line 669
      tmp___2 = strcmp((char const   *)(cmd___0), "movegenspeed");
      }
      }
#line 669
      if (tmp___2 == 0) {
        {
        {
#line 670
        TestMoveGenSpeed();
        }
        }
      } else {
        {
        {
#line 671
        tmp___1 = strcmp((char const   *)(cmd___0), "capturespeed");
        }
        }
#line 671
        if (tmp___1 == 0) {
          {
          {
#line 672
          TestCaptureGenSpeed();
          }
          }
        } else {
          {
          {
#line 673
          tmp___0 = strcmp((char const   *)(cmd___0), "eval");
          }
          }
#line 673
          if (tmp___0 == 0) {
            {
            {
#line 674
            TestEval();
            }
            }
          } else {
            {
            {
#line 675
            tmp = strcmp((char const   *)(cmd___0), "evalspeed");
            }
            }
#line 675
            if (tmp == 0) {
              {
              {
#line 676
              TestEvalSpeed();
              }
              }
            }
          }
        }
      }
    }
  }
#line 677
  return;
}
}
#line 689 "/home/khheo/testset/chess/src/cmd.c"
static char const   * const  helpstr[112]  = 
#line 689
  {      (char const   */* const  */)"^C",      (char const   */* const  */)" Typically the interrupt key stops a search in progress,",      (char const   */* const  */)" makes the move last considered best and returns to the",      (char const   */* const  */)" command prompt", 
        (char const   */* const  */)"quit",      (char const   */* const  */)"exit",      (char const   */* const  */)" These quit or exit the game.",      (char const   */* const  */)"help", 
        (char const   */* const  */)" Produces a help blurb corresponding to this list of commands.",      (char const   */* const  */)"book",      (char const   */* const  */)" add - compiles book.dat from book.pgn",      (char const   */* const  */)" on - enables use of book", 
        (char const   */* const  */)" off - disables use of book",      (char const   */* const  */)" worst - play worst move from book",      (char const   */* const  */)" best - play best move from book",      (char const   */* const  */)" random - play any move from book", 
        (char const   */* const  */)" prefer - default, same as \'book on\'",      (char const   */* const  */)"version",      (char const   */* const  */)" prints out the version of this program",      (char const   */* const  */)"pgnsave FILENAME", 
        (char const   */* const  */)" saves the game so far to the file from memory",      (char const   */* const  */)"pgnload FILENAME",      (char const   */* const  */)" loads the game in the file into memory",      (char const   */* const  */)"force", 
        (char const   */* const  */)"manual",      (char const   */* const  */)" Makes the program stop moving. You may now enter moves",      (char const   */* const  */)" to reach some position in the future.",      (char const   */* const  */)" ", 
        (char const   */* const  */)"white",      (char const   */* const  */)" Program plays white",      (char const   */* const  */)"black",      (char const   */* const  */)" Program plays black", 
        (char const   */* const  */)"go",      (char const   */* const  */)" Computer takes whichever side is on move and begins its",      (char const   */* const  */)" thinking immediately",      (char const   */* const  */)"post", 
        (char const   */* const  */)" Arranges for verbose thinking output showing variation, score,",      (char const   */* const  */)" time, depth, etc.",      (char const   */* const  */)"nopost",      (char const   */* const  */)" Turns off verbose thinking output", 
        (char const   */* const  */)"name NAME",      (char const   */* const  */)" Lets you input your name. Also writes the log.nnn and a",      (char const   */* const  */)" corresponding game.nnn file. For details please see",      (char const   */* const  */)" auxillary file format sections.", 
        (char const   */* const  */)"result",      (char const   */* const  */)" Mostly used by Internet Chess server.",      (char const   */* const  */)"activate",      (char const   */* const  */)" This command reactivates a game that has been terminated automatically", 
        (char const   */* const  */)" due to checkmate or no more time on the clock. However, it does not",      (char const   */* const  */)" alter those conditions. You would have to undo a move or two or",      (char const   */* const  */)" add time to the clock with level or time in that case.",      (char const   */* const  */)"rating COMPUTERRATING OPPONENTRATING", 
        (char const   */* const  */)" Inputs the estimated rating for computer and for its opponent",      (char const   */* const  */)"new",      (char const   */* const  */)" Sets up new game (i.e. positions in original positions)",      (char const   */* const  */)"time", 
        (char const   */* const  */)" Inputs time left in game for computer in hundredths of a second.",      (char const   */* const  */)" Mostly used by Internet Chess server.",      (char const   */* const  */)"hash",      (char const   */* const  */)" on - enables using the memory hash table to speed search", 
        (char const   */* const  */)" off - disables the memory hash table",      (char const   */* const  */)"hashsize N",      (char const   */* const  */)" Sets the hash table to permit storage of N positions",      (char const   */* const  */)"null", 
        (char const   */* const  */)" on - enables using the null move heuristic to speed search",      (char const   */* const  */)" off - disables using the null move heuristic",      (char const   */* const  */)"xboard",      (char const   */* const  */)" on - enables use of xboard/winboard", 
        (char const   */* const  */)" off - disables use of xboard/winboard",      (char const   */* const  */)"depth N",      (char const   */* const  */)" Sets the program to look N ply (half-moves) deep for every",      (char const   */* const  */)" search it performs. If there is a checkmate or other condition", 
        (char const   */* const  */)" that does not allow that depth, then it will not be ",      (char const   */* const  */)"level MOVES MINUTES INCREMENT",      (char const   */* const  */)" Sets time control to be MOVES in MINUTES with each move giving",      (char const   */* const  */)" an INCREMENT (in seconds, i.e. Fischer-style clock).", 
        (char const   */* const  */)"load",      (char const   */* const  */)"epdload",      (char const   */* const  */)" Loads a position in EPD format from disk into memory.",      (char const   */* const  */)"save", 
        (char const   */* const  */)"epdsave",      (char const   */* const  */)" Saves game position into EPD format from memory to disk.",      (char const   */* const  */)"switch",      (char const   */* const  */)" Switches side to move", 
        (char const   */* const  */)"solve FILENAME",      (char const   */* const  */)"solveepd FILENAME",      (char const   */* const  */)" Solves the positions in FILENAME",      (char const   */* const  */)"remove", 
        (char const   */* const  */)" Backs up two moves in game history",      (char const   */* const  */)"undo",      (char const   */* const  */)" Backs up one move in game history",      (char const   */* const  */)"show", 
        (char const   */* const  */)" board - displays the current board",      (char const   */* const  */)" time - displays the time settings",      (char const   */* const  */)" moves - shows all moves using one call to routine",      (char const   */* const  */)" escape - shows moves that escape from check using one call to routine", 
        (char const   */* const  */)" noncapture - shows non-capture moves",      (char const   */* const  */)" capture - shows capture moves",      (char const   */* const  */)" eval [or score] - shows the evaluation per piece and overall",      (char const   */* const  */)" game - shows moves in game history", 
        (char const   */* const  */)" pin - shows pinned pieces",      (char const   */* const  */)"test",      (char const   */* const  */)" movelist - reads in an epd file and shows legal moves for its entries",      (char const   */* const  */)" capture - reads in an epd file and shows legal captures for its entries", 
        (char const   */* const  */)" movegenspeed - tests speed of move generator",      (char const   */* const  */)" capturespeed - tests speed of capture move generator",      (char const   */* const  */)" eval - reads in an epd file and shows evaluation for its entries",      (char const   */* const  */)" evalspeed tests speed of the evaluator", 
        (char const   */* const  */)"bk",      (char const   */* const  */)" show moves from opening book.",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0)};
#line 804 "/home/khheo/testset/chess/src/cmd.c"
void ShowHelp(char const   *command ) 
{ 
  char const   * const  *p___1 ;
  int count ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 814
  tmp___1 = strlen(command);
  }
  }
#line 814
  if (tmp___1 > 0UL) {
#line 815
    p___1 = helpstr;
#line 815
    count = 0;
    {
    {
#line 815
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 815
      if (! *p___1) {
#line 815
        goto while_break;
      }
      {
      {
#line 816
      tmp = strlen(command);
      }
      {
#line 816
      tmp___0 = strncmp((char const   *)*p___1, (char const   *)inputstr, tmp);
      }
      }
#line 816
      if (tmp___0 == 0) {
        {
        {
#line 817
        puts((char const   *)*p___1);
        }
        }
        {
        {
#line 818
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 818
          p___1 ++;
#line 818
          if (*p___1) {
#line 818
            if (! ((int const   )*(*p___1) != 32)) {
#line 818
              goto while_break___0;
            }
          } else {
#line 818
            goto while_break___0;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 819
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 819
          if (*p___1) {
#line 819
            if (! ((int const   )*(*p___1) == 32)) {
#line 819
              goto while_break___1;
            }
          } else {
#line 819
            goto while_break___1;
          }
          {
          {
#line 820
          puts((char const   *)*p___1);
          }
#line 819
          p___1 ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 822
        return;
      }
#line 815
      p___1 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 825
    printf((char const   */* __restrict  */)"Help for command %s not found\n\n", command);
    }
    }
  }
  {
  {
#line 827
  printf((char const   */* __restrict  */)"List of commands: (help COMMAND to get more help)\n");
  }
#line 828
  p___1 = helpstr;
#line 828
  count = 0;
  }
  {
  {
#line 828
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 828
    if (! *p___1) {
#line 828
      goto while_break___2;
    }
    {
    {
#line 829
    tmp___2 = strcspn((char const   *)*p___1, " ");
    }
#line 829
    len = (int )tmp___2;
    }
#line 830
    if (len > 0) {
      {
      {
#line 831
      tmp___3 = printf((char const   */* __restrict  */)"%.*s  ", len, *p___1);
      }
#line 831
      count += tmp___3;
      }
#line 832
      if (count > 60) {
        {
#line 833
        count = 0;
        {
#line 834
        puts("");
        }
        }
      }
    }
#line 828
    p___1 ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 838
  puts("");
  }
  }
#line 839
  return;
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 380 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 67 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/testset/chess/src/book.h"
static char const   *bookbin[4]  = {      "book.dat",      "/usr/share/games/gnuchess/book.dat",      "/usr/lib/games/gnuchess/book.dat",      (char const   *)((void *)0)};
#line 38 "/home/khheo/testset/chess/src/book.c"
static int bookcnt  ;
#line 39 "/home/khheo/testset/chess/src/book.c"
static HashType posshash[200]  ;
#line 46 "/home/khheo/testset/chess/src/book.c"
static int book_allocated  =    0;
#line 62 "/home/khheo/testset/chess/src/book.c"
static char const   magic_str[6]  = {      (char const   )'B',      (char const   )'#',      (char const   )'\b',      (char const   )'\025', 
        (char const   )'\003',      (char const   )'\000'};
#line 64 "/home/khheo/testset/chess/src/book.c"
static int check_magic(FILE *f ) 
{ 
  char buf___0[5] ;
  int r ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 69
  tmp = fread((void */* __restrict  */)(& buf___0), (size_t )1, (size_t )5, (FILE */* __restrict  */)f);
  }
#line 69
  r = (int )tmp;
  }
#line 70
  if (r == 5) {
    {
    {
#line 70
    tmp___0 = memcmp((void const   *)(buf___0), (void const   *)(magic_str), (size_t )5);
    }
    }
#line 70
    if (tmp___0 == 0) {
#line 70
      tmp___1 = 1;
    } else {
#line 70
      tmp___1 = 0;
    }
  } else {
#line 70
    tmp___1 = 0;
  }
#line 70
  return (tmp___1);
}
}
#line 74 "/home/khheo/testset/chess/src/book.c"
static int write_magic(FILE *f ) 
{ 
  size_t tmp ;

  {
  {
  {
#line 76
  tmp = fwrite((void const   */* __restrict  */)(& magic_str), (size_t )1, (size_t )5,
               (FILE */* __restrict  */)f);
  }
  }
#line 76
  if (5UL != tmp) {
#line 77
    return (3);
  } else {
#line 79
    return (0);
  }
}
}
#line 85 "/home/khheo/testset/chess/src/book.c"
static int write_size(FILE *f , uint32_t size ) 
{ 
  unsigned char sizebuf[4] ;
  int k___0 ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
#line 90
  k___0 = 0;
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 90
    if (! (k___0 < 4)) {
#line 90
      goto while_break;
    }
#line 91
    sizebuf[k___0] = (unsigned char )((size >> (3 - k___0) * 8) & 255U);
#line 90
    k___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 93
  tmp = fwrite((void const   */* __restrict  */)(& sizebuf), sizeof(sizebuf), (size_t )1,
               (FILE */* __restrict  */)f);
  }
  }
#line 93
  if (1UL == tmp) {
#line 94
    return (0);
  } else {
#line 96
    return (3);
  }
}
}
#line 102 "/home/khheo/testset/chess/src/book.c"
static uint32_t read_size(FILE *f ) 
{ 
  unsigned char sizebuf[4] ;
  uint32_t size ;
  int k___0 ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 105
  size = (uint32_t )0;
  {
#line 108
  tmp = fread((void */* __restrict  */)(& sizebuf), sizeof(sizebuf), (size_t )1, (FILE */* __restrict  */)f);
  }
  }
#line 108
  if (1UL != tmp) {
#line 109
    return ((uint32_t )0);
  }
#line 111
  k___0 = 0;
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 111
    if (! (k___0 < 4)) {
#line 111
      goto while_break;
    }
#line 112
    size = (size << 8) | (unsigned int )sizebuf[k___0];
#line 111
    k___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (size);
}
}
#line 126 "/home/khheo/testset/chess/src/book.c"
static int digest_bits  ;
#line 131 "/home/khheo/testset/chess/src/book.c"
static struct hashtype *bookpos  ;
#line 138 "/home/khheo/testset/chess/src/book.c"
__inline static int is_empty(uint32_t index___0 ) 
{ 
  int tmp ;

  {
#line 140
  if ((bookpos + index___0)->key == 0UL) {
#line 140
    if ((int )(bookpos + index___0)->wins == 0) {
#line 140
      if ((int )(bookpos + index___0)->draws == 0) {
#line 140
        if ((int )(bookpos + index___0)->losses == 0) {
#line 140
          tmp = 1;
        } else {
#line 140
          tmp = 0;
        }
      } else {
#line 140
        tmp = 0;
      }
    } else {
#line 140
      tmp = 0;
    }
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return (tmp);
}
}
#line 182 "/home/khheo/testset/chess/src/book.c"
static int bookhashcollisions  =    0;
#line 198 "/home/khheo/testset/chess/src/book.c"
static unsigned char buf[14]  ;
#line 201 "/home/khheo/testset/chess/src/book.c"
static int const   wins_off  =    (int const   )0;
#line 202 "/home/khheo/testset/chess/src/book.c"
static int const   losses_off  =    (int const   )2;
#line 203 "/home/khheo/testset/chess/src/book.c"
static int const   draws_off  =    (int const   )4;
#line 204 "/home/khheo/testset/chess/src/book.c"
static int const   key_off  =    (int const   )6;
#line 206 "/home/khheo/testset/chess/src/book.c"
static void buf_to_book(void) 
{ 
  HashType key ;
  uint32_t i ;
  int tmp ;

  {
#line 211
  key = ((((((((uint64_t )buf[key_off] << 56) | ((uint64_t )buf[key_off + 1] << 48)) | ((uint64_t )buf[key_off + 2] << 40)) | ((uint64_t )buf[key_off + 3] << 32)) | ((uint64_t )buf[key_off + 4] << 24)) | ((uint64_t )buf[key_off + 5] << 16)) | ((uint64_t )buf[key_off + 6] << 8)) | (uint64_t )buf[key_off + 7];
#line 223
  i = (uint32_t )(key & ((1UL << digest_bits) - 1UL));
  {
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 223
    if (! (key == (bookpos + i)->key)) {
      {
      {
#line 223
      tmp = is_empty(i);
      }
      }
#line 223
      if (tmp) {
#line 223
        goto while_break;
      }
    } else {
#line 223
      goto while_break;
    }
#line 227
    bookhashcollisions ++;
#line 223
    i = (uint32_t )(((unsigned long )i + ((key >> digest_bits) | 1UL)) & ((1UL << digest_bits) - 1UL));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  (bookpos + i)->wins = (uint16_t )((int )(bookpos + i)->wins + (((int )buf[wins_off] << 8) | (int )buf[wins_off + 1]));
#line 230
  (bookpos + i)->draws = (uint16_t )((int )(bookpos + i)->draws + (((int )buf[draws_off] << 8) | (int )buf[draws_off + 1]));
#line 231
  (bookpos + i)->losses = (uint16_t )((int )(bookpos + i)->losses + (((int )buf[losses_off] << 8) | (int )buf[losses_off + 1]));
#line 232
  (bookpos + i)->key = key;
#line 233
  return;
}
}
#line 235 "/home/khheo/testset/chess/src/book.c"
static void book_to_buf(uint32_t index___0 ) 
{ 
  int k___0 ;

  {
#line 239
  k___0 = 0;
  {
  {
#line 239
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 239
    if (! (k___0 < 2)) {
#line 239
      goto while_break;
    }
#line 240
    buf[wins_off + (int const   )k___0] = (unsigned char )(((int )(bookpos + index___0)->wins >> (1 - k___0) * 8) & 255);
#line 241
    buf[draws_off + (int const   )k___0] = (unsigned char )(((int )(bookpos + index___0)->draws >> (1 - k___0) * 8) & 255);
#line 242
    buf[losses_off + (int const   )k___0] = (unsigned char )(((int )(bookpos + index___0)->losses >> (1 - k___0) * 8) & 255);
#line 239
    k___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  k___0 = 0;
  {
  {
#line 244
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! (k___0 < 8)) {
#line 244
      goto while_break___0;
    }
#line 245
    buf[key_off + (int const   )k___0] = (unsigned char )(((bookpos + index___0)->key >> (7 - k___0) * 8) & 255UL);
#line 244
    k___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 249 "/home/khheo/testset/chess/src/book.c"
static int compare(void const   *aa , void const   *bb___0 ) 
{ 
  leaf const   *a ;
  leaf const   *b ;

  {
#line 251
  a = (leaf const   *)aa;
#line 252
  b = (leaf const   *)bb___0;
#line 254
  if (b->score > a->score) {
#line 254
    return (1);
  } else
#line 255
  if (b->score < a->score) {
#line 255
    return (-1);
  } else {
#line 256
    return (0);
  }
}
}
#line 266 "/home/khheo/testset/chess/src/book.c"
static int read_book(FILE *f ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
#line 268
  if (book_allocated) {
    {
    {
#line 269
    free((void *)bookpos);
    }
#line 270
    book_allocated = 0;
    }
  }
  {
  {
#line 272
  tmp = calloc(1UL << digest_bits, sizeof(struct hashtype ));
  }
#line 272
  bookpos = (struct hashtype *)tmp;
  }
#line 273
  if ((unsigned long )bookpos == (unsigned long )((void *)0)) {
#line 274
    return (7);
  }
#line 276
  book_allocated = 1;
#line 277
  bookcnt = 0;
#line 278
  bookhashcollisions = 0;
  {
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 279
    tmp___0 = fread((void */* __restrict  */)(& buf), sizeof(buf), (size_t )1, (FILE */* __restrict  */)f);
    }
    }
#line 279
    if (! (1UL == tmp___0)) {
#line 279
      goto while_break;
    }
    {
    {
#line 280
    buf_to_book();
    }
#line 281
    bookcnt ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  return (0);
}
}
#line 290 "/home/khheo/testset/chess/src/book.c"
int BookBuilderOpen(void) 
{ 
  FILE *rfp ;
  FILE *wfp ;
  int res ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
  {
#line 295
  rfp = fopen((char const   */* __restrict  */)"book.dat", (char const   */* __restrict  */)"rb");
  }
  }
#line 295
  if ((unsigned long )rfp != (unsigned long )((void *)0)) {
    {
    {
#line 296
    printf((char const   */* __restrict  */)"Opened existing book!\n");
    }
    {
#line 297
    tmp = check_magic(rfp);
    }
    }
#line 297
    if (! tmp) {
      {
      {
#line 298
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File %s does not conform to the current format.\nConsider rebuilding your book.\n",
              "book.dat");
      }
      }
#line 302
      return (1);
    }
    {
#line 308
    digest_bits = 20;
    {
#line 309
    read_size(rfp);
    }
    {
#line 310
    res = read_book(rfp);
    }
    {
#line 311
    fclose(rfp);
    }
    }
#line 312
    if (res != 0) {
      {
      {
#line 313
      fclose(rfp);
      }
      }
#line 314
      return (res);
    }
    {
    {
#line 316
    printf((char const   */* __restrict  */)"Read %d book positions\n", bookcnt);
    }
    {
#line 317
    printf((char const   */* __restrict  */)"Got %d hash collisions\n", bookhashcollisions);
    }
    }
  } else {
    {
    {
#line 319
    wfp = fopen((char const   */* __restrict  */)"book.dat", (char const   */* __restrict  */)"w+b");
    }
    }
#line 320
    if ((unsigned long )wfp == (unsigned long )((void *)0)) {
      {
      {
#line 321
      tmp___0 = __errno_location();
      }
      {
#line 321
      tmp___1 = strerror(*tmp___0);
      }
      {
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not create %s file: %s\n",
              "book.dat", tmp___1);
      }
      }
#line 323
      return (3);
    }
    {
    {
#line 325
    tmp___4 = write_magic(wfp);
    }
    }
#line 325
    if (tmp___4 != 0) {
      {
      {
#line 326
      tmp___2 = __errno_location();
      }
      {
#line 326
      tmp___3 = strerror(*tmp___2);
      }
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not write to %s: %s\n",
              "book.dat", tmp___3);
      }
      }
#line 328
      return (3);
    }
    {
    {
#line 330
    tmp___7 = fclose(wfp);
    }
    }
#line 330
    if (tmp___7 != 0) {
      {
      {
#line 331
      tmp___5 = __errno_location();
      }
      {
#line 331
      tmp___6 = strerror(*tmp___5);
      }
      {
#line 331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not write to %s: %s\n",
              "book.dat", tmp___6);
      }
      }
#line 333
      return (3);
    }
    {
    {
#line 335
    printf((char const   */* __restrict  */)"Created new book %s!\n", "book.dat");
    }
    {
#line 336
    rfp = fopen((char const   */* __restrict  */)"book.dat", (char const   */* __restrict  */)"rb");
    }
    }
#line 337
    if ((unsigned long )rfp == (unsigned long )((void *)0)) {
      {
      {
#line 338
      tmp___8 = __errno_location();
      }
      {
#line 338
      tmp___9 = strerror(*tmp___8);
      }
      {
#line 338
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open %s for reading: %s\n",
              "book.dat", tmp___9);
      }
      }
#line 340
      return (3);
    }
    {
#line 342
    digest_bits = 20;
    {
#line 344
    tmp___10 = read_book(wfp);
    }
    }
#line 344
    if (tmp___10 == 7) {
#line 345
      return (7);
    }
  }
#line 348
  return (0);
}
}
#line 364 "/home/khheo/testset/chess/src/book.c"
int BookBuilder(int result , int side ) 
{ 
  uint32_t i ;
  int tmp ;

  {
#line 370
  if (GameCnt > 20) {
#line 371
    return (2);
  }
  {
  {
#line 372
  CalcHashKey();
  }
#line 373
  i = (uint32_t )(HashKey & ((1UL << digest_bits) - 1UL));
  }
  {
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 376
    if (HashKey == (bookpos + i)->key) {
#line 377
      existpos ++;
#line 378
      goto while_break;
    } else {
      {
      {
#line 379
      tmp = is_empty(i);
      }
      }
#line 379
      if (tmp) {
#line 380
        if ((double )bookcnt > 0.95 * (double )(1UL << digest_bits)) {
#line 381
          return (4);
        }
#line 382
        (bookpos + i)->key = HashKey;
#line 383
        newpos ++;
#line 384
        bookcnt ++;
#line 385
        goto while_break;
      } else {
#line 387
        bookhashcollisions ++;
      }
    }
#line 373
    i = (uint32_t )(((unsigned long )i + ((HashKey >> digest_bits) | 1UL)) & ((1UL << digest_bits) - 1UL));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (side == 0) {
#line 391
    if (result == 1) {
#line 392
      (bookpos + i)->wins = (uint16_t )((int )(bookpos + i)->wins + 1);
    } else
#line 393
    if (result == 2) {
#line 394
      (bookpos + i)->losses = (uint16_t )((int )(bookpos + i)->losses + 1);
    } else
#line 395
    if (result == 3) {
#line 396
      (bookpos + i)->draws = (uint16_t )((int )(bookpos + i)->draws + 1);
    }
  } else
#line 398
  if (result == 1) {
#line 399
    (bookpos + i)->losses = (uint16_t )((int )(bookpos + i)->losses + 1);
  } else
#line 400
  if (result == 2) {
#line 401
    (bookpos + i)->wins = (uint16_t )((int )(bookpos + i)->wins + 1);
  } else
#line 402
  if (result == 3) {
#line 403
    (bookpos + i)->draws = (uint16_t )((int )(bookpos + i)->draws + 1);
  }
#line 405
  return (0);
}
}
#line 408 "/home/khheo/testset/chess/src/book.c"
int BookBuilderClose(void) 
{ 
  FILE *wfp ;
  unsigned int i ;
  int errcode ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 420
  errcode = 0;
  {
#line 422
  wfp = fopen((char const   */* __restrict  */)"book.dat", (char const   */* __restrict  */)"wb");
  }
  }
#line 423
  if ((unsigned long )wfp == (unsigned long )((void *)0)) {
#line 424
    errcode = 3;
#line 425
    goto bailout_noclose;
  }
  {
  {
#line 427
  tmp = write_magic(wfp);
  }
  }
#line 427
  if (tmp != 0) {
#line 428
    errcode = 3;
#line 429
    goto bailout;
  }
  {
  {
#line 431
  tmp___0 = write_size(wfp, (uint32_t )bookcnt);
  }
  }
#line 431
  if (tmp___0 != 0) {
#line 432
    errcode = 3;
#line 433
    goto bailout;
  }
#line 435
  i = 0U;
  {
  {
#line 435
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 435
    if (! ((unsigned long )i < 1UL << digest_bits)) {
#line 435
      goto while_break;
    }
    {
    {
#line 436
    tmp___2 = is_empty(i);
    }
    }
#line 436
    if (! tmp___2) {
      {
      {
#line 437
      book_to_buf(i);
      }
      {
#line 438
      tmp___1 = fwrite((void const   */* __restrict  */)(& buf), sizeof(buf), (size_t )1,
                       (FILE */* __restrict  */)wfp);
      }
      }
#line 438
      if (1UL != tmp___1) {
#line 439
        errcode = 3;
#line 440
        goto bailout;
      }
    }
#line 435
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 444
  printf((char const   */* __restrict  */)"Got %d hash collisions\n", bookhashcollisions);
  }
  }
  bailout: 
  {
  {
#line 447
  tmp___3 = fclose(wfp);
  }
  }
#line 447
  if (tmp___3 != 0) {
#line 448
    errcode = 3;
  }
  bailout_noclose: 
  {
  {
#line 452
  free((void *)bookpos);
  }
#line 453
  book_allocated = 0;
#line 456
  bookloaded = 0;
  }
#line 458
  return (errcode);
}
}
#line 469 "/home/khheo/testset/chess/src/book.c"
int BookQuery(int BKquery ) 
{ 
  int i ;
  int j___0 ;
  int k___0 ;
  int icnt ;
  int mcnt ;
  int found ;
  int tot ;
  int maxdistribution ;
  int matches[100] ;
  leaf m[200] ;
  leaf pref[200] ;
  struct __anonstruct_r_32 r[200] ;
  FILE *rfp ;
  leaf *p___1 ;
  int side ;
  int xside ;
  int temp ;
  uint32_t booksize ;
  int res ;
  char const   * const  *booktry ;
  int tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  int __cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 476
  icnt = 0;
#line 485
  rfp = (FILE *)((void *)0);
#line 491
  if (bookloaded) {
#line 491
    if (! book_allocated) {
#line 493
      return (5);
    }
  }
#line 495
  if (! bookloaded) {
#line 498
    bookloaded = 1;
#line 499
    booktry = (char const   * const  *)(bookbin);
    {
    {
#line 499
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 499
      if (! *booktry) {
#line 499
        goto while_break;
      }
#line 500
      if (! (flags & 1024U)) {
        {
        {
#line 501
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Looking for opening book in %s...\n",
                *booktry);
        }
        }
      }
      {
      {
#line 503
      rfp = fopen((char const   */* __restrict  */)*booktry, (char const   */* __restrict  */)"rb");
      }
      }
#line 505
      if ((unsigned long )rfp == (unsigned long )((void *)0)) {
#line 505
        goto __Cont;
      }
#line 506
      if (! (flags & 1024U)) {
        {
        {
#line 507
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Read opening book (%s)...\n",
                *booktry);
        }
        }
      }
      {
      {
#line 508
      tmp = check_magic(rfp);
      }
      }
#line 508
      if (tmp) {
#line 515
        goto while_break;
      } else {
        {
        {
#line 509
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" File %s does not conform to the current format.\n Consider rebuilding it.\n\n",
                *booktry);
        }
        {
#line 513
        fclose(rfp);
        }
#line 514
        rfp = (FILE *)((void *)0);
        }
      }
      __Cont: /* CIL Label */ 
#line 499
      booktry ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 517
    if ((unsigned long )rfp == (unsigned long )((void *)0)) {
#line 519
      if (! (flags & 1024U)) {
        {
        {
#line 520
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" No book found.\n\n");
        }
        }
      } else
#line 519
      if (BKquery == 1) {
        {
        {
#line 520
        fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" No book found.\n\n");
        }
        }
      }
#line 521
      return (5);
    }
#line 523
    if (! (flags & 1024U)) {
      {
      {
#line 524
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"Loading book from %s.\n",
              *booktry);
      }
      }
    }
    {
    {
#line 530
    tmp___0 = read_size(rfp);
    }
#line 530
    booksize = (uint32_t )((double )tmp___0 * 1.06);
#line 531
    digest_bits = 1;
    }
    {
    {
#line 531
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 531
      if (! booksize) {
#line 531
        goto while_break___0;
      }
#line 532
      digest_bits ++;
#line 531
      booksize >>= 1;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 534
    res = read_book(rfp);
    }
    }
#line 535
    if (res != 0) {
#line 536
      return (res);
    }
#line 538
    if (! (flags & 1024U)) {
      {
      {
#line 539
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)"%d hash collisions... ",
              bookhashcollisions);
      }
      }
    }
  }
  {
#line 542
  mcnt = -1;
#line 543
  side = board.side;
#line 544
  xside = 1 ^ side;
#line 545
  TreePtr[2] = TreePtr[1];
  {
#line 546
  GenMoves(1);
  }
  {
#line 547
  FilterIllegalMoves(1);
  }
#line 548
  p___1 = TreePtr[1];
  }
  {
  {
#line 548
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 548
    if (! ((unsigned long )p___1 < (unsigned long )TreePtr[2])) {
#line 548
      goto while_break___1;
    }
    {
    {
#line 549
    MakeMove(side, & p___1->move);
    }
#line 550
    m[icnt].move = p___1->move;
#line 551
    posshash[icnt] = HashKey;
#line 552
    icnt ++;
    {
#line 553
    UnmakeMove(xside, & p___1->move);
    }
#line 548
    p___1 ++;
    }
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 555
  i = 0;
  {
  {
#line 555
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 555
    if (! (i < icnt)) {
#line 555
      goto while_break___2;
    }
#line 556
    j___0 = (int )(posshash[i] & ((1UL << digest_bits) - 1UL));
    {
    {
#line 556
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
      {
      {
#line 556
      tmp___3 = is_empty((uint32_t )j___0);
      }
      }
#line 556
      if (tmp___3) {
#line 556
        goto while_break___3;
      }
#line 559
      if (posshash[i] == (bookpos + j___0)->key) {
#line 560
        found = 0;
#line 561
        k___0 = 0;
        {
        {
#line 561
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 561
          if (! (k___0 < mcnt)) {
#line 561
            goto while_break___4;
          }
#line 562
          if (matches[k___0] == i) {
#line 563
            found = 1;
#line 564
            goto while_break___4;
          }
#line 561
          k___0 ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 567
        if (! found) {
#line 568
          mcnt ++;
#line 568
          matches[mcnt] = i;
#line 569
          pref[mcnt].move = m[matches[mcnt]].move;
#line 570
          r[i].losses = (bookpos + j___0)->losses;
#line 571
          r[i].wins = (bookpos + j___0)->wins;
#line 572
          r[i].draws = (bookpos + j___0)->draws;
#line 576
          if (((int )r[i].wins + (int )r[i].losses) + (int )r[i].draws > 1) {
#line 576
            tmp___2 = ((int )r[i].wins + (int )r[i].losses) + (int )r[i].draws;
          } else {
#line 576
            tmp___2 = 1;
          }
#line 576
          tmp___1 = (100 * ((int )r[i].wins + (int )r[i].draws / 2)) / tmp___2 + (int )r[i].wins / 2;
#line 576
          m[i].score = tmp___1;
#line 576
          pref[mcnt].score = tmp___1;
        }
#line 581
        if (mcnt >= 100) {
          {
          {
#line 582
          fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" Too many matches in book.\n\n");
          }
          }
#line 583
          goto fini;
        }
#line 585
        goto while_break___3;
      }
#line 556
      j___0 = (int )(((unsigned long )j___0 + ((posshash[i] >> digest_bits) | 1UL)) & ((1UL << digest_bits) - 1UL));
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 555
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  fini: 
#line 591
  if (! (flags & 1024U)) {
#line 591
    goto _L;
  } else
#line 591
  if (BKquery == 1) {
    _L: /* CIL Label */ 
    {
    {
#line 593
    fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" Opening database: %d book positions.\n",
            bookcnt);
    }
    }
#line 594
    if (mcnt + 1 == 0) {
      {
      {
#line 595
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" In this position, there is no book move.\n\n");
      }
      }
    } else
#line 596
    if (mcnt + 1 == 1) {
      {
      {
#line 597
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" In this position, there is one book move:\n");
      }
      }
    } else {
      {
      {
#line 599
      fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" In this position, there are %d book moves:\n",
              mcnt + 1);
      }
      }
    }
  }
#line 603
  if (mcnt == -1) {
#line 604
    return (6);
  }
#line 606
  k___0 = 0;
#line 607
  if (mcnt + 1) {
#line 608
    if (! (flags & 1024U)) {
#line 608
      goto _L___2;
    } else
#line 608
    if (BKquery == 1) {
      _L___2: /* CIL Label */ 
#line 609
      i = 0;
      {
      {
#line 609
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 609
        if (! (i <= mcnt)) {
#line 609
          goto while_break___5;
        }
#line 610
        if (! (flags & 1024U)) {
#line 610
          goto _L___0;
        } else
#line 610
        if (BKquery == 1) {
          _L___0: /* CIL Label */ 
          {
          {
#line 611
          SANMove(m[matches[i]].move, 1);
          }
#line 612
          tot = ((int )r[matches[i]].wins + (int )r[matches[i]].draws) + (int )r[matches[i]].losses;
          {
#line 613
          fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" %s(%2.0f/%d/%d/%d) ",
                  SANmv, (100.0 * ((double )r[matches[i]].wins + (double )r[matches[i]].draws / 2.0)) / (double )tot,
                  (int )r[matches[i]].wins, (int )r[matches[i]].losses, (int )r[matches[i]].draws);
          }
          }
#line 618
          if ((i + 1) % 4 == 0) {
            {
            {
#line 618
            fputc('\n', ofp);
            }
            }
          }
        }
#line 609
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 621
      if (! (flags & 1024U)) {
#line 621
        goto _L___1;
      } else
#line 621
      if (BKquery == 1) {
        _L___1: /* CIL Label */ 
#line 622
        if (i % 4 != 0) {
          {
          {
#line 622
          fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" \n \n");
          }
          }
        }
      }
    }
#line 624
    if (bookmode == 1) {
      {
      {
#line 625
      k___0 = rand();
      }
#line 626
      k___0 %= mcnt + 1;
#line 627
      RootPV = m[matches[k___0]].move;
      }
#line 628
      if (! (flags & 1024U)) {
        {
        {
#line 629
        printf((char const   */* __restrict  */)"\n(Random picked move #%d %s%s from above list)\n",
               k___0, algbr[(RootPV >> 6) & 63], algbr[RootPV & 63]);
        }
#line 631
        tot = ((int )r[matches[k___0]].wins + (int )r[matches[k___0]].draws) + (int )r[matches[k___0]].losses;
        }
#line 632
        if (tot != 0) {
          {
          {
#line 633
          printf((char const   */* __restrict  */)"B p=%2.0f\n", (100.0 * (double )((int )r[matches[k___0]].wins + (int )r[matches[k___0]].draws)) / (double )tot);
          }
          }
        } else {
          {
          {
#line 636
          printf((char const   */* __restrict  */)"p=NO EXPERIENCES\n");
          }
          }
        }
      }
    } else
#line 638
    if (bookmode == 2) {
      {
      {
#line 639
      qsort((void *)(& pref), (size_t )(mcnt + 1), sizeof(leaf ), & compare);
      }
#line 640
      RootPV = pref[0].move;
      }
    } else
#line 641
    if (bookmode == 3) {
      {
      {
#line 642
      qsort((void *)(& pref), (size_t )(mcnt + 1), sizeof(leaf ), & compare);
      }
#line 643
      RootPV = pref[mcnt].move;
      }
    } else
#line 644
    if (bookmode == 4) {
      {
      {
#line 645
      qsort((void *)(& pref), (size_t )(mcnt + 1), sizeof(leaf ), & compare);
      }
#line 646
      i = 0;
      }
      {
      {
#line 646
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 646
        if (! (i <= mcnt)) {
#line 646
          goto while_break___6;
        }
#line 647
        if (! (flags & 1024U)) {
          {
          {
#line 648
          SANMove(pref[i].move, 1);
          }
          {
#line 649
          printf((char const   */* __restrict  */)" %s(%d) ", SANmv, pref[i].score);
          }
          }
        } else
#line 647
        if (BKquery == 1) {
          {
          {
#line 648
          SANMove(pref[i].move, 1);
          }
          {
#line 649
          printf((char const   */* __restrict  */)" %s(%d) ", SANmv, pref[i].score);
          }
          }
        }
#line 651
        m[i].move = pref[i].move;
#line 652
        if (! (flags & 1024U)) {
#line 652
          goto _L___3;
        } else
#line 652
        if (BKquery == 1) {
          _L___3: /* CIL Label */ 
#line 653
          if ((i + 1) % 8 == 0) {
            {
            {
#line 653
            fputc('\n', ofp);
            }
            }
          }
        }
#line 646
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 655
      if (! (flags & 1024U)) {
#line 655
        goto _L___4;
      } else
#line 655
      if (BKquery == 1) {
        _L___4: /* CIL Label */ 
#line 656
        if (i % 8 != 0) {
          {
          {
#line 656
          fprintf((FILE */* __restrict  */)ofp, (char const   */* __restrict  */)" \n \n");
          }
          }
        }
      }
#line 657
      if (bookfirstlast > mcnt + 1) {
#line 657
        temp = mcnt + 1;
      } else {
#line 657
        temp = bookfirstlast;
      }
#line 659
      maxdistribution = 0;
#line 660
      i = 0;
      {
      {
#line 660
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 660
        if (! (i < temp)) {
#line 660
          goto while_break___7;
        }
#line 661
        maxdistribution += pref[i].score;
#line 660
        i ++;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 663
      if (maxdistribution == 0) {
#line 664
        return (6);
      }
      {
      {
#line 665
      tmp___4 = rand();
      }
#line 665
      k___0 = tmp___4 % maxdistribution;
#line 666
      maxdistribution = 0;
#line 667
      i = 0;
      }
      {
      {
#line 667
      while (1) {
        while_continue___18: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 667
        if (! (i < temp)) {
#line 667
          goto while_break___8;
        }
#line 668
        maxdistribution += pref[i].score;
#line 669
        if (k___0 >= maxdistribution - pref[i].score) {
#line 669
          if (k___0 < maxdistribution) {
#line 672
            k___0 = i;
#line 673
            RootPV = m[k___0].move;
#line 674
            goto while_break___8;
          }
        }
#line 667
        i ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
#line 679
  return (0);
}
}
#line 524 "/home/khheo/testset/chess/src/common.h"
BitBoard AttackXTo(int sq , int side ) ;
#line 525
BitBoard AttackFrom(int sq , int piece , int side ) ;
#line 31 "/home/khheo/testset/chess/src/atak.c"
int SqAtakd(int sq , int side ) 
{ 
  register BitBoard *a ;
  register BitBoard b ;
  register BitBoard *c ;
  register BitBoard d ;
  register BitBoard blocker ;
  int t ;

  {
#line 41
  a = board.b[side];
#line 44
  if (*(a + 2) & MoveArray[2][sq]) {
#line 45
    return (1);
  }
#line 48
  if (*(a + 6) & MoveArray[6][sq]) {
#line 49
    return (1);
  }
#line 52
  if (*(a + 1) & MoveArray[ptype[1 ^ side]][sq]) {
#line 53
    return (1);
  }
#line 55
  c = FromToRay[sq];
#line 56
  blocker = board.blocker;
#line 59
  b = (*(a + 3) | *(a + 5)) & MoveArray[3][sq];
#line 60
  d = ~ b & blocker;
  {
  {
#line 61
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 61
    if (! b) {
#line 61
      goto while_break;
    }
    {
    {
#line 63
    t = leadz(b);
    }
    }
#line 64
    if (! (*(c + t) & d)) {
#line 65
      return (1);
    }
#line 66
    b &= NotBitPosArray[t];
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  b = (*(a + 4) | *(a + 5)) & MoveArray[4][sq];
#line 71
  d = ~ b & blocker;
  {
  {
#line 72
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! b) {
#line 72
      goto while_break___0;
    }
    {
    {
#line 74
    t = leadz(b);
    }
    }
#line 75
    if (! (*(c + t) & d)) {
#line 76
      return (1);
    }
#line 77
    b &= NotBitPosArray[t];
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 79
  return (0);
}
}
#line 85 "/home/khheo/testset/chess/src/atak.c"
void GenAtaks(void) 
{ 
  int side ;
  int sq ;
  register BitBoard *a ;
  register BitBoard b ;
  register BitBoard *t ;
  register BitBoard *a0 ;

  {
  {
  {
#line 98
  memset((void *)(Ataks), 0, sizeof(Ataks));
  }
#line 99
  side = 0;
  }
  {
  {
#line 99
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! (side <= 1)) {
#line 99
      goto while_break;
    }
#line 101
    a = board.b[side];
#line 104
    t = & Ataks[side][2];
#line 105
    b = *(a + 2);
    {
    {
#line 106
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! b) {
#line 106
        goto while_break___0;
      }
      {
      {
#line 108
      sq = leadz(b);
      }
#line 109
      b &= NotBitPosArray[sq];
#line 110
      *t |= MoveArray[2][sq];
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    t = & Ataks[side][3];
#line 115
    b = *(a + 3);
    {
    {
#line 116
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 116
      if (! b) {
#line 116
        goto while_break___1;
      }
      {
      {
#line 118
      sq = leadz(b);
      }
#line 119
      b &= NotBitPosArray[sq];
#line 120
      *t |= Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]];
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 124
    t = & Ataks[side][4];
#line 125
    b = *(a + 4);
    {
    {
#line 126
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 126
      if (! b) {
#line 126
        goto while_break___2;
      }
      {
      {
#line 128
      sq = leadz(b);
      }
#line 129
      b &= NotBitPosArray[sq];
#line 130
      *t |= Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL];
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 134
    t = & Ataks[side][5];
#line 135
    b = *(a + 5);
    {
    {
#line 136
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 136
      if (! b) {
#line 136
        goto while_break___3;
      }
      {
      {
#line 138
      sq = leadz(b);
      }
#line 139
      b &= NotBitPosArray[sq];
#line 140
      *t |= (Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) | (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 144
    t = & Ataks[side][6];
#line 145
    b = *(a + 6);
    {
    {
#line 146
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 146
      if (! b) {
#line 146
        goto while_break___4;
      }
      {
      {
#line 148
      sq = leadz(b);
      }
#line 149
      b &= NotBitPosArray[sq];
#line 150
      *t |= MoveArray[6][sq];
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 154
    t = & Ataks[side][1];
#line 155
    if (side == 0) {
#line 157
      b = board.b[0][1] & ~ FileBit[0];
#line 158
      *t |= b >> 7;
#line 159
      b = board.b[0][1] & ~ FileBit[7];
#line 160
      *t |= b >> 9;
    } else {
#line 164
      b = board.b[1][1] & ~ FileBit[0];
#line 165
      *t |= b << 9;
#line 166
      b = board.b[1][1] & ~ FileBit[7];
#line 167
      *t |= b << 7;
    }
#line 169
    a0 = Ataks[side];
#line 170
    *(a0 + 0) = ((((*(a0 + 1) | *(a0 + 2)) | *(a0 + 3)) | *(a0 + 4)) | *(a0 + 5)) | *(a0 + 6);
#line 99
    side ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 176 "/home/khheo/testset/chess/src/atak.c"
BitBoard AttackTo(int sq , int side ) 
{ 
  register BitBoard *a ;
  register BitBoard b ;
  register BitBoard *c ;
  register BitBoard e ;
  register BitBoard blocker ;
  int t ;

  {
#line 187
  a = board.b[side];
#line 190
  e = *(a + 2) & MoveArray[2][sq];
#line 193
  e |= *(a + 6) & MoveArray[6][sq];
#line 196
  e |= *(a + 1) & MoveArray[ptype[1 ^ side]][sq];
#line 198
  c = FromToRay[sq];
#line 199
  blocker = board.blocker;
#line 202
  b = (*(a + 3) | *(a + 5)) & MoveArray[3][sq];
  {
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 203
    if (! b) {
#line 203
      goto while_break;
    }
    {
    {
#line 205
    t = leadz(b);
    }
#line 206
    b &= NotBitPosArray[t];
    }
#line 207
    if (! ((*(c + t) & blocker) & NotBitPosArray[t])) {
#line 208
      e |= BitPosArray[t];
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  b = (*(a + 4) | *(a + 5)) & MoveArray[4][sq];
  {
  {
#line 213
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 213
    if (! b) {
#line 213
      goto while_break___0;
    }
    {
    {
#line 215
    t = leadz(b);
    }
#line 216
    b &= NotBitPosArray[t];
    }
#line 217
    if (! ((*(c + t) & blocker) & NotBitPosArray[t])) {
#line 218
      e |= BitPosArray[t];
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 221
  return (e);
}
}
#line 225 "/home/khheo/testset/chess/src/atak.c"
BitBoard AttackXTo(int sq , int side ) 
{ 
  register BitBoard *a ;
  register BitBoard b ;
  register BitBoard *c ;
  register BitBoard *d ;
  register BitBoard e ;
  register BitBoard blocker ;
  int t ;

  {
#line 239
  a = board.b[side];
#line 240
  d = board.b[1 ^ side];
#line 243
  e = *(a + 2) & MoveArray[2][sq];
#line 246
  e |= *(a + 6) & MoveArray[6][sq];
#line 248
  c = FromToRay[sq];
#line 251
  b = *(a + 1) & MoveArray[ptype[1 ^ side]][sq];
#line 252
  blocker = board.blocker;
#line 253
  blocker &= ~ ((((*(a + 3) | *(a + 5)) | *(d + 3)) | *(d + 5)) | b);
#line 254
  b |= (*(a + 3) | *(a + 5)) & MoveArray[3][sq];
  {
  {
#line 255
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 255
    if (! b) {
#line 255
      goto while_break;
    }
    {
    {
#line 257
    t = leadz(b);
    }
#line 258
    b &= NotBitPosArray[t];
    }
#line 259
    if (! ((*(c + t) & blocker) & NotBitPosArray[t])) {
#line 260
      e |= BitPosArray[t];
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  b = (*(a + 4) | *(a + 5)) & MoveArray[4][sq];
#line 265
  blocker = board.blocker;
#line 266
  blocker &= ~ (((*(a + 4) | *(a + 5)) | *(d + 4)) | *(d + 5));
  {
  {
#line 267
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! b) {
#line 267
      goto while_break___0;
    }
    {
    {
#line 269
    t = leadz(b);
    }
#line 270
    b &= NotBitPosArray[t];
    }
#line 271
    if (! ((*(c + t) & blocker) & NotBitPosArray[t])) {
#line 272
      e |= BitPosArray[t];
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 275
  return (e);
}
}
#line 279 "/home/khheo/testset/chess/src/atak.c"
BitBoard AttackFrom(int sq , int piece , int side ) 
{ 


  {
  {
#line 288
  if (piece == 1) {
#line 288
    goto case_1;
  }
#line 290
  if (piece == 2) {
#line 290
    goto case_2;
  }
#line 292
  if (piece == 3) {
#line 292
    goto case_3;
  }
#line 294
  if (piece == 4) {
#line 294
    goto case_4;
  }
#line 296
  if (piece == 5) {
#line 296
    goto case_5;
  }
#line 298
  if (piece == 6) {
#line 298
    goto case_6;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  return (MoveArray[ptype[side]][sq]);
  case_2: /* CIL Label */ 
#line 291
  return (MoveArray[2][sq]);
  case_3: /* CIL Label */ 
#line 293
  return (Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]);
  case_4: /* CIL Label */ 
#line 295
  return (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]);
  case_5: /* CIL Label */ 
#line 297
  return ((Bishop45Atak[sq][(board.blockerr45 >> Shift45[sq]) & (unsigned long )Mask45[sq]] | Bishop315Atak[sq][(board.blockerr315 >> Shift315[sq]) & (unsigned long )Mask315[sq]]) | (Rook00Atak[sq][(board.blocker >> Shift00[sq]) & 255UL] | Rook90Atak[sq][(board.blockerr90 >> Shift90[sq]) & 255UL]));
  case_6: /* CIL Label */ 
#line 299
  return (MoveArray[6][sq]);
  switch_break: /* CIL Label */ ;
  }
#line 301
  return ((BitBoard )0);
}
}
#line 305 "/home/khheo/testset/chess/src/atak.c"
BitBoard AttackXFrom(int sq , int side ) 
{ 
  register BitBoard *a ;
  register BitBoard b ;
  register BitBoard c ;
  register BitBoard blocker ;
  int piece ;
  int dir___0 ;
  int blocksq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 317
  a = board.b[side];
#line 318
  piece = cboard[sq];
#line 319
  blocker = board.blocker;
#line 320
  b = (BitBoard )0;
  {
#line 323
  if (piece == 1) {
#line 323
    goto case_1;
  }
#line 326
  if (piece == 2) {
#line 326
    goto case_2;
  }
#line 330
  if (piece == 5) {
#line 330
    goto case_5;
  }
#line 330
  if (piece == 3) {
#line 330
    goto case_5;
  }
#line 347
  if (piece == 4) {
#line 347
    goto case_4;
  }
#line 362
  if (piece == 6) {
#line 362
    goto case_6;
  }
#line 321
  goto switch_break;
  case_1: /* CIL Label */ 
#line 324
  b = MoveArray[ptype[side]][sq];
#line 325
  goto switch_break;
  case_2: /* CIL Label */ 
#line 327
  b = MoveArray[2][sq];
#line 328
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 331
  blocker &= ~ (*(a + 3) | *(a + 5));
#line 332
  dir___0 = (int )raybeg[3];
  {
  {
#line 332
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 332
    if (! (dir___0 < (int )rayend[3])) {
#line 332
      goto while_break;
    }
#line 334
    c = Ray[sq][dir___0] & blocker;
#line 335
    if ((unsigned long long )c == 0ULL) {
#line 336
      c = Ray[sq][dir___0];
    } else {
#line 339
      if (BitPosArray[sq] > c) {
        {
        {
#line 339
        tmp = leadz(c);
        }
#line 339
        blocksq = tmp;
        }
      } else {
        {
        {
#line 339
        tmp___0 = leadz(c & (~ c + 1UL));
        }
#line 339
        blocksq = tmp___0;
        }
      }
#line 340
      c = FromToRay[sq][blocksq];
    }
#line 342
    b |= c;
#line 332
    dir___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  if (piece == 3) {
#line 345
    goto switch_break;
  }
#line 346
  blocker = board.blocker;
  case_4: /* CIL Label */ 
#line 348
  blocker &= ~ (*(a + 4) | *(a + 5));
#line 349
  dir___0 = (int )raybeg[4];
  {
  {
#line 349
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (dir___0 < (int )rayend[4])) {
#line 349
      goto while_break___0;
    }
#line 351
    c = Ray[sq][dir___0] & blocker;
#line 352
    if ((unsigned long long )c == 0ULL) {
#line 353
      c = Ray[sq][dir___0];
    } else {
#line 356
      if (BitPosArray[sq] > c) {
        {
        {
#line 356
        tmp___1 = leadz(c);
        }
#line 356
        blocksq = tmp___1;
        }
      } else {
        {
        {
#line 356
        tmp___2 = leadz(c & (~ c + 1UL));
        }
#line 356
        blocksq = tmp___2;
        }
      }
#line 357
      c = FromToRay[sq][blocksq];
    }
#line 359
    b |= c;
#line 349
    dir___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  goto switch_break;
  case_6: /* CIL Label */ 
#line 363
  b = MoveArray[6][sq];
#line 364
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 366
  return (b);
}
}
#line 370 "/home/khheo/testset/chess/src/atak.c"
int PinnedOnKing(int sq , int side ) 
{ 
  int xside ;
  int KingSq___0 ;
  int dir___0 ;
  int sq1 ;
  BitBoard b ;
  BitBoard blocker ;
  int tmp ;
  int tmp___0 ;

  {
#line 385
  KingSq___0 = board.king[side];
#line 386
  dir___0 = directions[KingSq___0][sq];
#line 386
  if (dir___0 == -1) {
#line 387
    return (0);
  }
#line 389
  xside = 1 ^ side;
#line 390
  blocker = board.blocker;
#line 393
  if ((FromToRay[KingSq___0][sq] & NotBitPosArray[sq]) & blocker) {
#line 394
    return (0);
  }
#line 395
  b = (Ray[KingSq___0][dir___0] ^ FromToRay[KingSq___0][sq]) & blocker;
#line 396
  if ((unsigned long long )b == 0ULL) {
#line 397
    return (0);
  }
#line 398
  if (sq > KingSq___0) {
    {
    {
#line 398
    tmp = leadz(b);
    }
#line 398
    sq1 = tmp;
    }
  } else {
    {
    {
#line 398
    tmp___0 = leadz(b & (~ b + 1UL));
    }
#line 398
    sq1 = tmp___0;
    }
  }
#line 401
  if (dir___0 <= 3) {
#line 401
    if (BitPosArray[sq1] & (board.b[xside][5] | board.b[xside][3])) {
#line 403
      return (1);
    }
  }
#line 406
  if (dir___0 >= 4) {
#line 406
    if (BitPosArray[sq1] & (board.b[xside][5] | board.b[xside][4])) {
#line 408
      return (1);
    }
  }
#line 410
  return (0);
}
}
#line 414 "/home/khheo/testset/chess/src/atak.c"
void FindPins(BitBoard *pin ) 
{ 
  int side ;
  int xside ;
  int sq ;
  int sq1 ;
  BitBoard b ;
  BitBoard c ;
  BitBoard e ;
  BitBoard f ;
  BitBoard t ;
  BitBoard *p___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 425
  *pin = (BitBoard )0ULL;
#line 426
  t = board.friends[0] | board.friends[1];
#line 427
  side = 0;
  {
  {
#line 427
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 427
    if (! (side <= 1)) {
#line 427
      goto while_break;
    }
#line 429
    xside = 1 ^ side;
#line 430
    p___1 = board.b[xside];
#line 433
    e = (*(p___1 + 4) | *(p___1 + 5)) | *(p___1 + 6);
#line 434
    e |= (*(p___1 + 3) | *(p___1 + 2)) & ~ Ataks[xside][0];
#line 435
    b = board.b[side][3];
    {
    {
#line 436
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 436
      if (! b) {
#line 436
        goto while_break___0;
      }
      {
      {
#line 438
      sq = leadz(b);
      }
#line 439
      b &= NotBitPosArray[sq];
#line 441
      c = MoveArray[3][sq] & e;
      }
      {
      {
#line 442
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 442
        if (! c) {
#line 442
          goto while_break___1;
        }
        {
        {
#line 444
        sq1 = leadz(c);
        }
#line 445
        c &= NotBitPosArray[sq1];
#line 446
        f = (t & NotBitPosArray[sq]) & FromToRay[sq1][sq];
        }
#line 447
        if (board.friends[xside] & f) {
          {
          {
#line 447
          tmp = nbits(f);
          }
          }
#line 447
          if (tmp == 1) {
#line 448
            *pin |= f;
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    e = *(p___1 + 5) | *(p___1 + 6);
#line 454
    e |= ((*(p___1 + 4) | *(p___1 + 3)) | *(p___1 + 2)) & ~ Ataks[xside][0];
#line 455
    b = board.b[side][4];
    {
    {
#line 456
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 456
      if (! b) {
#line 456
        goto while_break___2;
      }
      {
      {
#line 458
      sq = leadz(b);
      }
#line 459
      b &= NotBitPosArray[sq];
#line 461
      c = MoveArray[4][sq] & e;
      }
      {
      {
#line 462
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 462
        if (! c) {
#line 462
          goto while_break___3;
        }
        {
        {
#line 464
        sq1 = leadz(c);
        }
#line 465
        c &= NotBitPosArray[sq1];
#line 466
        f = (t & NotBitPosArray[sq]) & FromToRay[sq1][sq];
        }
#line 467
        if (board.friends[xside] & f) {
          {
          {
#line 467
          tmp___0 = nbits(f);
          }
          }
#line 467
          if (tmp___0 == 1) {
#line 468
            *pin |= f;
          }
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 473
    e = board.b[xside][6];
#line 474
    e |= (((*(p___1 + 5) | *(p___1 + 4)) | *(p___1 + 3)) | *(p___1 + 2)) & ~ Ataks[xside][0];
#line 475
    b = board.b[side][5];
    {
    {
#line 476
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 476
      if (! b) {
#line 476
        goto while_break___4;
      }
      {
      {
#line 478
      sq = leadz(b);
      }
#line 479
      b &= NotBitPosArray[sq];
#line 481
      c = MoveArray[5][sq] & e;
      }
      {
      {
#line 482
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 482
        if (! c) {
#line 482
          goto while_break___5;
        }
        {
        {
#line 484
        sq1 = leadz(c);
        }
#line 485
        c &= NotBitPosArray[sq1];
#line 486
        f = (t & NotBitPosArray[sq]) & FromToRay[sq1][sq];
        }
#line 487
        if (board.friends[xside] & f) {
          {
          {
#line 487
          tmp___1 = nbits(f);
          }
          }
#line 487
          if (tmp___1 == 1) {
#line 489
            *pin |= f;
          }
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 427
    side ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 498 "/home/khheo/testset/chess/src/atak.c"
int MateScan(int side ) 
{ 
  int KingSq___0 ;
  int QueenSq ;
  int sq ;
  int xside ;
  BitBoard b ;
  BitBoard tmp ;
  BitBoard tmp___0 ;

  {
#line 512
  xside = 1 ^ side;
#line 515
  if (board.b[xside][5] == 0UL) {
#line 516
    return (0);
  }
  {
#line 518
  KingSq___0 = board.king[side];
  {
#line 519
  QueenSq = leadz(board.b[xside][5]);
  }
#line 520
  b = ((Bishop45Atak[QueenSq][(board.blockerr45 >> Shift45[QueenSq]) & (unsigned long )Mask45[QueenSq]] | Bishop315Atak[QueenSq][(board.blockerr315 >> Shift315[QueenSq]) & (unsigned long )Mask315[QueenSq]]) | (Rook00Atak[QueenSq][(board.blocker >> Shift00[QueenSq]) & 255UL] | Rook90Atak[QueenSq][(board.blockerr90 >> Shift90[QueenSq]) & 255UL])) & MoveArray[6][KingSq___0];
  }
#line 521
  if (b == 0UL) {
#line 522
    return (0);
  }
  {
  {
#line 524
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 524
    if (! b) {
#line 524
      goto while_break;
    }
    {
    {
#line 526
    sq = leadz(b);
    }
    {
#line 527
    tmp = AttackTo(sq, side);
    }
    }
#line 527
    if (tmp == board.b[side][6]) {
      {
      {
#line 527
      tmp___0 = AttackXTo(sq, xside);
      }
      }
#line 527
      if (tmp___0 != board.b[xside][5]) {
#line 529
        return (1);
      }
    }
#line 530
    b &= NotBitPosArray[sq];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return (0);
}
}
