/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 34 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.h"
struct __anonstruct_v10_24 {
   char comment[31] ;
};
#line 34 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.h"
struct __anonstruct_v11_25 {
   char comment[29] ;
   char track ;
};
#line 34 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.h"
union __anonunion_u_23 {
   struct __anonstruct_v10_24 v10 ;
   struct __anonstruct_v11_25 v11 ;
};
#line 34 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.h"
struct ID3_struct {
   char version ;
   char tag[4] ;
   char songname[31] ;
   char artist[31] ;
   char album[31] ;
   char year[5] ;
   union __anonunion_u_23 u ;
   int genre ;
};
#line 34 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.h"
typedef struct ID3_struct ID3_tag;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 56 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.h"
struct __anonstruct_FLAGS_struct_27 {
   short logging ;
   short no_tag_prompt ;
   short no_config ;
   short quiet ;
   short verbose ;
   short show_tag ;
   short tag_ffn ;
   short strip_tag ;
   short force_tag ;
   short tag_only ;
   short edit_tag ;
   short no_year ;
   short no_album ;
   short no_comment ;
   short no_genre ;
   short no_track ;
   short ulcase ;
};
#line 56 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.h"
typedef struct __anonstruct_FLAGS_struct_27 FLAGS_struct;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 799
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 1020
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 57 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.h"
int add_to_log(char *data ) ;
#line 58
int id3_read_file(char *dest , unsigned long size , FILE *fp , char *fn ) ;
#line 59
int id3_write_file(char *src , unsigned long size , FILE *fp , char *fn ) ;
#line 60
int id3_open_file(FILE **fp , char *fn , char *mode ) ;
#line 61
int id3_close_file(FILE *fp ) ;
#line 62
int id3_seek_header(FILE *fp , char *fn ) ;
#line 63
int id3_strip_tag(long sizelesstag , char *fn ) ;
#line 65
int id3_write_tag(ID3_tag *tag , int append_flag , char *fn ) ;
#line 66
int id3_read_tag(ID3_tag *tag , FILE *fp , char *fn ) ;
#line 67
void id3_show_tag(ID3_tag *tag , char *fn ) ;
#line 25 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3genre.h"
char *genre_table[126]  = 
#line 25 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3genre.h"
  {      (char *)"Blues",      (char *)"Classic Rock",      (char *)"Country",      (char *)"Dance", 
        (char *)"Disco",      (char *)"Funk",      (char *)"Grunge",      (char *)"Hip-Hop", 
        (char *)"Jazz",      (char *)"Metal",      (char *)"New Age",      (char *)"Oldies", 
        (char *)"Other",      (char *)"Pop",      (char *)"R&B",      (char *)"Rap", 
        (char *)"Reggae",      (char *)"Rock",      (char *)"Techno",      (char *)"Industrial", 
        (char *)"Alternative",      (char *)"Ska",      (char *)"Death Metal",      (char *)"Pranks", 
        (char *)"Soundtrack",      (char *)"Euro-Techno",      (char *)"Ambient",      (char *)"Trip-Hop", 
        (char *)"Vocal",      (char *)"Jazz+Funk",      (char *)"Fusion",      (char *)"Trance", 
        (char *)"Classical",      (char *)"Instrumental",      (char *)"Acid",      (char *)"House", 
        (char *)"Game",      (char *)"Sound Clip",      (char *)"Gospel",      (char *)"Noise", 
        (char *)"AlternRock",      (char *)"Bass",      (char *)"Soul",      (char *)"Punk", 
        (char *)"Space",      (char *)"Meditative",      (char *)"Instrum. Pop",      (char *)"Instrum. Rock", 
        (char *)"Ethnic",      (char *)"Gothic",      (char *)"Darkwave",      (char *)"Techno-Industrial", 
        (char *)"Electronic",      (char *)"Pop-Folk",      (char *)"Eurodance",      (char *)"Dream", 
        (char *)"Southern Rock",      (char *)"Comedy",      (char *)"Cult",      (char *)"Gangsta", 
        (char *)"Top",      (char *)"Christian Rap",      (char *)"Pop/Funk",      (char *)"Jungle", 
        (char *)"Native American",      (char *)"Cabaret",      (char *)"New Wave",      (char *)"Psychadelic", 
        (char *)"Rave",      (char *)"Showtunes",      (char *)"Trailer",      (char *)"Lo-Fi", 
        (char *)"Tribal",      (char *)"Acid Punk",      (char *)"Acid Jazz",      (char *)"Polka", 
        (char *)"Retro",      (char *)"Musical",      (char *)"Rock & Roll",      (char *)"Hard Rock", 
        (char *)"Folk",      (char *)"Folk-Rock",      (char *)"National Folk",      (char *)"Swing", 
        (char *)"Fast Fusion",      (char *)"Bebob",      (char *)"Latin",      (char *)"Revival", 
        (char *)"Celtic",      (char *)"Bluegrass",      (char *)"Avantgarde",      (char *)"Gothic Rock", 
        (char *)"Prog. Rock",      (char *)"Psychedel. Rock",      (char *)"Symph. Rock",      (char *)"Slow Rock", 
        (char *)"Big Band",      (char *)"Chorus",      (char *)"Easy Listening",      (char *)"Acoustic", 
        (char *)"Humour",      (char *)"Speech",      (char *)"Chanson",      (char *)"Opera", 
        (char *)"Chamber Music",      (char *)"Sonata",      (char *)"Symphony",      (char *)"Booty Bass", 
        (char *)"Primus",      (char *)"Porn Groove",      (char *)"Satire",      (char *)"Slow Jam", 
        (char *)"Club",      (char *)"Tango",      (char *)"Samba",      (char *)"Folklore", 
        (char *)"Ballad",      (char *)"Power Ballad",      (char *)"Rhythmic Soul",      (char *)"Freestyle", 
        (char *)"Duet",      (char *)"Punk Rock",      (char *)"Drum Solo",      (char *)"Acapella", 
        (char *)"Euro-House",      (char *)"Dance Hall"};
#line 155 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3genre.h"
int const   genre_count  =    (int const   )125;
#line 28 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.h"
void print_error(char *format  , ...) ;
#line 29
void user_message(int errflag , char *format  , ...) ;
#line 37 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
char const   logfile[11]  = 
#line 37 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
  {      (char const   )'i',      (char const   )'d',      (char const   )'3',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'.',      (char const   )'l', 
        (char const   )'o',      (char const   )'g',      (char const   )'\000'};
#line 40 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int add_to_log(char *data ) 
{ 
  FILE *fp ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 45
  tmp = id3_open_file(& fp, (char *)(logfile), (char *)"at");
  }
  }
#line 45
  if (tmp == 0) {
#line 46
    return (0);
  }
  {
  {
#line 48
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", data);
  }
  {
#line 49
  fclose(fp);
  }
  }
#line 51
  return (1);
}
}
#line 55 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_read_file(char *dest , unsigned long size , FILE *fp , char *fn ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 58
  tmp = fread((void */* __restrict  */)dest, (size_t )size, (size_t )1, (FILE */* __restrict  */)fp);
  }
  }
#line 58
  if (tmp != 1U) {
    {
    {
#line 60
    print_error((char *)"id3_read_file: Error reading %s", fn);
    }
    {
#line 61
    fclose(fp);
    }
    }
#line 62
    return (0);
  }
  {
  {
#line 65
  tmp___0 = ferror(fp);
  }
  }
#line 65
  if (tmp___0 != 0) {
    {
    {
#line 67
    print_error((char *)"id3_read_file: Error reading %s", fn);
    }
    {
#line 68
    clearerr(fp);
    }
    {
#line 69
    fclose(fp);
    }
    }
#line 70
    return (0);
  }
  {
  {
#line 73
  tmp___1 = feof(fp);
  }
  }
#line 73
  if (tmp___1) {
    {
    {
#line 75
    print_error((char *)"id3_read_file: Premature end of file in %s", fn);
    }
    {
#line 76
    fclose(fp);
    }
    }
#line 77
    return (0);
  }
#line 80
  return (1);
}
}
#line 84 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_write_file(char *src , unsigned long size , FILE *fp , char *fn ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 87
  tmp = fwrite((void const   */* __restrict  */)src, (size_t )size, (size_t )1, (FILE */* __restrict  */)fp);
  }
  }
#line 87
  if (tmp != 1U) {
    {
    {
#line 89
    print_error((char *)"id3_write_file: Error writing to %s", fn);
    }
    {
#line 90
    fclose(fp);
    }
    }
#line 91
    return (0);
  }
  {
  {
#line 94
  tmp___0 = ferror(fp);
  }
  }
#line 94
  if (tmp___0 != 0) {
    {
    {
#line 96
    print_error((char *)"id3_write_file: Error writing to %s", fn);
    }
    {
#line 97
    clearerr(fp);
    }
    {
#line 98
    fclose(fp);
    }
    }
#line 99
    return (0);
  }
#line 102
  return (1);
}
}
#line 106 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_open_file(FILE **fp , char *fn , char *mode ) 
{ 
  char *__cil_tmp4 ;

  {
  {
  {
#line 109
  *fp = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)mode);
  }
  }
#line 111
  if ((unsigned long )*fp == (unsigned long )((void *)0)) {
    {
    {
#line 113
    print_error((char *)"id3_open_file: Error opening file %s", fn);
    }
    }
#line 114
    return (0);
  }
#line 117
  return (1);
}
}
#line 120 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_close_file(FILE *fp ) 
{ 
  int tmp ;

  {
  {
  {
#line 123
  tmp = fclose(fp);
  }
  }
#line 123
  return (tmp);
}
}
#line 126 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_seek_header(FILE *fp , char *fn ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 130
  tmp = fseek(fp, -128L, 2);
  }
  }
#line 130
  if (tmp < 0) {
    {
    {
#line 132
    fclose(fp);
    }
    {
#line 133
    print_error((char *)"id3_seek_header: Error reading file %s", fn);
    }
    }
#line 134
    return (0);
  }
#line 137
  return (1);
}
}
#line 141 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_strip_tag(long sizelesstag , char *fn ) 
{ 
  int fd ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 146
  fd = open((char const   *)fn, 2);
  }
  }
#line 148
  if (fd == -1) {
    {
    {
#line 150
    print_error((char *)"strip_tag: Error opening %s", fn);
    }
    }
#line 151
    return (0);
  }
  {
  {
#line 157
  ftruncate(fd, sizelesstag);
  }
  {
#line 160
  close(fd);
  }
  }
#line 161
  return (1);
}
}
#line 183
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 164 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_write_tag(ID3_tag *tag , int append_flag , char *fn ) 
{ 
  FILE *fp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 169
  if (append_flag == 1) {
    {
    {
#line 171
    tmp = id3_open_file(& fp, fn, (char *)"ab");
    }
    }
#line 171
    if (tmp == 0) {
#line 172
      return (0);
    }
  } else {
    {
    {
#line 176
    tmp___0 = id3_open_file(& fp, fn, (char *)"r+b");
    }
    }
#line 176
    if (tmp___0 == 0) {
#line 177
      return (0);
    }
    {
    {
#line 179
    tmp___1 = id3_seek_header(fp, fn);
    }
    }
#line 179
    if (tmp___1 == 0) {
#line 180
      return (0);
    }
  }
  {
  {
#line 183
  strcpy(tag->tag, "TAG");
  }
  {
#line 184
  tmp___2 = id3_write_file(tag->tag, sizeof(tag->tag) - 1UL, fp, fn);
  }
  }
#line 184
  if (! tmp___2) {
#line 185
    return (0);
  }
  {
  {
#line 186
  tmp___3 = id3_write_file(tag->songname, sizeof(tag->songname) - 1UL, fp, fn);
  }
  }
#line 186
  if (! tmp___3) {
#line 187
    return (0);
  }
  {
  {
#line 188
  tmp___4 = id3_write_file(tag->artist, sizeof(tag->artist) - 1UL, fp, fn);
  }
  }
#line 188
  if (! tmp___4) {
#line 189
    return (0);
  }
  {
  {
#line 190
  tmp___5 = id3_write_file(tag->album, sizeof(tag->album) - 1UL, fp, fn);
  }
  }
#line 190
  if (! tmp___5) {
#line 191
    return (0);
  }
  {
  {
#line 192
  tmp___6 = id3_write_file(tag->year, sizeof(tag->year) - 1UL, fp, fn);
  }
  }
#line 192
  if (! tmp___6) {
#line 193
    return (0);
  }
  {
  {
#line 194
  tmp___7 = id3_write_file(tag->u.v10.comment, sizeof(tag->u.v10.comment) - 1UL, fp,
                           fn);
  }
  }
#line 194
  if (! tmp___7) {
#line 195
    return (0);
  }
  {
  {
#line 198
  tmp___8 = fputc(tag->genre, fp);
  }
  }
#line 198
  if (tmp___8 == -1) {
    {
    {
#line 200
    fclose(fp);
    }
    {
#line 201
    print_error((char *)"write_tag: Error writing to %s", fn);
    }
    }
#line 202
    return (0);
  }
  {
  {
#line 205
  fclose(fp);
  }
  }
#line 206
  return (1);
}
}
#line 210 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
int id3_read_tag(ID3_tag *tag , FILE *fp , char *fn ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 213
  tmp = id3_read_file(tag->songname, sizeof(tag->songname) - 1UL, fp, fn);
  }
  }
#line 213
  if (! tmp) {
#line 214
    return (0);
  }
  {
  {
#line 215
  tmp___0 = id3_read_file(tag->artist, sizeof(tag->artist) - 1UL, fp, fn);
  }
  }
#line 215
  if (! tmp___0) {
#line 216
    return (0);
  }
  {
  {
#line 217
  tmp___1 = id3_read_file(tag->album, sizeof(tag->album) - 1UL, fp, fn);
  }
  }
#line 217
  if (! tmp___1) {
#line 218
    return (0);
  }
  {
  {
#line 219
  tmp___2 = id3_read_file(tag->year, sizeof(tag->year) - 1UL, fp, fn);
  }
  }
#line 219
  if (! tmp___2) {
#line 220
    return (0);
  }
  {
  {
#line 221
  tmp___3 = id3_read_file(tag->u.v10.comment, sizeof(tag->u.v10.comment) - 1UL, fp,
                          fn);
  }
  }
#line 221
  if (! tmp___3) {
#line 222
    return (0);
  }
#line 225
  if ((int )tag->u.v10.comment[28] == 0) {
#line 225
    if ((int )tag->u.v10.comment[29] != 0) {
#line 227
      tag->version = (char)1;
    }
  }
  {
  {
#line 230
  tag->genre = fgetc(fp);
  }
  }
#line 232
  if (tag->genre == -1) {
    {
    {
#line 234
    fclose(fp);
    }
    {
#line 235
    print_error((char *)"tag_file: Error reading %s", fn);
    }
    }
#line 236
    return (0);
  }
#line 239
  return (1);
}
}
#line 247
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 242 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3file.c"
void id3_show_tag(ID3_tag *tag , char *fn ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 245
  user_message(0, (char *)"===> %s:\n", fn);
  }
  {
#line 247
  tmp = (int )strlen(tag->songname);
  }
  }
#line 247
  if (tmp > 0) {
    {
    {
#line 248
    user_message(0, (char *)"Song Name: %s\n", tag->songname);
    }
    }
  }
  {
  {
#line 250
  tmp___0 = (int )strlen(tag->artist);
  }
  }
#line 250
  if (tmp___0 > 0) {
    {
    {
#line 251
    user_message(0, (char *)"   Artist: %s\n", tag->artist);
    }
    }
  }
  {
  {
#line 253
  tmp___1 = (int )strlen(tag->album);
  }
  }
#line 253
  if (tmp___1 > 0) {
    {
    {
#line 254
    user_message(0, (char *)"    Album: %s\n", tag->album);
    }
    }
  }
  {
  {
#line 256
  tmp___2 = (int )strlen(tag->year);
  }
  }
#line 256
  if (tmp___2 > 0) {
    {
    {
#line 257
    user_message(0, (char *)"     Year: %s\n", tag->year);
    }
    }
  }
  {
  {
#line 259
  tmp___3 = (int )strlen(tag->u.v10.comment);
  }
  }
#line 259
  if (tmp___3 > 0) {
    {
    {
#line 260
    user_message(0, (char *)"  Comment: %s\n", tag->u.v10.comment);
    }
    }
  }
#line 262
  if ((int )tag->version == 1) {
#line 262
    if ((int )tag->u.v11.track != 0) {
      {
      {
#line 263
      user_message(0, (char *)"    Track: %02d\n", (int )tag->u.v11.track);
      }
      }
    }
  }
#line 265
  if (tag->genre >= 0) {
#line 265
    if (tag->genre < (int )genre_count) {
      {
      {
#line 266
      user_message(0, (char *)"    Genre: %s\n", genre_table[tag->genre]);
      }
      }
    }
  }
  {
  {
#line 268
  user_message(0, (char *)"\n");
  }
  }
#line 269
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 356
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 471
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 24 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.h"
void alloc_string(char **dest , unsigned long size ) ;
#line 25
int strcase_search(char *in_s1 , char *in_s2 ) ;
#line 26
void string_lower(char *lowstr ) ;
#line 27
int get_term_lines(void) ;
#line 34 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
FLAGS_struct flags ;
#line 35
char *program_name ;
#line 38 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
void alloc_string(char **dest , unsigned long size ) 
{ 
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 41
  tmp = malloc((size_t )size);
  }
#line 41
  *dest = (char *)tmp;
  }
#line 43
  if ((unsigned long )*dest == (unsigned long )((void *)0)) {
    {
    {
#line 45
    print_error((char *)"alloc_string: Out of memory for malloc");
    }
    {
#line 46
    exit(1);
    }
    }
  }
#line 48
  return;
}
}
#line 50 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
int strcase_search(char *in_s1 , char *in_s2 ) 
{ 
  char *s1 ;
  char *s2 ;
  int retflag ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 54
  retflag = 0;
  {
#line 56
  tmp = strlen((char const   *)in_s1);
  }
  {
#line 56
  tmp___0 = malloc(tmp + 1U);
  }
#line 56
  s1 = (char *)tmp___0;
  }
#line 57
  if ((unsigned long )s1 == (unsigned long )((void *)0)) {
    {
    {
#line 59
    print_error((char *)"strcase_search: Out of memory for malloc");
    }
    {
#line 60
    exit(1);
    }
    }
  }
  {
  {
#line 62
  tmp___1 = strlen((char const   *)in_s2);
  }
  {
#line 62
  tmp___2 = malloc(tmp___1 + 1U);
  }
#line 62
  s2 = (char *)tmp___2;
  }
#line 63
  if ((unsigned long )s2 == (unsigned long )((void *)0)) {
    {
    {
#line 65
    free((void *)s1);
    }
    {
#line 66
    print_error((char *)"strcase_search: Out of memory for malloc");
    }
    {
#line 67
    exit(1);
    }
    }
  }
  {
  {
#line 70
  strcpy((char */* __restrict  */)s1, (char const   */* __restrict  */)in_s1);
  }
  {
#line 71
  strcpy((char */* __restrict  */)s2, (char const   */* __restrict  */)in_s2);
  }
  {
#line 72
  string_lower(s1);
  }
  {
#line 73
  string_lower(s2);
  }
  {
#line 75
  tmp___3 = strstr((char const   *)s1, (char const   *)s2);
  }
  }
#line 75
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 76
    retflag = 0;
  } else {
#line 78
    retflag = 1;
  }
  {
  {
#line 80
  free((void *)s1);
  }
  {
#line 81
  free((void *)s2);
  }
  }
#line 82
  return (retflag);
}
}
#line 85 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
void string_lower(char *lowstr ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 90
  i = 0;
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 90
    tmp___0 = strlen((char const   *)lowstr);
    }
    }
#line 90
    if (! ((size_t )i < tmp___0)) {
#line 90
      goto while_break;
    }
    {
    {
#line 91
    tmp = tolower((int )*(lowstr + i));
    }
#line 91
    *(lowstr + i) = (char )tmp;
#line 90
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 95 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
int get_term_lines(void) 
{ 
  char *lines ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 100
  lines = getenv("LINES");
  }
  }
#line 102
  if ((unsigned long )lines == (unsigned long )((void *)0)) {
#line 103
    return (25);
  } else {
    {
    {
#line 102
    tmp = atoi((char const   *)lines);
    }
    }
#line 102
    if (tmp < 1) {
#line 103
      return (25);
    }
  }
  {
  {
#line 105
  tmp___0 = atoi((char const   *)lines);
  }
  }
#line 105
  return (tmp___0);
}
}
#line 109 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
void print_error(char *format  , ...) 
{ 
  char buf[1024] ;
  va_list msg ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 115
  __builtin_va_start(msg, format);
  }
  {
#line 116
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)format,
           msg);
  }
  {
#line 117
  __builtin_va_end(msg);
  }
  {
#line 119
  tmp = __errno_location();
  }
  {
#line 119
  tmp___0 = strerror(*tmp);
  }
  {
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
          program_name, buf, tmp___0);
  }
  }
#line 121
  if ((int )flags.logging == 1) {
    {
    {
#line 123
    tmp___1 = __errno_location();
    }
    {
#line 123
    tmp___2 = strerror(*tmp___1);
    }
    {
#line 123
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s: %s: %s\n",
            program_name, buf, tmp___2);
    }
    {
#line 124
    add_to_log(buf);
    }
    }
  }
#line 126
  return;
}
}
#line 129 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3misc.c"
void user_message(int errflag , char *format  , ...) 
{ 
  char buf[1024] ;
  va_list msg ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 135
  __builtin_va_start(msg, format);
  }
  {
#line 136
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)format,
           msg);
  }
  {
#line 137
  __builtin_va_end(msg);
  }
  }
#line 139
  if (errflag) {
    {
    {
#line 140
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            buf);
    }
    }
  } else
#line 141
  if ((int )flags.quiet == 0) {
    {
    {
#line 142
    printf((char const   */* __restrict  */)"%s", buf);
    }
    }
  }
#line 144
  if ((int )flags.logging == 1) {
    {
    {
#line 145
    add_to_log(buf);
    }
    }
  }
#line 147
  return;
}
}
#line 157 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 138
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 321 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 517 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 25 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.h"
void show_genres(int pause_flag ) ;
#line 26
int search_genre(int flag_search_only , int *dest , char *search_gen ) ;
#line 31
int tag_file(char *fn ) ;
#line 45 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
ID3_tag *ptrtag ;
#line 50 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *def_artist  =    (char *)((void *)0);
#line 51 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *def_song  =    (char *)((void *)0);
#line 52 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *def_album  =    (char *)((void *)0);
#line 53 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *def_year  =    (char *)((void *)0);
#line 54 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *def_comment  =    (char *)((void *)0);
#line 55 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
int def_genre  =    -1;
#line 56 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char def_track  =    (char)-1;
#line 57 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *def_field  =    (char *)"unknown";
#line 59 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
ID3_tag copytag  ;
#line 60 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
FILE *copyfp  =    (FILE *)((void *)0);
#line 62 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
FLAGS_struct flags  = 
#line 62
     {(short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
    (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
    (short)0};
#line 81 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char filename_template[256]  = 
#line 81
  {      (char )'[',      (char )'%',      (char )'a',      (char )']', 
        (char )'-',      (char )'[',      (char )'%',      (char )'s', 
        (char )']',      (char )'.',      (char )'m',      (char )'p', 
        (char )'3',      (char )'\000'};
#line 87 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char tag_template[256]  = 
#line 87
  {      (char )'[',      (char )'%',      (char )'a',      (char )']', 
        (char )'-',      (char )'[',      (char )'%',      (char )'s', 
        (char )']',      (char )'.',      (char )'m',      (char )'p', 
        (char )'3',      (char )'\000'};
#line 90 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *program_name  =    (char *)((void *)0);
#line 91 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *program_path  =    (char *)((void *)0);
#line 94 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char replace_spacechar[32]  = {      (char )' ',      (char )'\000'};
#line 96 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *replace_char  =    (char *)"";
#line 97 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char *remove_char  =    (char *)"";
#line 100 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
char applied_filename[512]  ;
#line 103
void exit_function(void) ;
#line 104
void apply_template(char *origfile ) ;
#line 105
void show_usage(char *myname ) ;
#line 106
void check_num_args(int current , int total ) ;
#line 107
int read_config(char *path , char *filename ) ;
#line 108
void toggle_flag(short *flag ) ;
#line 109
int check_option(int *count , int argc , char *arg1 , char *arg2 , char *name , char **option ,
                 int nb ) ;
#line 110
void check_arg(int *count , int argc , char *arg1 , char *arg2 ) ;
#line 111
int check_args(int argc , char **argv ) ;
#line 112
int main(int argc , char **argv ) ;
#line 115 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
void exit_function(void) 
{ 


  {
#line 120
  return;
}
}
#line 123 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
void apply_template(char *origfile ) 
{ 
  char *ptrNewfile ;
  char tmpfile___0[512] ;
  char strack[10] ;
  int i ;
  int tcount ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 129
  tcount = 0;
#line 131
  applied_filename[0] = (char )'\000';
#line 132
  ptrNewfile = applied_filename;
  {
  {
#line 134
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int )filename_template[tcount] != 0)) {
#line 134
      goto while_break;
    }
#line 136
    if ((int )filename_template[tcount] == 37) {
#line 138
      tcount ++;
      {
#line 142
      if ((int )filename_template[tcount] == 97) {
#line 142
        goto case_97;
      }
#line 148
      if ((int )filename_template[tcount] == 99) {
#line 148
        goto case_99;
      }
#line 154
      if ((int )filename_template[tcount] == 103) {
#line 154
        goto case_103;
      }
#line 160
      if ((int )filename_template[tcount] == 115) {
#line 160
        goto case_115;
      }
#line 166
      if ((int )filename_template[tcount] == 116) {
#line 166
        goto case_116;
      }
#line 172
      if ((int )filename_template[tcount] == 121) {
#line 172
        goto case_121;
      }
#line 178
      if ((int )filename_template[tcount] == 110) {
#line 178
        goto case_110;
      }
#line 186
      goto switch_default;
      case_97: /* CIL Label */ 
      {
      {
#line 143
      tmp = strcmp((char const   *)(ptrtag->artist), "");
      }
      }
#line 143
      if (tmp != 0) {
        {
        {
#line 144
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(ptrtag->artist));
        }
        }
      } else
#line 145
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 146
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 147
      goto switch_break;
      case_99: /* CIL Label */ 
      {
      {
#line 149
      tmp___0 = strcmp((char const   *)(ptrtag->u.v10.comment), "");
      }
      }
#line 149
      if (tmp___0 != 0) {
        {
        {
#line 150
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(ptrtag->u.v10.comment));
        }
        }
      } else
#line 151
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 152
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 153
      goto switch_break;
      case_103: /* CIL Label */ 
#line 155
      if (ptrtag->genre < (int )genre_count) {
#line 155
        if (ptrtag->genre >= 0) {
          {
          {
#line 156
          strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)genre_table[ptrtag->genre]);
          }
          }
        } else {
#line 155
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 157
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 158
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 159
      goto switch_break;
      case_115: /* CIL Label */ 
      {
      {
#line 161
      tmp___1 = strcmp((char const   *)(ptrtag->songname), "");
      }
      }
#line 161
      if (tmp___1 != 0) {
        {
        {
#line 162
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(ptrtag->songname));
        }
        }
      } else
#line 163
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 164
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 165
      goto switch_break;
      case_116: /* CIL Label */ 
      {
      {
#line 167
      tmp___2 = strcmp((char const   *)(ptrtag->album), "");
      }
      }
#line 167
      if (tmp___2 != 0) {
        {
        {
#line 168
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(ptrtag->album));
        }
        }
      } else
#line 169
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 170
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 171
      goto switch_break;
      case_121: /* CIL Label */ 
      {
      {
#line 173
      tmp___3 = strcmp((char const   *)(ptrtag->year), "");
      }
      }
#line 173
      if (tmp___3 != 0) {
        {
        {
#line 174
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(ptrtag->year));
        }
        }
      } else
#line 175
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 176
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 177
      goto switch_break;
      case_110: /* CIL Label */ 
#line 179
      if ((int )ptrtag->version >= 1) {
        {
        {
#line 180
        sprintf((char */* __restrict  */)(strack), (char const   */* __restrict  */)"%02d",
                (int )ptrtag->u.v11.track);
        }
        {
#line 181
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(strack));
        }
        }
      } else
#line 183
      if ((unsigned long )def_field != (unsigned long )((void *)0)) {
        {
        {
#line 184
        strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)def_field);
        }
        }
      }
#line 185
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 187
      user_message(0, (char *)"Unknown identifier in template: %c%c\n", '%', (int )filename_template[tcount]);
      }
      }
#line 189
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 192
      tcount ++;
    } else {
      {
#line 196
      ptrNewfile = applied_filename;
      {
#line 197
      tmp___4 = strlen((char const   *)(applied_filename));
      }
#line 197
      ptrNewfile += tmp___4;
#line 198
      *ptrNewfile = filename_template[tcount];
#line 199
      ptrNewfile ++;
#line 200
      *ptrNewfile = (char )'\000';
#line 201
      tcount ++;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 205
  strcpy((char */* __restrict  */)(tmpfile___0), (char const   */* __restrict  */)(applied_filename));
  }
#line 206
  ptrNewfile = applied_filename;
#line 207
  tcount = 0;
  }
  {
  {
#line 209
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 209
    if (! ((int )tmpfile___0[tcount] != 0)) {
#line 209
      goto while_break___0;
    }
#line 211
    i = 0;
    {
    {
#line 211
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 211
      tmp___6 = strlen((char const   *)replace_char);
      }
      }
#line 211
      if (! ((size_t )i < tmp___6)) {
#line 211
        goto while_break___1;
      }
#line 213
      if ((int )*(replace_char + i) == (int )tmpfile___0[tcount]) {
        {
        {
#line 213
        tmp___5 = strlen((char const   *)replace_char);
        }
        }
#line 213
        if ((size_t )(i + 1) < tmp___5) {
#line 216
          *ptrNewfile = *(replace_char + (i + 1));
#line 217
          ptrNewfile ++;
#line 218
          i = 31335;
        }
      }
#line 211
      i += 2;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 222
    if (i != 31337) {
      {
      {
#line 222
      tmp___12 = strchr((char const   *)remove_char, (int )tmpfile___0[tcount]);
      }
      }
#line 222
      if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
        {
        {
#line 224
        tmp___11 = __ctype_b_loc();
        }
        }
#line 224
        if ((int const   )*(*tmp___11 + (int )tmpfile___0[tcount]) & 1024) {
#line 224
          if ((int )flags.ulcase == 1) {
            {
            {
#line 226
            tmp___7 = toupper((int )tmpfile___0[tcount]);
            }
#line 226
            *ptrNewfile = (char )tmp___7;
#line 227
            ptrNewfile ++;
            }
          } else {
#line 224
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
          {
#line 229
          tmp___10 = __ctype_b_loc();
          }
          }
#line 229
          if ((int const   )*(*tmp___10 + (int )tmpfile___0[tcount]) & 1024) {
#line 229
            if ((int )flags.ulcase == 2) {
              {
              {
#line 231
              tmp___8 = tolower((int )tmpfile___0[tcount]);
              }
#line 231
              *ptrNewfile = (char )tmp___8;
#line 232
              ptrNewfile ++;
              }
            } else {
#line 229
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 234
          if ((int )tmpfile___0[tcount] == 32) {
            {
#line 236
            *ptrNewfile = (char )'\000';
            {
#line 237
            strcat((char */* __restrict  */)(applied_filename), (char const   */* __restrict  */)(replace_spacechar));
            }
#line 238
            ptrNewfile = applied_filename;
            {
#line 239
            tmp___9 = strlen((char const   *)(applied_filename));
            }
#line 239
            ptrNewfile += tmp___9;
            }
          } else {
#line 243
            *ptrNewfile = tmpfile___0[tcount];
#line 244
            ptrNewfile ++;
          }
        }
      }
    }
#line 248
    tcount ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 251
  *ptrNewfile = (char )'\000';
#line 254
  i = 0;
  {
  {
#line 254
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 254
    tmp___13 = strlen((char const   *)(applied_filename));
    }
    }
#line 254
    if (! ((size_t )i < tmp___13)) {
#line 254
      goto while_break___2;
    }
    {
#line 258
    if ((int )applied_filename[i] == 60) {
#line 258
      goto case_60;
    }
#line 259
    if ((int )applied_filename[i] == 62) {
#line 259
      goto case_62;
    }
#line 260
    if ((int )applied_filename[i] == 124) {
#line 260
      goto case_124;
    }
#line 263
    if ((int )applied_filename[i] == 92) {
#line 263
      goto case_92;
    }
#line 264
    if ((int )applied_filename[i] == 42) {
#line 264
      goto case_42;
    }
#line 265
    if ((int )applied_filename[i] == 63) {
#line 265
      goto case_63;
    }
#line 266
    if ((int )applied_filename[i] == 58) {
#line 266
      goto case_58;
    }
#line 267
    if ((int )applied_filename[i] == 34) {
#line 267
      goto case_34;
    }
#line 268
    goto switch_default___0;
    case_60: /* CIL Label */ 
#line 258
    applied_filename[i] = (char )'[';
#line 258
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 259
    applied_filename[i] = (char )']';
#line 259
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 260
    applied_filename[i] = (char )'_';
#line 260
    goto switch_break___0;
    case_92: /* CIL Label */ 
#line 263
    applied_filename[i] = (char )'-';
#line 263
    goto switch_break___0;
    case_42: /* CIL Label */ 
#line 264
    applied_filename[i] = (char )'_';
#line 264
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 265
    applied_filename[i] = (char )'_';
#line 265
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 266
    applied_filename[i] = (char )';';
#line 266
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 267
    applied_filename[i] = (char )'-';
#line 267
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 268
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 254
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 272
  return;
}
}
#line 275 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
void show_usage(char *myname ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 278
  user_message(1, (char *)"GPL\'d id3 Renamer & Tagger version %s\n", "1.1b0 for *nix");
  }
  {
#line 279
  user_message(1, (char *)"(C) Copyright 1998 by Robert Alto (badcrc@tscnet.com)\n");
  }
  {
#line 280
  user_message(1, (char *)"(C) Copyright 2001 by Christophe Bothamy (cbothamy@free.fr)\n");
  }
  {
#line 281
  user_message(1, (char *)"Usage: %s [-help]\n", myname);
  }
  {
#line 282
  user_message(1, (char *)"       [-song=SONG_NAME] [-artist=ARTIST_NAME] [-album=ALBUM_NAME]\n");
  }
  {
#line 283
  user_message(1, (char *)"       [-year=YEAR] [-genre={# | GENRE}] [-comment=COMMENT] [-track=TRACK]\n");
  }
  {
#line 284
  user_message(1, (char *)"       [-showgen] [-searchgen={# | GENRE}] [-default=DEFAULT]\n");
  }
  {
#line 285
  user_message(1, (char *)"       [-copytagfrom=FILE [-copysong] [-copyartist] [-copyalbum]\n");
  }
  {
#line 286
  user_message(1, (char *)"       [-copyyear] [-copygenre] [-copycomment] [-copytrack] [-copyall] ]\n");
  }
  {
#line 287
  user_message(1, (char *)"       [-quick] [-noalbum] [-nocomment] [-noyear] [-nogenre] [-notrack]\n");
  }
  {
#line 288
  user_message(1, (char *)"       [-tag] [-edit] [-notagprompt | -showtag | -striptag | -tagonly]\n");
  }
  {
#line 289
  user_message(1, (char *)"       [-nocfg] [-log] [-quiet] [-verbose] [-defcase | -lower | -upper]\n");
  }
  {
#line 290
  user_message(1, (char *)"       [-remchar=CHARS] [-repchar=CHARS] [-space=STRING]\n");
  }
  {
#line 291
  user_message(1, (char *)"       [-tagfromfilename | -tagffn] [-tagtemplate=TAGTEMPLATE]\n");
  }
  {
#line 292
  user_message(1, (char *)"       [-template=TEMPLATE] [FILE1 FILE2.. | WILDCARDS]\n\n");
  }
  {
#line 293
  user_message(1, (char *)"When logging is enabled, most normal output is also sent to %s.\n",
               logfile);
  }
  {
#line 294
  user_message(1, (char *)"To disable all output except for the usage screen on errors, use -quiet.\n\n");
  }
  {
#line 295
  user_message(1, (char *)"The templates can contain the following identifiers from the id3 tag:\n");
  }
  {
#line 296
  user_message(1, (char *)" %ca - Artist       %cc - Comment  %cg - Genre  %cs - Song Name\n",
               '%', '%', '%', '%');
  }
  {
#line 297
  user_message(1, (char *)" %ct - Album title  %cy - Year     %cn - Track ##\n", '%',
               '%', '%');
  }
  {
#line 298
  user_message(1, (char *)"The tagtemplate can also contain the dummy identifier %cd.\n",
               '%');
  }
  }
#line 299
  return;
}
}
#line 302 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
void check_num_args(int current , int total ) 
{ 
  char *__cil_tmp3 ;

  {
#line 305
  if (current >= total) {
    {
    {
#line 307
    user_message(1, (char *)"%s: Not enough arguments\n", program_name);
    }
    {
#line 308
    exit(2);
    }
    }
  }
#line 310
  return;
}
}
#line 313 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
int read_config(char *path , char *filename ) 
{ 
  FILE *fp ;
  char buffer[1024] ;
  char *cfile ;
  char *p1 ;
  char *p2 ;
  int i ;
  char first[1024] ;
  char second[1024] ;
  char insingle ;
  char indouble ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 325
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 326
    return (0);
  } else {
    {
    {
#line 325
    tmp = strlen((char const   *)path);
    }
    }
#line 325
    if (tmp < 1U) {
#line 326
      return (0);
    }
  }
#line 328
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
    {
#line 330
    tmp___0 = strlen((char const   *)path);
    }
    {
#line 330
    alloc_string(& cfile, (unsigned long )(tmp___0 + 1U));
    }
    {
#line 331
    strcpy((char */* __restrict  */)cfile, (char const   */* __restrict  */)path);
    }
    }
  } else {
    {
    {
#line 328
    tmp___3 = strlen((char const   *)filename);
    }
    }
#line 328
    if (tmp___3 < 1U) {
      {
      {
#line 330
      tmp___0 = strlen((char const   *)path);
      }
      {
#line 330
      alloc_string(& cfile, (unsigned long )(tmp___0 + 1U));
      }
      {
#line 331
      strcpy((char */* __restrict  */)cfile, (char const   */* __restrict  */)path);
      }
      }
    } else {
      {
      {
#line 335
      tmp___1 = strlen((char const   *)path);
      }
      {
#line 335
      tmp___2 = strlen((char const   *)filename);
      }
      {
#line 335
      alloc_string(& cfile, (unsigned long )((tmp___1 + tmp___2) + 2U));
      }
      {
#line 336
      sprintf((char */* __restrict  */)cfile, (char const   */* __restrict  */)"%s%c%s",
              path, '/', filename);
      }
      }
    }
  }
#line 339
  if (flags.verbose) {
    {
    {
#line 340
    user_message(0, (char *)"%s: Checking for config file %s...", program_name, cfile);
    }
    }
  }
  {
  {
#line 342
  tmp___4 = access((char const   *)cfile, 0);
  }
  }
#line 342
  if (tmp___4 != 0) {
#line 344
    if (flags.verbose) {
      {
      {
#line 345
      user_message(0, (char *)"not found\n");
      }
      }
    }
    {
    {
#line 347
    free((void *)cfile);
    }
    }
#line 348
    return (0);
  } else
#line 349
  if (flags.verbose) {
    {
    {
#line 350
    user_message(0, (char *)"found\n");
    }
    }
  }
  {
  {
#line 352
  fp = fopen((char const   */* __restrict  */)cfile, (char const   */* __restrict  */)"rt");
  }
  }
#line 354
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 356
    print_error((char *)"Couldn\'t open config file %s", cfile);
    }
    {
#line 357
    free((void *)cfile);
    }
    }
#line 358
    return (0);
  }
#line 361
  if (flags.verbose) {
    {
    {
#line 362
    user_message(0, (char *)"%s: Reading config file %s\n", program_name, cfile);
    }
    }
  }
  {
  {
#line 364
  fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)fp);
  }
  }
  {
  {
#line 366
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 366
    tmp___9 = feof(fp);
    }
    }
#line 366
    if (tmp___9) {
#line 366
      goto while_break;
    }
    {
    {
#line 368
    tmp___6 = strlen((char const   *)(buffer));
    }
    }
#line 368
    if ((int )buffer[tmp___6 - 1U] == 10) {
      {
      {
#line 369
      tmp___5 = strlen((char const   *)(buffer));
      }
#line 369
      buffer[tmp___5 - 1U] = (char )'\000';
      }
    }
#line 371
    p1 = buffer;
    {
    {
#line 372
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! ((int )*p1 == 32)) {
#line 372
        goto while_break___0;
      }
#line 372
      p1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 374
    if ((int )*p1 != 0) {
#line 374
      if ((int )*p1 != 35) {
#line 376
        p2 = p1;
        {
        {
#line 378
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 378
          if ((int )*p2 != 61) {
#line 378
            if ((int )*p2 != 32) {
#line 378
              if (! ((int )*p2 != 0)) {
#line 378
                goto while_break___1;
              }
            } else {
#line 378
              goto while_break___1;
            }
          } else {
#line 378
            goto while_break___1;
          }
#line 378
          p2 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 380
        if ((int )*p2 == 32) {
#line 382
          *p2 = (char )'\000';
#line 383
          p2 ++;
        } else
#line 380
        if ((int )*p2 == 61) {
#line 382
          *p2 = (char )'\000';
#line 383
          p2 ++;
        }
        {
        {
#line 387
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 387
          if ((int )*p2 == 32) {
#line 387
            if (! ((int )*p2 != 0)) {
#line 387
              goto while_break___2;
            }
          } else {
#line 387
            goto while_break___2;
          }
#line 387
          p2 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        {
#line 390
        strcpy((char */* __restrict  */)(first), (char const   */* __restrict  */)p1);
        }
        {
#line 391
        strcpy((char */* __restrict  */)(second), (char const   */* __restrict  */)"");
        }
#line 392
        insingle = (char)0;
#line 392
        indouble = (char)0;
        }
        {
        {
#line 393
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 393
          if (! ((int )*p2 != 0)) {
#line 393
            goto while_break___3;
          }
#line 395
          if (insingle) {
#line 396
            if ((int )*p2 == 39) {
#line 396
              insingle = (char)0;
            } else {
              {
              {
#line 397
              strncat((char */* __restrict  */)(second), (char const   */* __restrict  */)p2,
                      (size_t )1);
              }
              }
            }
          } else
#line 399
          if (indouble) {
#line 400
            if ((int )*p2 == 34) {
#line 400
              indouble = (char)0;
            } else {
              {
              {
#line 401
              strncat((char */* __restrict  */)(second), (char const   */* __restrict  */)p2,
                      (size_t )1);
              }
              }
            }
          } else
#line 403
          if ((int )*p2 == 34) {
#line 403
            indouble = (char)1;
          } else
#line 404
          if ((int )*p2 == 39) {
#line 404
            insingle = (char)1;
          } else
#line 405
          if ((int )*p2 != 32) {
            {
            {
#line 405
            strncat((char */* __restrict  */)(second), (char const   */* __restrict  */)p2,
                    (size_t )1);
            }
            }
          } else {
#line 406
            goto while_break___3;
          }
#line 408
          p2 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 411
        i = 0;
#line 412
        if ((int )second[0] == 0) {
#line 412
          tmp___7 = "";
        } else {
#line 412
          tmp___7 = (char const   *)(second);
        }
#line 412
        if ((int )second[0] == 0) {
#line 412
          tmp___8 = 1;
        } else {
#line 412
          tmp___8 = 2;
        }
        {
        {
#line 412
        check_arg(& i, tmp___8, first, (char *)tmp___7);
        }
        }
      }
    }
    {
    {
#line 415
    fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)fp);
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 418
  fclose(fp);
  }
  {
#line 419
  free((void *)cfile);
  }
  }
#line 420
  return (1);
}
}
#line 423 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
void toggle_flag(short *flag ) 
{ 


  {
#line 426
  if ((int )*flag == 1) {
#line 428
    *flag = (short)0;
  } else {
#line 432
    *flag = (short)1;
  }
#line 434
  return;
}
}
#line 436 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
int check_option(int *count , int argc , char *arg1 , char *arg2 , char *name , char **option ,
                 int nb ) 
{ 
  char *stmp ;
  char found ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp16 ;

  {
#line 439
  found = (char)0;
#line 441
  *option = (char *)((void *)0);
#line 444
  if (nb == 0) {
    {
    {
#line 446
    tmp = strcmp((char const   *)name, (char const   *)arg1);
    }
    }
#line 446
    if (tmp == 0) {
#line 447
      found = (char)1;
    }
  } else {
    {
    {
#line 452
    tmp___4 = strcmp((char const   *)name, (char const   *)arg1);
    }
    }
#line 452
    if (tmp___4 == 0) {
      {
#line 454
      (*count) ++;
      {
#line 455
      check_num_args(*count, argc);
      }
#line 457
      *option = arg2;
#line 458
      found = (char)1;
      }
    } else {
      {
      {
#line 462
      tmp___0 = strlen((char const   *)name);
      }
      {
#line 462
      alloc_string(& stmp, (unsigned long )(tmp___0 + 2U));
      }
      {
#line 463
      sprintf((char */* __restrict  */)stmp, (char const   */* __restrict  */)"%s=",
              name);
      }
      {
#line 464
      tmp___2 = strlen((char const   *)stmp);
      }
      {
#line 464
      tmp___3 = strncmp((char const   *)stmp, (char const   *)arg1, tmp___2);
      }
      }
#line 464
      if (tmp___3 == 0) {
        {
        {
#line 466
        tmp___1 = strchr((char const   *)arg1, '=');
        }
#line 466
        *option = tmp___1 + 1;
#line 467
        found = (char)1;
        }
      }
      {
      {
#line 469
      free((void *)stmp);
      }
      }
    }
  }
#line 473
  if (found) {
#line 473
    return (1);
  } else {
#line 474
    return (0);
  }
}
}
#line 477 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
void check_arg(int *count , int argc , char *arg1 , char *arg2 ) 
{ 
  char *option ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;

  {
  {
  {
#line 483
  tmp___68 = check_option(count, argc, arg1, arg2, (char *)"-help", & option, 0);
  }
  }
#line 483
  if (tmp___68 != 0) {
    {
    {
#line 485
    show_usage(program_name);
    }
    {
#line 486
    exit(0);
    }
    }
  } else {
    {
    {
#line 488
    tmp___67 = check_option(count, argc, arg1, arg2, (char *)"-song", & option, 1);
    }
    }
#line 488
    if (tmp___67 != 0) {
      {
      {
#line 490
      tmp = strlen((char const   *)option);
      }
      {
#line 490
      alloc_string(& def_song, (unsigned long )(tmp + 1U));
      }
      {
#line 491
      strcpy((char */* __restrict  */)def_song, (char const   */* __restrict  */)option);
      }
      }
    } else {
      {
      {
#line 493
      tmp___66 = check_option(count, argc, arg1, arg2, (char *)"-artist", & option,
                              1);
      }
      }
#line 493
      if (tmp___66 != 0) {
        {
        {
#line 495
        tmp___0 = strlen((char const   *)option);
        }
        {
#line 495
        alloc_string(& def_artist, (unsigned long )(tmp___0 + 1U));
        }
        {
#line 496
        strcpy((char */* __restrict  */)def_artist, (char const   */* __restrict  */)option);
        }
        }
      } else {
        {
        {
#line 498
        tmp___65 = check_option(count, argc, arg1, arg2, (char *)"-album", & option,
                                1);
        }
        }
#line 498
        if (tmp___65 != 0) {
          {
          {
#line 500
          tmp___1 = strlen((char const   *)option);
          }
          {
#line 500
          alloc_string(& def_album, (unsigned long )(tmp___1 + 1U));
          }
          {
#line 501
          strcpy((char */* __restrict  */)def_album, (char const   */* __restrict  */)option);
          }
          }
        } else {
          {
          {
#line 503
          tmp___64 = check_option(count, argc, arg1, arg2, (char *)"-year", & option,
                                  1);
          }
          }
#line 503
          if (tmp___64 != 0) {
            {
            {
#line 505
            tmp___2 = strlen((char const   *)option);
            }
            {
#line 505
            alloc_string(& def_year, (unsigned long )(tmp___2 + 1U));
            }
            {
#line 506
            strcpy((char */* __restrict  */)def_year, (char const   */* __restrict  */)option);
            }
            }
          } else {
            {
            {
#line 508
            tmp___63 = check_option(count, argc, arg1, arg2, (char *)"-track", & option,
                                    1);
            }
            }
#line 508
            if (tmp___63 != 0) {
#line 511
              def_track = (char)0;
#line 512
              i = 0;
              {
              {
#line 512
              while (1) {
                while_continue___0: /* CIL Label */ ;
                while_continue: /* CIL Label */ ;
                {
                {
#line 512
                tmp___3 = strlen((char const   *)option);
                }
                }
#line 512
                if (! ((size_t )i < tmp___3)) {
#line 512
                  goto while_break;
                }
#line 513
                def_track = (char )(((int )def_track * 10 + (int )*(option + i)) - 48);
#line 512
                i ++;
              }
              while_break___0: /* CIL Label */ ;
              }
              while_break: /* CIL Label */ ;
              }
#line 514
              if ((int )def_track > 99) {
                {
                {
#line 516
                user_message(1, (char *)"%s: track %s is > 99\n", program_name, option);
                }
                {
#line 517
                exit(2);
                }
                }
              }
            } else {
              {
              {
#line 520
              tmp___62 = check_option(count, argc, arg1, arg2, (char *)"-comment",
                                      & option, 1);
              }
              }
#line 520
              if (tmp___62 != 0) {
                {
                {
#line 522
                tmp___4 = strlen((char const   *)option);
                }
                {
#line 522
                alloc_string(& def_comment, (unsigned long )(tmp___4 + 1U));
                }
                {
#line 523
                strcpy((char */* __restrict  */)def_comment, (char const   */* __restrict  */)option);
                }
                }
              } else {
                {
                {
#line 525
                tmp___61 = check_option(count, argc, arg1, arg2, (char *)"-genre",
                                        & option, 1);
                }
                }
#line 525
                if (tmp___61 != 0) {
                  {
                  {
#line 527
                  tmp___5 = search_genre(1, & def_genre, option);
                  }
                  }
#line 527
                  if (tmp___5 == 0) {
                    {
                    {
#line 529
                    user_message(1, (char *)"%s: No genre selected\n", program_name);
                    }
                    {
#line 530
                    exit(2);
                    }
                    }
                  }
                } else {
                  {
                  {
#line 533
                  tmp___60 = check_option(count, argc, arg1, arg2, (char *)"-default",
                                          & option, 1);
                  }
                  }
#line 533
                  if (tmp___60 != 0) {
                    {
                    {
#line 535
                    tmp___6 = strlen((char const   *)option);
                    }
                    {
#line 535
                    alloc_string(& def_field, (unsigned long )(tmp___6 + 1U));
                    }
                    {
#line 536
                    strcpy((char */* __restrict  */)def_field, (char const   */* __restrict  */)option);
                    }
                    }
                  } else {
                    {
                    {
#line 538
                    tmp___59 = check_option(count, argc, arg1, arg2, (char *)"-log",
                                            & option, 0);
                    }
                    }
#line 538
                    if (tmp___59 != 0) {
                      {
                      {
#line 539
                      toggle_flag(& flags.logging);
                      }
                      }
                    } else {
                      {
                      {
#line 540
                      tmp___58 = check_option(count, argc, arg1, arg2, (char *)"-notagprompt",
                                              & option, 0);
                      }
                      }
#line 540
                      if (tmp___58 != 0) {
                        {
                        {
#line 541
                        toggle_flag(& flags.no_tag_prompt);
                        }
                        }
                      } else {
                        {
                        {
#line 542
                        tmp___57 = check_option(count, argc, arg1, arg2, (char *)"-noalbum",
                                                & option, 0);
                        }
                        }
#line 542
                        if (tmp___57 != 0) {
                          {
                          {
#line 543
                          toggle_flag(& flags.no_album);
                          }
                          }
                        } else {
                          {
                          {
#line 544
                          tmp___56 = check_option(count, argc, arg1, arg2, (char *)"-nocomment",
                                                  & option, 0);
                          }
                          }
#line 544
                          if (tmp___56 != 0) {
                            {
                            {
#line 545
                            toggle_flag(& flags.no_comment);
                            }
                            }
                          } else {
                            {
                            {
#line 546
                            tmp___55 = check_option(count, argc, arg1, arg2, (char *)"-noyear",
                                                    & option, 0);
                            }
                            }
#line 546
                            if (tmp___55 != 0) {
                              {
                              {
#line 547
                              toggle_flag(& flags.no_year);
                              }
                              }
                            } else {
                              {
                              {
#line 548
                              tmp___54 = check_option(count, argc, arg1, arg2, (char *)"-notrack",
                                                      & option, 0);
                              }
                              }
#line 548
                              if (tmp___54 != 0) {
                                {
                                {
#line 549
                                toggle_flag(& flags.no_track);
                                }
                                }
                              } else {
                                {
                                {
#line 550
                                tmp___53 = check_option(count, argc, arg1, arg2, (char *)"-nogenre",
                                                        & option, 0);
                                }
                                }
#line 550
                                if (tmp___53 != 0) {
                                  {
                                  {
#line 551
                                  toggle_flag(& flags.no_genre);
                                  }
                                  }
                                } else {
                                  {
                                  {
#line 552
                                  tmp___52 = check_option(count, argc, arg1, arg2,
                                                          (char *)"-nocfg", & option,
                                                          0);
                                  }
                                  }
#line 552
                                  if (tmp___52 != 0) {
                                    {
                                    {
#line 553
                                    toggle_flag(& flags.no_config);
                                    }
                                    }
                                  } else {
                                    {
                                    {
#line 554
                                    tmp___51 = check_option(count, argc, arg1, arg2,
                                                            (char *)"-quick", & option,
                                                            0);
                                    }
                                    }
#line 554
                                    if (tmp___51 != 0) {
#line 556
                                      flags.no_album = (short)1;
#line 557
                                      flags.no_comment = (short)1;
#line 558
                                      flags.no_year = (short)1;
                                    } else {
                                      {
                                      {
#line 560
                                      tmp___50 = check_option(count, argc, arg1, arg2,
                                                              (char *)"-quiet", & option,
                                                              0);
                                      }
                                      }
#line 560
                                      if (tmp___50 != 0) {
                                        {
                                        {
#line 561
                                        toggle_flag(& flags.quiet);
                                        }
                                        }
                                      } else {
                                        {
                                        {
#line 562
                                        tmp___49 = check_option(count, argc, arg1,
                                                                arg2, (char *)"-verbose",
                                                                & option, 0);
                                        }
                                        }
#line 562
                                        if (tmp___49 != 0) {
                                          {
                                          {
#line 563
                                          toggle_flag(& flags.verbose);
                                          }
                                          }
                                        } else {
                                          {
                                          {
#line 564
                                          tmp___48 = check_option(count, argc, arg1,
                                                                  arg2, (char *)"-searchgen",
                                                                  & option, 1);
                                          }
                                          }
#line 564
                                          if (tmp___48 != 0) {
                                            {
                                            {
#line 566
                                            search_genre(2, & def_genre, option);
                                            }
                                            {
#line 567
                                            exit(0);
                                            }
                                            }
                                          } else {
                                            {
                                            {
#line 569
                                            tmp___47 = check_option(count, argc, arg1,
                                                                    arg2, (char *)"-showgen",
                                                                    & option, 0);
                                            }
                                            }
#line 569
                                            if (tmp___47 != 0) {
                                              {
                                              {
#line 571
                                              show_genres(0);
                                              }
                                              {
#line 572
                                              exit(0);
                                              }
                                              }
                                            } else {
                                              {
                                              {
#line 574
                                              tmp___46 = check_option(count, argc,
                                                                      arg1, arg2,
                                                                      (char *)"-showtag",
                                                                      & option, 0);
                                              }
                                              }
#line 574
                                              if (tmp___46 != 0) {
#line 576
                                                flags.show_tag = (short)1;
#line 577
                                                flags.no_tag_prompt = (short)1;
                                              } else {
                                                {
                                                {
#line 579
                                                tmp___45 = check_option(count, argc,
                                                                        arg1, arg2,
                                                                        (char *)"-striptag",
                                                                        & option,
                                                                        0);
                                                }
                                                }
#line 579
                                                if (tmp___45 != 0) {
                                                  {
                                                  {
#line 580
                                                  toggle_flag(& flags.strip_tag);
                                                  }
                                                  }
                                                } else {
                                                  {
                                                  {
#line 581
                                                  tmp___44 = check_option(count, argc,
                                                                          arg1, arg2,
                                                                          (char *)"-tag",
                                                                          & option,
                                                                          0);
                                                  }
                                                  }
#line 581
                                                  if (tmp___44 != 0) {
                                                    {
                                                    {
#line 582
                                                    toggle_flag(& flags.force_tag);
                                                    }
                                                    }
                                                  } else {
                                                    {
                                                    {
#line 583
                                                    tmp___43 = check_option(count,
                                                                            argc,
                                                                            arg1,
                                                                            arg2,
                                                                            (char *)"-tagonly",
                                                                            & option,
                                                                            0);
                                                    }
                                                    }
#line 583
                                                    if (tmp___43 != 0) {
                                                      {
                                                      {
#line 584
                                                      toggle_flag(& flags.tag_only);
                                                      }
                                                      }
                                                    } else {
                                                      {
                                                      {
#line 585
                                                      tmp___42 = check_option(count,
                                                                              argc,
                                                                              arg1,
                                                                              arg2,
                                                                              (char *)"-tagfromfilename",
                                                                              & option,
                                                                              0);
                                                      }
                                                      }
#line 585
                                                      if (tmp___42 != 0) {
                                                        {
                                                        {
#line 586
                                                        toggle_flag(& flags.tag_ffn);
                                                        }
                                                        }
                                                      } else {
                                                        {
                                                        {
#line 587
                                                        tmp___41 = check_option(count,
                                                                                argc,
                                                                                arg1,
                                                                                arg2,
                                                                                (char *)"-tagffn",
                                                                                & option,
                                                                                0);
                                                        }
                                                        }
#line 587
                                                        if (tmp___41 != 0) {
                                                          {
                                                          {
#line 588
                                                          toggle_flag(& flags.tag_ffn);
                                                          }
                                                          }
                                                        } else {
                                                          {
                                                          {
#line 589
                                                          tmp___40 = check_option(count,
                                                                                  argc,
                                                                                  arg1,
                                                                                  arg2,
                                                                                  (char *)"-edit",
                                                                                  & option,
                                                                                  0);
                                                          }
                                                          }
#line 589
                                                          if (tmp___40 != 0) {
                                                            {
                                                            {
#line 590
                                                            toggle_flag(& flags.edit_tag);
                                                            }
                                                            }
                                                          } else {
                                                            {
                                                            {
#line 591
                                                            tmp___39 = check_option(count,
                                                                                    argc,
                                                                                    arg1,
                                                                                    arg2,
                                                                                    (char *)"-defcase",
                                                                                    & option,
                                                                                    0);
                                                            }
                                                            }
#line 591
                                                            if (tmp___39 != 0) {
#line 592
                                                              flags.ulcase = (short)0;
                                                            } else {
                                                              {
                                                              {
#line 593
                                                              tmp___38 = check_option(count,
                                                                                      argc,
                                                                                      arg1,
                                                                                      arg2,
                                                                                      (char *)"-upper",
                                                                                      & option,
                                                                                      0);
                                                              }
                                                              }
#line 593
                                                              if (tmp___38 != 0) {
#line 594
                                                                flags.ulcase = (short)1;
                                                              } else {
                                                                {
                                                                {
#line 595
                                                                tmp___37 = check_option(count,
                                                                                        argc,
                                                                                        arg1,
                                                                                        arg2,
                                                                                        (char *)"-lower",
                                                                                        & option,
                                                                                        0);
                                                                }
                                                                }
#line 595
                                                                if (tmp___37 != 0) {
#line 596
                                                                  flags.ulcase = (short)2;
                                                                } else {
                                                                  {
                                                                  {
#line 597
                                                                  tmp___36 = check_option(count,
                                                                                          argc,
                                                                                          arg1,
                                                                                          arg2,
                                                                                          (char *)"-space",
                                                                                          & option,
                                                                                          1);
                                                                  }
                                                                  }
#line 597
                                                                  if (tmp___36 != 0) {
#line 599
                                                                    if ((unsigned long )option == (unsigned long )((void *)0)) {
                                                                      {
                                                                      {
#line 600
                                                                      strcpy((char */* __restrict  */)(replace_spacechar),
                                                                             (char const   */* __restrict  */)"");
                                                                      }
                                                                      }
                                                                    } else {
                                                                      {
                                                                      {
#line 602
                                                                      strncpy((char */* __restrict  */)(replace_spacechar),
                                                                              (char const   */* __restrict  */)option,
                                                                              (size_t )(sizeof(replace_spacechar) - 1UL));
                                                                      }
                                                                      }
                                                                    }
                                                                  } else {
                                                                    {
                                                                    {
#line 604
                                                                    tmp___35 = check_option(count,
                                                                                            argc,
                                                                                            arg1,
                                                                                            arg2,
                                                                                            (char *)"-remchar",
                                                                                            & option,
                                                                                            1);
                                                                    }
                                                                    }
#line 604
                                                                    if (tmp___35 != 0) {
                                                                      {
                                                                      {
#line 606
                                                                      tmp___7 = strlen((char const   *)option);
                                                                      }
                                                                      {
#line 606
                                                                      alloc_string(& remove_char,
                                                                                   (unsigned long )(tmp___7 + 1U));
                                                                      }
                                                                      {
#line 607
                                                                      strcpy((char */* __restrict  */)remove_char,
                                                                             (char const   */* __restrict  */)option);
                                                                      }
                                                                      }
                                                                    } else {
                                                                      {
                                                                      {
#line 609
                                                                      tmp___34 = check_option(count,
                                                                                              argc,
                                                                                              arg1,
                                                                                              arg2,
                                                                                              (char *)"-repchar",
                                                                                              & option,
                                                                                              1);
                                                                      }
                                                                      }
#line 609
                                                                      if (tmp___34 != 0) {
                                                                        {
                                                                        {
#line 611
                                                                        tmp___8 = strlen((char const   *)option);
                                                                        }
                                                                        }
#line 611
                                                                        if (tmp___8 % 2U != 0U) {
                                                                          {
                                                                          {
#line 613
                                                                          user_message(1,
                                                                                       (char *)"%s: Replace characters must be in pairs\n",
                                                                                       program_name);
                                                                          }
                                                                          {
#line 614
                                                                          exit(2);
                                                                          }
                                                                          }
                                                                        }
                                                                        {
                                                                        {
#line 617
                                                                        tmp___9 = strlen((char const   *)option);
                                                                        }
                                                                        {
#line 617
                                                                        alloc_string(& replace_char,
                                                                                     (unsigned long )(tmp___9 + 1U));
                                                                        }
                                                                        {
#line 618
                                                                        strcpy((char */* __restrict  */)replace_char,
                                                                               (char const   */* __restrict  */)option);
                                                                        }
                                                                        }
                                                                      } else {
                                                                        {
                                                                        {
#line 620
                                                                        tmp___33 = check_option(count,
                                                                                                argc,
                                                                                                arg1,
                                                                                                arg2,
                                                                                                (char *)"-template",
                                                                                                & option,
                                                                                                1);
                                                                        }
                                                                        }
#line 620
                                                                        if (tmp___33 != 0) {
#line 622
                                                                          if ((unsigned long )option == (unsigned long )((void *)0)) {
                                                                            {
                                                                            {
#line 624
                                                                            user_message(1,
                                                                                         (char *)"%s: Empty template specified (%s)\n",
                                                                                         program_name,
                                                                                         arg1);
                                                                            }
                                                                            {
#line 625
                                                                            exit(2);
                                                                            }
                                                                            }
                                                                          } else {
                                                                            {
                                                                            {
#line 628
                                                                            strncpy((char */* __restrict  */)(filename_template),
                                                                                    (char const   */* __restrict  */)option,
                                                                                    (size_t )(sizeof(filename_template) - 1UL));
                                                                            }
                                                                            }
                                                                          }
                                                                        } else {
                                                                          {
                                                                          {
#line 630
                                                                          tmp___32 = check_option(count,
                                                                                                  argc,
                                                                                                  arg1,
                                                                                                  arg2,
                                                                                                  (char *)"-tagtemplate",
                                                                                                  & option,
                                                                                                  1);
                                                                          }
                                                                          }
#line 630
                                                                          if (tmp___32 != 0) {
#line 632
                                                                            if ((unsigned long )option == (unsigned long )((void *)0)) {
                                                                              {
                                                                              {
#line 634
                                                                              user_message(1,
                                                                                           (char *)"%s: Empty tagtemplate specified (%s)\n",
                                                                                           program_name,
                                                                                           arg1);
                                                                              }
                                                                              {
#line 635
                                                                              exit(2);
                                                                              }
                                                                              }
                                                                            } else {
                                                                              {
                                                                              {
#line 638
                                                                              strncpy((char */* __restrict  */)(tag_template),
                                                                                      (char const   */* __restrict  */)option,
                                                                                      (size_t )(sizeof(tag_template) - 1UL));
                                                                              }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            {
                                                                            {
#line 640
                                                                            tmp___31 = check_option(count,
                                                                                                    argc,
                                                                                                    arg1,
                                                                                                    arg2,
                                                                                                    (char *)"-copytagfrom",
                                                                                                    & option,
                                                                                                    1);
                                                                            }
                                                                            }
#line 640
                                                                            if (tmp___31 != 0) {
#line 642
                                                                              if ((unsigned long )option == (unsigned long )((void *)0)) {
                                                                                {
                                                                                {
#line 644
                                                                                user_message(1,
                                                                                             (char *)"%s: Empty file name to copy from specified (%s)\n",
                                                                                             program_name,
                                                                                             arg1);
                                                                                }
                                                                                {
#line 645
                                                                                exit(2);
                                                                                }
                                                                                }
                                                                              } else {
                                                                                {
                                                                                {
#line 649
                                                                                tmp___10 = id3_open_file(& copyfp,
                                                                                                         option,
                                                                                                         (char *)"rb");
                                                                                }
                                                                                }
#line 649
                                                                                if (tmp___10 == 0) {
                                                                                  {
                                                                                  {
#line 651
                                                                                  user_message(1,
                                                                                               (char *)"%s: Can not copy from file (%s)\n",
                                                                                               program_name,
                                                                                               arg1);
                                                                                  }
                                                                                  {
#line 652
                                                                                  exit(2);
                                                                                  }
                                                                                  }
                                                                                }
                                                                                {
                                                                                {
#line 655
                                                                                memset((void *)(& copytag),
                                                                                       0,
                                                                                       (size_t )sizeof(ID3_tag ));
                                                                                }
                                                                                {
#line 656
                                                                                tmp___11 = id3_seek_header(copyfp,
                                                                                                           option);
                                                                                }
                                                                                }
#line 656
                                                                                if (tmp___11 != 0) {
                                                                                  {
                                                                                  {
#line 657
                                                                                  id3_read_file(copytag.tag,
                                                                                                sizeof(copytag.tag) - 1UL,
                                                                                                copyfp,
                                                                                                option);
                                                                                  }
                                                                                  }
                                                                                }
                                                                                {
                                                                                {
#line 658
                                                                                tmp___12 = strcmp((char const   *)(copytag.tag),
                                                                                                  "TAG");
                                                                                }
                                                                                }
#line 658
                                                                                if (tmp___12 != 0) {
                                                                                  {
                                                                                  {
#line 660
                                                                                  user_message(1,
                                                                                               (char *)"%s: Can not find any tag in file (%s)\n",
                                                                                               program_name,
                                                                                               arg1);
                                                                                  }
                                                                                  {
#line 661
                                                                                  id3_close_file(copyfp);
                                                                                  }
                                                                                  {
#line 662
                                                                                  exit(2);
                                                                                  }
                                                                                  }
                                                                                }
                                                                                {
                                                                                {
#line 664
                                                                                id3_read_tag(& copytag,
                                                                                             copyfp,
                                                                                             option);
                                                                                }
                                                                                {
#line 665
                                                                                id3_close_file(copyfp);
                                                                                }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              {
                                                                              {
#line 668
                                                                              tmp___30 = check_option(count,
                                                                                                      argc,
                                                                                                      arg1,
                                                                                                      arg2,
                                                                                                      (char *)"-copysong",
                                                                                                      & option,
                                                                                                      0);
                                                                              }
                                                                              }
#line 668
                                                                              if (tmp___30 != 0) {
#line 670
                                                                                if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                  {
                                                                                  {
#line 671
                                                                                  user_message(1,
                                                                                               (char *)"%s: No copytagfrom file specified\n",
                                                                                               program_name);
                                                                                  }
                                                                                  {
#line 672
                                                                                  exit(2);
                                                                                  }
                                                                                  }
                                                                                }
                                                                                {
                                                                                {
#line 675
                                                                                tmp___13 = strlen((char const   *)(copytag.songname));
                                                                                }
                                                                                {
#line 675
                                                                                alloc_string(& def_song,
                                                                                             (unsigned long )(tmp___13 + 1U));
                                                                                }
                                                                                {
#line 676
                                                                                strcpy((char */* __restrict  */)def_song,
                                                                                       (char const   */* __restrict  */)(copytag.songname));
                                                                                }
                                                                                }
                                                                              } else {
                                                                                {
                                                                                {
#line 678
                                                                                tmp___29 = check_option(count,
                                                                                                        argc,
                                                                                                        arg1,
                                                                                                        arg2,
                                                                                                        (char *)"-copyartist",
                                                                                                        & option,
                                                                                                        0);
                                                                                }
                                                                                }
#line 678
                                                                                if (tmp___29 != 0) {
#line 680
                                                                                  if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                    {
                                                                                    {
#line 681
                                                                                    user_message(1,
                                                                                                 (char *)"%s: No copytagfrom file specified\n",
                                                                                                 program_name);
                                                                                    }
                                                                                    {
#line 682
                                                                                    exit(2);
                                                                                    }
                                                                                    }
                                                                                  }
                                                                                  {
                                                                                  {
#line 685
                                                                                  tmp___14 = strlen((char const   *)(copytag.artist));
                                                                                  }
                                                                                  {
#line 685
                                                                                  alloc_string(& def_artist,
                                                                                               (unsigned long )(tmp___14 + 1U));
                                                                                  }
                                                                                  {
#line 686
                                                                                  strcpy((char */* __restrict  */)def_artist,
                                                                                         (char const   */* __restrict  */)(copytag.artist));
                                                                                  }
                                                                                  }
                                                                                } else {
                                                                                  {
                                                                                  {
#line 688
                                                                                  tmp___28 = check_option(count,
                                                                                                          argc,
                                                                                                          arg1,
                                                                                                          arg2,
                                                                                                          (char *)"-copyalbum",
                                                                                                          & option,
                                                                                                          0);
                                                                                  }
                                                                                  }
#line 688
                                                                                  if (tmp___28 != 0) {
#line 690
                                                                                    if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                      {
                                                                                      {
#line 691
                                                                                      user_message(1,
                                                                                                   (char *)"%s: No copytagfrom file specified\n",
                                                                                                   program_name);
                                                                                      }
                                                                                      {
#line 692
                                                                                      exit(2);
                                                                                      }
                                                                                      }
                                                                                    }
                                                                                    {
                                                                                    {
#line 695
                                                                                    tmp___15 = strlen((char const   *)(copytag.album));
                                                                                    }
                                                                                    {
#line 695
                                                                                    alloc_string(& def_album,
                                                                                                 (unsigned long )(tmp___15 + 1U));
                                                                                    }
                                                                                    {
#line 696
                                                                                    strcpy((char */* __restrict  */)def_album,
                                                                                           (char const   */* __restrict  */)(copytag.album));
                                                                                    }
                                                                                    }
                                                                                  } else {
                                                                                    {
                                                                                    {
#line 698
                                                                                    tmp___27 = check_option(count,
                                                                                                            argc,
                                                                                                            arg1,
                                                                                                            arg2,
                                                                                                            (char *)"-copyyear",
                                                                                                            & option,
                                                                                                            0);
                                                                                    }
                                                                                    }
#line 698
                                                                                    if (tmp___27 != 0) {
#line 700
                                                                                      if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                        {
                                                                                        {
#line 701
                                                                                        user_message(1,
                                                                                                     (char *)"%s: No copytagfrom file specified\n",
                                                                                                     program_name);
                                                                                        }
                                                                                        {
#line 702
                                                                                        exit(2);
                                                                                        }
                                                                                        }
                                                                                      }
                                                                                      {
                                                                                      {
#line 705
                                                                                      tmp___16 = strlen((char const   *)(copytag.year));
                                                                                      }
                                                                                      {
#line 705
                                                                                      alloc_string(& def_year,
                                                                                                   (unsigned long )(tmp___16 + 1U));
                                                                                      }
                                                                                      {
#line 706
                                                                                      strcpy((char */* __restrict  */)def_year,
                                                                                             (char const   */* __restrict  */)(copytag.year));
                                                                                      }
                                                                                      }
                                                                                    } else {
                                                                                      {
                                                                                      {
#line 708
                                                                                      tmp___26 = check_option(count,
                                                                                                              argc,
                                                                                                              arg1,
                                                                                                              arg2,
                                                                                                              (char *)"-copytrack",
                                                                                                              & option,
                                                                                                              0);
                                                                                      }
                                                                                      }
#line 708
                                                                                      if (tmp___26 != 0) {
#line 710
                                                                                        if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                          {
                                                                                          {
#line 711
                                                                                          user_message(1,
                                                                                                       (char *)"%s: No copytagfrom file specified\n",
                                                                                                       program_name);
                                                                                          }
                                                                                          {
#line 712
                                                                                          exit(2);
                                                                                          }
                                                                                          }
                                                                                        }
#line 714
                                                                                        if ((int )copytag.version == 0) {
                                                                                          {
                                                                                          {
#line 715
                                                                                          user_message(1,
                                                                                                       (char *)"%s: Copied tag is not id3v1.1\n",
                                                                                                       program_name);
                                                                                          }
                                                                                          {
#line 716
                                                                                          exit(2);
                                                                                          }
                                                                                          }
                                                                                        }
#line 719
                                                                                        def_track = copytag.u.v11.track;
                                                                                      } else {
                                                                                        {
                                                                                        {
#line 721
                                                                                        tmp___25 = check_option(count,
                                                                                                                argc,
                                                                                                                arg1,
                                                                                                                arg2,
                                                                                                                (char *)"-copycomment",
                                                                                                                & option,
                                                                                                                0);
                                                                                        }
                                                                                        }
#line 721
                                                                                        if (tmp___25 != 0) {
#line 723
                                                                                          if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                            {
                                                                                            {
#line 724
                                                                                            user_message(1,
                                                                                                         (char *)"%s: No copytagfrom file specified\n",
                                                                                                         program_name);
                                                                                            }
                                                                                            {
#line 725
                                                                                            exit(2);
                                                                                            }
                                                                                            }
                                                                                          }
                                                                                          {
                                                                                          {
#line 728
                                                                                          tmp___17 = strlen((char const   *)(copytag.u.v10.comment));
                                                                                          }
                                                                                          {
#line 728
                                                                                          alloc_string(& def_comment,
                                                                                                       (unsigned long )(tmp___17 + 1U));
                                                                                          }
                                                                                          {
#line 729
                                                                                          strcpy((char */* __restrict  */)def_comment,
                                                                                                 (char const   */* __restrict  */)(copytag.u.v10.comment));
                                                                                          }
                                                                                          }
                                                                                        } else {
                                                                                          {
                                                                                          {
#line 731
                                                                                          tmp___24 = check_option(count,
                                                                                                                  argc,
                                                                                                                  arg1,
                                                                                                                  arg2,
                                                                                                                  (char *)"-copygenre",
                                                                                                                  & option,
                                                                                                                  0);
                                                                                          }
                                                                                          }
#line 731
                                                                                          if (tmp___24 != 0) {
#line 733
                                                                                            if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                              {
                                                                                              {
#line 734
                                                                                              user_message(1,
                                                                                                           (char *)"%s: No copytagfrom file specified\n",
                                                                                                           program_name);
                                                                                              }
                                                                                              {
#line 735
                                                                                              exit(2);
                                                                                              }
                                                                                              }
                                                                                            }
#line 738
                                                                                            def_genre = copytag.genre;
                                                                                          } else {
                                                                                            {
                                                                                            {
#line 740
                                                                                            tmp___23 = check_option(count,
                                                                                                                    argc,
                                                                                                                    arg1,
                                                                                                                    arg2,
                                                                                                                    (char *)"-copyall",
                                                                                                                    & option,
                                                                                                                    0);
                                                                                            }
                                                                                            }
#line 740
                                                                                            if (tmp___23 != 0) {
#line 742
                                                                                              if ((unsigned long )copyfp == (unsigned long )((void *)0)) {
                                                                                                {
                                                                                                {
#line 743
                                                                                                user_message(1,
                                                                                                             (char *)"%s: No copytagfrom file specified\n",
                                                                                                             program_name);
                                                                                                }
                                                                                                {
#line 744
                                                                                                exit(2);
                                                                                                }
                                                                                                }
                                                                                              }
                                                                                              {
                                                                                              {
#line 747
                                                                                              tmp___18 = strlen((char const   *)(copytag.songname));
                                                                                              }
                                                                                              {
#line 747
                                                                                              alloc_string(& def_song,
                                                                                                           (unsigned long )(tmp___18 + 1U));
                                                                                              }
                                                                                              {
#line 748
                                                                                              strcpy((char */* __restrict  */)def_song,
                                                                                                     (char const   */* __restrict  */)(copytag.songname));
                                                                                              }
                                                                                              {
#line 749
                                                                                              tmp___19 = strlen((char const   *)(copytag.artist));
                                                                                              }
                                                                                              {
#line 749
                                                                                              alloc_string(& def_artist,
                                                                                                           (unsigned long )(tmp___19 + 1U));
                                                                                              }
                                                                                              {
#line 750
                                                                                              strcpy((char */* __restrict  */)def_artist,
                                                                                                     (char const   */* __restrict  */)(copytag.artist));
                                                                                              }
                                                                                              {
#line 751
                                                                                              tmp___20 = strlen((char const   *)(copytag.album));
                                                                                              }
                                                                                              {
#line 751
                                                                                              alloc_string(& def_album,
                                                                                                           (unsigned long )(tmp___20 + 1U));
                                                                                              }
                                                                                              {
#line 752
                                                                                              strcpy((char */* __restrict  */)def_album,
                                                                                                     (char const   */* __restrict  */)(copytag.album));
                                                                                              }
                                                                                              {
#line 753
                                                                                              tmp___21 = strlen((char const   *)(copytag.year));
                                                                                              }
                                                                                              {
#line 753
                                                                                              alloc_string(& def_year,
                                                                                                           (unsigned long )(tmp___21 + 1U));
                                                                                              }
                                                                                              {
#line 754
                                                                                              strcpy((char */* __restrict  */)def_year,
                                                                                                     (char const   */* __restrict  */)(copytag.year));
                                                                                              }
                                                                                              }
#line 755
                                                                                              if ((int )copytag.version > 0) {
#line 755
                                                                                                def_track = copytag.u.v11.track;
                                                                                              }
                                                                                              {
                                                                                              {
#line 756
                                                                                              tmp___22 = strlen((char const   *)(copytag.u.v10.comment));
                                                                                              }
                                                                                              {
#line 756
                                                                                              alloc_string(& def_comment,
                                                                                                           (unsigned long )(tmp___22 + 1U));
                                                                                              }
                                                                                              {
#line 757
                                                                                              strcpy((char */* __restrict  */)def_comment,
                                                                                                     (char const   */* __restrict  */)(copytag.u.v10.comment));
                                                                                              }
#line 758
                                                                                              def_genre = copytag.genre;
                                                                                              }
                                                                                            } else {
                                                                                              {
                                                                                              {
#line 762
                                                                                              user_message(1,
                                                                                                           (char *)"%s: Unknown option: %s\n",
                                                                                                           program_name,
                                                                                                           arg1);
                                                                                              }
                                                                                              {
#line 763
                                                                                              exit(2);
                                                                                              }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 765
  return;
}
}
#line 768 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
int check_args(int argc , char **argv ) 
{ 
  int i ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 773
  i = 1;
  {
  {
#line 773
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 773
    if (i < argc) {
#line 773
      if (! ((int )*(*(argv + i) + 0) == 45)) {
#line 773
        goto while_break;
      }
    } else {
#line 773
      goto while_break;
    }
#line 775
    if (i + 1 < argc) {
#line 775
      tmp = (char const   *)*(argv + (i + 1));
    } else {
#line 775
      tmp = "";
    }
    {
    {
#line 775
    check_arg(& i, argc, *(argv + i), (char *)tmp);
    }
#line 773
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  if ((int )flags.no_config == 0) {
    {
    {
#line 780
    tmp___2 = getenv("ID3REN");
    }
    {
#line 780
    tmp___3 = read_config(tmp___2, (char *)"");
    }
    }
#line 780
    if (! tmp___3) {
      {
      {
#line 781
      tmp___0 = getenv("HOME");
      }
      {
#line 781
      tmp___1 = read_config(tmp___0, (char *)".id3renrc");
      }
      }
#line 781
      if (! tmp___1) {
        {
        {
#line 785
        read_config((char *)"/etc", (char *)"id3renrc");
        }
        }
      }
    }
  }
#line 789
  return (i);
}
}
#line 793 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3ren.c"
int main(int argc , char **argv ) 
{ 
  char arg[256] ;
  char *p ;
  int i ;
  int count ;
  int errcount ;
  char tempname[512] ;
  char *d ;
  char *s ;
  int okflag ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 799
  count = 0;
#line 800
  errcount = 0;
  {
#line 808
  atexit(& exit_function);
  }
  {
#line 809
  p = strrchr((char const   *)*(argv + 0), '/');
  }
  }
#line 811
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 813
    p = *(argv + 0);
    {
#line 814
    alloc_string(& program_path, 2UL);
    }
    {
#line 815
    strcpy((char */* __restrict  */)program_path, (char const   */* __restrict  */)".");
    }
    }
  } else {
    {
#line 819
    p ++;
    {
#line 820
    tmp = strlen((char const   *)*(argv + 0));
    }
    {
#line 820
    tmp___0 = strlen((char const   *)p);
    }
    {
#line 820
    alloc_string(& program_path, (unsigned long )(tmp - tmp___0));
    }
    {
#line 821
    tmp___1 = strlen((char const   *)*(argv + 0));
    }
    {
#line 821
    tmp___2 = strlen((char const   *)p);
    }
    {
#line 821
    strncpy((char */* __restrict  */)program_path, (char const   */* __restrict  */)*(argv + 0),
            (tmp___1 - tmp___2) - 1U);
    }
    }
  }
  {
  {
#line 824
  tmp___3 = strlen((char const   *)p);
  }
  {
#line 824
  alloc_string(& program_name, (unsigned long )(tmp___3 + 1U));
  }
  {
#line 825
  strcpy((char */* __restrict  */)program_name, (char const   */* __restrict  */)p);
  }
  }
#line 827
  if (argc <= 1) {
    {
    {
#line 829
    show_usage(*(argv + 0));
    }
    }
#line 830
    return (2);
  }
  {
  {
#line 833
  tmp___4 = malloc((size_t )sizeof(*ptrtag));
  }
#line 833
  ptrtag = (ID3_tag *)tmp___4;
  }
#line 833
  if ((unsigned long )ptrtag == (unsigned long )((void *)0)) {
    {
    {
#line 835
    print_error((char *)"Out of memory for malloc");
    }
    {
#line 836
    exit(1);
    }
    }
  }
  {
  {
#line 847
  i = check_args(argc, argv);
  }
  }
#line 849
  if (i >= argc) {
    {
    {
#line 851
    user_message(1, (char *)"%s: Not enough arguments specified\n", program_name);
    }
    {
#line 852
    exit(2);
    }
    }
  }
  {
  {
#line 856
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < argc)) {
#line 856
      goto while_break;
    }
    {
#line 858
    count ++;
    {
#line 872
    strncpy((char */* __restrict  */)(arg), (char const   */* __restrict  */)*(argv + i),
            (size_t )(sizeof(arg) - 1UL));
    }
    {
#line 874
    tmp___11 = access((char const   *)(arg), 0);
    }
    }
#line 874
    if (tmp___11 != 0) {
      {
      {
#line 876
      user_message(1, (char *)"%s: File not found: %s\n", program_name, arg);
      }
      }
    } else {
      {
      {
#line 879
      tmp___10 = tag_file(arg);
      }
      }
#line 879
      if (tmp___10) {
#line 882
        if (flags.show_tag) {
          {
          {
#line 884
          id3_show_tag(ptrtag, arg);
          }
          }
        } else
#line 886
        if (! flags.tag_only) {
#line 886
          if (! flags.strip_tag) {
            {
            {
#line 888
            apply_template(arg);
            }
            {
#line 890
            tmp___9 = access((char const   *)(applied_filename), 0);
            }
            }
#line 890
            if (tmp___9 == 0) {
              {
              {
#line 892
              user_message(1, (char *)"%s: File already exists: %s\n", program_name,
                           applied_filename);
              }
              }
            } else {
              {
#line 898
              okflag = 1;
              {
#line 899
              strcpy((char */* __restrict  */)(tempname), (char const   */* __restrict  */)(applied_filename));
              }
#line 900
              s = tempname;
              }
              {
              {
#line 901
              while (1) {
                while_continue___2: /* CIL Label */ ;
                while_continue___0: /* CIL Label */ ;
#line 901
                if (! (okflag == 1)) {
#line 901
                  goto while_break___0;
                }
                {
                {
#line 903
                d = strchr((char const   *)s, '/');
                }
                }
#line 904
                if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 904
                  goto while_break___0;
                }
                {
#line 906
                *d = (char)0;
                {
#line 907
                tmp___7 = strcmp((char const   *)(tempname), "");
                }
                }
#line 907
                if (tmp___7 != 0) {
                  {
                  {
#line 908
                  tmp___6 = mkdir((char const   *)(tempname), (__mode_t )511);
                  }
                  }
#line 908
                  if (tmp___6 != 0) {
                    {
                    {
#line 910
                    tmp___5 = __errno_location();
                    }
                    }
#line 910
                    if (*tmp___5 != 17) {
                      {
                      {
#line 912
                      print_error((char *)"Create dir failed on %s", tempname);
                      }
#line 913
                      okflag = 0;
                      }
                    }
                  }
                }
#line 917
                *d = (char )'/';
#line 918
                s = d + 1;
              }
              while_break___2: /* CIL Label */ ;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 921
              if (okflag == 1) {
                {
                {
#line 923
                tmp___8 = rename((char const   *)(arg), (char const   *)(applied_filename));
                }
                }
#line 923
                if (tmp___8 == 0) {
                  {
                  {
#line 924
                  user_message(0, (char *)"%-38s => %-37s\n", arg, applied_filename);
                  }
                  }
                } else {
                  {
                  {
#line 926
                  print_error((char *)"Rename failed on %s", arg);
                  }
                  }
                }
              } else {
#line 930
                count --;
#line 931
                errcount ++;
              }
            }
          }
        }
      } else {
#line 938
        count --;
#line 939
        errcount ++;
      }
    }
#line 856
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 953
  user_message(0, (char *)"Processed: %d  Failed: %d  Total: %d\n", count, errcount,
               count + errcount);
  }
  }
#line 954
  return (0);
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 520
extern int getchar(void) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 27 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.h"
void resize_tag_field(char *field ) ;
#line 28
int get_tag_genre(int *genre , int def_genre___0 ) ;
#line 29
int get_tag_string(int size , char *def_string , char *string , char *desc ) ;
#line 30
int ask_tag(char *fn ) ;
#line 51 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
ID3_tag *ptrtag  =    (ID3_tag *)((void *)0);
#line 53 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
void show_genres(int pause_flag ) 
{ 
  int i ;
  int count ;
  int lines ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 58
  i = 0;
#line 58
  count = 1;
#line 58
  lines = 1;
  {
  {
#line 58
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < (int )genre_count)) {
#line 58
      goto while_break;
    }
    {
    {
#line 60
    printf((char const   */* __restrict  */)"%3d:%-15s", i + 1, genre_table[i]);
    }
    }
#line 62
    if (count >= 4) {
      {
      {
#line 64
      printf((char const   */* __restrict  */)"\n");
      }
#line 65
      count = 0;
#line 66
      lines ++;
      {
#line 67
      tmp___1 = get_term_lines();
      }
      }
#line 67
      if (lines >= tmp___1 - 1) {
#line 69
        if (pause_flag) {
          {
          {
#line 71
          printf((char const   */* __restrict  */)"-MORE- Press ENTER");
          }
          {
#line 73
          tmp___0 = _IO_getc(stdin);
          }
          }
#line 73
          if (tmp___0 != 10) {
            {
            {
#line 74
            while (1) {
              while_continue___2: /* CIL Label */ ;
              while_continue___0: /* CIL Label */ ;
              {
              {
#line 74
              tmp = _IO_getc(stdin);
              }
              }
#line 74
              if (! (tmp != 10)) {
#line 74
                goto while_break___0;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 76
          lines = 0;
        }
      }
    }
#line 58
    i ++;
#line 58
    count ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if (count > 1) {
    {
    {
#line 83
    printf((char const   */* __restrict  */)"\n");
    }
    }
  }
#line 85
  return;
}
}
#line 93 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
int search_genre(int flag_search_only , int *dest , char *search_gen ) 
{ 
  int i ;
  int digit ;
  int substring_matches ;
  char c ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 99
  c = (char )'z';
#line 101
  i = 0;
  {
  {
#line 103
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 103
    tmp = strlen((char const   *)search_gen);
    }
    }
#line 103
    if ((size_t )i < tmp) {
      {
      {
#line 103
      tmp___0 = __ctype_b_loc();
      }
      }
#line 103
      if (! ((int const   )*(*tmp___0 + (int )*(search_gen + i)) & 2048)) {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
#line 104
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 106
  tmp___2 = strlen((char const   *)search_gen);
  }
  }
#line 106
  if ((size_t )i >= tmp___2) {
    {
    {
#line 108
    tmp___1 = atoi((char const   *)search_gen);
    }
#line 108
    digit = tmp___1 - 1;
    }
#line 110
    if (digit >= 0) {
#line 110
      if (digit < (int )genre_count) {
#line 112
        if (flag_search_only == 2) {
          {
          {
#line 113
          user_message(0, (char *)"%s\n", genre_table[digit]);
          }
          }
        }
#line 115
        *dest = digit;
#line 116
        return (1);
      }
    }
    {
    {
#line 119
    user_message(1, (char *)"%s: search_genre: Invalid genre type: %d\n", program_name,
                 digit);
    }
#line 121
    *dest = -1;
    }
#line 122
    return (0);
  }
#line 125
  substring_matches = 0;
#line 127
  i = 0;
  {
  {
#line 127
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 127
    if (! (i < (int )genre_count)) {
#line 127
      goto while_break___0;
    }
#line 129
    if (flag_search_only != 2) {
      {
      {
#line 129
      tmp___3 = strcasecmp((char const   *)search_gen, (char const   *)genre_table[i]);
      }
      }
#line 129
      if (tmp___3 == 0) {
#line 132
        *dest = i;
#line 134
        if (flag_search_only == 0) {
#line 134
          if (flags.verbose) {
            {
            {
#line 135
            printf((char const   */* __restrict  */)"Found exact genre match [%s]\n",
                   genre_table[i]);
            }
            }
          }
        }
#line 137
        return (1);
      }
    }
    {
    {
#line 142
    tmp___4 = strcase_search(genre_table[i], search_gen);
    }
    }
#line 142
    if (tmp___4) {
#line 144
      substring_matches ++;
#line 146
      if (flag_search_only == 0) {
#line 146
        if (flags.verbose) {
          {
          {
#line 147
          printf((char const   */* __restrict  */)"Found matching genre [%s]\n", genre_table[i]);
          }
          }
        }
      }
#line 149
      if (flag_search_only == 2) {
        {
        {
#line 150
        printf((char const   */* __restrict  */)"%3d: %s\n", substring_matches, genre_table[i]);
        }
        }
      }
    }
#line 127
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  if (substring_matches == 0) {
    {
    {
#line 156
    user_message(0, (char *)"Genre not found: %s\n", search_gen);
    }
#line 157
    *dest = -1;
    }
#line 158
    return (0);
  }
#line 161
  if (flag_search_only == 2) {
#line 162
    return (1);
  }
#line 166
  i = 0;
  {
  {
#line 166
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 166
    if (i < (int )genre_count) {
#line 166
      if (! ((int )c != 113)) {
#line 166
        goto while_break___1;
      }
    } else {
#line 166
      goto while_break___1;
    }
    {
    {
#line 168
    tmp___8 = strcase_search(genre_table[i], search_gen);
    }
    }
#line 168
    if (tmp___8) {
#line 170
      if (substring_matches == 1) {
#line 172
        *dest = i;
#line 173
        return (1);
      }
      {
      {
#line 176
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
        {
        {
#line 178
        printf((char const   */* __restrict  */)"[%s] use this genre? (Y/n/q) ", genre_table[i]);
        }
        {
#line 179
        tmp___5 = getchar();
        }
        {
#line 179
        tmp___6 = tolower(tmp___5);
        }
#line 179
        c = (char )tmp___6;
        }
#line 181
        if ((int )c == 10) {
#line 183
          c = (char )'y';
        } else {
          {
          {
#line 187
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
            {
            {
#line 187
            tmp___7 = getchar();
            }
            }
#line 187
            if (! (tmp___7 != 10)) {
#line 187
              goto while_break___3;
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 176
        if ((int )c != 110) {
#line 176
          if ((int )c != 121) {
#line 176
            if (! ((int )c != 113)) {
#line 176
              goto while_break___2;
            }
          } else {
#line 176
            goto while_break___2;
          }
        } else {
#line 176
          goto while_break___2;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 191
      if ((int )c == 121) {
#line 193
        *dest = i;
#line 194
        return (1);
      }
    }
#line 166
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 199
  if (flag_search_only == 0) {
    {
    {
#line 200
    user_message(0, (char *)"No genre selected...tough choice isn\'t it?\n");
    }
    }
  }
#line 202
  *dest = -1;
#line 203
  return (0);
}
}
#line 206 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
void resize_tag_field(char *field ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
  {
#line 211
  tmp = strlen((char const   *)field);
  }
#line 211
  i = (int )tmp;
  }
  {
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((int )*(field + (i - 1)) == 32)) {
#line 212
      goto while_break;
    }
#line 213
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  *(field + i) = (char )'\000';
#line 216
  return;
}
}
#line 218 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
int get_tag_genre(int *genre , int def_genre___0 ) 
{ 
  char buffer[64] ;
  char c ;
  int flag_got_genre ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 223
  flag_got_genre = 0;
#line 225
  if (def_genre___0 >= 0) {
#line 225
    if (def_genre___0 < (int )genre_count) {
      {
#line 227
      *genre = def_genre___0;
      {
#line 228
      printf((char const   */* __restrict  */)"Genre of music: %s\n", genre_table[*genre]);
      }
      }
#line 229
      return (1);
    }
  }
#line 232
  if (flags.edit_tag) {
#line 232
    if (*genre >= 0) {
#line 232
      if (*genre < (int )genre_count) {
        {
        {
#line 234
        printf((char const   */* __restrict  */)"Genre of music: %s\n", genre_table[*genre]);
        }
        }
#line 235
        return (1);
      }
    }
  }
  {
  {
#line 238
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 240
    printf((char const   */* __restrict  */)"Genre of music (blank to cancel, \'l\' to list): ");
    }
    {
#line 241
    fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)stdin);
    }
    {
#line 243
    tmp___1 = strlen((char const   *)(buffer));
    }
    }
#line 243
    if ((int )buffer[tmp___1 - 1U] == 10) {
      {
      {
#line 245
      tmp = strlen((char const   *)(buffer));
      }
#line 245
      buffer[tmp - 1U] = (char )'\000';
      }
    } else {
      {
      {
#line 249
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 249
        tmp___0 = _IO_getc(stdin);
        }
        }
#line 249
        if (! (tmp___0 != 10)) {
#line 249
          goto while_break___0;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 252
    tmp___7 = tolower((int )buffer[0]);
    }
    }
#line 252
    if (tmp___7 == 108) {
      {
      {
#line 253
      show_genres(1);
      }
      }
    } else {
      {
      {
#line 254
      tmp___6 = strlen((char const   *)(buffer));
      }
      }
#line 254
      if (tmp___6 < 1U) {
#line 255
        flag_got_genre = 1;
      } else {
        {
        {
#line 256
        tmp___5 = search_genre(0, genre, buffer);
        }
        }
#line 256
        if (tmp___5 == 1) {
#line 257
          flag_got_genre = 1;
        } else {
          {
          {
#line 260
          while (1) {
            while_continue___5: /* CIL Label */ ;
            while_continue___1: /* CIL Label */ ;
            {
            {
#line 262
            printf((char const   */* __restrict  */)"Would you like to see a list? (Y/n) ");
            }
            {
#line 263
            tmp___2 = getchar();
            }
            {
#line 263
            tmp___3 = tolower(tmp___2);
            }
#line 263
            c = (char )tmp___3;
            }
#line 260
            if ((int )c != 110) {
#line 260
              if ((int )c != 121) {
#line 260
                if (! ((int )c != 10)) {
#line 260
                  goto while_break___1;
                }
              } else {
#line 260
                goto while_break___1;
              }
            } else {
#line 260
              goto while_break___1;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 266
          if ((int )c == 10) {
#line 267
            c = (char )'y';
          } else {
            {
            {
#line 269
            while (1) {
              while_continue___6: /* CIL Label */ ;
              while_continue___2: /* CIL Label */ ;
              {
              {
#line 269
              tmp___4 = getchar();
              }
              }
#line 269
              if (! (tmp___4 != 10)) {
#line 269
                goto while_break___2;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 271
          if ((int )c == 121) {
            {
            {
#line 272
            show_genres(1);
            }
            }
          }
        }
      }
    }
#line 238
    if (! (flag_got_genre == 0)) {
#line 238
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (*genre != -1) {
    {
    {
#line 277
    printf((char const   */* __restrict  */)"\"%s\" selected.\n", genre_table[*genre]);
    }
    }
  }
#line 279
  return (1);
}
}
#line 282 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
int get_tag_track(char *track , char def_track___0 , char *version ) 
{ 
  char buffer[64] ;
  char tracktmp ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 289
  *version = (char)0;
#line 291
  if ((int )def_track___0 >= 0) {
#line 291
    if ((int )def_track___0 <= 99) {
      {
#line 293
      *track = def_track___0;
      {
#line 294
      printf((char const   */* __restrict  */)"Track: %02d\n", (int )*track);
      }
#line 295
      *version = (char)1;
      }
#line 296
      return (1);
    }
  }
#line 299
  if (flags.edit_tag) {
#line 299
    if ((int )*track >= 0) {
#line 299
      if ((int )*track <= 99) {
        {
        {
#line 301
        printf((char const   */* __restrict  */)"Track: %02d\n", (int )*track);
        }
#line 302
        *version = (char)1;
        }
#line 303
        return (1);
      }
    }
  }
  {
  {
#line 306
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 308
    printf((char const   */* __restrict  */)"Track (1 to 99, blank for none): ");
    }
    {
#line 309
    fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)stdin);
    }
    {
#line 311
    tmp___1 = strlen((char const   *)(buffer));
    }
    }
#line 311
    if ((int )buffer[tmp___1 - 1U] == 10) {
      {
      {
#line 313
      tmp = strlen((char const   *)(buffer));
      }
#line 313
      buffer[tmp - 1U] = (char )'\000';
      }
    } else {
      {
      {
#line 317
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 317
        tmp___0 = _IO_getc(stdin);
        }
        }
#line 317
        if (! (tmp___0 != 10)) {
#line 317
          goto while_break___0;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 320
    tmp___3 = strcmp((char const   *)(buffer), "");
    }
    }
#line 320
    if (tmp___3 == 0) {
#line 321
      return (1);
    } else {
#line 324
      tracktmp = (char)0;
#line 325
      i = 0;
      {
      {
#line 325
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 325
        tmp___2 = strlen((char const   *)(buffer));
        }
        }
#line 325
        if (! ((size_t )i < tmp___2)) {
#line 325
          goto while_break___1;
        }
#line 327
        if ((int )buffer[i] < 48) {
#line 328
          tracktmp = (char)0;
#line 329
          goto while_break___1;
        } else
#line 327
        if ((int )buffer[i] > 57) {
#line 328
          tracktmp = (char)0;
#line 329
          goto while_break___1;
        } else {
#line 331
          tracktmp = (char )(((int )tracktmp * 10 + (int )buffer[i]) - 48);
        }
#line 325
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 335
    if ((int )tracktmp > 0) {
#line 335
      if ((int )tracktmp < 100) {
#line 336
        *track = tracktmp;
#line 337
        *version = (char)1;
      } else {
#line 340
        tracktmp = (char)0;
      }
    } else {
#line 340
      tracktmp = (char)0;
    }
#line 306
    if (! ((int )tracktmp == 0)) {
#line 306
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (1);
}
}
#line 347 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
int get_tag_string(int size , char *def_string , char *string , char *desc ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 351
  printf((char const   */* __restrict  */)"%s (%d chars): ", desc, size - 1);
  }
  }
#line 353
  if ((unsigned long )def_string != (unsigned long )((void *)0)) {
    {
    {
#line 353
    tmp = strlen((char const   *)def_string);
    }
    }
#line 353
    if (tmp > 0U) {
      {
      {
#line 355
      strcpy((char */* __restrict  */)string, (char const   */* __restrict  */)def_string);
      }
      {
#line 356
      printf((char const   */* __restrict  */)"%s\n", string);
      }
      }
#line 357
      return (1);
    }
  }
#line 360
  if (flags.edit_tag) {
#line 360
    if ((unsigned long )string != (unsigned long )((void *)0)) {
      {
      {
#line 360
      tmp___0 = strlen((char const   *)string);
      }
      }
#line 360
      if (tmp___0 > 0U) {
        {
        {
#line 362
        printf((char const   */* __restrict  */)"%s\n", string);
        }
        }
#line 363
        return (1);
      }
    }
  }
  {
  {
#line 366
  fgets((char */* __restrict  */)string, size, (FILE */* __restrict  */)stdin);
  }
  {
#line 368
  tmp___3 = strlen((char const   *)string);
  }
  }
#line 368
  if ((int )*(string + (tmp___3 - 1U)) == 10) {
    {
    {
#line 369
    tmp___1 = strlen((char const   *)string);
    }
#line 369
    *(string + (tmp___1 - 1U)) = (char )'\000';
    }
  } else {
    {
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 371
      tmp___2 = _IO_getc(stdin);
      }
      }
#line 371
      if (! (tmp___2 != 10)) {
#line 371
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 373
  return (1);
}
}
#line 377 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
int ask_tag(char *fn ) 
{ 
  ID3_tag fntag ;
  char track[20] ;
  char genre[20] ;
  char *t ;
  char *w ;
  char *p ;
  char *f ;
  char *pfntmp ;
  char *ptagtmp ;
  char tagtmp[256] ;
  char fntmp[256] ;
  int length ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
  {
#line 386
  memset((void *)(& fntag), 0, (size_t )sizeof(ID3_tag ));
  }
  }
#line 387
  if ((int )flags.tag_ffn == 1) {
    {
    {
#line 389
    strcpy((char */* __restrict  */)(tagtmp), (char const   */* __restrict  */)(tag_template));
    }
#line 389
    ptagtmp = tagtmp;
#line 389
    p = ptagtmp;
    {
#line 390
    strcpy((char */* __restrict  */)(fntmp), (char const   */* __restrict  */)fn);
    }
#line 390
    pfntmp = fntmp;
#line 391
    w = (char *)((void *)0);
    }
    {
    {
#line 393
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 393
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 393
        goto while_break;
      }
      {
      {
#line 395
      p = strchr((char const   *)ptagtmp, '%');
      }
      }
#line 398
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 400
        *p = (char)0;
#line 401
        if ((int )*(p + 1) == 0) {
#line 401
          goto while_break;
        }
      }
      {
      {
#line 404
      f = strstr((char const   *)pfntmp, (char const   *)ptagtmp);
      }
      }
#line 405
      if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 405
        goto while_break;
      }
#line 407
      if ((unsigned long )w != (unsigned long )((void *)0)) {
        {
#line 411
        if ((int )*w == 97) {
#line 411
          goto case_97;
        }
#line 415
        if ((int )*w == 99) {
#line 415
          goto case_99;
        }
#line 425
        if ((int )*w == 115) {
#line 425
          goto case_115;
        }
#line 429
        if ((int )*w == 116) {
#line 429
          goto case_116;
        }
#line 433
        if ((int )*w == 121) {
#line 433
          goto case_121;
        }
#line 437
        if ((int )*w == 100) {
#line 437
          goto case_100;
        }
#line 439
        if ((int )*w == 103) {
#line 439
          goto case_103;
        }
#line 445
        if ((int )*w == 110) {
#line 445
          goto case_110;
        }
#line 409
        goto switch_break;
        case_97: /* CIL Label */ 
#line 412
        if ((unsigned long )(f - pfntmp) < sizeof(fntag.artist)) {
#line 412
          length = (int )(f - pfntmp);
        } else {
#line 412
          length = (int )sizeof(fntag.artist);
        }
        {
        {
#line 413
        strncpy((char */* __restrict  */)(fntag.artist), (char const   */* __restrict  */)pfntmp,
                (size_t )length);
        }
        }
#line 414
        goto switch_break;
        case_99: /* CIL Label */ 
#line 416
        if ((int )fntag.version == 0) {
#line 417
          if ((unsigned long )(f - pfntmp) < sizeof(fntag.u.v10.comment)) {
#line 417
            length = (int )(f - pfntmp);
          } else {
#line 417
            length = (int )sizeof(fntag.u.v10.comment);
          }
          {
          {
#line 418
          strncpy((char */* __restrict  */)(fntag.u.v10.comment), (char const   */* __restrict  */)pfntmp,
                  (size_t )length);
          }
          }
        } else {
#line 421
          if ((unsigned long )(f - pfntmp) < sizeof(fntag.u.v11.comment)) {
#line 421
            length = (int )(f - pfntmp);
          } else {
#line 421
            length = (int )sizeof(fntag.u.v11.comment);
          }
          {
          {
#line 422
          strncpy((char */* __restrict  */)(fntag.u.v11.comment), (char const   */* __restrict  */)pfntmp,
                  (size_t )length);
          }
          }
        }
#line 424
        goto switch_break;
        case_115: /* CIL Label */ 
#line 426
        if ((unsigned long )(f - pfntmp) < sizeof(fntag.songname)) {
#line 426
          length = (int )(f - pfntmp);
        } else {
#line 426
          length = (int )sizeof(fntag.songname);
        }
        {
        {
#line 427
        strncpy((char */* __restrict  */)(fntag.songname), (char const   */* __restrict  */)pfntmp,
                (size_t )length);
        }
        }
#line 428
        goto switch_break;
        case_116: /* CIL Label */ 
#line 430
        if ((unsigned long )(f - pfntmp) < sizeof(fntag.album)) {
#line 430
          length = (int )(f - pfntmp);
        } else {
#line 430
          length = (int )sizeof(fntag.album);
        }
        {
        {
#line 431
        strncpy((char */* __restrict  */)(fntag.album), (char const   */* __restrict  */)pfntmp,
                (size_t )length);
        }
        }
#line 432
        goto switch_break;
        case_121: /* CIL Label */ 
#line 434
        if ((unsigned long )(f - pfntmp) < sizeof(fntag.year)) {
#line 434
          length = (int )(f - pfntmp);
        } else {
#line 434
          length = (int )sizeof(fntag.year);
        }
        {
        {
#line 435
        strncpy((char */* __restrict  */)(fntag.year), (char const   */* __restrict  */)pfntmp,
                (size_t )length);
        }
        }
#line 436
        goto switch_break;
        case_100: /* CIL Label */ 
#line 438
        goto switch_break;
        case_103: /* CIL Label */ 
        {
        {
#line 440
        memset((void *)(genre), 0, (size_t )sizeof(genre));
        }
        }
#line 441
        if ((unsigned long )(f - pfntmp) < sizeof(genre) - 1UL) {
#line 441
          length = (int )(f - pfntmp);
        } else {
#line 441
          length = (int )(sizeof(genre) - 1UL);
        }
        {
        {
#line 442
        strncpy((char */* __restrict  */)(genre), (char const   */* __restrict  */)pfntmp,
                (size_t )length);
        }
        {
#line 443
        search_genre(2, & fntag.genre, genre);
        }
        }
#line 444
        goto switch_break;
        case_110: /* CIL Label */ 
        {
        {
#line 446
        memset((void *)(track), 0, (size_t )sizeof(track));
        }
        }
#line 447
        if ((unsigned long )(f - pfntmp) < sizeof(track) - 1UL) {
#line 447
          length = (int )(f - pfntmp);
        } else {
#line 447
          length = (int )(sizeof(track) - 1UL);
        }
        {
        {
#line 448
        strncpy((char */* __restrict  */)(track), (char const   */* __restrict  */)pfntmp,
                (size_t )length);
        }
#line 449
        fntag.version = (char)1;
#line 450
        fntag.u.v11.track = (char)0;
#line 451
        t = track;
        }
        {
        {
#line 452
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 452
          if (! ((int )*t != 0)) {
#line 452
            goto while_break___0;
          }
#line 453
          fntag.u.v11.track = (char )((int )fntag.u.v11.track * 10);
#line 454
          fntag.u.v11.track = (char )((int )fntag.u.v11.track + ((int )*t - 48));
#line 455
          t ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 457
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 459
        w = (char *)((void *)0);
      }
      {
      {
#line 462
      tmp = strlen((char const   *)ptagtmp);
      }
#line 462
      f += tmp;
      }
#line 464
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 466
        w = p + 1;
#line 467
        p += 2;
#line 469
        ptagtmp = p;
#line 470
        pfntmp = f;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 475
  tmp___0 = strcmp((char const   *)(fntag.songname), "");
  }
  }
#line 475
  if (tmp___0 == 0) {
    {
    {
#line 476
    get_tag_string((int )sizeof(ptrtag->songname), def_song, ptrtag->songname, (char *)"Song Name");
    }
    }
  } else {
    {
    {
#line 478
    get_tag_string((int )sizeof(ptrtag->songname), fntag.songname, ptrtag->songname,
                   (char *)"Song Name");
    }
    }
  }
  {
  {
#line 480
  tmp___1 = strcmp((char const   *)(fntag.artist), "");
  }
  }
#line 480
  if (tmp___1 == 0) {
    {
    {
#line 481
    get_tag_string((int )sizeof(ptrtag->artist), def_artist, ptrtag->artist, (char *)"Artist Name");
    }
    }
  } else {
    {
    {
#line 483
    get_tag_string((int )sizeof(ptrtag->artist), fntag.artist, ptrtag->artist, (char *)"Artist Name");
    }
    }
  }
#line 485
  if ((int )flags.no_album == 0) {
    {
    {
#line 487
    tmp___2 = strcmp((char const   *)(fntag.album), "");
    }
    }
#line 487
    if (tmp___2 == 0) {
      {
      {
#line 488
      get_tag_string((int )sizeof(ptrtag->album), def_album, ptrtag->album, (char *)"Album Name");
      }
      }
    } else {
      {
      {
#line 490
      get_tag_string((int )sizeof(ptrtag->album), fntag.album, ptrtag->album, (char *)"Album Name");
      }
      }
    }
  }
#line 493
  if ((int )flags.no_year == 0) {
    {
    {
#line 495
    tmp___3 = strcmp((char const   *)(fntag.year), "");
    }
    }
#line 495
    if (tmp___3 == 0) {
      {
      {
#line 496
      get_tag_string((int )sizeof(ptrtag->year), def_year, ptrtag->year, (char *)"Year");
      }
      }
    } else {
      {
      {
#line 498
      get_tag_string((int )sizeof(ptrtag->year), fntag.year, ptrtag->year, (char *)"Year");
      }
      }
    }
  }
#line 501
  if ((int )flags.no_track == 0) {
#line 503
    if ((int )fntag.version == 1) {
#line 503
      if ((int )fntag.u.v11.track != 0) {
        {
        {
#line 504
        get_tag_track(& ptrtag->u.v11.track, fntag.u.v11.track, & ptrtag->version);
        }
        }
      } else {
        {
        {
#line 506
        get_tag_track(& ptrtag->u.v11.track, def_track, & ptrtag->version);
        }
        }
      }
    } else {
      {
      {
#line 506
      get_tag_track(& ptrtag->u.v11.track, def_track, & ptrtag->version);
      }
      }
    }
  }
#line 509
  if ((int )flags.no_comment == 0) {
#line 511
    if ((int )ptrtag->version == 0) {
      {
      {
#line 513
      tmp___4 = strcmp((char const   *)(fntag.u.v10.comment), "");
      }
      }
#line 513
      if (tmp___4 == 0) {
        {
        {
#line 514
        get_tag_string((int )sizeof(ptrtag->u.v10.comment), def_comment, ptrtag->u.v10.comment,
                       (char *)"Comment");
        }
        }
      } else {
        {
        {
#line 516
        get_tag_string((int )sizeof(ptrtag->u.v10.comment), fntag.u.v10.comment, ptrtag->u.v10.comment,
                       (char *)"Comment");
        }
        }
      }
    } else {
      {
      {
#line 520
      tmp___5 = strcmp((char const   *)(fntag.u.v11.comment), "");
      }
      }
#line 520
      if (tmp___5 == 0) {
        {
        {
#line 521
        get_tag_string((int )sizeof(ptrtag->u.v11.comment), def_comment, ptrtag->u.v11.comment,
                       (char *)"Comment");
        }
        }
      } else {
        {
        {
#line 523
        get_tag_string((int )sizeof(ptrtag->u.v11.comment), fntag.u.v11.comment, ptrtag->u.v11.comment,
                       (char *)"Comment");
        }
        }
      }
    }
  }
#line 527
  if ((int )flags.no_genre == 0) {
#line 529
    if (fntag.genre == 0) {
      {
      {
#line 530
      get_tag_genre(& ptrtag->genre, def_genre);
      }
      }
    } else {
      {
      {
#line 532
      get_tag_genre(& ptrtag->genre, fntag.genre);
      }
      }
    }
  }
  {
  {
#line 535
  tmp___6 = strlen((char const   *)(ptrtag->songname));
  }
  }
#line 535
  if (tmp___6 < 1U) {
    {
    {
#line 538
    user_message(0, (char *)"Not enough info entered to tag %s\n", fn);
    }
    }
#line 539
    return (0);
  }
#line 542
  return (1);
}
}
#line 546 "/home/wslee/benchmarks/sound/id3ren-1.1b0/src/id3tag.c"
int tag_file(char *fn ) 
{ 
  FILE *fp ;
  long sizelesstag ;
  short found_tag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
  {
#line 553
  tmp = id3_open_file(& fp, fn, (char *)"rb");
  }
  }
#line 553
  if (tmp == 0) {
#line 554
    return (0);
  }
  {
  {
#line 556
  memset((void *)ptrtag, 0, (size_t )sizeof(ID3_tag ));
  }
  {
#line 558
  tmp___0 = id3_seek_header(fp, fn);
  }
  }
#line 558
  if (tmp___0 == 0) {
#line 558
    return (0);
  }
  {
  {
#line 559
  sizelesstag = ftell(fp);
  }
  {
#line 561
  tmp___1 = id3_read_file(ptrtag->tag, sizeof(ptrtag->tag) - 1UL, fp, fn);
  }
  }
#line 561
  if (! tmp___1) {
#line 562
    return (0);
  }
  {
  {
#line 567
  tmp___2 = strcmp((char const   *)(ptrtag->tag), "TAG");
  }
  }
#line 567
  if (tmp___2 != 0) {
#line 568
    found_tag = (short)0;
  } else {
#line 570
    found_tag = (short)1;
  }
#line 573
  if ((int )found_tag == 0) {
    {
    {
#line 575
    id3_close_file(fp);
    }
    {
#line 577
    user_message(0, (char *)"*** No ID3 tag found in %s\n", fn);
    }
    }
#line 579
    if ((int )flags.strip_tag == 1) {
#line 580
      return (1);
    }
#line 583
    if ((int )flags.no_tag_prompt == 1) {
#line 584
      return (0);
    }
    {
    {
#line 586
    printf((char const   */* __restrict  */)"\n===> Entering new tag info for %s:\n",
           fn);
    }
    {
#line 587
    tmp___3 = ask_tag(fn);
    }
    }
#line 587
    if (tmp___3 == 0) {
#line 588
      return (0);
    }
    {
    {
#line 590
    tmp___4 = id3_write_tag(ptrtag, 1, fn);
    }
    }
#line 590
    if (tmp___4 == 0) {
#line 591
      return (0);
    }
#line 593
    if ((int )flags.tag_only == 1) {
#line 594
      return (1);
    }
    {
    {
#line 596
    tmp___5 = id3_open_file(& fp, fn, (char *)"rb");
    }
    }
#line 596
    if (tmp___5 == 0) {
#line 597
      return (0);
    }
    {
    {
#line 599
    tmp___6 = id3_seek_header(fp, fn);
    }
    }
#line 599
    if (tmp___6 == 0) {
#line 599
      return (0);
    }
    {
    {
#line 601
    tmp___7 = id3_read_file(ptrtag->tag, sizeof(ptrtag->tag) - 1UL, fp, fn);
    }
    }
#line 601
    if (! tmp___7) {
#line 602
      return (0);
    }
  } else
#line 604
  if ((int )flags.force_tag == 1) {
    {
    {
#line 606
    tmp___8 = id3_read_tag(ptrtag, fp, fn);
    }
    }
#line 606
    if (tmp___8 == 0) {
#line 607
      return (0);
    }
    {
    {
#line 609
    id3_close_file(fp);
    }
    {
#line 610
    printf((char const   */* __restrict  */)"\n===> Changing old tag info for %s:\n",
           fn);
    }
    {
#line 612
    tmp___9 = ask_tag(fn);
    }
    }
#line 612
    if (tmp___9 == 0) {
#line 613
      return (0);
    }
    {
    {
#line 615
    tmp___10 = id3_write_tag(ptrtag, 0, fn);
    }
    }
#line 615
    if (tmp___10 == 0) {
#line 616
      return (0);
    }
#line 618
    if ((int )flags.tag_only == 1) {
#line 619
      return (1);
    }
    {
    {
#line 621
    tmp___11 = id3_open_file(& fp, fn, (char *)"rb");
    }
    }
#line 621
    if (tmp___11 == 0) {
#line 622
      return (0);
    }
    {
    {
#line 624
    tmp___12 = id3_seek_header(fp, fn);
    }
    }
#line 624
    if (tmp___12 == 0) {
#line 624
      return (0);
    }
    {
    {
#line 626
    tmp___13 = id3_read_file(ptrtag->tag, sizeof(ptrtag->tag) - 1UL, fp, fn);
    }
    }
#line 626
    if (! tmp___13) {
#line 627
      return (0);
    }
  } else
#line 629
  if ((int )flags.tag_only == 1) {
    {
    {
#line 631
    id3_close_file(fp);
    }
    {
#line 632
    user_message(0, (char *)"===> Already has a tag: %s\n", fn);
    }
    }
#line 633
    return (1);
  } else
#line 635
  if ((int )flags.strip_tag == 1) {
    {
    {
#line 637
    id3_close_file(fp);
    }
    {
#line 638
    tmp___14 = id3_strip_tag(sizelesstag, fn);
    }
    }
#line 638
    if (tmp___14 == 0) {
#line 639
      return (0);
    }
    {
    {
#line 640
    user_message(0, (char *)"===> Removed ID3 tag from %s\n", fn);
    }
    }
#line 641
    return (1);
  }
  {
  {
#line 644
  tmp___15 = id3_read_tag(ptrtag, fp, fn);
  }
  }
#line 644
  if (tmp___15 == 0) {
#line 645
    return (0);
  }
  {
  {
#line 647
  resize_tag_field(ptrtag->songname);
  }
  {
#line 648
  resize_tag_field(ptrtag->artist);
  }
  {
#line 649
  resize_tag_field(ptrtag->album);
  }
  {
#line 650
  resize_tag_field(ptrtag->year);
  }
  {
#line 651
  resize_tag_field(ptrtag->u.v10.comment);
  }
  {
#line 652
  id3_close_file(fp);
  }
  }
#line 653
  return (1);
}
}
