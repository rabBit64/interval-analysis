/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 8 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.h"
struct stream_tTAG;
#line 8 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.h"
typedef struct stream_tTAG stream_t;
#line 7 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.h"
typedef uint32_t fourcc_t;
#line 9 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.h"
struct __anonstruct_time_to_sample_25 {
   uint32_t sample_count ;
   uint32_t sample_duration ;
};
#line 9 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.h"
struct __anonstruct_demux_res_t_24 {
   int format_read ;
   uint16_t num_channels ;
   uint16_t sample_size ;
   uint32_t sample_rate ;
   fourcc_t format ;
   void *buf ;
   struct __anonstruct_time_to_sample_25 *time_to_sample ;
   uint32_t num_time_to_samples ;
   uint32_t *sample_byte_size ;
   uint32_t num_sample_byte_sizes ;
   uint32_t codecdata_len ;
   void *codecdata ;
   uint32_t mdat_len ;
};
#line 9 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.h"
typedef struct __anonstruct_demux_res_t_24 demux_res_t;
#line 4 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/decomp.h"
struct alac_file;
#line 4 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/decomp.h"
typedef struct alac_file alac_file;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 53 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
struct alac_file {
   unsigned char *input_buffer ;
   int input_buffer_bitaccumulator ;
   int samplesize ;
   int numchannels ;
   int bytespersample ;
   int32_t *predicterror_buffer_a ;
   int32_t *predicterror_buffer_b ;
   int32_t *outputsamples_buffer_a ;
   int32_t *outputsamples_buffer_b ;
   uint32_t setinfo_max_samples_per_frame ;
   uint8_t setinfo_7a ;
   uint8_t setinfo_sample_size ;
   uint8_t setinfo_rice_historymult ;
   uint8_t setinfo_rice_initialhistory ;
   uint8_t setinfo_rice_kmodifier ;
   uint8_t setinfo_7f ;
   uint16_t setinfo_80 ;
   uint32_t setinfo_82 ;
   uint32_t setinfo_86 ;
   uint32_t setinfo_8a_rate ;
};
#line 41 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
struct __anonstruct_qtmovie_t_25 {
   stream_t *stream ;
   demux_res_t *res ;
   long saved_mdat_pos ;
};
#line 41 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
typedef struct __anonstruct_qtmovie_t_25 qtmovie_t;
#line 37 "/usr/include/stdint.h"
typedef signed char int8_t;
#line 52 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
struct stream_tTAG {
   FILE *f ;
   int bigendian ;
   int eof ;
};
#line 688 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 55 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/wavwriter.c"
int host_bigendian ;
#line 57 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/wavwriter.c"
static void write_uint32(FILE *f , uint32_t v , int bigendian ) 
{ 


  {
#line 59
  if (bigendian ^ host_bigendian) {
    {
    {
#line 59
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 59
      v = ((((v & 255U) << 24) | ((v & 65280U) << 8)) | ((v & 16711680U) >> 8)) | ((v & 4278190080U) >> 24);
#line 59
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 60
  fwrite((void const   */* __restrict  */)(& v), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
  }
  }
#line 61
  return;
}
}
#line 63 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/wavwriter.c"
static void write_uint16(FILE *f , uint16_t v , int bigendian ) 
{ 


  {
#line 65
  if (bigendian ^ host_bigendian) {
    {
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 65
      v = (uint16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 65
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 66
  fwrite((void const   */* __restrict  */)(& v), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
  }
  }
#line 67
  return;
}
}
#line 69 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/wavwriter.c"
void wavwriter_writeheaders(FILE *f , int datasize , int numchannels , int samplerate ,
                            int bitspersample ) 
{ 


  {
  {
  {
#line 74
  write_uint32(f, (uint32_t )((((82 << 24) | (73 << 16)) | (70 << 8)) | 70), 1);
  }
  {
#line 75
  write_uint32(f, (uint32_t )(36 + datasize), 0);
  }
  {
#line 76
  write_uint32(f, (uint32_t )((((87 << 24) | (65 << 16)) | (86 << 8)) | 69), 1);
  }
  {
#line 79
  write_uint32(f, (uint32_t )((((102 << 24) | (109 << 16)) | (116 << 8)) | 32), 1);
  }
  {
#line 80
  write_uint32(f, (uint32_t )16, 0);
  }
  {
#line 81
  write_uint16(f, (uint16_t )1, 0);
  }
  {
#line 82
  write_uint16(f, (uint16_t )numchannels, 0);
  }
  {
#line 83
  write_uint32(f, (uint32_t )samplerate, 0);
  }
  {
#line 84
  write_uint32(f, (uint32_t )((samplerate * numchannels) * (bitspersample / 8)), 0);
  }
  {
#line 85
  write_uint16(f, (uint16_t )(numchannels * (bitspersample / 8)), 0);
  }
  {
#line 86
  write_uint16(f, (uint16_t )bitspersample, 0);
  }
  {
#line 89
  write_uint32(f, (uint32_t )((((100 << 24) | (97 << 16)) | (116 << 8)) | 97), 1);
  }
  {
#line 90
  write_uint32(f, (uint32_t )datasize, 0);
  }
  }
#line 91
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 819
extern void perror(char const   *__s ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 10 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.h"
void stream_read(stream_t *stream , size_t size , void *buf ) ;
#line 28
stream_t *stream_create_file(FILE *file , int bigendian ) ;
#line 30
void stream_destroy(stream_t *stream ) ;
#line 37 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.h"
int qtmovie_read(stream_t *file , demux_res_t *demux_res ) ;
#line 6 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/decomp.h"
alac_file *create_alac(int samplesize , int numchannels ) ;
#line 7
void decode_frame(alac_file *alac___0 , unsigned char *inbuffer , void *outbuffer ,
                  int *outputsize ) ;
#line 10
void alac_set_info(alac_file *alac___0 , char *inputbuffer ) ;
#line 47 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
int host_bigendian  =    0;
#line 49 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
alac_file *alac  =    (alac_file *)((void *)0);
#line 51 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static FILE *input_file  =    (FILE *)((void *)0);
#line 52 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int input_opened  =    0;
#line 53 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static stream_t *input_stream  ;
#line 55 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static FILE *output_file  =    (FILE *)((void *)0);
#line 56 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int output_opened  =    0;
#line 58 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int write_wav_format  =    1;
#line 59 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int verbose  =    0;
#line 60 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int test_file_type  =    0;
#line 62 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int get_sample_info(demux_res_t *demux_res , uint32_t samplenum , uint32_t *sample_duration ,
                           uint32_t *sample_byte_size ) 
{ 
  unsigned int duration_index_accum ;
  unsigned int duration_cur_index ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 66
  duration_index_accum = 0U;
#line 67
  duration_cur_index = 0U;
#line 69
  if (samplenum >= demux_res->num_sample_byte_sizes) {
    {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample %i does not exist\n",
            samplenum);
    }
    }
#line 72
    return (0);
  }
#line 75
  if (! demux_res->num_time_to_samples) {
    {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no time to samples\n");
    }
    }
#line 78
    return (0);
  }
  {
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((demux_res->time_to_sample + duration_cur_index)->sample_count + duration_index_accum <= samplenum)) {
#line 80
      goto while_break;
    }
#line 83
    duration_index_accum += (demux_res->time_to_sample + duration_cur_index)->sample_count;
#line 84
    duration_cur_index ++;
#line 85
    if (duration_cur_index >= demux_res->num_time_to_samples) {
      {
      {
#line 87
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample %i does not have a duration\n",
              samplenum);
      }
      }
#line 88
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  *sample_duration = (demux_res->time_to_sample + duration_cur_index)->sample_duration;
#line 93
  *sample_byte_size = *(demux_res->sample_byte_size + samplenum);
#line 95
  return (1);
}
}
#line 98 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void GetBuffer(demux_res_t *demux_res ) 
{ 
  unsigned long destBufferSize ;
  void *pDestBuffer ;
  void *tmp ;
  int bytes_read ;
  unsigned int buffer_size ;
  void *buffer ;
  unsigned int i ;
  uint32_t sample_duration ;
  uint32_t sample_byte_size ;
  int outputBytes ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 100
  destBufferSize = 16384UL;
  {
#line 101
  tmp = malloc((size_t )destBufferSize);
  }
#line 101
  pDestBuffer = tmp;
#line 102
  bytes_read = 0;
#line 104
  buffer_size = 65536U;
  {
#line 109
  buffer = malloc(buffer_size);
  }
#line 111
  i = 0U;
  }
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < demux_res->num_sample_byte_sizes)) {
#line 111
      goto while_break;
    }
    {
    {
#line 119
    tmp___0 = get_sample_info(demux_res, i, & sample_duration, & sample_byte_size);
    }
    }
#line 119
    if (! tmp___0) {
      {
      {
#line 122
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample failed\n");
      }
      }
#line 123
      return;
    }
#line 126
    if (buffer_size < sample_byte_size) {
      {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sorry buffer too small! (is %i want %i)\n",
              buffer_size, sample_byte_size);
      }
      }
#line 131
      return;
    }
    {
    {
#line 134
    stream_read(input_stream, sample_byte_size, buffer);
    }
#line 138
    outputBytes = (int )destBufferSize;
    {
#line 139
    decode_frame(alac, (unsigned char *)buffer, pDestBuffer, & outputBytes);
    }
#line 142
    bytes_read += outputBytes;
    }
#line 144
    if (verbose) {
      {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read %i bytes. total: %i\n",
              outputBytes, bytes_read);
      }
      }
    }
    {
    {
#line 147
    fwrite((void const   */* __restrict  */)pDestBuffer, (size_t )outputBytes, (size_t )1,
           (FILE */* __restrict  */)output_file);
    }
#line 111
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (verbose) {
    {
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done reading, read %i frames\n",
            i);
    }
    }
  }
#line 151
  return;
}
}
#line 153 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void init_sound_converter(demux_res_t *demux_res ) 
{ 


  {
  {
  {
#line 155
  alac = create_alac((int )demux_res->sample_size, (int )demux_res->num_channels);
  }
  {
#line 157
  alac_set_info(alac, (char *)demux_res->codecdata);
  }
  }
#line 158
  return;
}
}
#line 160 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void usage(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 162
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: alac [options] [--] file\nDecompresses the ALAC file specified\n\nOptions:\n  -f output.wav     outputs the decompressed data to the\n                    specified file, in WAV format. Default\n                    is stdout.\n  -r                write output as raw PCM data. Default\n                    is in WAV format.\n  -v                verbose output.\n  -t                test that file is ALAC, also tests for\n                    other m4a file types.\n\nThis software is Copyright (c) 2005 David Hammerton\nAll rights reserved\nhttp://crazney.net/\n");
  }
  {
#line 178
  exit(1);
  }
  }
}
}
#line 181 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void setup_environment(int argc , char **argv ) 
{ 
  int i ;
  char *input_file_n ;
  char *output_file_n ;
  int escaped ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 183
  i = argc;
#line 185
  input_file_n = (char *)((void *)0);
#line 186
  output_file_n = (char *)((void *)0);
#line 188
  escaped = 0;
#line 190
  if (argc < 2) {
    {
    {
#line 190
    usage();
    }
    }
  }
#line 192
  i = argc - 1;
  {
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i > 1)) {
#line 192
      goto while_break;
    }
    {
    {
#line 194
    tmp___3 = strcmp((char const   *)*(argv + (argc - i)), "-f");
    }
    }
#line 194
    if (tmp___3 == 0) {
#line 196
      i --;
#line 196
      if (! i) {
        {
        {
#line 196
        usage();
        }
        }
      }
#line 197
      output_file_n = *(argv + (argc - i));
    } else {
      {
      {
#line 199
      tmp___2 = strcmp((char const   *)*(argv + (argc - i)), "-r");
      }
      }
#line 199
      if (tmp___2 == 0) {
#line 201
        write_wav_format = 0;
      } else {
        {
        {
#line 203
        tmp___1 = strcmp((char const   *)*(argv + (argc - i)), "-v");
        }
        }
#line 203
        if (tmp___1 == 0) {
#line 205
          verbose = 1;
        } else {
          {
          {
#line 207
          tmp___0 = strcmp((char const   *)*(argv + (argc - i)), "-t");
          }
          }
#line 207
          if (tmp___0 == 0) {
#line 209
            test_file_type = 1;
          } else {
            {
            {
#line 211
            tmp = strcmp((char const   *)*(argv + (argc - i)), "--");
            }
            }
#line 211
            if (tmp == 0) {
#line 214
              if (i != 2) {
                {
                {
#line 214
                usage();
                }
                }
              }
#line 215
              escaped = 1;
            } else {
              {
              {
#line 218
              usage();
              }
              }
            }
          }
        }
      }
    }
#line 192
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  if (i != 1) {
    {
    {
#line 221
    usage();
    }
    }
  }
#line 223
  input_file_n = *(argv + (argc - 1));
#line 229
  if (! escaped) {
#line 229
    if ((int )*(input_file_n + 0) == 45) {
#line 229
      if ((int )*(input_file_n + 1) != 0) {
        {
        {
#line 229
        usage();
        }
        }
      }
    }
  }
#line 231
  if (! input_file_n) {
    {
    {
#line 231
    usage();
    }
    }
  }
#line 233
  if (output_file_n) {
    {
    {
#line 235
    output_file = fopen((char const   */* __restrict  */)output_file_n, (char const   */* __restrict  */)"wb");
    }
    }
#line 236
    if (! output_file) {
      {
      {
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open output file \'%s\': ",
              output_file_n);
      }
      {
#line 239
      perror((char const   *)((void *)0));
      }
      {
#line 240
      exit(1);
      }
      }
    }
#line 242
    output_opened = 1;
  } else {
#line 246
    output_file = stdout;
  }
  {
  {
#line 249
  tmp___4 = strcmp((char const   *)input_file_n, "-");
  }
  }
#line 249
  if (tmp___4 == 0) {
#line 251
    input_file = stdin;
  } else {
    {
    {
#line 255
    input_file = fopen((char const   */* __restrict  */)input_file_n, (char const   */* __restrict  */)"rb");
    }
    }
#line 256
    if (! input_file) {
      {
      {
#line 258
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open input file \'%s\': ",
              input_file_n);
      }
      {
#line 259
      perror((char const   *)((void *)0));
      }
      {
#line 260
      exit(1);
      }
      }
    }
#line 262
    input_opened = 1;
  }
#line 264
  return;
}
}
#line 271 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
void set_endian(void) 
{ 
  uint32_t integer ;
  unsigned char *p ;

  {
#line 273
  integer = (uint32_t )170;
#line 274
  p = (unsigned char *)(& integer);
#line 276
  if ((int )*(p + 0) == 170) {
#line 276
    host_bigendian = 0;
  } else {
#line 277
    host_bigendian = 1;
  }
#line 278
  return;
}
}
#line 280 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
int main(int argc , char **argv ) 
{ 
  demux_res_t demux_res ;
  unsigned int output_size ;
  unsigned int i ;
  int tmp ;
  unsigned int thissample_duration ;
  unsigned int thissample_bytesize ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 285
  memset((void *)(& demux_res), 0, (size_t )sizeof(demux_res));
  }
  {
#line 287
  set_endian();
  }
  {
#line 289
  setup_environment(argc, argv);
  }
  {
#line 296
  input_stream = stream_create_file(input_file, 1);
  }
  }
#line 297
  if (! input_stream) {
    {
    {
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to create input stream from file\n");
    }
    }
#line 300
    return (1);
  }
  {
  {
#line 305
  tmp = qtmovie_read(input_stream, & demux_res);
  }
  }
#line 305
  if (! tmp) {
#line 307
    if (! test_file_type) {
#line 307
      goto _L;
    } else
#line 307
    if (! demux_res.format_read) {
      _L: /* CIL Label */ 
      {
      {
#line 309
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to load the QuickTime movie headers");
      }
      }
#line 310
      if (demux_res.format_read) {
        {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (file type: %c%c%c%c)\n",
                (int )((char )((int32_t )demux_res.format >> 24)), (int )((char )((int32_t )demux_res.format >> 16)),
                (int )((char )((int32_t )demux_res.format >> 8)), (int )((char )demux_res.format));
        }
        }
      } else {
        {
        {
#line 314
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
        }
      }
#line 315
      return (1);
    }
  }
#line 318
  if (test_file_type) {
#line 321
    if (! demux_res.format_read) {
      {
      {
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to load the QUickTime movie headers. Probably not a quicktime file\n");
      }
      }
#line 325
      return (1);
    }
    {
    {
#line 327
    printf((char const   */* __restrict  */)"file type: %c%c%c%c\n", (int )((char )((int32_t )demux_res.format >> 24)),
           (int )((char )((int32_t )demux_res.format >> 16)), (int )((char )((int32_t )demux_res.format >> 8)),
           (int )((char )demux_res.format));
    }
    }
    {
#line 331
    if (demux_res.format == (fourcc_t )((((97 << 24) | (108 << 16)) | (97 << 8)) | 99)) {
#line 331
      goto case_exp;
    }
#line 333
    if (demux_res.format == (fourcc_t )((((109 << 24) | (112 << 16)) | (52 << 8)) | 97)) {
#line 333
      goto case_exp___0;
    }
#line 329
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 332
    return (0);
    case_exp___0: /* CIL Label */ 
#line 334
    return (100);
    switch_break: /* CIL Label */ ;
    }
#line 336
    return (1);
  }
  {
  {
#line 340
  init_sound_converter(& demux_res);
  }
  }
#line 343
  if (write_wav_format) {
#line 346
    output_size = 0U;
#line 347
    i = 0U;
    {
    {
#line 347
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 347
      if (! (i < demux_res.num_sample_byte_sizes)) {
#line 347
        goto while_break;
      }
      {
#line 349
      thissample_duration = 0U;
#line 350
      thissample_bytesize = 0U;
      {
#line 352
      get_sample_info(& demux_res, i, & thissample_duration, & thissample_bytesize);
      }
#line 355
      output_size += (thissample_duration * (unsigned int )((int )demux_res.sample_size / 8)) * (unsigned int )demux_res.num_channels;
#line 347
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 358
    wavwriter_writeheaders(output_file, (int )output_size, (int )demux_res.num_channels,
                           (int )demux_res.sample_rate, (int )demux_res.sample_size);
    }
    }
  }
  {
  {
#line 366
  GetBuffer(& demux_res);
  }
  {
#line 368
  stream_destroy(input_stream);
  }
  }
#line 370
  if (output_opened) {
    {
    {
#line 371
    fclose(output_file);
    }
    }
  }
#line 373
  if (input_opened) {
    {
    {
#line 374
    fclose(input_file);
    }
    }
  }
#line 376
  return (0);
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 89 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static void allocate_buffers(alac_file *alac___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  {
#line 91
  tmp = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 91
  alac___0->predicterror_buffer_a = (int32_t *)tmp;
  {
#line 92
  tmp___0 = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 92
  alac___0->predicterror_buffer_b = (int32_t *)tmp___0;
  {
#line 94
  tmp___1 = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 94
  alac___0->outputsamples_buffer_a = (int32_t *)tmp___1;
  {
#line 95
  tmp___2 = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 95
  alac___0->outputsamples_buffer_b = (int32_t *)tmp___2;
  }
#line 96
  return;
}
}
#line 98 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
void alac_set_info(alac_file *alac___0 , char *inputbuffer ) 
{ 
  char *ptr ;

  {
#line 100
  ptr = inputbuffer;
#line 101
  ptr += 4;
#line 102
  ptr += 4;
#line 103
  ptr += 4;
#line 104
  ptr += 4;
#line 105
  ptr += 4;
#line 107
  ptr += 4;
#line 109
  alac___0->setinfo_max_samples_per_frame = *((uint32_t *)ptr);
#line 110
  if (! host_bigendian) {
    {
    {
#line 111
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 111
      alac___0->setinfo_max_samples_per_frame = ((((alac___0->setinfo_max_samples_per_frame & 255U) << 24) | ((alac___0->setinfo_max_samples_per_frame & 65280U) << 8)) | ((alac___0->setinfo_max_samples_per_frame & 16711680U) >> 8)) | ((alac___0->setinfo_max_samples_per_frame & 4278190080U) >> 24);
#line 111
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 112
  ptr += 4;
#line 113
  alac___0->setinfo_7a = *((uint8_t *)ptr);
#line 114
  ptr ++;
#line 115
  alac___0->setinfo_sample_size = *((uint8_t *)ptr);
#line 116
  ptr ++;
#line 117
  alac___0->setinfo_rice_historymult = *((uint8_t *)ptr);
#line 118
  ptr ++;
#line 119
  alac___0->setinfo_rice_initialhistory = *((uint8_t *)ptr);
#line 120
  ptr ++;
#line 121
  alac___0->setinfo_rice_kmodifier = *((uint8_t *)ptr);
#line 122
  ptr ++;
#line 123
  alac___0->setinfo_7f = *((uint8_t *)ptr);
#line 124
  ptr ++;
#line 125
  alac___0->setinfo_80 = *((uint16_t *)ptr);
#line 126
  if (! host_bigendian) {
    {
    {
#line 127
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 127
      alac___0->setinfo_80 = (uint16_t )((((int )alac___0->setinfo_80 & 255) << 8) | (((int )alac___0->setinfo_80 & 65280) >> 8));
#line 127
      goto while_break___0;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 128
  ptr += 2;
#line 129
  alac___0->setinfo_82 = *((uint32_t *)ptr);
#line 130
  if (! host_bigendian) {
    {
    {
#line 131
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 131
      alac___0->setinfo_82 = ((((alac___0->setinfo_82 & 255U) << 24) | ((alac___0->setinfo_82 & 65280U) << 8)) | ((alac___0->setinfo_82 & 16711680U) >> 8)) | ((alac___0->setinfo_82 & 4278190080U) >> 24);
#line 131
      goto while_break___1;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 132
  ptr += 4;
#line 133
  alac___0->setinfo_86 = *((uint32_t *)ptr);
#line 134
  if (! host_bigendian) {
    {
    {
#line 135
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 135
      alac___0->setinfo_86 = ((((alac___0->setinfo_86 & 255U) << 24) | ((alac___0->setinfo_86 & 65280U) << 8)) | ((alac___0->setinfo_86 & 16711680U) >> 8)) | ((alac___0->setinfo_86 & 4278190080U) >> 24);
#line 135
      goto while_break___2;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 136
  ptr += 4;
#line 137
  alac___0->setinfo_8a_rate = *((uint32_t *)ptr);
#line 138
  if (! host_bigendian) {
    {
    {
#line 139
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 139
      alac___0->setinfo_8a_rate = ((((alac___0->setinfo_8a_rate & 255U) << 24) | ((alac___0->setinfo_8a_rate & 65280U) << 8)) | ((alac___0->setinfo_8a_rate & 16711680U) >> 8)) | ((alac___0->setinfo_8a_rate & 4278190080U) >> 24);
#line 139
      goto while_break___3;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 140
  ptr += 4;
  {
#line 142
  allocate_buffers(alac___0);
  }
  }
#line 144
  return;
}
}
#line 149 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static uint32_t readbits_16(alac_file *alac___0 , int bits ) 
{ 
  uint32_t result ;
  int new_accumulator ;

  {
#line 154
  result = (uint32_t )((((int )*(alac___0->input_buffer + 0) << 16) | ((int )*(alac___0->input_buffer + 1) << 8)) | (int )*(alac___0->input_buffer + 2));
#line 161
  result <<= alac___0->input_buffer_bitaccumulator;
#line 163
  result &= 16777215U;
#line 167
  result >>= 24 - bits;
#line 169
  new_accumulator = alac___0->input_buffer_bitaccumulator + bits;
#line 172
  alac___0->input_buffer += new_accumulator >> 3;
#line 175
  alac___0->input_buffer_bitaccumulator = new_accumulator & 7;
#line 177
  return (result);
}
}
#line 181 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static uint32_t readbits(alac_file *alac___0 , int bits ) 
{ 
  int32_t result ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 183
  result = 0;
#line 185
  if (bits > 16) {
    {
#line 187
    bits -= 16;
    {
#line 188
    tmp = readbits_16(alac___0, 16);
    }
#line 188
    result = (int32_t )(tmp << bits);
    }
  }
  {
  {
#line 191
  tmp___0 = readbits_16(alac___0, bits);
  }
#line 191
  result = (int32_t )((unsigned int )result | tmp___0);
  }
#line 193
  return ((uint32_t )result);
}
}
#line 197 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static int readbit(alac_file *alac___0 ) 
{ 
  int result ;
  int new_accumulator ;

  {
#line 202
  result = (int )*(alac___0->input_buffer + 0);
#line 204
  result <<= alac___0->input_buffer_bitaccumulator;
#line 206
  result = (result >> 7) & 1;
#line 208
  new_accumulator = alac___0->input_buffer_bitaccumulator + 1;
#line 210
  alac___0->input_buffer += new_accumulator / 8;
#line 212
  alac___0->input_buffer_bitaccumulator = new_accumulator % 8;
#line 214
  return (result);
}
}
#line 217 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static void unreadbits(alac_file *alac___0 , int bits ) 
{ 
  int new_accumulator ;

  {
#line 219
  new_accumulator = alac___0->input_buffer_bitaccumulator - bits;
#line 221
  alac___0->input_buffer += new_accumulator >> 3;
#line 223
  alac___0->input_buffer_bitaccumulator = new_accumulator & 7;
#line 224
  if (alac___0->input_buffer_bitaccumulator < 0) {
#line 225
    alac___0->input_buffer_bitaccumulator *= -1;
  }
#line 226
  return;
}
}
#line 253 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static int count_leading_zeros(int input ) 
{ 
  int output ;

  {
#line 255
  output = 0;
#line 256
  if (! input) {
#line 256
    return (32);
  }
#line 257
  __asm__  ("bsr %1, %0\n": "=r" (output): "r" (input));
#line 260
  return (31 - output);
}
}
#line 324 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
void basterdised_rice_decompress(alac_file *alac___0 , int32_t *output_buffer , int output_size ,
                                 int readsamplesize , int rice_initialhistory , int rice_kmodifier ,
                                 int rice_historymult , int rice_kmodifier_mask ) 
{ 
  int output_count ;
  unsigned int history ;
  int sign_modifier ;
  int32_t x ;
  int32_t x_modified ;
  int32_t final_val ;
  int tmp ;
  int32_t value ;
  uint32_t tmp___0 ;
  int extrabits ;
  int k ;
  int tmp___1 ;
  uint32_t tmp___2 ;
  int block_size ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  int k___0 ;
  int extrabits___0 ;
  int tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 335
  history = (unsigned int )rice_initialhistory;
#line 336
  sign_modifier = 0;
#line 338
  output_count = 0;
  {
  {
#line 338
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 338
    if (! (output_count < output_size)) {
#line 338
      goto while_break;
    }
#line 340
    x = 0;
    {
    {
#line 345
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 345
      if (x <= 8) {
        {
        {
#line 345
        tmp = readbit(alac___0);
        }
        }
#line 345
        if (! tmp) {
#line 345
          goto while_break___0;
        }
      } else {
#line 345
        goto while_break___0;
      }
#line 347
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 351
    if (x > 8) {
      {
      {
#line 355
      tmp___0 = readbits(alac___0, readsamplesize);
      }
#line 355
      value = (int32_t )tmp___0;
      }
#line 358
      if (readsamplesize != 32) {
#line 359
        value = (int32_t )((unsigned int )value & (4294967295U >> (32 - readsamplesize)));
      }
#line 361
      x = value;
    } else {
      {
      {
#line 369
      tmp___1 = count_leading_zeros((int )((history >> 9) + 3U));
      }
#line 369
      k = (31 - rice_kmodifier) - tmp___1;
      }
#line 371
      if (k < 0) {
#line 371
        k += rice_kmodifier;
      } else {
#line 372
        k = rice_kmodifier;
      }
#line 374
      if (k != 1) {
        {
        {
#line 376
        tmp___2 = readbits(alac___0, k);
        }
#line 376
        extrabits = (int )tmp___2;
#line 379
        x = (x << k) - x;
        }
#line 381
        if (extrabits > 1) {
#line 383
          x += extrabits - 1;
        } else {
          {
          {
#line 385
          unreadbits(alac___0, 1);
          }
          }
        }
      }
    }
#line 389
    x_modified = sign_modifier + x;
#line 390
    final_val = (x_modified + 1) / 2;
#line 391
    if (x_modified & 1) {
#line 391
      final_val *= -1;
    }
#line 393
    *(output_buffer + output_count) = final_val;
#line 395
    sign_modifier = 0;
#line 398
    history += (unsigned int )(x_modified * rice_historymult) - (history * (unsigned int )rice_historymult >> 9);
#line 401
    if (x_modified > 65535) {
#line 402
      history = 65535U;
    }
#line 405
    if (history < 128U) {
#line 405
      if (output_count + 1 < output_size) {
#line 409
        sign_modifier = 1;
#line 411
        x = 0;
        {
        {
#line 412
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 412
          if (x <= 8) {
            {
            {
#line 412
            tmp___3 = readbit(alac___0);
            }
            }
#line 412
            if (! tmp___3) {
#line 412
              goto while_break___1;
            }
          } else {
#line 412
            goto while_break___1;
          }
#line 414
          x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 417
        if (x > 8) {
          {
          {
#line 419
          tmp___4 = readbits(alac___0, 16);
          }
#line 419
          block_size = (int )tmp___4;
#line 420
          block_size &= 65535;
          }
        } else {
          {
          {
#line 427
          tmp___5 = count_leading_zeros((int )history);
          }
#line 427
          k___0 = (int )(((unsigned int )tmp___5 + ((history + 16U) >> 6)) - 24U);
          {
#line 429
          tmp___6 = readbits(alac___0, k___0);
          }
#line 429
          extrabits___0 = (int )tmp___6;
#line 431
          block_size = ((((1 << k___0) - 1) & rice_kmodifier_mask) * x + extrabits___0) - 1;
          }
#line 434
          if (extrabits___0 < 2) {
            {
#line 436
            x = 1 - extrabits___0;
#line 437
            block_size += x;
            {
#line 438
            unreadbits(alac___0, 1);
            }
            }
          }
        }
#line 442
        if (block_size > 0) {
          {
          {
#line 444
          memset((void *)(output_buffer + (output_count + 1)), 0, (size_t )(block_size * 4));
          }
#line 445
          output_count += block_size;
          }
        }
#line 449
        if (block_size > 65535) {
#line 450
          sign_modifier = 0;
        }
#line 452
        history = 0U;
      }
    }
#line 338
    output_count ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  return;
}
}
#line 464 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static void predictor_decompress_fir_adapt(int32_t *error_buffer , int32_t *buffer_out ,
                                           int output_size , int readsamplesize ,
                                           int16_t *predictor_coef_table , int predictor_coef_num ,
                                           int predictor_quantitization ) 
{ 
  int i ;
  int32_t prev_value ;
  int32_t error_value ;
  int i___0 ;
  int32_t val ;
  int j ;
  int sum ;
  int outval ;
  int error_val ;
  int predictor_num ;
  int val___0 ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int predictor_num___0 ;
  int val___1 ;
  int sign___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 475
  *buffer_out = *error_buffer;
#line 477
  if (! predictor_coef_num) {
#line 479
    if (output_size <= 1) {
#line 479
      return;
    }
    {
    {
#line 480
    memcpy((void */* __restrict  */)(buffer_out + 1), (void const   */* __restrict  */)(error_buffer + 1),
           (size_t )((output_size - 1) * 4));
    }
    }
#line 481
    return;
  }
#line 484
  if (predictor_coef_num == 31) {
#line 488
    if (output_size <= 1) {
#line 488
      return;
    }
#line 489
    i = 0;
    {
    {
#line 489
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 489
      if (! (i < output_size - 1)) {
#line 489
        goto while_break;
      }
#line 494
      prev_value = *(buffer_out + i);
#line 495
      error_value = *(error_buffer + (i + 1));
#line 496
      *(buffer_out + (i + 1)) = ((prev_value + error_value) << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 489
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 498
    return;
  }
#line 502
  if (predictor_coef_num > 0) {
#line 505
    i___0 = 0;
    {
    {
#line 505
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 505
      if (! (i___0 < predictor_coef_num)) {
#line 505
        goto while_break___0;
      }
#line 509
      val = *(buffer_out + i___0) + *(error_buffer + (i___0 + 1));
#line 511
      val = (val << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 513
      *(buffer_out + (i___0 + 1)) = val;
#line 505
      i___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 536
  if (predictor_coef_num > 0) {
#line 538
    i = predictor_coef_num + 1;
    {
    {
#line 538
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 538
      if (! (i < output_size)) {
#line 538
        goto while_break___1;
      }
#line 543
      sum = 0;
#line 545
      error_val = *(error_buffer + i);
#line 547
      j = 0;
      {
      {
#line 547
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 547
        if (! (j < predictor_coef_num)) {
#line 547
          goto while_break___2;
        }
#line 549
        sum += (*(buffer_out + (predictor_coef_num - j)) - *(buffer_out + 0)) * (int32_t )*(predictor_coef_table + j);
#line 547
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 553
      outval = (1 << (predictor_quantitization - 1)) + sum;
#line 554
      outval >>= predictor_quantitization;
#line 555
      outval = (outval + *(buffer_out + 0)) + error_val;
#line 556
      outval = (outval << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 558
      *(buffer_out + (predictor_coef_num + 1)) = outval;
#line 560
      if (error_val > 0) {
#line 562
        predictor_num = predictor_coef_num - 1;
        {
        {
#line 564
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 564
          if (predictor_num >= 0) {
#line 564
            if (! (error_val > 0)) {
#line 564
              goto while_break___3;
            }
          } else {
#line 564
            goto while_break___3;
          }
#line 566
          val___0 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num));
#line 567
          if (val___0 < 0) {
#line 567
            tmp___0 = -1;
          } else {
#line 567
            if (val___0 > 0) {
#line 567
              tmp = 1;
            } else {
#line 567
              tmp = 0;
            }
#line 567
            tmp___0 = tmp;
          }
#line 567
          sign = tmp___0;
#line 569
          *(predictor_coef_table + predictor_num) = (int16_t )((int )*(predictor_coef_table + predictor_num) - sign);
#line 571
          val___0 *= sign;
#line 573
          error_val -= (val___0 >> predictor_quantitization) * (predictor_coef_num - predictor_num);
#line 576
          predictor_num --;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 579
      if (error_val < 0) {
#line 581
        predictor_num___0 = predictor_coef_num - 1;
        {
        {
#line 583
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 583
          if (predictor_num___0 >= 0) {
#line 583
            if (! (error_val < 0)) {
#line 583
              goto while_break___4;
            }
          } else {
#line 583
            goto while_break___4;
          }
#line 585
          val___1 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num___0));
#line 586
          if (val___1 < 0) {
#line 586
            tmp___2 = -1;
          } else {
#line 586
            if (val___1 > 0) {
#line 586
              tmp___1 = 1;
            } else {
#line 586
              tmp___1 = 0;
            }
#line 586
            tmp___2 = tmp___1;
          }
#line 586
          sign___0 = - tmp___2;
#line 588
          *(predictor_coef_table + predictor_num___0) = (int16_t )((int )*(predictor_coef_table + predictor_num___0) - sign___0);
#line 590
          val___1 *= sign___0;
#line 592
          error_val -= (val___1 >> predictor_quantitization) * (predictor_coef_num - predictor_num___0);
#line 595
          predictor_num___0 --;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 599
      buffer_out ++;
#line 538
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 602
  return;
}
}
#line 604 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
void deinterlace_16(int32_t *buffer_a , int32_t *buffer_b , int16_t *buffer_out ,
                    int numchannels , int numsamples , uint8_t interlacing_shift ,
                    uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int16_t left ;
  int16_t right ;
  int16_t left___0 ;
  int16_t right___0 ;

  {
#line 611
  if (numsamples <= 0) {
#line 611
    return;
  }
#line 614
  if (interlacing_leftweight) {
#line 616
    i = 0;
    {
    {
#line 616
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 616
      if (! (i < numsamples)) {
#line 616
        goto while_break;
      }
#line 622
      midright = *(buffer_a + i);
#line 623
      difference = *(buffer_b + i);
#line 626
      right = (int16_t )(midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift));
#line 627
      left = (int16_t )((int )right + difference);
#line 630
      if (host_bigendian) {
        {
        {
#line 632
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 632
          left = (int16_t )((((int )left & 255) << 8) | (((int )left & 65280) >> 8));
#line 632
          goto while_break___0;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 633
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 633
          right = (int16_t )((((int )right & 255) << 8) | (((int )right & 65280) >> 8));
#line 633
          goto while_break___1;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 636
      *(buffer_out + i * numchannels) = left;
#line 637
      *(buffer_out + (i * numchannels + 1)) = right;
#line 616
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 640
    return;
  }
#line 644
  i = 0;
  {
  {
#line 644
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 644
    if (! (i < numsamples)) {
#line 644
      goto while_break___2;
    }
#line 648
    left___0 = (int16_t )*(buffer_a + i);
#line 649
    right___0 = (int16_t )*(buffer_b + i);
#line 652
    if (host_bigendian) {
      {
      {
#line 654
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 654
        left___0 = (int16_t )((((int )left___0 & 255) << 8) | (((int )left___0 & 65280) >> 8));
#line 654
        goto while_break___3;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      {
#line 655
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 655
        right___0 = (int16_t )((((int )right___0 & 255) << 8) | (((int )right___0 & 65280) >> 8));
#line 655
        goto while_break___4;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 658
    *(buffer_out + i * numchannels) = left___0;
#line 659
    *(buffer_out + (i * numchannels + 1)) = right___0;
#line 644
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 661
  return;
}
}
#line 663 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
void decode_frame(alac_file *alac___0 , unsigned char *inbuffer , void *outbuffer ,
                  int *outputsize ) 
{ 
  int channels ;
  int32_t outputsamples ;
  uint32_t tmp ;
  int hassize ;
  int isnotcompressed ;
  int readsamplesize ;
  int wasted_bytes ;
  int ricemodifier ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int16_t predictor_coef_table[32] ;
  int predictor_coef_num ;
  int prediction_type ;
  int prediction_quantitization ;
  int i ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int i___0 ;
  int32_t audiobits ;
  uint32_t tmp___9 ;
  int i___1 ;
  int32_t audiobits___0 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  int i___2 ;
  int16_t sample ;
  int hassize___0 ;
  int isnotcompressed___0 ;
  int readsamplesize___0 ;
  int wasted_bytes___0 ;
  uint8_t interlacing_shift ;
  uint8_t interlacing_leftweight ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  int16_t predictor_coef_table_a[32] ;
  int predictor_coef_num_a ;
  int prediction_type_a ;
  int prediction_quantitization_a ;
  int ricemodifier_a ;
  int16_t predictor_coef_table_b[32] ;
  int predictor_coef_num_b ;
  int prediction_type_b ;
  int prediction_quantitization_b ;
  int ricemodifier_b ;
  int i___3 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  int i___4 ;
  int32_t audiobits_a ;
  int32_t audiobits_b ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  int i___5 ;
  int32_t audiobits_a___0 ;
  int32_t audiobits_b___0 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  uint32_t tmp___33 ;
  void *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;

  {
  {
#line 668
  outputsamples = (int32_t )alac___0->setinfo_max_samples_per_frame;
#line 671
  alac___0->input_buffer = inbuffer;
#line 672
  alac___0->input_buffer_bitaccumulator = 0;
  {
#line 674
  tmp = readbits(alac___0, 3);
  }
#line 674
  channels = (int )tmp;
#line 676
  *outputsize = outputsamples * alac___0->bytespersample;
  }
  {
#line 680
  if (channels == 0) {
#line 680
    goto case_0;
  }
#line 836
  if (channels == 1) {
#line 836
    goto case_1;
  }
#line 678
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 693
  readbits(alac___0, 4);
  }
  {
#line 695
  readbits(alac___0, 12);
  }
  {
#line 697
  tmp___0 = readbits(alac___0, 1);
  }
#line 697
  hassize = (int )tmp___0;
  {
#line 699
  tmp___1 = readbits(alac___0, 2);
  }
#line 699
  wasted_bytes = (int )tmp___1;
  {
#line 701
  tmp___2 = readbits(alac___0, 1);
  }
#line 701
  isnotcompressed = (int )tmp___2;
  }
#line 703
  if (hassize) {
    {
    {
#line 707
    tmp___3 = readbits(alac___0, 32);
    }
#line 707
    outputsamples = (int32_t )tmp___3;
#line 708
    *outputsize = outputsamples * alac___0->bytespersample;
    }
  }
#line 711
  readsamplesize = (int )alac___0->setinfo_sample_size - wasted_bytes * 8;
#line 713
  if (! isnotcompressed) {
    {
    {
#line 723
    readbits(alac___0, 8);
    }
    {
#line 724
    readbits(alac___0, 8);
    }
    {
#line 726
    tmp___4 = readbits(alac___0, 4);
    }
#line 726
    prediction_type = (int )tmp___4;
    {
#line 727
    tmp___5 = readbits(alac___0, 4);
    }
#line 727
    prediction_quantitization = (int )tmp___5;
    {
#line 729
    tmp___6 = readbits(alac___0, 3);
    }
#line 729
    ricemodifier = (int )tmp___6;
    {
#line 730
    tmp___7 = readbits(alac___0, 5);
    }
#line 730
    predictor_coef_num = (int )tmp___7;
#line 733
    i = 0;
    }
    {
    {
#line 733
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 733
      if (! (i < predictor_coef_num)) {
#line 733
        goto while_break;
      }
      {
      {
#line 735
      tmp___8 = readbits(alac___0, 16);
      }
#line 735
      predictor_coef_table[i] = (int16_t )tmp___8;
#line 733
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 738
    if (wasted_bytes) {
      {
      {
#line 743
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unimplemented, unhandling of wasted_bytes\n");
      }
      }
    }
    {
    {
#line 746
    basterdised_rice_decompress(alac___0, alac___0->predicterror_buffer_a, outputsamples,
                                readsamplesize, (int )alac___0->setinfo_rice_initialhistory,
                                (int )alac___0->setinfo_rice_kmodifier, (ricemodifier * (int )alac___0->setinfo_rice_historymult) / 4,
                                (1 << (int )alac___0->setinfo_rice_kmodifier) - 1);
    }
    }
#line 755
    if (prediction_type == 0) {
      {
      {
#line 757
      predictor_decompress_fir_adapt(alac___0->predicterror_buffer_a, alac___0->outputsamples_buffer_a,
                                     outputsamples, readsamplesize, predictor_coef_table,
                                     predictor_coef_num, prediction_quantitization);
      }
      }
    } else {
      {
      {
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unhandled predicition type: %i\n",
              prediction_type);
      }
      }
    }
  } else
#line 779
  if (readsamplesize <= 16) {
#line 782
    i___0 = 0;
    {
    {
#line 782
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 782
      if (! (i___0 < outputsamples)) {
#line 782
        goto while_break___0;
      }
      {
      {
#line 784
      tmp___9 = readbits(alac___0, readsamplesize);
      }
#line 784
      audiobits = (int32_t )tmp___9;
#line 786
      audiobits = (audiobits << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 788
      *(alac___0->outputsamples_buffer_a + i___0) = audiobits;
#line 782
      i___0 ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 794
    i___1 = 0;
    {
    {
#line 794
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 794
      if (! (i___1 < outputsamples)) {
#line 794
        goto while_break___1;
      }
      {
      {
#line 798
      tmp___10 = readbits(alac___0, 16);
      }
#line 798
      audiobits___0 = (int32_t )tmp___10;
#line 801
      audiobits___0 <<= 16;
#line 802
      audiobits___0 >>= 32 - readsamplesize;
      {
#line 804
      tmp___11 = readbits(alac___0, readsamplesize - 16);
      }
#line 804
      audiobits___0 = (int32_t )((unsigned int )audiobits___0 | tmp___11);
#line 806
      *(alac___0->outputsamples_buffer_a + i___1) = audiobits___0;
#line 794
      i___1 ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 814
  if ((int )alac___0->setinfo_sample_size == 16) {
#line 814
    goto case_16;
  }
#line 828
  if ((int )alac___0->setinfo_sample_size == 32) {
#line 828
    goto case_32;
  }
#line 828
  if ((int )alac___0->setinfo_sample_size == 24) {
#line 828
    goto case_32;
  }
#line 828
  if ((int )alac___0->setinfo_sample_size == 20) {
#line 828
    goto case_32;
  }
#line 831
  goto switch_default;
  case_16: /* CIL Label */ 
#line 817
  i___2 = 0;
  {
  {
#line 817
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 817
    if (! (i___2 < outputsamples)) {
#line 817
      goto while_break___2;
    }
#line 819
    sample = (int16_t )*(alac___0->outputsamples_buffer_a + i___2);
#line 820
    if (host_bigendian) {
      {
      {
#line 821
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 821
        sample = (int16_t )((((int )sample & 255) << 8) | (((int )sample & 65280) >> 8));
#line 821
        goto while_break___3;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 822
    *((int16_t *)outbuffer + i___2 * alac___0->numchannels) = sample;
#line 817
    i___2 ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 824
  goto switch_break___0;
  case_32: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_20: /* CIL Label */ 
  {
  {
#line 829
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unimplemented sample size %i\n",
          (int )alac___0->setinfo_sample_size);
  }
  }
#line 830
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 832
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 834
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 850
  readbits(alac___0, 4);
  }
  {
#line 852
  readbits(alac___0, 12);
  }
  {
#line 854
  tmp___12 = readbits(alac___0, 1);
  }
#line 854
  hassize___0 = (int )tmp___12;
  {
#line 856
  tmp___13 = readbits(alac___0, 2);
  }
#line 856
  wasted_bytes___0 = (int )tmp___13;
  {
#line 858
  tmp___14 = readbits(alac___0, 1);
  }
#line 858
  isnotcompressed___0 = (int )tmp___14;
  }
#line 860
  if (hassize___0) {
    {
    {
#line 864
    tmp___15 = readbits(alac___0, 32);
    }
#line 864
    outputsamples = (int32_t )tmp___15;
#line 865
    *outputsize = outputsamples * alac___0->bytespersample;
    }
  }
#line 868
  readsamplesize___0 = ((int )alac___0->setinfo_sample_size - wasted_bytes___0 * 8) + 1;
#line 870
  if (! isnotcompressed___0) {
    {
    {
#line 886
    tmp___16 = readbits(alac___0, 8);
    }
#line 886
    interlacing_shift = (uint8_t )tmp___16;
    {
#line 887
    tmp___17 = readbits(alac___0, 8);
    }
#line 887
    interlacing_leftweight = (uint8_t )tmp___17;
    {
#line 890
    tmp___18 = readbits(alac___0, 4);
    }
#line 890
    prediction_type_a = (int )tmp___18;
    {
#line 891
    tmp___19 = readbits(alac___0, 4);
    }
#line 891
    prediction_quantitization_a = (int )tmp___19;
    {
#line 893
    tmp___20 = readbits(alac___0, 3);
    }
#line 893
    ricemodifier_a = (int )tmp___20;
    {
#line 894
    tmp___21 = readbits(alac___0, 5);
    }
#line 894
    predictor_coef_num_a = (int )tmp___21;
#line 897
    i___3 = 0;
    }
    {
    {
#line 897
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 897
      if (! (i___3 < predictor_coef_num_a)) {
#line 897
        goto while_break___4;
      }
      {
      {
#line 899
      tmp___22 = readbits(alac___0, 16);
      }
#line 899
      predictor_coef_table_a[i___3] = (int16_t )tmp___22;
#line 897
      i___3 ++;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
    {
#line 903
    tmp___23 = readbits(alac___0, 4);
    }
#line 903
    prediction_type_b = (int )tmp___23;
    {
#line 904
    tmp___24 = readbits(alac___0, 4);
    }
#line 904
    prediction_quantitization_b = (int )tmp___24;
    {
#line 906
    tmp___25 = readbits(alac___0, 3);
    }
#line 906
    ricemodifier_b = (int )tmp___25;
    {
#line 907
    tmp___26 = readbits(alac___0, 5);
    }
#line 907
    predictor_coef_num_b = (int )tmp___26;
#line 910
    i___3 = 0;
    }
    {
    {
#line 910
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 910
      if (! (i___3 < predictor_coef_num_b)) {
#line 910
        goto while_break___5;
      }
      {
      {
#line 912
      tmp___27 = readbits(alac___0, 16);
      }
#line 912
      predictor_coef_table_b[i___3] = (int16_t )tmp___27;
#line 910
      i___3 ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 916
    if (wasted_bytes___0) {
      {
      {
#line 918
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unimplemented, unhandling of wasted_bytes\n");
      }
      }
    }
    {
    {
#line 922
    basterdised_rice_decompress(alac___0, alac___0->predicterror_buffer_a, outputsamples,
                                readsamplesize___0, (int )alac___0->setinfo_rice_initialhistory,
                                (int )alac___0->setinfo_rice_kmodifier, (ricemodifier_a * (int )alac___0->setinfo_rice_historymult) / 4,
                                (1 << (int )alac___0->setinfo_rice_kmodifier) - 1);
    }
    }
#line 931
    if (prediction_type_a == 0) {
      {
      {
#line 933
      predictor_decompress_fir_adapt(alac___0->predicterror_buffer_a, alac___0->outputsamples_buffer_a,
                                     outputsamples, readsamplesize___0, predictor_coef_table_a,
                                     predictor_coef_num_a, prediction_quantitization_a);
      }
      }
    } else {
      {
      {
#line 943
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unhandled predicition type: %i\n",
              prediction_type_a);
      }
      }
    }
    {
    {
#line 947
    basterdised_rice_decompress(alac___0, alac___0->predicterror_buffer_b, outputsamples,
                                readsamplesize___0, (int )alac___0->setinfo_rice_initialhistory,
                                (int )alac___0->setinfo_rice_kmodifier, (ricemodifier_b * (int )alac___0->setinfo_rice_historymult) / 4,
                                (1 << (int )alac___0->setinfo_rice_kmodifier) - 1);
    }
    }
#line 956
    if (prediction_type_b == 0) {
      {
      {
#line 958
      predictor_decompress_fir_adapt(alac___0->predicterror_buffer_b, alac___0->outputsamples_buffer_b,
                                     outputsamples, readsamplesize___0, predictor_coef_table_b,
                                     predictor_coef_num_b, prediction_quantitization_b);
      }
      }
    } else {
      {
      {
#line 968
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unhandled predicition type: %i\n",
              prediction_type_b);
      }
      }
    }
  } else {
#line 973
    if ((int )alac___0->setinfo_sample_size <= 16) {
#line 976
      i___4 = 0;
      {
      {
#line 976
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 976
        if (! (i___4 < outputsamples)) {
#line 976
          goto while_break___6;
        }
        {
        {
#line 980
        tmp___28 = readbits(alac___0, (int )alac___0->setinfo_sample_size);
        }
#line 980
        audiobits_a = (int32_t )tmp___28;
        {
#line 981
        tmp___29 = readbits(alac___0, (int )alac___0->setinfo_sample_size);
        }
#line 981
        audiobits_b = (int32_t )tmp___29;
#line 983
        audiobits_a = (audiobits_a << (32 - (int )alac___0->setinfo_sample_size)) >> (32 - (int )alac___0->setinfo_sample_size);
#line 984
        audiobits_b = (audiobits_b << (32 - (int )alac___0->setinfo_sample_size)) >> (32 - (int )alac___0->setinfo_sample_size);
#line 986
        *(alac___0->outputsamples_buffer_a + i___4) = audiobits_a;
#line 987
        *(alac___0->outputsamples_buffer_b + i___4) = audiobits_b;
#line 976
        i___4 ++;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 993
      i___5 = 0;
      {
      {
#line 993
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 993
        if (! (i___5 < outputsamples)) {
#line 993
          goto while_break___7;
        }
        {
        {
#line 997
        tmp___30 = readbits(alac___0, 16);
        }
#line 997
        audiobits_a___0 = (int32_t )tmp___30;
#line 998
        audiobits_a___0 <<= 16;
#line 999
        audiobits_a___0 >>= 32 - (int )alac___0->setinfo_sample_size;
        {
#line 1000
        tmp___31 = readbits(alac___0, (int )alac___0->setinfo_sample_size - 16);
        }
#line 1000
        audiobits_a___0 = (int32_t )((unsigned int )audiobits_a___0 | tmp___31);
        {
#line 1002
        tmp___32 = readbits(alac___0, 16);
        }
#line 1002
        audiobits_b___0 = (int32_t )tmp___32;
#line 1003
        audiobits_b___0 <<= 16;
#line 1004
        audiobits_b___0 >>= 32 - (int )alac___0->setinfo_sample_size;
        {
#line 1005
        tmp___33 = readbits(alac___0, (int )alac___0->setinfo_sample_size - 16);
        }
#line 1005
        audiobits_b___0 = (int32_t )((unsigned int )audiobits_b___0 | tmp___33);
#line 1007
        *(alac___0->outputsamples_buffer_a + i___5) = audiobits_a___0;
#line 1008
        *(alac___0->outputsamples_buffer_b + i___5) = audiobits_b___0;
#line 993
        i___5 ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 1012
    interlacing_shift = (uint8_t )0;
#line 1013
    interlacing_leftweight = (uint8_t )0;
  }
  {
#line 1018
  if ((int )alac___0->setinfo_sample_size == 16) {
#line 1018
    goto case_16___0;
  }
#line 1031
  if ((int )alac___0->setinfo_sample_size == 32) {
#line 1031
    goto case_32___0;
  }
#line 1031
  if ((int )alac___0->setinfo_sample_size == 24) {
#line 1031
    goto case_32___0;
  }
#line 1031
  if ((int )alac___0->setinfo_sample_size == 20) {
#line 1031
    goto case_32___0;
  }
#line 1034
  goto switch_default___0;
  case_16___0: /* CIL Label */ 
  {
  {
#line 1020
  deinterlace_16(alac___0->outputsamples_buffer_a, alac___0->outputsamples_buffer_b,
                 (int16_t *)outbuffer, alac___0->numchannels, outputsamples, interlacing_shift,
                 interlacing_leftweight);
  }
  }
#line 1027
  goto switch_break___1;
  case_32___0: /* CIL Label */ 
  case_24___0: /* CIL Label */ 
  case_20___0: /* CIL Label */ 
  {
  {
#line 1032
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"FIXME: unimplemented sample size %i\n",
          (int )alac___0->setinfo_sample_size);
  }
  }
#line 1033
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 1035
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1038
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1041
  return;
}
}
#line 1043 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
alac_file *create_alac(int samplesize , int numchannels ) 
{ 
  alac_file *newfile ;
  void *tmp ;

  {
  {
  {
#line 1045
  tmp = malloc((size_t )sizeof(alac_file ));
  }
#line 1045
  newfile = (alac_file *)tmp;
#line 1047
  newfile->samplesize = samplesize;
#line 1048
  newfile->numchannels = numchannels;
#line 1049
  newfile->bytespersample = (samplesize / 8) * numchannels;
  }
#line 1051
  return (newfile);
}
}
#line 13 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.h"
uint32_t stream_read_uint32(stream_t *stream ) ;
#line 16
uint16_t stream_read_uint16(stream_t *stream ) ;
#line 19
uint8_t stream_read_uint8(stream_t *stream ) ;
#line 21
void stream_skip(stream_t *stream , size_t skip ) ;
#line 23
int stream_eof(stream_t *stream ) ;
#line 25
long stream_tell(stream_t *stream ) ;
#line 26
int stream_setpos(stream_t *stream , long pos ) ;
#line 50 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_ftyp(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  fourcc_t type ;
  uint32_t minor_ver ;
  size_t size_remaining ;
  char *__cil_tmp6 ;

  {
  {
#line 54
  size_remaining = chunk_len - 8U;
  {
#line 56
  type = stream_read_uint32(qtmovie->stream);
  }
#line 57
  size_remaining -= 4U;
  }
#line 58
  if (type != (fourcc_t )((((77 << 24) | (52 << 16)) | (65 << 8)) | 32)) {
    {
    {
#line 60
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not M4A file\n");
    }
    }
#line 61
    return;
  }
  {
  {
#line 63
  minor_ver = stream_read_uint32(qtmovie->stream);
  }
#line 64
  size_remaining -= 4U;
  }
  {
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 67
    if (! size_remaining) {
#line 67
      goto while_break;
    }
    {
    {
#line 70
    stream_read_uint32(qtmovie->stream);
    }
#line 71
    size_remaining -= 4U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_tkhd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 78
  size_remaining = chunk_len - 8U;
  {
#line 80
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 81
  return;
}
}
#line 83 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_mdhd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 86
  size_remaining = chunk_len - 8U;
  {
#line 88
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_edts(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 94
  size_remaining = chunk_len - 8U;
  {
#line 96
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_elst(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 102
  size_remaining = chunk_len - 8U;
  {
#line 104
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 105
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_hdlr(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  fourcc_t comptype ;
  fourcc_t compsubtype ;
  size_t size_remaining ;
  int strlen___0 ;
  char str[256] ;
  unsigned int tmp ;
  uint8_t tmp___0 ;
  void *__cil_tmp10 ;

  {
#line 111
  size_remaining = chunk_len - 8U;
#line 114
  str[0] = (char)0;
#line 114
  tmp = 1U;
  {
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    if (tmp >= 256U) {
#line 114
      goto while_break;
    }
#line 114
    str[tmp] = (char)0;
#line 114
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 117
  stream_read_uint8(qtmovie->stream);
  }
#line 118
  size_remaining --;
  {
#line 120
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 121
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 122
  stream_read_uint8(qtmovie->stream);
  }
#line 123
  size_remaining -= 3U;
  {
#line 126
  comptype = stream_read_uint32(qtmovie->stream);
  }
  {
#line 127
  compsubtype = stream_read_uint32(qtmovie->stream);
  }
#line 128
  size_remaining -= 8U;
  {
#line 131
  stream_read_uint32(qtmovie->stream);
  }
#line 132
  size_remaining -= 4U;
  {
#line 135
  stream_read_uint32(qtmovie->stream);
  }
  {
#line 136
  stream_read_uint32(qtmovie->stream);
  }
#line 137
  size_remaining -= 8U;
  {
#line 140
  tmp___0 = stream_read_uint8(qtmovie->stream);
  }
#line 140
  strlen___0 = (int )tmp___0;
  {
#line 141
  stream_read(qtmovie->stream, (size_t )strlen___0, (void *)(str));
  }
#line 142
  size_remaining -= (size_t )(1 + strlen___0);
  }
#line 144
  if (size_remaining) {
    {
    {
#line 146
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 149
  return;
}
}
#line 151 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_stsd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  uint32_t entry_size ;
  uint16_t version ;
  uint32_t entry_remaining ;
  uint16_t tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 155
  size_remaining = chunk_len - 8U;
  {
#line 158
  stream_read_uint8(qtmovie->stream);
  }
#line 159
  size_remaining --;
  {
#line 161
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 162
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 163
  stream_read_uint8(qtmovie->stream);
  }
#line 164
  size_remaining -= 3U;
  {
#line 166
  numentries = stream_read_uint32(qtmovie->stream);
  }
#line 167
  size_remaining -= 4U;
  }
#line 169
  if (numentries != 1U) {
    {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"only expecting one entry in sample description atom!\n");
    }
    }
#line 172
    return (0);
  }
#line 175
  i = 0U;
  {
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < numentries)) {
#line 175
      goto while_break;
    }
    {
    {
#line 182
    entry_size = stream_read_uint32(qtmovie->stream);
    }
    {
#line 183
    (qtmovie->res)->format = stream_read_uint32(qtmovie->stream);
    }
#line 184
    entry_remaining = entry_size;
#line 185
    entry_remaining -= 8U;
    {
#line 189
    stream_skip(qtmovie->stream, (size_t )6);
    }
#line 190
    entry_remaining -= 6U;
    {
#line 192
    version = stream_read_uint16(qtmovie->stream);
    }
    }
#line 193
    if ((int )version != 1) {
      {
      {
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown version??\n");
      }
      }
    }
    {
#line 195
    entry_remaining -= 2U;
    {
#line 198
    stream_read_uint16(qtmovie->stream);
    }
    {
#line 200
    stream_read_uint32(qtmovie->stream);
    }
#line 201
    entry_remaining -= 6U;
    {
#line 204
    stream_read_uint16(qtmovie->stream);
    }
#line 205
    entry_remaining -= 2U;
    {
#line 207
    (qtmovie->res)->num_channels = stream_read_uint16(qtmovie->stream);
    }
    {
#line 209
    (qtmovie->res)->sample_size = stream_read_uint16(qtmovie->stream);
    }
#line 210
    entry_remaining -= 4U;
    {
#line 213
    stream_read_uint16(qtmovie->stream);
    }
    {
#line 215
    stream_read_uint16(qtmovie->stream);
    }
#line 216
    entry_remaining -= 4U;
    {
#line 219
    tmp = stream_read_uint16(qtmovie->stream);
    }
#line 219
    (qtmovie->res)->sample_rate = (uint32_t )tmp;
#line 220
    entry_remaining -= 2U;
    {
#line 223
    stream_skip(qtmovie->stream, (size_t )2);
    }
#line 224
    entry_remaining -= 2U;
#line 246
    (qtmovie->res)->codecdata_len = (entry_remaining + 12U) + 8U;
    {
#line 247
    (qtmovie->res)->codecdata = malloc((qtmovie->res)->codecdata_len);
    }
    {
#line 248
    memset((qtmovie->res)->codecdata, 0, (qtmovie->res)->codecdata_len);
    }
#line 250
    *((unsigned int *)(qtmovie->res)->codecdata + 0) = 201326592U;
#line 251
    *((unsigned int *)(qtmovie->res)->codecdata + 1) = (unsigned int )((((97 << 24) | (109 << 16)) | (114 << 8)) | 102);
#line 252
    *((unsigned int *)(qtmovie->res)->codecdata + 2) = (unsigned int )((((99 << 24) | (97 << 16)) | (108 << 8)) | 97);
    {
#line 254
    stream_read(qtmovie->stream, entry_remaining, (void *)((char *)(qtmovie->res)->codecdata + 12));
    }
#line 257
    entry_remaining -= entry_remaining;
    }
#line 260
    if (entry_remaining) {
      {
      {
#line 261
      stream_skip(qtmovie->stream, entry_remaining);
      }
      }
    }
#line 263
    (qtmovie->res)->format_read = 1;
#line 264
    if ((qtmovie->res)->format != (fourcc_t )((((97 << 24) | (108 << 16)) | (97 << 8)) | 99)) {
#line 268
      return (0);
    }
#line 175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return (1);
}
}
#line 275 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_stts(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 279
  size_remaining = chunk_len - 8U;
  {
#line 282
  stream_read_uint8(qtmovie->stream);
  }
#line 283
  size_remaining --;
  {
#line 285
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 286
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 287
  stream_read_uint8(qtmovie->stream);
  }
#line 288
  size_remaining -= 3U;
  {
#line 290
  numentries = stream_read_uint32(qtmovie->stream);
  }
#line 291
  size_remaining -= 4U;
#line 293
  (qtmovie->res)->num_time_to_samples = numentries;
  {
#line 294
  tmp = malloc((size_t )((unsigned long )numentries * sizeof(*((qtmovie->res)->time_to_sample))));
  }
#line 294
  (qtmovie->res)->time_to_sample = (struct __anonstruct_time_to_sample_25 *)tmp;
#line 296
  i = 0U;
  }
  {
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < numentries)) {
#line 296
      goto while_break;
    }
    {
    {
#line 298
    ((qtmovie->res)->time_to_sample + i)->sample_count = stream_read_uint32(qtmovie->stream);
    }
    {
#line 299
    ((qtmovie->res)->time_to_sample + i)->sample_duration = stream_read_uint32(qtmovie->stream);
    }
#line 300
    size_remaining -= 8U;
#line 296
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (size_remaining) {
    {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ehm, size remianing?\n");
    }
    {
#line 306
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_stsz(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  uint32_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 314
  size_remaining = chunk_len - 8U;
  {
#line 317
  stream_read_uint8(qtmovie->stream);
  }
#line 318
  size_remaining --;
  {
#line 320
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 321
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 322
  stream_read_uint8(qtmovie->stream);
  }
#line 323
  size_remaining -= 3U;
  {
#line 326
  tmp = stream_read_uint32(qtmovie->stream);
  }
  }
#line 326
  if (tmp != 0U) {
    {
    {
#line 328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"i was expecting variable samples sizes\n");
    }
    {
#line 329
    stream_read_uint32(qtmovie->stream);
    }
#line 330
    size_remaining -= 4U;
    }
#line 331
    return;
  }
  {
#line 333
  size_remaining -= 4U;
  {
#line 335
  numentries = stream_read_uint32(qtmovie->stream);
  }
#line 336
  size_remaining -= 4U;
#line 338
  (qtmovie->res)->num_sample_byte_sizes = numentries;
  {
#line 339
  tmp___0 = malloc((size_t )((unsigned long )numentries * sizeof(*((qtmovie->res)->sample_byte_size))));
  }
#line 339
  (qtmovie->res)->sample_byte_size = (uint32_t *)tmp___0;
#line 341
  i = 0U;
  }
  {
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < numentries)) {
#line 341
      goto while_break;
    }
    {
    {
#line 343
    *((qtmovie->res)->sample_byte_size + i) = stream_read_uint32(qtmovie->stream);
    }
#line 344
    size_remaining -= 4U;
#line 341
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if (size_remaining) {
    {
    {
#line 349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ehm, size remianing?\n");
    }
    {
#line 350
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 352
  return;
}
}
#line 354 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_stbl(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 356
  size_remaining = chunk_len - 8U;
  {
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 358
    if (! size_remaining) {
#line 358
      goto while_break;
    }
    {
    {
#line 363
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 364
    if (sub_chunk_len <= 1U) {
      {
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside stbl (%lu) (remaining: %lu)\n",
              sub_chunk_len, size_remaining);
      }
      }
#line 368
      return (0);
    } else
#line 364
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside stbl (%lu) (remaining: %lu)\n",
              sub_chunk_len, size_remaining);
      }
      }
#line 368
      return (0);
    }
    {
    {
#line 371
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 375
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 100)) {
#line 375
      goto case_exp;
    }
#line 379
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (116 << 8)) | 115)) {
#line 379
      goto case_exp___0;
    }
#line 382
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 122)) {
#line 382
      goto case_exp___1;
    }
#line 386
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (99 << 8)) | 111)) {
#line 386
      goto case_exp___2;
    }
#line 386
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 99)) {
#line 386
      goto case_exp___2;
    }
#line 390
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 376
    tmp = read_chunk_stsd(qtmovie, sub_chunk_len);
    }
    }
#line 376
    if (tmp == 0) {
#line 377
      return (0);
    }
#line 378
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 380
    read_chunk_stts(qtmovie, sub_chunk_len);
    }
    }
#line 381
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 383
    read_chunk_stsz(qtmovie, sub_chunk_len);
    }
    }
#line 384
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
    {
    {
#line 388
    stream_skip(qtmovie->stream, sub_chunk_len - 8U);
    }
    }
#line 389
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(stbl) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 393
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 396
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return (1);
}
}
#line 402 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_minf(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t dinf_size ;
  size_t stbl_size ;
  size_t size_remaining ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 405
  size_remaining = chunk_len - 8U;
  {
#line 408
  tmp = stream_read_uint32(qtmovie->stream);
  }
  }
#line 408
  if (tmp != 16U) {
    {
    {
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected size in media info\n");
    }
    }
#line 411
    return (0);
  }
  {
  {
#line 413
  tmp___0 = stream_read_uint32(qtmovie->stream);
  }
  }
#line 413
  if (tmp___0 != (uint32_t )((((115 << 24) | (109 << 16)) | (104 << 8)) | 100)) {
    {
    {
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a sound header! can\'t handle this.\n");
    }
    }
#line 416
    return (0);
  }
  {
  {
#line 419
  stream_skip(qtmovie->stream, (size_t )8);
  }
#line 420
  size_remaining -= 16U;
  {
#line 424
  dinf_size = stream_read_uint32(qtmovie->stream);
  }
  {
#line 425
  tmp___1 = stream_read_uint32(qtmovie->stream);
  }
  }
#line 425
  if (tmp___1 != (uint32_t )((((100 << 24) | (105 << 16)) | (110 << 8)) | 102)) {
    {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected dinf, didn\'t get it.\n");
    }
    }
#line 428
    return (0);
  }
  {
  {
#line 431
  stream_skip(qtmovie->stream, dinf_size - 8U);
  }
#line 432
  size_remaining -= dinf_size;
  {
#line 437
  stbl_size = stream_read_uint32(qtmovie->stream);
  }
  {
#line 438
  tmp___2 = stream_read_uint32(qtmovie->stream);
  }
  }
#line 438
  if (tmp___2 != (uint32_t )((((115 << 24) | (116 << 16)) | (98 << 8)) | 108)) {
    {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected stbl, didn\'t get it.\n");
    }
    }
#line 441
    return (0);
  }
  {
  {
#line 443
  tmp___3 = read_chunk_stbl(qtmovie, stbl_size);
  }
  }
#line 443
  if (tmp___3 == 0) {
#line 444
    return (0);
  }
#line 445
  size_remaining -= stbl_size;
#line 447
  if (size_remaining) {
    {
    {
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oops\n");
    }
    {
#line 450
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 453
  return (1);
}
}
#line 456 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_mdia(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 458
  size_remaining = chunk_len - 8U;
  {
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 460
    if (! size_remaining) {
#line 460
      goto while_break;
    }
    {
    {
#line 465
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 466
    if (sub_chunk_len <= 1U) {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside mdia\n");
      }
      }
#line 469
      return (0);
    } else
#line 466
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside mdia\n");
      }
      }
#line 469
      return (0);
    }
    {
    {
#line 472
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 476
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (104 << 8)) | 100)) {
#line 476
      goto case_exp;
    }
#line 479
    if (sub_chunk_id == (fourcc_t )((((104 << 24) | (100 << 16)) | (108 << 8)) | 114)) {
#line 479
      goto case_exp___0;
    }
#line 482
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (105 << 16)) | (110 << 8)) | 102)) {
#line 482
      goto case_exp___1;
    }
#line 486
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 477
    read_chunk_mdhd(qtmovie, sub_chunk_len);
    }
    }
#line 478
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 480
    read_chunk_hdlr(qtmovie, sub_chunk_len);
    }
    }
#line 481
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 483
    tmp = read_chunk_minf(qtmovie, sub_chunk_len);
    }
    }
#line 483
    if (tmp == 0) {
#line 484
      return (0);
    }
#line 485
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(mdia) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 489
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 492
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return (1);
}
}
#line 499 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_trak(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 501
  size_remaining = chunk_len - 8U;
  {
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 503
    if (! size_remaining) {
#line 503
      goto while_break;
    }
    {
    {
#line 508
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 509
    if (sub_chunk_len <= 1U) {
      {
      {
#line 511
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside trak\n");
      }
      }
#line 512
      return (0);
    } else
#line 509
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 511
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside trak\n");
      }
      }
#line 512
      return (0);
    }
    {
    {
#line 515
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 519
    if (sub_chunk_id == (fourcc_t )((((116 << 24) | (107 << 16)) | (104 << 8)) | 100)) {
#line 519
      goto case_exp;
    }
#line 522
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (105 << 8)) | 97)) {
#line 522
      goto case_exp___0;
    }
#line 526
    if (sub_chunk_id == (fourcc_t )((((101 << 24) | (100 << 16)) | (116 << 8)) | 115)) {
#line 526
      goto case_exp___1;
    }
#line 529
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 520
    read_chunk_tkhd(qtmovie, sub_chunk_len);
    }
    }
#line 521
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 523
    tmp = read_chunk_mdia(qtmovie, sub_chunk_len);
    }
    }
#line 523
    if (tmp == 0) {
#line 524
      return (0);
    }
#line 525
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 527
    read_chunk_edts(qtmovie, sub_chunk_len);
    }
    }
#line 528
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(trak) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 532
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 535
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  return (1);
}
}
#line 542 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_mvhd(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 545
  size_remaining = chunk_len - 8U;
  {
#line 547
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 548
  return;
}
}
#line 551 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_udta(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 554
  size_remaining = chunk_len - 8U;
  {
#line 556
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 557
  return;
}
}
#line 560 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_iods(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 563
  size_remaining = chunk_len - 8U;
  {
#line 565
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 566
  return;
}
}
#line 569 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_moov(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 571
  size_remaining = chunk_len - 8U;
  {
  {
#line 573
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 573
    if (! size_remaining) {
#line 573
      goto while_break;
    }
    {
    {
#line 578
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 579
    if (sub_chunk_len <= 1U) {
      {
      {
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside moov\n");
      }
      }
#line 582
      return (0);
    } else
#line 579
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside moov\n");
      }
      }
#line 582
      return (0);
    }
    {
    {
#line 585
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 589
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (118 << 16)) | (104 << 8)) | 100)) {
#line 589
      goto case_exp;
    }
#line 592
    if (sub_chunk_id == (fourcc_t )((((116 << 24) | (114 << 16)) | (97 << 8)) | 107)) {
#line 592
      goto case_exp___0;
    }
#line 596
    if (sub_chunk_id == (fourcc_t )((((117 << 24) | (100 << 16)) | (116 << 8)) | 97)) {
#line 596
      goto case_exp___1;
    }
#line 599
    if (sub_chunk_id == (fourcc_t )((((101 << 24) | (108 << 16)) | (115 << 8)) | 116)) {
#line 599
      goto case_exp___2;
    }
#line 602
    if (sub_chunk_id == (fourcc_t )((((105 << 24) | (111 << 16)) | (100 << 8)) | 115)) {
#line 602
      goto case_exp___3;
    }
#line 605
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 590
    read_chunk_mvhd(qtmovie, sub_chunk_len);
    }
    }
#line 591
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 593
    tmp = read_chunk_trak(qtmovie, sub_chunk_len);
    }
    }
#line 593
    if (tmp == 0) {
#line 594
      return (0);
    }
#line 595
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 597
    read_chunk_udta(qtmovie, sub_chunk_len);
    }
    }
#line 598
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
    {
#line 600
    read_chunk_elst(qtmovie, sub_chunk_len);
    }
    }
#line 601
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
    {
#line 603
    read_chunk_iods(qtmovie, sub_chunk_len);
    }
    }
#line 604
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 606
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(moov) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 608
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 611
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return (1);
}
}
#line 617 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_mdat(qtmovie_t *qtmovie , size_t chunk_len , int skip_mdat ) 
{ 
  size_t size_remaining ;

  {
#line 619
  size_remaining = chunk_len - 8U;
#line 621
  if (size_remaining == 0U) {
#line 621
    return;
  }
#line 623
  (qtmovie->res)->mdat_len = size_remaining;
#line 624
  if (skip_mdat) {
    {
    {
#line 626
    qtmovie->saved_mdat_pos = stream_tell(qtmovie->stream);
    }
    {
#line 627
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 634
  return;
}
}
#line 636 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int set_saved_mdat(qtmovie_t *qtmovie ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 638
  if (qtmovie->saved_mdat_pos == -1L) {
    {
    {
#line 640
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stream contains mdat before moov but is not seekable\n");
    }
    }
#line 641
    return (0);
  }
  {
  {
#line 644
  tmp = stream_setpos(qtmovie->stream, qtmovie->saved_mdat_pos);
  }
  }
#line 644
  if (tmp) {
    {
    {
#line 646
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error while seeking stream to mdat pos\n");
    }
    }
#line 647
    return (0);
  }
#line 650
  return (1);
}
}
#line 653 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
int qtmovie_read(stream_t *file , demux_res_t *demux_res ) 
{ 
  int found_moov ;
  int found_mdat ;
  qtmovie_t *qtmovie ;
  void *tmp ;
  size_t chunk_len ;
  fourcc_t chunk_id ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 655
  found_moov = 0;
#line 656
  found_mdat = 0;
  {
#line 659
  tmp = malloc((size_t )sizeof(qtmovie_t ));
  }
#line 659
  qtmovie = (qtmovie_t *)tmp;
#line 662
  qtmovie->stream = file;
#line 664
  qtmovie->res = demux_res;
  {
#line 666
  memset((void *)demux_res, 0, (size_t )sizeof(demux_res_t ));
  }
  }
  {
  {
#line 669
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 674
    chunk_len = stream_read_uint32(qtmovie->stream);
    }
    {
#line 675
    tmp___0 = stream_eof(qtmovie->stream);
    }
    }
#line 675
    if (tmp___0) {
#line 677
      return (0);
    }
#line 680
    if (chunk_len == 1U) {
      {
      {
#line 682
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"need 64bit support\n");
      }
      }
#line 683
      return (0);
    }
    {
    {
#line 685
    chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 689
    if (chunk_id == (fourcc_t )((((102 << 24) | (116 << 16)) | (121 << 8)) | 112)) {
#line 689
      goto case_exp;
    }
#line 692
    if (chunk_id == (fourcc_t )((((109 << 24) | (111 << 16)) | (111 << 8)) | 118)) {
#line 692
      goto case_exp___0;
    }
#line 705
    if (chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (97 << 8)) | 116)) {
#line 705
      goto case_exp___1;
    }
#line 713
    if (chunk_id == (fourcc_t )((((102 << 24) | (114 << 16)) | (101 << 8)) | 101)) {
#line 713
      goto case_exp___2;
    }
#line 716
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 690
    read_chunk_ftyp(qtmovie, chunk_len);
    }
    }
#line 691
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 693
    tmp___1 = read_chunk_moov(qtmovie, chunk_len);
    }
    }
#line 693
    if (tmp___1 == 0) {
#line 694
      return (0);
    }
#line 695
    if (found_mdat) {
      {
      {
#line 697
      tmp___2 = set_saved_mdat(qtmovie);
      }
      }
#line 697
      return (tmp___2);
    }
#line 699
    found_moov = 1;
#line 700
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 706
    read_chunk_mdat(qtmovie, chunk_len, ! found_moov);
    }
    }
#line 707
    if (found_moov) {
#line 708
      return (1);
    }
#line 709
    found_mdat = 1;
#line 710
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
    {
#line 714
    stream_skip(qtmovie->stream, chunk_len - 8U);
    }
    }
#line 715
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 717
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(top) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )chunk_id >> 24)), (int )((char )((int32_t )chunk_id >> 16)),
            (int )((char )((int32_t )chunk_id >> 8)), (int )((char )chunk_id));
    }
    }
#line 719
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  return (0);
}
}
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 12 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.h"
int32_t stream_read_int32(stream_t *stream ) ;
#line 15
int16_t stream_read_int16(stream_t *stream ) ;
#line 18
int8_t stream_read_int8(stream_t *stream ) ;
#line 58 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
void stream_read(stream_t *stream , size_t size , void *buf ) 
{ 
  size_t ret ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
  {
#line 62
  tmp = fread((void */* __restrict  */)buf, (size_t )4, size >> 2, (FILE */* __restrict  */)stream->f);
  }
#line 62
  ret = tmp * 4U;
  {
#line 63
  tmp___0 = fread((void */* __restrict  */)((char *)buf + ret), (size_t )1, size - ret,
                  (FILE */* __restrict  */)stream->f);
  }
#line 63
  ret += tmp___0;
  }
#line 65
  if (ret == 0U) {
#line 65
    if (size != 0U) {
#line 65
      stream->eof = 1;
    }
  }
#line 66
  return;
}
}
#line 68 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
int32_t stream_read_int32(stream_t *stream ) 
{ 
  int32_t v ;

  {
  {
  {
#line 71
  stream_read(stream, (size_t )4, (void *)(& v));
  }
  }
#line 72
  if (stream->bigendian) {
#line 72
    if (! host_bigendian) {
#line 72
      goto _L;
    } else {
#line 72
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 72
  if (! stream->bigendian) {
#line 72
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
      {
#line 75
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 75
        v = (int32_t )((unsigned int )((((v & 255) << 24) | ((v & 65280) << 8)) | ((v & 16711680) >> 8)) | (((unsigned int )v & 4278190080U) >> 24));
#line 75
        goto while_break;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 77
  return (v);
}
}
#line 80 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
uint32_t stream_read_uint32(stream_t *stream ) 
{ 
  uint32_t v ;

  {
  {
  {
#line 83
  stream_read(stream, (size_t )4, (void *)(& v));
  }
  }
#line 84
  if (stream->bigendian) {
#line 84
    if (! host_bigendian) {
#line 84
      goto _L;
    } else {
#line 84
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 84
  if (! stream->bigendian) {
#line 84
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
      {
#line 87
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 87
        v = ((((v & 255U) << 24) | ((v & 65280U) << 8)) | ((v & 16711680U) >> 8)) | ((v & 4278190080U) >> 24);
#line 87
        goto while_break;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 89
  return (v);
}
}
#line 92 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
int16_t stream_read_int16(stream_t *stream ) 
{ 
  int16_t v ;

  {
  {
  {
#line 95
  stream_read(stream, (size_t )2, (void *)(& v));
  }
  }
#line 96
  if (stream->bigendian) {
#line 96
    if (! host_bigendian) {
#line 96
      goto _L;
    } else {
#line 96
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 96
  if (! stream->bigendian) {
#line 96
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
      {
#line 99
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 99
        v = (int16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 99
        goto while_break;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 101
  return (v);
}
}
#line 104 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
uint16_t stream_read_uint16(stream_t *stream ) 
{ 
  uint16_t v ;

  {
  {
  {
#line 107
  stream_read(stream, (size_t )2, (void *)(& v));
  }
  }
#line 108
  if (stream->bigendian) {
#line 108
    if (! host_bigendian) {
#line 108
      goto _L;
    } else {
#line 108
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 108
  if (! stream->bigendian) {
#line 108
    if (host_bigendian) {
      _L: /* CIL Label */ 
      {
      {
#line 111
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 111
        v = (uint16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 111
        goto while_break;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 113
  return (v);
}
}
#line 116 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
int8_t stream_read_int8(stream_t *stream ) 
{ 
  int8_t v ;

  {
  {
  {
#line 119
  stream_read(stream, (size_t )1, (void *)(& v));
  }
  }
#line 120
  return (v);
}
}
#line 123 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
uint8_t stream_read_uint8(stream_t *stream ) 
{ 
  uint8_t v ;

  {
  {
  {
#line 126
  stream_read(stream, (size_t )1, (void *)(& v));
  }
  }
#line 127
  return (v);
}
}
#line 131 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
void stream_skip(stream_t *stream , size_t skip ) 
{ 
  int tmp ;
  char *buffer ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
  {
#line 133
  tmp = fseek(stream->f, (long )skip, 1);
  }
  }
#line 133
  if (tmp == 0) {
#line 133
    return;
  }
  {
  {
#line 134
  tmp___1 = __errno_location();
  }
  }
#line 134
  if (*tmp___1 == 29) {
    {
    {
#line 136
    tmp___0 = malloc(skip);
    }
#line 136
    buffer = (char *)tmp___0;
    {
#line 137
    stream_read(stream, skip, (void *)buffer);
    }
    {
#line 138
    free((void *)buffer);
    }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
int stream_eof(stream_t *stream ) 
{ 


  {
#line 144
  return (stream->eof);
}
}
#line 147 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
long stream_tell(stream_t *stream ) 
{ 
  long tmp ;

  {
  {
  {
#line 149
  tmp = ftell(stream->f);
  }
  }
#line 149
  return (tmp);
}
}
#line 152 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
int stream_setpos(stream_t *stream , long pos ) 
{ 
  int tmp ;

  {
  {
  {
#line 154
  tmp = fseek(stream->f, pos, 0);
  }
  }
#line 154
  return (tmp);
}
}
#line 157 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
stream_t *stream_create_file(FILE *file , int bigendian ) 
{ 
  stream_t *new_stream ;
  void *tmp ;

  {
  {
  {
#line 162
  tmp = malloc((size_t )sizeof(stream_t ));
  }
#line 162
  new_stream = (stream_t *)tmp;
#line 163
  new_stream->f = file;
#line 164
  new_stream->bigendian = bigendian;
#line 165
  new_stream->eof = 0;
  }
#line 167
  return (new_stream);
}
}
#line 170 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/stream.c"
void stream_destroy(stream_t *stream ) 
{ 


  {
  {
  {
#line 172
  free((void *)stream);
  }
  }
#line 173
  return;
}
}
#line 50 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_ftyp___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  fourcc_t type ;
  uint32_t minor_ver ;
  size_t size_remaining ;
  char *__cil_tmp6 ;

  {
  {
#line 54
  size_remaining = chunk_len - 8U;
  {
#line 56
  type = stream_read_uint32(qtmovie->stream);
  }
#line 57
  size_remaining -= 4U;
  }
#line 58
  if (type != (fourcc_t )((((77 << 24) | (52 << 16)) | (65 << 8)) | 32)) {
    {
    {
#line 60
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not M4A file\n");
    }
    }
#line 61
    return;
  }
  {
  {
#line 63
  minor_ver = stream_read_uint32(qtmovie->stream);
  }
#line 64
  size_remaining -= 4U;
  }
  {
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 67
    if (! size_remaining) {
#line 67
      goto while_break;
    }
    {
    {
#line 70
    stream_read_uint32(qtmovie->stream);
    }
#line 71
    size_remaining -= 4U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_tkhd___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 78
  size_remaining = chunk_len - 8U;
  {
#line 80
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 81
  return;
}
}
#line 83 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_mdhd___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 86
  size_remaining = chunk_len - 8U;
  {
#line 88
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_edts___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 94
  size_remaining = chunk_len - 8U;
  {
#line 96
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_elst___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 102
  size_remaining = chunk_len - 8U;
  {
#line 104
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 105
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_hdlr___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  fourcc_t comptype ;
  fourcc_t compsubtype ;
  size_t size_remaining ;
  int strlen___0 ;
  char str[256] ;
  unsigned int tmp ;
  uint8_t tmp___0 ;
  void *__cil_tmp10 ;

  {
#line 111
  size_remaining = chunk_len - 8U;
#line 114
  str[0] = (char)0;
#line 114
  tmp = 1U;
  {
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    if (tmp >= 256U) {
#line 114
      goto while_break;
    }
#line 114
    str[tmp] = (char)0;
#line 114
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 117
  stream_read_uint8(qtmovie->stream);
  }
#line 118
  size_remaining --;
  {
#line 120
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 121
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 122
  stream_read_uint8(qtmovie->stream);
  }
#line 123
  size_remaining -= 3U;
  {
#line 126
  comptype = stream_read_uint32(qtmovie->stream);
  }
  {
#line 127
  compsubtype = stream_read_uint32(qtmovie->stream);
  }
#line 128
  size_remaining -= 8U;
  {
#line 131
  stream_read_uint32(qtmovie->stream);
  }
#line 132
  size_remaining -= 4U;
  {
#line 135
  stream_read_uint32(qtmovie->stream);
  }
  {
#line 136
  stream_read_uint32(qtmovie->stream);
  }
#line 137
  size_remaining -= 8U;
  {
#line 140
  tmp___0 = stream_read_uint8(qtmovie->stream);
  }
#line 140
  strlen___0 = (int )tmp___0;
  {
#line 141
  stream_read(qtmovie->stream, (size_t )strlen___0, (void *)(str));
  }
#line 142
  size_remaining -= (size_t )(1 + strlen___0);
  }
#line 144
  if (size_remaining) {
    {
    {
#line 146
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 149
  return;
}
}
#line 151 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_stsd___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  uint32_t entry_size ;
  uint16_t version ;
  uint32_t entry_remaining ;
  uint16_t tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 155
  size_remaining = chunk_len - 8U;
  {
#line 158
  stream_read_uint8(qtmovie->stream);
  }
#line 159
  size_remaining --;
  {
#line 161
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 162
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 163
  stream_read_uint8(qtmovie->stream);
  }
#line 164
  size_remaining -= 3U;
  {
#line 166
  numentries = stream_read_uint32(qtmovie->stream);
  }
#line 167
  size_remaining -= 4U;
  }
#line 169
  if (numentries != 1U) {
    {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"only expecting one entry in sample description atom!\n");
    }
    }
#line 172
    return (0);
  }
#line 175
  i = 0U;
  {
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < numentries)) {
#line 175
      goto while_break;
    }
    {
    {
#line 182
    entry_size = stream_read_uint32(qtmovie->stream);
    }
    {
#line 183
    (qtmovie->res)->format = stream_read_uint32(qtmovie->stream);
    }
#line 184
    entry_remaining = entry_size;
#line 185
    entry_remaining -= 8U;
    {
#line 189
    stream_skip(qtmovie->stream, (size_t )6);
    }
#line 190
    entry_remaining -= 6U;
    {
#line 192
    version = stream_read_uint16(qtmovie->stream);
    }
    }
#line 193
    if ((int )version != 1) {
      {
      {
#line 194
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown version??\n");
      }
      }
    }
    {
#line 195
    entry_remaining -= 2U;
    {
#line 198
    stream_read_uint16(qtmovie->stream);
    }
    {
#line 200
    stream_read_uint32(qtmovie->stream);
    }
#line 201
    entry_remaining -= 6U;
    {
#line 204
    stream_read_uint16(qtmovie->stream);
    }
#line 205
    entry_remaining -= 2U;
    {
#line 207
    (qtmovie->res)->num_channels = stream_read_uint16(qtmovie->stream);
    }
    {
#line 209
    (qtmovie->res)->sample_size = stream_read_uint16(qtmovie->stream);
    }
#line 210
    entry_remaining -= 4U;
    {
#line 213
    stream_read_uint16(qtmovie->stream);
    }
    {
#line 215
    stream_read_uint16(qtmovie->stream);
    }
#line 216
    entry_remaining -= 4U;
    {
#line 219
    tmp = stream_read_uint16(qtmovie->stream);
    }
#line 219
    (qtmovie->res)->sample_rate = (uint32_t )tmp;
#line 220
    entry_remaining -= 2U;
    {
#line 223
    stream_skip(qtmovie->stream, (size_t )2);
    }
#line 224
    entry_remaining -= 2U;
#line 246
    (qtmovie->res)->codecdata_len = (entry_remaining + 12U) + 8U;
    {
#line 247
    (qtmovie->res)->codecdata = malloc((qtmovie->res)->codecdata_len);
    }
    {
#line 248
    memset((qtmovie->res)->codecdata, 0, (qtmovie->res)->codecdata_len);
    }
#line 250
    *((unsigned int *)(qtmovie->res)->codecdata + 0) = 201326592U;
#line 251
    *((unsigned int *)(qtmovie->res)->codecdata + 1) = (unsigned int )((((97 << 24) | (109 << 16)) | (114 << 8)) | 102);
#line 252
    *((unsigned int *)(qtmovie->res)->codecdata + 2) = (unsigned int )((((99 << 24) | (97 << 16)) | (108 << 8)) | 97);
    {
#line 254
    stream_read(qtmovie->stream, entry_remaining, (void *)((char *)(qtmovie->res)->codecdata + 12));
    }
#line 257
    entry_remaining -= entry_remaining;
    }
#line 260
    if (entry_remaining) {
      {
      {
#line 261
      stream_skip(qtmovie->stream, entry_remaining);
      }
      }
    }
#line 263
    (qtmovie->res)->format_read = 1;
#line 264
    if ((qtmovie->res)->format != (fourcc_t )((((97 << 24) | (108 << 16)) | (97 << 8)) | 99)) {
#line 268
      return (0);
    }
#line 175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return (1);
}
}
#line 275 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_stts___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 279
  size_remaining = chunk_len - 8U;
  {
#line 282
  stream_read_uint8(qtmovie->stream);
  }
#line 283
  size_remaining --;
  {
#line 285
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 286
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 287
  stream_read_uint8(qtmovie->stream);
  }
#line 288
  size_remaining -= 3U;
  {
#line 290
  numentries = stream_read_uint32(qtmovie->stream);
  }
#line 291
  size_remaining -= 4U;
#line 293
  (qtmovie->res)->num_time_to_samples = numentries;
  {
#line 294
  tmp = malloc((size_t )((unsigned long )numentries * sizeof(*((qtmovie->res)->time_to_sample))));
  }
#line 294
  (qtmovie->res)->time_to_sample = (struct __anonstruct_time_to_sample_25 *)tmp;
#line 296
  i = 0U;
  }
  {
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < numentries)) {
#line 296
      goto while_break;
    }
    {
    {
#line 298
    ((qtmovie->res)->time_to_sample + i)->sample_count = stream_read_uint32(qtmovie->stream);
    }
    {
#line 299
    ((qtmovie->res)->time_to_sample + i)->sample_duration = stream_read_uint32(qtmovie->stream);
    }
#line 300
    size_remaining -= 8U;
#line 296
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (size_remaining) {
    {
    {
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ehm, size remianing?\n");
    }
    {
#line 306
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_stsz___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  unsigned int i ;
  uint32_t numentries ;
  size_t size_remaining ;
  uint32_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 314
  size_remaining = chunk_len - 8U;
  {
#line 317
  stream_read_uint8(qtmovie->stream);
  }
#line 318
  size_remaining --;
  {
#line 320
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 321
  stream_read_uint8(qtmovie->stream);
  }
  {
#line 322
  stream_read_uint8(qtmovie->stream);
  }
#line 323
  size_remaining -= 3U;
  {
#line 326
  tmp = stream_read_uint32(qtmovie->stream);
  }
  }
#line 326
  if (tmp != 0U) {
    {
    {
#line 328
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"i was expecting variable samples sizes\n");
    }
    {
#line 329
    stream_read_uint32(qtmovie->stream);
    }
#line 330
    size_remaining -= 4U;
    }
#line 331
    return;
  }
  {
#line 333
  size_remaining -= 4U;
  {
#line 335
  numentries = stream_read_uint32(qtmovie->stream);
  }
#line 336
  size_remaining -= 4U;
#line 338
  (qtmovie->res)->num_sample_byte_sizes = numentries;
  {
#line 339
  tmp___0 = malloc((size_t )((unsigned long )numentries * sizeof(*((qtmovie->res)->sample_byte_size))));
  }
#line 339
  (qtmovie->res)->sample_byte_size = (uint32_t *)tmp___0;
#line 341
  i = 0U;
  }
  {
  {
#line 341
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < numentries)) {
#line 341
      goto while_break;
    }
    {
    {
#line 343
    *((qtmovie->res)->sample_byte_size + i) = stream_read_uint32(qtmovie->stream);
    }
#line 344
    size_remaining -= 4U;
#line 341
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  if (size_remaining) {
    {
    {
#line 349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ehm, size remianing?\n");
    }
    {
#line 350
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 352
  return;
}
}
#line 354 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_stbl___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 356
  size_remaining = chunk_len - 8U;
  {
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 358
    if (! size_remaining) {
#line 358
      goto while_break;
    }
    {
    {
#line 363
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 364
    if (sub_chunk_len <= 1U) {
      {
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside stbl (%lu) (remaining: %lu)\n",
              sub_chunk_len, size_remaining);
      }
      }
#line 368
      return (0);
    } else
#line 364
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside stbl (%lu) (remaining: %lu)\n",
              sub_chunk_len, size_remaining);
      }
      }
#line 368
      return (0);
    }
    {
    {
#line 371
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 375
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 100)) {
#line 375
      goto case_exp;
    }
#line 379
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (116 << 8)) | 115)) {
#line 379
      goto case_exp___0;
    }
#line 382
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 122)) {
#line 382
      goto case_exp___1;
    }
#line 386
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (99 << 8)) | 111)) {
#line 386
      goto case_exp___2;
    }
#line 386
    if (sub_chunk_id == (fourcc_t )((((115 << 24) | (116 << 16)) | (115 << 8)) | 99)) {
#line 386
      goto case_exp___2;
    }
#line 390
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 376
    tmp = read_chunk_stsd___0(qtmovie, sub_chunk_len);
    }
    }
#line 376
    if (tmp == 0) {
#line 377
      return (0);
    }
#line 378
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 380
    read_chunk_stts___0(qtmovie, sub_chunk_len);
    }
    }
#line 381
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 383
    read_chunk_stsz___0(qtmovie, sub_chunk_len);
    }
    }
#line 384
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
    {
    {
#line 388
    stream_skip(qtmovie->stream, sub_chunk_len - 8U);
    }
    }
#line 389
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(stbl) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 393
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 396
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return (1);
}
}
#line 402 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_minf___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t dinf_size ;
  size_t stbl_size ;
  size_t size_remaining ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 405
  size_remaining = chunk_len - 8U;
  {
#line 408
  tmp = stream_read_uint32(qtmovie->stream);
  }
  }
#line 408
  if (tmp != 16U) {
    {
    {
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected size in media info\n");
    }
    }
#line 411
    return (0);
  }
  {
  {
#line 413
  tmp___0 = stream_read_uint32(qtmovie->stream);
  }
  }
#line 413
  if (tmp___0 != (uint32_t )((((115 << 24) | (109 << 16)) | (104 << 8)) | 100)) {
    {
    {
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not a sound header! can\'t handle this.\n");
    }
    }
#line 416
    return (0);
  }
  {
  {
#line 419
  stream_skip(qtmovie->stream, (size_t )8);
  }
#line 420
  size_remaining -= 16U;
  {
#line 424
  dinf_size = stream_read_uint32(qtmovie->stream);
  }
  {
#line 425
  tmp___1 = stream_read_uint32(qtmovie->stream);
  }
  }
#line 425
  if (tmp___1 != (uint32_t )((((100 << 24) | (105 << 16)) | (110 << 8)) | 102)) {
    {
    {
#line 427
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected dinf, didn\'t get it.\n");
    }
    }
#line 428
    return (0);
  }
  {
  {
#line 431
  stream_skip(qtmovie->stream, dinf_size - 8U);
  }
#line 432
  size_remaining -= dinf_size;
  {
#line 437
  stbl_size = stream_read_uint32(qtmovie->stream);
  }
  {
#line 438
  tmp___2 = stream_read_uint32(qtmovie->stream);
  }
  }
#line 438
  if (tmp___2 != (uint32_t )((((115 << 24) | (116 << 16)) | (98 << 8)) | 108)) {
    {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected stbl, didn\'t get it.\n");
    }
    }
#line 441
    return (0);
  }
  {
  {
#line 443
  tmp___3 = read_chunk_stbl___0(qtmovie, stbl_size);
  }
  }
#line 443
  if (tmp___3 == 0) {
#line 444
    return (0);
  }
#line 445
  size_remaining -= stbl_size;
#line 447
  if (size_remaining) {
    {
    {
#line 449
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oops\n");
    }
    {
#line 450
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 453
  return (1);
}
}
#line 456 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_mdia___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 458
  size_remaining = chunk_len - 8U;
  {
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 460
    if (! size_remaining) {
#line 460
      goto while_break;
    }
    {
    {
#line 465
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 466
    if (sub_chunk_len <= 1U) {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside mdia\n");
      }
      }
#line 469
      return (0);
    } else
#line 466
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside mdia\n");
      }
      }
#line 469
      return (0);
    }
    {
    {
#line 472
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 476
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (104 << 8)) | 100)) {
#line 476
      goto case_exp;
    }
#line 479
    if (sub_chunk_id == (fourcc_t )((((104 << 24) | (100 << 16)) | (108 << 8)) | 114)) {
#line 479
      goto case_exp___0;
    }
#line 482
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (105 << 16)) | (110 << 8)) | 102)) {
#line 482
      goto case_exp___1;
    }
#line 486
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 477
    read_chunk_mdhd___0(qtmovie, sub_chunk_len);
    }
    }
#line 478
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 480
    read_chunk_hdlr___0(qtmovie, sub_chunk_len);
    }
    }
#line 481
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 483
    tmp = read_chunk_minf___0(qtmovie, sub_chunk_len);
    }
    }
#line 483
    if (tmp == 0) {
#line 484
      return (0);
    }
#line 485
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(mdia) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 489
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 492
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return (1);
}
}
#line 499 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_trak___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 501
  size_remaining = chunk_len - 8U;
  {
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 503
    if (! size_remaining) {
#line 503
      goto while_break;
    }
    {
    {
#line 508
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 509
    if (sub_chunk_len <= 1U) {
      {
      {
#line 511
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside trak\n");
      }
      }
#line 512
      return (0);
    } else
#line 509
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 511
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside trak\n");
      }
      }
#line 512
      return (0);
    }
    {
    {
#line 515
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 519
    if (sub_chunk_id == (fourcc_t )((((116 << 24) | (107 << 16)) | (104 << 8)) | 100)) {
#line 519
      goto case_exp;
    }
#line 522
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (100 << 16)) | (105 << 8)) | 97)) {
#line 522
      goto case_exp___0;
    }
#line 526
    if (sub_chunk_id == (fourcc_t )((((101 << 24) | (100 << 16)) | (116 << 8)) | 115)) {
#line 526
      goto case_exp___1;
    }
#line 529
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 520
    read_chunk_tkhd___0(qtmovie, sub_chunk_len);
    }
    }
#line 521
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 523
    tmp = read_chunk_mdia___0(qtmovie, sub_chunk_len);
    }
    }
#line 523
    if (tmp == 0) {
#line 524
      return (0);
    }
#line 525
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 527
    read_chunk_edts___0(qtmovie, sub_chunk_len);
    }
    }
#line 528
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 530
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(trak) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 532
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 535
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  return (1);
}
}
#line 542 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_mvhd___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 545
  size_remaining = chunk_len - 8U;
  {
#line 547
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 548
  return;
}
}
#line 551 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_udta___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 554
  size_remaining = chunk_len - 8U;
  {
#line 556
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 557
  return;
}
}
#line 560 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_iods___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;

  {
  {
#line 563
  size_remaining = chunk_len - 8U;
  {
#line 565
  stream_skip(qtmovie->stream, size_remaining);
  }
  }
#line 566
  return;
}
}
#line 569 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int read_chunk_moov___0(qtmovie_t *qtmovie , size_t chunk_len ) 
{ 
  size_t size_remaining ;
  size_t sub_chunk_len ;
  fourcc_t sub_chunk_id ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 571
  size_remaining = chunk_len - 8U;
  {
  {
#line 573
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 573
    if (! size_remaining) {
#line 573
      goto while_break;
    }
    {
    {
#line 578
    sub_chunk_len = stream_read_uint32(qtmovie->stream);
    }
    }
#line 579
    if (sub_chunk_len <= 1U) {
      {
      {
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside moov\n");
      }
      }
#line 582
      return (0);
    } else
#line 579
    if (sub_chunk_len > size_remaining) {
      {
      {
#line 581
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"strange size for chunk inside moov\n");
      }
      }
#line 582
      return (0);
    }
    {
    {
#line 585
    sub_chunk_id = stream_read_uint32(qtmovie->stream);
    }
    }
    {
#line 589
    if (sub_chunk_id == (fourcc_t )((((109 << 24) | (118 << 16)) | (104 << 8)) | 100)) {
#line 589
      goto case_exp;
    }
#line 592
    if (sub_chunk_id == (fourcc_t )((((116 << 24) | (114 << 16)) | (97 << 8)) | 107)) {
#line 592
      goto case_exp___0;
    }
#line 596
    if (sub_chunk_id == (fourcc_t )((((117 << 24) | (100 << 16)) | (116 << 8)) | 97)) {
#line 596
      goto case_exp___1;
    }
#line 599
    if (sub_chunk_id == (fourcc_t )((((101 << 24) | (108 << 16)) | (115 << 8)) | 116)) {
#line 599
      goto case_exp___2;
    }
#line 602
    if (sub_chunk_id == (fourcc_t )((((105 << 24) | (111 << 16)) | (100 << 8)) | 115)) {
#line 602
      goto case_exp___3;
    }
#line 605
    goto switch_default;
    case_exp: /* CIL Label */ 
    {
    {
#line 590
    read_chunk_mvhd___0(qtmovie, sub_chunk_len);
    }
    }
#line 591
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
    {
#line 593
    tmp = read_chunk_trak___0(qtmovie, sub_chunk_len);
    }
    }
#line 593
    if (tmp == 0) {
#line 594
      return (0);
    }
#line 595
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
    {
#line 597
    read_chunk_udta___0(qtmovie, sub_chunk_len);
    }
    }
#line 598
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
    {
#line 600
    read_chunk_elst___0(qtmovie, sub_chunk_len);
    }
    }
#line 601
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
    {
#line 603
    read_chunk_iods___0(qtmovie, sub_chunk_len);
    }
    }
#line 604
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 606
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(moov) unknown chunk id: %c%c%c%c\n",
            (int )((char )((int32_t )sub_chunk_id >> 24)), (int )((char )((int32_t )sub_chunk_id >> 16)),
            (int )((char )((int32_t )sub_chunk_id >> 8)), (int )((char )sub_chunk_id));
    }
    }
#line 608
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 611
    size_remaining -= sub_chunk_len;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return (1);
}
}
#line 617 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static void read_chunk_mdat___0(qtmovie_t *qtmovie , size_t chunk_len , int skip_mdat ) 
{ 
  size_t size_remaining ;

  {
#line 619
  size_remaining = chunk_len - 8U;
#line 621
  if (size_remaining == 0U) {
#line 621
    return;
  }
#line 623
  (qtmovie->res)->mdat_len = size_remaining;
#line 624
  if (skip_mdat) {
    {
    {
#line 626
    qtmovie->saved_mdat_pos = stream_tell(qtmovie->stream);
    }
    {
#line 627
    stream_skip(qtmovie->stream, size_remaining);
    }
    }
  }
#line 634
  return;
}
}
#line 636 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/demux.c"
static int set_saved_mdat___0(qtmovie_t *qtmovie ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 638
  if (qtmovie->saved_mdat_pos == -1L) {
    {
    {
#line 640
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stream contains mdat before moov but is not seekable\n");
    }
    }
#line 641
    return (0);
  }
  {
  {
#line 644
  tmp = stream_setpos(qtmovie->stream, qtmovie->saved_mdat_pos);
  }
  }
#line 644
  if (tmp) {
    {
    {
#line 646
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error while seeking stream to mdat pos\n");
    }
    }
#line 647
    return (0);
  }
#line 650
  return (1);
}
}
#line 51 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static FILE *input_file___0  =    (FILE *)((void *)0);
#line 52 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int input_opened___0  =    0;
#line 53 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static stream_t *input_stream___0  ;
#line 55 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static FILE *output_file___0  =    (FILE *)((void *)0);
#line 56 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int output_opened___0  =    0;
#line 58 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int write_wav_format___0  =    1;
#line 59 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int verbose___0  =    0;
#line 60 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int test_file_type___0  =    0;
#line 62 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static int get_sample_info___0(demux_res_t *demux_res , uint32_t samplenum , uint32_t *sample_duration ,
                               uint32_t *sample_byte_size ) 
{ 
  unsigned int duration_index_accum ;
  unsigned int duration_cur_index ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 66
  duration_index_accum = 0U;
#line 67
  duration_cur_index = 0U;
#line 69
  if (samplenum >= demux_res->num_sample_byte_sizes) {
    {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample %i does not exist\n",
            samplenum);
    }
    }
#line 72
    return (0);
  }
#line 75
  if (! demux_res->num_time_to_samples) {
    {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no time to samples\n");
    }
    }
#line 78
    return (0);
  }
  {
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 80
    if (! ((demux_res->time_to_sample + duration_cur_index)->sample_count + duration_index_accum <= samplenum)) {
#line 80
      goto while_break;
    }
#line 83
    duration_index_accum += (demux_res->time_to_sample + duration_cur_index)->sample_count;
#line 84
    duration_cur_index ++;
#line 85
    if (duration_cur_index >= demux_res->num_time_to_samples) {
      {
      {
#line 87
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample %i does not have a duration\n",
              samplenum);
      }
      }
#line 88
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  *sample_duration = (demux_res->time_to_sample + duration_cur_index)->sample_duration;
#line 93
  *sample_byte_size = *(demux_res->sample_byte_size + samplenum);
#line 95
  return (1);
}
}
#line 98 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void GetBuffer___0(demux_res_t *demux_res ) 
{ 
  unsigned long destBufferSize ;
  void *pDestBuffer ;
  void *tmp ;
  int bytes_read ;
  unsigned int buffer_size ;
  void *buffer ;
  unsigned int i ;
  uint32_t sample_duration ;
  uint32_t sample_byte_size ;
  int outputBytes ;
  int tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 100
  destBufferSize = 16384UL;
  {
#line 101
  tmp = malloc((size_t )destBufferSize);
  }
#line 101
  pDestBuffer = tmp;
#line 102
  bytes_read = 0;
#line 104
  buffer_size = 65536U;
  {
#line 109
  buffer = malloc(buffer_size);
  }
#line 111
  i = 0U;
  }
  {
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < demux_res->num_sample_byte_sizes)) {
#line 111
      goto while_break;
    }
    {
    {
#line 119
    tmp___0 = get_sample_info___0(demux_res, i, & sample_duration, & sample_byte_size);
    }
    }
#line 119
    if (! tmp___0) {
      {
      {
#line 122
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sample failed\n");
      }
      }
#line 123
      return;
    }
#line 126
    if (buffer_size < sample_byte_size) {
      {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sorry buffer too small! (is %i want %i)\n",
              buffer_size, sample_byte_size);
      }
      }
#line 131
      return;
    }
    {
    {
#line 134
    stream_read(input_stream___0, sample_byte_size, buffer);
    }
#line 138
    outputBytes = (int )destBufferSize;
    {
#line 139
    decode_frame(alac, (unsigned char *)buffer, pDestBuffer, & outputBytes);
    }
#line 142
    bytes_read += outputBytes;
    }
#line 144
    if (verbose___0) {
      {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read %i bytes. total: %i\n",
              outputBytes, bytes_read);
      }
      }
    }
    {
    {
#line 147
    fwrite((void const   */* __restrict  */)pDestBuffer, (size_t )outputBytes, (size_t )1,
           (FILE */* __restrict  */)output_file___0);
    }
#line 111
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (verbose___0) {
    {
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done reading, read %i frames\n",
            i);
    }
    }
  }
#line 151
  return;
}
}
#line 153 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void init_sound_converter___0(demux_res_t *demux_res ) 
{ 


  {
  {
  {
#line 155
  alac = create_alac((int )demux_res->sample_size, (int )demux_res->num_channels);
  }
  {
#line 157
  alac_set_info(alac, (char *)demux_res->codecdata);
  }
  }
#line 158
  return;
}
}
#line 160 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void usage___0(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 162
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: alac [options] [--] file\nDecompresses the ALAC file specified\n\nOptions:\n  -f output.wav     outputs the decompressed data to the\n                    specified file, in WAV format. Default\n                    is stdout.\n  -r                write output as raw PCM data. Default\n                    is in WAV format.\n  -v                verbose output.\n  -t                test that file is ALAC, also tests for\n                    other m4a file types.\n\nThis software is Copyright (c) 2005 David Hammerton\nAll rights reserved\nhttp://crazney.net/\n");
  }
  {
#line 178
  exit(1);
  }
  }
}
}
#line 181 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/main.c"
static void setup_environment___0(int argc , char **argv ) 
{ 
  int i ;
  char *input_file_n ;
  char *output_file_n ;
  int escaped ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 183
  i = argc;
#line 185
  input_file_n = (char *)((void *)0);
#line 186
  output_file_n = (char *)((void *)0);
#line 188
  escaped = 0;
#line 190
  if (argc < 2) {
    {
    {
#line 190
    usage___0();
    }
    }
  }
#line 192
  i = argc - 1;
  {
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i > 1)) {
#line 192
      goto while_break;
    }
    {
    {
#line 194
    tmp___3 = strcmp((char const   *)*(argv + (argc - i)), "-f");
    }
    }
#line 194
    if (tmp___3 == 0) {
#line 196
      i --;
#line 196
      if (! i) {
        {
        {
#line 196
        usage___0();
        }
        }
      }
#line 197
      output_file_n = *(argv + (argc - i));
    } else {
      {
      {
#line 199
      tmp___2 = strcmp((char const   *)*(argv + (argc - i)), "-r");
      }
      }
#line 199
      if (tmp___2 == 0) {
#line 201
        write_wav_format___0 = 0;
      } else {
        {
        {
#line 203
        tmp___1 = strcmp((char const   *)*(argv + (argc - i)), "-v");
        }
        }
#line 203
        if (tmp___1 == 0) {
#line 205
          verbose___0 = 1;
        } else {
          {
          {
#line 207
          tmp___0 = strcmp((char const   *)*(argv + (argc - i)), "-t");
          }
          }
#line 207
          if (tmp___0 == 0) {
#line 209
            test_file_type___0 = 1;
          } else {
            {
            {
#line 211
            tmp = strcmp((char const   *)*(argv + (argc - i)), "--");
            }
            }
#line 211
            if (tmp == 0) {
#line 214
              if (i != 2) {
                {
                {
#line 214
                usage___0();
                }
                }
              }
#line 215
              escaped = 1;
            } else {
              {
              {
#line 218
              usage___0();
              }
              }
            }
          }
        }
      }
    }
#line 192
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  if (i != 1) {
    {
    {
#line 221
    usage___0();
    }
    }
  }
#line 223
  input_file_n = *(argv + (argc - 1));
#line 229
  if (! escaped) {
#line 229
    if ((int )*(input_file_n + 0) == 45) {
#line 229
      if ((int )*(input_file_n + 1) != 0) {
        {
        {
#line 229
        usage___0();
        }
        }
      }
    }
  }
#line 231
  if (! input_file_n) {
    {
    {
#line 231
    usage___0();
    }
    }
  }
#line 233
  if (output_file_n) {
    {
    {
#line 235
    output_file___0 = fopen((char const   */* __restrict  */)output_file_n, (char const   */* __restrict  */)"wb");
    }
    }
#line 236
    if (! output_file___0) {
      {
      {
#line 238
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open output file \'%s\': ",
              output_file_n);
      }
      {
#line 239
      perror((char const   *)((void *)0));
      }
      {
#line 240
      exit(1);
      }
      }
    }
#line 242
    output_opened___0 = 1;
  } else {
#line 246
    output_file___0 = stdout;
  }
  {
  {
#line 249
  tmp___4 = strcmp((char const   *)input_file_n, "-");
  }
  }
#line 249
  if (tmp___4 == 0) {
#line 251
    input_file___0 = stdin;
  } else {
    {
    {
#line 255
    input_file___0 = fopen((char const   */* __restrict  */)input_file_n, (char const   */* __restrict  */)"rb");
    }
    }
#line 256
    if (! input_file___0) {
      {
      {
#line 258
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open input file \'%s\': ",
              input_file_n);
      }
      {
#line 259
      perror((char const   *)((void *)0));
      }
      {
#line 260
      exit(1);
      }
      }
    }
#line 262
    input_opened___0 = 1;
  }
#line 264
  return;
}
}
#line 57 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/wavwriter.c"
static void write_uint32___0(FILE *f , uint32_t v , int bigendian ) 
{ 


  {
#line 59
  if (bigendian ^ host_bigendian) {
    {
    {
#line 59
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 59
      v = ((((v & 255U) << 24) | ((v & 65280U) << 8)) | ((v & 16711680U) >> 8)) | ((v & 4278190080U) >> 24);
#line 59
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 60
  fwrite((void const   */* __restrict  */)(& v), (size_t )4, (size_t )1, (FILE */* __restrict  */)f);
  }
  }
#line 61
  return;
}
}
#line 63 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/wavwriter.c"
static void write_uint16___0(FILE *f , uint16_t v , int bigendian ) 
{ 


  {
#line 65
  if (bigendian ^ host_bigendian) {
    {
    {
#line 65
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 65
      v = (uint16_t )((((int )v & 255) << 8) | (((int )v & 65280) >> 8));
#line 65
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 66
  fwrite((void const   */* __restrict  */)(& v), (size_t )2, (size_t )1, (FILE */* __restrict  */)f);
  }
  }
#line 67
  return;
}
}
#line 89 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static void allocate_buffers___0(alac_file *alac___0 ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
  {
#line 91
  tmp = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 91
  alac___0->predicterror_buffer_a = (int32_t *)tmp;
  {
#line 92
  tmp___0 = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 92
  alac___0->predicterror_buffer_b = (int32_t *)tmp___0;
  {
#line 94
  tmp___1 = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 94
  alac___0->outputsamples_buffer_a = (int32_t *)tmp___1;
  {
#line 95
  tmp___2 = malloc(alac___0->setinfo_max_samples_per_frame * 4U);
  }
#line 95
  alac___0->outputsamples_buffer_b = (int32_t *)tmp___2;
  }
#line 96
  return;
}
}
#line 149 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static uint32_t readbits_16___0(alac_file *alac___0 , int bits ) 
{ 
  uint32_t result ;
  int new_accumulator ;

  {
#line 154
  result = (uint32_t )((((int )*(alac___0->input_buffer + 0) << 16) | ((int )*(alac___0->input_buffer + 1) << 8)) | (int )*(alac___0->input_buffer + 2));
#line 161
  result <<= alac___0->input_buffer_bitaccumulator;
#line 163
  result &= 16777215U;
#line 167
  result >>= 24 - bits;
#line 169
  new_accumulator = alac___0->input_buffer_bitaccumulator + bits;
#line 172
  alac___0->input_buffer += new_accumulator >> 3;
#line 175
  alac___0->input_buffer_bitaccumulator = new_accumulator & 7;
#line 177
  return (result);
}
}
#line 181 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static uint32_t readbits___0(alac_file *alac___0 , int bits ) 
{ 
  int32_t result ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 183
  result = 0;
#line 185
  if (bits > 16) {
    {
#line 187
    bits -= 16;
    {
#line 188
    tmp = readbits_16___0(alac___0, 16);
    }
#line 188
    result = (int32_t )(tmp << bits);
    }
  }
  {
  {
#line 191
  tmp___0 = readbits_16___0(alac___0, bits);
  }
#line 191
  result = (int32_t )((unsigned int )result | tmp___0);
  }
#line 193
  return ((uint32_t )result);
}
}
#line 197 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static int readbit___0(alac_file *alac___0 ) 
{ 
  int result ;
  int new_accumulator ;

  {
#line 202
  result = (int )*(alac___0->input_buffer + 0);
#line 204
  result <<= alac___0->input_buffer_bitaccumulator;
#line 206
  result = (result >> 7) & 1;
#line 208
  new_accumulator = alac___0->input_buffer_bitaccumulator + 1;
#line 210
  alac___0->input_buffer += new_accumulator / 8;
#line 212
  alac___0->input_buffer_bitaccumulator = new_accumulator % 8;
#line 214
  return (result);
}
}
#line 217 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static void unreadbits___0(alac_file *alac___0 , int bits ) 
{ 
  int new_accumulator ;

  {
#line 219
  new_accumulator = alac___0->input_buffer_bitaccumulator - bits;
#line 221
  alac___0->input_buffer += new_accumulator >> 3;
#line 223
  alac___0->input_buffer_bitaccumulator = new_accumulator & 7;
#line 224
  if (alac___0->input_buffer_bitaccumulator < 0) {
#line 225
    alac___0->input_buffer_bitaccumulator *= -1;
  }
#line 226
  return;
}
}
#line 253 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static int count_leading_zeros___0(int input ) 
{ 
  int output ;

  {
#line 255
  output = 0;
#line 256
  if (! input) {
#line 256
    return (32);
  }
#line 257
  __asm__  ("bsr %1, %0\n": "=r" (output): "r" (input));
#line 260
  return (31 - output);
}
}
#line 464 "/home/wslee/benchmarks/sound/alac-decoder-0.1.3/alac.c"
static void predictor_decompress_fir_adapt___0(int32_t *error_buffer , int32_t *buffer_out ,
                                               int output_size , int readsamplesize ,
                                               int16_t *predictor_coef_table , int predictor_coef_num ,
                                               int predictor_quantitization ) 
{ 
  int i ;
  int32_t prev_value ;
  int32_t error_value ;
  int i___0 ;
  int32_t val ;
  int j ;
  int sum ;
  int outval ;
  int error_val ;
  int predictor_num ;
  int val___0 ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int predictor_num___0 ;
  int val___1 ;
  int sign___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 475
  *buffer_out = *error_buffer;
#line 477
  if (! predictor_coef_num) {
#line 479
    if (output_size <= 1) {
#line 479
      return;
    }
    {
    {
#line 480
    memcpy((void */* __restrict  */)(buffer_out + 1), (void const   */* __restrict  */)(error_buffer + 1),
           (size_t )((output_size - 1) * 4));
    }
    }
#line 481
    return;
  }
#line 484
  if (predictor_coef_num == 31) {
#line 488
    if (output_size <= 1) {
#line 488
      return;
    }
#line 489
    i = 0;
    {
    {
#line 489
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 489
      if (! (i < output_size - 1)) {
#line 489
        goto while_break;
      }
#line 494
      prev_value = *(buffer_out + i);
#line 495
      error_value = *(error_buffer + (i + 1));
#line 496
      *(buffer_out + (i + 1)) = ((prev_value + error_value) << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 489
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 498
    return;
  }
#line 502
  if (predictor_coef_num > 0) {
#line 505
    i___0 = 0;
    {
    {
#line 505
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 505
      if (! (i___0 < predictor_coef_num)) {
#line 505
        goto while_break___0;
      }
#line 509
      val = *(buffer_out + i___0) + *(error_buffer + (i___0 + 1));
#line 511
      val = (val << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 513
      *(buffer_out + (i___0 + 1)) = val;
#line 505
      i___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 536
  if (predictor_coef_num > 0) {
#line 538
    i = predictor_coef_num + 1;
    {
    {
#line 538
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 538
      if (! (i < output_size)) {
#line 538
        goto while_break___1;
      }
#line 543
      sum = 0;
#line 545
      error_val = *(error_buffer + i);
#line 547
      j = 0;
      {
      {
#line 547
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 547
        if (! (j < predictor_coef_num)) {
#line 547
          goto while_break___2;
        }
#line 549
        sum += (*(buffer_out + (predictor_coef_num - j)) - *(buffer_out + 0)) * (int32_t )*(predictor_coef_table + j);
#line 547
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 553
      outval = (1 << (predictor_quantitization - 1)) + sum;
#line 554
      outval >>= predictor_quantitization;
#line 555
      outval = (outval + *(buffer_out + 0)) + error_val;
#line 556
      outval = (outval << (32 - readsamplesize)) >> (32 - readsamplesize);
#line 558
      *(buffer_out + (predictor_coef_num + 1)) = outval;
#line 560
      if (error_val > 0) {
#line 562
        predictor_num = predictor_coef_num - 1;
        {
        {
#line 564
        while (1) {
          while_continue___9: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 564
          if (predictor_num >= 0) {
#line 564
            if (! (error_val > 0)) {
#line 564
              goto while_break___3;
            }
          } else {
#line 564
            goto while_break___3;
          }
#line 566
          val___0 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num));
#line 567
          if (val___0 < 0) {
#line 567
            tmp___0 = -1;
          } else {
#line 567
            if (val___0 > 0) {
#line 567
              tmp = 1;
            } else {
#line 567
              tmp = 0;
            }
#line 567
            tmp___0 = tmp;
          }
#line 567
          sign = tmp___0;
#line 569
          *(predictor_coef_table + predictor_num) = (int16_t )((int )*(predictor_coef_table + predictor_num) - sign);
#line 571
          val___0 *= sign;
#line 573
          error_val -= (val___0 >> predictor_quantitization) * (predictor_coef_num - predictor_num);
#line 576
          predictor_num --;
        }
        while_break___9: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 579
      if (error_val < 0) {
#line 581
        predictor_num___0 = predictor_coef_num - 1;
        {
        {
#line 583
        while (1) {
          while_continue___10: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 583
          if (predictor_num___0 >= 0) {
#line 583
            if (! (error_val < 0)) {
#line 583
              goto while_break___4;
            }
          } else {
#line 583
            goto while_break___4;
          }
#line 585
          val___1 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num___0));
#line 586
          if (val___1 < 0) {
#line 586
            tmp___2 = -1;
          } else {
#line 586
            if (val___1 > 0) {
#line 586
              tmp___1 = 1;
            } else {
#line 586
              tmp___1 = 0;
            }
#line 586
            tmp___2 = tmp___1;
          }
#line 586
          sign___0 = - tmp___2;
#line 588
          *(predictor_coef_table + predictor_num___0) = (int16_t )((int )*(predictor_coef_table + predictor_num___0) - sign___0);
#line 590
          val___1 *= sign___0;
#line 592
          error_val -= (val___1 >> predictor_quantitization) * (predictor_coef_num - predictor_num___0);
#line 595
          predictor_num___0 --;
        }
        while_break___10: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 599
      buffer_out ++;
#line 538
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 602
  return;
}
}
