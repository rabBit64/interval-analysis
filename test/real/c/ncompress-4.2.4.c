/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h"
typedef unsigned long size_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 45
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 172 "/usr/include/libio.h"
struct _IO_FILE;
#line 182 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 188 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 273 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 343 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 153 "compress42.c"
struct utimbuf {
   time_t actime ;
   time_t modtime ;
};
#line 355 "compress42.c"
typedef long code_int;
#line 362 "compress42.c"
typedef long count_int;
#line 366 "compress42.c"
typedef unsigned char char_type;
#line 1348 "compress42.c"
struct __anonstruct_e_43 {
   char_type c ;
   unsigned short ent ;
};
#line 1348 "compress42.c"
union __anonunion_fcode_42 {
   long code ;
   struct __anonstruct_e_43 e ;
};
#line 463 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 171 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 243
extern int fflush(FILE *__stream ) ;
#line 357
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 843
extern void perror(char const   *__s ) ;
#line 119 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 211 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 216
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 286
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 1 "patchlevel.h"
static char ident[22]  = 
#line 1 "patchlevel.h"
  {      (char )'@',      (char )'(',      (char )'#',      (char )')', 
        (char )'(',      (char )'N',      (char )')',      (char )'c', 
        (char )'o',      (char )'m',      (char )'p',      (char )'r', 
        (char )'e',      (char )'s',      (char )'s',      (char )' ', 
        (char )'4',      (char )'.',      (char )'2',      (char )'.', 
        (char )'4',      (char )'\000'};
#line 518 "compress42.c"
char *progname  ;
#line 519 "compress42.c"
int silent  =    0;
#line 520 "compress42.c"
int quiet  =    1;
#line 521 "compress42.c"
int do_decomp  =    0;
#line 522 "compress42.c"
int force  =    0;
#line 523 "compress42.c"
int nomagic  =    0;
#line 525 "compress42.c"
int block_mode  =    128;
#line 526 "compress42.c"
int maxbits  =    16;
#line 527 "compress42.c"
int zcat_flg  =    0;
#line 528 "compress42.c"
int recursive  =    0;
#line 529 "compress42.c"
int exit_code  =    -1;
#line 531 "compress42.c"
char_type inbuf[8256]  ;
#line 532 "compress42.c"
char_type outbuf[10240]  ;
#line 534 "compress42.c"
struct stat infstat  ;
#line 535 "compress42.c"
char *ifname  ;
#line 536 "compress42.c"
int remove_ofname  =    0;
#line 537 "compress42.c"
char ofname[1024]  ;
#line 538 "compress42.c"
int fgnd_flag  =    0;
#line 540 "compress42.c"
long bytes_in  ;
#line 541 "compress42.c"
long bytes_out  ;
#line 593 "compress42.c"
count_int htab[69001]  ;
#line 594 "compress42.c"
unsigned short codetab[69001]  ;
#line 643
void main(int argc , char **argv ) ;
#line 644
void Usage(void) ;
#line 645
void comprexx(char **fileptr ) ;
#line 647
void compress(int fdin , int fdout ) ;
#line 648
void decompress(int fdin , int fdout ) ;
#line 649
char *rindex(char *s , int c ) ;
#line 650
void read_error(void) ;
#line 651
void write_error(void) ;
#line 652
void abort_compress(void) ;
#line 653
void prratio(FILE *stream , long num , long den ) ;
#line 654
void about(void) ;
#line 716
extern int ( /* missing proto */  malloc)() ;
#line 727
extern int ( /* missing proto */  strcmp)() ;
#line 790
extern int ( /* missing proto */  atoi)() ;
#line 856
extern int ( /* missing proto */  exit)() ;
#line 696 "compress42.c"
void main(int argc , char **argv ) 
{ 
  char **filelist ;
  char **fileptr ;
  __sighandler_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char **tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 704
  tmp = signal(2, (void (*)(int  ))1);
  }
#line 704
  fgnd_flag = (unsigned long )tmp != (unsigned long )((void (*)(int  ))1);
  }
#line 704
  if (fgnd_flag) {
    {
    {
#line 705
    signal(2, (void (*)(int  ))(& abort_compress));
    }
    }
  }
  {
  {
#line 707
  signal(15, (void (*)(int  ))(& abort_compress));
  }
  {
#line 709
  signal(1, (void (*)(int  ))(& abort_compress));
  }
  {
#line 716
  tmp___0 = malloc((unsigned long )argc * sizeof(char *));
  }
#line 716
  fileptr = (char **)tmp___0;
#line 716
  filelist = fileptr;
#line 717
  *filelist = (char *)((void *)0);
  {
#line 719
  progname = rindex(*(argv + 0), '/');
  }
  }
#line 719
  if ((unsigned long )progname != (unsigned long )((char *)0)) {
#line 720
    progname ++;
  } else {
#line 722
    progname = *(argv + 0);
  }
  {
  {
#line 724
  tmp___2 = strcmp(progname, "uncompress");
  }
  }
#line 724
  if (tmp___2 == 0) {
#line 725
    do_decomp = 1;
  } else {
    {
    {
#line 727
    tmp___1 = strcmp(progname, "zcat");
    }
    }
#line 727
    if (tmp___1 == 0) {
#line 728
      zcat_flg = 1;
#line 728
      do_decomp = zcat_flg;
    }
  }
#line 744
  argc --;
#line 744
  argv ++;
  {
  {
#line 744
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 744
    if (! (argc > 0)) {
#line 744
      goto while_break;
    }
#line 746
    if ((int )*(*argv) == 45) {
      {
      {
#line 748
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 748
        (*argv) ++;
#line 748
        if (! *(*argv)) {
#line 748
          goto while_break___0;
        }
        {
#line 752
        if ((int )*(*argv) == 86) {
#line 752
          goto case_86;
        }
#line 756
        if ((int )*(*argv) == 115) {
#line 756
          goto case_115;
        }
#line 761
        if ((int )*(*argv) == 118) {
#line 761
          goto case_118;
        }
#line 766
        if ((int )*(*argv) == 100) {
#line 766
          goto case_100;
        }
#line 771
        if ((int )*(*argv) == 70) {
#line 771
          goto case_70;
        }
#line 771
        if ((int )*(*argv) == 102) {
#line 771
          goto case_70;
        }
#line 775
        if ((int )*(*argv) == 110) {
#line 775
          goto case_110;
        }
#line 779
        if ((int )*(*argv) == 67) {
#line 779
          goto case_67;
        }
#line 783
        if ((int )*(*argv) == 98) {
#line 783
          goto case_98;
        }
#line 793
        if ((int )*(*argv) == 99) {
#line 793
          goto case_99;
        }
#line 797
        if ((int )*(*argv) == 113) {
#line 797
          goto case_113;
        }
#line 801
        if ((int )*(*argv) == 82) {
#line 801
          goto case_82;
        }
#line 801
        if ((int )*(*argv) == 114) {
#line 801
          goto case_82;
        }
#line 809
        goto switch_default;
        case_86: /* CIL Label */ 
        {
        {
#line 753
        about();
        }
        }
#line 754
        goto switch_break;
        case_115: /* CIL Label */ 
#line 757
        silent = 1;
#line 758
        quiet = 1;
#line 759
        goto switch_break;
        case_118: /* CIL Label */ 
#line 762
        silent = 0;
#line 763
        quiet = 0;
#line 764
        goto switch_break;
        case_100: /* CIL Label */ 
#line 767
        do_decomp = 1;
#line 768
        goto switch_break;
        case_70: /* CIL Label */ 
        case_102: /* CIL Label */ 
#line 772
        force = 1;
#line 773
        goto switch_break;
        case_110: /* CIL Label */ 
#line 776
        nomagic = 1;
#line 777
        goto switch_break;
        case_67: /* CIL Label */ 
#line 780
        block_mode = 0;
#line 781
        goto switch_break;
        case_98: /* CIL Label */ 
#line 784
        (*argv) ++;
#line 784
        if (! *(*argv)) {
#line 784
          argc --;
#line 784
          if (argc) {
#line 784
            argv ++;
#line 784
            if (! *argv) {
              {
              {
#line 786
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing maxbits\n");
              }
              {
#line 787
              Usage();
              }
              }
            }
          } else {
            {
            {
#line 786
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing maxbits\n");
            }
            {
#line 787
            Usage();
            }
            }
          }
        }
        {
        {
#line 790
        maxbits = atoi(*argv);
        }
        }
#line 791
        goto nextarg;
        case_99: /* CIL Label */ 
#line 794
        zcat_flg = 1;
#line 795
        goto switch_break;
        case_113: /* CIL Label */ 
#line 798
        quiet = 1;
#line 799
        goto switch_break;
        case_82: /* CIL Label */ 
        case_114: /* CIL Label */ 
        {
        {
#line 805
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s -r not availble (du to missing directory functions)\n",
                *argv);
        }
        }
#line 807
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
        {
#line 810
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown flag: \'%c\'; ",
                (int )*(*argv));
        }
        {
#line 811
        Usage();
        }
        }
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 817
      tmp___3 = fileptr;
#line 817
      fileptr ++;
#line 817
      *tmp___3 = *argv;
#line 818
      *fileptr = (char *)((void *)0);
    }
    nextarg: 
#line 821
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 744
    argc --;
#line 744
    argv ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  if (maxbits < 9) {
#line 824
    maxbits = 9;
  }
#line 825
  if (maxbits > 16) {
#line 825
    maxbits = 16;
  }
#line 827
  if ((unsigned long )*filelist != (unsigned long )((void *)0)) {
#line 829
    fileptr = filelist;
    {
    {
#line 829
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 829
      if (! *fileptr) {
#line 829
        goto while_break___1;
      }
      {
      {
#line 830
      comprexx(fileptr);
      }
#line 829
      fileptr ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 834
    ifname = (char *)"";
#line 835
    exit_code = 0;
#line 836
    remove_ofname = 0;
#line 838
    if (do_decomp == 0) {
      {
      {
#line 840
      compress(0, 1);
      }
      }
#line 842
      if (zcat_flg == 0) {
#line 842
        if (! quiet) {
          {
          {
#line 844
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compression: ");
          }
          {
#line 845
          prratio(stderr, bytes_in - bytes_out, bytes_in);
          }
          {
#line 846
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
          }
          }
        }
      }
#line 849
      if (bytes_out >= bytes_in) {
#line 849
        if (! force) {
#line 850
          exit_code = 2;
        }
      }
    } else {
      {
      {
#line 853
      decompress(0, 1);
      }
      }
    }
  }
#line 856
  if (exit_code == -1) {
#line 856
    tmp___4 = 1;
  } else {
#line 856
    tmp___4 = exit_code;
  }
  {
  {
#line 856
  exit(tmp___4);
  }
  }
}
}
#line 859 "compress42.c"
void Usage(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 862
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-dfvcVr] [-b maxbits] [file ...]\n       -d   If given, decompression is done instead.\n       -c   Write output on stdout, don\'t remove original.\n       -b   Parameter limits the max number of bits/code.\n",
          progname);
  }
  {
#line 867
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       -f   Forces output file to be generated, even if one already.\n            exists, and even if no space is saved by compressing.\n            If -f is not used, the user will be prompted if stdin is.\n            a tty, otherwise, the output file will not be overwritten.\n       -v   Write compression statistics.\n       -V   Output vesion and compile options.\n       -r   Recursive. If a filename is a directory, descend\n            into it and compress everything in it.\n");
  }
  {
#line 877
  exit(1);
  }
  }
}
}
#line 887
extern int ( /* missing proto */  strcpy)() ;
#line 908
extern int ( /* missing proto */  strcat)() ;
#line 906
extern int ( /* missing proto */  strlen)() ;
#line 1066
extern int ( /* missing proto */  read)() ;
#line 1055
extern int ( /* missing proto */  isatty)() ;
#line 1087
extern int ( /* missing proto */  unlink)() ;
#line 1158
extern int ( /* missing proto */  close)() ;
#line 1214
extern int ( /* missing proto */  utime)() ;
#line 1229
extern int ( /* missing proto */  chown)() ;
#line 880 "compress42.c"
void comprexx(char **fileptr ) 
{ 
  int fdin ;
  int fdout ;
  char tempname[1024] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int c ;
  int s ;
  struct stat statbuf ;
  struct stat statbuf2 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  struct utimbuf timep ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  {
  {
#line 887
  strcpy(tempname, *fileptr);
  }
  {
#line 888
  tmp = __errno_location();
  }
#line 888
  *tmp = 0;
  {
#line 893
  tmp___5 = stat((char const   */* __restrict  */)(tempname), (struct stat */* __restrict  */)(& infstat));
  }
  }
#line 893
  if (tmp___5 == -1) {
#line 896
    if (do_decomp) {
      {
      {
#line 898
      tmp___0 = __errno_location();
      }
      }
      {
#line 900
      if (*tmp___0 == 2) {
#line 900
        goto case_2;
      }
#line 937
      goto switch_default;
      case_2: /* CIL Label */ 
      {
      {
#line 906
      tmp___3 = strlen(tempname);
      }
      {
#line 906
      tmp___4 = strcmp((tempname + tmp___3) - 2, ".Z");
      }
      }
#line 906
      if (tmp___4 != 0) {
        {
        {
#line 908
        strcat(tempname, ".Z");
        }
        {
#line 909
        tmp___1 = __errno_location();
        }
#line 909
        *tmp___1 = 0;
        {
#line 913
        tmp___2 = stat((char const   */* __restrict  */)(tempname), (struct stat */* __restrict  */)(& infstat));
        }
        }
#line 913
        if (tmp___2 == -1) {
          {
          {
#line 916
          perror((char const   *)(tempname));
          }
#line 917
          exit_code = 1;
          }
#line 918
          return;
        }
#line 921
        if ((infstat.st_mode & 61440U) != 32768U) {
          {
          {
#line 923
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Not a regular file.\n",
                  tempname);
          }
#line 924
          exit_code = 1;
          }
#line 925
          return;
        }
      } else {
        {
        {
#line 930
        perror((char const   *)(tempname));
        }
#line 931
        exit_code = 1;
        }
#line 932
        return;
      }
#line 935
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 938
      perror((char const   *)(tempname));
      }
#line 939
      exit_code = 1;
      }
#line 940
      return;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 945
      perror((char const   *)(tempname));
      }
#line 946
      exit_code = 1;
      }
#line 947
      return;
    }
  }
  {
#line 953
  if ((infstat.st_mode & 61440U) == 16384U) {
#line 953
    goto case_16384;
  }
#line 963
  if ((infstat.st_mode & 61440U) == 32768U) {
#line 963
    goto case_32768;
  }
#line 1248
  goto switch_default___0;
  case_16384: /* CIL Label */ 
#line 959
  if (! quiet) {
    {
    {
#line 960
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is a directory -- ignored\n",
            tempname);
    }
    }
  }
#line 961
  goto switch_break___0;
  case_32768: /* CIL Label */ 
#line 964
  if (do_decomp != 0) {
#line 966
    if (! zcat_flg) {
      {
      {
#line 968
      tmp___6 = strlen(tempname);
      }
      {
#line 968
      tmp___7 = strcmp((tempname + tmp___6) - 2, ".Z");
      }
      }
#line 968
      if (tmp___7 != 0) {
#line 970
        if (! quiet) {
          {
          {
#line 971
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - no .Z suffix\n",
                  tempname);
          }
          }
        }
#line 973
        return;
      }
    }
    {
    {
#line 976
    strcpy(ofname, tempname);
    }
    {
#line 980
    tmp___9 = strlen(tempname);
    }
    {
#line 980
    tmp___10 = strcmp((tempname + tmp___9) - 2, ".Z");
    }
    }
#line 980
    if (tmp___10 == 0) {
      {
      {
#line 981
      tmp___8 = strlen(tempname);
      }
#line 981
      ofname[tmp___8 - 2] = (char )'\000';
      }
    }
  } else {
#line 986
    if (! zcat_flg) {
      {
      {
#line 988
      tmp___11 = strlen(tempname);
      }
      {
#line 988
      tmp___12 = strcmp((tempname + tmp___11) - 2, ".Z");
      }
      }
#line 988
      if (tmp___12 == 0) {
        {
        {
#line 990
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: already has .Z suffix -- no change\n",
                tempname);
        }
        }
#line 991
        return;
      }
#line 994
      if (infstat.st_nlink > 1UL) {
#line 994
        if (! force) {
          {
          {
#line 996
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has %d other links: unchanged\n",
                  tempname, infstat.st_nlink - 1UL);
          }
#line 998
          exit_code = 1;
          }
#line 999
          return;
        }
      }
    }
    {
    {
#line 1003
    strcpy(ofname, tempname);
    }
    {
#line 1004
    strcat(ofname, ".Z");
    }
    }
  }
  {
#line 1007
  ifname = tempname;
  {
#line 1007
  fdin = open((char const   *)ifname, 0);
  }
  }
#line 1007
  if (fdin == -1) {
    {
    {
#line 1009
    perror((char const   *)(tempname));
    }
#line 1010
    exit_code = 1;
    }
#line 1011
    return;
  }
#line 1014
  if (zcat_flg == 0) {
    {
    {
#line 1021
    tmp___18 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& statbuf));
    }
    }
#line 1021
    if (tmp___18 == 0) {
      {
      {
#line 1023
      s = strlen(ofname);
      }
      }
#line 1023
      if (s > 8) {
        {
#line 1025
        c = (int )ofname[s - 1];
#line 1026
        ofname[s - 1] = (char )'\000';
#line 1028
        statbuf2 = statbuf;
        {
#line 1030
        tmp___13 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& statbuf2));
        }
        }
#line 1030
        if (! tmp___13) {
#line 1030
          if (statbuf.st_mode == statbuf2.st_mode) {
#line 1030
            if (statbuf.st_ino == statbuf2.st_ino) {
#line 1030
              if (statbuf.st_dev == statbuf2.st_dev) {
#line 1030
                if (statbuf.st_uid == statbuf2.st_uid) {
#line 1030
                  if (statbuf.st_gid == statbuf2.st_gid) {
#line 1030
                    if (statbuf.st_size == statbuf2.st_size) {
#line 1030
                      if (statbuf.st_atim.tv_sec == statbuf2.st_atim.tv_sec) {
#line 1030
                        if (statbuf.st_mtim.tv_sec == statbuf2.st_mtim.tv_sec) {
#line 1030
                          if (statbuf.st_ctim.tv_sec == statbuf2.st_ctim.tv_sec) {
                            {
                            {
#line 1041
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: filename too long to tack on .Z\n",
                                    tempname);
                            }
#line 1042
                            exit_code = 1;
                            }
#line 1043
                            return;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 1046
        ofname[s - 1] = (char )c;
      }
#line 1049
      if (! force) {
        {
#line 1051
        inbuf[0] = (char_type )'n';
        {
#line 1053
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s already exists.\n",
                ofname);
        }
        }
#line 1055
        if (fgnd_flag) {
          {
          {
#line 1055
          tmp___16 = isatty(0);
          }
          }
#line 1055
          if (tmp___16) {
            {
            {
#line 1057
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Do you wish to overwrite %s (y or n)? ",
                    ofname);
            }
            {
#line 1058
            fflush(stderr);
            }
            {
#line 1060
            tmp___15 = read(0, inbuf, 1);
            }
            }
#line 1060
            if (tmp___15 > 0) {
#line 1062
              if ((int )inbuf[0] != 10) {
                {
                {
#line 1064
                while (1) {
                  while_continue___0: /* CIL Label */ ;
                  while_continue: /* CIL Label */ ;
                  {
                  {
#line 1066
                  tmp___14 = read(0, inbuf + 1, 1);
                  }
                  }
#line 1066
                  if (tmp___14 <= 0) {
                    {
                    {
#line 1068
                    perror("stdin");
                    }
                    }
#line 1069
                    goto while_break;
                  }
#line 1064
                  if (! ((int )inbuf[1] != 10)) {
#line 1064
                    goto while_break;
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
                while_break: /* CIL Label */ ;
                }
              }
            } else {
              {
              {
#line 1076
              perror("stdin");
              }
              }
            }
          }
        }
#line 1079
        if ((int )inbuf[0] != 121) {
          {
          {
#line 1081
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s not overwritten\n",
                  ofname);
          }
#line 1082
          exit_code = 1;
          }
#line 1083
          return;
        }
      }
      {
      {
#line 1087
      tmp___17 = unlink(ofname);
      }
      }
#line 1087
      if (tmp___17) {
        {
        {
#line 1089
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t remove old output file\n");
        }
        {
#line 1090
        perror((char const   *)(ofname));
        }
#line 1091
        exit_code = 1;
        }
#line 1092
        return;
      }
    }
    {
    {
#line 1096
    fdout = open((char const   *)(ofname), 193, 384);
    }
    }
#line 1096
    if (fdout == -1) {
      {
      {
#line 1098
      perror((char const   *)(tempname));
      }
      }
#line 1099
      return;
    }
    {
    {
#line 1102
    s = strlen(ofname);
    }
    }
#line 1102
    if (s > 8) {
      {
      {
#line 1104
      tmp___19 = fstat(fdout, & statbuf);
      }
      }
#line 1104
      if (tmp___19) {
        {
        {
#line 1106
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t get status op output file\n");
        }
        {
#line 1107
        perror((char const   *)(ofname));
        }
#line 1108
        exit_code = 1;
        }
#line 1109
        return;
      }
      {
#line 1112
      c = (int )ofname[s - 1];
#line 1113
      ofname[s - 1] = (char )'\000';
#line 1114
      statbuf2 = statbuf;
      {
#line 1116
      tmp___21 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& statbuf2));
      }
      }
#line 1116
      if (! tmp___21) {
#line 1116
        if (statbuf.st_mode == statbuf2.st_mode) {
#line 1116
          if (statbuf.st_ino == statbuf2.st_ino) {
#line 1116
            if (statbuf.st_dev == statbuf2.st_dev) {
#line 1116
              if (statbuf.st_uid == statbuf2.st_uid) {
#line 1116
                if (statbuf.st_gid == statbuf2.st_gid) {
#line 1116
                  if (statbuf.st_size == statbuf2.st_size) {
#line 1116
                    if (statbuf.st_atim.tv_sec == statbuf2.st_atim.tv_sec) {
#line 1116
                      if (statbuf.st_mtim.tv_sec == statbuf2.st_mtim.tv_sec) {
#line 1116
                        if (statbuf.st_ctim.tv_sec == statbuf2.st_ctim.tv_sec) {
                          {
                          {
#line 1127
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: filename too long to tack on .Z\n",
                                  tempname);
                          }
                          {
#line 1129
                          tmp___20 = unlink(ofname);
                          }
                          }
#line 1129
                          if (tmp___20) {
                            {
                            {
#line 1131
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t remove bad output file\n");
                            }
                            {
#line 1132
                            perror((char const   *)(ofname));
                            }
                            }
                          }
#line 1134
                          exit_code = 1;
#line 1135
                          return;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 1138
      ofname[s - 1] = (char )c;
    }
#line 1141
    if (! quiet) {
      {
      {
#line 1142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              tempname);
      }
      }
    }
#line 1144
    remove_ofname = 1;
  } else {
#line 1148
    fdout = 1;
#line 1149
    ofname[0] = (char )'\000';
#line 1150
    remove_ofname = 0;
  }
#line 1153
  if (do_decomp == 0) {
    {
    {
#line 1154
    compress(fdin, fdout);
    }
    }
  } else {
    {
    {
#line 1156
    decompress(fdin, fdout);
    }
    }
  }
  {
  {
#line 1158
  close(fdin);
  }
  }
#line 1160
  if (fdout != 1) {
    {
    {
#line 1160
    tmp___22 = close(fdout);
    }
    }
#line 1160
    if (tmp___22) {
      {
      {
#line 1161
      write_error();
      }
      }
    }
  }
#line 1163
  if (bytes_in == 0L) {
#line 1165
    if (remove_ofname) {
      {
      {
#line 1167
      tmp___23 = unlink(ofname);
      }
      }
#line 1167
      if (tmp___23) {
        {
        {
#line 1169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nunlink error (ignored) ");
        }
        {
#line 1170
        perror((char const   *)(ofname));
        }
#line 1171
        exit_code = 1;
        }
      }
#line 1174
      remove_ofname = 0;
    }
  } else
#line 1178
  if (zcat_flg == 0) {
#line 1182
    if (! do_decomp) {
#line 1182
      if (bytes_out >= bytes_in) {
#line 1182
        if (! force) {
#line 1184
          if (! quiet) {
            {
            {
#line 1185
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No compression -- %s unchanged\n",
                    ifname);
            }
            }
          }
          {
          {
#line 1187
          tmp___24 = unlink(ofname);
          }
          }
#line 1187
          if (tmp___24) {
            {
            {
#line 1189
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unlink error (ignored) ");
            }
            {
#line 1190
            perror((char const   *)(ofname));
            }
            }
          }
#line 1193
          remove_ofname = 0;
#line 1194
          exit_code = 2;
        } else {
#line 1182
          goto _L___0;
        }
      } else {
#line 1182
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1198
      if (! quiet) {
        {
        {
#line 1200
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -- replaced with %s",
                ofname);
        }
        }
#line 1202
        if (! do_decomp) {
          {
          {
#line 1204
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Compression: ");
          }
          {
#line 1205
          prratio(stderr, bytes_in - bytes_out, bytes_in);
          }
          }
        }
        {
        {
#line 1208
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
        }
      }
      {
#line 1211
      timep.actime = infstat.st_atim.tv_sec;
#line 1212
      timep.modtime = infstat.st_mtim.tv_sec;
      {
#line 1214
      tmp___25 = utime(ofname, & timep);
      }
      }
#line 1214
      if (tmp___25) {
        {
        {
#line 1216
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nutime error (ignored) ");
        }
        {
#line 1217
        perror((char const   *)(ofname));
        }
#line 1218
        exit_code = 1;
        }
      }
      {
      {
#line 1222
      tmp___26 = chmod((char const   *)(ofname), infstat.st_mode & 4095U);
      }
      }
#line 1222
      if (tmp___26) {
        {
        {
#line 1224
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nchmod error (ignored) ");
        }
        {
#line 1225
        perror((char const   *)(ofname));
        }
#line 1226
        exit_code = 1;
        }
      }
      {
      {
#line 1229
      chown(ofname, infstat.st_uid, infstat.st_gid);
      }
#line 1232
      remove_ofname = 0;
      {
#line 1234
      tmp___27 = unlink(ifname);
      }
      }
#line 1234
      if (tmp___27) {
        {
        {
#line 1236
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nunlink error (ignored) ");
        }
        {
#line 1237
        perror((char const   *)ifname);
        }
#line 1238
        exit_code = 1;
        }
      }
    }
  }
#line 1243
  if (exit_code == -1) {
#line 1244
    exit_code = 0;
  }
#line 1246
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
  {
#line 1249
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is not a directory or a regular file - ignored\n",
          tempname);
  }
  }
#line 1251
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1253
  return;
}
}
#line 1364
extern int ( /* missing proto */  memset)() ;
#line 1440
extern int ( /* missing proto */  write)() ;
#line 1447
extern int ( /* missing proto */  memcpy)() ;
#line 1328 "compress42.c"
void compress(int fdin , int fdout ) 
{ 
  register long hp ;
  int rpos ;
  int outbits ;
  int rlop ;
  int rsize ;
  int stcode ;
  code_int free_ent ;
  int boff ;
  int n_bits ;
  int ratio ;
  long checkpoint ;
  code_int extcode ;
  union __anonunion_fcode_42 fcode ;
  register long rat ;
  register char_type *p ;
  register long i ;
  int tmp ;
  register int i___0 ;
  int tmp___0 ;
  register code_int i___1 ;
  long disp ;
  register char_type *p___0 ;
  register long i___2 ;
  register long fc ;
  code_int tmp___1 ;
  register char_type *p___1 ;
  register long i___3 ;
  int tmp___2 ;

  {
  {
#line 1358
  ratio = 0;
#line 1359
  checkpoint = 10000L;
#line 1360
  n_bits = 9;
#line 1360
  extcode = (1L << n_bits) + 1L;
#line 1361
  stcode = 1;
#line 1362
  free_ent = (code_int )257;
  {
#line 1364
  memset(outbuf, 0, sizeof(outbuf));
  }
#line 1365
  bytes_out = 0L;
#line 1365
  bytes_in = 0L;
#line 1366
  outbuf[0] = (char_type )'\037';
#line 1367
  outbuf[1] = (char_type )'\235';
#line 1368
  outbuf[2] = (char_type )((char )(maxbits | block_mode));
#line 1369
  outbits = 3 << 3;
#line 1369
  boff = outbits;
#line 1370
  fcode.code = 0L;
  {
#line 1372
  memset(htab, -1, sizeof(htab));
  }
  }
  {
  {
#line 1374
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1374
    rsize = read(fdin, inbuf, 8192);
    }
    }
#line 1374
    if (! (rsize > 0)) {
#line 1374
      goto while_break;
    }
#line 1376
    if (bytes_in == 0L) {
#line 1378
      fcode.e.ent = (unsigned short )inbuf[0];
#line 1379
      rpos = 1;
    } else {
#line 1382
      rpos = 0;
    }
#line 1384
    rlop = 0;
    {
    {
#line 1386
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1388
      if (free_ent >= extcode) {
#line 1388
        if ((int )fcode.e.ent < 257) {
#line 1390
          if (n_bits < maxbits) {
#line 1392
            outbits = (outbits - 1) + ((n_bits << 3) - (((outbits - boff) - 1) + (n_bits << 3)) % (n_bits << 3));
#line 1392
            boff = outbits;
#line 1394
            n_bits ++;
#line 1394
            if (n_bits < maxbits) {
#line 1395
              extcode = (1L << n_bits) + 1L;
            } else {
#line 1397
              extcode = 1L << n_bits;
            }
          } else {
#line 1401
            extcode = (1L << 16) + 8192L;
#line 1402
            stcode = 0;
          }
        }
      }
#line 1406
      if (! stcode) {
#line 1406
        if (bytes_in >= checkpoint) {
#line 1406
          if ((int )fcode.e.ent < 257) {
#line 1410
            checkpoint = bytes_in + 10000L;
#line 1412
            if (bytes_in > 8388607L) {
#line 1414
              rat = (bytes_out + (long )(outbits >> 3)) >> 8;
#line 1416
              if (rat == 0L) {
#line 1417
                rat = 2147483647L;
              } else {
#line 1419
                rat = bytes_in / rat;
              }
            } else {
#line 1422
              rat = (bytes_in << 8) / (bytes_out + (long )(outbits >> 3));
            }
#line 1423
            if (rat >= (long )ratio) {
#line 1424
              ratio = (int )rat;
            } else {
              {
#line 1427
              ratio = 0;
              {
#line 1428
              memset(htab, -1, sizeof(htab));
              }
#line 1429
              p = & outbuf[outbits >> 3];
#line 1429
              i = 256L << (outbits & 7);
#line 1429
              *(p + 0) = (char_type )((int )*(p + 0) | (int )((char_type )i));
#line 1429
              *(p + 1) = (char_type )((int )*(p + 1) | (int )((char_type )(i >> 8)));
#line 1429
              *(p + 2) = (char_type )((int )*(p + 2) | (int )((char_type )(i >> 16)));
#line 1429
              outbits += n_bits;
#line 1430
              outbits = (outbits - 1) + ((n_bits << 3) - (((outbits - boff) - 1) + (n_bits << 3)) % (n_bits << 3));
#line 1430
              boff = outbits;
#line 1432
              n_bits = 9;
#line 1432
              extcode = (1L << n_bits) + 1L;
#line 1433
              free_ent = (code_int )257;
#line 1434
              stcode = 1;
              }
            }
          }
        }
      }
#line 1438
      if (outbits >= 8192 << 3) {
        {
        {
#line 1440
        tmp = write(fdout, outbuf, 8192);
        }
        }
#line 1440
        if (tmp != 8192) {
          {
          {
#line 1441
          write_error();
          }
          }
        }
        {
#line 1443
        outbits -= 8192 << 3;
#line 1444
        boff = - (((8192 << 3) - boff) % (n_bits << 3));
#line 1445
        bytes_out += 8192L;
        {
#line 1447
        memcpy(outbuf, outbuf + 8192, (outbits >> 3) + 1);
        }
        {
#line 1448
        memset((outbuf + (outbits >> 3)) + 1, '\000', 8192);
        }
        }
      }
#line 1454
      i___0 = rsize - rlop;
#line 1456
      if ((code_int )i___0 > extcode - free_ent) {
#line 1456
        i___0 = (int )(extcode - free_ent);
      }
#line 1457
      if ((unsigned long )i___0 > ((sizeof(outbuf) - 32UL) * 8UL - (unsigned long )outbits) / (unsigned long )n_bits) {
#line 1458
        i___0 = (int )(((sizeof(outbuf) - 32UL) * 8UL - (unsigned long )outbits) / (unsigned long )n_bits);
      }
#line 1460
      if (! stcode) {
#line 1460
        if ((long )i___0 > checkpoint - bytes_in) {
#line 1461
          i___0 = (int )(checkpoint - bytes_in);
        }
      }
#line 1463
      rlop += i___0;
#line 1464
      bytes_in += (long )i___0;
#line 1467
      goto next;
      hfound: 
#line 1468
      fcode.e.ent = codetab[hp];
      next: 
#line 1469
      if (rpos >= rlop) {
#line 1470
        goto endlop;
      }
      next2: 
#line 1471
      tmp___0 = rpos;
#line 1471
      rpos ++;
#line 1471
      fcode.e.c = inbuf[tmp___0];
#line 1480
      hp = ((long )fcode.e.c << 8) ^ (long )fcode.e.ent;
#line 1482
      i___1 = htab[hp];
#line 1482
      if (i___1 == fcode.code) {
#line 1483
        goto hfound;
      }
#line 1485
      if (i___1 != -1L) {
#line 1489
        disp = (69001L - hp) - 1L;
        {
        {
#line 1491
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 1493
          hp -= disp;
#line 1493
          if (hp < 0L) {
#line 1493
            hp += 69001L;
          }
#line 1495
          i___1 = htab[hp];
#line 1495
          if (i___1 == fcode.code) {
#line 1496
            goto hfound;
          }
#line 1491
          if (! (i___1 != -1L)) {
#line 1491
            goto while_break___1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1529
      p___0 = & outbuf[outbits >> 3];
#line 1529
      i___2 = (long )fcode.e.ent << (outbits & 7);
#line 1529
      *(p___0 + 0) = (char_type )((int )*(p___0 + 0) | (int )((char_type )i___2));
#line 1529
      *(p___0 + 1) = (char_type )((int )*(p___0 + 1) | (int )((char_type )(i___2 >> 8)));
#line 1529
      *(p___0 + 2) = (char_type )((int )*(p___0 + 2) | (int )((char_type )(i___2 >> 16)));
#line 1529
      outbits += n_bits;
#line 1535
      fc = fcode.code;
#line 1537
      fcode.e.ent = (unsigned short )fcode.e.c;
#line 1540
      if (stcode) {
#line 1542
        tmp___1 = free_ent;
#line 1542
        free_ent ++;
#line 1542
        codetab[hp] = (unsigned short )tmp___1;
#line 1543
        htab[hp] = fc;
      }
#line 1547
      goto next;
      endlop: 
#line 1549
      if ((int )fcode.e.ent >= 257) {
#line 1549
        if (rpos < rsize) {
#line 1550
          goto next2;
        }
      }
#line 1552
      if (rpos > rlop) {
#line 1554
        bytes_in += (long )(rpos - rlop);
#line 1555
        rlop = rpos;
      }
#line 1386
      if (! (rlop < rsize)) {
#line 1386
        goto while_break___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1561
  if (rsize < 0) {
    {
    {
#line 1562
    read_error();
    }
    }
  }
#line 1564
  if (bytes_in > 0L) {
#line 1565
    p___1 = & outbuf[outbits >> 3];
#line 1565
    i___3 = (long )fcode.e.ent << (outbits & 7);
#line 1565
    *(p___1 + 0) = (char_type )((int )*(p___1 + 0) | (int )((char_type )i___3));
#line 1565
    *(p___1 + 1) = (char_type )((int )*(p___1 + 1) | (int )((char_type )(i___3 >> 8)));
#line 1565
    *(p___1 + 2) = (char_type )((int )*(p___1 + 2) | (int )((char_type )(i___3 >> 16)));
#line 1565
    outbits += n_bits;
  }
  {
  {
#line 1567
  tmp___2 = write(fdout, outbuf, (outbits + 7) >> 3);
  }
  }
#line 1567
  if (tmp___2 != (outbits + 7) >> 3) {
    {
    {
#line 1568
    write_error();
    }
    }
  }
#line 1570
  bytes_out += (long )((outbits + 7) >> 3);
#line 1572
  return;
}
}
#line 1582 "compress42.c"
void decompress(int fdin , int fdout ) 
{ 
  register char_type *stackp ;
  code_int code ;
  int finchar ;
  code_int oldcode ;
  code_int incode ;
  int inbits ;
  int posbits ;
  int outpos ;
  int insize ;
  int bitmask ;
  code_int free_ent ;
  code_int maxcode ;
  code_int maxmaxcode ;
  int n_bits ;
  int rsize ;
  char const   *tmp ;
  char const   *tmp___0 ;
  register int i ;
  int e ;
  int o ;
  register char_type *p ;
  int tmp___1 ;
  register char_type *p___0 ;
  register int i___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1603
  bytes_in = 0L;
#line 1604
  bytes_out = 0L;
#line 1605
  insize = 0;
  {
  {
#line 1607
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1607
    if (insize < 3) {
      {
      {
#line 1607
      rsize = read(fdin, inbuf + insize, 8192);
      }
      }
#line 1607
      if (! (rsize > 0)) {
#line 1607
        goto while_break;
      }
    } else {
#line 1607
      goto while_break;
    }
#line 1608
    insize += rsize;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1610
  if (insize < 3) {
#line 1610
    goto _L;
  } else
#line 1610
  if ((int )inbuf[0] != 31) {
#line 1610
    goto _L;
  } else
#line 1610
  if ((int )inbuf[1] != 157) {
    _L: /* CIL Label */ 
#line 1612
    if (rsize < 0) {
      {
      {
#line 1613
      read_error();
      }
      }
    }
#line 1615
    if (insize > 0) {
#line 1617
      if ((int )*(ifname + 0) != 0) {
#line 1617
        tmp = (char const   *)ifname;
      } else {
#line 1617
        tmp = "stdin";
      }
      {
      {
#line 1617
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not in compressed format\n",
              tmp);
      }
#line 1619
      exit_code = 1;
      }
    }
#line 1622
    return;
  }
#line 1625
  maxbits = (int )inbuf[2] & 31;
#line 1626
  block_mode = (int )inbuf[2] & 128;
#line 1627
  maxmaxcode = 1L << maxbits;
#line 1629
  if (maxbits > 16) {
#line 1631
    if ((int )*ifname != 0) {
#line 1631
      tmp___0 = (char const   *)ifname;
    } else {
#line 1631
      tmp___0 = "stdin";
    }
    {
    {
#line 1631
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: compressed with %d bits, can only handle %d bits\n",
            tmp___0, maxbits, 16);
    }
#line 1634
    exit_code = 4;
    }
#line 1635
    return;
  }
#line 1638
  bytes_in = (long )insize;
#line 1639
  n_bits = 9;
#line 1639
  maxcode = (1L << n_bits) - 1L;
#line 1640
  bitmask = (1 << n_bits) - 1;
#line 1641
  oldcode = (code_int )-1;
#line 1642
  finchar = 0;
#line 1643
  outpos = 0;
#line 1644
  posbits = 3 << 3;
#line 1646
  if (block_mode) {
#line 1646
    free_ent = (code_int )257;
  } else {
#line 1646
    free_ent = (code_int )256;
  }
  {
  {
#line 1648
  memset(codetab, 0, 256);
  }
#line 1651
  code = (code_int )255;
  }
  {
  {
#line 1651
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1651
    if (! (code >= 0L)) {
#line 1651
      goto while_break___0;
    }
#line 1652
    *((char_type *)(htab) + code) = (char_type )code;
#line 1651
    code --;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1654
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    resetbuf: 
#line 1662
    o = posbits >> 3;
#line 1662
    e = insize - o;
#line 1664
    i = 0;
    {
    {
#line 1664
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1664
      if (! (i < e)) {
#line 1664
        goto while_break___2;
      }
#line 1665
      inbuf[i] = inbuf[i + o];
#line 1664
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1667
    insize = e;
#line 1668
    posbits = 0;
#line 1671
    if ((unsigned long )insize < sizeof(inbuf) - 8192UL) {
      {
      {
#line 1673
      rsize = read(fdin, inbuf + insize, 8192);
      }
      }
#line 1673
      if (rsize < 0) {
        {
        {
#line 1674
        read_error();
        }
        }
      }
#line 1676
      insize += rsize;
    }
#line 1679
    if (rsize > 0) {
#line 1679
      inbits = (insize - insize % n_bits) << 3;
    } else {
#line 1679
      inbits = (insize << 3) - (n_bits - 1);
    }
    {
    {
#line 1682
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 1682
      if (! (inbits > posbits)) {
#line 1682
        goto while_break___3;
      }
#line 1684
      if (free_ent > maxcode) {
#line 1686
        posbits = (posbits - 1) + ((n_bits << 3) - ((posbits - 1) + (n_bits << 3)) % (n_bits << 3));
#line 1689
        n_bits ++;
#line 1690
        if (n_bits == maxbits) {
#line 1691
          maxcode = maxmaxcode;
        } else {
#line 1693
          maxcode = (1L << n_bits) - 1L;
        }
#line 1695
        bitmask = (1 << n_bits) - 1;
#line 1696
        goto resetbuf;
      }
#line 1699
      p = & inbuf[posbits >> 3];
#line 1699
      code = ((((long )*(p + 0) | ((long )*(p + 1) << 8)) | ((long )*(p + 2) << 16)) >> (posbits & 7)) & (long )bitmask;
#line 1699
      posbits += n_bits;
#line 1701
      if (oldcode == -1L) {
#line 1703
        tmp___1 = outpos;
#line 1703
        outpos ++;
#line 1703
        oldcode = code;
#line 1703
        finchar = (int )oldcode;
#line 1703
        outbuf[tmp___1] = (char_type )finchar;
#line 1704
        goto while_continue___3;
      }
#line 1707
      if (code == 256L) {
#line 1707
        if (block_mode) {
          {
          {
#line 1709
          memset(codetab, 0, 256);
          }
#line 1710
          free_ent = (code_int )256;
#line 1711
          posbits = (posbits - 1) + ((n_bits << 3) - ((posbits - 1) + (n_bits << 3)) % (n_bits << 3));
#line 1713
          n_bits = 9;
#line 1713
          maxcode = (1L << n_bits) - 1L;
#line 1714
          bitmask = (1 << n_bits) - 1;
          }
#line 1715
          goto resetbuf;
        }
      }
#line 1718
      incode = code;
#line 1719
      stackp = (char_type *)(& htab[69000]);
#line 1721
      if (code >= free_ent) {
#line 1723
        if (code > free_ent) {
          {
#line 1727
          posbits -= n_bits;
#line 1728
          p___0 = & inbuf[posbits >> 3];
          {
#line 1730
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"insize:%d posbits:%d inbuf:%02X %02X %02X %02X %02X (%d)\n",
                  insize, posbits, (int )*(p___0 + -1), (int )*(p___0 + 0), (int )*(p___0 + 1),
                  (int )*(p___0 + 2), (int )*(p___0 + 3), posbits & 7);
          }
          {
#line 1732
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"uncompress: corrupt input\n");
          }
          {
#line 1733
          abort_compress();
          }
          }
        }
#line 1736
        stackp --;
#line 1736
        *stackp = (char_type )finchar;
#line 1737
        code = oldcode;
      }
      {
      {
#line 1740
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 1740
        if (! (code >= 256L)) {
#line 1740
          goto while_break___4;
        }
#line 1742
        stackp --;
#line 1742
        *stackp = *((char_type *)(htab) + code);
#line 1743
        code = (code_int )codetab[code];
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1746
      stackp --;
#line 1746
      finchar = (int )*((char_type *)(htab) + code);
#line 1746
      *stackp = (char_type )finchar;
#line 1753
      i___0 = (int )((char_type *)(& htab[69000]) - stackp);
#line 1753
      if (outpos + i___0 >= 8192) {
        {
        {
#line 1755
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 1757
          if (i___0 > 8192 - outpos) {
#line 1757
            i___0 = 8192 - outpos;
          }
#line 1759
          if (i___0 > 0) {
            {
            {
#line 1761
            memcpy(outbuf + outpos, stackp, i___0);
            }
#line 1762
            outpos += i___0;
            }
          }
#line 1765
          if (outpos >= 8192) {
            {
            {
#line 1767
            tmp___2 = write(fdout, outbuf, outpos);
            }
            }
#line 1767
            if (tmp___2 != outpos) {
              {
              {
#line 1768
              write_error();
              }
              }
            }
#line 1770
            outpos = 0;
          }
#line 1772
          stackp += i___0;
#line 1755
          i___0 = (int )((char_type *)(& htab[69000]) - stackp);
#line 1755
          if (! (i___0 > 0)) {
#line 1755
            goto while_break___5;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 1778
        memcpy(outbuf + outpos, stackp, i___0);
        }
#line 1779
        outpos += i___0;
        }
      }
#line 1783
      code = free_ent;
#line 1783
      if (code < maxmaxcode) {
#line 1785
        codetab[code] = (unsigned short )oldcode;
#line 1786
        *((char_type *)(htab) + code) = (char_type )finchar;
#line 1787
        free_ent = code + 1L;
      }
#line 1790
      oldcode = incode;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1793
    bytes_in += (long )rsize;
#line 1654
    if (! (rsize > 0)) {
#line 1654
      goto while_break___1;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1797
  if (outpos > 0) {
    {
    {
#line 1797
    tmp___3 = write(fdout, outbuf, outpos);
    }
    }
#line 1797
    if (tmp___3 != outpos) {
      {
      {
#line 1798
      write_error();
      }
      }
    }
  }
#line 1799
  return;
}
}
#line 1801 "compress42.c"
char *rindex(char *s , int c ) 
{ 
  char *p ;

  {
#line 1808
  p = (char *)((void *)0);
  {
  {
#line 1808
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1808
    if (! *s) {
#line 1808
      goto while_break;
    }
#line 1809
    if ((int )*s == (int )((char )c)) {
#line 1810
      p = s;
    }
#line 1808
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1812
  return (p);
}
}
#line 1815 "compress42.c"
void read_error(void) 
{ 
  char const   *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 1818
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nread error on");
  }
  }
#line 1819
  if ((int )*(ifname + 0) != 0) {
#line 1819
    tmp = (char const   *)ifname;
  } else {
#line 1819
    tmp = "stdin";
  }
  {
  {
#line 1819
  perror(tmp);
  }
  {
#line 1820
  abort_compress();
  }
  }
#line 1821
  return;
}
}
#line 1823 "compress42.c"
void write_error(void) 
{ 
  char const   *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 1826
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nwrite error on");
  }
  }
#line 1827
  if ((int )ofname[0] != 0) {
#line 1827
    tmp = (char const   *)(ofname);
  } else {
#line 1827
    tmp = "stdout";
  }
  {
  {
#line 1827
  perror(tmp);
  }
  {
#line 1828
  abort_compress();
  }
  }
#line 1829
  return;
}
}
#line 1831 "compress42.c"
void abort_compress(void) 
{ 


  {
#line 1834
  if (remove_ofname) {
    {
    {
#line 1835
    unlink(ofname);
    }
    }
  }
  {
  {
#line 1837
  exit(1);
  }
  }
}
}
#line 1840 "compress42.c"
void prratio(FILE *stream , long num , long den ) 
{ 
  register int q ;
  char *__cil_tmp5 ;

  {
#line 1848
  if (den > 0L) {
#line 1850
    if (num > 214748L) {
#line 1851
      q = (int )(num / (den / 10000L));
    } else {
#line 1853
      q = (int )((10000L * num) / den);
    }
  } else {
#line 1856
    q = 10000;
  }
#line 1858
  if (q < 0) {
    {
    {
#line 1860
    _IO_putc('-', stream);
    }
#line 1861
    q = - q;
    }
  }
  {
  {
#line 1864
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%d.%02d%%",
          q / 100, q % 100);
  }
  }
#line 1865
  return;
}
}
#line 1867 "compress42.c"
void about(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1870
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compress version: %s, compiled: %s\n",
          ident + 4, "Dec  5 2014");
  }
  {
#line 1871
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compile options:\n        ");
  }
  {
#line 1905
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n        REGISTERS=%d IBUFSIZ=%d, OBUFSIZ=%d, BITS=%d\n",
          2, 8192, 8192, 16);
  }
  {
#line 1908
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAuthor version 4.2 (Speed improvement & source cleanup):\n     Peter Jannesen  (peter@ncs.nl)\n\nAuthor version 4.1 (Added recursive directory compress):\n     Dave Mack  (csu@alembic.acs.com)\n\nAuthors version 4.0 (World release in 1985):\n     Spencer W. Thomas, Jim McKie, Steve Davies,\n     Ken Turkowski, James A. Woods, Joe Orost\n");
  }
  {
#line 1919
  exit(0);
  }
  }
}
}
