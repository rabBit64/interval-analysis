/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/home/wslee/benchmarks/acpi-1.4/list.h"
struct list {
   void *data ;
   struct list *next ;
};
#line 28 "/home/wslee/benchmarks/acpi-1.4/list.h"
struct field {
   char *attr ;
   char *value ;
};
#line 51 "/home/wslee/benchmarks/acpi-1.4/acpi.h"
struct device {
   int type ;
   char *proc ;
   char *sys ;
   char *sys_dev ;
};
#line 119 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
struct file_list {
   char *file ;
   char *attr ;
};
#line 476 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
struct __anonstruct_trip_27 {
   float trip_temp ;
   char *trip_type ;
};
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 476 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
struct __anonstruct_trip_27___0 {
   float trip_temp ;
   char *trip_type ;
};
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 45 "/home/wslee/benchmarks/acpi-1.4/list.h"
struct list *list_append(struct list *node , void *data ) ;
#line 52
struct list *list_next(struct list *node ) ;
#line 66
void list_free(struct list *node ) ;
#line 51 "/home/wslee/benchmarks/acpi-1.4/acpi.h"
struct device device[4] ;
#line 59
struct list *find_devices(char *acpi_path , int device_nr , int proc_interface ) ;
#line 61
void free_devices(struct list *devices ) ;
#line 63
void print_battery_information(struct list *batteries , int show_empty_slots , int show_capacity ) ;
#line 65
void print_ac_adapter_information(struct list *ac_adapters , int show_empty_slots ) ;
#line 67
void print_thermal_information(struct list *thermal , int show_empty_slots , int temp_units ,
                               int show_trip_points ) ;
#line 69
void print_cooling_information(struct list *cooling , int show_empty_slots ) ;
#line 44 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static int ignore_directory_entry(struct dirent *de ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 46
  tmp = strcmp((char const   *)(de->d_name), ".");
  }
  }
#line 46
  if (tmp) {
    {
    {
#line 46
    tmp___0 = strcmp((char const   *)(de->d_name), "..");
    }
    }
#line 46
    if (tmp___0) {
#line 46
      tmp___1 = 0;
    } else {
#line 46
      tmp___1 = 1;
    }
  } else {
#line 46
    tmp___1 = 1;
  }
#line 46
  return (tmp___1);
}
}
#line 49 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct field *parse_field(char *buf , char *given_attr ) 
{ 
  struct field *rval ;
  char *p ;
  char *attr ;
  char *value ;
  int has_attr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 55
  has_attr = 0;
  {
#line 57
  tmp = calloc((size_t )1024, (size_t )sizeof(char ));
  }
#line 57
  attr = (char *)tmp;
  {
#line 58
  tmp___0 = calloc((size_t )1024, (size_t )sizeof(char ));
  }
#line 58
  value = (char *)tmp___0;
  {
#line 59
  tmp___1 = malloc((size_t )sizeof(struct field ));
  }
#line 59
  rval = (struct field *)tmp___1;
  }
#line 60
  if (! rval) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
    }
    {
#line 62
    exit(1);
    }
    }
  } else
#line 60
  if (! attr) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
    }
    {
#line 62
    exit(1);
    }
    }
  } else
#line 60
  if (! value) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
    }
    {
#line 62
    exit(1);
    }
    }
  }
#line 65
  p = buf;
#line 66
  if (! given_attr) {
    {
    {
#line 67
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 67
      tmp___2 = p;
#line 67
      p ++;
#line 67
      if (! *tmp___2) {
#line 67
        goto while_break;
      }
#line 68
      if ((int )*p == 58) {
        {
        {
#line 69
        strncpy((char */* __restrict  */)attr, (char const   */* __restrict  */)buf,
                (size_t )(p - buf));
        }
#line 70
        has_attr = 1;
        }
#line 71
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (! has_attr) {
      {
      {
#line 75
      free((void *)attr);
      }
      {
#line 76
      free((void *)value);
      }
      {
#line 77
      free((void *)rval);
      }
      }
#line 78
      return ((struct field *)((void *)0));
    }
#line 80
    if ((int )*p == 32) {
#line 81
      p ++;
    }
    {
    {
#line 82
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 82
      tmp___3 = p;
#line 82
      p ++;
#line 82
      if (! *tmp___3) {
#line 82
        goto while_break___0;
      }
#line 83
      if ((int )*p != 32) {
#line 84
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 87
    strncpy((char */* __restrict  */)attr, (char const   */* __restrict  */)given_attr,
            (size_t )1024);
    }
    }
  }
  {
  {
#line 89
  strncpy((char */* __restrict  */)value, (char const   */* __restrict  */)p, (size_t )1024);
  }
  {
#line 90
  tmp___5 = strlen((char const   *)attr);
  }
  }
#line 90
  if ((int )*(attr + (tmp___5 - 1U)) == 10) {
    {
    {
#line 91
    tmp___4 = strlen((char const   *)attr);
    }
#line 91
    *(attr + (tmp___4 - 1U)) = (char )'\000';
    }
  }
  {
  {
#line 92
  tmp___7 = strlen((char const   *)value);
  }
  }
#line 92
  if ((int )*(value + (tmp___7 - 1U)) == 10) {
    {
    {
#line 93
    tmp___6 = strlen((char const   *)value);
    }
#line 93
    *(value + (tmp___6 - 1U)) = (char )'\000';
    }
  }
#line 94
  rval->attr = attr;
#line 95
  rval->value = value;
#line 96
  return (rval);
}
}
#line 99 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct list *parse_info_file(struct list *l , char *filename , char *given_attr ) 
{ 
  FILE *fd ;
  char buf[1024] ;
  struct field *f ;
  char *tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 104
  fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
  }
#line 105
  if (! fd) {
#line 106
    return (l);
  }
  {
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 108
    tmp = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fd);
    }
    }
#line 108
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 108
      goto while_break;
    }
    {
    {
#line 110
    f = parse_field(buf, given_attr);
    }
    }
#line 111
    if (! f) {
#line 112
      goto while_continue;
    }
    {
    {
#line 113
    l = list_append(l, (void *)f);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 115
  fclose(fd);
  }
  }
#line 116
  return (l);
}
}
#line 124 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct file_list sys_list[25]  = 
#line 124
  {      {(char *)"current_now", (char *)"current_now"}, 
        {(char *)"charge_now", (char *)"charge_now"}, 
        {(char *)"energy_now", (char *)"energy_now"}, 
        {(char *)"voltage_now", (char *)"voltage_now"}, 
        {(char *)"voltage_min_design", (char *)"voltage_min_design"}, 
        {(char *)"charge_full", (char *)"charge_full"}, 
        {(char *)"energy_full", (char *)"energy_full"}, 
        {(char *)"charge_full_design", (char *)"charge_full_design"}, 
        {(char *)"energy_full_design", (char *)"energy_full_design"}, 
        {(char *)"online", (char *)"online"}, 
        {(char *)"status", (char *)"charging state"}, 
        {(char *)"type", (char *)"type"}, 
        {(char *)"temp", (char *)"sys_temp"}, 
        {(char *)"trip_point_0_type", (char *)"trip_point_0_type"}, 
        {(char *)"trip_point_0_temp", (char *)"trip_point_0_temp"}, 
        {(char *)"trip_point_1_type", (char *)"trip_point_1_type"}, 
        {(char *)"trip_point_1_temp", (char *)"trip_point_1_temp"}, 
        {(char *)"trip_point_2_type", (char *)"trip_point_2_type"}, 
        {(char *)"trip_point_2_temp", (char *)"trip_point_2_temp"}, 
        {(char *)"trip_point_3_type", (char *)"trip_point_3_type"}, 
        {(char *)"trip_point_3_temp", (char *)"trip_point_3_temp"}, 
        {(char *)"trip_point_4_type", (char *)"trip_point_4_type"}, 
        {(char *)"trip_point_4_temp", (char *)"trip_point_4_temp"}, 
        {(char *)"cur_state", (char *)"cur_state"}, 
        {(char *)"max_state", (char *)"max_state"}};
#line 152 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct file_list proc_list[5]  = {      {(char *)"state", (char *)((void *)0)}, 
        {(char *)"status", (char *)((void *)0)}, 
        {(char *)"info", (char *)((void *)0)}, 
        {(char *)"temperature", (char *)((void *)0)}, 
        {(char *)"cooling_mode", (char *)((void *)0)}};
#line 160 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct list *get_info(char *device_name , int proc_interface ) 
{ 
  struct list *rval ;
  struct file_list *list ;
  struct file_list *tmp ;
  int i ;
  int n ;
  unsigned long tmp___0 ;
  char *filename ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 162
  rval = (struct list *)((void *)0);
#line 163
  if (proc_interface) {
#line 163
    tmp = proc_list;
  } else {
#line 163
    tmp = sys_list;
  }
#line 163
  list = tmp;
#line 164
  if (proc_interface) {
#line 164
    tmp___0 = sizeof(proc_list);
  } else {
#line 164
    tmp___0 = sizeof(sys_list);
  }
  {
#line 164
  n = (int )(tmp___0 / sizeof(struct file_list ));
  {
#line 165
  tmp___1 = strlen((char const   *)device_name);
  }
  {
#line 165
  tmp___2 = strlen("/energy_full_design ");
  }
  {
#line 165
  tmp___3 = malloc(tmp___1 + tmp___2);
  }
#line 165
  filename = (char *)tmp___3;
  }
#line 167
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
    {
#line 168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in get_info.\n");
    }
    }
#line 169
    return ((struct list *)((void *)0));
  }
#line 172
  i = 0;
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 172
    if (! (i < n)) {
#line 172
      goto while_break;
    }
    {
    {
#line 173
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s/%s",
            device_name, (list + i)->file);
    }
    {
#line 174
    rval = parse_info_file(rval, filename, (list + i)->attr);
    }
#line 172
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (rval);
}
}
#line 180 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
void free_devices(struct list *devices ) 
{ 
  struct list *p ;
  struct list *r ;
  struct list *s ;
  struct field *f ;

  {
#line 185
  p = devices;
  {
  {
#line 186
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 186
    if (! p) {
#line 186
      goto while_break;
    }
#line 187
    s = (struct list *)p->data;
#line 187
    r = s;
    {
    {
#line 188
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! r) {
#line 188
        goto while_break___0;
      }
      {
#line 189
      f = (struct field *)r->data;
      {
#line 190
      free((void *)f->attr);
      }
      {
#line 191
      free((void *)f->value);
      }
      {
#line 192
      free((void *)f);
      }
#line 193
      r = r->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 195
    list_free(s);
    }
#line 196
    p = p->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 198
  list_free(devices);
  }
  }
#line 199
  return;
}
}
#line 201 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
struct list *find_devices(char *acpi_path , int device_nr , int proc_interface ) 
{ 
  DIR *d ;
  struct dirent *de ;
  struct list *device_info ;
  struct list *rval ;
  char *device_type ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 207
  rval = (struct list *)((void *)0);
#line 208
  if (proc_interface) {
#line 208
    tmp = device[device_nr].proc;
  } else {
#line 208
    tmp = device[device_nr].sys;
  }
  {
#line 208
  device_type = tmp;
  {
#line 210
  tmp___0 = chdir((char const   *)acpi_path);
  }
  }
#line 210
  if (tmp___0 < 0) {
    {
    {
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No ACPI support in kernel, or incorrect acpi_path (\"%s\").\n",
            acpi_path);
    }
    {
#line 212
    exit(1);
    }
    }
  }
  {
  {
#line 214
  tmp___1 = chdir((char const   *)device_type);
  }
  }
#line 214
  if (tmp___1 < 0) {
    {
    {
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No support for device type: %s\n",
            device_type);
    }
    }
#line 216
    return ((struct list *)((void *)0));
  }
  {
  {
#line 218
  d = opendir(".");
  }
  }
#line 219
  if (! d) {
#line 220
    return ((struct list *)((void *)0));
  }
  {
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 222
    de = readdir(d);
    }
    }
#line 222
    if (! de) {
#line 222
      goto while_break;
    }
    {
    {
#line 223
    tmp___2 = ignore_directory_entry(de);
    }
    }
#line 223
    if (tmp___2) {
#line 224
      goto while_continue;
    }
    {
    {
#line 226
    device_info = get_info(de->d_name, proc_interface);
    }
    }
#line 228
    if (device_info) {
      {
      {
#line 229
      rval = list_append(rval, (void *)device_info);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 231
  closedir(d);
  }
  }
#line 232
  return (rval);
}
}
#line 235 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static int get_unit_value(char *value ) 
{ 
  int n ;
  char *__cil_tmp3 ;

  {
  {
#line 237
  n = -1;
  {
#line 238
  sscanf((char const   */* __restrict  */)value, (char const   */* __restrict  */)"%d",
         & n);
  }
  }
#line 239
  return (n);
}
}
#line 242 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
void print_battery_information(struct list *batteries , int show_empty_slots , int show_capacity ) 
{ 
  struct list *battery ;
  struct list *fields ;
  struct field *value ;
  int battery_num ;
  int remaining_capacity ;
  int remaining_energy ;
  int present_rate ;
  int voltage ;
  int design_capacity ;
  int design_capacity_unit ;
  int last_capacity ;
  int last_capacity_unit ;
  int hours ;
  int minutes ;
  int seconds ;
  int percentage ;
  char *state ;
  char *poststr ;
  int type_battery ;
  char capacity_unit[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
#line 244
  battery = batteries;
#line 247
  battery_num = 1;
  {
  {
#line 249
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 249
    if (! battery) {
#line 249
      goto while_break;
    }
#line 250
    remaining_capacity = -1;
#line 251
    remaining_energy = -1;
#line 252
    present_rate = -1;
#line 253
    voltage = -1;
#line 254
    design_capacity = -1;
#line 255
    design_capacity_unit = -1;
#line 256
    last_capacity = -1;
#line 257
    last_capacity_unit = -1;
#line 260
    state = (char *)((void *)0);
#line 261
    type_battery = 1;
#line 262
    capacity_unit[0] = (char )'m';
#line 262
    capacity_unit[1] = (char )'A';
#line 262
    capacity_unit[2] = (char )'h';
#line 262
    capacity_unit[3] = (char )'\000';
#line 264
    fields = (struct list *)battery->data;
    {
    {
#line 265
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 265
      if (! fields) {
#line 265
        goto while_break___0;
      }
      {
#line 266
      value = (struct field *)fields->data;
      {
#line 267
      tmp___21 = strcasecmp((char const   *)value->attr, "remaining capacity");
      }
      }
#line 267
      if (tmp___21) {
        {
        {
#line 271
        tmp___20 = strcmp((char const   *)value->attr, "charge_now");
        }
        }
#line 271
        if (tmp___20) {
          {
          {
#line 275
          tmp___19 = strcmp((char const   *)value->attr, "energy_now");
          }
          }
#line 275
          if (tmp___19) {
            {
            {
#line 279
            tmp___18 = strcasecmp((char const   *)value->attr, "present rate");
            }
            }
#line 279
            if (tmp___18) {
              {
              {
#line 281
              tmp___17 = strcmp((char const   *)value->attr, "current_now");
              }
              }
#line 281
              if (tmp___17) {
                {
                {
#line 283
                tmp___16 = strcasecmp((char const   *)value->attr, "last full capacity");
                }
                }
#line 283
                if (tmp___16) {
                  {
                  {
#line 287
                  tmp___15 = strcmp((char const   *)value->attr, "charge_full");
                  }
                  }
#line 287
                  if (tmp___15) {
                    {
                    {
#line 291
                    tmp___14 = strcmp((char const   *)value->attr, "energy_full");
                    }
                    }
#line 291
                    if (tmp___14) {
                      {
                      {
#line 295
                      tmp___13 = strcmp((char const   *)value->attr, "charge_full_design");
                      }
                      }
#line 295
                      if (tmp___13) {
                        {
                        {
#line 297
                        tmp___12 = strcmp((char const   *)value->attr, "energy_full_design");
                        }
                        }
#line 297
                        if (tmp___12) {
                          {
                          {
#line 300
                          tmp___11 = strcmp((char const   *)value->attr, "type");
                          }
                          }
#line 300
                          if (tmp___11) {
                            {
                            {
#line 302
                            tmp___9 = strcmp((char const   *)value->attr, "charging state");
                            }
                            }
#line 302
                            if (tmp___9) {
                              {
                              {
#line 302
                              tmp___10 = strcmp((char const   *)value->attr, "State");
                              }
                              }
#line 302
                              if (tmp___10) {
                                {
                                {
#line 304
                                tmp___8 = strcmp((char const   *)value->attr, "voltage_now");
                                }
                                }
#line 304
                                if (! tmp___8) {
                                  {
                                  {
#line 305
                                  tmp___7 = get_unit_value(value->value);
                                  }
#line 305
                                  voltage = tmp___7 / 1000;
                                  }
#line 306
                                  if (! voltage) {
#line 307
                                    voltage = -1;
                                  }
                                }
                              } else {
#line 303
                                state = value->value;
                              }
                            } else {
#line 303
                              state = value->value;
                            }
                          } else {
                            {
                            {
#line 301
                            tmp___6 = strcasecmp((char const   *)value->value, "battery");
                            }
#line 301
                            type_battery = tmp___6 == 0;
                            }
                          }
                        } else {
                          {
                          {
#line 298
                          tmp___5 = get_unit_value(value->value);
                          }
#line 298
                          design_capacity_unit = tmp___5 / 1000;
                          }
                        }
                      } else {
                        {
                        {
#line 296
                        tmp___4 = get_unit_value(value->value);
                        }
#line 296
                        design_capacity = tmp___4 / 1000;
                        }
                      }
                    } else {
                      {
                      {
#line 292
                      tmp___3 = get_unit_value(value->value);
                      }
#line 292
                      last_capacity_unit = tmp___3 / 1000;
                      }
#line 293
                      if (! state) {
                        {
                        {
#line 294
                        state = strdup("available");
                        }
                        }
                      }
                    }
                  } else {
                    {
                    {
#line 288
                    tmp___2 = get_unit_value(value->value);
                    }
#line 288
                    last_capacity = tmp___2 / 1000;
                    }
#line 289
                    if (! state) {
                      {
                      {
#line 290
                      state = strdup("available");
                      }
                      }
                    }
                  }
                } else {
                  {
                  {
#line 284
                  last_capacity = get_unit_value(value->value);
                  }
                  }
#line 285
                  if (! state) {
                    {
                    {
#line 286
                    state = strdup("available");
                    }
                    }
                  }
                }
              } else {
                {
                {
#line 282
                tmp___1 = get_unit_value(value->value);
                }
#line 282
                present_rate = tmp___1 / 1000;
                }
              }
            } else {
              {
              {
#line 280
              present_rate = get_unit_value(value->value);
              }
              }
            }
          } else {
            {
            {
#line 276
            tmp___0 = get_unit_value(value->value);
            }
#line 276
            remaining_energy = tmp___0 / 1000;
            }
#line 277
            if (! state) {
              {
              {
#line 278
              state = strdup("available");
              }
              }
            }
          }
        } else {
          {
          {
#line 272
          tmp = get_unit_value(value->value);
          }
#line 272
          remaining_capacity = tmp / 1000;
          }
#line 273
          if (! state) {
            {
            {
#line 274
            state = strdup("available");
            }
            }
          }
        }
      } else {
        {
        {
#line 268
        remaining_capacity = get_unit_value(value->value);
        }
        }
#line 269
        if (! state) {
          {
          {
#line 270
          state = strdup("available");
          }
          }
        }
      }
      {
      {
#line 309
      fields = list_next(fields);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 311
    if (type_battery) {
#line 312
      if (! state) {
#line 313
        if (show_empty_slots) {
          {
          {
#line 314
          printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Battery",
                 battery_num - 1);
          }
          }
        }
      } else {
#line 317
        if (last_capacity_unit != -1) {
#line 317
          if (last_capacity == -1) {
#line 318
            if (voltage != -1) {
#line 319
              last_capacity = (last_capacity_unit * 1000) / voltage;
            } else {
              {
#line 321
              last_capacity = last_capacity_unit;
              {
#line 322
              strcpy((char */* __restrict  */)(capacity_unit), (char const   */* __restrict  */)"mWh");
              }
              }
            }
          }
        }
#line 325
        if (design_capacity_unit != -1) {
#line 325
          if (design_capacity == -1) {
#line 326
            if (voltage != -1) {
#line 327
              design_capacity = (design_capacity_unit * 1000) / voltage;
            } else {
              {
#line 329
              design_capacity = design_capacity_unit;
              {
#line 330
              strcpy((char */* __restrict  */)(capacity_unit), (char const   */* __restrict  */)"mWh");
              }
              }
            }
          }
        }
#line 333
        if (remaining_energy != -1) {
#line 333
          if (remaining_capacity == -1) {
#line 334
            if (voltage != -1) {
#line 335
              remaining_capacity = (remaining_energy * 1000) / voltage;
#line 336
              present_rate = (present_rate * 1000) / voltage;
            } else {
#line 338
              remaining_capacity = remaining_energy;
            }
          }
        }
#line 341
        if ((double )last_capacity < 0.01) {
#line 342
          percentage = 0;
        } else {
#line 344
          percentage = (remaining_capacity * 100) / last_capacity;
        }
#line 346
        if (percentage > 100) {
#line 347
          percentage = 100;
        }
        {
        {
#line 349
        printf((char const   */* __restrict  */)"%s %d: %s, %d%%", "Battery", battery_num - 1,
               state, percentage);
        }
        }
#line 351
        if (present_rate == -1) {
#line 352
          poststr = (char *)"rate information unavailable";
#line 353
          seconds = -1;
        } else {
          {
          {
#line 354
          tmp___23 = strcasecmp((char const   *)state, "charging");
          }
          }
#line 354
          if (tmp___23) {
            {
            {
#line 362
            tmp___22 = strcasecmp((char const   *)state, "discharging");
            }
            }
#line 362
            if (tmp___22) {
#line 371
              poststr = (char *)((void *)0);
#line 372
              seconds = -1;
            } else
#line 363
            if ((double )present_rate > 0.01) {
#line 364
              seconds = (3600 * remaining_capacity) / present_rate;
#line 365
              poststr = (char *)" remaining";
            } else {
#line 367
              poststr = (char *)"discharging at zero rate - will never fully discharge.";
#line 368
              seconds = -1;
            }
          } else
#line 355
          if ((double )present_rate > 0.01) {
#line 356
            seconds = (3600 * (last_capacity - remaining_capacity)) / present_rate;
#line 357
            poststr = (char *)" until charged";
          } else {
#line 359
            poststr = (char *)"charging at zero rate - will never fully charge.";
#line 360
            seconds = -1;
          }
        }
#line 375
        if (seconds > 0) {
          {
#line 376
          hours = seconds / 3600;
#line 377
          seconds -= 3600 * hours;
#line 378
          minutes = seconds / 60;
#line 379
          seconds -= 60 * minutes;
          {
#line 380
          printf((char const   */* __restrict  */)", %02d:%02d:%02d%s", hours, minutes,
                 seconds, poststr);
          }
          }
        } else
#line 381
        if ((unsigned long )poststr != (unsigned long )((void *)0)) {
          {
          {
#line 382
          printf((char const   */* __restrict  */)", %s", poststr);
          }
          }
        }
        {
        {
#line 385
        printf((char const   */* __restrict  */)"\n");
        }
        }
#line 387
        if (show_capacity) {
#line 387
          if (design_capacity > 0) {
#line 388
            if (last_capacity <= 100) {
#line 390
              percentage = last_capacity;
#line 391
              last_capacity = (percentage * design_capacity) / 100;
            } else {
#line 393
              percentage = (last_capacity * 100) / design_capacity;
            }
#line 395
            if (percentage > 100) {
#line 396
              percentage = 100;
            }
            {
            {
#line 398
            printf((char const   */* __restrict  */)"%s %d: design capacity %d %s, last full capacity %d %s = %d%%\n",
                   "Battery", battery_num - 1, design_capacity, capacity_unit, last_capacity,
                   capacity_unit, percentage);
            }
            }
          }
        }
      }
#line 402
      battery_num ++;
    }
    {
    {
#line 404
    battery = list_next(battery);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return;
}
}
#line 408 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
void print_ac_adapter_information(struct list *ac_adapters , int show_empty_slots ) 
{ 
  struct list *adapter ;
  struct list *fields ;
  struct field *value ;
  int adapter_num ;
  char *state ;
  int type_ac ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 410
  adapter = ac_adapters;
#line 413
  adapter_num = 1;
  {
  {
#line 415
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 415
    if (! adapter) {
#line 415
      goto while_break;
    }
#line 416
    state = (char *)((void *)0);
#line 417
    type_ac = 1;
#line 419
    fields = (struct list *)adapter->data;
    {
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 420
      if (! fields) {
#line 420
        goto while_break___0;
      }
      {
#line 421
      value = (struct field *)fields->data;
      {
#line 422
      tmp___4 = strcmp((char const   *)value->attr, "state");
      }
      }
#line 422
      if (tmp___4) {
        {
        {
#line 422
        tmp___5 = strcmp((char const   *)value->attr, "Status");
        }
        }
#line 422
        if (tmp___5) {
          {
          {
#line 424
          tmp___3 = strcmp((char const   *)value->attr, "online");
          }
          }
#line 424
          if (tmp___3) {
            {
            {
#line 426
            tmp___2 = strcmp((char const   *)value->attr, "type");
            }
            }
#line 426
            if (! tmp___2) {
              {
              {
#line 427
              tmp___1 = strcasecmp((char const   *)value->value, "mains");
              }
#line 427
              type_ac = tmp___1 == 0;
              }
            }
          } else {
            {
            {
#line 425
            tmp___0 = get_unit_value(value->value);
            }
            }
#line 425
            if (tmp___0) {
#line 425
              state = (char *)"on-line";
            } else {
#line 425
              state = (char *)"off-line";
            }
          }
        } else {
#line 423
          state = value->value;
        }
      } else {
#line 423
        state = value->value;
      }
      {
      {
#line 429
      fields = list_next(fields);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 431
    if (type_ac) {
#line 432
      if (! state) {
#line 433
        if (show_empty_slots) {
          {
          {
#line 434
          printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Adapter",
                 adapter_num - 1);
          }
          }
        }
      } else {
        {
        {
#line 436
        printf((char const   */* __restrict  */)"%s %d: %s\n", "Adapter", adapter_num - 1,
               state);
        }
        }
      }
#line 439
      adapter_num ++;
    }
    {
    {
#line 441
    adapter = list_next(adapter);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return;
}
}
#line 445 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static double get_real_temp(float temperature , char **scale , int temp_units ) 
{ 
  double real_temp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 447
  real_temp = (double )temperature;
  {
#line 450
  if (temp_units == 1) {
#line 450
    goto case_1;
  }
#line 453
  if (temp_units == 2) {
#line 453
    goto case_2;
  }
#line 458
  goto switch_default;
  case_1: /* CIL Label */ 
#line 451
  *scale = (char *)"degrees C";
#line 452
  goto switch_break;
  case_2: /* CIL Label */ 
#line 454
  real_temp = real_temp * 1.8 + (double )32;
#line 455
  *scale = (char *)"degrees F";
#line 456
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 459
  real_temp += 273.1;
#line 460
  *scale = (char *)"kelvin";
#line 461
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 463
  return (real_temp);
}
}
#line 466 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
void print_thermal_information(struct list *thermal , int show_empty_slots , int temp_units ,
                               int show_trip_points ) 
{ 
  struct list *sensor ;
  struct list *fields ;
  struct field *value ;
  int sensor_num ;
  int type_zone ;
  float temperature ;
  struct __anonstruct_trip_27 trip[5] ;
  char str[20] ;
  char *state ;
  char *scale ;
  double real_temp ;
  int i ;
  int trip_points ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp31 ;
  int __cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 468
  sensor = thermal;
#line 471
  sensor_num = 1;
#line 472
  type_zone = 1;
  {
  {
#line 474
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 474
    if (! sensor) {
#line 474
      goto while_break;
    }
    {
#line 475
    temperature = (float )-1;
#line 480
    str[0] = (char )'t';
#line 480
    str[1] = (char )'r';
#line 480
    str[2] = (char )'i';
#line 480
    str[3] = (char )'p';
#line 480
    str[4] = (char )'_';
#line 480
    str[5] = (char )'p';
#line 480
    str[6] = (char )'o';
#line 480
    str[7] = (char )'i';
#line 480
    str[8] = (char )'n';
#line 480
    str[9] = (char )'t';
#line 480
    str[10] = (char )'_';
#line 480
    str[11] = (char )'1';
#line 480
    str[12] = (char )'2';
#line 480
    str[13] = (char )'3';
#line 480
    str[14] = (char )'_';
#line 480
    str[15] = (char )'t';
#line 480
    str[16] = (char )'y';
#line 480
    str[17] = (char )'p';
#line 480
    str[18] = (char )'e';
#line 480
    str[19] = (char )'\000';
#line 481
    state = (char *)((void *)0);
#line 483
    trip_points = -1;
    {
#line 485
    memset((void *)(trip), (int )sizeof(trip), (size_t )0);
    }
#line 486
    fields = (struct list *)sensor->data;
    }
    {
    {
#line 487
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 487
      if (! fields) {
#line 487
        goto while_break___0;
      }
      {
#line 488
      value = (struct field *)fields->data;
      {
#line 489
      tmp___11 = strcmp((char const   *)value->attr, "state");
      }
      }
#line 489
      if (tmp___11) {
        {
        {
#line 491
        tmp___10 = strcmp((char const   *)value->attr, "type");
        }
        }
#line 491
        if (tmp___10) {
          {
          {
#line 495
          tmp___9 = strcmp((char const   *)value->attr, "temperature");
          }
          }
#line 495
          if (tmp___9) {
            {
            {
#line 501
            tmp___8 = strcmp((char const   *)value->attr, "sys_temp");
            }
            }
#line 501
            if (tmp___8) {
#line 506
              i = 0;
              {
              {
#line 506
              while (1) {
                while_continue___6: /* CIL Label */ ;
                while_continue___1: /* CIL Label */ ;
#line 506
                if (! (i < 5)) {
#line 506
                  goto while_break___1;
                }
                {
                {
#line 508
                sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"trip_point_%d_temp",
                        i);
                }
                {
#line 509
                tmp___6 = strcmp((char const   *)value->attr, (char const   *)(str));
                }
                }
#line 509
                if (! tmp___6) {
                  {
                  {
#line 510
                  tmp___5 = get_unit_value(value->value);
                  }
#line 510
                  trip[i].trip_temp = (float )((double )tmp___5 / 1000.0);
                  }
                }
                {
                {
#line 512
                sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"trip_point_%d_type",
                        i);
                }
                {
#line 513
                tmp___7 = strcmp((char const   *)value->attr, (char const   *)(str));
                }
                }
#line 513
                if (! tmp___7) {
#line 514
                  trip[i].trip_type = value->value;
#line 515
                  if (i > trip_points) {
#line 516
                    trip_points = i;
                  }
                }
#line 506
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
              {
              {
#line 502
              tmp___4 = get_unit_value(value->value);
              }
#line 502
              temperature = (float )((double )tmp___4 / 1000.0);
              }
#line 503
              if (! state) {
                {
                {
#line 504
                state = strdup("ok");
                }
                }
              }
            }
          } else {
            {
            {
#line 496
            tmp___2 = get_unit_value(value->value);
            }
#line 496
            temperature = (float )tmp___2;
            {
#line 497
            tmp___3 = strstr((char const   *)value->value, "dK");
            }
            }
#line 497
            if (tmp___3) {
#line 498
              temperature = (float )((double )(temperature / (float )10) - 273.1);
            }
#line 499
            if (! state) {
              {
              {
#line 500
              state = strdup("ok");
              }
              }
            }
          }
        } else {
          {
          {
#line 492
          tmp = strstr((char const   *)value->value, "thermal zone");
          }
          }
#line 492
          if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 492
            tmp___1 = 1;
          } else {
            {
            {
#line 492
            tmp___0 = strstr((char const   *)value->value, "acpitz");
            }
            }
#line 492
            if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 492
              tmp___1 = 1;
            } else {
#line 492
              tmp___1 = 0;
            }
          }
#line 492
          type_zone = tmp___1;
#line 493
          if (! state) {
            {
            {
#line 494
            state = strdup("ok");
            }
            }
          }
        }
      } else {
#line 490
        state = value->value;
      }
      {
      {
#line 520
      fields = list_next(fields);
      }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 522
    if (type_zone) {
#line 523
      i = 0;
      {
      {
#line 523
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 523
        if (! (i <= trip_points)) {
#line 523
          goto while_break___2;
        }
#line 525
        if (temperature >= trip[i].trip_temp) {
#line 525
          if ((double )trip[i].trip_temp >= 0.01) {
#line 526
            state = trip[i].trip_type;
#line 527
            goto while_break___2;
          }
        }
#line 523
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 530
      if (! state) {
#line 531
        if (show_empty_slots) {
          {
          {
#line 532
          printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Thermal",
                 sensor_num - 1);
          }
          }
        }
      } else {
        {
        {
#line 534
        real_temp = get_real_temp(temperature, & scale, temp_units);
        }
        {
#line 535
        printf((char const   */* __restrict  */)"%s %d: %s, %.1f %s\n", "Thermal",
               sensor_num - 1, state, real_temp, scale);
        }
        }
#line 536
        if (show_trip_points) {
#line 537
          i = 0;
          {
          {
#line 537
          while (1) {
            while_continue___8: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
#line 537
            if (! (i <= trip_points)) {
#line 537
              goto while_break___3;
            }
#line 539
            if ((double )trip[i].trip_temp >= 0.01) {
              {
              {
#line 540
              real_temp = get_real_temp(trip[i].trip_temp, & scale, temp_units);
              }
              {
#line 541
              printf((char const   */* __restrict  */)"%s %d: trip point %d switches to mode %s at temperature %.1f %s\n",
                     "Thermal", sensor_num - 1, i, trip[i].trip_type, real_temp, scale);
              }
              }
            }
#line 537
            i ++;
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
#line 547
      sensor_num ++;
    }
    {
    {
#line 549
    sensor = list_next(sensor);
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return;
}
}
#line 553 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
void print_cooling_information(struct list *cooling , int show_empty_slots ) 
{ 
  struct list *sensor ;
  struct list *fields ;
  struct field *value ;
  int sensor_num ;
  char *state ;
  char *type ;
  int cur_state ;
  int max_state ;
  int type_cooling ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 555
  sensor = cooling;
#line 558
  sensor_num = 1;
  {
  {
#line 560
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 560
    if (! sensor) {
#line 560
      goto while_break;
    }
#line 561
    state = (char *)((void *)0);
#line 561
    type = (char *)((void *)0);
#line 562
    cur_state = -1;
#line 562
    max_state = -1;
#line 563
    type_cooling = 1;
#line 565
    fields = (struct list *)sensor->data;
    {
    {
#line 566
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 566
      if (! fields) {
#line 566
        goto while_break___0;
      }
      {
#line 567
      value = (struct field *)fields->data;
      {
#line 568
      tmp___5 = strcmp((char const   *)value->attr, "status");
      }
      }
#line 568
      if (tmp___5) {
        {
        {
#line 570
        tmp___4 = strcmp((char const   *)value->attr, "type");
        }
        }
#line 570
        if (tmp___4) {
          {
          {
#line 573
          tmp___3 = strcmp((char const   *)value->attr, "cur_state");
          }
          }
#line 573
          if (tmp___3) {
            {
            {
#line 575
            tmp___2 = strcmp((char const   *)value->attr, "max_state");
            }
            }
#line 575
            if (! tmp___2) {
              {
              {
#line 576
              max_state = get_unit_value(value->value);
              }
              }
            }
          } else {
            {
            {
#line 574
            cur_state = get_unit_value(value->value);
            }
            }
          }
        } else {
          {
#line 571
          type = value->value;
          {
#line 572
          tmp = strstr((char const   *)type, "thermal zone");
          }
          }
#line 572
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
            {
            {
#line 572
            tmp___0 = strstr((char const   *)type, "acpitz");
            }
            }
#line 572
            if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 572
              tmp___1 = 1;
            } else {
#line 572
              tmp___1 = 0;
            }
          } else {
#line 572
            tmp___1 = 0;
          }
#line 572
          type_cooling = tmp___1;
        }
      } else {
#line 569
        state = value->value;
      }
      {
      {
#line 578
      fields = list_next(fields);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 580
    if (type_cooling) {
#line 581
      if (! state) {
#line 581
        if (! type) {
#line 582
          if (show_empty_slots) {
            {
            {
#line 583
            printf((char const   */* __restrict  */)"%s %d: slot empty\n", "Cooling",
                   sensor_num - 1);
            }
            }
          }
        } else {
#line 581
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 584
      if (state) {
        {
        {
#line 585
        printf((char const   */* __restrict  */)"%s %d: %s\n", "Cooling", sensor_num - 1,
               state);
        }
        }
      } else
#line 586
      if (cur_state < 0) {
        {
        {
#line 587
        printf((char const   */* __restrict  */)"%s %d: %s no state information available\n",
               "Cooling", sensor_num - 1, type);
        }
        }
      } else
#line 586
      if (max_state < 0) {
        {
        {
#line 587
        printf((char const   */* __restrict  */)"%s %d: %s no state information available\n",
               "Cooling", sensor_num - 1, type);
        }
        }
      } else {
        {
        {
#line 589
        printf((char const   */* __restrict  */)"%s %d: %s %d of %d\n", "Cooling",
               sensor_num - 1, type, cur_state, max_state);
        }
        }
      }
#line 592
      sensor_num ++;
    }
    {
    {
#line 595
    sensor = list_next(sensor);
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  return;
}
}
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 175
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 28 "/home/wslee/benchmarks/acpi-1.4/main.c"
struct device device[4]  = {      {0, (char *)"battery", (char *)"power_supply", (char *)"BAT"}, 
        {1, (char *)"ac_adapter", (char *)"power_supply", (char *)"AC"}, 
        {2, (char *)"thermal_zone", (char *)"thermal", (char *)"thermal_zone"}, 
        {3, (char *)"fan", (char *)"thermal", (char *)"cooling_device"}};
#line 35 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_batteries(char *acpi_path , int show_empty_slots , int show_details ,
                              int proc_interface ) 
{ 
  struct list *batteries ;

  {
  {
  {
#line 39
  batteries = find_devices(acpi_path, 0, proc_interface);
  }
  {
#line 40
  print_battery_information(batteries, show_empty_slots, show_details);
  }
  {
#line 41
  free_devices(batteries);
  }
  }
#line 42
  return;
}
}
#line 44 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_ac_adapter(char *acpi_path , int show_empty_slots , int proc_interface ) 
{ 
  struct list *ac_adapter ;

  {
  {
  {
#line 48
  ac_adapter = find_devices(acpi_path, 1, proc_interface);
  }
  {
#line 49
  print_ac_adapter_information(ac_adapter, show_empty_slots);
  }
  {
#line 50
  free_devices(ac_adapter);
  }
  }
#line 51
  return;
}
}
#line 53 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_thermal(char *acpi_path , int show_empty_slots , int temperature_units ,
                            int show_details , int proc_interface ) 
{ 
  struct list *thermal ;

  {
  {
  {
#line 56
  thermal = find_devices(acpi_path, 2, proc_interface);
  }
  {
#line 57
  print_thermal_information(thermal, show_empty_slots, temperature_units, show_details);
  }
  {
#line 58
  free_devices(thermal);
  }
  }
#line 59
  return;
}
}
#line 61 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_cooling(char *acpi_path , int show_empty_slots , int proc_interface ) 
{ 
  struct list *cooling ;

  {
  {
  {
#line 64
  cooling = find_devices(acpi_path, 3, proc_interface);
  }
  {
#line 65
  print_cooling_information(cooling, show_empty_slots);
  }
  {
#line 66
  free_devices(cooling);
  }
  }
#line 67
  return;
}
}
#line 69 "/home/wslee/benchmarks/acpi-1.4/main.c"
static int version(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 71
  printf((char const   */* __restrict  */)"acpi 1.4\n\nCopyright (C) 2001 Grahame Bowland.\n              2008 Michael Meskes.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
  }
#line 78
  return (1);
}
}
#line 81 "/home/wslee/benchmarks/acpi-1.4/main.c"
static int usage(char **argv ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 83
  printf((char const   */* __restrict  */)"Usage: acpi [OPTION]...\nShows information from the /proc filesystem, such as battery status or\nthermal information.\n\n  -b, --battery\t\tbattery information\n  -i, --details\t\tshow additional details if available:\n\t\t\t\t- battery capacity information\n\t\t\t\t- temperature trip points\n  -a, --ac-adapter\t\tac adapter information\n  -t, --thermal\t\tthermal information\n  -c, --cooling\t\tcooling information\n  -V, --everything\t\tshow every device, overrides above options\n  -s, --show-empty\t\tshow non-operational devices\n  -f, --fahrenheit\t\tuse fahrenheit as the temperature unit\n  -k, --kelvin\t\t\tuse kelvin as the temperature unit\n  -d, --directory <dir>\tpath to ACPI info (/sys/class resp. /proc/acpi)\n  -p, --proc\t\t\tuse old proc interface instead of new sys interface\n  -h, --help\t\t\tdisplay this help and exit\n  -v, --version\t\toutput version information and exit\n\nBy default, acpi displays information on installed system batteries.\nNon-operational devices, for example empty battery slots are hidden.\nThe default unit of temperature is degrees celsius.\n\nReport bugs to Michael Meskes <meskes@debian.org>.\n");
  }
  }
#line 110
  return (1);
}
}
#line 113 "/home/wslee/benchmarks/acpi-1.4/main.c"
static struct option long_options[16]  = 
#line 113
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"verbose", 0, (int *)0, 'V'}, 
        {"battery", 0, (int *)0, 'b'}, 
        {"ac-adapter", 0, (int *)0, 'a'}, 
        {"thermal", 0, (int *)0, 't'}, 
        {"cooling", 0, (int *)0, 'c'}, 
        {"show-empty", 0, (int *)0, 's'}, 
        {"hide-empty", 0, (int *)0, 'S'}, 
        {"fahrenheit", 0, (int *)0, 'f'}, 
        {"kelvin", 0, (int *)0, 'k'}, 
        {"directory", 1, (int *)0, 'd'}, 
        {"everything", 0, (int *)0, 'V'}, 
        {"proc", 0, (int *)0, 'p'}, 
        {"details", 0, (int *)0, 'i'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 132 "/home/wslee/benchmarks/acpi-1.4/main.c"
int main(int argc , char **argv ) 
{ 
  int show_batteries ;
  int show_ac_adapter ;
  int show_thermal ;
  int show_cooling ;
  int show_empty_slots ;
  int show_details ;
  int proc_interface ;
  int temperature_units ;
  int ch ;
  int option_index ;
  char *acpi_path ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 134
  show_batteries = 0;
#line 135
  show_ac_adapter = 0;
#line 136
  show_thermal = 0;
#line 137
  show_cooling = 0;
#line 138
  show_empty_slots = 0;
#line 139
  show_details = 0;
#line 140
  proc_interface = 0;
#line 141
  temperature_units = 1;
  {
#line 143
  tmp = strdup("/sys/class");
  }
#line 143
  acpi_path = tmp;
  }
#line 145
  if (! acpi_path) {
    {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in main()\n");
    }
    }
#line 147
    return (-1);
  }
  {
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 150
    ch = getopt_long(argc, (char * const  *)argv, "ipVbtashvfkcd:", (struct option  const  *)(long_options),
                     & option_index);
    }
    }
#line 150
    if (! (ch != -1)) {
#line 150
      goto while_break;
    }
    {
#line 152
    if (ch == 86) {
#line 152
      goto case_86;
    }
#line 155
    if (ch == 98) {
#line 155
      goto case_98;
    }
#line 158
    if (ch == 97) {
#line 158
      goto case_97;
    }
#line 161
    if (ch == 116) {
#line 161
      goto case_116;
    }
#line 164
    if (ch == 99) {
#line 164
      goto case_99;
    }
#line 167
    if (ch == 115) {
#line 167
      goto case_115;
    }
#line 170
    if (ch == 105) {
#line 170
      goto case_105;
    }
#line 173
    if (ch == 118) {
#line 173
      goto case_118;
    }
#line 176
    if (ch == 102) {
#line 176
      goto case_102;
    }
#line 179
    if (ch == 107) {
#line 179
      goto case_107;
    }
#line 182
    if (ch == 112) {
#line 182
      goto case_112;
    }
#line 191
    if (ch == 100) {
#line 191
      goto case_100;
    }
#line 200
    goto switch_default;
    case_86: /* CIL Label */ 
#line 153
    show_details = 1;
#line 153
    show_cooling = show_details;
#line 153
    show_thermal = show_cooling;
#line 153
    show_ac_adapter = show_thermal;
#line 153
    show_batteries = show_ac_adapter;
#line 154
    goto switch_break;
    case_98: /* CIL Label */ 
#line 156
    show_batteries = 1;
#line 157
    goto switch_break;
    case_97: /* CIL Label */ 
#line 159
    show_ac_adapter = 1;
#line 160
    goto switch_break;
    case_116: /* CIL Label */ 
#line 162
    show_thermal = 1;
#line 163
    goto switch_break;
    case_99: /* CIL Label */ 
#line 165
    show_cooling = 1;
#line 166
    goto switch_break;
    case_115: /* CIL Label */ 
#line 168
    show_empty_slots = 1;
#line 169
    goto switch_break;
    case_105: /* CIL Label */ 
#line 171
    show_details = 1;
#line 172
    goto switch_break;
    case_118: /* CIL Label */ 
    {
    {
#line 174
    tmp___0 = version();
    }
    }
#line 174
    return (tmp___0);
#line 175
    goto switch_break;
    case_102: /* CIL Label */ 
#line 177
    temperature_units = 2;
#line 178
    goto switch_break;
    case_107: /* CIL Label */ 
#line 180
    temperature_units = 0;
#line 181
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 183
    proc_interface = 1;
    {
#line 184
    free((void *)acpi_path);
    }
    {
#line 185
    acpi_path = strdup("/proc/acpi");
    }
    }
#line 186
    if (! acpi_path) {
      {
      {
#line 187
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in main()\n");
      }
      }
#line 188
      return (-1);
    }
#line 190
    goto switch_break;
    case_100: /* CIL Label */ 
    {
    {
#line 192
    free((void *)acpi_path);
    }
    {
#line 193
    acpi_path = strdup((char const   *)optarg);
    }
    }
#line 194
    if (! acpi_path) {
      {
      {
#line 195
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in main()\n");
      }
      }
#line 196
      return (-1);
    }
#line 198
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 201
    tmp___1 = usage(argv);
    }
    }
#line 201
    return (tmp___1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (! show_batteries) {
#line 206
    if (! show_ac_adapter) {
#line 206
      if (! show_thermal) {
#line 206
        if (! show_cooling) {
#line 207
          show_batteries = 1;
        }
      }
    }
  }
#line 209
  if (show_batteries) {
    {
    {
#line 210
    do_show_batteries(acpi_path, show_empty_slots, show_details, proc_interface);
    }
    }
  }
#line 212
  if (show_ac_adapter) {
    {
    {
#line 213
    do_show_ac_adapter(acpi_path, show_empty_slots, proc_interface);
    }
    }
  }
#line 215
  if (show_thermal) {
    {
    {
#line 216
    do_show_thermal(acpi_path, show_empty_slots, temperature_units, show_details,
                    proc_interface);
    }
    }
  }
#line 218
  if (show_cooling) {
    {
    {
#line 219
    do_show_cooling(acpi_path, show_empty_slots, proc_interface);
    }
    }
  }
#line 221
  return (0);
}
}
#line 44 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static int ignore_directory_entry___0(struct dirent *de ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 46
  tmp = strcmp((char const   *)(de->d_name), ".");
  }
  }
#line 46
  if (tmp) {
    {
    {
#line 46
    tmp___0 = strcmp((char const   *)(de->d_name), "..");
    }
    }
#line 46
    if (tmp___0) {
#line 46
      tmp___1 = 0;
    } else {
#line 46
      tmp___1 = 1;
    }
  } else {
#line 46
    tmp___1 = 1;
  }
#line 46
  return (tmp___1);
}
}
#line 49 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct field *parse_field___0(char *buf , char *given_attr ) 
{ 
  struct field *rval ;
  char *p ;
  char *attr ;
  char *value ;
  int has_attr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 55
  has_attr = 0;
  {
#line 57
  tmp = calloc((size_t )1024, (size_t )sizeof(char ));
  }
#line 57
  attr = (char *)tmp;
  {
#line 58
  tmp___0 = calloc((size_t )1024, (size_t )sizeof(char ));
  }
#line 58
  value = (char *)tmp___0;
  {
#line 59
  tmp___1 = malloc((size_t )sizeof(struct field ));
  }
#line 59
  rval = (struct field *)tmp___1;
  }
#line 60
  if (! rval) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
    }
    {
#line 62
    exit(1);
    }
    }
  } else
#line 60
  if (! attr) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
    }
    {
#line 62
    exit(1);
    }
    }
  } else
#line 60
  if (! value) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in parse_field.\n");
    }
    {
#line 62
    exit(1);
    }
    }
  }
#line 65
  p = buf;
#line 66
  if (! given_attr) {
    {
    {
#line 67
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 67
      tmp___2 = p;
#line 67
      p ++;
#line 67
      if (! *tmp___2) {
#line 67
        goto while_break;
      }
#line 68
      if ((int )*p == 58) {
        {
        {
#line 69
        strncpy((char */* __restrict  */)attr, (char const   */* __restrict  */)buf,
                (size_t )(p - buf));
        }
#line 70
        has_attr = 1;
        }
#line 71
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (! has_attr) {
      {
      {
#line 75
      free((void *)attr);
      }
      {
#line 76
      free((void *)value);
      }
      {
#line 77
      free((void *)rval);
      }
      }
#line 78
      return ((struct field *)((void *)0));
    }
#line 80
    if ((int )*p == 32) {
#line 81
      p ++;
    }
    {
    {
#line 82
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 82
      tmp___3 = p;
#line 82
      p ++;
#line 82
      if (! *tmp___3) {
#line 82
        goto while_break___0;
      }
#line 83
      if ((int )*p != 32) {
#line 84
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 87
    strncpy((char */* __restrict  */)attr, (char const   */* __restrict  */)given_attr,
            (size_t )1024);
    }
    }
  }
  {
  {
#line 89
  strncpy((char */* __restrict  */)value, (char const   */* __restrict  */)p, (size_t )1024);
  }
  {
#line 90
  tmp___5 = strlen((char const   *)attr);
  }
  }
#line 90
  if ((int )*(attr + (tmp___5 - 1U)) == 10) {
    {
    {
#line 91
    tmp___4 = strlen((char const   *)attr);
    }
#line 91
    *(attr + (tmp___4 - 1U)) = (char )'\000';
    }
  }
  {
  {
#line 92
  tmp___7 = strlen((char const   *)value);
  }
  }
#line 92
  if ((int )*(value + (tmp___7 - 1U)) == 10) {
    {
    {
#line 93
    tmp___6 = strlen((char const   *)value);
    }
#line 93
    *(value + (tmp___6 - 1U)) = (char )'\000';
    }
  }
#line 94
  rval->attr = attr;
#line 95
  rval->value = value;
#line 96
  return (rval);
}
}
#line 99 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct list *parse_info_file___0(struct list *l , char *filename , char *given_attr ) 
{ 
  FILE *fd ;
  char buf[1024] ;
  struct field *f ;
  char *tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 104
  fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
  }
#line 105
  if (! fd) {
#line 106
    return (l);
  }
  {
  {
#line 108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 108
    tmp = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fd);
    }
    }
#line 108
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 108
      goto while_break;
    }
    {
    {
#line 110
    f = parse_field___0(buf, given_attr);
    }
    }
#line 111
    if (! f) {
#line 112
      goto while_continue;
    }
    {
    {
#line 113
    l = list_append(l, (void *)f);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 115
  fclose(fd);
  }
  }
#line 116
  return (l);
}
}
#line 124 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct file_list sys_list___0[25]  = 
#line 124
  {      {(char *)"current_now", (char *)"current_now"}, 
        {(char *)"charge_now", (char *)"charge_now"}, 
        {(char *)"energy_now", (char *)"energy_now"}, 
        {(char *)"voltage_now", (char *)"voltage_now"}, 
        {(char *)"voltage_min_design", (char *)"voltage_min_design"}, 
        {(char *)"charge_full", (char *)"charge_full"}, 
        {(char *)"energy_full", (char *)"energy_full"}, 
        {(char *)"charge_full_design", (char *)"charge_full_design"}, 
        {(char *)"energy_full_design", (char *)"energy_full_design"}, 
        {(char *)"online", (char *)"online"}, 
        {(char *)"status", (char *)"charging state"}, 
        {(char *)"type", (char *)"type"}, 
        {(char *)"temp", (char *)"sys_temp"}, 
        {(char *)"trip_point_0_type", (char *)"trip_point_0_type"}, 
        {(char *)"trip_point_0_temp", (char *)"trip_point_0_temp"}, 
        {(char *)"trip_point_1_type", (char *)"trip_point_1_type"}, 
        {(char *)"trip_point_1_temp", (char *)"trip_point_1_temp"}, 
        {(char *)"trip_point_2_type", (char *)"trip_point_2_type"}, 
        {(char *)"trip_point_2_temp", (char *)"trip_point_2_temp"}, 
        {(char *)"trip_point_3_type", (char *)"trip_point_3_type"}, 
        {(char *)"trip_point_3_temp", (char *)"trip_point_3_temp"}, 
        {(char *)"trip_point_4_type", (char *)"trip_point_4_type"}, 
        {(char *)"trip_point_4_temp", (char *)"trip_point_4_temp"}, 
        {(char *)"cur_state", (char *)"cur_state"}, 
        {(char *)"max_state", (char *)"max_state"}};
#line 152 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct file_list proc_list___0[5]  = {      {(char *)"state", (char *)((void *)0)}, 
        {(char *)"status", (char *)((void *)0)}, 
        {(char *)"info", (char *)((void *)0)}, 
        {(char *)"temperature", (char *)((void *)0)}, 
        {(char *)"cooling_mode", (char *)((void *)0)}};
#line 160 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static struct list *get_info___0(char *device_name , int proc_interface ) 
{ 
  struct list *rval ;
  struct file_list *list ;
  struct file_list *tmp ;
  int i ;
  int n ;
  unsigned long tmp___0 ;
  char *filename ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 162
  rval = (struct list *)((void *)0);
#line 163
  if (proc_interface) {
#line 163
    tmp = proc_list___0;
  } else {
#line 163
    tmp = sys_list___0;
  }
#line 163
  list = tmp;
#line 164
  if (proc_interface) {
#line 164
    tmp___0 = sizeof(proc_list___0);
  } else {
#line 164
    tmp___0 = sizeof(sys_list___0);
  }
  {
#line 164
  n = (int )(tmp___0 / sizeof(struct file_list ));
  {
#line 165
  tmp___1 = strlen((char const   *)device_name);
  }
  {
#line 165
  tmp___2 = strlen("/energy_full_design ");
  }
  {
#line 165
  tmp___3 = malloc(tmp___1 + tmp___2);
  }
#line 165
  filename = (char *)tmp___3;
  }
#line 167
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
    {
    {
#line 168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in get_info.\n");
    }
    }
#line 169
    return ((struct list *)((void *)0));
  }
#line 172
  i = 0;
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 172
    if (! (i < n)) {
#line 172
      goto while_break;
    }
    {
    {
#line 173
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s/%s",
            device_name, (list + i)->file);
    }
    {
#line 174
    rval = parse_info_file___0(rval, filename, (list + i)->attr);
    }
#line 172
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (rval);
}
}
#line 235 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static int get_unit_value___0(char *value ) 
{ 
  int n ;
  char *__cil_tmp3 ;

  {
  {
#line 237
  n = -1;
  {
#line 238
  sscanf((char const   */* __restrict  */)value, (char const   */* __restrict  */)"%d",
         & n);
  }
  }
#line 239
  return (n);
}
}
#line 445 "/home/wslee/benchmarks/acpi-1.4/acpi.c"
static double get_real_temp___0(float temperature , char **scale , int temp_units ) 
{ 
  double real_temp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 447
  real_temp = (double )temperature;
  {
#line 450
  if (temp_units == 1) {
#line 450
    goto case_1;
  }
#line 453
  if (temp_units == 2) {
#line 453
    goto case_2;
  }
#line 458
  goto switch_default;
  case_1: /* CIL Label */ 
#line 451
  *scale = (char *)"degrees C";
#line 452
  goto switch_break;
  case_2: /* CIL Label */ 
#line 454
  real_temp = real_temp * 1.8 + (double )32;
#line 455
  *scale = (char *)"degrees F";
#line 456
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 459
  real_temp += 273.1;
#line 460
  *scale = (char *)"kelvin";
#line 461
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 463
  return (real_temp);
}
}
#line 38 "/home/wslee/benchmarks/acpi-1.4/list.h"
struct list *list_new(void *data ) ;
#line 59
unsigned int list_length(struct list *node ) ;
#line 24 "/home/wslee/benchmarks/acpi-1.4/list.c"
struct list *list_new(void *data ) 
{ 
  struct list *r ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 28
  tmp = malloc((size_t )sizeof(struct list ));
  }
#line 28
  r = (struct list *)tmp;
  }
#line 29
  if (! r) {
    {
    {
#line 30
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory. Could not allocate memory in list_new_node.\n");
    }
    {
#line 31
    exit(1);
    }
    }
  }
#line 33
  r->data = data;
#line 34
  r->next = (struct list *)((void *)0);
#line 35
  return (r);
}
}
#line 38 "/home/wslee/benchmarks/acpi-1.4/list.c"
struct list *list_append(struct list *node , void *data ) 
{ 
  struct list *r ;

  {
  {
  {
#line 42
  r = list_new(data);
  }
#line 43
  r->next = node;
  }
#line 44
  return (r);
}
}
#line 47 "/home/wslee/benchmarks/acpi-1.4/list.c"
struct list *list_next(struct list *node ) 
{ 


  {
#line 49
  return (node->next);
}
}
#line 52 "/home/wslee/benchmarks/acpi-1.4/list.c"
unsigned int list_length(struct list *node ) 
{ 
  unsigned int l ;

  {
#line 54
  l = 0U;
  {
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 55
    if (! node) {
#line 55
      goto while_break;
    }
#line 56
    l ++;
#line 57
    node = node->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return (l);
}
}
#line 62 "/home/wslee/benchmarks/acpi-1.4/list.c"
void list_free(struct list *node ) 
{ 
  struct list *p ;
  struct list *next ;

  {
#line 65
  p = node;
  {
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 66
    if (! p) {
#line 66
      goto while_break;
    }
    {
#line 67
    next = p->next;
    {
#line 68
    free((void *)p);
    }
#line 69
    p = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 35 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_batteries___0(char *acpi_path , int show_empty_slots , int show_details ,
                                  int proc_interface ) 
{ 
  struct list *batteries ;

  {
  {
  {
#line 39
  batteries = find_devices(acpi_path, 0, proc_interface);
  }
  {
#line 40
  print_battery_information(batteries, show_empty_slots, show_details);
  }
  {
#line 41
  free_devices(batteries);
  }
  }
#line 42
  return;
}
}
#line 44 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_ac_adapter___0(char *acpi_path , int show_empty_slots , int proc_interface ) 
{ 
  struct list *ac_adapter ;

  {
  {
  {
#line 48
  ac_adapter = find_devices(acpi_path, 1, proc_interface);
  }
  {
#line 49
  print_ac_adapter_information(ac_adapter, show_empty_slots);
  }
  {
#line 50
  free_devices(ac_adapter);
  }
  }
#line 51
  return;
}
}
#line 53 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_thermal___0(char *acpi_path , int show_empty_slots , int temperature_units ,
                                int show_details , int proc_interface ) 
{ 
  struct list *thermal ;

  {
  {
  {
#line 56
  thermal = find_devices(acpi_path, 2, proc_interface);
  }
  {
#line 57
  print_thermal_information(thermal, show_empty_slots, temperature_units, show_details);
  }
  {
#line 58
  free_devices(thermal);
  }
  }
#line 59
  return;
}
}
#line 61 "/home/wslee/benchmarks/acpi-1.4/main.c"
static void do_show_cooling___0(char *acpi_path , int show_empty_slots , int proc_interface ) 
{ 
  struct list *cooling ;

  {
  {
  {
#line 64
  cooling = find_devices(acpi_path, 3, proc_interface);
  }
  {
#line 65
  print_cooling_information(cooling, show_empty_slots);
  }
  {
#line 66
  free_devices(cooling);
  }
  }
#line 67
  return;
}
}
#line 69 "/home/wslee/benchmarks/acpi-1.4/main.c"
static int version___0(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 71
  printf((char const   */* __restrict  */)"acpi 1.4\n\nCopyright (C) 2001 Grahame Bowland.\n              2008 Michael Meskes.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
  }
#line 78
  return (1);
}
}
#line 81 "/home/wslee/benchmarks/acpi-1.4/main.c"
static int usage___0(char **argv ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 83
  printf((char const   */* __restrict  */)"Usage: acpi [OPTION]...\nShows information from the /proc filesystem, such as battery status or\nthermal information.\n\n  -b, --battery\t\tbattery information\n  -i, --details\t\tshow additional details if available:\n\t\t\t\t- battery capacity information\n\t\t\t\t- temperature trip points\n  -a, --ac-adapter\t\tac adapter information\n  -t, --thermal\t\tthermal information\n  -c, --cooling\t\tcooling information\n  -V, --everything\t\tshow every device, overrides above options\n  -s, --show-empty\t\tshow non-operational devices\n  -f, --fahrenheit\t\tuse fahrenheit as the temperature unit\n  -k, --kelvin\t\t\tuse kelvin as the temperature unit\n  -d, --directory <dir>\tpath to ACPI info (/sys/class resp. /proc/acpi)\n  -p, --proc\t\t\tuse old proc interface instead of new sys interface\n  -h, --help\t\t\tdisplay this help and exit\n  -v, --version\t\toutput version information and exit\n\nBy default, acpi displays information on installed system batteries.\nNon-operational devices, for example empty battery slots are hidden.\nThe default unit of temperature is degrees celsius.\n\nReport bugs to Michael Meskes <meskes@debian.org>.\n");
  }
  }
#line 110
  return (1);
}
}
#line 113 "/home/wslee/benchmarks/acpi-1.4/main.c"
static struct option long_options___0[16]  = 
#line 113
  {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"verbose", 0, (int *)0, 'V'}, 
        {"battery", 0, (int *)0, 'b'}, 
        {"ac-adapter", 0, (int *)0, 'a'}, 
        {"thermal", 0, (int *)0, 't'}, 
        {"cooling", 0, (int *)0, 'c'}, 
        {"show-empty", 0, (int *)0, 's'}, 
        {"hide-empty", 0, (int *)0, 'S'}, 
        {"fahrenheit", 0, (int *)0, 'f'}, 
        {"kelvin", 0, (int *)0, 'k'}, 
        {"directory", 1, (int *)0, 'd'}, 
        {"everything", 0, (int *)0, 'V'}, 
        {"proc", 0, (int *)0, 'p'}, 
        {"details", 0, (int *)0, 'i'}, 
        {(char const   *)0, 0, (int *)0, 0}};
