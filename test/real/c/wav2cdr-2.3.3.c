/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 169 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef unsigned short UINT16;
#line 179 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef short SINT16;
#line 183 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef long SINT32;
#line 215
enum __anonenum_BOOL_8 {
    FALSE = 0,
    TRUE = 1
} ;
#line 215 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef enum __anonenum_BOOL_8 BOOL;
#line 264 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
enum __anonenum_monostereo_t_17 {
    MS_NONE = 0,
    MS_TOMONO = 1,
    MS_TOSTEREO = 2,
    MS_TOMONOSTEREO = 3
} ;
#line 264 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef enum __anonenum_monostereo_t_17 monostereo_t;
#line 270 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef unsigned long cdseccount_t;
#line 276 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
struct __anonstruct_process_t_18 {
   size_t n_in ;
   size_t n_returned ;
   BOOL first ;
   BOOL last ;
   BOOL little_host ;
   BOOL from_little ;
   BOOL to_little ;
   short iscale ;
   float fscale ;
   BOOL swap_channels ;
   monostereo_t monostereo ;
   BOOL silencecuts ;
   unsigned short silence_thresh ;
   unsigned short silence_delay ;
   BOOL silence_val ;
   cdseccount_t fadein ;
   cdseccount_t fadeout ;
};
#line 276 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef struct __anonstruct_process_t_18 process_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 160 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef char string;
#line 168 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef unsigned char byte;
#line 174 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef unsigned long UINT32;
#line 66 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
struct __anonstruct_wav_chunkheader_t_11 {
   char id[4] ;
   UINT32 size ;
};
#line 66 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef struct __anonstruct_wav_chunkheader_t_11 wav_chunkheader_t;
#line 72 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
struct __anonstruct_wav_header_t_12 {
   wav_chunkheader_t RIFF ;
   char wavename[4] ;
   wav_chunkheader_t Format ;
   UINT16 FormatTag ;
   UINT16 channels ;
   UINT32 SamplingRate ;
   UINT32 AvgBytesPerSec ;
   UINT16 BlockAlignment ;
   UINT16 BitsPerSample ;
   wav_chunkheader_t Data ;
};
#line 72 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef struct __anonstruct_wav_header_t_12 wav_header_t;
#line 179
enum __anonenum_exit_t_14 {
    ERR_OK = 0,
    ERR_USAGE = 1,
    ERR_CMDARG = 2,
    ERR_IO = 3,
    ERR_NOMEM = 4,
    ERR_INTERNAL = 5
} ;
#line 179 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef enum __anonenum_exit_t_14 exit_t;
#line 197
enum __anonenum_audioformat_t_15 {
    AF_default = 0,
    AF_raw = 1,
    AF_cdr = 2,
    AF_wav = 3,
    AF_err = 4
} ;
#line 197 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef enum __anonenum_audioformat_t_15 audioformat_t;
#line 203 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
struct __anonstruct_cmdarg_t_16 {
   BOOL little_input ;
   BOOL little_output ;
   long iscale ;
   float fscale ;
   BOOL swapwords ;
   BOOL monostereo ;
   BOOL silencecuts ;
   BOOL silenceinfo ;
   long silence_thresh ;
   long silence_delay ;
   unsigned long fadein ;
   unsigned long fadeout ;
   audioformat_t informat ;
   audioformat_t outformat ;
   unsigned long startsilence ;
   unsigned long endsilence ;
   string *infilename ;
   string *outfilename ;
   int numcuts ;
   string **cutstarts ;
   BOOL version ;
   BOOL usage ;
   BOOL help ;
   BOOL quiet ;
   BOOL verbose ;
};
#line 203 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef struct __anonstruct_cmdarg_t_16 cmdarg_t;
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 168 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/chelp.h"
typedef unsigned char UINT8;
#line 171 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
union __anonunion_audiosect_t_13 {
   UINT8 i8[2352] ;
   SINT16 i16[1176] ;
   UINT32 i32[588] ;
};
#line 171 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
typedef union __anonunion_audiosect_t_13 audiosect_t;
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 83 "/usr/include/wchar.h"
union __anonunion___value_5 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 83 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_4 {
   int __count ;
   union __anonunion___value_5 __value ;
};
#line 83 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_4 __mbstate_t;
#line 22 "/usr/include/_G_config.h"
struct __anonstruct__G_fpos_t_6 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 22 "/usr/include/_G_config.h"
typedef struct __anonstruct__G_fpos_t_6 _G_fpos_t;
#line 91 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 372 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
void process_swap_bytes(void *buf , process_t *pinfo ) ;
#line 373
void process_swap_words(void *buf , process_t *pinfo ) ;
#line 374
void process_swap_tolocal(void *buf , process_t *pinfo ) ;
#line 375
void process_swap_totarget(void *buf , process_t *pinfo ) ;
#line 376
void process_tomono(void *buf , process_t *pinfo ) ;
#line 377
void process_tostereo(void *buf , process_t *pinfo ) ;
#line 378
void process_tomonostereo(void *buf , process_t *pinfo ) ;
#line 379
void process_swap_iscale(void *buf , process_t *pinfo ) ;
#line 380
void process_swap_fscale(void *buf , process_t *pinfo ) ;
#line 381
void process_swap_noscale(void *buf , process_t *pinfo ) ;
#line 382
void process_fading(void *buf , process_t *pinfo ) ;
#line 383
void process_silencecuts(void *buf , process_t *pinfo ) ;
#line 384
void process_sector(void *buf , process_t *pinfo ) ;
#line 71 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static BOOL is_silent_sector(void *buf , process_t const   *pinfo ) ;
#line 104 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_bytes(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 109
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 109
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  109U, "process_swap_bytes");
    }
    }
  }
#line 112
  i = (size_t )0;
  {
  {
#line 112
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 112
    if (! (i < pinfo->n_in / 2U)) {
#line 112
      goto while_break;
    }
#line 113
    *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 112
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return;
}
}
#line 128 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_words(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 133
  if (! ((pinfo->n_in & 3U) == 0U)) {
    {
    {
#line 133
    __assert_fail("(pinfo->n_in & 0x3) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  133U, "process_swap_words");
    }
    }
  }
#line 136
  i = (size_t )0;
  {
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < pinfo->n_in / 4U)) {
#line 136
      goto while_break;
    }
#line 137
    *((SINT32 *)buf + i) = (SINT32 )(((unsigned long )(*((SINT32 *)buf + i) >> 16) & 65535UL) | (unsigned long )(*((SINT32 *)buf + i) << 16));
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 152 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_tolocal(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 157
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 157
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  157U, "process_swap_tolocal");
    }
    }
  }
#line 160
  if ((unsigned int )pinfo->from_little != (unsigned int )pinfo->little_host) {
#line 161
    i = (size_t )0;
    {
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 161
      if (! (i < pinfo->n_in / 2U)) {
#line 161
        goto while_break;
      }
#line 162
      *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 161
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 164
  return;
}
}
#line 177 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_totarget(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 182
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 182
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  182U, "process_swap_totarget");
    }
    }
  }
#line 185
  if ((unsigned int )pinfo->to_little != (unsigned int )pinfo->little_host) {
#line 186
    i = (size_t )0;
    {
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 186
      if (! (i < pinfo->n_in / 2U)) {
#line 186
        goto while_break;
      }
#line 187
      *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 186
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 189
  return;
}
}
#line 202 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_tomono(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 207
  if (! ((pinfo->n_in & 3U) == 0U)) {
    {
    {
#line 207
    __assert_fail("(pinfo->n_in & 0x3) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  207U, "process_tomono");
    }
    }
  }
#line 210
  i = (size_t )0;
  {
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < pinfo->n_in / 4U)) {
#line 210
      goto while_break;
    }
#line 211
    *((SINT16 *)buf + i) = (SINT16 )(((SINT32 )*((SINT16 *)buf + 2U * i) + (SINT32 )*((SINT16 *)buf + (2U * i + 1U))) / 2L);
#line 210
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  pinfo->n_returned = pinfo->n_in / 2U;
#line 216
  return;
}
}
#line 230 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_tostereo(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 235
  if (! ((pinfo->n_in & 3U) == 0U)) {
    {
    {
#line 235
    __assert_fail("(pinfo->n_in & 0x3) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  235U, "process_tostereo");
    }
    }
  }
#line 238
  i = pinfo->n_in / 4U;
#line 239
  pinfo->n_returned = (size_t )0;
#line 240
  if (i == 0U) {
#line 240
    return;
  }
  {
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 243
    i --;
#line 244
    *((SINT16 *)buf + (2U * i + 1U)) = *((SINT16 *)buf + i);
#line 245
    *((SINT16 *)buf + 2U * i) = *((SINT16 *)buf + i);
#line 242
    if (! (! (i == 0U))) {
#line 242
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  pinfo->n_returned = pinfo->n_in * 2U;
#line 250
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_tomonostereo(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  SINT16 tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 268
  if (! ((pinfo->n_in & 3U) == 0U)) {
    {
    {
#line 268
    __assert_fail("(pinfo->n_in & 0x3) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  268U, "process_tomonostereo");
    }
    }
  }
#line 270
  i = (size_t )0;
  {
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 270
    if (! (i < pinfo->n_in / 2U)) {
#line 270
      goto while_break;
    }
#line 271
    tmp = (SINT16 )(((SINT32 )*((SINT16 *)buf + i) + (SINT32 )*((SINT16 *)buf + (i + 1U))) / 2L);
#line 271
    *((SINT16 *)buf + (i + 1U)) = tmp;
#line 271
    *((SINT16 *)buf + i) = tmp;
#line 270
    i += 2U;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return;
}
}
#line 291 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_iscale(void *buf , process_t *pinfo ) 
{ 
  long si32 ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 297
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 297
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  297U, "process_swap_iscale");
    }
    }
  }
#line 300
  if (((unsigned int )pinfo->from_little != 0U) ^ ((unsigned int )pinfo->little_host != 0U)) {
#line 302
    if (((unsigned int )pinfo->to_little != 0U) ^ ((unsigned int )pinfo->little_host != 0U)) {
#line 304
      i = (size_t )0;
      {
      {
#line 304
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 304
        if (! (i < pinfo->n_in / 2U)) {
#line 304
          goto while_break;
        }
#line 305
        si32 = (long )pinfo->iscale * (long )((short )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8)));
#line 307
        si32 /= 100L;
#line 308
        if (si32 > 32767L) {
#line 308
          *((SINT16 *)buf + i) = (SINT16 )32767;
        } else {
#line 308
          if (si32 < -32768L) {
#line 308
            tmp = -32768;
          } else {
#line 308
            tmp = (int )((short )si32);
          }
#line 308
          *((SINT16 *)buf + i) = (SINT16 )tmp;
        }
#line 309
        *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 304
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 313
      i = (size_t )0;
      {
      {
#line 313
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 313
        if (! (i < pinfo->n_in / 2U)) {
#line 313
          goto while_break___0;
        }
#line 314
        si32 = (long )pinfo->iscale * (long )((short )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8)));
#line 316
        si32 /= 100L;
#line 317
        if (si32 > 32767L) {
#line 317
          *((SINT16 *)buf + i) = (SINT16 )32767;
        } else {
#line 317
          if (si32 < -32768L) {
#line 317
            tmp___0 = -32768;
          } else {
#line 317
            tmp___0 = (int )((short )si32);
          }
#line 317
          *((SINT16 *)buf + i) = (SINT16 )tmp___0;
        }
#line 313
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 320
  if (((unsigned int )pinfo->to_little != 0U) ^ ((unsigned int )pinfo->little_host != 0U)) {
#line 322
    i = (size_t )0;
    {
    {
#line 322
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (i < pinfo->n_in / 2U)) {
#line 322
        goto while_break___1;
      }
#line 323
      si32 = (long )pinfo->iscale * (long )*((SINT16 *)buf + i);
#line 325
      si32 /= 100L;
#line 326
      if (si32 > 32767L) {
#line 326
        *((SINT16 *)buf + i) = (SINT16 )32767;
      } else {
#line 326
        if (si32 < -32768L) {
#line 326
          tmp___1 = -32768;
        } else {
#line 326
          tmp___1 = (int )((short )si32);
        }
#line 326
        *((SINT16 *)buf + i) = (SINT16 )tmp___1;
      }
#line 327
      *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 322
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 331
    i = (size_t )0;
    {
    {
#line 331
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 331
      if (! (i < pinfo->n_in / 2U)) {
#line 331
        goto while_break___2;
      }
#line 332
      si32 = (long )pinfo->iscale * (long )*((SINT16 *)buf + i);
#line 334
      si32 /= 100L;
#line 335
      if (si32 > 32767L) {
#line 335
        *((SINT16 *)buf + i) = (SINT16 )32767;
      } else {
#line 335
        if (si32 < -32768L) {
#line 335
          tmp___2 = -32768;
        } else {
#line 335
          tmp___2 = (int )((short )si32);
        }
#line 335
        *((SINT16 *)buf + i) = (SINT16 )tmp___2;
      }
#line 331
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 337
  return;
}
}
#line 352 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_fscale(void *buf , process_t *pinfo ) 
{ 
  long si32 ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 358
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 358
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  358U, "process_swap_fscale");
    }
    }
  }
#line 361
  if (((unsigned int )pinfo->from_little != 0U) ^ ((unsigned int )pinfo->little_host != 0U)) {
#line 363
    if (((unsigned int )pinfo->to_little != 0U) ^ ((unsigned int )pinfo->little_host != 0U)) {
#line 365
      i = (size_t )0;
      {
      {
#line 365
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 365
        if (! (i < pinfo->n_in / 2U)) {
#line 365
          goto while_break;
        }
#line 366
        si32 = (long )(pinfo->fscale * (float )((short )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8))));
#line 368
        if (si32 > 32767L) {
#line 368
          *((SINT16 *)buf + i) = (SINT16 )32767;
        } else {
#line 368
          if (si32 < -32768L) {
#line 368
            tmp = -32768;
          } else {
#line 368
            tmp = (int )((short )si32);
          }
#line 368
          *((SINT16 *)buf + i) = (SINT16 )tmp;
        }
#line 369
        *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 365
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 373
      i = (size_t )0;
      {
      {
#line 373
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 373
        if (! (i < pinfo->n_in / 2U)) {
#line 373
          goto while_break___0;
        }
#line 374
        si32 = (long )(pinfo->fscale * (float )((short )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8))));
#line 376
        if (si32 > 32767L) {
#line 376
          *((SINT16 *)buf + i) = (SINT16 )32767;
        } else {
#line 376
          if (si32 < -32768L) {
#line 376
            tmp___0 = -32768;
          } else {
#line 376
            tmp___0 = (int )((short )si32);
          }
#line 376
          *((SINT16 *)buf + i) = (SINT16 )tmp___0;
        }
#line 373
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 379
  if (((unsigned int )pinfo->to_little != 0U) ^ ((unsigned int )pinfo->little_host != 0U)) {
#line 381
    i = (size_t )0;
    {
    {
#line 381
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 381
      if (! (i < pinfo->n_in / 2U)) {
#line 381
        goto while_break___1;
      }
#line 382
      si32 = (long )(pinfo->fscale * (float )*((SINT16 *)buf + i));
#line 383
      if (si32 > 32767L) {
#line 383
        *((SINT16 *)buf + i) = (SINT16 )32767;
      } else {
#line 383
        if (si32 < -32768L) {
#line 383
          tmp___1 = -32768;
        } else {
#line 383
          tmp___1 = (int )((short )si32);
        }
#line 383
        *((SINT16 *)buf + i) = (SINT16 )tmp___1;
      }
#line 384
      *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 381
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 388
    i = (size_t )0;
    {
    {
#line 388
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 388
      if (! (i < pinfo->n_in / 2U)) {
#line 388
        goto while_break___2;
      }
#line 389
      si32 = (long )(pinfo->fscale * (float )*((SINT16 *)buf + i));
#line 390
      if (si32 > 32767L) {
#line 390
        *((SINT16 *)buf + i) = (SINT16 )32767;
      } else {
#line 390
        if (si32 < -32768L) {
#line 390
          tmp___2 = -32768;
        } else {
#line 390
          tmp___2 = (int )((short )si32);
        }
#line 390
        *((SINT16 *)buf + i) = (SINT16 )tmp___2;
      }
#line 388
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 392
  return;
}
}
#line 405 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_swap_noscale(void *buf , process_t *pinfo ) 
{ 
  size_t i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 410
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 410
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  410U, "process_swap_noscale");
    }
    }
  }
#line 413
  if (((unsigned int )pinfo->from_little != 0U) ^ ((unsigned int )pinfo->to_little != 0U)) {
#line 414
    i = (size_t )0;
    {
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 414
      if (! (i < pinfo->n_in / 2U)) {
#line 414
        goto while_break;
      }
#line 415
      *((SINT16 *)buf + i) = (SINT16 )((((int )*((SINT16 *)buf + i) >> 8) & 255) | ((int )*((SINT16 *)buf + i) << 8));
#line 414
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 417
  return;
}
}
#line 427 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t fi_len  =    (cdseccount_t )0;
#line 427 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t fo_len  =    (cdseccount_t )0;
#line 423 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_fading(void *buf , process_t *pinfo ) 
{ 
  float fade ;
  size_t i ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 430
  if (! ((pinfo->n_in & 1U) == 0U)) {
    {
    {
#line 430
    __assert_fail("(pinfo->n_in & 0x1) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  430U, "process_fading");
    }
    }
  }
#line 434
  if (fi_len == 0UL) {
#line 434
    if (pinfo->fadein != 0UL) {
#line 435
      fi_len = pinfo->fadein + 1UL;
    }
  }
#line 437
  if (fo_len == 0UL) {
#line 437
    if (pinfo->fadeout != 0UL) {
#line 438
      fo_len = pinfo->fadeout + 1UL;
    }
  }
#line 443
  if (fi_len > 0UL) {
#line 444
    if (fo_len > 0UL) {
#line 445
      fade = ((float )(fi_len - pinfo->fadein) / (float )fi_len) * ((float )pinfo->fadeout / (float )fo_len);
#line 447
      (pinfo->fadein) --;
#line 447
      if (pinfo->fadein == 0UL) {
#line 447
        fi_len = (cdseccount_t )0;
      }
#line 448
      (pinfo->fadeout) --;
#line 448
      if (pinfo->fadeout == 0UL) {
#line 448
        fo_len = (cdseccount_t )0;
      }
    } else {
#line 450
      fade = (float )(fi_len - pinfo->fadein) / (float )fi_len;
#line 451
      (pinfo->fadein) --;
#line 451
      if (pinfo->fadein == 0UL) {
#line 451
        fi_len = (cdseccount_t )0;
      }
    }
  } else
#line 454
  if (fo_len > 0UL) {
#line 455
    fade = (float )pinfo->fadeout / (float )fo_len;
#line 456
    (pinfo->fadeout) --;
#line 456
    if (pinfo->fadeout == 0UL) {
#line 456
      fo_len = (cdseccount_t )0;
    }
  } else {
#line 458
    return;
  }
#line 463
  i = (size_t )0;
  {
  {
#line 463
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < pinfo->n_in / 2U)) {
#line 463
      goto while_break;
    }
#line 464
    *((SINT16 *)buf + i) = (SINT16 )((float )*((SINT16 *)buf + i) * fade);
#line 463
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 476 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static BOOL is_silent_sector(void *buf , process_t const   *pinfo ) 
{ 
  long sum ;
  SINT16 avg ;
  unsigned long sumdcpk ;
  UINT16 avgdcpk ;
  size_t i ;
  BOOL is_silent ;
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 482
  sum = 0L;
#line 484
  sumdcpk = 0UL;
#line 496
  if (pinfo->n_in / 2U == 0U) {
#line 497
    *((char *)buf) = (char )'\000';
#line 498
    return ((BOOL )1);
  }
#line 504
  if ((int const   )pinfo->silence_thresh == 0) {
#line 505
    i = (size_t )0;
    {
    {
#line 505
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 505
      if (! (i < (size_t )(pinfo->n_in / 2U))) {
#line 505
        goto while_break;
      }
#line 506
      if ((int )*((SINT16 *)buf + i) != 0) {
#line 507
        return ((BOOL )0);
      }
#line 505
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 508
    return ((BOOL )1);
  }
#line 513
  i = (size_t )0;
  {
  {
#line 513
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 513
    if (! (i < (size_t )(pinfo->n_in / 2U))) {
#line 513
      goto while_break___0;
    }
#line 521
    sum += (long )*((SINT16 *)buf + i);
#line 513
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 526
  avg = (SINT16 )(sum / (long )(pinfo->n_in / 2U));
#line 531
  i = (size_t )0;
  {
  {
#line 531
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 531
    if (! (i < (size_t )(pinfo->n_in / 2U))) {
#line 531
      goto while_break___1;
    }
#line 535
    if ((int )avg - (int )*((SINT16 *)buf + i) < 0) {
#line 535
      tmp = - ((int )avg - (int )*((SINT16 *)buf + i));
    } else {
#line 535
      tmp = (int )avg - (int )*((SINT16 *)buf + i);
    }
#line 535
    sumdcpk += (unsigned long )tmp;
#line 531
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 538
  avgdcpk = (UINT16 )(sumdcpk / (unsigned long )(pinfo->n_in / 2U));
#line 563
  is_silent = (BOOL )((int )avgdcpk < (int )pinfo->silence_thresh);
#line 566
  *((char *)buf) = (char )'\000';
#line 577
  if (pinfo->silence_val) {
    {
    {
#line 577
    tmp___0 = strlen((char const   *)buf);
    }
    {
#line 577
    sprintf((char */* __restrict  */)((char *)buf + tmp___0), (char const   */* __restrict  */)"S%hu ",
            (int )avgdcpk);
    }
    }
  }
#line 579
  return (is_silent);
}
}
#line 604 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t secnum  =    (cdseccount_t )0;
#line 605 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static BOOL sigstarted  =    (BOOL )0;
#line 606 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t sigstart  ;
#line 607 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t silentsectors  =    (cdseccount_t )0;
#line 609 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t silencestart  ;
#line 611 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t lastsigend  =    (cdseccount_t )0;
#line 602 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_silencecuts(void *buf , process_t *pinfo ) 
{ 
  cdseccount_t tmp ;
  size_t tmp___0 ;
  cdseccount_t tmp___1 ;
  BOOL tmp___2 ;
  size_t tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 630
  tmp___2 = is_silent_sector(buf, (process_t const   *)pinfo);
  }
  }
#line 630
  if (tmp___2) {
#line 631
    if (pinfo->n_in / 2U > 0U) {
#line 632
      tmp = silentsectors;
#line 632
      silentsectors ++;
#line 632
      if (tmp == 0UL) {
#line 633
        silencestart = secnum;
      }
#line 634
      if (silentsectors == (cdseccount_t )pinfo->silence_delay) {
#line 634
        if (sigstarted) {
          {
          {
#line 640
          tmp___0 = strlen((char const   *)buf);
          }
          {
#line 640
          sprintf((char */* __restrict  */)((char *)buf + tmp___0), (char const   */* __restrict  */)"%ldC %ldC\n",
                  sigstart, secnum + 1UL);
          }
#line 641
          lastsigend = secnum + 1UL;
#line 643
          sigstarted = (BOOL )0;
          }
        }
      }
    }
  } else {
#line 647
    if (! sigstarted) {
#line 653
      if (silentsectors < (cdseccount_t )pinfo->silence_delay) {
#line 653
        tmp___1 = silentsectors;
      } else {
#line 653
        tmp___1 = (cdseccount_t )pinfo->silence_delay;
      }
#line 653
      sigstart = secnum - tmp___1;
#line 655
      if (sigstart < lastsigend) {
#line 656
        sigstart = lastsigend;
      }
#line 658
      sigstarted = (BOOL )1;
    }
#line 660
    silentsectors = (cdseccount_t )0U;
  }
#line 663
  if (pinfo->last) {
#line 663
    if (sigstarted) {
      {
      {
#line 665
      tmp___3 = strlen((char const   *)buf);
      }
      {
#line 665
      sprintf((char */* __restrict  */)((char *)buf + tmp___3), (char const   */* __restrict  */)"%ldC %ldC\n",
              sigstart, secnum);
      }
      }
    }
  }
  {
#line 669
  secnum ++;
  {
#line 670
  pinfo->n_returned = strlen((char const   *)buf);
  }
  }
#line 674
  return;
}
}
#line 691 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
void process_sector(void *buf , process_t *pinfo ) 
{ 
  BOOL order ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 696
  if (! ((pinfo->n_in & 3U) == 0U)) {
    {
    {
#line 696
    __assert_fail("(pinfo->n_in & 0x3) == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c",
                  696U, "process_sector");
    }
    }
  }
#line 700
  pinfo->n_returned = pinfo->n_in;
#line 703
  if ((int )pinfo->iscale != 100) {
    {
    {
#line 704
    process_swap_iscale(buf, pinfo);
    }
    }
  } else
#line 705
  if ((double )pinfo->fscale != 1.0) {
    {
    {
#line 706
    process_swap_fscale(buf, pinfo);
    }
    }
  } else {
    {
    {
#line 708
    process_swap_noscale(buf, pinfo);
    }
    }
  }
#line 712
  if ((unsigned int )pinfo->monostereo != 0U) {
#line 712
    goto _L;
  } else
#line 712
  if (pinfo->silencecuts) {
#line 712
    goto _L;
  } else
#line 712
  if (pinfo->fadein != 0UL) {
#line 712
    goto _L;
  } else
#line 712
  if (pinfo->fadeout != 0UL) {
    _L: /* CIL Label */ 
    {
#line 717
    order = pinfo->from_little;
#line 718
    pinfo->from_little = pinfo->to_little;
    {
#line 719
    process_swap_tolocal(buf, pinfo);
    }
    }
#line 722
    if ((unsigned int )pinfo->monostereo != 0U) {
      {
#line 724
      if ((unsigned int )pinfo->monostereo == 1U) {
#line 724
        goto case_1;
      }
#line 726
      if ((unsigned int )pinfo->monostereo == 2U) {
#line 726
        goto case_2;
      }
#line 728
      if ((unsigned int )pinfo->monostereo == 3U) {
#line 728
        goto case_3;
      }
#line 730
      goto switch_default;
      case_1: /* CIL Label */ 
      {
      {
#line 725
      process_tomono(buf, pinfo);
      }
      }
#line 725
      goto switch_break;
      case_2: /* CIL Label */ 
      {
      {
#line 727
      process_tostereo(buf, pinfo);
      }
      }
#line 727
      goto switch_break;
      case_3: /* CIL Label */ 
      {
      {
#line 729
      process_tomonostereo(buf, pinfo);
      }
      }
#line 729
      goto switch_break;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
    }
#line 736
    if (pinfo->silencecuts) {
      {
      {
#line 737
      process_silencecuts(buf, pinfo);
      }
      }
    }
#line 740
    if (pinfo->fadein != 0UL) {
      {
      {
#line 741
      process_fading(buf, pinfo);
      }
      }
    } else
#line 740
    if (pinfo->fadeout != 0UL) {
      {
      {
#line 741
      process_fading(buf, pinfo);
      }
      }
    }
    {
    {
#line 744
    process_swap_totarget(buf, pinfo);
    }
#line 745
    pinfo->from_little = order;
    }
  }
#line 749
  if (pinfo->swap_channels) {
    {
    {
#line 750
    process_swap_words(buf, pinfo);
    }
    }
  }
#line 752
  return;
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 333 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 189
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 321 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
void exit_error(exit_t err , char const   *errtext , char const   *errtext2 ) ;
#line 323
int timeprintf(string *buf , unsigned long bytes ) ;
#line 332
long get_input_size_in_cd_blocks(void) ;
#line 333
unsigned long get_cut_value(int n ) ;
#line 335
void get_cmdarg_info(cmdarg_t *pcmdarg ) ;
#line 336
void init_process_info(process_t *pinfo ) ;
#line 339
void open_out(int track___1 ) ;
#line 340
void close_out(void) ;
#line 341
int get_af_header_size(audioformat_t af ) ;
#line 342
void read_header(void) ;
#line 343
void write_header(void) ;
#line 344
void write_trailer(void) ;
#line 345
void add_silence(unsigned long bytes ) ;
#line 346
BOOL copy_sector_check_file(void) ;
#line 347
BOOL got_silence_number(char **pstr , UINT16 *ps ) ;
#line 348
BOOL got_cut_number(char **pstr , unsigned long *pi ) ;
#line 349
void sprint_cutinfo(void *buffer , unsigned long start , unsigned long end , BOOL is_audio_interval ) ;
#line 351
void silence_info(void *buffer , BOOL eof ) ;
#line 352
void handle_sectors(void) ;
#line 353
void do_data_io(void) ;
#line 356
void open_input_file(string const   *name ) ;
#line 357
void close_input_file(void) ;
#line 359
void open_output_file(string const   *name , int track___1 ) ;
#line 360
void close_output_file(void) ;
#line 364
void read_wav_header(wav_header_t *header ) ;
#line 365
void make_wav_header(wav_header_t *header , unsigned long databytes ) ;
#line 366
void write_wav_header(wav_header_t const   *header ) ;
#line 367
size_t read_block(void *buf , size_t bytes ) ;
#line 368
BOOL read_eof(void) ;
#line 369
size_t write_block(void const   *buf , size_t bytes ) ;
#line 47 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static cmdarg_t cmdinfo  ;
#line 50 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static process_t procinfo  ;
#line 53 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long firstsec  ;
#line 53 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long lastsec  ;
#line 57 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long total_bytes_out  ;
#line 60 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static time_t outstart  ;
#line 64 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static BOOL out_is_open  ;
#line 67
FILE *msgfile ;
#line 70
unsigned long bytes_in ;
#line 70
unsigned long bytes_out ;
#line 74
string const   outname[1024] ;
#line 80
static void check_for_fadeout(unsigned long nsecs___1 , unsigned long endsecnum___1 ) ;
#line 87 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void open_out(int track___1 ) 
{ 


  {
  {
  {
#line 89
  outstart = time((time_t *)((void *)0));
  }
  {
#line 91
  open_output_file((string const   *)cmdinfo.outfilename, track___1);
  }
#line 92
  out_is_open = (BOOL )1;
  {
#line 95
  write_header();
  }
  }
#line 97
  return;
}
}
#line 106 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void close_out(void) 
{ 
  time_t runtime ;
  string const   *to ;
  string strstdout[9] ;
  string stime[20] ;
  time_t tmp ;
  double tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 109
  strstdout[0] = (string )'(';
#line 109
  strstdout[1] = (string )'s';
#line 109
  strstdout[2] = (string )'t';
#line 109
  strstdout[3] = (string )'d';
#line 109
  strstdout[4] = (string )'o';
#line 109
  strstdout[5] = (string )'u';
#line 109
  strstdout[6] = (string )'t';
#line 109
  strstdout[7] = (string )')';
#line 109
  strstdout[8] = (string )'\000';
#line 113
  if (! out_is_open) {
#line 114
    return;
  }
  {
  {
#line 116
  write_trailer();
  }
  {
#line 117
  close_output_file();
  }
#line 118
  out_is_open = (BOOL )0;
  {
#line 120
  tmp = time((time_t *)((void *)0));
  }
  {
#line 120
  tmp___0 = difftime(tmp, outstart);
  }
#line 120
  runtime = (time_t )tmp___0;
#line 121
  total_bytes_out += (unsigned long )bytes_out;
  }
#line 123
  if ((unsigned long )cmdinfo.outfilename == (unsigned long )((void *)0)) {
#line 123
    to = (string const   *)(strstdout);
  } else {
#line 123
    to = outname;
  }
  {
  {
#line 124
  timeprintf(stime, (unsigned long )bytes_out);
  }
  }
#line 125
  if ((unsigned int )cmdinfo.outformat == 2U) {
    {
    {
#line 126
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Wrote bytes:       %li (%li C, %s min) -> %s\n",
            (long )bytes_out, (long )bytes_out / 2352L, stime, to);
    }
    }
  } else {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Wrote bytes:       %li -> %s\n",
            (long )bytes_out, to);
    }
    }
  }
  {
  {
#line 138
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Execution time:    %02li:%02li:%02li h  (%li s)\n-\n",
          runtime / 3600L, (runtime / 60L) % 60L, runtime % 60L, runtime);
  }
  }
#line 142
  return;
}
}
#line 152 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
int get_af_header_size(audioformat_t af ) 
{ 


  {
  {
#line 155
  if ((unsigned int )af == 1U) {
#line 155
    goto case_1;
  }
#line 157
  if ((unsigned int )af == 2U) {
#line 157
    goto case_2;
  }
#line 159
  if ((unsigned int )af == 3U) {
#line 159
    goto case_3;
  }
#line 161
  goto switch_default;
  case_1: /* CIL Label */ 
#line 156
  return (0);
  case_2: /* CIL Label */ 
#line 158
  return (0);
  case_3: /* CIL Label */ 
#line 160
  return ((int )sizeof(wav_header_t ));
  switch_default: /* CIL Label */ 
#line 162
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 171 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void read_header(void) 
{ 
  wav_header_t wh___1 ;

  {
  {
#line 176
  if ((unsigned int )cmdinfo.informat == 3U) {
#line 176
    goto case_3;
  }
#line 181
  goto switch_default;
  case_3: /* CIL Label */ 
  {
  {
#line 177
  read_wav_header(& wh___1);
  }
  }
#line 178
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void write_header(void) 
{ 
  wav_header_t wh___1 ;

  {
  {
#line 202
  if ((unsigned int )cmdinfo.outformat == 3U) {
#line 202
    goto case_3;
  }
#line 208
  goto switch_default;
  case_3: /* CIL Label */ 
  {
  {
#line 203
  make_wav_header(& wh___1, 0UL);
  }
  {
#line 204
  write_wav_header((wav_header_t const   *)(& wh___1));
  }
  }
#line 205
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 212
  add_silence(cmdinfo.startsilence);
  }
  }
#line 214
  return;
}
}
#line 228 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void write_trailer(void) 
{ 
  wav_header_t wh___1 ;
  size_t last ;
  char buffer[2352] ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 235
  add_silence(cmdinfo.endsilence);
  }
  }
  {
#line 238
  if ((unsigned int )cmdinfo.outformat == 3U) {
#line 238
    goto case_3;
  }
#line 243
  if ((unsigned int )cmdinfo.outformat == 2U) {
#line 243
    goto case_2;
  }
#line 256
  goto switch_default;
  case_3: /* CIL Label */ 
  {
  {
#line 240
  make_wav_header(& wh___1, (unsigned long )(bytes_out - (unsigned long const   )sizeof(wh___1)));
  }
  {
#line 241
  write_wav_header((wav_header_t const   *)(& wh___1));
  }
  }
#line 242
  goto switch_break;
  case_2: /* CIL Label */ 
#line 245
  last = (size_t )(bytes_out % 2352UL);
#line 246
  if (last == 0U) {
#line 247
    goto switch_break;
  }
#line 248
  last = 2352U - last;
#line 249
  if (last > 0U) {
    {
    {
#line 250
    memset((void *)(buffer), 0, last);
    }
    {
#line 251
    write_block((void const   *)(buffer), last);
    }
    {
#line 252
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"cdr: padding %li bytes\n",
            (long )last);
    }
    }
  }
#line 254
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 260
  return;
}
}
#line 270 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void add_silence(unsigned long bytes ) 
{ 
  size_t w ;
  char buffer[2352] ;
  void *__cil_tmp4 ;

  {
  {
  {
#line 276
  memset((void *)(buffer), 0, (size_t )sizeof(buffer));
  }
  }
  {
  {
#line 277
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 278
    if (bytes > sizeof(buffer)) {
#line 278
      w = (size_t )sizeof(buffer);
    } else {
#line 278
      w = (size_t )bytes;
    }
    {
    {
#line 279
    w = write_block((void const   *)(buffer), w);
    }
#line 280
    bytes -= (unsigned long )w;
    }
#line 277
    if (! (bytes > 0UL)) {
#line 277
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  return;
}
}
#line 289 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static void check_for_fadeout(unsigned long nsecs___1 , unsigned long endsecnum___1 ) 
{ 
  unsigned long fadeoutblocks ;

  {
#line 293
  fadeoutblocks = cmdinfo.fadeout / 2352UL;
#line 294
  if (nsecs___1 + fadeoutblocks == endsecnum___1) {
#line 295
    procinfo.fadeout = fadeoutblocks;
  }
#line 297
  return;
}
}
#line 323 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long nsecs  =    0UL;
#line 323 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long endsecnum  =    0UL;
#line 325 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static int track  =    1;
#line 321 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
BOOL copy_sector_check_file(void) 
{ 
  long tmp ;

  {
#line 328
  if (nsecs < firstsec) {
#line 329
    nsecs ++;
#line 329
    return ((BOOL )0);
  }
#line 333
  if (nsecs == firstsec) {
    {
    {
#line 334
    open_out(track);
    }
#line 335
    procinfo.fadein = cmdinfo.fadein / 2352UL;
    }
#line 336
    if (cmdinfo.numcuts != 0) {
      {
      {
#line 337
      endsecnum = get_cut_value(track);
      }
      }
    } else
#line 339
    if (cmdinfo.fadeout) {
      {
      {
#line 340
      tmp = get_input_size_in_cd_blocks();
      }
#line 340
      endsecnum = (unsigned long )tmp;
      }
    }
  }
#line 345
  if (cmdinfo.numcuts == 0) {
#line 346
    if (cmdinfo.fadeout) {
      {
      {
#line 347
      check_for_fadeout(nsecs, endsecnum);
      }
      }
    }
#line 348
    nsecs ++;
#line 348
    return ((BOOL )1);
  }
#line 352
  if ((unsigned long )cmdinfo.outfilename == (unsigned long )((void *)0)) {
#line 353
    if (cmdinfo.fadeout) {
      {
      {
#line 354
      check_for_fadeout(nsecs, endsecnum);
      }
      }
    }
#line 355
    nsecs ++;
#line 355
    return ((BOOL )(nsecs <= lastsec));
  }
#line 360
  if (cmdinfo.fadeout) {
    {
    {
#line 361
    check_for_fadeout(nsecs, endsecnum);
    }
    }
  }
  {
  {
#line 362
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 362
    if (! (nsecs >= endsecnum)) {
#line 362
      goto while_break;
    }
#line 363
    if (track < cmdinfo.numcuts - 1) {
      {
      {
#line 364
      close_out();
      }
#line 365
      track ++;
      {
#line 365
      open_out(track);
      }
#line 366
      procinfo.fadein = cmdinfo.fadein / 2352UL;
      {
#line 367
      endsecnum = get_cut_value(track);
      }
      }
    } else {
#line 370
      nsecs ++;
#line 370
      return ((BOOL )0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  nsecs ++;
#line 374
  return ((BOOL )1);
}
}
#line 386 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
BOOL got_silence_number(char **pstr , UINT16 *ps ) 
{ 
  int numbers_scanned ;
  int chars_scanned ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 392
  numbers_scanned = sscanf((char const   */* __restrict  */)*pstr, (char const   */* __restrict  */)"%nS%hu%n%*c%n",
                           & chars_scanned, ps, & chars_scanned, & chars_scanned);
  }
#line 394
  *pstr += chars_scanned;
  }
#line 396
  return ((BOOL )(numbers_scanned >= 1));
}
}
#line 409 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
BOOL got_cut_number(char **pstr , unsigned long *pi ) 
{ 
  int numbers_scanned ;
  int chars_scanned ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 413
  numbers_scanned = sscanf((char const   */* __restrict  */)*pstr, (char const   */* __restrict  */)"%n%ld%n%*c%n",
                           & chars_scanned, pi, & chars_scanned, & chars_scanned);
  }
#line 415
  *pstr += chars_scanned;
  }
#line 416
  return ((BOOL )(numbers_scanned >= 1));
}
}
#line 421 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void sprint_cutinfo(void *buffer , unsigned long start , unsigned long end , BOOL is_audio_interval ) 
{ 
  cdseccount_t diff ;
  string st1[15] ;
  string st2[15] ;
  string st3[15] ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 427
  diff = end - start;
  {
#line 428
  timeprintf(st1, start * 2352UL);
  }
  {
#line 429
  timeprintf(st2, end * 2352UL);
  }
  {
#line 430
  timeprintf(st3, diff * 2352UL);
  }
  }
#line 431
  if (is_audio_interval) {
#line 431
    tmp = "AUDIO";
  } else {
#line 431
    tmp = "silnc";
  }
  {
  {
#line 431
  tmp___0 = strlen((char const   *)buffer);
  }
  {
#line 431
  sprintf((char */* __restrict  */)((char *)buffer + tmp___0), (char const   */* __restrict  */)" %-5s %9li b, %6li C, %4li s, %s min\n  DIFF %9li b, %6li C, %4li s, %s min\n   --> %9li b, %6li C, %4li s, %s min\n\n",
          tmp, start * 2352UL, start, start / 75UL, st1, diff * 2352UL, diff, diff / 75UL,
          st3, end * 2352UL, end, end / 75UL, st2);
  }
  }
#line 443
  return;
}
}
#line 455 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static cdseccount_t lastcut  =    (cdseccount_t )-1;
#line 455 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static cdseccount_t lastsigend___0  =    (cdseccount_t )0U;
#line 456 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static BOOL didname  =    (BOOL )0;
#line 457 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static BOOL hadcut  =    (BOOL )0;
#line 452 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void silence_info(void *buffer , BOOL eof ) 
{ 
  cdseccount_t cut ;
  string *cutstring ;
  string *cuts ;
  UINT16 silval ;
  void *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 454
  cut = (cdseccount_t )0U;
#line 475
  if (procinfo.n_returned == 0U) {
#line 475
    if (! eof) {
#line 476
      return;
    }
  }
  {
  {
#line 478
  tmp = malloc(procinfo.n_returned + 1U);
  }
#line 478
  cuts = (string *)tmp;
#line 478
  cutstring = cuts;
  }
#line 479
  if ((unsigned long )cuts == (unsigned long )((void *)0)) {
    {
    {
#line 480
    exit_error((exit_t )4, "Could not allocate memory", (char const   *)((void *)0));
    }
    }
  }
  {
  {
#line 481
  strncpy((char */* __restrict  */)cuts, (char const   */* __restrict  */)buffer,
          procinfo.n_returned);
  }
#line 482
  *(cuts + procinfo.n_returned) = (string )'\000';
#line 488
  *((char *)buffer) = (char )'\000';
  }
#line 489
  if (! didname) {
#line 490
    if ((unsigned long )cmdinfo.infilename == (unsigned long )((void *)0)) {
#line 490
      tmp___0 = "(stdin)";
    } else {
#line 490
      tmp___0 = (char const   *)cmdinfo.infilename;
    }
    {
    {
#line 490
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%s:\n",
            tmp___0);
    }
#line 491
    didname = (BOOL )1;
    }
  }
  {
  {
#line 494
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 494
    if (! (procinfo.n_returned > 1U)) {
#line 494
      goto while_break;
    }
    {
    {
#line 496
    tmp___2 = got_silence_number(& cuts, & silval);
    }
    }
#line 496
    if (tmp___2) {
#line 496
      if (cmdinfo.verbose) {
        {
        {
#line 497
        tmp___1 = strlen((char const   *)buffer);
        }
        {
#line 497
        sprintf((char */* __restrict  */)((char *)buffer + tmp___1), (char const   */* __restrict  */)"Silence = %i\n",
                (int )silval);
        }
        }
      }
    }
    {
    {
#line 500
    tmp___3 = got_cut_number(& cuts, & cut);
    }
    }
#line 500
    if (! tmp___3) {
#line 501
      goto while_break;
    }
#line 502
    if (lastcut == 0xffffffffffffffffUL) {
#line 503
      lastcut = cut;
#line 504
      goto while_continue;
    }
#line 506
    hadcut = (BOOL )1;
#line 507
    if (cut == 0UL) {
#line 508
      cut = (cdseccount_t )(bytes_in / 2352UL);
    }
#line 509
    if (lastsigend___0 < lastcut) {
      {
      {
#line 510
      tmp___4 = strlen((char const   *)buffer);
      }
      {
#line 510
      sprint_cutinfo((void *)((char *)buffer + tmp___4), lastsigend___0, lastcut,
                     (BOOL )0);
      }
      }
    }
    {
    {
#line 511
    tmp___5 = strlen((char const   *)buffer);
    }
    {
#line 511
    sprint_cutinfo((void *)((char *)buffer + tmp___5), lastcut, cut, (BOOL )1);
    }
#line 512
    lastsigend___0 = cut;
#line 513
    lastcut = (cdseccount_t )-1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  if (eof) {
#line 515
    if (lastsigend___0 < (cdseccount_t )(bytes_in / 2352UL)) {
      {
      {
#line 516
      sprint_cutinfo(buffer, lastsigend___0, (unsigned long )(bytes_in / 2352UL),
                     (BOOL )0);
      }
      }
    }
  }
  {
  {
#line 518
  free((void *)cutstring);
  }
  {
#line 519
  procinfo.n_returned = strlen((char const   *)buffer);
  }
  }
#line 520
  return;
}
}
#line 534 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void handle_sectors(void) 
{ 
  size_t numtoread ;
  size_t numread ;
  size_t numtowrite ;
  byte buffer[4704] ;
  BOOL tmp ;
  BOOL tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 540
  numtoread = (size_t )2352;
  {
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 543
    numread = read_block((void *)(& buffer), numtoread);
    }
    }
#line 547
    if (numread & 3U) {
      {
      {
#line 548
      fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Can only process data in multiples of 4 bytes, truncating %i bytes.\n",
              numread & 3U);
      }
#line 551
      numread &= 4294967292U;
      }
    }
    {
    {
#line 555
    tmp = copy_sector_check_file();
    }
    }
#line 555
    if (! tmp) {
#line 556
      goto __Cont;
    }
    {
#line 559
    procinfo.n_in = numread;
    {
#line 560
    procinfo.last = read_eof();
    }
    {
#line 561
    process_sector((void *)(& buffer), & procinfo);
    }
    }
#line 562
    if (cmdinfo.silenceinfo) {
      {
      {
#line 563
      silence_info((void *)(buffer), procinfo.last);
      }
      }
    }
    {
#line 566
    numtowrite = procinfo.n_returned;
    {
#line 569
    write_block((void const   *)(& buffer), numtowrite);
    }
    }
    __Cont: /* CIL Label */ 
#line 542
    if (numread == numtoread) {
      {
      {
#line 542
      tmp___0 = read_eof();
      }
      }
#line 542
      if (tmp___0) {
#line 542
        goto while_break;
      }
    } else {
#line 542
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 573
  return;
}
}
#line 584 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
void do_data_io(void) 
{ 
  time_t executionstart ;
  unsigned long runtime ;
  string stime[20] ;
  time_t tmp ;
  double tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 591
  total_bytes_out = 0UL;
#line 592
  lastsec = 0UL;
#line 592
  firstsec = lastsec;
#line 593
  outstart = (time_t )-1;
#line 594
  out_is_open = (BOOL )0;
  {
#line 597
  get_cmdarg_info(& cmdinfo);
  }
  {
#line 598
  init_process_info(& procinfo);
  }
  }
#line 599
  if (cmdinfo.numcuts > 0) {
    {
    {
#line 600
    firstsec = get_cut_value(0);
    }
    {
#line 601
    lastsec = get_cut_value(cmdinfo.numcuts - 1);
    }
    }
  }
  {
  {
#line 605
  executionstart = time((time_t *)((void *)0));
  }
  {
#line 608
  open_input_file((string const   *)cmdinfo.infilename);
  }
  {
#line 609
  read_header();
  }
  {
#line 611
  handle_sectors();
  }
  {
#line 612
  close_input_file();
  }
  {
#line 613
  close_out();
  }
  {
#line 616
  tmp = time((time_t *)((void *)0));
  }
  {
#line 616
  tmp___0 = difftime(tmp, executionstart);
  }
#line 616
  runtime = (unsigned long )tmp___0;
  }
#line 618
  if ((unsigned int )cmdinfo.outformat == 2U) {
    {
    {
#line 619
    timeprintf(stime, total_bytes_out);
    }
    {
#line 620
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Wrote bytes total: %li (%li C, %s min)\n",
            (long )total_bytes_out, (long )total_bytes_out / 2352L, stime);
    }
    }
  } else {
    {
    {
#line 625
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Wrote bytes total: %li\n",
            (long )total_bytes_out);
    }
    }
  }
  {
  {
#line 628
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Exec time total:   %02li:%02li:%02li h  (%li s)\n",
          runtime / 3600UL, (runtime / 60UL) % 60UL, runtime % 60UL, runtime);
  }
  }
#line 631
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 318 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
void version(void) ;
#line 319
void usage(void) ;
#line 320
void help(void) ;
#line 322
BOOL is_localhost_little(void) ;
#line 325
int main(int argc , char **argv ) ;
#line 328
void scan_cmd_args(int argc , char **argv ) ;
#line 329
void set_message_output(void) ;
#line 330
void check_cmd_args(void) ;
#line 331
void showcmdargs(void) ;
#line 363
void emergency_close(void) ;
#line 111 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
FILE *msgfile  =    (FILE *)((void *)0);
#line 124
static void version_text(void) ;
#line 132 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
static void version_text(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 134
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"wav2cdr [OPTIONS] [INPUTFILE [OUTPUTFILE]]\nwav2cdr [OPTIONS] --cut -- CUTNUMBER CUTNUMBER [CUTNUMBER...]\n%-65s(%s)\n\nConvert a wav file to one or more cdr files which can be written on CD.\nReads stdin, writes stdout. See --help for more information.\n\n",
          "Version 2.3.3  Copyright (C) 27 Oct 2000 by Volker Kuhlmann", "GNU getopt()");
  }
  }
#line 143
  return;
}
}
#line 145 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
void version(void) 
{ 


  {
  {
  {
#line 147
  version_text();
  }
  {
#line 148
  exit_error((exit_t )1, (char const   *)((void *)0), (char const   *)((void *)0));
  }
  }
#line 149
  return;
}
}
#line 157 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
void usage(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 159
  version_text();
  }
  {
#line 160
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)" -h, -u, --usage   Display this usage\n --help            Display extensive help\n -V, --version     Display version\n -i, --inlittle    Input data is little endian (LSB, MSB)\n -I, --inbig       Input data is big endian (MSB, LSB)\n -o, --outlittle   Output data in little endian (LSB, MSB)\n -O, --outbig      Output data in big endian (MSB, LSB)\n --monostereo      Convert both channels to mono, then back to stereo\n --inwav           Input is in wav format (default)\n --incdr           Input is in cdr format\n --inraw           Input is in raw format\n --tocdr           Convert to cdr format (default)\n --towav           Convert to wav format\n --toraw           Convert to raw format\n --iscale NUM      Scale data to NUM percent (100 does nothing)\n --fscale FLOAT    Scale data by FLOAT / multiply by FLOAT (1.0 does nothing)\n --startsilence, --ss VAL   Add VAL silence to the start of each output file\n --endsilence, --es VAL     Add VAL silence to the end of each output file\n --swapchannels,   Swap channels (consecutive 16 bit values with each other)\n --noswapchannels, Don\'t swap channels / words\n --fadein LEN      Fade in at the start for a duration of LEN\n --fadeout LEN     Fade out at the end\n -r, --infile NAME   Input filename (default stdin)       [\'-\' = stdin/stdout]\n -w, --outfile NAME  Output name (track number appended to name) (dflt stdout)\n --cut VAL ...     All remaining arguments are cut numbers\n --silencecuts     Generate cut numbers to cut out intervals of silence\n --silencethresh   Threshold for silence detection (default 10)\n --silencedelay    Delay for silence detection (default 30C)\n --silenceinfo     As --silencecuts, shows info about silent/non-silent parts\n --verbose         More output\n --quiet           Suppress progress output\n --                Stop option scanning, remaining are filenames or cut numbers\n\n Options are processed left-to-right. Parameters to options must be separated\n by a space from the option. VAL units: b (bytes), C (CD sectors), s (seconds)\n\n");
  }
  {
#line 164
  showcmdargs();
  }
  {
#line 165
  exit_error((exit_t )1, (char const   *)((void *)0), (char const   *)((void *)0));
  }
  }
#line 167
  return;
}
}
#line 175 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
void help(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 177
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"\nwav2cdr(1)                                             wav2cdr(1)\n\nNAME\n       wav2cdr - converts input in (or similar to) wav format to cdr for-\n       mat suitable for writing onto audio CDs.\n\nSYNOPSIS\n       wav2cdr [options ...] [infile [outfile]] [--cut cutnumber ...]\n\nVERSION\n       This man page describes wav2cdr version 2.3.3.\n\nDESCRIPTION\n       wav2cdr is a conversion program for audio data which adopts  auto-\n       matically  to  big and little endian machines. Its primary use was\n       to convert wav to cdr, but it is a little more  flexible  now  and\n       can  handle  some  file formats and perform some operations on the\n       data. These formats are possible (reading and writing):\n\n           wav   MS Windows sound\n           cdr   audio CD\n           raw   fixed sampling rate, channels, and bytes per sample\n                 (= that of cdr); byte order must be specified\n\n       These operations can be performed on the  data  (combinations  are\n       possible as long as they are meaningful):\n\n           Scaling (volume change), integer arithmetic\n           Scaling (volume change), floating point arithmetic\n           Cutting of the input into pieces / tracks\n           Conversion to mono and back to stereo\n           Swapping of the 2 channels\n           Adding silence to (or removing from, see cutting) the\n             start and/or end\n           Generation of cut numbers along silent intervals, e.g.\n             to break up a record into tracks\n           Information about non-silent intervals\n           Fading in and out\n\nOPTIONS\n       --cut NUM NUM [NUM...]\n              Cut  the  input into pieces, cutting at positions NUM.  See\n              sections about argument scanning and splitting below.\n\n       --endsilence, --es DUR\n              Adds the given amount of silence to the end of each  output\n              file.\n\n       --fadein LEN\n              Fade  in  at  the start over a duration of LEN.  The syntax\n              for LEN is the same as for a cut number, see section  about\n              argument  scanning below.  If cutting is active, fade-in is\n              applied to the beginning of each cut.\n\n              Fading in is performed by increasing the amplitude  for  CD\n              sectors  by  an  amount derived from LEN over a duration of\n              LEN. --fadein 3 would result in the amplitude of the  first\n              sector lowered to 1/4, of the second sector to 2/4, and the\n              third sector to 3/4. The fourth sector is unchanged and has\n              then reached full amplitude.\n\n       --fadeout LEN\n              Fade out at the end over a duration of LEN.  The syntax for\n              LEN is the same as for a  cut  number,  see  section  about\n              argument  scanning below.  If cutting is active, fad-out is\n              applied to the end of each cut.\n\n              The computation is similar to --fadein.  --fadein  3  would\n              result  in  the  last  3 CD sectors having their amplitudes\n              lowered to 3/4, 2/4, and 1/4. The (non-existant)  following\n              sector is assumed to be silent.\n\n              To  add  silent sector(s) to the end of the audio file, use\n              --endsilence.\n\n              Fading out can only be performed if the input size  can  be\n              determined (i.e. the input must be seekable and cannot be a\n              pipe). If cutting is active, the end of the cut  is  always\n              known and the fade-out can be applied.\n\n              If the fade-out starts before the fade-in is finished, both\n              will overlap, producing sensible results.\n\n       --fscale FLOAT\n              Scale data by FLOAT, i.e. multiply by FLOAT (1.0 does noth-\n              ing).\n\n       -h, -u, --usage\n              Display usage.\n\n       --help Display  extensive  help.  (The information is derived from\n              and equivalent to this manual page.)\n\n       --inbig, -I\n              Input data is big endian (MSB, LSB) (Motorola).\n\n       --incdr\n              Read cdr format (default is wav).  Sets  the  correct  byte\n              order.\n\n       --infile, -r NAME\n              Input filename. Defaults to stdin. \'-\' = stdin.\n\n       --inlittle, -i\n              Input data is little endian (LSB, MSB) (Intel).\n\n       --inraw\n              Read  raw format. Byte order should be specified with -i/-I\n              (default big).\n\n       --inwav\n              Read wav format (default). Sets the correct byte order.\n\n       --iscale NUM\n              Scale data to NUM percent (100 does nothing).\n\n       --monostereo\n              Convert input to mono and immediately back to  stereo.  The\n              result is 2 channels with the same data. This can be useful\n              in some cases.\n\n       --noswapchannels\n              Don\'t swap channels. (default)\n\n       --outfile, -w NAME\n              Write output to file NAME.  The track number is appended as\n              a  2-digit  number.  The default is to write output to std-\n              out.  A NAME of \'-\' means stdout.  When cutting  is  active\n              and more than one cut is made, output can not be written to\n              stdout and the use of this option is mandatory.\n\n       --outbig, -O\n              Output data in big endian (MSB, LSB) (Motorola) byte order.\n\n       --outlittle, -o\n              Output data in little endian (LSB, MSB) (Intel) byte order.\n\n       --quiet\n              Suppress progress output.  The name of this option might be\n              misleading:  it  does  not  prevent copious output in other\n              places which might be turned on by --verbose.\n\n       --silencecuts\n              Generate cut numbers for cutting out silent intervals. This\n              is  useful  when digitising a whole record and then cutting\n              it into tracks. The cut numbers are output  on  stdout  and\n              can  be  fed  back into --cut.  After cutting, every second\n              track (those with even numbers) contains a silent  interval\n              and can be deleted.\n\n              Together  with  --verbose, the silence value of each sector\n              is printed as well (can\'t be fed  back  into  --cut  then).\n              This most likely produces some VERY long lines.\n\n              Silence    is    detected    by    applying   a   threshold\n              (--silencethresh) to a value computed for each  CD  sector;\n              the  value must be below the threshold for a minimum number\n              of sectors (delay --silencedelay). Currently,  the  average\n              is  computed  first  (this  is  the DC component); then the\n              average of the absolute of the difference between each sam-\n              ple  and  the  DC component. The difference between these 2\n              averages is compared with the threshold. Check whether  the\n              cuts  really  fall  into  the  silent intervals, and adjust\n              threshold and duration if not (or edit the cut numbers man-\n              ually).\n\n              The  silence  delay  period is part of the signal interval,\n              not the silence interval. This means that  each  non-silent\n              period  has  --silencedelay silence at the start and at the\n              end. If the silent interval between two signal intervals is\n              less than (2 * silence delay), the silent part at the start\n              of the second signal period will be shortened.\n\n       --silencedelay DELAY\n              The duration for  which  the  \"input\"  must  be  below  the\n              threshold  in order to be detected as a silent interval. In\n              other words, the number of sectors  which  must  be  silent\n              before  a  silent  interval  is  detected.  Ignored without\n              --silencecuts. The delay can be specified with units in the\n              same way as for --cut, and is truncated to full CD sectors.\n              Default is 30C (=0.4s).\n\n       --silenceinfo\n              Similar to --silencecuts, but it  generates  more  informa-\n              tion. Silent and non-silent intervals are listed in a tabu-\n              lar format.  The output format is useful for documentation,\n              but  not  for feeding back into --cut.  With --verbose, the\n              silence values of each CD sector are shown as  well.   This\n              produces  lots  of  output,  but it is useful for finding a\n              suitable --silencethresh.\n\n       --silencethresh THRESHOLD\n              Threshold for silence detection. Ignored without --silence-\n              cuts.   Default  is 10. Always select a threshold as low as\n              possible. When cutting a record into tracks, the  threshold\n              must  be  high  enough  to  recognise the crackling between\n              pieces as silence. When the threshold is too high, a little\n              at  the  beginning  and  end of each piece might be chopped\n              off.\n\n              As a special case, if the threshold is set to 0  the  usual\n              numerical computation of the silence value is bypassed, and\n              the sector is deemed to be silent if all samples are 0.\n\n       --startsilence, --ss DUR\n              Adds the given amount of silence to the start of each  out-\n              put file.\n\n       --swapchannels\n              Swap the left with the right channel.\n\n       --tocdr\n              Write  data  in cdr format (default). Sets the correct byte\n              order.\n\n       --toraw\n              Write data in raw format. Byte order  should  be  specified\n              with -o/-O (default big).\n\n       --towav\n              Write data in wav format. Sets the correct byte order.\n\n       --verbose\n              Produce  more  output. Currently only used by --silencecuts\n              and --silenceinfo.\n\n       --version, -V\n              Display version information.\n\n       --     Stop argument processing.  Remaining arguments can only  be\n              filenames, or cut numbers if cutting is used.\n\nCommand line option scanning:\n       From  left  to  right.  Later settings may override previous ones.\n       Beware to switch file formats before  byte  ordering,  or  a  byte\n       order  might  be  rejected  for the (then active) format. When not\n       using cutting, remaining arguments are used to fill up  input  and\n       output  filenames.  When  using  cutting,  remaining arguments are\n       assumed to be cut numbers. When using negative cut numbers, use --\n       to terminate option processing or the negative numbers can be mis-\n       taken as options (this is a must with GNU getopt()).\n\n       All options which take an argument denoting a time accept the fol-\n       lowing number format. The number may be in decimal, octal (leading\n       0), or hexadecimal (leading 0x or 0X). A one-letter  unit  may  be\n       following. If there is space between the number and the unit, both\n       must be quoted, as in  \"55  C\".  These  units  are  recognised:  b\n       (bytes), C (audio CD sectors), s (seconds). When no unit is given,\n       C is assumed. The progress display might only show numbers in some\n       of these units. Fractions for seconds are allowed.\n\n       Negative  cut  numbers  are  only allowed if the input size can be\n       determined (which will not be possible if the input comes  from  a\n       pipe),  and are shown as the equivalent positive ones. If the last\n       cut number is 0 it means the end of the file. If  the  input  file\n       size  can  not be determined the longest possible input (about 405\n       minutes) is substituted.\n\n       A filename of \'-\' is taken as stdin/stdout.\n\n       If wav2cdr was compiled to use GNU getopt(), argument scanning  is\n       more  powerful  and long options can be shortened to significance.\n       Options are also re-ordered; this is nice but can be a  trap.  Use\n       --  if in doubt, and don\'t mix options with filename or cut number\n       arguments.\n\nData formats:\n       All data handling currently assumes signed 16-bit integers, inter-\n       leaved  for  2  channels, at a sampling rate of that of a CD. Only\n       wav files with these parameters can be read correctly.  cdr  files\n       are in that format, and only raw formats with these parameters can\n       be processed. The only flexibility allowed for  raw  is  the  byte\n       order,  which  can  be specified for both reading and writing. The\n       byte ordering for wav and cdr is fixed.\n\nChannel swapping:\n       Left and right channel are swapped, which is the same as  swapping\n       consecutive  16  bit values with each other. Also see \'CDR Format\'\n       below.\n\nScaling / Volume change:\n       Scaling can be performed with either  integer  or  floating  point\n       arithmetic.  Integer arithmatic is faster but possibly not as pre-\n       cise. Values will saturate (i.e. be clipped), rather than be trun-\n       cated.  The  speed  of this operation depends on the endianness of\n       the input data, output data, and host. It is  slowest  when  bytes\n       have  to  be swapped before scaling and swapped back after.  Nega-\n       tive scale factors are allowed but might be of dubious value.\n\nMono / stereo:\n       Input data can be converted to mono and then back to  stereo.  The\n       result  is  2  channels  with the same data. This can be useful in\n       some cases.\n\nOutput file naming:\n       Unless output is to stdout, the resulting  filename  is  the  name\n       given  with  --outfile.  A  period  and a 2-digit track number are\n       appended.\n\nInput data splitting:\n       Input data can be split into pieces resp. tracks.  Currently  cuts\n       can only be placed at multiples of audio CD sectors (at the sector\n       boundaries), whether the input format is cdr or not.\n\n       The cuts are placed at the  given  positions,  which  must  be  in\n       ascending  order (or equal). Negative numbers are counted from the\n       end of the input data. This only works if the  input  is  seekable\n       (Unix  pipes  are  not). Sectors of the input are numbered from 0.\n       Bytes of a header, which the input  format  might  have,  are  not\n       counted.\n\n       Any number of cuts can be made, but only 99 tracks can be put on a\n       CD. All sectors before the first but not including the first  sec-\n       tor number are discarded, as well as all sectors after and includ-\n       ing the last sector number.  At least 2 sector numbers  (cut  num-\n       bers) must be given, in which case one piece is cut out.\n\n       If  there  are only 2 cut numbers (1 track to cut out) data can be\n       written to stdout or file. More than one track can only be written\n       to  file,  the  track  number will be added as an extension to the\n       filename.  To avoid the track number to be appended to  the  file-\n       name  when  only one cut is made, don\'t use --outfile but write to\n       stdout and use output redirection.\n\n        Example (assuming 50000 sectors in the input):\n           wav2cdr < INPUT --outfile NAME --cut 500 20000 40000\n                sectors     0-  499: discarded\n                          500-19999: saved to NAME.01\n                        20000-39999: saved to NAME.02\n                        40000-49999: discarded\n\nCutting out silent intervals:\n       Assuming a digitised record is stored in record.wav, and is to  be\n       cut into tracks.\n\n         wav2cdr < record.wav > cuts --silencecuts --silencedelay 2s\n         wav2cdr < record.wav --of tracks --cut `cat cuts`\n\n       Will  store  the  tracks of the record in track.01, track.02, ...,\n       with the delay for cutting at a silent part set to 2 seconds.  The\n       threshold used is the default. Note the `` syntax works under Unix\n       and in this case puts the contents of file \"cuts\" on  the  command\n       line.\n\nInformation about silences and actual sound parts:\n       --silenceinfo  can  be  used in the same way as --silencecuts.  It\n       produces output like\n\n       (stdin):\n        silnc         0 b,      0 C,    0 s, 00:00.00 min\n         DIFF    811440 b,    345 C,    4 s, 00:04.22 min\n          -->    811440 b,    345 C,    4 s, 00:04.22 min\n\n        AUDIO    811440 b,    345 C,    4 s, 00:04.22 min\n         DIFF  20603520 b,   8760 C,  116 s, 01:56.05 min\n          -->  21414960 b,   9105 C,  121 s, 02:01.02 min\n\n       showing the beginning, length (\"DIFF\"), and end  (\"-->\")  of  both\n       silent  (\"silnc\")  and and non-silent (\"AUDIO\") intervals. This is\n       useful for examining existing tracks, but it can not be used  with\n       --cut.\n\nMessages:\n       Progress  messages and statistics are written to stderr when writ-\n       ing to stdout, and to stdout when writing to file. It is currently\n       not  possible  to  suppress this, other than by redirection to the\n       bit bucket.\n\nWriting wav format:\n       Only wav files with 2 channels, 16 bits per sample, and  audio  CD\n       sampling  rate can be written. If the input data is different, the\n       resulting wav file is incorrect. Scaling  can  be  performed  when\n       writing  wav.  Cutting  can  only  be performed in multiples of an\n       audio CD sector size. When writing wav the output must be seekable\n       (e.g. no pipes).\n\nCDR Format:\n       Raw  sample  data at a sampling rate of %li Hz. The channels are\n       interleaved.  The numbers are 16 bit  signed  integers  with  this\n       byte  order: MSByte Left, LSByte Left, MSByte Right, LSByte Right.\n       The track size must be a multiple  of  the  sector  size  of  %i\n       bytes.  There are %i sectors per second.\n\nBUGS / LIMITATIONS\n       All operations can only be performed on a minimum of 1 CD block or\n       a multiple thereof.\n\nCOPYRIGHT\n       Copyright (C)\n       Nov, Dec 1997, Jan, Mar, Apr, May 1998, Feb, May, Jun, Jul,\n       Aug 1999, Oct 2000 by\n       Volker Kuhlmann  <VolkerKuhlmann@gmx.de>\n       c/o EEE Dept, University of Canterbury\n       Christchurch, New Zealand\n\n       Permission granted to use and distribute  this  software  free  of\n       charge,  provided  any  improvements  are sent back to the author.\n       Comments and bug reports welcome.  All rights  reserved.  Standard\n       disclaimer applies.\n\nAUTHOR\n       Volker Kuhlmann\n\nwav2cdr                    27 Oct 2000                          1\n\n",
          44100L, 2352, 75);
  }
  {
#line 184
  exit_error((exit_t )1, (char const   *)((void *)0), (char const   *)((void *)0));
  }
  }
#line 186
  return;
}
}
#line 198 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
void exit_error(exit_t err , char const   *errtext , char const   *errtext2 ) 
{ 
  char const   *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 200
  if ((unsigned long )errtext != (unsigned long )((void *)0)) {
#line 201
    if ((unsigned long )errtext2 == (unsigned long )((void *)0)) {
#line 201
      tmp = "";
    } else {
#line 201
      tmp = errtext2;
    }
    {
    {
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"wav2cdr: error: %s%s",
            errtext, tmp);
    }
    }
  }
#line 204
  if ((unsigned int )err == 3U) {
    {
    {
#line 205
    tmp___2 = __errno_location();
    }
    }
#line 205
    if (*tmp___2 != 0) {
      {
      {
#line 206
      tmp___0 = __errno_location();
      }
      {
#line 206
      tmp___1 = strerror(*tmp___0);
      }
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
              tmp___1);
      }
      }
    }
  }
#line 208
  if ((unsigned long )errtext != (unsigned long )((void *)0)) {
    {
    {
#line 209
    _IO_putc('\n', stderr);
    }
    }
  } else
#line 208
  if ((unsigned int )err == 3U) {
    {
    {
#line 209
    _IO_putc('\n', stderr);
    }
    }
  }
#line 210
  if ((unsigned int )err == 2U) {
    {
    {
#line 211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use -h or -u or --usage for usage, or --help for more help\n");
    }
    }
  }
  {
  {
#line 214
  emergency_close();
  }
  {
#line 216
  exit((int )err);
  }
  }
}
}
#line 227 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
BOOL is_localhost_little(void) 
{ 
  UINT16 lclfmt ;
  UINT8 *is_little ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 229
  lclfmt = (UINT16 )1;
#line 230
  is_little = (UINT8 *)(& lclfmt);
#line 233
  if (! (sizeof(UINT16 ) == 2UL * sizeof(UINT8 ))) {
    {
    {
#line 233
    __assert_fail("sizeof(UINT16) == 2 * sizeof(UINT8)", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  233U, "is_localhost_little");
    }
    }
  }
#line 245
  return ((BOOL )((int )*is_little != 0));
}
}
#line 257 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
int timeprintf(string *buf , unsigned long bytes ) 
{ 
  unsigned short m ;
  unsigned short s ;
  unsigned short fs ;
  int tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 264
  s = (unsigned short )((bytes / 2352UL) / 75UL);
#line 265
  fs = (unsigned short )(((bytes - (unsigned long )s * 176400UL) * 100UL) / 176400UL);
#line 267
  m = (unsigned short )((int )s / 60);
#line 268
  s = (unsigned short )((int )s % 60);
  {
#line 270
  tmp = sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%02d:%02d.%02d",
                (int )m, (int )s, (int )fs);
  }
  }
#line 270
  return (tmp);
}
}
#line 276 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
int main(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 278
  if (! (sizeof(UINT8 ) == 1UL)) {
    {
    {
#line 278
    __assert_fail("sizeof(UINT8) == 1", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  278U, "main");
    }
    }
  }
#line 279
  if (! (sizeof(UINT16 ) == 2UL)) {
    {
    {
#line 279
    __assert_fail("sizeof(UINT16) == 2", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  279U, "main");
    }
    }
  }
#line 280
  if (! (sizeof(UINT32 ) == 4UL)) {
    {
    {
#line 280
    __assert_fail("sizeof(UINT32) == 4", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  280U, "main");
    }
    }
  }
#line 281
  if (! (sizeof(SINT16 ) == 2UL)) {
    {
    {
#line 281
    __assert_fail("sizeof(SINT16) == 2", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  281U, "main");
    }
    }
  }
#line 282
  if (! (sizeof(SINT32 ) == 4UL)) {
    {
    {
#line 282
    __assert_fail("sizeof(SINT32) == 4", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  282U, "main");
    }
    }
  }
#line 284
  if (! (sizeof(audiosect_t ) >= sizeof(wav_header_t ))) {
    {
    {
#line 284
    __assert_fail("sizeof(audiosect_t) >= sizeof(wav_header_t)", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  284U, "main");
    }
    }
  }
#line 285
  if (! (sizeof(audiosect_t ) % 4UL == 0UL)) {
    {
    {
#line 285
    __assert_fail("sizeof(audiosect_t) % 4 == 0", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c",
                  285U, "main");
    }
    }
  }
  {
  {
#line 295
  scan_cmd_args(argc, argv);
  }
  {
#line 296
  set_message_output();
  }
  {
#line 297
  check_cmd_args();
  }
  {
#line 298
  showcmdargs();
  }
  {
#line 300
  do_data_io();
  }
  }
#line 302
  return (0);
}
}
#line 71 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static BOOL is_silent_sector___0(void *buf , process_t const   *pinfo ) ;
#line 427 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t fi_len___0  =    (cdseccount_t )0;
#line 427 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t fo_len___0  =    (cdseccount_t )0;
#line 476 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static BOOL is_silent_sector___0(void *buf , process_t const   *pinfo ) 
{ 
  long sum ;
  SINT16 avg ;
  unsigned long sumdcpk ;
  UINT16 avgdcpk ;
  size_t i ;
  BOOL is_silent ;
  int tmp ;
  size_t tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 482
  sum = 0L;
#line 484
  sumdcpk = 0UL;
#line 496
  if (pinfo->n_in / 2U == 0U) {
#line 497
    *((char *)buf) = (char )'\000';
#line 498
    return ((BOOL )1);
  }
#line 504
  if ((int const   )pinfo->silence_thresh == 0) {
#line 505
    i = (size_t )0;
    {
    {
#line 505
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 505
      if (! (i < (size_t )(pinfo->n_in / 2U))) {
#line 505
        goto while_break;
      }
#line 506
      if ((int )*((SINT16 *)buf + i) != 0) {
#line 507
        return ((BOOL )0);
      }
#line 505
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 508
    return ((BOOL )1);
  }
#line 513
  i = (size_t )0;
  {
  {
#line 513
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 513
    if (! (i < (size_t )(pinfo->n_in / 2U))) {
#line 513
      goto while_break___0;
    }
#line 521
    sum += (long )*((SINT16 *)buf + i);
#line 513
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 526
  avg = (SINT16 )(sum / (long )(pinfo->n_in / 2U));
#line 531
  i = (size_t )0;
  {
  {
#line 531
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 531
    if (! (i < (size_t )(pinfo->n_in / 2U))) {
#line 531
      goto while_break___1;
    }
#line 535
    if ((int )avg - (int )*((SINT16 *)buf + i) < 0) {
#line 535
      tmp = - ((int )avg - (int )*((SINT16 *)buf + i));
    } else {
#line 535
      tmp = (int )avg - (int )*((SINT16 *)buf + i);
    }
#line 535
    sumdcpk += (unsigned long )tmp;
#line 531
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 538
  avgdcpk = (UINT16 )(sumdcpk / (unsigned long )(pinfo->n_in / 2U));
#line 563
  is_silent = (BOOL )((int )avgdcpk < (int )pinfo->silence_thresh);
#line 566
  *((char *)buf) = (char )'\000';
#line 577
  if (pinfo->silence_val) {
    {
    {
#line 577
    tmp___0 = strlen((char const   *)buf);
    }
    {
#line 577
    sprintf((char */* __restrict  */)((char *)buf + tmp___0), (char const   */* __restrict  */)"S%hu ",
            (int )avgdcpk);
    }
    }
  }
#line 579
  return (is_silent);
}
}
#line 604 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t secnum___0  =    (cdseccount_t )0;
#line 605 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static BOOL sigstarted___0  =    (BOOL )0;
#line 606 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t sigstart___0  ;
#line 607 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t silentsectors___0  =    (cdseccount_t )0;
#line 609 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t silencestart___0  ;
#line 611 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/process.c"
static cdseccount_t lastsigend___1  =    (cdseccount_t )0;
#line 47 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static cmdarg_t cmdinfo___0  ;
#line 50 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static process_t procinfo___0  ;
#line 53 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long firstsec___0  ;
#line 53 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long lastsec___0  ;
#line 57 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long total_bytes_out___0  ;
#line 60 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static time_t outstart___0  ;
#line 64 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static BOOL out_is_open___0  ;
#line 80
static void check_for_fadeout___0(unsigned long nsecs___1 , unsigned long endsecnum___1 ) ;
#line 289 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static void check_for_fadeout___0(unsigned long nsecs___1 , unsigned long endsecnum___1 ) 
{ 
  unsigned long fadeoutblocks ;

  {
#line 293
  fadeoutblocks = cmdinfo___0.fadeout / 2352UL;
#line 294
  if (nsecs___1 + fadeoutblocks == endsecnum___1) {
#line 295
    procinfo___0.fadeout = fadeoutblocks;
  }
#line 297
  return;
}
}
#line 323 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long nsecs___0  =    0UL;
#line 323 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static unsigned long endsecnum___0  =    0UL;
#line 325 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static int track___0  =    1;
#line 455 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static cdseccount_t lastcut___0  =    (cdseccount_t )-1;
#line 455 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static cdseccount_t lastsigend___2  =    (cdseccount_t )0U;
#line 456 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static BOOL didname___0  =    (BOOL )0;
#line 457 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/data.c"
static BOOL hadcut___0  =    (BOOL )0;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 334 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
unsigned long get_silence_value(string const   *s ) ;
#line 358
long get_file_size(string const   *name , FILE *stream ) ;
#line 361
FILE *open_message_file(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 82
extern int optopt ;
#line 175
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 67 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static cmdarg_t cmdarg  = 
#line 67 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
     {(BOOL )1, (BOOL )0, 100L, (float )1.0, (BOOL )0, (BOOL )0, (BOOL )0, (BOOL )0,
    10L, 30L, 0UL, 0UL, (audioformat_t )3, (audioformat_t )2, 0UL, 0UL, (string *)((void *)0),
    (string *)((void *)0), 0, (string **)((void *)0), (BOOL )0, (BOOL )0, (BOOL )0,
    (BOOL )0, (BOOL )0};
#line 76 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static long input_size  ;
#line 83
static long get_num_unit(string const   *s ) ;
#line 88
static void check_monotonous_cuts(void) ;
#line 89
static long get_neg_cut(long cut ) ;
#line 99 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
void scan_cmd_args(int argc , char **argv ) 
{ 
  int lidx ;
  int r ;
  string shortoptions[12] ;
  struct option longoptions[40] ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  string s[2] ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  string buf[20] ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
#line 106
  r = 1;
#line 113
  shortoptions[0] = (string )'h';
#line 113
  shortoptions[1] = (string )'I';
#line 113
  shortoptions[2] = (string )'i';
#line 113
  shortoptions[3] = (string )'O';
#line 113
  shortoptions[4] = (string )'o';
#line 113
  shortoptions[5] = (string )'u';
#line 113
  shortoptions[6] = (string )'r';
#line 113
  shortoptions[7] = (string )':';
#line 113
  shortoptions[8] = (string )'V';
#line 113
  shortoptions[9] = (string )'w';
#line 113
  shortoptions[10] = (string )':';
#line 113
  shortoptions[11] = (string )'\000';
#line 114
  longoptions[0].name = "h";
#line 114
  longoptions[0].has_arg = 0;
#line 114
  longoptions[0].flag = (int *)(& cmdarg.usage);
#line 114
  longoptions[0].val = 'u';
#line 114
  longoptions[1].name = "u";
#line 114
  longoptions[1].has_arg = 0;
#line 114
  longoptions[1].flag = (int *)(& cmdarg.usage);
#line 114
  longoptions[1].val = 'u';
#line 114
  longoptions[2].name = "usage";
#line 114
  longoptions[2].has_arg = 0;
#line 114
  longoptions[2].flag = (int *)(& cmdarg.usage);
#line 114
  longoptions[2].val = 'u';
#line 114
  longoptions[3].name = "help";
#line 114
  longoptions[3].has_arg = 0;
#line 114
  longoptions[3].flag = (int *)(& cmdarg.help);
#line 114
  longoptions[3].val = 'H';
#line 114
  longoptions[4].name = "tocdr";
#line 114
  longoptions[4].has_arg = 0;
#line 114
  longoptions[4].flag = (int *)((void *)0);
#line 114
  longoptions[4].val = 13;
#line 114
  longoptions[5].name = "towav";
#line 114
  longoptions[5].has_arg = 0;
#line 114
  longoptions[5].flag = (int *)((void *)0);
#line 114
  longoptions[5].val = 14;
#line 114
  longoptions[6].name = "toraw";
#line 114
  longoptions[6].has_arg = 0;
#line 114
  longoptions[6].flag = (int *)((void *)0);
#line 114
  longoptions[6].val = 12;
#line 114
  longoptions[7].name = "inraw";
#line 114
  longoptions[7].has_arg = 0;
#line 114
  longoptions[7].flag = (int *)((void *)0);
#line 114
  longoptions[7].val = 10;
#line 114
  longoptions[8].name = "inwav";
#line 114
  longoptions[8].has_arg = 0;
#line 114
  longoptions[8].flag = (int *)((void *)0);
#line 114
  longoptions[8].val = 8;
#line 114
  longoptions[9].name = "incdr";
#line 114
  longoptions[9].has_arg = 0;
#line 114
  longoptions[9].flag = (int *)((void *)0);
#line 114
  longoptions[9].val = 9;
#line 114
  longoptions[10].name = "monostereo";
#line 114
  longoptions[10].has_arg = 0;
#line 114
  longoptions[10].flag = (int *)(& cmdarg.monostereo);
#line 114
  longoptions[10].val = 1;
#line 114
  longoptions[11].name = "inbig";
#line 114
  longoptions[11].has_arg = 0;
#line 114
  longoptions[11].flag = (int *)((void *)0);
#line 114
  longoptions[11].val = 'I';
#line 114
  longoptions[12].name = "I";
#line 114
  longoptions[12].has_arg = 0;
#line 114
  longoptions[12].flag = (int *)((void *)0);
#line 114
  longoptions[12].val = 'I';
#line 114
  longoptions[13].name = "inlittle";
#line 114
  longoptions[13].has_arg = 0;
#line 114
  longoptions[13].flag = (int *)((void *)0);
#line 114
  longoptions[13].val = 'i';
#line 114
  longoptions[14].name = "i";
#line 114
  longoptions[14].has_arg = 0;
#line 114
  longoptions[14].flag = (int *)((void *)0);
#line 114
  longoptions[14].val = 'i';
#line 114
  longoptions[15].name = "outbig";
#line 114
  longoptions[15].has_arg = 0;
#line 114
  longoptions[15].flag = (int *)((void *)0);
#line 114
  longoptions[15].val = 'O';
#line 114
  longoptions[16].name = "O";
#line 114
  longoptions[16].has_arg = 0;
#line 114
  longoptions[16].flag = (int *)((void *)0);
#line 114
  longoptions[16].val = 'O';
#line 114
  longoptions[17].name = "outlittle";
#line 114
  longoptions[17].has_arg = 0;
#line 114
  longoptions[17].flag = (int *)((void *)0);
#line 114
  longoptions[17].val = 'o';
#line 114
  longoptions[18].name = "o";
#line 114
  longoptions[18].has_arg = 0;
#line 114
  longoptions[18].flag = (int *)((void *)0);
#line 114
  longoptions[18].val = 'o';
#line 114
  longoptions[19].name = "swapchannels";
#line 114
  longoptions[19].has_arg = 0;
#line 114
  longoptions[19].flag = (int *)((void *)0);
#line 114
  longoptions[19].val = 16;
#line 114
  longoptions[20].name = "noswapchannels";
#line 114
  longoptions[20].has_arg = 0;
#line 114
  longoptions[20].flag = (int *)((void *)0);
#line 114
  longoptions[20].val = 15;
#line 114
  longoptions[21].name = "infile";
#line 114
  longoptions[21].has_arg = 1;
#line 114
  longoptions[21].flag = (int *)((void *)0);
#line 114
  longoptions[21].val = 1;
#line 114
  longoptions[22].name = "outfile";
#line 114
  longoptions[22].has_arg = 1;
#line 114
  longoptions[22].flag = (int *)((void *)0);
#line 114
  longoptions[22].val = 2;
#line 114
  longoptions[23].name = "iscale";
#line 114
  longoptions[23].has_arg = 1;
#line 114
  longoptions[23].flag = (int *)((void *)0);
#line 114
  longoptions[23].val = 3;
#line 114
  longoptions[24].name = "fscale";
#line 114
  longoptions[24].has_arg = 1;
#line 114
  longoptions[24].flag = (int *)((void *)0);
#line 114
  longoptions[24].val = 4;
#line 114
  longoptions[25].name = "cut";
#line 114
  longoptions[25].has_arg = 0;
#line 114
  longoptions[25].flag = (int *)((void *)0);
#line 114
  longoptions[25].val = 'c';
#line 114
  longoptions[26].name = "startsilence";
#line 114
  longoptions[26].has_arg = 1;
#line 114
  longoptions[26].flag = (int *)((void *)0);
#line 114
  longoptions[26].val = 5;
#line 114
  longoptions[27].name = "ss";
#line 114
  longoptions[27].has_arg = 1;
#line 114
  longoptions[27].flag = (int *)((void *)0);
#line 114
  longoptions[27].val = 5;
#line 114
  longoptions[28].name = "endsilence";
#line 114
  longoptions[28].has_arg = 1;
#line 114
  longoptions[28].flag = (int *)((void *)0);
#line 114
  longoptions[28].val = 6;
#line 114
  longoptions[29].name = "es";
#line 114
  longoptions[29].has_arg = 1;
#line 114
  longoptions[29].flag = (int *)((void *)0);
#line 114
  longoptions[29].val = 6;
#line 114
  longoptions[30].name = "silencecuts";
#line 114
  longoptions[30].has_arg = 0;
#line 114
  longoptions[30].flag = (int *)(& cmdarg.silencecuts);
#line 114
  longoptions[30].val = 1;
#line 114
  longoptions[31].name = "silenceinfo";
#line 114
  longoptions[31].has_arg = 0;
#line 114
  longoptions[31].flag = (int *)(& cmdarg.silenceinfo);
#line 114
  longoptions[31].val = 1;
#line 114
  longoptions[32].name = "silencethresh";
#line 114
  longoptions[32].has_arg = 1;
#line 114
  longoptions[32].flag = (int *)((void *)0);
#line 114
  longoptions[32].val = 17;
#line 114
  longoptions[33].name = "silencedelay";
#line 114
  longoptions[33].has_arg = 1;
#line 114
  longoptions[33].flag = (int *)((void *)0);
#line 114
  longoptions[33].val = 18;
#line 114
  longoptions[34].name = "fadein";
#line 114
  longoptions[34].has_arg = 1;
#line 114
  longoptions[34].flag = (int *)((void *)0);
#line 114
  longoptions[34].val = 19;
#line 114
  longoptions[35].name = "fadeout";
#line 114
  longoptions[35].has_arg = 1;
#line 114
  longoptions[35].flag = (int *)((void *)0);
#line 114
  longoptions[35].val = 20;
#line 114
  longoptions[36].name = "quiet";
#line 114
  longoptions[36].has_arg = 0;
#line 114
  longoptions[36].flag = (int *)(& cmdarg.quiet);
#line 114
  longoptions[36].val = 1;
#line 114
  longoptions[37].name = "version";
#line 114
  longoptions[37].has_arg = 0;
#line 114
  longoptions[37].flag = (int *)((void *)0);
#line 114
  longoptions[37].val = 'V';
#line 114
  longoptions[38].name = "verbose";
#line 114
  longoptions[38].has_arg = 0;
#line 114
  longoptions[38].flag = (int *)(& cmdarg.verbose);
#line 114
  longoptions[38].val = 1;
#line 114
  longoptions[39].name = (char const   *)((void *)0);
#line 114
  longoptions[39].has_arg = 0;
#line 114
  longoptions[39].flag = (int *)((void *)0);
#line 114
  longoptions[39].val = 0;
#line 167
  if (! (sizeof(BOOL ) == sizeof(int ))) {
    {
    {
#line 167
    __assert_fail("sizeof(BOOL)==sizeof(int)", "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c",
                  167U, "scan_cmd_args");
    }
    }
  }
#line 174
  optind = 0;
  {
  {
#line 175
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 175
    if (! (r != -1)) {
#line 175
      goto while_break;
    }
    {
    {
#line 176
    r = getopt_long(argc, (char * const  *)argv, (char const   *)(shortoptions), (struct option  const  *)(longoptions),
                    & lidx);
    }
    }
    {
#line 184
    if (r == 117) {
#line 184
      goto case_117;
    }
#line 184
    if (r == 104) {
#line 184
      goto case_117;
    }
#line 187
    if (r == 86) {
#line 187
      goto case_86;
    }
#line 190
    if (r == 16) {
#line 190
      goto case_16;
    }
#line 193
    if (r == 15) {
#line 193
      goto case_15;
    }
#line 196
    if (r == 10) {
#line 196
      goto case_10;
    }
#line 200
    if (r == 8) {
#line 200
      goto case_8;
    }
#line 204
    if (r == 9) {
#line 204
      goto case_9;
    }
#line 208
    if (r == 13) {
#line 208
      goto case_13;
    }
#line 212
    if (r == 14) {
#line 212
      goto case_14;
    }
#line 216
    if (r == 12) {
#line 216
      goto case_12;
    }
#line 220
    if (r == 73) {
#line 220
      goto case_73;
    }
#line 225
    if (r == 105) {
#line 225
      goto case_105;
    }
#line 230
    if (r == 79) {
#line 230
      goto case_79;
    }
#line 235
    if (r == 111) {
#line 235
      goto case_111;
    }
#line 241
    if (r == 114) {
#line 241
      goto case_114;
    }
#line 241
    if (r == 1) {
#line 241
      goto case_114;
    }
#line 245
    if (r == 119) {
#line 245
      goto case_119;
    }
#line 245
    if (r == 2) {
#line 245
      goto case_119;
    }
#line 248
    if (r == 3) {
#line 248
      goto case_3;
    }
#line 254
    if (r == 4) {
#line 254
      goto case_4;
    }
#line 260
    if (r == 99) {
#line 260
      goto case_99;
    }
#line 263
    if (r == 5) {
#line 263
      goto case_5;
    }
#line 266
    if (r == 6) {
#line 266
      goto case_6;
    }
#line 269
    if (r == 17) {
#line 269
      goto case_17;
    }
#line 272
    if (r == 18) {
#line 272
      goto case_18;
    }
#line 275
    if (r == 19) {
#line 275
      goto case_19;
    }
#line 278
    if (r == 20) {
#line 278
      goto case_20;
    }
#line 282
    if (r == -1) {
#line 282
      goto case_neg_1;
    }
#line 282
    if (r == 0) {
#line 282
      goto case_neg_1;
    }
#line 284
    if (r == 63) {
#line 284
      goto case_63;
    }
#line 297
    goto switch_default;
    case_117: /* CIL Label */ 
    case_104: /* CIL Label */ 
#line 185
    cmdarg.usage = (BOOL )1;
#line 186
    goto switch_break;
    case_86: /* CIL Label */ 
#line 188
    cmdarg.version = (BOOL )1;
#line 189
    goto switch_break;
    case_16: /* CIL Label */ 
#line 191
    cmdarg.swapwords = (BOOL )1;
#line 192
    goto switch_break;
    case_15: /* CIL Label */ 
#line 194
    cmdarg.swapwords = (BOOL )0;
#line 195
    goto switch_break;
    case_10: /* CIL Label */ 
#line 197
    cmdarg.informat = (audioformat_t )1;
#line 198
    cmdarg.little_input = (BOOL )0;
#line 199
    goto switch_break;
    case_8: /* CIL Label */ 
#line 201
    cmdarg.informat = (audioformat_t )3;
#line 202
    cmdarg.little_input = (BOOL )1;
#line 203
    goto switch_break;
    case_9: /* CIL Label */ 
#line 205
    cmdarg.informat = (audioformat_t )2;
#line 206
    cmdarg.little_input = (BOOL )0;
#line 207
    goto switch_break;
    case_13: /* CIL Label */ 
#line 209
    cmdarg.outformat = (audioformat_t )2;
#line 210
    cmdarg.little_output = (BOOL )0;
#line 211
    goto switch_break;
    case_14: /* CIL Label */ 
#line 213
    cmdarg.outformat = (audioformat_t )3;
#line 214
    cmdarg.little_output = (BOOL )1;
#line 215
    goto switch_break;
    case_12: /* CIL Label */ 
#line 217
    cmdarg.outformat = (audioformat_t )1;
#line 218
    cmdarg.little_output = (BOOL )0;
#line 219
    goto switch_break;
    case_73: /* CIL Label */ 
#line 221
    cmdarg.little_input = (BOOL )0;
#line 222
    if ((unsigned int )cmdarg.informat == 3U) {
      {
      {
#line 223
      exit_error((exit_t )2, "can\'t read wav in big endian", (char const   *)((void *)0));
      }
      }
    }
#line 224
    goto switch_break;
    case_105: /* CIL Label */ 
#line 226
    cmdarg.little_input = (BOOL )1;
#line 227
    if ((unsigned int )cmdarg.informat == 2U) {
      {
      {
#line 228
      exit_error((exit_t )2, "can\'t read cdr in little endian", (char const   *)((void *)0));
      }
      }
    }
#line 229
    goto switch_break;
    case_79: /* CIL Label */ 
#line 231
    cmdarg.little_output = (BOOL )0;
#line 232
    if ((unsigned int )cmdarg.outformat == 3U) {
      {
      {
#line 233
      exit_error((exit_t )2, "must write wav in little endian", (char const   *)((void *)0));
      }
      }
    }
#line 234
    goto switch_break;
    case_111: /* CIL Label */ 
#line 236
    cmdarg.little_output = (BOOL )1;
#line 237
    if ((unsigned int )cmdarg.outformat == 2U) {
      {
      {
#line 238
      exit_error((exit_t )2, "must write cdr in big endian", (char const   *)((void *)0));
      }
      }
    }
#line 239
    goto switch_break;
    case_114: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 242
    cmdarg.infilename = optarg;
#line 243
    goto switch_break;
    case_119: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 246
    cmdarg.outfilename = optarg;
#line 247
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 249
    r = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%li",
               & cmdarg.iscale);
    }
    }
#line 250
    if (r != 1) {
      {
      {
#line 251
      exit_error((exit_t )2, "with number (syntax): ", (char const   *)optarg);
      }
      }
    }
#line 253
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    {
#line 255
    r = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%f",
               & cmdarg.fscale);
    }
    }
#line 256
    if (r != 1) {
      {
      {
#line 257
      exit_error((exit_t )2, "with floating point number (syntax): ", (char const   *)optarg);
      }
      }
    }
#line 259
    goto switch_break;
    case_99: /* CIL Label */ 
#line 261
    cmdarg.numcuts = 1;
#line 262
    goto switch_break;
    case_5: /* CIL Label */ 
    {
    {
#line 264
    cmdarg.startsilence = get_silence_value((string const   *)optarg);
    }
    }
#line 265
    goto switch_break;
    case_6: /* CIL Label */ 
    {
    {
#line 267
    cmdarg.endsilence = get_silence_value((string const   *)optarg);
    }
    }
#line 268
    goto switch_break;
    case_17: /* CIL Label */ 
    {
    {
#line 270
    tmp = get_num_unit((string const   *)optarg);
    }
#line 270
    cmdarg.silence_thresh = tmp / 2352L;
    }
#line 271
    goto switch_break;
    case_18: /* CIL Label */ 
    {
    {
#line 273
    tmp___0 = get_num_unit((string const   *)optarg);
    }
#line 273
    cmdarg.silence_delay = tmp___0 / 2352L;
    }
#line 274
    goto switch_break;
    case_19: /* CIL Label */ 
    {
    {
#line 276
    tmp___1 = get_num_unit((string const   *)optarg);
    }
#line 276
    cmdarg.fadein = (unsigned long )tmp___1;
    }
#line 277
    goto switch_break;
    case_20: /* CIL Label */ 
    {
    {
#line 279
    tmp___2 = get_num_unit((string const   *)optarg);
    }
#line 279
    cmdarg.fadeout = (unsigned long )tmp___2;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 283
    goto switch_break;
    case_63: /* CIL Label */ 
#line 287
    if (optopt == 0) {
      {
      {
#line 288
      exit_error((exit_t )2, "unknown option: ", (char const   *)*(argv + (optind - 1)));
      }
      }
    }
    {
    {
#line 289
    tmp___5 = strchr((char const   *)(shortoptions), optopt);
    }
    }
#line 289
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
      {
      {
#line 291
      exit_error((exit_t )2, (char const   *)*(argv + (optind - 1)), " requires an argument");
      }
      }
    } else {
      {
      {
#line 289
      tmp___6 = __ctype_b_loc();
      }
      }
#line 289
      if ((int const   )*(*tmp___6 + optopt) & 16384) {
        {
        {
#line 294
        tmp___4 = __ctype_b_loc();
        }
        }
#line 294
        if ((int const   )*(*tmp___4 + optopt) & 16384) {
#line 294
          s[0] = (string )optopt;
        } else {
#line 294
          s[0] = (string )' ';
        }
        {
#line 294
        s[1] = (string )'\000';
        {
#line 295
        exit_error((exit_t )2, "unknown short option: ", (char const   *)(s));
        }
        }
      } else {
        {
        {
#line 291
        exit_error((exit_t )2, (char const   *)*(argv + (optind - 1)), " requires an argument");
        }
        }
      }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 301
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%i",
            r);
    }
    {
#line 302
    exit_error((exit_t )5, "can\'t handle getopt() return val ", (char const   *)(buf));
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 315
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 315
    if (! (optind < argc)) {
#line 315
      goto while_break___0;
    }
#line 321
    if (cmdarg.numcuts) {
#line 322
      cmdarg.numcuts = argc - optind;
#line 323
      cmdarg.cutstarts = argv + optind;
#line 324
      goto while_break___0;
    }
#line 326
    if ((unsigned long )cmdarg.infilename == (unsigned long )((void *)0)) {
#line 327
      cmdarg.infilename = *(argv + optind);
    } else
#line 329
    if ((unsigned long )cmdarg.outfilename == (unsigned long )((void *)0)) {
#line 330
      cmdarg.outfilename = *(argv + optind);
    } else {
      {
      {
#line 332
      exit_error((exit_t )2, "can not handle ", (char const   *)*(argv + optind));
      }
      }
    }
#line 334
    optind ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 339
  if ((unsigned long )cmdarg.infilename != (unsigned long )((void *)0)) {
    {
    {
#line 339
    tmp___7 = strcmp((char const   *)cmdarg.infilename, "-");
    }
    }
#line 339
    if (tmp___7 == 0) {
#line 341
      cmdarg.infilename = (string *)((void *)0);
    }
  }
#line 342
  if ((unsigned long )cmdarg.outfilename != (unsigned long )((void *)0)) {
    {
    {
#line 342
    tmp___8 = strcmp((char const   *)cmdarg.outfilename, "-");
    }
    }
#line 342
    if (tmp___8 == 0) {
#line 344
      cmdarg.outfilename = (string *)((void *)0);
    }
  }
#line 348
  if (cmdarg.silenceinfo) {
#line 349
    cmdarg.silencecuts = (BOOL )1;
  }
#line 350
  if (cmdarg.silencecuts) {
    {
#line 351
    cmdarg.outformat = (audioformat_t )1;
    {
#line 352
    cmdarg.little_output = is_localhost_little();
    }
    }
  }
#line 355
  return;
}
}
#line 363 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
void set_message_output(void) 
{ 


  {
#line 366
  msgfile = stdout;
#line 367
  if ((unsigned long )cmdarg.outfilename == (unsigned long )((void *)0)) {
#line 368
    msgfile = stderr;
  }
#line 372
  if (cmdarg.quiet) {
    {
    {
#line 373
    msgfile = open_message_file();
    }
    }
  }
#line 374
  return;
}
}
#line 381 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
void check_cmd_args(void) 
{ 
  int hs ;
  long tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 393
  if (cmdarg.iscale < -32768L) {
    {
    {
#line 397
    exit_error((exit_t )2, "scale factor out of range", (char const   *)((void *)0));
    }
    }
  } else
#line 393
  if (cmdarg.iscale > 32767L) {
    {
    {
#line 397
    exit_error((exit_t )2, "scale factor out of range", (char const   *)((void *)0));
    }
    }
  } else
#line 393
  if ((long )cmdarg.fscale < -32768L) {
    {
    {
#line 397
    exit_error((exit_t )2, "scale factor out of range", (char const   *)((void *)0));
    }
    }
  } else
#line 393
  if ((long )cmdarg.fscale > 32767L) {
    {
    {
#line 397
    exit_error((exit_t )2, "scale factor out of range", (char const   *)((void *)0));
    }
    }
  }
#line 398
  if (cmdarg.iscale < 0L) {
    {
    {
#line 399
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Scale factor is negative. Will proceed and assume you know what you are doing.\n");
    }
    }
  } else
#line 398
  if ((double )cmdarg.fscale < 0.0) {
    {
    {
#line 399
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Scale factor is negative. Will proceed and assume you know what you are doing.\n");
    }
    }
  }
  {
  {
#line 403
  input_size = get_file_size((string const   *)cmdarg.infilename, stdin);
  }
  {
#line 406
  hs = get_af_header_size(cmdarg.informat);
  }
  }
#line 407
  if (input_size != -1L) {
#line 408
    if (input_size >= (long )hs) {
#line 408
      tmp = (long )hs;
    } else {
#line 408
      tmp = input_size;
    }
#line 408
    input_size -= tmp;
  }
#line 410
  if (cmdarg.numcuts > 0) {
#line 411
    if (cmdarg.numcuts > 2) {
#line 411
      if ((unsigned long )cmdarg.outfilename == (unsigned long )((void *)0)) {
        {
        {
#line 412
        exit_error((exit_t )2, "can not cut more than 1 part to stdout", "");
        }
        }
      }
    }
#line 414
    if (cmdarg.numcuts == 1) {
      {
      {
#line 415
      exit_error((exit_t )2, "must have >= 2 cut numbers", "");
      }
      }
    }
    {
    {
#line 416
    check_monotonous_cuts();
    }
    }
  }
#line 419
  if (cmdarg.help) {
    {
#line 420
    msgfile = stdout;
    {
#line 421
    help();
    }
    }
  }
#line 423
  if (cmdarg.usage) {
    {
#line 424
    msgfile = stdout;
    {
#line 425
    usage();
    }
    }
  }
#line 427
  if (cmdarg.version) {
    {
#line 428
    msgfile = stdout;
    {
#line 429
    version();
    }
    }
  }
#line 432
  if (cmdarg.iscale != 100L) {
#line 432
    if ((double )cmdarg.fscale != 1.0) {
      {
      {
#line 433
      fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Both integer and float scale given - float scale ignored.\n");
      }
#line 435
      cmdarg.fscale = (float )1.0;
      }
    }
  }
#line 438
  if ((unsigned long )cmdarg.silence_thresh > 65535UL) {
    {
    {
#line 440
    exit_error((exit_t )2, "silence threshold and delay must be positive 16 bit",
               "");
    }
    }
  } else
#line 438
  if ((unsigned long )cmdarg.silence_delay > 65535UL) {
    {
    {
#line 440
    exit_error((exit_t )2, "silence threshold and delay must be positive 16 bit",
               "");
    }
    }
  }
#line 443
  if (cmdarg.silence_delay == 0L) {
    {
    {
#line 444
    exit_error((exit_t )2, "silence delay must be >= 1", "");
    }
    }
  }
#line 447
  if (cmdarg.fadeout > 0UL) {
#line 447
    if (cmdarg.numcuts == 0) {
#line 447
      if (input_size == -1L) {
        {
        {
#line 448
        exit_error((exit_t )2, "can\'t fade out when input size can\'t be determined",
                   "");
        }
        }
      }
    }
  }
#line 451
  return;
}
}
#line 458 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static void check_monotonous_cuts(void) 
{ 
  int j ;
  unsigned long this ;
  unsigned long next ;
  string buf[80] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 464
  j = 0;
  {
#line 464
  this = get_cut_value(0);
  }
  }
  {
  {
#line 464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 464
    if (! (j < cmdarg.numcuts - 1)) {
#line 464
      goto while_break;
    }
    {
    {
#line 465
    next = get_cut_value(j + 1);
    }
    }
#line 466
    if (next < this) {
      {
      {
#line 467
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"cut number (N+1) not >= (N)  (%li not >= %li)",
              next, this);
      }
      {
#line 469
      exit_error((exit_t )2, (char const   *)(buf), (char const   *)((void *)0));
      }
      }
    }
#line 471
    this = next;
#line 464
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return;
}
}
#line 484 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
void showcmdargs(void) 
{ 
  string yes[4] ;
  string no[3] ;
  string big[4] ;
  string little[7] ;
  string const   *AF_nameidx[5] ;
  cdseccount_t firstcut ;
  cdseccount_t lastcut___1 ;
  string insize[80] ;
  string silence[80] ;
  string stasil[15] ;
  string endsil[15] ;
  string filength[15] ;
  string folength[15] ;
  string stime[15] ;
  string sfirstcut[15] ;
  string slastcut[15] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  string *tmp___3 ;
  string *tmp___4 ;
  string *tmp___5 ;
  string *tmp___6 ;
  string *tmp___8 ;
  BOOL tmp___9 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 486
  yes[0] = (string )'y';
#line 486
  yes[1] = (string )'e';
#line 486
  yes[2] = (string )'s';
#line 486
  yes[3] = (string )'\000';
#line 486
  no[0] = (string )'n';
#line 486
  no[1] = (string )'o';
#line 486
  no[2] = (string )'\000';
#line 486
  big[0] = (string )'b';
#line 486
  big[1] = (string )'i';
#line 486
  big[2] = (string )'g';
#line 486
  big[3] = (string )'\000';
#line 486
  little[0] = (string )'l';
#line 486
  little[1] = (string )'i';
#line 486
  little[2] = (string )'t';
#line 486
  little[3] = (string )'t';
#line 486
  little[4] = (string )'l';
#line 486
  little[5] = (string )'e';
#line 486
  little[6] = (string )'\000';
#line 491
  AF_nameidx[0] = "dflt";
#line 491
  AF_nameidx[1] = "raw";
#line 491
  AF_nameidx[2] = "cdr";
#line 491
  AF_nameidx[3] = "wav";
#line 491
  AF_nameidx[4] = "???";
#line 492
  firstcut = (cdseccount_t )0;
#line 492
  lastcut___1 = (cdseccount_t )0;
  {
#line 498
  timeprintf(stasil, cmdarg.startsilence);
  }
  {
#line 499
  timeprintf(endsil, cmdarg.endsilence);
  }
  {
#line 500
  timeprintf(filength, cmdarg.fadein);
  }
  {
#line 501
  timeprintf(folength, cmdarg.fadeout);
  }
  }
#line 503
  if (input_size == -1L) {
    {
    {
#line 504
    strcpy((char */* __restrict  */)(insize), (char const   */* __restrict  */)"not sizeable/seekable (reading pipe?)");
    }
    }
  } else {
    {
    {
#line 506
    timeprintf(stime, (unsigned long )input_size);
    }
    {
#line 507
    sprintf((char */* __restrict  */)(insize), (char const   */* __restrict  */)"%li b = %li C = %li s = %s min",
            input_size, input_size / 2352L, (input_size / 2352L) / 75L, stime);
    }
    }
  }
#line 516
  if (cmdarg.numcuts > 0) {
    {
    {
#line 517
    firstcut = get_cut_value(0);
    }
    {
#line 518
    lastcut___1 = get_cut_value(cmdarg.numcuts - 1);
    }
    }
  }
  {
  {
#line 520
  timeprintf(sfirstcut, firstcut * 2352UL);
  }
  {
#line 521
  timeprintf(slastcut, lastcut___1 * 2352UL);
  }
  }
#line 522
  if (cmdarg.silencecuts) {
    {
    {
#line 523
    sprintf((char */* __restrict  */)(silence), (char const   */* __restrict  */)"%s   (threshold %li, delay %li C = %.2f s)",
            yes, cmdarg.silence_thresh, cmdarg.silence_delay, (double )((float )cmdarg.silence_delay / (float )75));
    }
    }
  } else {
    {
    {
#line 527
    strcpy((char */* __restrict  */)(silence), (char const   */* __restrict  */)(no));
    }
    }
  }
#line 529
  if ((unsigned long )cmdarg.outfilename != (unsigned long )((void *)0)) {
#line 529
    tmp = ".%02d";
  } else {
#line 529
    tmp = "";
  }
#line 529
  if ((unsigned long )cmdarg.outfilename == (unsigned long )((void *)0)) {
#line 529
    tmp___0 = "(stdout)";
  } else {
#line 529
    tmp___0 = (char const   *)cmdarg.outfilename;
  }
#line 529
  if ((unsigned long )cmdarg.infilename == (unsigned long )((void *)0)) {
#line 529
    tmp___1 = "(stdin)";
  } else {
#line 529
    tmp___1 = (char const   *)cmdarg.infilename;
  }
#line 529
  if (cmdarg.silenceinfo) {
#line 529
    tmp___2 = "[INFO]";
  } else {
#line 529
    tmp___2 = "";
  }
#line 529
  if (cmdarg.monostereo) {
#line 529
    tmp___3 = yes;
  } else {
#line 529
    tmp___3 = no;
  }
#line 529
  if (cmdarg.swapwords) {
#line 529
    tmp___4 = yes;
  } else {
#line 529
    tmp___4 = no;
  }
#line 529
  if (cmdarg.little_output) {
#line 529
    tmp___5 = little;
  } else {
#line 529
    tmp___5 = big;
  }
#line 529
  if (cmdarg.little_input) {
#line 529
    tmp___6 = little;
  } else {
#line 529
    tmp___6 = big;
  }
  {
  {
#line 529
  tmp___9 = is_localhost_little();
  }
  }
#line 529
  if (tmp___9) {
#line 529
    tmp___8 = little;
  } else {
#line 529
    tmp___8 = big;
  }
  {
  {
#line 529
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Host is:            %s\nByte order in, out: %s -> %s\nFormat in, out:     %s -> %s\nScale:              %li%%, * %f\nSwap channels:      %s\nDo ->mono->stereo:  %s\nFind silences:      %s  %s\nAdd silence:        %li C = %s min, %li C = %s min\nFade-in / -out:     %li C = %s min, %li C = %s min\nInput data size:    %s\nNumber of cuts:     %i\nSkipping before:    %s min = %li C  (excl) (first cut)\nSkipping after:     %s min = %li C  (incl) (last cut)\nInput filename:     %s\nOutput filename:    %s%s\n-\n",
          tmp___8, tmp___6, tmp___5, AF_nameidx[cmdarg.informat], AF_nameidx[cmdarg.outformat],
          cmdarg.iscale, (double )cmdarg.fscale, tmp___4, tmp___3, silence, tmp___2,
          cmdarg.startsilence / 2352UL, stasil, cmdarg.endsilence / 2352UL, endsil,
          cmdarg.fadein / 2352UL, filength, cmdarg.fadeout / 2352UL, folength, insize,
          cmdarg.numcuts, sfirstcut, firstcut, slastcut, lastcut___1, tmp___1, tmp___0,
          tmp);
  }
  }
#line 569
  return;
}
}
#line 584 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static long get_num_unit(string const   *s ) 
{ 
  long i ;
  float sec ;
  char unit[2] ;
  int r ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 588
  unit[0] = (char )'\000';
#line 588
  unit[1] = (char )'\000';
  {
#line 591
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%li%1s",
             & i, unit);
  }
  }
#line 592
  if (r == 1) {
#line 593
    unit[0] = (char )'C';
  }
#line 594
  if (r < 1) {
    {
    {
#line 595
    exit_error((exit_t )2, "number/unit syntax: ", s);
    }
    }
  } else
#line 594
  if (r == 2) {
    {
    {
#line 594
    tmp = strchr("bscC.", (int )unit[0]);
    }
    }
#line 594
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
      {
#line 595
      exit_error((exit_t )2, "number/unit syntax: ", s);
      }
      }
    }
  }
#line 596
  if (r == 2) {
#line 596
    if ((int )unit[0] == 46) {
      {
#line 597
      unit[0] = (char )'\000';
      {
#line 598
      r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%f%1s",
                 & sec, unit);
      }
      }
#line 599
      if (r == 2) {
        {
        {
#line 599
        tmp___0 = strchr("bcC", (int )unit[0]);
        }
        }
#line 599
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          {
          {
#line 600
          exit_error((exit_t )2, "number/unit syntax (fractions not with b, c): ",
                     s);
          }
          }
        }
      }
#line 602
      if (r < 1) {
        {
        {
#line 603
        exit_error((exit_t )2, "number/unit syntax: ", s);
        }
        }
      } else
#line 602
      if ((int )unit[0] != 115) {
        {
        {
#line 603
        exit_error((exit_t )2, "number/unit syntax: ", s);
        }
        }
      }
#line 604
      unit[0] = (char )'S';
    }
  }
  {
#line 610
  if ((int )unit[0] == 67) {
#line 610
    goto case_67;
  }
#line 610
  if ((int )unit[0] == 99) {
#line 610
    goto case_67;
  }
#line 613
  if ((int )unit[0] == 98) {
#line 613
    goto case_98;
  }
#line 617
  if ((int )unit[0] == 115) {
#line 617
    goto case_115;
  }
#line 620
  if ((int )unit[0] == 83) {
#line 620
    goto case_83;
  }
#line 624
  goto switch_default;
  case_67: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 611
  i *= 2352L;
#line 612
  goto switch_break;
  case_98: /* CIL Label */ 
#line 614
  i = ((i + 1176L) / 2352L) * 2352L;
#line 616
  goto switch_break;
  case_115: /* CIL Label */ 
#line 618
  i *= 176400L;
#line 619
  goto switch_break;
  case_83: /* CIL Label */ 
#line 621
  i = (long )((double )(sec * (float )75) + 0.5) * 2352L;
#line 623
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 625
  exit_error((exit_t )5, "switch", (char const   *)((void *)0));
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 629
  return (i);
}
}
#line 683 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
long get_input_size_in_cd_blocks(void) 
{ 
  long size ;

  {
#line 687
  if (input_size == -1L) {
#line 688
    return (-1L);
  }
#line 691
  size = input_size / 2352L;
#line 692
  if (size * 2352L < input_size) {
#line 693
    size ++;
  }
#line 694
  return (size);
}
}
#line 704 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static long get_neg_cut(long cut ) 
{ 
  long pos ;
  long size ;
  string buf[100] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 708
  if (input_size == -1L) {
    {
    {
#line 709
    exit_error((exit_t )2, "cut numbers must not be negative when input can\'t be sized",
               (char const   *)((void *)0));
    }
    }
  }
  {
  {
#line 713
  size = get_input_size_in_cd_blocks();
  }
#line 714
  pos = size - - cut;
  }
#line 715
  if (pos < 0L) {
    {
    {
#line 717
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"cut %li C before start of input with length %li b = %li C",
            cut, input_size, size);
    }
    {
#line 720
    exit_error((exit_t )2, (char const   *)(buf), (char const   *)((void *)0));
    }
    }
  }
#line 722
  return (pos);
}
}
#line 732 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
unsigned long get_cut_value(int n ) 
{ 
  long cut ;
  long l ;
  long tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 734
  l = 0L;
  {
#line 736
  tmp = get_num_unit((string const   *)*(cmdarg.cutstarts + n));
  }
#line 736
  cut = tmp / 2352L;
#line 737
  l = cut;
  }
#line 738
  if (cut == 0L) {
#line 738
    if (n == cmdarg.numcuts - 1) {
#line 742
      if (input_size != -1L) {
        {
        {
#line 743
        l = get_neg_cut(cut);
        }
        }
      } else {
#line 745
        l = 1826091L;
      }
    } else {
#line 738
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 746
  if (cut < 0L) {
#line 748
    if (input_size == -1L) {
      {
      {
#line 749
      exit_error((exit_t )2, "cut numbers must not be negative when input can\'t be sized",
                 (char const   *)((void *)0));
      }
      }
    } else {
      {
      {
#line 753
      l = get_neg_cut(cut);
      }
      }
    }
  }
#line 757
  return ((unsigned long )l);
}
}
#line 767 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
unsigned long get_silence_value(string const   *s ) 
{ 
  long l ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 771
  l = get_num_unit(s);
  }
  }
#line 772
  if (l < 0L) {
    {
    {
#line 773
    exit_error((exit_t )2, "negative silence number does not make sense", (char const   *)((void *)0));
    }
    }
  }
#line 775
  return ((unsigned long )l);
}
}
#line 787 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
void get_cmdarg_info(cmdarg_t *pcmdarg ) 
{ 


  {
#line 789
  *pcmdarg = cmdarg;
#line 790
  return;
}
}
#line 800 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
void init_process_info(process_t *pinfo ) 
{ 
  size_t tmp ;

  {
  {
#line 802
  tmp = (size_t )0;
#line 802
  pinfo->n_returned = tmp;
#line 802
  pinfo->n_in = tmp;
#line 804
  pinfo->first = (BOOL )1;
#line 805
  pinfo->last = (BOOL )0;
  {
#line 807
  pinfo->little_host = is_localhost_little();
  }
#line 808
  pinfo->from_little = cmdarg.little_input;
#line 809
  pinfo->to_little = cmdarg.little_output;
#line 810
  pinfo->iscale = (short )cmdarg.iscale;
#line 811
  pinfo->fscale = cmdarg.fscale;
#line 812
  pinfo->swap_channels = cmdarg.swapwords;
  }
#line 813
  if (cmdarg.monostereo) {
#line 813
    pinfo->monostereo = (monostereo_t )3;
  } else {
#line 813
    pinfo->monostereo = (monostereo_t )0;
  }
#line 814
  pinfo->silencecuts = cmdarg.silencecuts;
#line 815
  pinfo->silence_thresh = (unsigned short )cmdarg.silence_thresh;
#line 816
  pinfo->silence_delay = (unsigned short )cmdarg.silence_delay;
#line 817
  pinfo->silence_val = cmdarg.verbose;
#line 818
  pinfo->fadein = (cdseccount_t )0;
#line 819
  pinfo->fadeout = (cdseccount_t )0;
#line 821
  return;
}
}
#line 124 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
static void version_text___0(void) ;
#line 132 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.c"
static void version_text___0(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 134
  fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"wav2cdr [OPTIONS] [INPUTFILE [OUTPUTFILE]]\nwav2cdr [OPTIONS] --cut -- CUTNUMBER CUTNUMBER [CUTNUMBER...]\n%-65s(%s)\n\nConvert a wav file to one or more cdr files which can be written on CD.\nReads stdin, writes stdout. See --help for more information.\n\n",
          "Version 2.3.3  Copyright (C) 27 Oct 2000 by Volker Kuhlmann", "GNU getopt()");
  }
  }
#line 143
  return;
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 771
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 776
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 362 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/wav2cdr.h"
void close_message_file(void) ;
#line 49 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
unsigned long bytes_in  ;
#line 49 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
unsigned long bytes_out  ;
#line 53 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
string const   outname[1024]  ;
#line 64 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
static FILE *infile  =    (FILE *)((void *)0);
#line 64 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
static FILE *outfile  =    (FILE *)((void *)0);
#line 76 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void open_input_file(string const   *name ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 78
  bytes_in = 0UL;
#line 81
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 82
    infile = stdin;
  } else {
    {
    {
#line 84
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Opening file(r):   %s\n-\n",
            name);
    }
    {
#line 86
    infile = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
    }
    }
#line 87
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
      {
#line 88
      exit_error((exit_t )3, "opening file ", name);
      }
      }
    }
  }
#line 90
  return;
}
}
#line 97 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void close_input_file(void) 
{ 
  int r ;
  char *__cil_tmp2 ;

  {
#line 99
  r = 0;
#line 101
  if ((unsigned long )infile != (unsigned long )stdin) {
    {
    {
#line 102
    r = fclose(infile);
    }
    }
  }
#line 103
  infile = (FILE *)((void *)0);
#line 104
  if (r != 0) {
    {
    {
#line 105
    exit_error((exit_t )3, "closing input", (char const   *)((void *)0));
    }
    }
  }
#line 107
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
long get_file_size(string const   *name , FILE *stream ) 
{ 
  FILE *file ;
  fpos_t pos ;
  long size ;
  int r ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 126
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 127
    file = stream;
  } else {
    {
    {
#line 129
    file = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
    }
    }
#line 130
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      {
      {
#line 131
      tmp = __errno_location();
      }
      {
#line 131
      tmp___0 = strerror(*tmp);
      }
      {
#line 131
      fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Failed to open file %s (%s)\n",
              name, tmp___0);
      }
      }
#line 133
      return (-1L);
    }
  }
  {
  {
#line 138
  fgetpos((FILE */* __restrict  */)file, (fpos_t */* __restrict  */)(& pos));
  }
  {
#line 139
  r = fseek(file, 0L, 2);
  }
  }
#line 141
  if (r == 0) {
    {
    {
#line 142
    size = ftell(file);
    }
    {
#line 145
    fsetpos(file, (fpos_t const   *)(& pos));
    }
    }
  } else {
#line 148
    size = -1L;
  }
#line 151
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
    {
#line 152
    fclose(file);
    }
    }
  }
#line 154
  return (size);
}
}
#line 168 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void open_output_file(string const   *name , int track___1 ) 
{ 
  size_t l ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 172
  bytes_out = 0UL;
#line 175
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 176
    outfile = stdout;
  } else {
    {
    {
#line 178
    strncpy((char */* __restrict  */)(outname), (char const   */* __restrict  */)name,
            (size_t )1024);
    }
#line 179
    outname[1023] = (string )'\000';
    }
#line 180
    if (track___1 != 0) {
      {
#line 181
      outname[1010] = (string )'\000';
      {
#line 182
      l = strlen((char const   *)(outname));
      }
      {
#line 183
      sprintf((char */* __restrict  */)(outname + l), (char const   */* __restrict  */)".%02i",
              track___1);
      }
      }
    }
    {
    {
#line 185
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Opening file(w):   %s\n",
            outname);
    }
    {
#line 187
    outfile = fopen((char const   */* __restrict  */)(outname), (char const   */* __restrict  */)"wb");
    }
    }
#line 188
    if ((unsigned long )outfile == (unsigned long )((void *)0)) {
      {
      {
#line 189
      exit_error((exit_t )3, "opening file ", (char const   *)(outname));
      }
      }
    }
  }
#line 191
  return;
}
}
#line 198 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void close_output_file(void) 
{ 
  int r ;
  char *__cil_tmp2 ;

  {
  {
#line 200
  r = 0;
  {
#line 202
  r = fclose(outfile);
  }
#line 203
  outfile = (FILE *)((void *)0);
  }
#line 204
  if (r != 0) {
    {
    {
#line 205
    exit_error((exit_t )3, "closing file", (char const   *)((void *)0));
    }
    }
  }
#line 207
  return;
}
}
#line 211 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
FILE *open_message_file(void) 
{ 
  FILE *file ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 218
  file = fopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"wb+");
  }
  }
#line 220
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
    {
#line 221
    exit_error((exit_t )3, "opening bit bucket", (char const   *)((void *)0));
    }
    }
  }
#line 222
  return (file);
}
}
#line 227 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void close_message_file(void) 
{ 
  int r ;
  char *__cil_tmp2 ;

  {
  {
#line 229
  r = 0;
  {
#line 231
  r = fclose(msgfile);
  }
#line 232
  msgfile = (FILE *)((void *)0);
  }
#line 233
  if (r != 0) {
    {
    {
#line 234
    exit_error((exit_t )3, "closing bit bucket", (char const   *)((void *)0));
    }
    }
  }
#line 236
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void emergency_close(void) 
{ 


  {
#line 246
  if ((unsigned long )infile != (unsigned long )((void *)0)) {
#line 246
    if ((unsigned long )infile != (unsigned long )stdin) {
      {
      {
#line 247
      fclose(infile);
      }
      }
    }
  }
#line 248
  if ((unsigned long )outfile != (unsigned long )((void *)0)) {
#line 248
    if ((unsigned long )outfile != (unsigned long )stdout) {
      {
      {
#line 249
      fclose(outfile);
      }
      }
    }
  }
#line 250
  if ((unsigned long )msgfile != (unsigned long )((void *)0)) {
#line 250
    if ((unsigned long )msgfile != (unsigned long )stdout) {
#line 250
      if ((unsigned long )msgfile != (unsigned long )stderr) {
        {
        {
#line 251
        fclose(msgfile);
        }
        }
      }
    }
  }
#line 252
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void read_wav_header(wav_header_t *header ) 
{ 
  size_t numread ;
  process_t proc ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 268
  numread = fread((void */* __restrict  */)header, (size_t )1, (size_t )sizeof(wav_header_t ),
                  (FILE */* __restrict  */)infile);
  }
  }
#line 269
  if ((unsigned long )numread != sizeof(wav_header_t )) {
    {
    {
#line 270
    tmp = ferror(infile);
    }
    }
#line 270
    if (tmp) {
      {
      {
#line 271
      exit_error((exit_t )3, "reading wav header", (char const   *)((void *)0));
      }
      }
    } else {
      {
      {
#line 273
      exit_error((exit_t )3, "EOF while reading wav header", (char const   *)((void *)0));
      }
      }
    }
  }
  {
  {
#line 277
  init_process_info(& proc);
  }
  }
#line 278
  if (! proc.little_host) {
#line 279
    header->RIFF.size = ((((header->RIFF.size >> 24) & 255UL) | ((header->RIFF.size >> 8) & 65280UL)) | ((header->RIFF.size << 8) & 16711680UL)) | (header->RIFF.size << 24);
#line 280
    header->Format.size = ((((header->Format.size >> 24) & 255UL) | ((header->Format.size >> 8) & 65280UL)) | ((header->Format.size << 8) & 16711680UL)) | (header->Format.size << 24);
#line 281
    header->FormatTag = (UINT16 )((((int )header->FormatTag >> 8) & 255) | ((int )header->FormatTag << 8));
#line 282
    header->channels = (UINT16 )((((int )header->channels >> 8) & 255) | ((int )header->channels << 8));
#line 283
    header->SamplingRate = ((((header->SamplingRate >> 24) & 255UL) | ((header->SamplingRate >> 8) & 65280UL)) | ((header->SamplingRate << 8) & 16711680UL)) | (header->SamplingRate << 24);
#line 284
    header->AvgBytesPerSec = ((((header->AvgBytesPerSec >> 24) & 255UL) | ((header->AvgBytesPerSec >> 8) & 65280UL)) | ((header->AvgBytesPerSec << 8) & 16711680UL)) | (header->AvgBytesPerSec << 24);
#line 285
    header->BlockAlignment = (UINT16 )((((int )header->BlockAlignment >> 8) & 255) | ((int )header->BlockAlignment << 8));
#line 286
    header->BitsPerSample = (UINT16 )((((int )header->BitsPerSample >> 8) & 255) | ((int )header->BitsPerSample << 8));
#line 287
    header->Data.size = ((((header->Data.size >> 24) & 255UL) | ((header->Data.size >> 8) & 65280UL)) | ((header->Data.size << 8) & 16711680UL)) | (header->Data.size << 24);
  }
#line 291
  if ((int )header->channels != 2) {
    {
    {
#line 294
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Can only handle wav data with: \n  2 channels, %li Hz sampling rate, 16 bits per sample\nI will ignore that this wav data is different, but expect garbled data.\n",
            44100L);
    }
    }
  } else
#line 291
  if (header->SamplingRate != 44100UL) {
    {
    {
#line 294
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Can only handle wav data with: \n  2 channels, %li Hz sampling rate, 16 bits per sample\nI will ignore that this wav data is different, but expect garbled data.\n",
            44100L);
    }
    }
  } else
#line 291
  if ((int )header->BitsPerSample != 16) {
    {
    {
#line 294
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Can only handle wav data with: \n  2 channels, %li Hz sampling rate, 16 bits per sample\nI will ignore that this wav data is different, but expect garbled data.\n",
            44100L);
    }
    }
  }
#line 301
  if ((int )header->FormatTag != 1) {
    {
    {
#line 302
    fprintf((FILE */* __restrict  */)msgfile, (char const   */* __restrict  */)"Ignoring unrecognised setting(s) in this wav header\n");
    }
    }
  }
#line 305
  return;
}
}
#line 318 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
static wav_header_t wh  = 
#line 318
     {{{(char )'R', (char )'I', (char )'F', (char )'F'}, sizeof(wav_header_t ) - sizeof(wav_chunkheader_t )},
    {(char )'W', (char )'A', (char )'V', (char )'E'}, {{(char )'f', (char )'m', (char )'t',
                                                        (char )' '}, (UINT32 )16},
    (UINT16 )1, (UINT16 )2, (UINT32 )44100L, (UINT32 )176400L, (UINT16 )4, (UINT16 )16,
    {{(char )'d', (char )'a', (char )'t', (char )'a'}, (UINT32 )0}};
#line 316 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void make_wav_header(wav_header_t *header , unsigned long databytes ) 
{ 


  {
#line 328
  *header = wh;
#line 329
  header->RIFF.size += databytes;
#line 330
  header->Data.size = databytes;
#line 332
  return;
}
}
#line 346 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
void write_wav_header(wav_header_t const   *header ) 
{ 
  size_t numwritten ;
  int r ;
  wav_header_t wh___1 ;
  process_t proc ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 353
  wh___1 = (wav_header_t )*header;
  {
#line 356
  init_process_info(& proc);
  }
  }
#line 357
  if (! proc.little_host) {
#line 358
    wh___1.RIFF.size = ((((wh___1.RIFF.size >> 24) & 255UL) | ((wh___1.RIFF.size >> 8) & 65280UL)) | ((wh___1.RIFF.size << 8) & 16711680UL)) | (wh___1.RIFF.size << 24);
#line 359
    wh___1.Format.size = ((((wh___1.Format.size >> 24) & 255UL) | ((wh___1.Format.size >> 8) & 65280UL)) | ((wh___1.Format.size << 8) & 16711680UL)) | (wh___1.Format.size << 24);
#line 360
    wh___1.FormatTag = (UINT16 )((((int )wh___1.FormatTag >> 8) & 255) | ((int )wh___1.FormatTag << 8));
#line 361
    wh___1.channels = (UINT16 )((((int )wh___1.channels >> 8) & 255) | ((int )wh___1.channels << 8));
#line 362
    wh___1.SamplingRate = ((((wh___1.SamplingRate >> 24) & 255UL) | ((wh___1.SamplingRate >> 8) & 65280UL)) | ((wh___1.SamplingRate << 8) & 16711680UL)) | (wh___1.SamplingRate << 24);
#line 363
    wh___1.AvgBytesPerSec = ((((wh___1.AvgBytesPerSec >> 24) & 255UL) | ((wh___1.AvgBytesPerSec >> 8) & 65280UL)) | ((wh___1.AvgBytesPerSec << 8) & 16711680UL)) | (wh___1.AvgBytesPerSec << 24);
#line 364
    wh___1.BlockAlignment = (UINT16 )((((int )wh___1.BlockAlignment >> 8) & 255) | ((int )wh___1.BlockAlignment << 8));
#line 365
    wh___1.BitsPerSample = (UINT16 )((((int )wh___1.BitsPerSample >> 8) & 255) | ((int )wh___1.BitsPerSample << 8));
#line 366
    wh___1.Data.size = ((((wh___1.Data.size >> 24) & 255UL) | ((wh___1.Data.size >> 8) & 65280UL)) | ((wh___1.Data.size << 8) & 16711680UL)) | (wh___1.Data.size << 24);
  }
  {
  {
#line 376
  r = fseek(outfile, 0L, 0);
  }
  }
#line 377
  if (r != 0) {
    {
    {
#line 378
    exit_error((exit_t )3, "for writing wav format output must be seekable", (char const   *)((void *)0));
    }
    }
  }
  {
  {
#line 381
  numwritten = fwrite((void const   */* __restrict  */)(& wh___1), (size_t )1, (size_t )sizeof(wav_header_t ),
                      (FILE */* __restrict  */)outfile);
  }
  }
#line 382
  if ((unsigned long )numwritten != sizeof(wav_header_t )) {
    {
    {
#line 383
    exit_error((exit_t )3, "writing wav header", (char const   *)((void *)0));
    }
    }
  }
#line 387
  if (bytes_out < (unsigned long )numwritten) {
#line 388
    bytes_out = (unsigned long )numwritten;
  }
#line 390
  return;
}
}
#line 402 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
size_t read_block(void *buf , size_t bytes ) 
{ 
  size_t numread ;
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 406
  numread = fread((void */* __restrict  */)buf, (size_t )1, bytes, (FILE */* __restrict  */)infile);
  }
  }
#line 407
  if (numread != bytes) {
    {
    {
#line 408
    tmp = ferror(infile);
    }
    }
#line 408
    if (tmp) {
      {
      {
#line 409
      exit_error((exit_t )3, "reading ", (char const   *)((void *)0));
      }
      }
    }
  }
#line 411
  bytes_in += (unsigned long )numread;
#line 412
  return (numread);
}
}
#line 424 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
BOOL read_eof(void) 
{ 
  int tmp ;

  {
  {
  {
#line 426
  tmp = feof(infile);
  }
  }
#line 426
  return ((BOOL )tmp);
}
}
#line 439 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
size_t write_block(void const   *buf , size_t bytes ) 
{ 
  size_t numwritten ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 443
  numwritten = fwrite((void const   */* __restrict  */)buf, (size_t )1, bytes, (FILE */* __restrict  */)outfile);
  }
  }
#line 445
  if (numwritten != bytes) {
    {
    {
#line 446
    exit_error((exit_t )3, "writing ", (char const   *)((void *)0));
    }
    }
  }
#line 448
  bytes_out += (unsigned long )numwritten;
#line 449
  return (numwritten);
}
}
#line 67 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static cmdarg_t cmdarg___0  = 
#line 67 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
     {(BOOL )1, (BOOL )0, 100L, (float )1.0, (BOOL )0, (BOOL )0, (BOOL )0, (BOOL )0,
    10L, 30L, 0UL, 0UL, (audioformat_t )3, (audioformat_t )2, 0UL, 0UL, (string *)((void *)0),
    (string *)((void *)0), 0, (string **)((void *)0), (BOOL )0, (BOOL )0, (BOOL )0,
    (BOOL )0, (BOOL )0};
#line 76 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static long input_size___0  ;
#line 83
static long get_num_unit___0(string const   *s ) ;
#line 88
static void check_monotonous_cuts___0(void) ;
#line 89
static long get_neg_cut___0(long cut ) ;
#line 458 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static void check_monotonous_cuts___0(void) 
{ 
  int j ;
  unsigned long this ;
  unsigned long next ;
  string buf[80] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 464
  j = 0;
  {
#line 464
  this = get_cut_value(0);
  }
  }
  {
  {
#line 464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 464
    if (! (j < cmdarg___0.numcuts - 1)) {
#line 464
      goto while_break;
    }
    {
    {
#line 465
    next = get_cut_value(j + 1);
    }
    }
#line 466
    if (next < this) {
      {
      {
#line 467
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"cut number (N+1) not >= (N)  (%li not >= %li)",
              next, this);
      }
      {
#line 469
      exit_error((exit_t )2, (char const   *)(buf), (char const   *)((void *)0));
      }
      }
    }
#line 471
    this = next;
#line 464
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return;
}
}
#line 584 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static long get_num_unit___0(string const   *s ) 
{ 
  long i ;
  float sec ;
  char unit[2] ;
  int r ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 588
  unit[0] = (char )'\000';
#line 588
  unit[1] = (char )'\000';
  {
#line 591
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%li%1s",
             & i, unit);
  }
  }
#line 592
  if (r == 1) {
#line 593
    unit[0] = (char )'C';
  }
#line 594
  if (r < 1) {
    {
    {
#line 595
    exit_error((exit_t )2, "number/unit syntax: ", s);
    }
    }
  } else
#line 594
  if (r == 2) {
    {
    {
#line 594
    tmp = strchr("bscC.", (int )unit[0]);
    }
    }
#line 594
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
      {
#line 595
      exit_error((exit_t )2, "number/unit syntax: ", s);
      }
      }
    }
  }
#line 596
  if (r == 2) {
#line 596
    if ((int )unit[0] == 46) {
      {
#line 597
      unit[0] = (char )'\000';
      {
#line 598
      r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%f%1s",
                 & sec, unit);
      }
      }
#line 599
      if (r == 2) {
        {
        {
#line 599
        tmp___0 = strchr("bcC", (int )unit[0]);
        }
        }
#line 599
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
          {
          {
#line 600
          exit_error((exit_t )2, "number/unit syntax (fractions not with b, c): ",
                     s);
          }
          }
        }
      }
#line 602
      if (r < 1) {
        {
        {
#line 603
        exit_error((exit_t )2, "number/unit syntax: ", s);
        }
        }
      } else
#line 602
      if ((int )unit[0] != 115) {
        {
        {
#line 603
        exit_error((exit_t )2, "number/unit syntax: ", s);
        }
        }
      }
#line 604
      unit[0] = (char )'S';
    }
  }
  {
#line 610
  if ((int )unit[0] == 67) {
#line 610
    goto case_67;
  }
#line 610
  if ((int )unit[0] == 99) {
#line 610
    goto case_67;
  }
#line 613
  if ((int )unit[0] == 98) {
#line 613
    goto case_98;
  }
#line 617
  if ((int )unit[0] == 115) {
#line 617
    goto case_115;
  }
#line 620
  if ((int )unit[0] == 83) {
#line 620
    goto case_83;
  }
#line 624
  goto switch_default;
  case_67: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 611
  i *= 2352L;
#line 612
  goto switch_break;
  case_98: /* CIL Label */ 
#line 614
  i = ((i + 1176L) / 2352L) * 2352L;
#line 616
  goto switch_break;
  case_115: /* CIL Label */ 
#line 618
  i *= 176400L;
#line 619
  goto switch_break;
  case_83: /* CIL Label */ 
#line 621
  i = (long )((double )(sec * (float )75) + 0.5) * 2352L;
#line 623
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 625
  exit_error((exit_t )5, "switch", (char const   *)((void *)0));
  }
  }
  switch_break: /* CIL Label */ ;
  }
#line 629
  return (i);
}
}
#line 704 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/cmdarg.c"
static long get_neg_cut___0(long cut ) 
{ 
  long pos ;
  long size ;
  string buf[100] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 708
  if (input_size___0 == -1L) {
    {
    {
#line 709
    exit_error((exit_t )2, "cut numbers must not be negative when input can\'t be sized",
               (char const   *)((void *)0));
    }
    }
  }
  {
  {
#line 713
  size = get_input_size_in_cd_blocks();
  }
#line 714
  pos = size - - cut;
  }
#line 715
  if (pos < 0L) {
    {
    {
#line 717
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"cut %li C before start of input with length %li b = %li C",
            cut, input_size___0, size);
    }
    {
#line 720
    exit_error((exit_t )2, (char const   *)(buf), (char const   *)((void *)0));
    }
    }
  }
#line 722
  return (pos);
}
}
#line 64 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
static FILE *infile___0  =    (FILE *)((void *)0);
#line 64 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
static FILE *outfile___0  =    (FILE *)((void *)0);
#line 318 "/home/wslee/benchmarks/sound/wav2cdr-2.3.3/fileio.c"
static wav_header_t wh___0  = 
#line 318
     {{{(char )'R', (char )'I', (char )'F', (char )'F'}, sizeof(wav_header_t ) - sizeof(wav_chunkheader_t )},
    {(char )'W', (char )'A', (char )'V', (char )'E'}, {{(char )'f', (char )'m', (char )'t',
                                                        (char )' '}, (UINT32 )16},
    (UINT16 )1, (UINT16 )2, (UINT32 )44100L, (UINT32 )176400L, (UINT16 )4, (UINT16 )16,
    {{(char )'d', (char )'a', (char )'t', (char )'a'}, (UINT32 )0}};
