/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 7 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.h"
struct __anonstruct_br_unit_list_27 {
   int numunits ;
   int allocatedunits ;
   int *devs ;
   int *houses ;
};
#line 7 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.h"
typedef struct __anonstruct_br_unit_list_27 br_unit_list;
#line 14 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.h"
struct __anonstruct_br_control_info_28 {
   int inverse ;
   int repeat ;
   int numcmds ;
   int allocatedcmds ;
   br_unit_list **units ;
   int *cmds ;
};
#line 14 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.h"
typedef struct __anonstruct_br_control_info_28 br_control_info;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 56 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.h"
char const   *br_cmd_list[9] ;
#line 58
int br_cmd(int fd , unsigned char unit , int cmd ) ;
#line 59
void br_error(char *where , char *problem ) ;
#line 65
int br_pre_cmd_delay ;
#line 66
int br_post_cmd_delay ;
#line 67
int br_inter_bit_delay ;
#line 73
int br_verbose ;
#line 80
void (*br_error_handler)(char * , char * ) ;
#line 27 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char housecode_table[16]  = 
#line 27 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
  {      (char)6,      (char)7,      (char)4,      (char)5, 
        (char)8,      (char)9,      (char)10,      (char)11, 
        (char)14,      (char)15,      (char)12,      (char)13, 
        (char)0,      (char)1,      (char)2,      (char)3};
#line 38 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char device_table[16][2]  = 
#line 38
  { {        (char)0,        (char)0}, 
   {        (char)0,        (char)16}, 
   {        (char)0,        (char)8}, 
   {        (char)0,        (char)24}, 
   {        (char)0,        (char)64}, 
   {        (char)0,        (char)80}, 
   {        (char)0,        (char)72}, 
   {        (char)0,        (char)88}, 
   {        (char)4,        (char)0}, 
   {        (char)4,        (char)16}, 
   {        (char)4,        (char)8}, 
   {        (char)4,        (char)24}, 
   {        (char)4,        (char)64}, 
   {        (char)4,        (char)80}, 
   {        (char)4,        (char)72}, 
   {        (char)4,        (char)88}};
#line 49 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char cmd_table[9]  = 
#line 49
  {      (char)0,      (char)32,      (char)-104,      (char)-120, 
        (char)-128,      (char)-111,      (char)-124,      (char)-108, 
        (char)32};
#line 80 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
int br_pre_cmd_delay  =    350000;
#line 81 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
int br_post_cmd_delay  =    350000;
#line 82 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
int br_inter_bit_delay  =    1400;
#line 84 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
int br_verbose  =    0;
#line 86 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
char const   *br_cmd_list[9]  = 
#line 86
  {      "ON",      "OFF",      "DIM",      "BRIGHT", 
        "ALL OFF",      "ALL ON",      "ALL LAMPS OFF",      "ALL LAMPS ON", 
        "PAUSE"};
#line 105
static void br_int_err_handler(char *where , char *problem ) ;
#line 107 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
void (*br_error_handler)(char * , char * )  =    & br_int_err_handler;
#line 109 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
void br_error(char *where , char *problem ) 
{ 
  int tmperrno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
  {
#line 114
  tmp = __errno_location();
  }
#line 114
  tmperrno = *tmp;
  }
#line 116
  if (br_error_handler) {
    {
    {
#line 117
    (*br_error_handler)(where, problem);
    }
    }
  }
  {
  {
#line 119
  tmp___0 = __errno_location();
  }
#line 119
  *tmp___0 = tmperrno;
  }
#line 120
  return;
}
}
#line 122 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static void br_int_err_handler(char *where , char *problem ) 
{ 
  int tmperrno ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 124
  tmp = __errno_location();
  }
#line 124
  tmperrno = *tmp;
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: ");
  }
  }
#line 129
  if (tmperrno) {
    {
    {
#line 130
    tmp___0 = strerror(tmperrno);
    }
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] ",
            tmp___0);
    }
    }
  }
#line 132
  if (problem) {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
            problem);
    }
    }
  }
#line 135
  if (where) {
    {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in %s",
            where);
    }
    }
  }
#line 138
  if (! where) {
#line 138
    if (! problem) {
#line 138
      if (! tmperrno) {
        {
        {
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(unknown error)");
        }
        }
      }
    }
  }
  {
  {
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int usec_sleep(long usecs ) 
{ 
  struct timeval sleeptime ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 153
  sleeptime.tv_sec = usecs / 1000000L;
#line 154
  sleeptime.tv_usec = usecs % 1000000L;
  {
#line 156
  tmp = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& sleeptime));
  }
  }
#line 156
  if (tmp < 0) {
    {
    {
#line 157
    br_error((char *)"usec_sleep", (char *)"select");
    }
    }
#line 158
    return (-1);
  }
#line 161
  return (0);
}
}
#line 164 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int usec_delay(long usecs ) 
{ 
  struct timeval endtime ;
  struct timeval currtime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 178
  tmp = gettimeofday((struct timeval */* __restrict  */)(& endtime), (__timezone_ptr_t )((void *)0));
  }
  }
#line 178
  if (tmp < 0) {
    {
    {
#line 179
    br_error((char *)"usec_delay", (char *)"gettimeofday");
    }
    }
#line 180
    return (-1);
  }
#line 183
  endtime.tv_usec += usecs;
#line 185
  if (endtime.tv_usec >= 1000000L) {
#line 186
    (endtime.tv_sec) ++;
#line 187
    endtime.tv_usec -= 1000000L;
  }
  {
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 191
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& currtime), (__timezone_ptr_t )((void *)0));
    }
    }
#line 191
    if (tmp___0 < 0) {
      {
      {
#line 192
      br_error((char *)"usec_delay", (char *)"gettimeofday");
      }
      }
#line 193
      return (-1);
    }
#line 190
    if (endtime.tv_sec == currtime.tv_sec) {
#line 190
      tmp___1 = endtime.tv_usec > currtime.tv_usec;
    } else {
#line 190
      tmp___1 = endtime.tv_sec > currtime.tv_sec;
    }
#line 190
    if (! tmp___1) {
#line 190
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 200 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int bits_out(int const   fd , int const   bits ) 
{ 
  int out ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 213
  if (bits) {
#line 213
    out = 2;
  } else {
#line 213
    out = 4;
  }
  {
  {
#line 217
  tmp = ioctl((int )fd, 21527UL, & out);
  }
  }
#line 217
  if (tmp < 0) {
    {
    {
#line 218
    br_error((char *)"bits_out", (char *)"ioctl");
    }
    }
#line 219
    return (-1);
  }
  {
  {
#line 222
  tmp___0 = usec_delay((long )br_inter_bit_delay);
  }
  }
#line 222
  if (tmp___0 < 0) {
#line 223
    return (-1);
  }
#line 225
  return (0);
}
}
#line 228 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int clock_out(int const   fd ) 
{ 
  int out ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 235
  out = 6;
  {
#line 238
  tmp = ioctl((int )fd, 21526UL, & out);
  }
  }
#line 238
  if (tmp < 0) {
    {
    {
#line 239
    br_error((char *)"clock_out", (char *)"ioctl");
    }
    }
#line 240
    return (-1);
  }
  {
  {
#line 243
  tmp___0 = usec_delay((long )br_inter_bit_delay);
  }
  }
#line 243
  if (tmp___0 < 0) {
#line 244
    return (-1);
  }
#line 246
  return (0);
}
}
#line 250 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
int br_cmd(int fd , unsigned char unit , int cmd ) 
{ 
  unsigned char cmd_seq[5] ;
  register int i ;
  register int j ;
  unsigned char byte ;
  int out ;
  int housecode ;
  int serial_state ;
  int device ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 259
  cmd_seq[0] = (unsigned char)213;
#line 259
  cmd_seq[1] = (unsigned char)170;
#line 259
  cmd_seq[2] = (unsigned char)0;
#line 259
  cmd_seq[3] = (unsigned char)0;
#line 259
  cmd_seq[4] = (unsigned char)173;
#line 274
  if (cmd > 8) {
#line 275
    return (-1);
  } else
#line 274
  if (cmd < 0) {
#line 275
    return (-1);
  }
#line 282
  if (cmd == 2) {
#line 283
    unit = (unsigned char )((int )unit & 240);
  } else
#line 282
  if (cmd == 3) {
#line 283
    unit = (unsigned char )((int )unit & 240);
  }
#line 285
  if (br_verbose >= 2) {
#line 286
    if (cmd == 8) {
      {
      {
#line 287
      printf((char const   */* __restrict  */)"Pausing 1 second\n");
      }
      }
    } else
#line 288
    if (cmd == 2) {
      {
      {
#line 289
      printf((char const   */* __restrict  */)"Sending command %s to %c\n", br_cmd_list[cmd],
             65 + (((int )unit & 240) >> 4));
      }
      }
    } else
#line 288
    if (cmd == 3) {
      {
      {
#line 289
      printf((char const   */* __restrict  */)"Sending command %s to %c\n", br_cmd_list[cmd],
             65 + (((int )unit & 240) >> 4));
      }
      }
    } else {
      {
      {
#line 292
      printf((char const   */* __restrict  */)"Sending command %s to %c%d\n", br_cmd_list[cmd],
             65 + (((int )unit & 240) >> 4), ((int )unit & 15) + 1);
      }
      }
    }
  }
#line 298
  if (cmd == 8) {
    {
    {
#line 299
    tmp = usec_sleep(1000000L);
    }
    }
#line 299
    return (tmp);
  }
  {
  {
#line 323
  tmp___0 = ioctl(fd, 21525UL, & serial_state);
  }
  }
#line 323
  if (tmp___0 < 0) {
    {
    {
#line 324
    br_error((char *)"br_cmd", (char *)"ioctl");
    }
    }
#line 325
    return (-1);
  }
  {
#line 332
  serial_state &= 6;
#line 339
  serial_state ^= 6;
#line 341
  housecode = (int )unit >> 4;
#line 342
  device = (int )unit & 15;
#line 348
  cmd_seq[2] = (unsigned char )((int )cmd_seq[2] | (((int )housecode_table[housecode] << 4) | (int )device_table[device][0]));
#line 349
  cmd_seq[3] = (unsigned char )((int )cmd_seq[3] | ((int )device_table[device][1] | (int )cmd_table[cmd]));
  {
#line 355
  tmp___1 = clock_out((int const   )fd);
  }
  }
#line 355
  if (tmp___1 < 0) {
#line 356
    return (-1);
  }
  {
  {
#line 358
  tmp___2 = usec_sleep((long )br_pre_cmd_delay);
  }
  }
#line 358
  if (tmp___2 < 0) {
#line 359
    return (-1);
  }
#line 361
  if (br_verbose == 5) {
    {
    {
#line 362
    printf((char const   */* __restrict  */)"              -------HEAD------ -----COMMAND----- --FOOT--\n");
    }
    {
#line 363
    printf((char const   */* __restrict  */)"sending bits: ");
    }
    }
  } else
#line 364
  if (br_verbose == 4) {
    {
    {
#line 365
    printf((char const   */* __restrict  */)"Sending bytes: ");
    }
    }
  }
#line 368
  j = 0;
  {
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 368
    if (! (j < 5)) {
#line 368
      goto while_break;
    }
#line 369
    byte = cmd_seq[j];
#line 371
    if (br_verbose == 4) {
      {
      {
#line 372
      printf((char const   */* __restrict  */)"%02x", (unsigned int )byte);
      }
      }
    }
#line 378
    i = 0;
    {
    {
#line 378
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 378
      if (! (i < 8)) {
#line 378
        goto while_break___0;
      }
#line 379
      if ((int )byte & 128) {
#line 379
        out = 1;
      } else {
#line 379
        out = 0;
      }
#line 380
      byte = (unsigned char )((int )byte << 1);
#line 382
      if (br_verbose == 5) {
        {
        {
#line 383
        printf((char const   */* __restrict  */)"%d", out);
        }
        }
      }
      {
      {
#line 385
      tmp___3 = bits_out((int const   )fd, (int const   )out);
      }
      }
#line 385
      if (tmp___3 < 0) {
#line 386
        return (-1);
      } else {
        {
        {
#line 385
        tmp___4 = clock_out((int const   )fd);
        }
        }
#line 385
        if (tmp___4 < 0) {
#line 386
          return (-1);
        }
      }
#line 378
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 389
    if (br_verbose == 4) {
      {
      {
#line 390
      printf((char const   */* __restrict  */)" ");
      }
      }
    } else
#line 389
    if (br_verbose == 5) {
      {
      {
#line 390
      printf((char const   */* __restrict  */)" ");
      }
      }
    }
#line 368
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (br_verbose == 4) {
    {
    {
#line 394
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 395
    fflush(stdout);
    }
    }
  } else
#line 393
  if (br_verbose == 5) {
    {
    {
#line 394
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 395
    fflush(stdout);
    }
    }
  }
  {
  {
#line 402
  tmp___5 = clock_out((int const   )fd);
  }
  }
#line 402
  if (tmp___5 < 0) {
#line 403
    return (-1);
  }
  {
  {
#line 405
  tmp___6 = usec_sleep((long )br_post_cmd_delay);
  }
  }
#line 405
  if (tmp___6 < 0) {
#line 406
    return (-1);
  }
  {
  {
#line 412
  tmp___7 = ioctl(fd, 21527UL, & serial_state);
  }
  }
#line 412
  if (tmp___7 < 0) {
    {
    {
#line 413
    br_error((char *)"x10_br_out", (char *)"ioctl");
    }
    }
#line 414
    return (-1);
  }
#line 424
  return (0);
}
}
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 598
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 692
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 698
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 701
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 184
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 25 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.h"
int br_execute(int fd , br_control_info *cinfo ) ;
#line 26
br_unit_list *br_new_unit_list(void) ;
#line 27
int br_free_unit_list(br_unit_list *units ) ;
#line 33
int br_add_ul_cmd(br_control_info *cinfo , int cmd , br_unit_list *units ) ;
#line 35
int br_add_cmd(br_control_info *cinfo , int cmd , int house , int dev ) ;
#line 38
br_control_info *br_new_control_info(void) ;
#line 39
int br_free_control_info(br_control_info *cinfo ) ;
#line 40
int br_strtoul(char *ulptr , br_unit_list *units , char **endptr ) ;
#line 43
int br_strtohc(char *hcptr , char **endptr ) ;
#line 44
int br_get_num_commands(br_control_info *cinfo ) ;
#line 45
int br_get_ul_device(br_unit_list *units , int index___0 ) ;
#line 46
int br_get_ul_house(br_unit_list *units , int index___0 ) ;
#line 47
int br_get_num_units(br_unit_list *units ) ;
#line 49
int br_default_house ;
#line 60 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int Verbose  =    0;
#line 61 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
char *MyName  ;
#line 62 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
void (*saved_br_error_handler)(char * , char * )  ;
#line 64 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
void usage(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BottleRocket version %s\n",
          "0.05b3");
  }
  {
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
  {
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [<options>][<housecode>(<list>) <native command> ...]\n\n",
          MyName);
  }
  {
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  Options:\n");
  }
  {
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v, --verbose\t\t\tadd v\'s to increase verbosity\n");
  }
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -x, --port=PORT\t\tset port to use\n");
  }
  {
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c, --house=[A-P]\t\tuse alternate house code (default \"A\")\n");
  }
  {
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n, --on=LIST\t\t\tturn on devices in LIST\n");
  }
  {
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f, --off=LIST\t\tturn off devices in LIST\n");
  }
  {
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -N, --ON\t\t\tturn on all devices in housecode\n");
  }
  {
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -F, --OFF\t\t\tturn off all devices in housecode\n");
  }
  {
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d, --dim=LEVEL[,LIST]\tdim devices in housecode to  relative LEVEL\n");
  }
  {
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -B, --lamps_on\t\tturn all lamps in housecode on\n");
  }
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -D, --lamps_off\t\tturn all lamps in housecode off\n");
  }
  {
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r, --repeat=NUM\t\trepeat commands NUM times (0 = ~ forever)\n");
  }
  {
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h, --help\t\t\tthis help\n\n");
  }
  {
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<list>\t\tis a comma separated list of devices (no spaces),\n");
  }
  {
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\teach ranging from 1 to 16\n");
  }
  {
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<dimlevel>\tis an integer from %d to %d (0 means no change)\n",
          -12, 12);
  }
  {
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<housecode>\tis a letter between A and P\n");
  }
  {
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<native cmd>\tis one of ON, OFF, DIM, BRIGHT, ALL_ON, ALL_OFF,\n");
  }
  {
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\tLAMPS_ON or LAMPS_OFF\n\n");
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For native commands, <list> should only be specified for ON or OFF.\n\n");
  }
  }
#line 114
  return;
}
}
#line 116 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
void my_br_error_handler(char *where , char *problem ) 
{ 
  int tmperrno ;
  int *tmp ;
  char *tmpwhere ;
  int *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 118
  tmp = __errno_location();
  }
#line 118
  tmperrno = *tmp;
  }
#line 127
  if (Verbose) {
#line 127
    tmpwhere = where;
  } else {
#line 127
    tmpwhere = (char *)((void *)0);
  }
  {
  {
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          MyName);
  }
  {
#line 131
  tmp___0 = __errno_location();
  }
#line 131
  *tmp___0 = tmperrno;
  {
#line 133
  (*saved_br_error_handler)(tmpwhere, problem);
  }
  }
#line 134
  return;
}
}
#line 136 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int checkimmutableport(char *port_source ) 
{ 
  __uid_t tmp ;
  __uid_t tmp___0 ;
  __gid_t tmp___1 ;
  __gid_t tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 142
  tmp = getuid();
  }
  {
#line 142
  tmp___0 = geteuid();
  }
  }
#line 142
  if (! (tmp != tmp___0)) {
    {
    {
#line 142
    tmp___1 = getgid();
    }
    {
#line 142
    tmp___2 = getegid();
    }
    }
#line 142
    if (! (tmp___1 != tmp___2)) {
#line 143
      return (0);
    }
  }
  {
  {
#line 145
  tmp___3 = __errno_location();
  }
#line 145
  *tmp___3 = 1;
  {
#line 146
  br_error((char *)"checkimmutableport", (char *)"You are not authorized to change the X10 port!");
  }
  {
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tPort specified %s\n",
          port_source);
  }
  }
#line 149
  return (-1);
}
}
#line 152 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int add_dimcmd(br_control_info *cinfo , br_unit_list *units , int dim_level ) 
{ 
  register int i ;
  int index___0 ;
  int dev ;
  int house ;
  int cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 160
  index___0 = 0;
#line 166
  if (dim_level < 0) {
#line 166
    cmd = 2;
  } else {
#line 166
    cmd = 3;
  }
#line 167
  if (dim_level < 0) {
#line 167
    dim_level = - dim_level;
  } else {
#line 167
    dim_level = dim_level;
  }
  {
  {
#line 169
  tmp___2 = br_get_num_units(units);
  }
  }
#line 169
  if (tmp___2) {
    {
    {
#line 170
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 170
      dev = br_get_ul_device(units, index___0);
      }
      }
#line 170
      if (! (dev != -1)) {
#line 170
        goto while_break;
      }
      {
      {
#line 171
      house = br_get_ul_house(units, index___0);
      }
      {
#line 172
      tmp = br_add_cmd(cinfo, 0, house, dev);
      }
      }
#line 172
      if (tmp < 0) {
#line 173
        return (-1);
      }
#line 174
      i = 0;
      {
      {
#line 174
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 174
        if (! (i < dim_level)) {
#line 174
          goto while_break___0;
        }
        {
        {
#line 175
        tmp___0 = br_add_cmd(cinfo, cmd, house, 0);
        }
        }
#line 175
        if (tmp___0 < 0) {
#line 176
          return (-1);
        }
#line 174
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 178
      index___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 181
    i = 0;
    {
    {
#line 181
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 181
      if (! (i < dim_level)) {
#line 181
        goto while_break___1;
      }
      {
      {
#line 182
      tmp___1 = br_add_cmd(cinfo, cmd, br_default_house, 0);
      }
      }
#line 182
      if (tmp___1 < 0) {
#line 183
        return (-1);
      }
#line 181
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 187
  return (0);
}
}
#line 190 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int gethouse(char *house ) 
{ 
  char *end ;
  int c ;
  int *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 200
  c = br_strtohc(house, & end);
  }
  }
#line 202
  if (c < 0) {
    {
    {
#line 203
    tmp = __errno_location();
    }
#line 203
    *tmp = 22;
    {
#line 204
    br_error((char *)"gethouse", (char *)"House code must be in range [A-P]");
    }
    }
#line 205
    return (-1);
  } else
#line 202
  if ((int )*end != 0) {
    {
    {
#line 203
    tmp = __errno_location();
    }
#line 203
    *tmp = 22;
    {
#line 204
    br_error((char *)"gethouse", (char *)"House code must be in range [A-P]");
    }
    }
#line 205
    return (-1);
  }
#line 208
  return (c);
}
}
#line 211 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int getunits(char *list , br_unit_list **units ) 
{ 
  char *end ;
  br_unit_list *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 220
  if ((unsigned long )*units == (unsigned long )((void *)0)) {
    {
    {
#line 221
    tmp = br_new_unit_list();
    }
#line 221
    *units = tmp;
    }
#line 221
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 222
      return (-1);
    }
  }
  {
  {
#line 225
  tmp___1 = br_strtoul(list, *units, & end);
  }
  }
#line 225
  if (tmp___1 < 0) {
#line 225
    goto _L;
  } else
#line 225
  if ((int )*end != 0) {
    _L: /* CIL Label */ 
    {
    {
#line 228
    br_free_unit_list(*units);
    }
    {
#line 229
    tmp___0 = __errno_location();
    }
#line 229
    *tmp___0 = 22;
    {
#line 230
    br_error((char *)"getunits", (char *)"Devices must be in the range of [1-16], housecodes [A-P]");
    }
#line 231
    *units = (br_unit_list *)((void *)0);
    }
#line 232
    return (-1);
  }
#line 235
  return (0);
}
}
#line 238 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int getdim(char *list , br_unit_list **units , int *dim ) 
{ 
  char *end ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 248
  tmp = strtol((char const   */* __restrict  */)list, (char **/* __restrict  */)(& end),
               0);
  }
#line 248
  *dim = (int )tmp;
  }
  {
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 250
    tmp___0 = __ctype_b_loc();
    }
    }
#line 250
    if (! ((int const   )*(*tmp___0 + (int )*end) & 8192)) {
#line 250
      goto while_break;
    }
#line 251
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  if ((int )*end == 44) {
#line 254
    end ++;
  }
#line 256
  if (*end) {
    {
    {
#line 257
    tmp___1 = getunits(end, units);
    }
    }
#line 257
    if (tmp___1 < 0) {
#line 258
      return (-1);
    }
  } else {
#line 260
    if (*units) {
      {
      {
#line 261
      br_free_unit_list(*units);
      }
      }
    }
#line 262
    *units = (br_unit_list *)((void *)0);
  }
#line 270
  if (*dim < -12) {
#line 270
    goto _L;
  } else
#line 270
  if (*dim > 12) {
    _L: /* CIL Label */ 
#line 272
    if (*units) {
      {
      {
#line 273
      br_free_unit_list(*units);
      }
      }
    }
    {
#line 274
    *units = (br_unit_list *)((void *)0);
    {
#line 275
    tmp___2 = __errno_location();
    }
#line 275
    *tmp___2 = 22;
    {
#line 276
    br_error((char *)"getdim", (char *)"Invalid dim level");
    }
    }
#line 278
    return (-1);
  }
#line 281
  return (0);
}
}
#line 284 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int open_port(br_control_info *cinfo , char *port ) 
{ 
  int fd ;
  int *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 297
    fd = open("/dev/null", 0, 0);
    }
    }
#line 297
    if (! (fd < 3)) {
#line 297
      goto while_break;
    }
#line 298
    if (fd < 0) {
      {
      {
#line 298
      tmp = __errno_location();
      }
      {
#line 298
      _exit(*tmp);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 299
  close(fd);
  }
  }
#line 301
  if (Verbose >= 2) {
    {
    {
#line 302
    printf((char const   */* __restrict  */)"%s: Opening serial port %s.\n", MyName,
           port);
    }
    }
  }
  {
  {
#line 308
  fd = open((char const   *)port, 2048);
  }
  }
#line 308
  if (fd < 0) {
    {
    {
#line 309
    br_error((char *)"open_port", (char *)"Unable to open serial port");
    }
    }
#line 310
    return (-1);
  }
#line 327
  return (fd);
}
}
#line 330 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int close_port(int fd ) 
{ 
  char *__cil_tmp2 ;

  {
#line 336
  if (Verbose >= 2) {
    {
    {
#line 337
    printf((char const   */* __restrict  */)"%s: Closing serial port.\n", MyName);
    }
    }
  }
  {
  {
#line 339
  close(fd);
  }
  }
#line 341
  return (0);
}
}
#line 344 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int native_getunits(char *arg , br_unit_list **units ) 
{ 
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 350
  tmp___0 = strlen((char const   *)arg);
  }
  }
#line 350
  if (tmp___0 < 2U) {
    {
    {
#line 351
    tmp = __errno_location();
    }
#line 351
    *tmp = 22;
    {
#line 352
    br_error((char *)"native_getunits", (char *)"No units specified");
    }
    }
#line 353
    return (-1);
  }
  {
  {
#line 356
  tmp___1 = getunits(arg, units);
  }
  }
#line 356
  if (tmp___1 < 0) {
#line 357
    return (-1);
  }
#line 359
  return (0);
}
}
#line 362 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int native_getcmd(char *arg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 368
  tmp = strcasecmp((char const   *)arg, "ON");
  }
  }
#line 368
  if (! tmp) {
#line 369
    return (0);
  }
  {
  {
#line 371
  tmp___0 = strcasecmp((char const   *)arg, "OFF");
  }
  }
#line 371
  if (! tmp___0) {
#line 372
    return (1);
  }
  {
  {
#line 374
  tmp___1 = strcasecmp((char const   *)arg, "DIM");
  }
  }
#line 374
  if (! tmp___1) {
#line 375
    return (2);
  }
  {
  {
#line 377
  tmp___2 = strcasecmp((char const   *)arg, "BRIGHT");
  }
  }
#line 377
  if (! tmp___2) {
#line 378
    return (3);
  }
  {
  {
#line 380
  tmp___3 = strcasecmp((char const   *)arg, "ALL_ON");
  }
  }
#line 380
  if (! tmp___3) {
#line 381
    return (5);
  }
  {
  {
#line 383
  tmp___4 = strcasecmp((char const   *)arg, "ALL_OFF");
  }
  }
#line 383
  if (! tmp___4) {
#line 384
    return (4);
  }
  {
  {
#line 386
  tmp___5 = strcasecmp((char const   *)arg, "LAMPS_ON");
  }
  }
#line 386
  if (! tmp___5) {
#line 387
    return (7);
  }
  {
  {
#line 389
  tmp___6 = strcasecmp((char const   *)arg, "LAMPS_OFF");
  }
  }
#line 389
  if (! tmp___6) {
#line 390
    return (6);
  }
  {
  {
#line 392
  tmp___7 = __errno_location();
  }
#line 392
  *tmp___7 = 22;
  {
#line 393
  br_error((char *)"native_getcmd", (char *)"Native br commands are ON, OFF, DIM,\n\tBRIGHT, ALL_ON, ALL_OFF, LAMPS_ON or LAMPS_OFF");
  }
  {
#line 395
  tmp___8 = __errno_location();
  }
#line 395
  *tmp___8 = 22;
  }
#line 397
  return (-1);
}
}
#line 400 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int native_cmdline(br_control_info *cinfo , int argc , char **argv , int optind___0 ) 
{ 
  int cmd ;
  int i ;
  int house ;
  br_unit_list *units ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
#line 409
  units = (br_unit_list *)((void *)0);
#line 412
  if (argc - optind___0 < 2) {
    {
    {
#line 413
    usage();
    }
    {
#line 414
    tmp = __errno_location();
    }
#line 414
    *tmp = 22;
    }
#line 415
    return (-1);
  }
#line 422
  i = optind___0;
  {
  {
#line 422
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < argc - 1)) {
#line 422
      goto while_break;
    }
    {
    {
#line 423
    cmd = native_getcmd(*(argv + (i + 1)));
    }
    }
    {
#line 426
    if (cmd == 0) {
#line 426
      goto case_0;
    }
#line 433
    if (cmd == 1) {
#line 433
      goto case_1;
    }
#line 440
    if (cmd == 2) {
#line 440
      goto case_2;
    }
#line 447
    if (cmd == 3) {
#line 447
      goto case_3;
    }
#line 454
    if (cmd == 5) {
#line 454
      goto case_5;
    }
#line 461
    if (cmd == 4) {
#line 461
      goto case_4;
    }
#line 468
    if (cmd == 7) {
#line 468
      goto case_7;
    }
#line 475
    if (cmd == 6) {
#line 475
      goto case_6;
    }
#line 482
    goto switch_default;
    case_0: /* CIL Label */ 
    {
    {
#line 427
    tmp___0 = native_getunits(*(argv + i), & units);
    }
    }
#line 427
    if (tmp___0 < 0) {
#line 428
      return (-1);
    }
    {
    {
#line 429
    tmp___1 = br_add_ul_cmd(cinfo, 0, units);
    }
    }
#line 429
    if (tmp___1 < 0) {
#line 430
      return (-1);
    }
#line 431
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 434
    tmp___2 = native_getunits(*(argv + i), & units);
    }
    }
#line 434
    if (tmp___2 < 0) {
#line 435
      return (-1);
    }
    {
    {
#line 436
    tmp___3 = br_add_ul_cmd(cinfo, 1, units);
    }
    }
#line 436
    if (tmp___3 < 0) {
#line 437
      return (-1);
    }
#line 438
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 441
    house = gethouse(*(argv + i));
    }
    }
#line 441
    if (house < 0) {
#line 442
      return (-1);
    }
    {
    {
#line 443
    tmp___4 = br_add_cmd(cinfo, 2, house, 0);
    }
    }
#line 443
    if (tmp___4 < 0) {
#line 444
      return (-1);
    }
#line 445
    goto switch_break;
    case_3: /* CIL Label */ 
    {
    {
#line 448
    house = gethouse(*(argv + i));
    }
    }
#line 448
    if (house < 0) {
#line 449
      return (-1);
    }
    {
    {
#line 450
    tmp___5 = br_add_cmd(cinfo, 3, house, 0);
    }
    }
#line 450
    if (tmp___5 < 0) {
#line 451
      return (-1);
    }
#line 452
    goto switch_break;
    case_5: /* CIL Label */ 
    {
    {
#line 455
    house = gethouse(*(argv + i));
    }
    }
#line 455
    if (house < 0) {
#line 456
      return (-1);
    }
    {
    {
#line 457
    tmp___6 = br_add_cmd(cinfo, 5, house, 0);
    }
    }
#line 457
    if (tmp___6 < 0) {
#line 458
      return (-1);
    }
#line 459
    goto switch_break;
    case_4: /* CIL Label */ 
    {
    {
#line 462
    house = gethouse(*(argv + i));
    }
    }
#line 462
    if (house < 0) {
#line 463
      return (-1);
    }
    {
    {
#line 464
    tmp___7 = br_add_cmd(cinfo, 4, house, 0);
    }
    }
#line 464
    if (tmp___7 < 0) {
#line 465
      return (-1);
    }
#line 466
    goto switch_break;
    case_7: /* CIL Label */ 
    {
    {
#line 469
    house = gethouse(*(argv + i));
    }
    }
#line 469
    if (house < 0) {
#line 470
      return (-1);
    }
    {
    {
#line 471
    tmp___8 = br_add_cmd(cinfo, 7, house, 0);
    }
    }
#line 471
    if (tmp___8 < 0) {
#line 472
      return (-1);
    }
#line 473
    goto switch_break;
    case_6: /* CIL Label */ 
    {
    {
#line 476
    house = gethouse(*(argv + i));
    }
    }
#line 476
    if (house < 0) {
#line 477
      return (-1);
    }
    {
    {
#line 478
    tmp___9 = br_add_cmd(cinfo, 6, house, 0);
    }
    }
#line 478
    if (tmp___9 < 0) {
#line 479
      return (-1);
    }
#line 480
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 483
    tmp___10 = __errno_location();
    }
#line 483
    *tmp___10 = 22;
    }
#line 484
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 422
    i += 2;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 488
  if (i != argc) {
    {
    {
#line 489
    usage();
    }
    {
#line 490
    tmp___11 = __errno_location();
    }
#line 490
    *tmp___11 = 22;
    }
#line 491
    return (-1);
  }
#line 494
  if (units) {
    {
    {
#line 495
    br_free_unit_list(units);
    }
    }
  }
#line 497
  return (0);
}
}
#line 515
int main(int argc , char **argv ) ;
#line 515 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
static struct option long_options[15]  = 
#line 515
  {      {"help", 0, (int *)0, 'h'}, 
        {"port", 1, (int *)0, 'x'}, 
        {"repeat", 1, (int *)0, 'r'}, 
        {"on", 1, (int *)0, 'n'}, 
        {"off", 1, (int *)0, 'f'}, 
        {"ON", 0, (int *)0, 'N'}, 
        {"OFF", 0, (int *)0, 'F'}, 
        {"dim", 1, (int *)0, 'd'}, 
        {"lamps_on", 0, (int *)0, 'B'}, 
        {"lamps_off", 0, (int *)0, 'D'}, 
        {"inverse", 0, (int *)0, 'i'}, 
        {"house", 1, (int *)0, 'c'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"pause", 0, (int *)0, 'p'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 500 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
int main(int argc , char **argv ) 
{ 
  char *port_source ;
  char *tmp_port ;
  char *port ;
  int opt ;
  int house ;
  int repeat ;
  int dimlevel ;
  int fd ;
  br_control_info *cinfo ;
  br_unit_list *units ;
  int opt_index ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  int *tmp___38 ;
  int tmp___39 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 502
  port_source = (char *)"at compile time";
#line 504
  port = (char *)"/dev/ttyS0";
#line 506
  house = 0;
#line 508
  dimlevel = 0;
#line 510
  cinfo = (br_control_info *)((void *)0);
#line 511
  units = (br_unit_list *)((void *)0);
#line 542
  saved_br_error_handler = br_error_handler;
#line 543
  br_error_handler = & my_br_error_handler;
#line 545
  MyName = *(argv + 0);
  {
#line 552
  cinfo = br_new_control_info();
  }
  }
#line 552
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 553
    tmp = __errno_location();
    }
    {
#line 553
    exit(*tmp);
    }
    }
  }
  {
  {
#line 555
  tmp_port = getenv("X10_PORTNAME");
  }
  }
#line 555
  if (tmp_port) {
    {
#line 556
    port_source = (char *)"in the environment variable X10_PORTNAME";
    {
#line 558
    tmp___1 = checkimmutableport(port_source);
    }
    }
#line 558
    if (tmp___1) {
      {
      {
#line 559
      tmp___0 = __errno_location();
      }
      {
#line 559
      exit(*tmp___0);
      }
      }
    } else {
#line 561
      port = tmp_port;
    }
  }
  {
  {
#line 566
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 566
    opt = getopt_long(argc, (char * const  *)argv, "x:hvr:ic:n:Nf:Fd:BDp", (struct option  const  *)(long_options),
                      & opt_index);
    }
    }
#line 566
    if (! (opt != -1)) {
#line 566
      goto while_break;
    }
    {
#line 573
    if (opt == 120) {
#line 573
      goto case_120;
    }
#line 579
    if (opt == 114) {
#line 579
      goto case_114;
    }
#line 588
    if (opt == 118) {
#line 588
      goto case_118;
    }
#line 595
    if (opt == 105) {
#line 595
      goto case_105;
    }
#line 600
    if (opt == 99) {
#line 600
      goto case_99;
    }
#line 604
    if (opt == 110) {
#line 604
      goto case_110;
    }
#line 610
    if (opt == 78) {
#line 610
      goto case_78;
    }
#line 614
    if (opt == 102) {
#line 614
      goto case_102;
    }
#line 620
    if (opt == 70) {
#line 620
      goto case_70;
    }
#line 624
    if (opt == 100) {
#line 624
      goto case_100;
    }
#line 630
    if (opt == 66) {
#line 630
      goto case_66;
    }
#line 634
    if (opt == 68) {
#line 634
      goto case_68;
    }
#line 638
    if (opt == 112) {
#line 638
      goto case_112;
    }
#line 642
    if (opt == 104) {
#line 642
      goto case_104;
    }
#line 645
    goto switch_default;
    case_120: /* CIL Label */ 
    {
#line 574
    port_source = (char *)"on the command line";
    {
#line 575
    tmp___3 = checkimmutableport(port_source);
    }
    }
#line 575
    if (tmp___3 < 0) {
      {
      {
#line 576
      tmp___2 = __errno_location();
      }
      {
#line 576
      exit(*tmp___2);
      }
      }
    }
#line 577
    port = optarg;
#line 578
    goto switch_break;
    case_114: /* CIL Label */ 
    {
    {
#line 580
    repeat = atoi((char const   *)optarg);
    }
    }
#line 581
    if (! repeat) {
      {
      {
#line 581
      tmp___6 = __ctype_b_loc();
      }
      }
#line 581
      if (! ((int const   )*(*tmp___6 + (int )*optarg) & 2048)) {
        {
        {
#line 582
        tmp___4 = __errno_location();
        }
#line 582
        *tmp___4 = 22;
        {
#line 583
        br_error((char *)((void *)0), (char *)"Invalid repeat value");
        }
        {
#line 584
        tmp___5 = __errno_location();
        }
        {
#line 584
        exit(*tmp___5);
        }
        }
      }
    }
#line 586
    if (repeat) {
#line 586
      cinfo->repeat = repeat;
    } else {
#line 586
      cinfo->repeat = 2147483647;
    }
#line 587
    goto switch_break;
    case_118: /* CIL Label */ 
#line 589
    tmp___7 = Verbose;
#line 589
    Verbose ++;
#line 589
    if (tmp___7 == 10) {
      {
      {
#line 590
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGet a LIFE already.  I\'ve got enough v\'s, thanks.\n\n");
      }
      }
    }
#line 592
    if (Verbose >= 4) {
#line 593
      br_verbose = Verbose - 3;
    }
#line 594
    goto switch_break;
    case_105: /* CIL Label */ 
#line 596
    (cinfo->inverse) ++;
#line 599
    goto switch_break;
    case_99: /* CIL Label */ 
    {
    {
#line 601
    br_default_house = gethouse(optarg);
    }
    }
#line 601
    if (br_default_house < 0) {
      {
      {
#line 602
      tmp___8 = __errno_location();
      }
      {
#line 602
      exit(*tmp___8);
      }
      }
    }
#line 603
    goto switch_break;
    case_110: /* CIL Label */ 
    {
    {
#line 605
    tmp___10 = getunits(optarg, & units);
    }
    }
#line 605
    if (tmp___10 < 0) {
      {
      {
#line 606
      tmp___9 = __errno_location();
      }
      {
#line 606
      exit(*tmp___9);
      }
      }
    }
    {
    {
#line 607
    tmp___12 = br_add_ul_cmd(cinfo, 0, units);
    }
    }
#line 607
    if (tmp___12 < 0) {
      {
      {
#line 608
      tmp___11 = __errno_location();
      }
      {
#line 608
      exit(*tmp___11);
      }
      }
    }
#line 609
    goto switch_break;
    case_78: /* CIL Label */ 
    {
    {
#line 611
    tmp___14 = br_add_cmd(cinfo, 5, house, 0);
    }
    }
#line 611
    if (tmp___14 < 0) {
      {
      {
#line 612
      tmp___13 = __errno_location();
      }
      {
#line 612
      exit(*tmp___13);
      }
      }
    }
#line 613
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 615
    tmp___16 = getunits(optarg, & units);
    }
    }
#line 615
    if (tmp___16 < 0) {
      {
      {
#line 616
      tmp___15 = __errno_location();
      }
      {
#line 616
      exit(*tmp___15);
      }
      }
    }
    {
    {
#line 617
    tmp___18 = br_add_ul_cmd(cinfo, 1, units);
    }
    }
#line 617
    if (tmp___18 < 0) {
      {
      {
#line 618
      tmp___17 = __errno_location();
      }
      {
#line 618
      exit(*tmp___17);
      }
      }
    }
#line 619
    goto switch_break;
    case_70: /* CIL Label */ 
    {
    {
#line 621
    tmp___20 = br_add_cmd(cinfo, 4, house, 0);
    }
    }
#line 621
    if (tmp___20 < 0) {
      {
      {
#line 622
      tmp___19 = __errno_location();
      }
      {
#line 622
      exit(*tmp___19);
      }
      }
    }
#line 623
    goto switch_break;
    case_100: /* CIL Label */ 
    {
    {
#line 625
    tmp___22 = getdim(optarg, & units, & dimlevel);
    }
    }
#line 625
    if (tmp___22 < 0) {
      {
      {
#line 626
      tmp___21 = __errno_location();
      }
      {
#line 626
      exit(*tmp___21);
      }
      }
    }
    {
    {
#line 627
    tmp___24 = add_dimcmd(cinfo, units, dimlevel);
    }
    }
#line 627
    if (tmp___24 < 0) {
      {
      {
#line 628
      tmp___23 = __errno_location();
      }
      {
#line 628
      exit(*tmp___23);
      }
      }
    }
#line 629
    goto switch_break;
    case_66: /* CIL Label */ 
    {
    {
#line 631
    tmp___26 = br_add_cmd(cinfo, 7, house, 0);
    }
    }
#line 631
    if (tmp___26 < 0) {
      {
      {
#line 632
      tmp___25 = __errno_location();
      }
      {
#line 632
      exit(*tmp___25);
      }
      }
    }
#line 633
    goto switch_break;
    case_68: /* CIL Label */ 
    {
    {
#line 635
    tmp___28 = br_add_cmd(cinfo, 6, house, 0);
    }
    }
#line 635
    if (tmp___28 < 0) {
      {
      {
#line 636
      tmp___27 = __errno_location();
      }
      {
#line 636
      exit(*tmp___27);
      }
      }
    }
#line 637
    goto switch_break;
    case_112: /* CIL Label */ 
    {
    {
#line 639
    tmp___30 = br_add_cmd(cinfo, 8, 0, 0);
    }
    }
#line 639
    if (tmp___30 < 0) {
      {
      {
#line 640
      tmp___29 = __errno_location();
      }
      {
#line 640
      exit(*tmp___29);
      }
      }
    }
#line 641
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 643
    usage();
    }
    {
#line 644
    exit(0);
    }
    }
    switch_default: /* CIL Label */ 
    {
    {
#line 646
    usage();
    }
    {
#line 647
    exit(22);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  if (argc > optind) {
    {
    {
#line 656
    tmp___32 = native_cmdline(cinfo, argc, argv, optind);
    }
    }
#line 656
    if (tmp___32 < 0) {
      {
      {
#line 657
      tmp___31 = __errno_location();
      }
      {
#line 657
      exit(*tmp___31);
      }
      }
    }
  }
  {
  {
#line 660
  tmp___33 = br_get_num_commands(cinfo);
  }
  }
#line 660
  if (! tmp___33) {
    {
    {
#line 661
    usage();
    }
    {
#line 662
    exit(22);
    }
    }
  }
  {
  {
#line 665
  fd = open_port(cinfo, port);
  }
  }
#line 665
  if (fd < 0) {
    {
    {
#line 666
    tmp___34 = __errno_location();
    }
    {
#line 666
    exit(*tmp___34);
    }
    }
  }
#line 668
  if (Verbose >= 2) {
    {
    {
#line 669
    tmp___35 = br_get_num_commands(cinfo);
    }
    {
#line 669
    printf((char const   */* __restrict  */)"%s: Executing %d commands\n", MyName,
           tmp___35);
    }
    }
  }
  {
  {
#line 672
  tmp___37 = br_execute(fd, cinfo);
  }
  }
#line 672
  if (tmp___37 < 0) {
    {
    {
#line 673
    tmp___36 = __errno_location();
    }
    {
#line 673
    exit(*tmp___36);
    }
    }
  }
  {
  {
#line 675
  tmp___39 = close_port(fd);
  }
  }
#line 675
  if (tmp___39 < 0) {
    {
    {
#line 676
    tmp___38 = __errno_location();
    }
    {
#line 676
    exit(*tmp___38);
    }
    }
  }
#line 678
  if (Verbose >= 3) {
    {
    {
#line 679
    printf((char const   */* __restrict  */)"%s: Cleaning up...\n", MyName);
    }
    }
  }
  {
  {
#line 681
  br_free_unit_list(units);
  }
  {
#line 682
  br_free_control_info(cinfo);
  }
  }
#line 684
  return (0);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 119 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 23 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.h"
int br_inverse_cmd(int cmd ) ;
#line 28
int br_add_unit(br_unit_list *units , int house , int dev ) ;
#line 29
int br_del_unit(br_unit_list *units , int house , int dev ) ;
#line 30
int br_malloc_cmds(br_control_info *cinfo , int numcmds ) ;
#line 31
int br_realloc_cmds(br_control_info *cinfo , int numcmds ) ;
#line 32
int br_free_cmds(br_control_info *cinfo ) ;
#line 37
int br_del_cmd(br_control_info *cinfo , int index___0 ) ;
#line 41
int br_ulcat(br_unit_list *a , br_unit_list *b ) ;
#line 42
br_unit_list *br_uldup(br_unit_list *a ) ;
#line 46 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_default_house  =    0;
#line 48 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_inverse_cmd(int cmd ) 
{ 


  {
  {
#line 51
  if (cmd == 0) {
#line 51
    goto case_0;
  }
#line 54
  if (cmd == 1) {
#line 54
    goto case_1;
  }
#line 57
  if (cmd == 2) {
#line 57
    goto case_2;
  }
#line 60
  if (cmd == 3) {
#line 60
    goto case_3;
  }
#line 63
  if (cmd == 5) {
#line 63
    goto case_5;
  }
#line 66
  if (cmd == 4) {
#line 66
    goto case_4;
  }
#line 69
  if (cmd == 7) {
#line 69
    goto case_7;
  }
#line 72
  if (cmd == 6) {
#line 72
    goto case_6;
  }
#line 50
  goto switch_break;
  case_0: /* CIL Label */ 
#line 52
  return (1);
#line 53
  goto switch_break;
  case_1: /* CIL Label */ 
#line 55
  return (0);
#line 56
  goto switch_break;
  case_2: /* CIL Label */ 
#line 58
  return (3);
#line 59
  goto switch_break;
  case_3: /* CIL Label */ 
#line 61
  return (2);
#line 62
  goto switch_break;
  case_5: /* CIL Label */ 
#line 64
  return (4);
#line 65
  goto switch_break;
  case_4: /* CIL Label */ 
#line 67
  return (5);
#line 68
  goto switch_break;
  case_7: /* CIL Label */ 
#line 70
  return (6);
#line 71
  goto switch_break;
  case_6: /* CIL Label */ 
#line 73
  return (7);
#line 74
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 77
  return (-1);
}
}
#line 80 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_execute(int fd , br_control_info *cinfo ) 
{ 
  register int i ;
  register int j ;
  register int repeat ;
  int inverse ;
  char unit ;
  int rv ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 88
  repeat = cinfo->repeat;
#line 89
  inverse = cinfo->inverse;
#line 93
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 94
    tmp = __errno_location();
    }
#line 94
    *tmp = 22;
    {
#line 95
    br_error((char *)"br_execute", (char *)"NULL control info pointer");
    }
    }
#line 96
    return (-1);
  }
#line 99
  if ((unsigned long )cinfo->units == (unsigned long )((void *)0)) {
    {
    {
#line 100
    tmp___0 = __errno_location();
    }
#line 100
    *tmp___0 = 22;
    {
#line 101
    br_error((char *)"br_execute", (char *)"NULL unit list pointer");
    }
    }
#line 102
    return (-1);
  }
  {
  {
#line 107
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 107
    if (! (repeat > 0)) {
#line 107
      goto while_break;
    }
#line 111
    i = 0;
    {
    {
#line 111
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! (i < cinfo->numcmds)) {
#line 111
        goto while_break___0;
      }
#line 115
      if (*(cinfo->cmds + i) == 0) {
#line 115
        goto _L;
      } else
#line 115
      if (*(cinfo->cmds + i) == 1) {
        _L: /* CIL Label */ 
#line 115
        if ((unsigned long )(*(cinfo->units + i))->devs == (unsigned long )((void *)0)) {
          {
          {
#line 116
          tmp___1 = __errno_location();
          }
#line 116
          *tmp___1 = 22;
          {
#line 117
          br_error((char *)"br_execute", (char *)"NULL device list");
          }
          }
#line 118
          return (-1);
        }
      }
#line 121
      j = 0;
      {
      {
#line 121
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 121
        if (*(cinfo->cmds + i) == 0) {
#line 121
          tmp___5 = (*(cinfo->units + i))->numunits;
        } else
#line 121
        if (*(cinfo->cmds + i) == 1) {
#line 121
          tmp___5 = (*(cinfo->units + i))->numunits;
        } else {
#line 121
          tmp___5 = 1;
        }
#line 121
        if (! (j < tmp___5)) {
#line 121
          goto while_break___1;
        }
#line 123
        if (*(cinfo->cmds + i) == 0) {
#line 123
          tmp___2 = *((*(cinfo->units + i))->devs + j);
        } else
#line 123
        if (*(cinfo->cmds + i) == 1) {
#line 123
          tmp___2 = *((*(cinfo->units + i))->devs + j);
        } else {
#line 123
          tmp___2 = 0;
        }
#line 123
        unit = (char )(((int )((char )*((*(cinfo->units + i))->houses + j)) << 4) | tmp___2);
#line 126
        if (inverse < 0) {
          {
          {
#line 126
          tmp___3 = br_inverse_cmd(*(cinfo->cmds + i));
          }
#line 126
          tmp___4 = tmp___3;
          }
        } else {
#line 126
          tmp___4 = *(cinfo->cmds + i);
        }
        {
        {
#line 126
        rv = br_cmd(fd, (unsigned char )unit, tmp___4);
        }
        }
#line 128
        if (rv < 0) {
#line 129
          return (-1);
        }
#line 121
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 111
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 133
    if (inverse) {
#line 133
      inverse = 0 - inverse;
    }
#line 107
    repeat --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return (0);
}
}
#line 139 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
br_unit_list *br_new_unit_list(void) 
{ 
  br_unit_list *units ;
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 143
  tmp = malloc((size_t )sizeof(br_unit_list ));
  }
#line 143
  units = (br_unit_list *)tmp;
  }
#line 145
  if ((unsigned long )units == (unsigned long )((void *)0)) {
    {
    {
#line 146
    br_error((char *)"br_new_unit_list", (char *)"malloc");
    }
    }
#line 147
    return ((br_unit_list *)((void *)0));
  }
#line 155
  units->allocatedunits = 0;
#line 156
  units->numunits = 0;
#line 157
  units->devs = (int *)((void *)0);
#line 158
  units->houses = (int *)((void *)0);
#line 160
  return (units);
}
}
#line 163 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_free_unit_list(br_unit_list *units ) 
{ 


  {
#line 165
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 166
    return (0);
  }
#line 168
  if ((unsigned long )units->devs != (unsigned long )((void *)0)) {
    {
    {
#line 175
    free((void *)units->devs);
    }
    }
  }
#line 178
  if ((unsigned long )units->houses != (unsigned long )((void *)0)) {
    {
    {
#line 185
    free((void *)units->houses);
    }
    }
  }
  {
  {
#line 193
  free((void *)units);
  }
  }
#line 195
  return (0);
}
}
#line 198 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_add_unit(br_unit_list *units , int house , int dev ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 200
  if ((unsigned long )units == (unsigned long )((void *)0)) {
    {
    {
#line 201
    tmp = __errno_location();
    }
#line 201
    *tmp = 22;
    {
#line 202
    br_error((char *)"br_add_unit", (char *)"NULL unit list");
    }
    }
#line 203
    return (-1);
  }
#line 206
  if (units->numunits >= units->allocatedunits) {
    {
    {
#line 213
    tmp___0 = realloc((void *)units->devs, (size_t )((unsigned long )(units->allocatedunits + 5) * sizeof(int )));
    }
#line 213
    units->devs = (int *)tmp___0;
    }
#line 215
    if ((unsigned long )units->devs == (unsigned long )((void *)0)) {
      {
      {
#line 216
      br_error((char *)"br_add_unit", (char *)"realloc");
      }
      }
#line 217
      return (-1);
    }
    {
    {
#line 228
    tmp___1 = realloc((void *)units->houses, (size_t )((unsigned long )(units->allocatedunits + 5) * sizeof(int )));
    }
#line 228
    units->houses = (int *)tmp___1;
    }
#line 230
    if ((unsigned long )units->houses == (unsigned long )((void *)0)) {
      {
      {
#line 231
      br_error((char *)"br_add_unit", (char *)"realloc");
      }
      }
#line 232
      return (-1);
    }
#line 240
    units->allocatedunits += 5;
  }
#line 244
  *(units->devs + units->numunits) = dev;
#line 245
  *(units->houses + units->numunits) = house;
#line 247
  (units->numunits) ++;
#line 249
  return (0);
}
}
#line 252 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_del_unit(br_unit_list *units , int house , int dev ) 
{ 
  register int i ;
  int moveby ;
  int *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 255
  moveby = 0;
#line 258
  if ((unsigned long )units == (unsigned long )((void *)0)) {
    {
    {
#line 259
    tmp = __errno_location();
    }
#line 259
    *tmp = 22;
    {
#line 260
    br_error((char *)"br_del_unit", (char *)"NULL unit list");
    }
    }
#line 261
    return (-1);
  }
#line 264
  i = 0;
  {
  {
#line 264
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 264
    if (! (i < units->numunits - moveby)) {
#line 264
      goto while_break;
    }
#line 265
    if (units->devs) {
#line 265
      if (*(units->devs + i) == dev) {
#line 265
        goto _L___0;
      } else {
#line 265
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 265
    if (dev == 0) {
      _L___0: /* CIL Label */ 
#line 265
      if (units->houses) {
#line 265
        if (*(units->houses + i) == house) {
#line 272
          moveby ++;
        } else {
#line 265
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 265
      if (house == 0) {
#line 272
        moveby ++;
      }
    }
#line 275
    if (units->devs) {
#line 276
      *(units->devs + i) = *(units->devs + (i + moveby));
    }
#line 278
    if (units->houses) {
#line 279
      *(units->houses + i) = *(units->houses + (i + moveby));
    }
#line 264
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  units->numunits -= moveby;
#line 284
  if (units->numunits == 0) {
#line 286
    if (units->devs) {
      {
      {
#line 293
      free((void *)units->devs);
      }
#line 294
      units->devs = (int *)((void *)0);
      }
    }
#line 297
    if (units->houses) {
      {
      {
#line 304
      free((void *)units->houses);
      }
#line 305
      units->houses = (int *)((void *)0);
      }
    }
#line 308
    units->numunits = 0;
#line 309
    units->allocatedunits = 0;
  }
#line 312
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
br_control_info *br_new_control_info(void) 
{ 
  br_control_info *cinfo ;
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 321
  tmp = malloc((size_t )sizeof(br_control_info ));
  }
#line 321
  cinfo = (br_control_info *)tmp;
  }
#line 323
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 324
    br_error((char *)"br_new_control_info", (char *)"malloc");
    }
    }
#line 325
    return ((br_control_info *)((void *)0));
  }
#line 333
  cinfo->inverse = 0;
#line 334
  cinfo->repeat = 1;
#line 335
  cinfo->numcmds = 0;
#line 336
  cinfo->allocatedcmds = 0;
#line 337
  cinfo->units = (br_unit_list **)((void *)0);
#line 338
  cinfo->cmds = (int *)((void *)0);
#line 340
  return (cinfo);
}
}
#line 343 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_free_control_info(br_control_info *cinfo ) 
{ 


  {
#line 345
  if (cinfo) {
    {
    {
#line 346
    br_free_cmds(cinfo);
    }
    {
#line 353
    free((void *)cinfo);
    }
    }
  }
#line 356
  return (0);
}
}
#line 359 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_malloc_cmds(br_control_info *cinfo , int numcmds ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 361
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 362
    tmp = __errno_location();
    }
#line 362
    *tmp = 22;
    {
#line 363
    br_error((char *)"br_malloc_cmds", (char *)"NULL control info pointer");
    }
    }
#line 364
    return (-1);
  }
  {
  {
#line 367
  tmp___0 = malloc((size_t )((unsigned long )numcmds * sizeof(int )));
  }
#line 367
  cinfo->cmds = (int *)tmp___0;
  }
#line 369
  if ((unsigned long )cinfo->cmds == (unsigned long )((void *)0)) {
    {
    {
#line 370
    br_error((char *)"br_malloc_cmds", (char *)"malloc");
    }
    }
#line 371
    return (-1);
  }
  {
  {
#line 379
  tmp___1 = malloc((size_t )((unsigned long )numcmds * sizeof(br_unit_list *)));
  }
#line 379
  cinfo->units = (br_unit_list **)tmp___1;
  }
#line 381
  if ((unsigned long )cinfo->units == (unsigned long )((void *)0)) {
    {
    {
#line 382
    br_error((char *)"br_malloc_cmds", (char *)"malloc");
    }
    }
#line 383
    return (-1);
  }
#line 391
  cinfo->allocatedcmds = numcmds;
#line 393
  return (0);
}
}
#line 396 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_realloc_cmds(br_control_info *cinfo , int numcmds ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 398
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 399
    tmp = __errno_location();
    }
#line 399
    *tmp = 22;
    {
#line 400
    br_error((char *)"br_realloc_cmds", (char *)"NULL control info pointer");
    }
    }
#line 401
    return (-1);
  }
  {
  {
#line 409
  tmp___0 = realloc((void *)cinfo->cmds, (size_t )((unsigned long )numcmds * sizeof(int )));
  }
#line 409
  cinfo->cmds = (int *)tmp___0;
  }
#line 411
  if ((unsigned long )cinfo->cmds == (unsigned long )((void *)0)) {
    {
    {
#line 412
    br_error((char *)"br_realloc_cmds", (char *)"realloc");
    }
    }
#line 413
    return (-1);
  }
  {
  {
#line 424
  tmp___1 = realloc((void *)cinfo->units, (size_t )((unsigned long )numcmds * sizeof(br_unit_list *)));
  }
#line 424
  cinfo->units = (br_unit_list **)tmp___1;
  }
#line 426
  if ((unsigned long )cinfo->units == (unsigned long )((void *)0)) {
    {
    {
#line 427
    br_error((char *)"br_realloc_cmds", (char *)"realloc");
    }
    }
#line 428
    return (-1);
  }
#line 437
  cinfo->allocatedcmds = numcmds;
#line 439
  return (0);
}
}
#line 442 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_free_cmds(br_control_info *cinfo ) 
{ 
  register int i ;

  {
#line 447
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
#line 448
    return (0);
  }
#line 451
  if (cinfo->cmds) {
    {
    {
#line 458
    free((void *)cinfo->cmds);
    }
#line 459
    cinfo->cmds = (int *)((void *)0);
    }
  }
#line 462
  if (cinfo->units) {
#line 463
    i = 0;
    {
    {
#line 463
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 463
      if (! (i < cinfo->numcmds)) {
#line 463
        goto while_break;
      }
      {
      {
#line 464
      br_free_unit_list(*(cinfo->units + i));
      }
#line 465
      *(cinfo->units + i) = (br_unit_list *)((void *)0);
#line 463
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 473
    free((void *)cinfo->units);
    }
#line 474
    cinfo->units = (br_unit_list **)((void *)0);
    }
  }
#line 477
  cinfo->numcmds = 0;
#line 478
  cinfo->allocatedcmds = 0;
#line 480
  return (0);
}
}
#line 483 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_add_ul_cmd(br_control_info *cinfo , int cmd , br_unit_list *units ) 
{ 
  br_unit_list *tmpunits ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 493
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 494
    tmp = __errno_location();
    }
#line 494
    *tmp = 22;
    {
#line 495
    br_error((char *)"br_add_ul_cmd", (char *)"NULL control info pointer");
    }
    }
#line 496
    return (-1);
  }
#line 499
  if ((unsigned long )units == (unsigned long )((void *)0)) {
    {
    {
#line 500
    tmp___0 = __errno_location();
    }
#line 500
    *tmp___0 = 22;
    {
#line 501
    br_error((char *)"br_add_ul_cmd", (char *)"NULL unit list pointer");
    }
    }
#line 502
    return (-1);
  }
  {
  {
#line 505
  tmpunits = br_uldup(units);
  }
  }
#line 507
  if ((unsigned long )tmpunits == (unsigned long )((void *)0)) {
    {
    {
#line 508
    br_error((char *)"br_add_ul_cmd", (char *)"malloc");
    }
    }
#line 509
    return (-1);
  }
#line 512
  if (cinfo->numcmds >= cinfo->allocatedcmds) {
    {
    {
#line 513
    tmp___1 = br_realloc_cmds(cinfo, cinfo->numcmds + 64);
    }
    }
#line 513
    if (tmp___1 < 0) {
      {
      {
#line 514
      br_free_unit_list(tmpunits);
      }
      }
#line 515
      return (-1);
    }
  }
#line 519
  *(cinfo->cmds + cinfo->numcmds) = cmd;
#line 520
  *(cinfo->units + cinfo->numcmds) = tmpunits;
#line 522
  (cinfo->numcmds) ++;
#line 524
  return (0);
}
}
#line 527 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_add_cmd(br_control_info *cinfo , int cmd , int house , int dev ) 
{ 
  br_unit_list *units ;
  int tmperrno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 533
  units = br_new_unit_list();
  }
  }
#line 535
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 536
    return (-1);
  }
  {
  {
#line 538
  tmp___1 = br_add_unit(units, house, dev);
  }
  }
#line 538
  if (tmp___1 < 0) {
    {
    {
#line 539
    tmp = __errno_location();
    }
#line 539
    tmperrno = *tmp;
    {
#line 540
    br_free_unit_list(units);
    }
    {
#line 541
    tmp___0 = __errno_location();
    }
#line 541
    *tmp___0 = tmperrno;
    }
#line 542
    return (-1);
  }
  {
  {
#line 545
  tmp___4 = br_add_ul_cmd(cinfo, cmd, units);
  }
  }
#line 545
  if (tmp___4 < 0) {
    {
    {
#line 546
    tmp___2 = __errno_location();
    }
#line 546
    tmperrno = *tmp___2;
    {
#line 547
    br_free_unit_list(units);
    }
    {
#line 548
    tmp___3 = __errno_location();
    }
#line 548
    *tmp___3 = tmperrno;
    }
#line 549
    return (-1);
  }
  {
  {
#line 552
  br_free_unit_list(units);
  }
  }
#line 554
  return (0);
}
}
#line 557 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_del_cmd(br_control_info *cinfo , int index___0 ) 
{ 
  register int i ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 561
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
    {
    {
#line 562
    tmp = __errno_location();
    }
#line 562
    *tmp = 22;
    {
#line 563
    br_error((char *)"br_del_cmd", (char *)"NULL control info pointer");
    }
    }
#line 564
    return (-1);
  }
#line 567
  if (index___0 >= cinfo->numcmds) {
    {
    {
#line 568
    tmp___0 = __errno_location();
    }
#line 568
    *tmp___0 = 22;
    {
#line 569
    br_error((char *)"br_del_cmd", (char *)"invalid command index");
    }
    }
#line 570
    return (-1);
  }
#line 573
  if (cinfo->numcmds - 1 == 0) {
    {
    {
#line 574
    tmp___1 = br_free_cmds(cinfo);
    }
    }
#line 574
    if (tmp___1 < 0) {
#line 575
      return (-1);
    }
#line 577
    return (0);
  }
  {
  {
#line 580
  br_free_unit_list(*(cinfo->units + index___0));
  }
#line 581
  *(cinfo->units + index___0) = (br_unit_list *)((void *)0);
#line 583
  i = index___0;
  }
  {
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 583
    if (! (i < cinfo->numcmds - 1)) {
#line 583
      goto while_break;
    }
#line 584
    *(cinfo->cmds + i) = *(cinfo->cmds + (i + 1));
#line 585
    *(cinfo->units + i) = *(cinfo->units + (i + 1));
#line 583
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 588
  (cinfo->numcmds) --;
#line 590
  return (0);
}
}
#line 593 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_strtoul(char *ulptr , br_unit_list *units , char **endptr ) 
{ 
  int house ;
  int tmphouse ;
  int dev ;
  char *my_endptr ;
  char *last_endptr ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  int *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 598
  my_endptr = (char *)((void *)0);
#line 599
  last_endptr = ulptr;
#line 602
  house = br_default_house;
#line 604
  if ((unsigned long )units == (unsigned long )((void *)0)) {
    {
    {
#line 605
    tmp = __errno_location();
    }
#line 605
    *tmp = 22;
    {
#line 606
    br_error((char *)"br_strtoul", (char *)"NULL unit list");
    }
    }
#line 607
    return (-1);
  }
#line 612
  if (units->devs) {
    {
    {
#line 613
    free((void *)units->devs);
    }
    }
  }
#line 615
  if (units->houses) {
    {
    {
#line 616
    free((void *)units->houses);
    }
    }
  }
#line 618
  units->devs = (int *)((void *)0);
#line 619
  units->houses = (int *)((void *)0);
#line 620
  units->allocatedunits = 0;
#line 621
  units->numunits = 0;
  {
  {
#line 623
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 624
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 624
      tmp___0 = __ctype_b_loc();
      }
      }
#line 624
      if (! ((int const   )*(*tmp___0 + (int )*ulptr) & 8192)) {
#line 624
        goto while_break___0;
      }
#line 625
      ulptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 627
    tmphouse = br_strtohc(ulptr, & ulptr);
    }
    }
#line 629
    if (tmphouse >= 0) {
#line 630
      house = tmphouse;
    }
#line 632
    last_endptr = ulptr;
    {
    {
#line 634
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 634
      tmp___1 = __ctype_b_loc();
      }
      }
#line 634
      if (! ((int const   )*(*tmp___1 + (int )*ulptr) & 8192)) {
#line 634
        goto while_break___1;
      }
#line 635
      ulptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 637
    tmp___2 = strtol((char const   */* __restrict  */)ulptr, (char **/* __restrict  */)(& my_endptr),
                     0);
    }
#line 637
    dev = (int )tmp___2;
    }
#line 639
    if (dev > 16) {
      {
      {
#line 641
      tmp___3 = __errno_location();
      }
#line 641
      *tmp___3 = 22;
      {
#line 642
      br_error((char *)"br_strtoul", (char *)"Bad device number");
      }
      }
#line 643
      return (-1);
    } else
#line 639
    if (dev < 1) {
      {
      {
#line 641
      tmp___3 = __errno_location();
      }
#line 641
      *tmp___3 = 22;
      {
#line 642
      br_error((char *)"br_strtoul", (char *)"Bad device number");
      }
      }
#line 643
      return (-1);
    }
#line 646
    last_endptr = ulptr;
    {
    {
#line 648
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 648
      tmp___4 = __ctype_b_loc();
      }
      }
#line 648
      if (! ((int const   )*(*tmp___4 + (int )*my_endptr) & 8192)) {
#line 648
        goto while_break___2;
      }
#line 649
      my_endptr ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 651
    ulptr = my_endptr;
#line 653
    if ((int )*my_endptr != 0) {
#line 653
      if ((int )*my_endptr != 44) {
#line 654
        *endptr = last_endptr;
#line 655
        return (0);
      }
    }
    {
    {
#line 658
    tmp___5 = br_add_unit(units, house, dev - 1);
    }
    }
#line 658
    if (tmp___5 < 0) {
#line 659
      return (-1);
    }
#line 623
    tmp___6 = ulptr;
#line 623
    ulptr ++;
#line 623
    if (! *tmp___6) {
#line 623
      goto while_break;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  ulptr --;
#line 662
  *endptr = ulptr;
#line 664
  return (0);
}
}
#line 667 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_ulcat(br_unit_list *a , br_unit_list *b ) 
{ 
  register int i ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 672
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
    {
#line 673
    tmp = __errno_location();
    }
#line 673
    *tmp = 22;
    {
#line 674
    br_error((char *)"br_ulcat", (char *)"NULL unit list");
    }
    }
#line 675
    return (-1);
  } else
#line 672
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
    {
#line 673
    tmp = __errno_location();
    }
#line 673
    *tmp = 22;
    {
#line 674
    br_error((char *)"br_ulcat", (char *)"NULL unit list");
    }
    }
#line 675
    return (-1);
  }
#line 678
  i = 0;
  {
  {
#line 678
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 678
    if (! (i < b->numunits)) {
#line 678
      goto while_break;
    }
    {
    {
#line 679
    tmp___0 = br_add_unit(a, *(b->houses + i), *(b->devs + i));
    }
    }
#line 679
    if (tmp___0 < 0) {
#line 680
      return (-1);
    }
#line 678
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (0);
}
}
#line 686 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
br_unit_list *br_uldup(br_unit_list *a ) 
{ 
  br_unit_list *units ;
  register int i ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 692
  units = br_new_unit_list();
  }
  }
#line 694
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 695
    return ((br_unit_list *)((void *)0));
  }
#line 698
  if (a->allocatedunits) {
    {
    {
#line 699
    tmp = malloc((size_t )(sizeof(int ) * (unsigned long )a->allocatedunits));
    }
#line 699
    units->devs = (int *)tmp;
    }
#line 701
    if ((unsigned long )units->devs == (unsigned long )((void *)0)) {
      {
      {
#line 702
      br_error((char *)"br_uldup", (char *)"malloc");
      }
      }
#line 703
      return ((br_unit_list *)((void *)0));
    }
    {
    {
#line 711
    tmp___0 = malloc((size_t )(sizeof(int ) * (unsigned long )a->allocatedunits));
    }
#line 711
    units->houses = (int *)tmp___0;
    }
#line 713
    if ((unsigned long )units->houses == (unsigned long )((void *)0)) {
      {
      {
#line 714
      br_error((char *)"br_uldup", (char *)"malloc");
      }
      }
#line 715
      return ((br_unit_list *)((void *)0));
    }
#line 723
    i = 0;
    {
    {
#line 723
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 723
      if (! (i < a->numunits)) {
#line 723
        goto while_break;
      }
#line 724
      *(units->devs + i) = *(a->devs + i);
#line 725
      *(units->houses + i) = *(a->houses + i);
#line 723
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 729
  units->numunits = a->numunits;
#line 730
  units->allocatedunits = a->allocatedunits;
#line 732
  return (units);
}
}
#line 735 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_strtohc(char *hcptr , char **endptr ) 
{ 
  char *my_endptr ;
  char c ;
  unsigned short const   **tmp ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *__cil_tmp19 ;

  {
#line 737
  my_endptr = hcptr;
  {
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 741
    tmp = __ctype_b_loc();
    }
    }
#line 741
    if (! ((int const   )*(*tmp + (int )*my_endptr) & 8192)) {
#line 741
      goto while_break;
    }
#line 742
    my_endptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  if (! *my_endptr) {
#line 745
    *endptr = hcptr;
#line 746
    return (-1);
  }
  {
  {
#line 749
  tmp___11 = toupper((int )*my_endptr);
  }
  }
#line 749
  if (tmp___11 - 65 < 0) {
#line 749
    tmp___10 = '?';
  } else {
    {
    {
#line 749
    tmp___12 = toupper((int )*my_endptr);
    }
    }
#line 749
    if (tmp___12 - 65 > 15) {
#line 749
      tmp___10 = '?';
    } else {
      {
      {
#line 749
      tmp___9 = toupper((int )*my_endptr);
      }
#line 749
      tmp___10 = (int )*("ABCDEFGHIJKLMNOP" + (tmp___9 - 65));
      }
    }
  }
#line 749
  if (tmp___10 != 63) {
    {
    {
#line 749
    tmp___6 = toupper((int )*my_endptr);
    }
#line 749
    c = (char )(tmp___6 - 65);
    }
  } else {
#line 749
    c = (char)-1;
  }
#line 751
  if ((int )c < 0) {
#line 752
    *endptr = hcptr;
#line 753
    return (-1);
  }
#line 756
  my_endptr ++;
#line 756
  *endptr = my_endptr;
#line 758
  return ((int )c);
}
}
#line 761 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_get_ul_device(br_unit_list *units , int index___0 ) 
{ 


  {
#line 763
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 764
    return (-1);
  }
#line 766
  if (index___0 >= units->numunits) {
#line 767
    return (-1);
  }
#line 769
  return (*(units->devs + index___0));
}
}
#line 772 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_get_ul_house(br_unit_list *units , int index___0 ) 
{ 


  {
#line 774
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 775
    return (-1);
  }
#line 777
  if (index___0 > units->numunits) {
#line 778
    return (-1);
  }
#line 780
  return (*(units->houses + index___0));
}
}
#line 783 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_get_num_units(br_unit_list *units ) 
{ 


  {
#line 785
  if ((unsigned long )units == (unsigned long )((void *)0)) {
#line 786
    return (0);
  }
#line 788
  return (units->numunits);
}
}
#line 791 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd_engine.c"
int br_get_num_commands(br_control_info *cinfo ) 
{ 


  {
#line 793
  if ((unsigned long )cinfo == (unsigned long )((void *)0)) {
#line 794
    return (0);
  }
#line 796
  return (cinfo->numcmds);
}
}
#line 515 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
static struct option long_options___0[15]  = 
#line 515 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br.c"
  {      {"help", 0, (int *)0, 'h'}, 
        {"port", 1, (int *)0, 'x'}, 
        {"repeat", 1, (int *)0, 'r'}, 
        {"on", 1, (int *)0, 'n'}, 
        {"off", 1, (int *)0, 'f'}, 
        {"ON", 0, (int *)0, 'N'}, 
        {"OFF", 0, (int *)0, 'F'}, 
        {"dim", 1, (int *)0, 'd'}, 
        {"lamps_on", 0, (int *)0, 'B'}, 
        {"lamps_off", 0, (int *)0, 'D'}, 
        {"inverse", 0, (int *)0, 'i'}, 
        {"house", 1, (int *)0, 'c'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"pause", 0, (int *)0, 'p'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 27 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char housecode_table___0[16]  = 
#line 27 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
  {      (char)6,      (char)7,      (char)4,      (char)5, 
        (char)8,      (char)9,      (char)10,      (char)11, 
        (char)14,      (char)15,      (char)12,      (char)13, 
        (char)0,      (char)1,      (char)2,      (char)3};
#line 38 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char device_table___0[16][2]  = 
#line 38
  { {        (char)0,        (char)0}, 
   {        (char)0,        (char)16}, 
   {        (char)0,        (char)8}, 
   {        (char)0,        (char)24}, 
   {        (char)0,        (char)64}, 
   {        (char)0,        (char)80}, 
   {        (char)0,        (char)72}, 
   {        (char)0,        (char)88}, 
   {        (char)4,        (char)0}, 
   {        (char)4,        (char)16}, 
   {        (char)4,        (char)8}, 
   {        (char)4,        (char)24}, 
   {        (char)4,        (char)64}, 
   {        (char)4,        (char)80}, 
   {        (char)4,        (char)72}, 
   {        (char)4,        (char)88}};
#line 49 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char cmd_table___0[9]  = 
#line 49
  {      (char)0,      (char)32,      (char)-104,      (char)-120, 
        (char)-128,      (char)-111,      (char)-124,      (char)-108, 
        (char)32};
#line 105 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static void br_int_err_handler___0(char *where , char *problem ) ;
#line 122 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static void br_int_err_handler___0(char *where , char *problem ) 
{ 
  int tmperrno ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 124
  tmp = __errno_location();
  }
#line 124
  tmperrno = *tmp;
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: ");
  }
  }
#line 129
  if (tmperrno) {
    {
    {
#line 130
    tmp___0 = strerror(tmperrno);
    }
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] ",
            tmp___0);
    }
    }
  }
#line 132
  if (problem) {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
            problem);
    }
    }
  }
#line 135
  if (where) {
    {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in %s",
            where);
    }
    }
  }
#line 138
  if (! where) {
#line 138
    if (! problem) {
#line 138
      if (! tmperrno) {
        {
        {
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(unknown error)");
        }
        }
      }
    }
  }
  {
  {
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int usec_sleep___0(long usecs ) 
{ 
  struct timeval sleeptime ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 153
  sleeptime.tv_sec = usecs / 1000000L;
#line 154
  sleeptime.tv_usec = usecs % 1000000L;
  {
#line 156
  tmp = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& sleeptime));
  }
  }
#line 156
  if (tmp < 0) {
    {
    {
#line 157
    br_error((char *)"usec_sleep", (char *)"select");
    }
    }
#line 158
    return (-1);
  }
#line 161
  return (0);
}
}
#line 164 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int usec_delay___0(long usecs ) 
{ 
  struct timeval endtime ;
  struct timeval currtime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 178
  tmp = gettimeofday((struct timeval */* __restrict  */)(& endtime), (__timezone_ptr_t )((void *)0));
  }
  }
#line 178
  if (tmp < 0) {
    {
    {
#line 179
    br_error((char *)"usec_delay", (char *)"gettimeofday");
    }
    }
#line 180
    return (-1);
  }
#line 183
  endtime.tv_usec += usecs;
#line 185
  if (endtime.tv_usec >= 1000000L) {
#line 186
    (endtime.tv_sec) ++;
#line 187
    endtime.tv_usec -= 1000000L;
  }
  {
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 191
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& currtime), (__timezone_ptr_t )((void *)0));
    }
    }
#line 191
    if (tmp___0 < 0) {
      {
      {
#line 192
      br_error((char *)"usec_delay", (char *)"gettimeofday");
      }
      }
#line 193
      return (-1);
    }
#line 190
    if (endtime.tv_sec == currtime.tv_sec) {
#line 190
      tmp___1 = endtime.tv_usec > currtime.tv_usec;
    } else {
#line 190
      tmp___1 = endtime.tv_sec > currtime.tv_sec;
    }
#line 190
    if (! tmp___1) {
#line 190
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 200 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int bits_out___0(int const   fd , int const   bits ) 
{ 
  int out ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 213
  if (bits) {
#line 213
    out = 2;
  } else {
#line 213
    out = 4;
  }
  {
  {
#line 217
  tmp = ioctl((int )fd, 21527UL, & out);
  }
  }
#line 217
  if (tmp < 0) {
    {
    {
#line 218
    br_error((char *)"bits_out", (char *)"ioctl");
    }
    }
#line 219
    return (-1);
  }
  {
  {
#line 222
  tmp___0 = usec_delay___0((long )br_inter_bit_delay);
  }
  }
#line 222
  if (tmp___0 < 0) {
#line 223
    return (-1);
  }
#line 225
  return (0);
}
}
#line 228 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int clock_out___0(int const   fd ) 
{ 
  int out ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 235
  out = 6;
  {
#line 238
  tmp = ioctl((int )fd, 21526UL, & out);
  }
  }
#line 238
  if (tmp < 0) {
    {
    {
#line 239
    br_error((char *)"clock_out", (char *)"ioctl");
    }
    }
#line 240
    return (-1);
  }
  {
  {
#line 243
  tmp___0 = usec_delay___0((long )br_inter_bit_delay);
  }
  }
#line 243
  if (tmp___0 < 0) {
#line 244
    return (-1);
  }
#line 246
  return (0);
}
}
#line 27 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char housecode_table___1[16]  = 
#line 27 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
  {      (char)6,      (char)7,      (char)4,      (char)5, 
        (char)8,      (char)9,      (char)10,      (char)11, 
        (char)14,      (char)15,      (char)12,      (char)13, 
        (char)0,      (char)1,      (char)2,      (char)3};
#line 38 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char device_table___1[16][2]  = 
#line 38
  { {        (char)0,        (char)0}, 
   {        (char)0,        (char)16}, 
   {        (char)0,        (char)8}, 
   {        (char)0,        (char)24}, 
   {        (char)0,        (char)64}, 
   {        (char)0,        (char)80}, 
   {        (char)0,        (char)72}, 
   {        (char)0,        (char)88}, 
   {        (char)4,        (char)0}, 
   {        (char)4,        (char)16}, 
   {        (char)4,        (char)8}, 
   {        (char)4,        (char)24}, 
   {        (char)4,        (char)64}, 
   {        (char)4,        (char)80}, 
   {        (char)4,        (char)72}, 
   {        (char)4,        (char)88}};
#line 49 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_translate.h"
static char cmd_table___1[9]  = 
#line 49
  {      (char)0,      (char)32,      (char)-104,      (char)-120, 
        (char)-128,      (char)-111,      (char)-124,      (char)-108, 
        (char)32};
#line 105 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static void br_int_err_handler___1(char *where , char *problem ) ;
#line 122 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static void br_int_err_handler___1(char *where , char *problem ) 
{ 
  int tmperrno ;
  int *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 124
  tmp = __errno_location();
  }
#line 124
  tmperrno = *tmp;
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: ");
  }
  }
#line 129
  if (tmperrno) {
    {
    {
#line 130
    tmp___0 = strerror(tmperrno);
    }
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] ",
            tmp___0);
    }
    }
  }
#line 132
  if (problem) {
    {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
            problem);
    }
    }
  }
#line 135
  if (where) {
    {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in %s",
            where);
    }
    }
  }
#line 138
  if (! where) {
#line 138
    if (! problem) {
#line 138
      if (! tmperrno) {
        {
        {
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(unknown error)");
        }
        }
      }
    }
  }
  {
  {
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int usec_sleep___1(long usecs ) 
{ 
  struct timeval sleeptime ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 153
  sleeptime.tv_sec = usecs / 1000000L;
#line 154
  sleeptime.tv_usec = usecs % 1000000L;
  {
#line 156
  tmp = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& sleeptime));
  }
  }
#line 156
  if (tmp < 0) {
    {
    {
#line 157
    br_error((char *)"usec_sleep", (char *)"select");
    }
    }
#line 158
    return (-1);
  }
#line 161
  return (0);
}
}
#line 164 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int usec_delay___1(long usecs ) 
{ 
  struct timeval endtime ;
  struct timeval currtime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 178
  tmp = gettimeofday((struct timeval */* __restrict  */)(& endtime), (__timezone_ptr_t )((void *)0));
  }
  }
#line 178
  if (tmp < 0) {
    {
    {
#line 179
    br_error((char *)"usec_delay", (char *)"gettimeofday");
    }
    }
#line 180
    return (-1);
  }
#line 183
  endtime.tv_usec += usecs;
#line 185
  if (endtime.tv_usec >= 1000000L) {
#line 186
    (endtime.tv_sec) ++;
#line 187
    endtime.tv_usec -= 1000000L;
  }
  {
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 191
    tmp___0 = gettimeofday((struct timeval */* __restrict  */)(& currtime), (__timezone_ptr_t )((void *)0));
    }
    }
#line 191
    if (tmp___0 < 0) {
      {
      {
#line 192
      br_error((char *)"usec_delay", (char *)"gettimeofday");
      }
      }
#line 193
      return (-1);
    }
#line 190
    if (endtime.tv_sec == currtime.tv_sec) {
#line 190
      tmp___1 = endtime.tv_usec > currtime.tv_usec;
    } else {
#line 190
      tmp___1 = endtime.tv_sec > currtime.tv_sec;
    }
#line 190
    if (! tmp___1) {
#line 190
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 200 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int bits_out___1(int const   fd , int const   bits ) 
{ 
  int out ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 213
  if (bits) {
#line 213
    out = 2;
  } else {
#line 213
    out = 4;
  }
  {
  {
#line 217
  tmp = ioctl((int )fd, 21527UL, & out);
  }
  }
#line 217
  if (tmp < 0) {
    {
    {
#line 218
    br_error((char *)"bits_out", (char *)"ioctl");
    }
    }
#line 219
    return (-1);
  }
  {
  {
#line 222
  tmp___0 = usec_delay___1((long )br_inter_bit_delay);
  }
  }
#line 222
  if (tmp___0 < 0) {
#line 223
    return (-1);
  }
#line 225
  return (0);
}
}
#line 228 "/home/wslee/benchmarks/bottlerocket-0.05b3/./br_cmd.c"
static int clock_out___1(int const   fd ) 
{ 
  int out ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 235
  out = 6;
  {
#line 238
  tmp = ioctl((int )fd, 21526UL, & out);
  }
  }
#line 238
  if (tmp < 0) {
    {
    {
#line 239
    br_error((char *)"clock_out", (char *)"ioctl");
    }
    }
#line 240
    return (-1);
  }
  {
  {
#line 243
  tmp___0 = usec_delay___1((long )br_inter_bit_delay);
  }
  }
#line 243
  if (tmp___0 < 0) {
#line 244
    return (-1);
  }
#line 246
  return (0);
}
}
