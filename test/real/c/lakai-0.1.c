/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 93 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
typedef int LHANDLE;
#line 118 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
struct __anonstruct_LakaiProgramList_24 {
   int numprogs ;
   char **prognames ;
};
#line 118 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiProgramList_24 LakaiProgramList;
#line 127 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
struct __anonstruct_LakaiSampleList_25 {
   int numsamples ;
   char **samplenames ;
};
#line 127 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiSampleList_25 LakaiSampleList;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 43 "/usr/include/scsi/sg.h"
struct sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   unsigned char *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 43 "/usr/include/scsi/sg.h"
typedef struct sg_io_hdr sg_io_hdr_t;
#line 101 "/usr/include/scsi/sg.h"
struct sg_scsi_id {
   int host_no ;
   int channel ;
   int scsi_id ;
   int lun ;
   int scsi_type ;
   short h_cmd_per_lun ;
   short d_queue_depth ;
   int unused[2] ;
};
#line 105 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
struct __anonstruct_LakaiStatus_26 {
   int osversion ;
   int nummaxblocks ;
   int numfreeblocks ;
   int nummaxsamples ;
   int numfreesamples ;
   int eoxchannel ;
};
#line 105 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiStatus_26 LakaiStatus;
#line 137 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
struct __anonstruct_LakaiProgram_9 {
   unsigned char prident ;
   unsigned short kgrp1 ;
   unsigned char prname[12] ;
   unsigned char prgnum ;
   unsigned char pmchan ;
   unsigned char polyph ;
   unsigned char priort ;
   unsigned char playlo ;
   unsigned char playhi ;
   unsigned char oshift ;
   unsigned char output ;
   unsigned char stereo ;
   unsigned char panpos ;
   unsigned char prloud ;
   unsigned char v_loud ;
   unsigned char k_loud ;
   unsigned char p_loud ;
   unsigned char panrat ;
   unsigned char pandep ;
   unsigned char pandel ;
   unsigned char k_panp ;
   unsigned char lforat ;
   unsigned char lfodep ;
   unsigned char lfodel ;
   unsigned char mwldep ;
   unsigned char prsdep ;
   unsigned char veldep ;
   unsigned char b_ptch ;
   unsigned char p_ptch ;
   unsigned char kxfade ;
   unsigned char groups ;
   unsigned char tpnum ;
   unsigned char temper[12] ;
   unsigned char echout ;
   unsigned char mw_pan ;
   unsigned char cohere ;
   unsigned char desync ;
   unsigned char plaw ;
   unsigned char vassoq ;
   unsigned char sploud ;
   unsigned char spatt ;
   unsigned char spfilt ;
   unsigned short ptuno ;
   unsigned char k_lrat ;
   unsigned char k_ldep ;
   unsigned char k_ldel ;
   unsigned char voscl ;
   unsigned char vsscl ;
   unsigned char legato ;
   unsigned char b_ptchd ;
   unsigned char b_mode ;
   unsigned char transpose ;
   unsigned char modspan1 ;
   unsigned char modspan2 ;
   unsigned char modspan3 ;
   unsigned char modsamp1 ;
   unsigned char modsamp2 ;
   unsigned char modslfot ;
   unsigned char modslfol ;
   unsigned char modslfod ;
   unsigned char modsfilt1 ;
   unsigned char modsfilt2 ;
   unsigned char modsfilt3 ;
   unsigned char modspitch ;
   unsigned char modsamp3 ;
   unsigned char modvpan1 ;
   unsigned char modvpan2 ;
   unsigned char modvpan3 ;
   unsigned char modvamp1 ;
   unsigned char modvamp2 ;
   unsigned char modvlfor ;
   unsigned char modvlfol ;
   unsigned char modvlfod ;
   unsigned char lfo1wave ;
   unsigned char lfo2wave ;
   unsigned char modslflt2_1 ;
   unsigned char modslflt2_2 ;
   unsigned char modslflt2_3 ;
   unsigned char lfo2trig ;
   unsigned char _reserved1[7] ;
   unsigned char portime ;
   unsigned char portype ;
   unsigned char porten ;
   unsigned char pfxchan ;
   unsigned char pfxslev ;
};
#line 137 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiProgram_9 LakaiProgram;
#line 250 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
struct __anonstruct_LakaiKeygroup_10 {
   unsigned char kgident ;
   unsigned short nxtkg ;
   unsigned char lonote ;
   unsigned char hinote ;
   unsigned short kgtuno ;
   unsigned char filfrq ;
   unsigned char k_freq ;
   unsigned char v_freq ;
   unsigned char p_freq ;
   unsigned char e_freq ;
   unsigned char attak1 ;
   unsigned char decay1 ;
   unsigned char sustn1 ;
   unsigned char relse1 ;
   unsigned char v_att1 ;
   unsigned char v_rel1 ;
   unsigned char o_rel1 ;
   unsigned char k_dar1 ;
   unsigned char attak2 ;
   unsigned char decay2 ;
   unsigned char sustn2 ;
   unsigned char relse2 ;
   unsigned char v_att2 ;
   unsigned char v_rel2 ;
   unsigned char o_rel2 ;
   unsigned char k_dar2 ;
   unsigned char v_env2 ;
   unsigned char e_ptch ;
   unsigned char vxfade ;
   unsigned char vzones ;
   unsigned char lkxf ;
   unsigned char rkxf ;
   unsigned char sname1[12] ;
   unsigned char lovel1 ;
   unsigned char hivel1 ;
   unsigned short vtuno1 ;
   unsigned char vloud1 ;
   unsigned char vfreq1 ;
   unsigned char vpano1 ;
   unsigned char zplay1 ;
   unsigned char lvxf1 ;
   unsigned char hvxf1 ;
   unsigned short sbadd1 ;
   unsigned char sname2[12] ;
   unsigned char lovel2 ;
   unsigned char hivel2 ;
   unsigned short vtuno2 ;
   unsigned char vloud2 ;
   unsigned char vfreq2 ;
   unsigned char vpano2 ;
   unsigned char zplay2 ;
   unsigned char lvxf2 ;
   unsigned char hvxf2 ;
   unsigned short sbadd2 ;
   unsigned char sname3[12] ;
   unsigned char lovel3 ;
   unsigned char hivel3 ;
   unsigned short vtuno3 ;
   unsigned char vloud3 ;
   unsigned char vfreq3 ;
   unsigned char vpano3 ;
   unsigned char zplay3 ;
   unsigned char lvxf3 ;
   unsigned char hvxf3 ;
   unsigned short sbadd3 ;
   unsigned char sname4[12] ;
   unsigned char lovel4 ;
   unsigned char hivel4 ;
   unsigned short vtuno4 ;
   unsigned char vloud4 ;
   unsigned char vfreq4 ;
   unsigned char vpano4 ;
   unsigned char zplay4 ;
   unsigned char lvxf4 ;
   unsigned char hvxf4 ;
   unsigned short sbadd4 ;
   unsigned char kbeat ;
   unsigned char ahold ;
   unsigned char cp1 ;
   unsigned char cp2 ;
   unsigned char cp3 ;
   unsigned char cp4 ;
   unsigned char vzout1 ;
   unsigned char vzout2 ;
   unsigned char vzout3 ;
   unsigned char vzout4 ;
   unsigned short vss1 ;
   unsigned short vss2 ;
   unsigned short vss3 ;
   unsigned short vss4 ;
   unsigned char kv_lo ;
   unsigned char filq ;
   unsigned char l_ptch ;
   unsigned char modvfilt1 ;
   unsigned char modvfilt2 ;
   unsigned char modvfilt3 ;
   unsigned char modvpitch ;
   unsigned char modvamp3 ;
   unsigned char env2l1 ;
   unsigned char env2r2 ;
   unsigned char env2l2 ;
   unsigned char env2l4 ;
   unsigned char kgmute ;
   unsigned char pfxchan ;
   unsigned char pfxslev ;
   unsigned char res1[5] ;
   unsigned char lsi2_on ;
   unsigned char flt2gain ;
   unsigned char flt2mode ;
   unsigned char flt2q ;
   unsigned char tonefreq ;
   unsigned char toneslop ;
   unsigned char modvflt2_1 ;
   unsigned char modvflt2_2 ;
   unsigned char modvflt2_3 ;
   unsigned char fil2fr ;
   unsigned char k_frq2 ;
   unsigned char env3r1 ;
   unsigned char env3l1 ;
   unsigned char env3r2 ;
   unsigned char env3l2 ;
   unsigned char env3r3 ;
   unsigned char env3l3 ;
   unsigned char env3r4 ;
   unsigned char env3l4 ;
   unsigned char v_att3 ;
   unsigned char v_rel3 ;
   unsigned char o_rel3 ;
   unsigned char k_dar3 ;
   unsigned char v_env3 ;
};
#line 250 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
typedef struct __anonstruct_LakaiKeygroup_10 LakaiKeygroup;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 580 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
void lakai_init(void) ;
#line 597
LHANDLE lakai_open(char *devname ) ;
#line 618
int lakai_close(LHANDLE handle ) ;
#line 652
int lakai_setmode(LHANDLE handle , int mode ) ;
#line 895
int lakai_get_program_list(LHANDLE handle , LakaiProgramList *lp ) ;
#line 912
void lakai_free_program_list(LakaiProgramList *lp ) ;
#line 929
int lakai_get_sample_list(LHANDLE handle , LakaiSampleList *ls ) ;
#line 947
void lakai_free_sample_list(LakaiSampleList *ls ) ;
#line 1049
int lakai_delete_program(LHANDLE handle , int prognum ) ;
#line 1091
int lakai_delete_sample(LHANDLE handle , int samplenum ) ;
#line 14 "/home/wslee/benchmarks/sound/lakai-0.1/lakclear.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int numprogs ;
  int numsamps ;
  int res ;
  LHANDLE hd1 ;
  LakaiProgramList lp ;
  LakaiSampleList ls ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 21
  if (argc != 2) {
    {
    {
#line 23
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s <devname>\n",
            *(argv + 0));
    }
    {
#line 24
    exit(1);
    }
    }
  }
  {
  {
#line 27
  lakai_init();
  }
  {
#line 29
  hd1 = lakai_open(*(argv + 1));
  }
  }
#line 30
  if (! (hd1 >= 0)) {
    {
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Open failed.\n");
    }
    {
#line 37
    lakai_close(hd1);
    }
    {
#line 38
    exit(5);
    }
    }
  }
  {
  {
#line 42
  numsamps = lakai_get_sample_list(hd1, & ls);
  }
  }
#line 43
  if (numsamps > 0) {
    {
    {
#line 45
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Deleting all samples...\n");
    }
#line 46
    i = numsamps - 1;
    }
    {
    {
#line 46
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 46
      if (! (i >= 0)) {
#line 46
        goto while_break;
      }
      {
      {
#line 48
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Delete sample #%d\n",
              i);
      }
      {
#line 49
      res = lakai_delete_sample(hd1, i);
      }
#line 46
      i --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Done.\n");
    }
    }
  } else {
    {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- No resident sample names found. --\n");
    }
    }
  }
  {
  {
#line 56
  lakai_free_sample_list(& ls);
  }
  {
#line 59
  numprogs = lakai_get_program_list(hd1, & lp);
  }
  }
#line 60
  if (numprogs > 0) {
    {
    {
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Deleting all programs...\n");
    }
#line 63
    i = numprogs - 1;
    }
    {
    {
#line 63
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 63
      if (! (i >= 0)) {
#line 63
        goto while_break___0;
      }
      {
      {
#line 65
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Delete program #%d\n",
              i);
      }
      {
#line 66
      res = lakai_delete_program(hd1, i);
      }
#line 63
      i --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 68
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Done.\n");
    }
    }
  } else {
    {
    {
#line 71
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- No resident program names found. --\n");
    }
    }
  }
  {
  {
#line 73
  lakai_free_program_list(& lp);
  }
  {
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"All done.\n");
  }
  {
#line 77
  lakai_setmode(hd1, 0);
  }
  {
#line 78
  lakai_close(hd1);
  }
  {
#line 80
  exit(0);
  }
  }
}
}
#line 562 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 456
extern int usleep(__useconds_t __useconds ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 671 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.h"
void lakai_asciitoakai(char *src , char *dst , int len ) ;
#line 691
void lakai_akaitoascii(char *src , char *dst , int len ) ;
#line 788
long lakai_get_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) ;
#line 878
int lakai_get_status_report(LHANDLE handle , LakaiStatus *ls ) ;
#line 970
int lakai_get_program(LHANDLE handle , int prognum , unsigned char *data ) ;
#line 991
int lakai_get_keygroup(LHANDLE handle , int prognum , int keygroupnum , unsigned char *data ) ;
#line 1010
int lakai_get_sample_header(LHANDLE handle , int samplenum , unsigned char *data ) ;
#line 1030
int lakai_put_sample_header(LHANDLE handle , int samplenum , unsigned char *data ,
                            int len ) ;
#line 1070
int lakai_delete_keygroup(LHANDLE handle , int prognum , int kgrpnum ) ;
#line 1109
int lakai_get_miscdata(LHANDLE handle , unsigned char *data ) ;
#line 1146
int lakai_put_program(LHANDLE handle , int prognum , unsigned char *data , int len ) ;
#line 1173
int lakai_put_keygroup(LHANDLE handle , int prognum , int kgrpnum , unsigned char *data ,
                       int len ) ;
#line 1191
long lakai_put_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) ;
#line 34 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int open_cnt  =    -1;
#line 35 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int fhandles[16]  ;
#line 38
static int send_command(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                        int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                             char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                              char *buf ) ;
#line 46
static long getbulkdata(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata(LHANDLE handle , int numbytes , char *buf ) ;
#line 55 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
void lakai_init(void) 
{ 
  int i ;

  {
#line 59
  if (open_cnt == -1) {
#line 61
    i = 0;
    {
    {
#line 61
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 61
      if (! (i < 16)) {
#line 61
        goto while_break;
      }
#line 62
      fhandles[i] = -1;
#line 61
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 64
  return;
}
}
#line 71 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
LHANDLE lakai_open(char *devname ) 
{ 
  int sg_fd ;
  int k ;
  int slotpos ;
  struct sg_scsi_id sg_scsiid ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 77
  if (open_cnt == 15) {
    {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_open: Maximum open count of liblakai reached.\n");
    }
    }
#line 80
    return (-1);
  }
#line 83
  slotpos = 0;
  {
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! (slotpos < 16)) {
#line 83
      goto while_break;
    }
#line 85
    if (fhandles[slotpos] == -1) {
#line 86
      goto while_break;
    }
#line 83
    slotpos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (slotpos == 16) {
    {
    {
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_open: no free slot found\n");
    }
    }
#line 91
    return (-1);
  }
  {
  {
#line 95
  sg_fd = open((char const   *)devname, 2);
  }
  }
#line 96
  if (sg_fd < 0) {
    {
    {
#line 98
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_open: error opening file: %s\n",
            devname);
    }
    }
#line 99
    return (-1);
  }
  {
  {
#line 102
  tmp = ioctl(sg_fd, 8834UL, & k);
  }
  }
#line 102
  if (tmp < 0) {
    {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to do ioctl() SG_GET_VERSION_NUM on sg device\n");
    }
    }
#line 105
    return (-1);
  }
#line 108
  if (k < 30000) {
    {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sg device\'s version is too old (below version 3)\n");
    }
    {
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please get a more recent kernel\n");
    }
    {
#line 112
    close(sg_fd);
    }
    }
#line 113
    return (-1);
  }
  {
  {
#line 117
  tmp___0 = ioctl(sg_fd, 8822UL, & sg_scsiid);
  }
  }
#line 117
  if (tmp___0 < 0) {
    {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to do ioctl() SG_GET_SCSI_ID on sg device\n");
    }
    {
#line 120
    close(sg_fd);
    }
    }
#line 121
    return (-1);
  }
#line 134
  if (sg_scsiid.scsi_type != 3) {
    {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Incorrect device type - should be a PROCESSOR device\n");
    }
    {
#line 137
    close(sg_fd);
    }
    }
#line 138
    return (-1);
  }
#line 142
  open_cnt ++;
#line 143
  fhandles[slotpos] = sg_fd;
#line 145
  return (slotpos);
}
}
#line 154 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_close(LHANDLE handle ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 156
  if (fhandles[handle] == -1) {
    {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_close: Bad file handle\n");
    }
    }
#line 159
    return (-1);
  } else
#line 156
  if (handle < 0) {
    {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_close: Bad file handle\n");
    }
    }
#line 159
    return (-1);
  } else
#line 156
  if (handle > 16) {
    {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_close: Bad file handle\n");
    }
    }
#line 159
    return (-1);
  }
  {
  {
#line 161
  close(fhandles[handle]);
  }
#line 162
  fhandles[handle] = -1;
#line 163
  open_cnt --;
  }
#line 164
  return (0);
}
}
#line 175 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 173 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_setmode(LHANDLE handle , int mode ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 189
  if (mode == 0) {
#line 191
    cmdblk[2] = (unsigned char)0;
#line 192
    cmdblk[3] = (unsigned char)0;
  } else
#line 194
  if (mode == 1) {
#line 196
    cmdblk[2] = (unsigned char)1;
#line 197
    cmdblk[3] = (unsigned char)0;
  } else
#line 199
  if (mode == 2) {
#line 201
    cmdblk[2] = (unsigned char)1;
#line 202
    cmdblk[3] = (unsigned char)1;
  } else {
    {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal mode in lakai_setmode()\n");
    }
    }
#line 207
    return (-1);
  }
#line 210
  if (fhandles[handle] == -1) {
    {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode: Bad file handle\n");
    }
    }
#line 213
    return (-1);
  } else
#line 210
  if (handle < 0) {
    {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode: Bad file handle\n");
    }
    }
#line 213
    return (-1);
  } else
#line 210
  if (handle > 16) {
    {
    {
#line 212
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode: Bad file handle\n");
    }
    }
#line 213
    return (-1);
  }
  {
  {
#line 216
  tmp = send_command(fhandles[handle], (char *)(cmdblk), 1, (void *)0, 0, (void *)0,
                     0);
  }
  }
#line 216
  if (tmp != 0) {
    {
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_setmode() FAILED\n");
    }
    }
#line 219
    return (-1);
  }
#line 221
  return (0);
}
}
#line 234 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 229 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_status_report(LHANDLE handle , LakaiStatus *ls ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 237
  if (fhandles[handle] == -1) {
    {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_status_report(): Bad file handle\n");
    }
    }
#line 240
    return (-1);
  } else
#line 237
  if (handle < 0) {
    {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_status_report(): Bad file handle\n");
    }
    }
#line 240
    return (-1);
  } else
#line 237
  if (handle > 16) {
    {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_status_report(): Bad file handle\n");
    }
    }
#line 240
    return (-1);
  }
  {
  {
#line 246
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1), (unsigned int )sizeof(cmdblk1),
                                (char *)(statusbuf));
  }
  }
#line 247
  if (! (statuslen > 0)) {
    {
    {
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 262
  return (0);
}
}
#line 274 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___0[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 269 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_program_list(LHANDLE handle , LakaiProgramList *lp ) 
{ 
  unsigned char finalbuf[2048] ;
  int i ;
  int finallen ;
  int numprogs ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 277
  if (fhandles[handle] == -1) {
    {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Bad file handle\n");
    }
    }
#line 280
    return (-1);
  } else
#line 277
  if (handle < 0) {
    {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Bad file handle\n");
    }
    }
#line 280
    return (-1);
  } else
#line 277
  if (handle > 16) {
    {
    {
#line 279
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Bad file handle\n");
    }
    }
#line 280
    return (-1);
  }
  {
  {
#line 283
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___0), (unsigned int )sizeof(cmdblk1___0),
                               (char *)(finalbuf));
  }
  }
#line 284
  if (! (finallen > 0)) {
    {
    {
#line 293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 296
  numprogs = (int )finalbuf[5] + 128 * (int )finalbuf[6];
#line 298
  if ((int )finalbuf[0] == 240) {
#line 298
    if ((int )*(finalbuf + 3) == 3) {
      {
      {
#line 300
      tmp = malloc((size_t )((unsigned long )numprogs * sizeof(char *)));
      }
#line 300
      lp->prognames = (char **)tmp;
      }
#line 301
      if (! lp->prognames) {
        {
        {
#line 303
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Unable to malloc prognames\n");
        }
        }
#line 304
        return (-1);
      }
#line 306
      i = 0;
      {
      {
#line 306
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 306
        if (! (i < numprogs)) {
#line 306
          goto while_break;
        }
        {
        {
#line 308
        tmp___0 = malloc((size_t )13);
        }
#line 308
        *(lp->prognames + i) = (char *)tmp___0;
        }
#line 309
        if (! *(lp->prognames + i)) {
          {
          {
#line 311
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): Unable to malloc progname slot\n");
          }
          }
#line 312
          return (-1);
        }
        {
        {
#line 314
        lakai_akaitoascii((char *)((finalbuf + 7) + i * 12), *(lp->prognames + i),
                          12);
        }
#line 315
        *(*(lp->prognames + i) + 12) = (char )'\000';
#line 306
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 317
      lp->numprogs = numprogs;
    } else {
      {
      {
#line 320
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): bad answer from sampler\n");
      }
      }
    }
  } else {
    {
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program_list(): bad answer from sampler\n");
    }
    }
  }
#line 322
  return (numprogs);
}
}
#line 329 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
void lakai_free_program_list(LakaiProgramList *lp ) 
{ 
  int i ;

  {
#line 333
  if (lp) {
#line 335
    if (lp->numprogs > 0) {
#line 337
      i = 0;
      {
      {
#line 337
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 337
        if (! (i < lp->numprogs)) {
#line 337
          goto while_break;
        }
#line 339
        if (*(lp->prognames + i)) {
          {
          {
#line 342
          free((void *)*(lp->prognames + i));
          }
          }
        }
#line 337
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 346
      free((void *)lp->prognames);
      }
      }
    }
  }
#line 349
  return;
}
}
#line 360 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___1[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 355 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_sample_list(LHANDLE handle , LakaiSampleList *ls ) 
{ 
  unsigned char finalbuf[2048] ;
  int i ;
  int finallen ;
  int numsamples ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 363
  if (fhandles[handle] == -1) {
    {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Bad file handle\n");
    }
    }
#line 366
    return (-1);
  } else
#line 363
  if (handle < 0) {
    {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Bad file handle\n");
    }
    }
#line 366
    return (-1);
  } else
#line 363
  if (handle > 16) {
    {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Bad file handle\n");
    }
    }
#line 366
    return (-1);
  }
  {
  {
#line 369
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___1), (unsigned int )sizeof(cmdblk1___1),
                               (char *)(finalbuf));
  }
  }
#line 370
  if (! (finallen > 0)) {
    {
    {
#line 379
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 382
  numsamples = (int )finalbuf[5] + 128 * (int )finalbuf[6];
#line 384
  if ((int )finalbuf[0] == 240) {
#line 384
    if ((int )*(finalbuf + 3) == 5) {
      {
      {
#line 386
      tmp = malloc((size_t )((unsigned long )numsamples * sizeof(char *)));
      }
#line 386
      ls->samplenames = (char **)tmp;
      }
#line 387
      if (! ls->samplenames) {
        {
        {
#line 389
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Unable to malloc samplenames\n");
        }
        }
#line 390
        return (-1);
      }
#line 392
      i = 0;
      {
      {
#line 392
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 392
        if (! (i < numsamples)) {
#line 392
          goto while_break;
        }
        {
        {
#line 394
        tmp___0 = malloc((size_t )13);
        }
#line 394
        *(ls->samplenames + i) = (char *)tmp___0;
        }
#line 395
        if (! *(ls->samplenames + i)) {
          {
          {
#line 397
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): Unable to malloc samplename slot\n");
          }
          }
#line 398
          return (-1);
        }
        {
        {
#line 400
        lakai_akaitoascii((char *)((finalbuf + 7) + i * 12), *(ls->samplenames + i),
                          12);
        }
#line 401
        *(*(ls->samplenames + i) + 12) = (char )'\000';
#line 392
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 403
      ls->numsamples = numsamples;
    } else {
      {
      {
#line 407
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): bad answer from sampler\n");
      }
      }
#line 408
      return (-1);
    }
  } else {
    {
    {
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_list(): bad answer from sampler\n");
    }
    }
#line 408
    return (-1);
  }
#line 411
  return (numsamples);
}
}
#line 418 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
void lakai_free_sample_list(LakaiSampleList *ls ) 
{ 
  int i ;

  {
#line 422
  if (ls) {
#line 424
    if (ls->numsamples > 0) {
#line 426
      i = 0;
      {
      {
#line 426
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 426
        if (! (i < ls->numsamples)) {
#line 426
          goto while_break;
        }
#line 428
        if (*(ls->samplenames + i)) {
          {
          {
#line 431
          free((void *)*(ls->samplenames + i));
          }
          }
        }
#line 426
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 435
      free((void *)ls->samplenames);
      }
      }
    }
  }
#line 438
  return;
}
}
#line 452 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___2[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 447 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_program(LHANDLE handle , int prognum , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 457
  if (fhandles[handle] == -1) {
    {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Bad file handle\n");
    }
    }
#line 460
    return (-1);
  } else
#line 457
  if (handle < 0) {
    {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Bad file handle\n");
    }
    }
#line 460
    return (-1);
  } else
#line 457
  if (handle > 16) {
    {
    {
#line 459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Bad file handle\n");
    }
    }
#line 460
    return (-1);
  }
#line 463
  if (prognum < 0) {
    {
    {
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Illegal program number\n");
    }
    }
#line 466
    return (-1);
  } else
#line 463
  if (prognum > 16383) {
    {
    {
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_program(): Illegal program number\n");
    }
    }
#line 466
    return (-1);
  }
  {
#line 469
  cmdblk1___2[6] = (unsigned char )(prognum / 128);
#line 470
  cmdblk1___2[5] = (unsigned char )(prognum - (int )cmdblk1___2[6] * 128);
  {
#line 472
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___2), (unsigned int )sizeof(cmdblk1___2),
                               (char *)(finalbuf));
  }
  }
#line 473
  if (finallen <= 0) {
    {
    {
#line 475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
#line 476
    return (-1);
  }
#line 484
  numvals = (finallen - 8) / 2;
#line 485
  i = 0;
  {
  {
#line 485
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < numvals)) {
#line 485
      goto while_break;
    }
#line 487
    *(data + i) = (unsigned char )((int )finalbuf[7 + i * 2] | ((int )finalbuf[(7 + i * 2) + 1] << 4));
#line 485
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  return (numvals);
}
}
#line 550 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___3[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 545 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_keygroup(LHANDLE handle , int prognum , int keygroupnum , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 557
  if (fhandles[handle] == -1) {
    {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Bad file handle\n");
    }
    }
#line 560
    return (-1);
  } else
#line 557
  if (handle < 0) {
    {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Bad file handle\n");
    }
    }
#line 560
    return (-1);
  } else
#line 557
  if (handle > 16) {
    {
    {
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Bad file handle\n");
    }
    }
#line 560
    return (-1);
  }
#line 563
  if (prognum < 0) {
    {
    {
#line 565
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal program number\n");
    }
    }
#line 566
    return (-1);
  } else
#line 563
  if (prognum > 16383) {
    {
    {
#line 565
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal program number\n");
    }
    }
#line 566
    return (-1);
  }
#line 569
  cmdblk1___3[6] = (unsigned char )(prognum / 128);
#line 570
  cmdblk1___3[5] = (unsigned char )(prognum - (int )cmdblk1___3[6] * 128);
#line 572
  if (keygroupnum < 0) {
    {
    {
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal keygroup number\n");
    }
    }
#line 575
    return (-1);
  } else
#line 572
  if (keygroupnum > 99) {
    {
    {
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_keygroup(): Illegal keygroup number\n");
    }
    }
#line 575
    return (-1);
  }
  {
#line 578
  cmdblk1___3[7] = (unsigned char )keygroupnum;
  {
#line 580
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___3), (unsigned int )sizeof(cmdblk1___3),
                               (char *)(finalbuf));
  }
  }
#line 581
  if (finallen <= 0) {
    {
    {
#line 583
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
#line 584
    return (-1);
  }
#line 592
  numvals = (finallen - 9) / 2;
#line 593
  i = 0;
  {
  {
#line 593
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 593
    if (! (i < numvals)) {
#line 593
      goto while_break;
    }
#line 595
    *(data + i) = (unsigned char )((int )finalbuf[8 + i * 2] | ((int )finalbuf[(8 + i * 2) + 1] << 4));
#line 593
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return (numvals);
}
}
#line 621 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___4[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 616 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_sample_header(LHANDLE handle , int samplenum , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 628
  if (fhandles[handle] == -1) {
    {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Bad file handle\n");
    }
    }
#line 631
    return (-1);
  } else
#line 628
  if (handle < 0) {
    {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Bad file handle\n");
    }
    }
#line 631
    return (-1);
  } else
#line 628
  if (handle > 16) {
    {
    {
#line 630
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Bad file handle\n");
    }
    }
#line 631
    return (-1);
  }
#line 634
  if (samplenum < 0) {
    {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Illegal sample number\n");
    }
    }
#line 637
    return (-1);
  } else
#line 634
  if (samplenum > 16383) {
    {
    {
#line 636
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample_header(): Illegal sample number\n");
    }
    }
#line 637
    return (-1);
  }
  {
#line 640
  cmdblk1___4[6] = (unsigned char )(samplenum / 128);
#line 641
  cmdblk1___4[5] = (unsigned char )(samplenum - (int )cmdblk1___4[6] * 128);
  {
#line 643
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___4), (unsigned int )sizeof(cmdblk1___4),
                               (char *)(finalbuf));
  }
  }
#line 644
  if (finallen <= 0) {
    {
    {
#line 646
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
#line 647
    return (-1);
  }
#line 655
  numvals = (finallen - 8) / 2;
#line 656
  i = 0;
  {
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i < numvals)) {
#line 656
      goto while_break;
    }
#line 658
    *(data + i) = (unsigned char )((int )finalbuf[7 + i * 2] | ((int )finalbuf[(7 + i * 2) + 1] << 4));
#line 656
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  return (numvals);
}
}
#line 693 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___5[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 687 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_put_sample_header(LHANDLE handle , int samplenum , unsigned char *data ,
                            int len ) 
{ 
  unsigned char finalbuf[1024] ;
  unsigned char resbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 700
  if (fhandles[handle] == -1) {
    {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Bad file handle\n");
    }
    }
#line 703
    return (-1);
  } else
#line 700
  if (handle < 0) {
    {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Bad file handle\n");
    }
    }
#line 703
    return (-1);
  } else
#line 700
  if (handle > 16) {
    {
    {
#line 702
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Bad file handle\n");
    }
    }
#line 703
    return (-1);
  }
#line 706
  if (samplenum < 0) {
    {
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Illegal sample number\n");
    }
    }
#line 709
    return (-1);
  } else
#line 706
  if (samplenum > 16383) {
    {
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample_header(): Illegal sample number\n");
    }
    }
#line 709
    return (-1);
  }
  {
#line 712
  cmdblk1___5[6] = (unsigned char )(samplenum / 128);
#line 713
  cmdblk1___5[5] = (unsigned char )(samplenum - (int )cmdblk1___5[6] * 128);
  {
#line 716
  memcpy((void */* __restrict  */)(finalbuf), (void const   */* __restrict  */)(cmdblk1___5),
         (size_t )sizeof(cmdblk1___5));
  }
#line 718
  i = 0;
  }
  {
  {
#line 718
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 718
    if (! (i < len)) {
#line 718
      goto while_break;
    }
#line 720
    finalbuf[sizeof(cmdblk1___5) + (unsigned long )(i * 2)] = (unsigned char )((int )*(data + i) & 15);
#line 721
    finalbuf[(sizeof(cmdblk1___5) + (unsigned long )(i * 2)) + 1UL] = (unsigned char )(((int )*(data + i) & 240) >> 4);
#line 718
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  finalbuf[sizeof(cmdblk1___5) + (unsigned long )(2 * len)] = (unsigned char)247;
  {
#line 726
  finallen = sendrecv_scsimidi(handle, (char *)(finalbuf), (unsigned int )((sizeof(cmdblk1___5) + (unsigned long )(len * 2)) + 1UL),
                               (char *)(resbuf));
  }
  }
#line 728
  if (finallen <= 0) {
    {
    {
#line 730
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
#line 731
    return (-1);
  }
#line 735
  return (numvals);
}
}
#line 747 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___6[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 742 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_delete_program(LHANDLE handle , int prognum ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 750
  if (fhandles[handle] == -1) {
    {
    {
#line 752
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Bad file handle\n");
    }
    }
#line 753
    return (-1);
  } else
#line 750
  if (handle < 0) {
    {
    {
#line 752
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Bad file handle\n");
    }
    }
#line 753
    return (-1);
  } else
#line 750
  if (handle > 16) {
    {
    {
#line 752
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Bad file handle\n");
    }
    }
#line 753
    return (-1);
  }
#line 756
  if (prognum < 0) {
    {
    {
#line 758
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Illegal program number\n");
    }
    }
#line 759
    return (-1);
  } else
#line 756
  if (prognum > 16383) {
    {
    {
#line 758
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_program(): Illegal program number\n");
    }
    }
#line 759
    return (-1);
  }
  {
#line 762
  cmdblk1___6[6] = (unsigned char )(prognum / 128);
#line 763
  cmdblk1___6[5] = (unsigned char )(prognum - (int )cmdblk1___6[6] * 128);
  {
#line 765
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1___6), (unsigned int )sizeof(cmdblk1___6),
                                (char *)(statusbuf));
  }
  }
#line 767
  if (! (statuslen > 0)) {
    {
    {
#line 776
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 779
  return (0);
}
}
#line 792 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___7[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 787 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_delete_keygroup(LHANDLE handle , int prognum , int kgrpnum ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 795
  if (fhandles[handle] == -1) {
    {
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Bad file handle\n");
    }
    }
#line 798
    return (-1);
  } else
#line 795
  if (handle < 0) {
    {
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Bad file handle\n");
    }
    }
#line 798
    return (-1);
  } else
#line 795
  if (handle > 16) {
    {
    {
#line 797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Bad file handle\n");
    }
    }
#line 798
    return (-1);
  }
#line 801
  if (prognum < 0) {
    {
    {
#line 803
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal program number\n");
    }
    }
#line 804
    return (-1);
  } else
#line 801
  if (prognum > 16383) {
    {
    {
#line 803
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal program number\n");
    }
    }
#line 804
    return (-1);
  }
#line 807
  if (kgrpnum < 0) {
    {
    {
#line 809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal keygroup number\n");
    }
    }
#line 810
    return (-1);
  } else
#line 807
  if (kgrpnum > 99) {
    {
    {
#line 809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_keygroup(): Illegal keygroup number\n");
    }
    }
#line 810
    return (-1);
  }
  {
#line 812
  cmdblk1___7[6] = (unsigned char )(prognum / 128);
#line 813
  cmdblk1___7[5] = (unsigned char )(prognum - (int )cmdblk1___7[6] * 128);
#line 815
  cmdblk1___7[7] = (unsigned char )kgrpnum;
  {
#line 817
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1___7), (unsigned int )sizeof(cmdblk1___7),
                                (char *)(statusbuf));
  }
  }
#line 819
  if (! (statuslen > 0)) {
    {
    {
#line 828
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 831
  return (0);
}
}
#line 846 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___8[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 841 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_delete_sample(LHANDLE handle , int samplenum ) 
{ 
  unsigned char statusbuf[100] ;
  int statuslen ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 849
  if (fhandles[handle] == -1) {
    {
    {
#line 851
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Bad file handle\n");
    }
    }
#line 852
    return (-1);
  } else
#line 849
  if (handle < 0) {
    {
    {
#line 851
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Bad file handle\n");
    }
    }
#line 852
    return (-1);
  } else
#line 849
  if (handle > 16) {
    {
    {
#line 851
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Bad file handle\n");
    }
    }
#line 852
    return (-1);
  }
#line 855
  if (samplenum < 0) {
    {
    {
#line 857
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Illegal sample number\n");
    }
    }
#line 858
    return (-1);
  } else
#line 855
  if (samplenum > 16383) {
    {
    {
#line 857
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_delete_sample(): Illegal sample number\n");
    }
    }
#line 858
    return (-1);
  }
  {
#line 861
  cmdblk1___8[6] = (unsigned char )(samplenum / 128);
#line 862
  cmdblk1___8[5] = (unsigned char )(samplenum - (int )cmdblk1___8[6] * 128);
  {
#line 864
  statuslen = sendrecv_scsimidi(handle, (char *)(cmdblk1___8), (unsigned int )sizeof(cmdblk1___8),
                                (char *)(statusbuf));
  }
  }
#line 866
  if (! (statuslen > 0)) {
    {
    {
#line 875
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 878
  return (0);
}
}
#line 887 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
long lakai_get_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) 
{ 
  int availbytes ;
  int stilltoget ;
  int getnow ;
  int ret ;
  unsigned char statusbuf[100] ;
  unsigned char *ptr ;
  unsigned char cmdblk1___74[18] ;
  long tmp ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 892
  cmdblk1___74[0] = (unsigned char)240;
#line 892
  cmdblk1___74[1] = (unsigned char)71;
#line 892
  cmdblk1___74[2] = (unsigned char)0;
#line 892
  cmdblk1___74[3] = (unsigned char)12;
#line 892
  cmdblk1___74[4] = (unsigned char)72;
#line 892
  cmdblk1___74[5] = (unsigned char)0;
#line 892
  cmdblk1___74[6] = (unsigned char)0;
#line 892
  cmdblk1___74[7] = (unsigned char)0;
#line 892
  cmdblk1___74[8] = (unsigned char)0;
#line 892
  cmdblk1___74[9] = (unsigned char)0;
#line 892
  cmdblk1___74[10] = (unsigned char)0;
#line 892
  cmdblk1___74[11] = (unsigned char)0;
#line 892
  cmdblk1___74[12] = (unsigned char)0;
#line 892
  cmdblk1___74[13] = (unsigned char)0;
#line 892
  cmdblk1___74[14] = (unsigned char)0;
#line 892
  cmdblk1___74[15] = (unsigned char)1;
#line 892
  cmdblk1___74[16] = (unsigned char)0;
#line 892
  cmdblk1___74[17] = (unsigned char)247;
#line 900
  if (fhandles[handle] == -1) {
    {
    {
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample: Bad file handle\n");
    }
    }
#line 903
    return (-1L);
  } else
#line 900
  if (handle < 0) {
    {
    {
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample: Bad file handle\n");
    }
    }
#line 903
    return (-1L);
  } else
#line 900
  if (handle > 16) {
    {
    {
#line 902
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_sample: Bad file handle\n");
    }
    }
#line 903
    return (-1L);
  }
  {
#line 907
  cmdblk1___74[5] = (unsigned char )(samplenum & 127);
#line 908
  cmdblk1___74[6] = (unsigned char )((samplenum >> 7) & 127);
#line 911
  cmdblk1___74[7] = (unsigned char )(locat & 127L);
#line 912
  cmdblk1___74[8] = (unsigned char )((locat >> 7) & 127L);
#line 913
  cmdblk1___74[9] = (unsigned char )((locat >> 14) & 127L);
#line 914
  cmdblk1___74[10] = (unsigned char )((locat >> 21) & 127L);
#line 916
  cmdblk1___74[11] = (unsigned char )(len & 127L);
#line 917
  cmdblk1___74[12] = (unsigned char )((len >> 7) & 127L);
#line 918
  cmdblk1___74[13] = (unsigned char )((len >> 14) & 127L);
#line 919
  cmdblk1___74[14] = (unsigned char )((len >> 21) & 127L);
  {
#line 921
  lakai_setmode(handle, 2);
  }
  {
#line 923
  availbytes = sendrecv_scsimidi2(handle, (char *)(cmdblk1___74), (unsigned int )sizeof(cmdblk1___74),
                                  (char *)(statusbuf));
  }
  }
#line 924
  if (! (availbytes > 0)) {
    {
    {
#line 932
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
  }
#line 935
  stilltoget = availbytes;
#line 936
  ptr = (unsigned char *)buffer;
  {
  {
#line 937
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 937
    if (! (stilltoget > 0)) {
#line 937
      goto while_break;
    }
#line 939
    if (stilltoget < 65534) {
#line 940
      getnow = stilltoget;
    } else {
#line 942
      getnow = 65534;
    }
    {
    {
#line 943
    tmp = getbulkdata(handle, getnow, (char *)ptr);
    }
#line 943
    ret = (int )tmp;
#line 947
    stilltoget -= getnow;
#line 948
    ptr += getnow;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 951
  lakai_setmode(handle, 0);
  }
  }
#line 953
  return (0L);
}
}
#line 965 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___9[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 960 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_get_miscdata(LHANDLE handle , unsigned char *data ) 
{ 
  unsigned char finalbuf[1024] ;
  int i ;
  int finallen ;
  int numvals ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 968
  if (fhandles[handle] == -1) {
    {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_get_miscata(): Bad file handle\n");
    }
    }
#line 971
    return (-1);
  } else
#line 968
  if (handle < 0) {
    {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_get_miscata(): Bad file handle\n");
    }
    }
#line 971
    return (-1);
  } else
#line 968
  if (handle > 16) {
    {
    {
#line 970
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_get_get_miscata(): Bad file handle\n");
    }
    }
#line 971
    return (-1);
  }
  {
  {
#line 974
  finallen = sendrecv_scsimidi(handle, (char *)(cmdblk1___9), (unsigned int )sizeof(cmdblk1___9),
                               (char *)(finalbuf));
  }
  }
#line 975
  if (finallen <= 0) {
    {
    {
#line 977
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Seems there were problems in receiving..\n");
    }
    }
#line 978
    return (-1);
  }
#line 986
  numvals = (finallen - 6) / 2;
#line 987
  i = 0;
  {
  {
#line 987
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 987
    if (! (i < numvals)) {
#line 987
      goto while_break;
    }
#line 989
    *(data + i) = (unsigned char )((int )finalbuf[5 + i * 2] | ((int )finalbuf[(5 + i * 2) + 1] << 4));
#line 987
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 997
  return (numvals);
}
}
#line 1011 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___10[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1005 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_put_program(LHANDLE handle , int prognum , unsigned char *data , int len ) 
{ 
  unsigned char finalbuf[1024] ;
  unsigned char resbuf[128] ;
  int i ;
  int finallen ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1017
  if (fhandles[handle] == -1) {
    {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Bad file handle\n");
    }
    }
#line 1020
    return (-1);
  } else
#line 1017
  if (handle < 0) {
    {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Bad file handle\n");
    }
    }
#line 1020
    return (-1);
  } else
#line 1017
  if (handle > 16) {
    {
    {
#line 1019
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Bad file handle\n");
    }
    }
#line 1020
    return (-1);
  }
#line 1023
  if (prognum < 0) {
    {
    {
#line 1025
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Illegal program number\n");
    }
    }
#line 1026
    return (-1);
  } else
#line 1023
  if (prognum > 16383) {
    {
    {
#line 1025
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Illegal program number\n");
    }
    }
#line 1026
    return (-1);
  }
  {
#line 1034
  cmdblk1___10[6] = (unsigned char )(prognum / 128);
#line 1035
  cmdblk1___10[5] = (unsigned char )(prognum - (int )cmdblk1___10[6] * 128);
  {
#line 1038
  memcpy((void */* __restrict  */)(finalbuf), (void const   */* __restrict  */)(cmdblk1___10),
         (size_t )sizeof(cmdblk1___10));
  }
#line 1040
  i = 0;
  }
  {
  {
#line 1040
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1040
    if (! (i < len)) {
#line 1040
      goto while_break;
    }
#line 1042
    finalbuf[sizeof(cmdblk1___10) + (unsigned long )(i * 2)] = (unsigned char )((int )*(data + i) & 15);
#line 1043
    finalbuf[(sizeof(cmdblk1___10) + (unsigned long )(i * 2)) + 1UL] = (unsigned char )(((int )*(data + i) & 240) >> 4);
#line 1040
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1045
  finalbuf[sizeof(cmdblk1___10) + (unsigned long )(2 * len)] = (unsigned char)247;
  {
#line 1052
  finallen = sendrecv_scsimidi(handle, (char *)(finalbuf), (unsigned int )((sizeof(cmdblk1___10) + (unsigned long )(len * 2)) + 1UL),
                               (char *)(resbuf));
  }
  }
#line 1053
  if (finallen <= 0) {
    {
    {
#line 1055
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_program(): Seems there were problems in receiving..\n");
    }
    }
#line 1056
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1082 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___11[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1076 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
int lakai_put_keygroup(LHANDLE handle , int prognum , int kgrpnum , unsigned char *data ,
                       int len ) 
{ 
  unsigned char finalbuf[1024] ;
  unsigned char resbuf[128] ;
  int i ;
  int finallen ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1090
  if (fhandles[handle] == -1) {
    {
    {
#line 1092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Bad file handle\n");
    }
    }
#line 1093
    return (-1);
  } else
#line 1090
  if (handle < 0) {
    {
    {
#line 1092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Bad file handle\n");
    }
    }
#line 1093
    return (-1);
  } else
#line 1090
  if (handle > 16) {
    {
    {
#line 1092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Bad file handle\n");
    }
    }
#line 1093
    return (-1);
  }
#line 1096
  if (prognum < 0) {
    {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Illegal program number\n");
    }
    }
#line 1099
    return (-1);
  } else
#line 1096
  if (prognum > 16383) {
    {
    {
#line 1098
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Illegal program number\n");
    }
    }
#line 1099
    return (-1);
  }
#line 1102
  if (kgrpnum > 255) {
    {
    {
#line 1104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Illegal keygroup number\n");
    }
    }
#line 1105
    return (-1);
  }
  {
#line 1113
  cmdblk1___11[6] = (unsigned char )(prognum / 128);
#line 1114
  cmdblk1___11[5] = (unsigned char )(prognum - (int )cmdblk1___11[6] * 128);
#line 1116
  cmdblk1___11[7] = (unsigned char )kgrpnum;
  {
#line 1119
  memcpy((void */* __restrict  */)(finalbuf), (void const   */* __restrict  */)(cmdblk1___11),
         (size_t )sizeof(cmdblk1___11));
  }
#line 1121
  i = 0;
  }
  {
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1121
    if (! (i < len)) {
#line 1121
      goto while_break;
    }
#line 1123
    finalbuf[sizeof(cmdblk1___11) + (unsigned long )(i * 2)] = (unsigned char )((int )*(data + i) & 15);
#line 1124
    finalbuf[(sizeof(cmdblk1___11) + (unsigned long )(i * 2)) + 1UL] = (unsigned char )(((int )*(data + i) & 240) >> 4);
#line 1121
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1126
  finalbuf[sizeof(cmdblk1___11) + (unsigned long )(2 * len)] = (unsigned char)247;
  {
#line 1133
  finallen = sendrecv_scsimidi(handle, (char *)(finalbuf), (unsigned int )((sizeof(cmdblk1___11) + (unsigned long )(len * 2)) + 1UL),
                               (char *)(resbuf));
  }
  }
#line 1134
  if (finallen <= 0) {
    {
    {
#line 1136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_keygroup(): Seems there were problems in receiving..\n");
    }
    }
#line 1137
    return (-1);
  }
#line 1139
  return (0);
}
}
#line 1150 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
long lakai_put_sample(LHANDLE handle , int samplenum , char *buffer , long locat ,
                      long len ) 
{ 
  int availbytes ;
  int stilltoput ;
  int putnow ;
  int ret ;
  unsigned char statusbuf[100] ;
  unsigned char *ptr ;
  int len_samples ;
  unsigned char cmdblk1___74[16] ;
  long tmp ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1155
  len_samples = (int )(len / 2L);
#line 1156
  cmdblk1___74[0] = (unsigned char)240;
#line 1156
  cmdblk1___74[1] = (unsigned char)71;
#line 1156
  cmdblk1___74[2] = (unsigned char)0;
#line 1156
  cmdblk1___74[3] = (unsigned char)13;
#line 1156
  cmdblk1___74[4] = (unsigned char)72;
#line 1156
  cmdblk1___74[5] = (unsigned char)0;
#line 1156
  cmdblk1___74[6] = (unsigned char)0;
#line 1156
  cmdblk1___74[7] = (unsigned char)0;
#line 1156
  cmdblk1___74[8] = (unsigned char)0;
#line 1156
  cmdblk1___74[9] = (unsigned char)0;
#line 1156
  cmdblk1___74[10] = (unsigned char)0;
#line 1156
  cmdblk1___74[11] = (unsigned char)0;
#line 1156
  cmdblk1___74[12] = (unsigned char)0;
#line 1156
  cmdblk1___74[13] = (unsigned char)0;
#line 1156
  cmdblk1___74[14] = (unsigned char)0;
#line 1156
  cmdblk1___74[15] = (unsigned char)247;
#line 1166
  if (fhandles[handle] == -1) {
    {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample: Bad file handle\n");
    }
    }
#line 1169
    return (-1L);
  } else
#line 1166
  if (handle < 0) {
    {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample: Bad file handle\n");
    }
    }
#line 1169
    return (-1L);
  } else
#line 1166
  if (handle > 16) {
    {
    {
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lakai_put_sample: Bad file handle\n");
    }
    }
#line 1169
    return (-1L);
  }
  {
#line 1173
  cmdblk1___74[5] = (unsigned char )(samplenum & 127);
#line 1174
  cmdblk1___74[6] = (unsigned char )((samplenum >> 7) & 127);
#line 1177
  cmdblk1___74[7] = (unsigned char )(locat & 127L);
#line 1178
  cmdblk1___74[8] = (unsigned char )((locat >> 7) & 127L);
#line 1179
  cmdblk1___74[9] = (unsigned char )((locat >> 14) & 127L);
#line 1180
  cmdblk1___74[10] = (unsigned char )((locat >> 21) & 127L);
#line 1182
  cmdblk1___74[11] = (unsigned char )(len_samples & 127);
#line 1183
  cmdblk1___74[12] = (unsigned char )((len_samples >> 7) & 127);
#line 1184
  cmdblk1___74[13] = (unsigned char )((len_samples >> 14) & 127);
#line 1185
  cmdblk1___74[14] = (unsigned char )((len_samples >> 21) & 127);
  {
#line 1188
  lakai_setmode(handle, 2);
  }
  {
#line 1190
  availbytes = sendrecv_scsimidi2(handle, (char *)(cmdblk1___74), (unsigned int )sizeof(cmdblk1___74),
                                  (char *)(statusbuf));
  }
  {
#line 1207
  usleep((__useconds_t )100000);
  }
#line 1209
  stilltoput = (int )len;
#line 1210
  ptr = (unsigned char *)buffer;
  }
  {
  {
#line 1211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1211
    if (! (stilltoput > 0)) {
#line 1211
      goto while_break;
    }
#line 1213
    if (stilltoput < 65534) {
#line 1214
      putnow = stilltoput;
    } else {
#line 1216
      putnow = 65534;
    }
    {
    {
#line 1217
    tmp = putbulkdata(handle, putnow, (char *)ptr);
    }
#line 1217
    ret = (int )tmp;
#line 1219
    stilltoput -= putnow;
#line 1220
    ptr += putnow;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1223
  lakai_setmode(handle, 0);
  }
  }
#line 1225
  return (0L);
}
}
#line 1235 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
void lakai_asciitoakai(char *src , char *dst , int len ) 
{ 
  int i ;
  unsigned char val_in ;
  unsigned char val_out ;

  {
#line 1239
  i = 0;
  {
  {
#line 1239
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1239
    if (! (i < len)) {
#line 1239
      goto while_break;
    }
#line 1241
    val_in = (unsigned char )*(src + i);
#line 1242
    if ((int )val_in >= 48) {
#line 1242
      if ((int )val_in <= 57) {
#line 1243
        val_out = (unsigned char )((int )val_in - 48);
      } else {
#line 1242
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1244
    if ((int )val_in >= 65) {
#line 1244
      if ((int )val_in <= 90) {
#line 1245
        val_out = (unsigned char )((int )val_in - 54);
      } else {
#line 1244
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1246
    if ((int )val_in >= 97) {
#line 1246
      if ((int )val_in <= 122) {
#line 1247
        val_out = (unsigned char )((int )val_in - 86);
      } else {
#line 1246
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1248
    if ((int )val_in == 35) {
#line 1249
      val_out = (unsigned char)37;
    } else
#line 1250
    if ((int )val_in == 43) {
#line 1251
      val_out = (unsigned char)38;
    } else
#line 1252
    if ((int )val_in == 45) {
#line 1253
      val_out = (unsigned char)39;
    } else
#line 1254
    if ((int )val_in == 46) {
#line 1255
      val_out = (unsigned char)40;
    } else {
#line 1257
      val_out = (unsigned char)38;
    }
#line 1259
    *(dst + i) = (char )val_out;
#line 1239
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1261
  return;
}
}
#line 1270 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
void lakai_akaitoascii(char *src , char *dst , int len ) 
{ 
  int i ;
  unsigned char val_in ;
  unsigned char val_out ;

  {
#line 1274
  i = 0;
  {
  {
#line 1274
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1274
    if (! (i < len)) {
#line 1274
      goto while_break;
    }
#line 1276
    val_in = (unsigned char )*(src + i);
#line 1277
    if ((int )val_in <= 9) {
#line 1278
      val_out = (unsigned char )((int )val_in + 48);
    } else
#line 1279
    if ((int )val_in >= 11) {
#line 1279
      if ((int )val_in <= 36) {
#line 1280
        val_out = (unsigned char )((int )val_in + 54);
      } else {
#line 1279
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1281
    if ((int )val_in == 37) {
#line 1282
      val_out = (unsigned char)35;
    } else
#line 1283
    if ((int )val_in == 38) {
#line 1284
      val_out = (unsigned char)43;
    } else
#line 1285
    if ((int )val_in == 39) {
#line 1286
      val_out = (unsigned char)45;
    } else
#line 1287
    if ((int )val_in == 40) {
#line 1288
      val_out = (unsigned char)46;
    } else {
#line 1290
      val_out = (unsigned char)32;
    }
#line 1292
    *(dst + i) = (char )val_out;
#line 1274
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1294
  return;
}
}
#line 1324 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int send_command(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                        int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, (size_t )sizeof(sg_io_hdr_t ));
  }
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___14;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
  {
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
  }
#line 1367
  if (tmp < 0) {
    {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
    }
    {
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
    }
    {
#line 1395
    hexprint(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static void hexprint(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;
  void *__cil_tmp5 ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
  {
#line 1411
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
      }
      {
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
      }
      {
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
      }
      {
#line 1419
      putchar((int )hexlist[(int )i & 15]);
      }
      {
#line 1420
      putchar(':');
      }
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
      {
#line 1423
      putchar(' ');
      }
      }
    }
    {
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
    }
    {
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
    }
    {
#line 1427
    putchar(' ');
    }
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
      {
#line 1430
      putchar('\n');
      }
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1432
  putchar('\n');
  }
  }
#line 1433
  return;
}
}
#line 1485 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___12[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk3[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                             char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1509
  if (fhandles[handle] == -1) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___12[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___12[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___12[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1526
  lakai_setmode(handle, 1);
  }
  {
#line 1533
  tmp = send_command(fhandles[handle], (char *)(cmdblk1___12), 1, (void *)sysexblk,
                     (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1533
  if (tmp < 0) {
    {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
    }
    {
#line 1536
    lakai_setmode(handle, 0);
    }
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
  {
#line 1543
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1546
    tmp___0 = send_command(fhandles[handle], (char *)(cmdblk2), 0, (void *)0, 0, (void *)(outbuf),
                           3);
    }
    }
#line 1546
    if (tmp___0 < 0) {
      {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
      }
      {
#line 1549
      lakai_setmode(handle, 0);
      }
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3[2] = outbuf[0];
#line 1562
      cmdblk3[3] = outbuf[1];
#line 1563
      cmdblk3[4] = outbuf[2];
      {
#line 1566
      tmp___1 = send_command(fhandles[handle], (char *)(cmdblk3), 0, (void *)0, 0,
                             (void *)(destbuf + currentlen), templen);
      }
      }
#line 1566
      if (tmp___1 < 0) {
        {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
        }
        {
#line 1570
        lakai_setmode(handle, 0);
        }
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1580
  lakai_setmode(handle, 0);
  }
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___13[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___0[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                              char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1610
  if (fhandles[handle] == -1) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___13[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___13[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___13[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1631
  tmp = send_command(fhandles[handle], (char *)(cmdblk1___13), 1, (void *)sysexblk,
                     (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1631
  if (tmp < 0) {
    {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
    }
    {
#line 1634
    lakai_setmode(handle, 0);
    }
    }
#line 1635
    return (-1);
  }
  {
  {
#line 1639
  tmp___0 = send_command(fhandles[handle], (char *)(cmdblk2___0), 0, (void *)0, 0,
                         (void *)(outbuf), 3);
  }
  }
#line 1639
  if (tmp___0 < 0) {
    {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
    }
    {
#line 1642
    lakai_setmode(handle, 0);
    }
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___0[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long getbulkdata(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1724
  if (fhandles[handle] == -1) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___0[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___0[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___0[5] = (unsigned char)128;
  {
#line 1741
  tmp = send_command(fhandles[handle], (char *)(cmdblk___0), 0, (void *)0, 0, (void *)buf,
                     numbytes);
  }
  }
#line 1741
  if (tmp < 0) {
    {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
    }
    {
#line 1744
    lakai_setmode(handle, 0);
    }
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___1[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long putbulkdata(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1778
  if (fhandles[handle] == -1) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___1[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___1[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___1[5] = (unsigned char)128;
  {
#line 1795
  tmp = send_command(fhandles[handle], (char *)(cmdblk___1), 1, (void *)buf, numbytes,
                     (void *)0, 0);
  }
  }
#line 1795
  if (tmp < 0) {
    {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
    }
    {
#line 1798
    lakai_setmode(handle, 0);
    }
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
#line 34 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int open_cnt___0  =    -1;
#line 35 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int fhandles___0[16]  ;
#line 38
static int send_command___0(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint___0(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) ;
#line 46
static long getbulkdata___0(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata___0(LHANDLE handle , int numbytes , char *buf ) ;
#line 175 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___2[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 234 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___14[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 274 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___15[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 360 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___16[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 452 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___17[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 550 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___18[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 621 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___19[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 693 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___20[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 747 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___21[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 792 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___22[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 846 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___23[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 965 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___24[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 1011 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___25[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1082 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___26[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1324 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int send_command___0(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, (size_t )sizeof(sg_io_hdr_t ));
  }
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___14;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
  {
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
  }
#line 1367
  if (tmp < 0) {
    {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
    }
    {
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
    }
    {
#line 1395
    hexprint___0(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static void hexprint___0(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;
  void *__cil_tmp5 ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
  {
#line 1411
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
      }
      {
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
      }
      {
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
      }
      {
#line 1419
      putchar((int )hexlist[(int )i & 15]);
      }
      {
#line 1420
      putchar(':');
      }
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
      {
#line 1423
      putchar(' ');
      }
      }
    }
    {
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
    }
    {
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
    }
    {
#line 1427
    putchar(' ');
    }
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
      {
#line 1430
      putchar('\n');
      }
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1432
  putchar('\n');
  }
  }
#line 1433
  return;
}
}
#line 1485 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___27[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___1[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk3___0[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1509
  if (fhandles___0[handle] == -1) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___27[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___27[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___27[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1526
  lakai_setmode(handle, 1);
  }
  {
#line 1533
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk1___27), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1533
  if (tmp < 0) {
    {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
    }
    {
#line 1536
    lakai_setmode(handle, 0);
    }
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
  {
#line 1543
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1546
    tmp___0 = send_command___0(fhandles___0[handle], (char *)(cmdblk2___1), 0, (void *)0,
                               0, (void *)(outbuf), 3);
    }
    }
#line 1546
    if (tmp___0 < 0) {
      {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
      }
      {
#line 1549
      lakai_setmode(handle, 0);
      }
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3___0[2] = outbuf[0];
#line 1562
      cmdblk3___0[3] = outbuf[1];
#line 1563
      cmdblk3___0[4] = outbuf[2];
      {
#line 1566
      tmp___1 = send_command___0(fhandles___0[handle], (char *)(cmdblk3___0), 0, (void *)0,
                                 0, (void *)(destbuf + currentlen), templen);
      }
      }
#line 1566
      if (tmp___1 < 0) {
        {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
        }
        {
#line 1570
        lakai_setmode(handle, 0);
        }
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1580
  lakai_setmode(handle, 0);
  }
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___28[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___2[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2___0(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1610
  if (fhandles___0[handle] == -1) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___28[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___28[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___28[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1631
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk1___28), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1631
  if (tmp < 0) {
    {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
    }
    {
#line 1634
    lakai_setmode(handle, 0);
    }
    }
#line 1635
    return (-1);
  }
  {
  {
#line 1639
  tmp___0 = send_command___0(fhandles___0[handle], (char *)(cmdblk2___2), 0, (void *)0,
                             0, (void *)(outbuf), 3);
  }
  }
#line 1639
  if (tmp___0 < 0) {
    {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
    }
    {
#line 1642
    lakai_setmode(handle, 0);
    }
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___3[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long getbulkdata___0(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1724
  if (fhandles___0[handle] == -1) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___3[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___3[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___3[5] = (unsigned char)128;
  {
#line 1741
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk___3), 0, (void *)0,
                         0, (void *)buf, numbytes);
  }
  }
#line 1741
  if (tmp < 0) {
    {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
    }
    {
#line 1744
    lakai_setmode(handle, 0);
    }
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___4[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long putbulkdata___0(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1778
  if (fhandles___0[handle] == -1) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___4[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___4[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___4[5] = (unsigned char)128;
  {
#line 1795
  tmp = send_command___0(fhandles___0[handle], (char *)(cmdblk___4), 1, (void *)buf,
                         numbytes, (void *)0, 0);
  }
  }
#line 1795
  if (tmp < 0) {
    {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
    }
    {
#line 1798
    lakai_setmode(handle, 0);
    }
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 25 "/home/wslee/benchmarks/sound/lakai-0.1/lakres.c"
int do_send_sample(LHANDLE hd1 , char *fname , int sample_idx ) ;
#line 26
int do_send_program(LHANDLE hd1 , char *fname , int prog_idx ) ;
#line 108 "/home/wslee/benchmarks/sound/lakai-0.1/lakres.c"
int do_send_sample(LHANDLE hd1 , char *fname , int sample_idx ) 
{ 
  FILE *fp1 ;
  int flen ;
  int res ;
  unsigned char *buf ;
  unsigned long slocat ;
  unsigned char hdrbuf[1024] ;
  long tmp ;
  void *tmp___0 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 118
  fp1 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
  }
#line 119
  if (! fp1) {
    {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"do_send_sample(): Could not open program file \'%s\'\n",
            fname);
    }
    }
#line 122
    return (0);
  }
  {
  {
#line 124
  fseek(fp1, 0L, 2);
  }
  {
#line 125
  tmp = ftell(fp1);
  }
#line 125
  flen = (int )tmp;
  {
#line 125
  fseek(fp1, 0L, 0);
  }
  {
#line 127
  tmp___0 = malloc((size_t )flen);
  }
#line 127
  buf = (unsigned char *)tmp___0;
  }
#line 128
  if (! buf) {
    {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"do_send_sample(): Unable to malloc sample buf\n");
    }
    {
#line 131
    fclose(fp1);
    }
    }
#line 132
    return (0);
  }
  {
  {
#line 135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Uploading sample #%d from file \'%s\', %d bytes...",
          sample_idx, fname, flen);
  }
  {
#line 136
  fread((void */* __restrict  */)buf, (size_t )flen, (size_t )1, (FILE */* __restrict  */)fp1);
  }
  {
#line 137
  fclose(fp1);
  }
  {
#line 143
  lakai_put_sample_header(hd1, 255, buf, 192);
  }
  {
#line 148
  res = lakai_get_sample_header(hd1, sample_idx, hdrbuf);
  }
#line 152
  slocat = (unsigned long )((((int )hdrbuf[25] * 16777216 + (int )hdrbuf[24] * 65536) + (int )hdrbuf[23] * 256) + (int )hdrbuf[22]);
  {
#line 164
  lakai_put_sample(hd1, sample_idx, (char *)(buf + 192), 0L, (long )(flen - 192));
  }
  {
#line 166
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done.\n");
  }
  {
#line 168
  free((void *)buf);
  }
  }
#line 169
  return (1);
}
}
#line 182 "/home/wslee/benchmarks/sound/lakai-0.1/lakres.c"
int do_send_program(LHANDLE hd1 , char *fname , int prog_idx ) 
{ 
  FILE *fp1 ;
  int i ;
  int flen ;
  int numkeygroups ;
  unsigned char *buf ;
  long tmp ;
  void *tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 188
  fp1 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
  }
#line 189
  if (! fp1) {
    {
    {
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"do_send_program(): Could not open program file \'%s\'\n",
            fname);
    }
    }
#line 192
    return (0);
  }
  {
  {
#line 194
  fseek(fp1, 0L, 2);
  }
  {
#line 195
  tmp = ftell(fp1);
  }
#line 195
  flen = (int )tmp;
  {
#line 195
  fseek(fp1, 0L, 0);
  }
  {
#line 197
  tmp___0 = malloc((size_t )flen);
  }
#line 197
  buf = (unsigned char *)tmp___0;
  }
#line 198
  if (! buf) {
    {
    {
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"do_send_program(): Unable to malloc program buf\n");
    }
    {
#line 201
    fclose(fp1);
    }
    }
#line 202
    return (0);
  }
  {
  {
#line 205
  fread((void */* __restrict  */)buf, (size_t )flen, (size_t )1, (FILE */* __restrict  */)fp1);
  }
  {
#line 206
  fclose(fp1);
  }
#line 208
  numkeygroups = (int )*(buf + 42);
  {
#line 209
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Uploading program #%d from file \'%s\', %d keygroup(s)...\n",
          prog_idx, fname, numkeygroups);
  }
#line 213
  *(buf + 42) = (unsigned char)1;
  {
#line 216
  lakai_put_program(hd1, 254, buf, 192);
  }
#line 221
  i = 0;
  }
  {
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < numkeygroups)) {
#line 221
      goto while_break;
    }
    {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tUploading keygroup %d..",
            i);
    }
    {
#line 226
    lakai_put_keygroup(hd1, prog_idx + 1, i, buf + (i + 1) * 192, 192);
    }
    {
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done.\n");
    }
#line 221
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 232
  free((void *)buf);
  }
  }
#line 234
  return (1);
}
}
#line 688 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 113 "/home/wslee/benchmarks/sound/lakai-0.1/lakbak.c"
extern int ( /* missing proto */  strlen)() ;
#line 121
extern int ( /* missing proto */  strcat)() ;
#line 34 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int open_cnt___1  =    -1;
#line 35 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int fhandles___1[16]  ;
#line 38
static int send_command___1(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint___1(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) ;
#line 46
static long getbulkdata___1(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata___1(LHANDLE handle , int numbytes , char *buf ) ;
#line 175 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___5[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 234 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___29[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 274 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___30[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 360 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___31[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 452 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___32[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 550 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___33[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 621 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___34[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 693 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___35[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 747 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___36[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 792 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___37[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 846 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___38[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 965 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___39[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 1011 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___40[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1082 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___41[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1324 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int send_command___1(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, (size_t )sizeof(sg_io_hdr_t ));
  }
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___14;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
  {
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
  }
#line 1367
  if (tmp < 0) {
    {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
    }
    {
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
    }
    {
#line 1395
    hexprint___1(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static void hexprint___1(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;
  void *__cil_tmp5 ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
  {
#line 1411
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
      }
      {
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
      }
      {
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
      }
      {
#line 1419
      putchar((int )hexlist[(int )i & 15]);
      }
      {
#line 1420
      putchar(':');
      }
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
      {
#line 1423
      putchar(' ');
      }
      }
    }
    {
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
    }
    {
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
    }
    {
#line 1427
    putchar(' ');
    }
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
      {
#line 1430
      putchar('\n');
      }
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1432
  putchar('\n');
  }
  }
#line 1433
  return;
}
}
#line 1485 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___42[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___3[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk3___1[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1509
  if (fhandles___1[handle] == -1) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___42[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___42[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___42[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1526
  lakai_setmode(handle, 1);
  }
  {
#line 1533
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk1___42), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1533
  if (tmp < 0) {
    {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
    }
    {
#line 1536
    lakai_setmode(handle, 0);
    }
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
  {
#line 1543
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1546
    tmp___0 = send_command___1(fhandles___1[handle], (char *)(cmdblk2___3), 0, (void *)0,
                               0, (void *)(outbuf), 3);
    }
    }
#line 1546
    if (tmp___0 < 0) {
      {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
      }
      {
#line 1549
      lakai_setmode(handle, 0);
      }
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3___1[2] = outbuf[0];
#line 1562
      cmdblk3___1[3] = outbuf[1];
#line 1563
      cmdblk3___1[4] = outbuf[2];
      {
#line 1566
      tmp___1 = send_command___1(fhandles___1[handle], (char *)(cmdblk3___1), 0, (void *)0,
                                 0, (void *)(destbuf + currentlen), templen);
      }
      }
#line 1566
      if (tmp___1 < 0) {
        {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
        }
        {
#line 1570
        lakai_setmode(handle, 0);
        }
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1580
  lakai_setmode(handle, 0);
  }
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___43[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___4[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2___1(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1610
  if (fhandles___1[handle] == -1) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___43[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___43[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___43[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1631
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk1___43), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1631
  if (tmp < 0) {
    {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
    }
    {
#line 1634
    lakai_setmode(handle, 0);
    }
    }
#line 1635
    return (-1);
  }
  {
  {
#line 1639
  tmp___0 = send_command___1(fhandles___1[handle], (char *)(cmdblk2___4), 0, (void *)0,
                             0, (void *)(outbuf), 3);
  }
  }
#line 1639
  if (tmp___0 < 0) {
    {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
    }
    {
#line 1642
    lakai_setmode(handle, 0);
    }
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___6[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long getbulkdata___1(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1724
  if (fhandles___1[handle] == -1) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___6[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___6[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___6[5] = (unsigned char)128;
  {
#line 1741
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk___6), 0, (void *)0,
                         0, (void *)buf, numbytes);
  }
  }
#line 1741
  if (tmp < 0) {
    {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
    }
    {
#line 1744
    lakai_setmode(handle, 0);
    }
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___7[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long putbulkdata___1(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1778
  if (fhandles___1[handle] == -1) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___7[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___7[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___7[5] = (unsigned char)128;
  {
#line 1795
  tmp = send_command___1(fhandles___1[handle], (char *)(cmdblk___7), 1, (void *)buf,
                         numbytes, (void *)0, 0);
  }
  }
#line 1795
  if (tmp < 0) {
    {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
    }
    {
#line 1798
    lakai_setmode(handle, 0);
    }
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
#line 34 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int open_cnt___2  =    -1;
#line 35 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int fhandles___2[16]  ;
#line 38
static int send_command___2(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint___2(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi___2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2___2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) ;
#line 46
static long getbulkdata___2(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata___2(LHANDLE handle , int numbytes , char *buf ) ;
#line 175 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___8[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 234 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___44[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 274 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___45[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 360 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___46[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 452 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___47[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 550 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___48[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 621 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___49[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 693 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___50[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 747 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___51[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 792 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___52[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 846 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___53[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 965 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___54[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 1011 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___55[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1082 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___56[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1324 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int send_command___2(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, (size_t )sizeof(sg_io_hdr_t ));
  }
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___14;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
  {
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
  }
#line 1367
  if (tmp < 0) {
    {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
    }
    {
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
    }
    {
#line 1395
    hexprint___2(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static void hexprint___2(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;
  void *__cil_tmp5 ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
  {
#line 1411
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
      }
      {
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
      }
      {
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
      }
      {
#line 1419
      putchar((int )hexlist[(int )i & 15]);
      }
      {
#line 1420
      putchar(':');
      }
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
      {
#line 1423
      putchar(' ');
      }
      }
    }
    {
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
    }
    {
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
    }
    {
#line 1427
    putchar(' ');
    }
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
      {
#line 1430
      putchar('\n');
      }
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1432
  putchar('\n');
  }
  }
#line 1433
  return;
}
}
#line 1485 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___57[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___5[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk3___2[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi___2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1509
  if (fhandles___2[handle] == -1) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___57[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___57[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___57[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1526
  lakai_setmode(handle, 1);
  }
  {
#line 1533
  tmp = send_command___2(fhandles___2[handle], (char *)(cmdblk1___57), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1533
  if (tmp < 0) {
    {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
    }
    {
#line 1536
    lakai_setmode(handle, 0);
    }
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
  {
#line 1543
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1546
    tmp___0 = send_command___2(fhandles___2[handle], (char *)(cmdblk2___5), 0, (void *)0,
                               0, (void *)(outbuf), 3);
    }
    }
#line 1546
    if (tmp___0 < 0) {
      {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
      }
      {
#line 1549
      lakai_setmode(handle, 0);
      }
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3___2[2] = outbuf[0];
#line 1562
      cmdblk3___2[3] = outbuf[1];
#line 1563
      cmdblk3___2[4] = outbuf[2];
      {
#line 1566
      tmp___1 = send_command___2(fhandles___2[handle], (char *)(cmdblk3___2), 0, (void *)0,
                                 0, (void *)(destbuf + currentlen), templen);
      }
      }
#line 1566
      if (tmp___1 < 0) {
        {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
        }
        {
#line 1570
        lakai_setmode(handle, 0);
        }
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1580
  lakai_setmode(handle, 0);
  }
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___58[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___6[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2___2(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1610
  if (fhandles___2[handle] == -1) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___58[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___58[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___58[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1631
  tmp = send_command___2(fhandles___2[handle], (char *)(cmdblk1___58), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1631
  if (tmp < 0) {
    {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
    }
    {
#line 1634
    lakai_setmode(handle, 0);
    }
    }
#line 1635
    return (-1);
  }
  {
  {
#line 1639
  tmp___0 = send_command___2(fhandles___2[handle], (char *)(cmdblk2___6), 0, (void *)0,
                             0, (void *)(outbuf), 3);
  }
  }
#line 1639
  if (tmp___0 < 0) {
    {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
    }
    {
#line 1642
    lakai_setmode(handle, 0);
    }
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___9[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long getbulkdata___2(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1724
  if (fhandles___2[handle] == -1) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___9[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___9[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___9[5] = (unsigned char)128;
  {
#line 1741
  tmp = send_command___2(fhandles___2[handle], (char *)(cmdblk___9), 0, (void *)0,
                         0, (void *)buf, numbytes);
  }
  }
#line 1741
  if (tmp < 0) {
    {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
    }
    {
#line 1744
    lakai_setmode(handle, 0);
    }
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___10[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long putbulkdata___2(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1778
  if (fhandles___2[handle] == -1) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___10[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___10[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___10[5] = (unsigned char)128;
  {
#line 1795
  tmp = send_command___2(fhandles___2[handle], (char *)(cmdblk___10), 1, (void *)buf,
                         numbytes, (void *)0, 0);
  }
  }
#line 1795
  if (tmp < 0) {
    {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
    }
    {
#line 1798
    lakai_setmode(handle, 0);
    }
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
#line 34 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int open_cnt___3  =    -1;
#line 35 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int fhandles___3[16]  ;
#line 38
static int send_command___3(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) ;
#line 41
static void hexprint___3(unsigned char *buf , int len ) ;
#line 43
static int sendrecv_scsimidi___3(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) ;
#line 44
static int sendrecv_scsimidi2___3(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) ;
#line 46
static long getbulkdata___3(LHANDLE handle , int numbytes , char *buf ) ;
#line 47
static long putbulkdata___3(LHANDLE handle , int numbytes , char *buf ) ;
#line 175 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___11[6]  = {      (unsigned char)9,      (unsigned char)0,      (unsigned char)1,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 234 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___59[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)72,      (unsigned char)247};
#line 274 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___60[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)2, 
        (unsigned char)72,      (unsigned char)247};
#line 360 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___61[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)4, 
        (unsigned char)72,      (unsigned char)247};
#line 452 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___62[8]  = 
#line 452
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)6, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 550 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___63[9]  = 
#line 550
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)8, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 621 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___64[8]  = 
#line 621
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)10, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 693 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___65[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)11, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 747 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___66[8]  = 
#line 747
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)18, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 792 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___67[9]  = 
#line 792
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)19, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)247};
#line 846 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___68[8]  = 
#line 846
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)20, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)247};
#line 965 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___69[6]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)16, 
        (unsigned char)72,      (unsigned char)247};
#line 1011 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___70[7]  = {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)7, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0};
#line 1082 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___71[8]  = 
#line 1082
  {      (unsigned char)240,      (unsigned char)71,      (unsigned char)0,      (unsigned char)9, 
        (unsigned char)72,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 1324 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int send_command___3(int sg_fd , char *cmdblk___14 , int dirflag , void *tosamp_ptr ,
                            int tosamp_len , void *fromsamp_ptr , int fromsamp_len ) 
{ 
  sg_io_hdr_t io_hdr ;
  unsigned char sense_buffer[32] ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1332
  memset((void *)(& io_hdr), 0, (size_t )sizeof(sg_io_hdr_t ));
  }
#line 1333
  io_hdr.interface_id = 'S';
#line 1334
  io_hdr.cmd_len = (unsigned char)6;
#line 1336
  io_hdr.mx_sb_len = (unsigned char )sizeof(sense_buffer);
  }
#line 1338
  if (dirflag == 0) {
#line 1341
    io_hdr.dxfer_direction = -3;
#line 1342
    io_hdr.dxfer_len = (unsigned int )fromsamp_len;
#line 1343
    io_hdr.dxferp = fromsamp_ptr;
  } else {
#line 1348
    io_hdr.dxfer_direction = -2;
#line 1349
    io_hdr.dxfer_len = (unsigned int )tosamp_len;
#line 1350
    io_hdr.dxferp = tosamp_ptr;
  }
  {
#line 1360
  io_hdr.cmdp = (unsigned char *)cmdblk___14;
#line 1361
  io_hdr.sbp = sense_buffer;
#line 1362
  io_hdr.timeout = 20000U;
  {
#line 1367
  tmp = ioctl(sg_fd, 8837UL, & io_hdr);
  }
  }
#line 1367
  if (tmp < 0) {
    {
    {
#line 1369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"send_command(): ioctl(SG_IO, ..) failed\n");
    }
    }
#line 1370
    return (-1);
  }
#line 1381
  if (! ((io_hdr.info & 1U) == 0U)) {
    {
    {
#line 1387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"### return code: NOT OK\n");
    }
    }
#line 1388
    return (-1);
  }
#line 1391
  if ((int )io_hdr.sb_len_wr > 0) {
    {
    {
#line 1393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Something (%d bytes) is in the sense buffer.\n",
            (int )io_hdr.sb_len_wr);
    }
    {
#line 1394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dump of sense buffer follows:\n");
    }
    {
#line 1395
    hexprint___3(io_hdr.sbp, (int )io_hdr.sb_len_wr);
    }
    }
#line 1396
    return (-1);
  }
#line 1399
  return (0);
}
}
#line 1406 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static void hexprint___3(unsigned char *buf , int len ) 
{ 
  unsigned char hexlist[17] ;
  unsigned short i ;
  void *__cil_tmp5 ;

  {
#line 1408
  hexlist[0] = (unsigned char )'0';
#line 1408
  hexlist[1] = (unsigned char )'1';
#line 1408
  hexlist[2] = (unsigned char )'2';
#line 1408
  hexlist[3] = (unsigned char )'3';
#line 1408
  hexlist[4] = (unsigned char )'4';
#line 1408
  hexlist[5] = (unsigned char )'5';
#line 1408
  hexlist[6] = (unsigned char )'6';
#line 1408
  hexlist[7] = (unsigned char )'7';
#line 1408
  hexlist[8] = (unsigned char )'8';
#line 1408
  hexlist[9] = (unsigned char )'9';
#line 1408
  hexlist[10] = (unsigned char )'A';
#line 1408
  hexlist[11] = (unsigned char )'B';
#line 1408
  hexlist[12] = (unsigned char )'C';
#line 1408
  hexlist[13] = (unsigned char )'D';
#line 1408
  hexlist[14] = (unsigned char )'E';
#line 1408
  hexlist[15] = (unsigned char )'F';
#line 1408
  hexlist[16] = (unsigned char )'\000';
#line 1411
  i = (unsigned short)0;
  {
  {
#line 1411
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1411
    if (! ((int )i < len)) {
#line 1411
      goto while_break;
    }
#line 1413
    if ((int )i % 16 == 0) {
      {
      {
#line 1416
      putchar((int )hexlist[((int )i >> 12) & 15]);
      }
      {
#line 1417
      putchar((int )hexlist[((int )i >> 8) & 15]);
      }
      {
#line 1418
      putchar((int )hexlist[((int )i >> 4) & 15]);
      }
      {
#line 1419
      putchar((int )hexlist[(int )i & 15]);
      }
      {
#line 1420
      putchar(':');
      }
      }
    }
#line 1422
    if ((int )i % 8 == 0) {
      {
      {
#line 1423
      putchar(' ');
      }
      }
    }
    {
    {
#line 1425
    putchar((int )hexlist[(int )*(buf + (int )i) >> 4]);
    }
    {
#line 1426
    putchar((int )hexlist[(int )*(buf + (int )i) & 15]);
    }
    {
#line 1427
    putchar(' ');
    }
    }
#line 1429
    if (((int )i + 1) % 16 == 0) {
      {
      {
#line 1430
      putchar('\n');
      }
      }
    }
#line 1411
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1432
  putchar('\n');
  }
  }
#line 1433
  return;
}
}
#line 1485 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___72[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1493 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___7[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1501 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk3___3[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1480 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi___3(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                 char *destbuf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int currentlen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1509
  if (fhandles___3[handle] == -1) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle < 0) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  } else
#line 1509
  if (handle > 16) {
    {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Bad file handle\n");
    }
    }
#line 1512
    return (-1);
  }
#line 1516
  if (sysexblksize > 65534U) {
    {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Error: SysEx msg too long\n!");
    }
    }
#line 1519
    return (-1);
  }
  {
#line 1522
  cmdblk1___72[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1523
  cmdblk1___72[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1524
  cmdblk1___72[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1526
  lakai_setmode(handle, 1);
  }
  {
#line 1533
  tmp = send_command___3(fhandles___3[handle], (char *)(cmdblk1___72), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1533
  if (tmp < 0) {
    {
    {
#line 1535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 1\n");
    }
    {
#line 1536
    lakai_setmode(handle, 0);
    }
    }
#line 1537
    return (-1);
  }
#line 1541
  currentlen = 0;
  {
  {
#line 1543
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1546
    tmp___0 = send_command___3(fhandles___3[handle], (char *)(cmdblk2___7), 0, (void *)0,
                               0, (void *)(outbuf), 3);
    }
    }
#line 1546
    if (tmp___0 < 0) {
      {
      {
#line 1548
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 2\n");
      }
      {
#line 1549
      lakai_setmode(handle, 0);
      }
      }
#line 1550
      return (-1);
    }
#line 1556
    templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1559
    if (templen > 0) {
      {
#line 1561
      cmdblk3___3[2] = outbuf[0];
#line 1562
      cmdblk3___3[3] = outbuf[1];
#line 1563
      cmdblk3___3[4] = outbuf[2];
      {
#line 1566
      tmp___1 = send_command___3(fhandles___3[handle], (char *)(cmdblk3___3), 0, (void *)0,
                                 0, (void *)(destbuf + currentlen), templen);
      }
      }
#line 1566
      if (tmp___1 < 0) {
        {
        {
#line 1569
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi: Problems in part 3\n");
        }
        {
#line 1570
        lakai_setmode(handle, 0);
        }
        }
#line 1571
        return (-1);
      }
#line 1574
      currentlen += templen;
    }
#line 1543
    if (! (templen > 0)) {
#line 1543
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1580
  lakai_setmode(handle, 0);
  }
  }
#line 1581
  return (currentlen);
}
}
#line 1594 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk1___73[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0};
#line 1602 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk2___8[6]  = {      (unsigned char)13,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)128};
#line 1589 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static int sendrecv_scsimidi2___3(LHANDLE handle , char *sysexblk , unsigned int sysexblksize ,
                                  char *buf ) 
{ 
  unsigned char outbuf[32] ;
  int templen ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1610
  if (fhandles___3[handle] == -1) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle < 0) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  } else
#line 1610
  if (handle > 16) {
    {
    {
#line 1612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Bad file handle\n");
    }
    }
#line 1613
    return (-1);
  }
#line 1616
  if (sysexblksize > 65534U) {
    {
    {
#line 1618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Error: SysEx msg too long\n!");
    }
    }
#line 1619
    return (-1);
  }
  {
#line 1623
  cmdblk1___73[4] = (unsigned char )((int )((unsigned char )sysexblksize) & 255);
#line 1624
  cmdblk1___73[3] = (unsigned char )((sysexblksize & 65280U) >> 8);
#line 1625
  cmdblk1___73[2] = (unsigned char )((sysexblksize & 16711680U) >> 16);
  {
#line 1631
  tmp = send_command___3(fhandles___3[handle], (char *)(cmdblk1___73), 1, (void *)sysexblk,
                         (int )sysexblksize, (void *)0, 0);
  }
  }
#line 1631
  if (tmp < 0) {
    {
    {
#line 1633
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 1\n");
    }
    {
#line 1634
    lakai_setmode(handle, 0);
    }
    }
#line 1635
    return (-1);
  }
  {
  {
#line 1639
  tmp___0 = send_command___3(fhandles___3[handle], (char *)(cmdblk2___8), 0, (void *)0,
                             0, (void *)(outbuf), 3);
  }
  }
#line 1639
  if (tmp___0 < 0) {
    {
    {
#line 1641
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sendrecv_scsimidi2: Problems in part 2\n");
    }
    {
#line 1642
    lakai_setmode(handle, 0);
    }
    }
#line 1643
    return (-1);
  }
#line 1647
  templen = (((int )outbuf[0] << 16) + ((int )outbuf[1] << 8)) + (int )outbuf[2];
#line 1651
  return (templen);
}
}
#line 1716 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___12[6]  = {      (unsigned char)14,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1714 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long getbulkdata___3(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1724
  if (fhandles___3[handle] == -1) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle < 0) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  } else
#line 1724
  if (handle > 16) {
    {
    {
#line 1726
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Bad file handle\n");
    }
    }
#line 1727
    return (-1L);
  }
#line 1730
  if (numbytes > 65536) {
    {
    {
#line 1732
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1733
    return (-1L);
  }
  {
#line 1737
  cmdblk___12[3] = (unsigned char )(numbytes >> 8);
#line 1738
  cmdblk___12[4] = (unsigned char )(numbytes & 255);
#line 1739
  cmdblk___12[5] = (unsigned char)128;
  {
#line 1741
  tmp = send_command___3(fhandles___3[handle], (char *)(cmdblk___12), 0, (void *)0,
                         0, (void *)buf, numbytes);
  }
  }
#line 1741
  if (tmp < 0) {
    {
    {
#line 1743
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getbulkdata: Problems in part 1\n");
    }
    {
#line 1744
    lakai_setmode(handle, 0);
    }
    }
#line 1745
    return (-1L);
  }
#line 1748
  return ((long )numbytes);
}
}
#line 1770 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static unsigned char cmdblk___13[6]  = {      (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0};
#line 1768 "/home/wslee/benchmarks/sound/lakai-0.1/lakai.c"
static long putbulkdata___3(LHANDLE handle , int numbytes , char *buf ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1778
  if (fhandles___3[handle] == -1) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle < 0) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  } else
#line 1778
  if (handle > 16) {
    {
    {
#line 1780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Bad file handle\n");
    }
    }
#line 1781
    return (-1L);
  }
#line 1784
  if (numbytes > 65536) {
    {
    {
#line 1786
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Error: numbytes too large\n!");
    }
    }
#line 1787
    return (-1L);
  }
  {
#line 1791
  cmdblk___13[3] = (unsigned char )(numbytes >> 8);
#line 1792
  cmdblk___13[4] = (unsigned char )(numbytes & 255);
#line 1793
  cmdblk___13[5] = (unsigned char)128;
  {
#line 1795
  tmp = send_command___3(fhandles___3[handle], (char *)(cmdblk___13), 1, (void *)buf,
                         numbytes, (void *)0, 0);
  }
  }
#line 1795
  if (tmp < 0) {
    {
    {
#line 1797
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"putbulkdata: Problems in part 1\n");
    }
    {
#line 1798
    lakai_setmode(handle, 0);
    }
    }
#line 1799
    return (-1L);
  }
#line 1804
  return ((long )numbytes);
}
}
