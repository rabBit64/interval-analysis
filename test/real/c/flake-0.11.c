/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 38 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.h"
enum WavSampleFormat {
    WAV_SAMPLE_FMT_UNKNOWN = -1,
    WAV_SAMPLE_FMT_U8 = 0,
    WAV_SAMPLE_FMT_S16 = 1,
    WAV_SAMPLE_FMT_S20 = 2,
    WAV_SAMPLE_FMT_S24 = 3,
    WAV_SAMPLE_FMT_S32 = 4,
    WAV_SAMPLE_FMT_FLT = 5,
    WAV_SAMPLE_FMT_DBL = 6
} ;
#line 49 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.h"
struct WavFile {
   FILE *fp ;
   uint32_t filepos ;
   int seekable ;
   uint32_t file_size ;
   uint32_t data_start ;
   uint32_t data_size ;
   uint32_t samples ;
   int format ;
   int channels ;
   uint32_t ch_mask ;
   int sample_rate ;
   int bytes_per_sec ;
   int block_align ;
   int bit_width ;
   enum WavSampleFormat source_format ;
   enum WavSampleFormat read_format ;
};
#line 49 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.h"
typedef struct WavFile WavFile;
#line 59 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 44 "/home/wslee/benchmarks/sound/flake-0.11/libflake/flake.h"
struct FlakeEncodeParams {
   int compression ;
   int order_method ;
   int stereo_method ;
   int block_size ;
   int block_time_ms ;
   int padding_size ;
   int max_frame_size ;
   int min_prediction_order ;
   int max_prediction_order ;
   int prediction_type ;
   int min_partition_order ;
   int max_partition_order ;
   int variable_block_size ;
};
#line 44 "/home/wslee/benchmarks/sound/flake-0.11/libflake/flake.h"
typedef struct FlakeEncodeParams FlakeEncodeParams;
#line 137 "/home/wslee/benchmarks/sound/flake-0.11/libflake/flake.h"
struct FlakeContext {
   int channels ;
   int sample_rate ;
   int bits_per_sample ;
   unsigned int samples ;
   FlakeEncodeParams params ;
   int max_frame_size ;
   unsigned char md5digest[16] ;
   unsigned char *header ;
   void *private_ctx ;
};
#line 137 "/home/wslee/benchmarks/sound/flake-0.11/libflake/flake.h"
typedef struct FlakeContext FlakeContext;
#line 34 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.h"
struct RiceContext {
   int porder ;
   int params[1 << 8] ;
   int esc_bps[1 << 8] ;
};
#line 34 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.h"
typedef struct RiceContext RiceContext;
#line 17 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.h"
struct __anonstruct_MD5Context_26 {
   uint32_t lo ;
   uint32_t hi ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
   uint32_t d ;
   uint8_t buffer[64] ;
   uint32_t block[16] ;
};
#line 17 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.h"
typedef struct __anonstruct_MD5Context_26 MD5Context;
#line 48 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
struct BitWriter;
#line 50 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
struct FlacSubframe {
   int type ;
   int type_code ;
   int order ;
   int obits ;
   int32_t coefs[32] ;
   int shift ;
   int32_t samples[65535] ;
   int32_t residual[65535] ;
   RiceContext rc ;
};
#line 50 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
typedef struct FlacSubframe FlacSubframe;
#line 62 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
struct FlacFrame {
   int blocksize ;
   int bs_code[2] ;
   int ch_mode ;
   int ch_order[2] ;
   uint8_t crc8 ;
   FlacSubframe subframes[8] ;
};
#line 62 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
typedef struct FlacFrame FlacFrame;
#line 71 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
struct FlacEncodeContext {
   int channels ;
   int ch_code ;
   int samplerate ;
   int sr_code[2] ;
   int bps ;
   int bps_code ;
   uint32_t sample_count ;
   FlakeEncodeParams params ;
   int max_frame_size ;
   int lpc_precision ;
   uint32_t frame_count ;
   FlacFrame frame ;
   MD5Context md5ctx ;
   struct BitWriter *bw ;
};
#line 71 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
typedef struct FlacEncodeContext FlacEncodeContext;
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
struct BitWriter {
   uint32_t bit_buf ;
   int bit_left ;
   uint8_t *buffer ;
   uint8_t *buf_ptr ;
   uint8_t *buf_end ;
   int eof ;
};
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
typedef struct BitWriter BitWriter;
#line 198 "/usr/include/sys/types.h"
typedef long int64_t;
#line 92 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
struct FilePair {
   char *infile ;
   char *outfile ;
   FILE *ifp ;
   FILE *ofp ;
};
#line 92 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
typedef struct FilePair FilePair;
#line 99 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
struct CommandOptions {
   FilePair *filelist ;
   int input_count ;
   int found_output ;
   int compr ;
   int omethod ;
   int ptype ;
   int omin ;
   int omax ;
   int pomin ;
   int pomax ;
   int bsize ;
   int stmethod ;
   int padding ;
   int vbs ;
   int quiet ;
};
#line 99 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
typedef struct CommandOptions CommandOptions;
#line 268 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
struct WavInfo {
   char *fname ;
   WavFile wf ;
};
#line 268 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
typedef struct WavInfo WavInfo;
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 68 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.h"
int wavfile_init(WavFile *wf , FILE *fp ) ;
#line 70
int wavfile_read_samples(WavFile *wf , void *output , int num_samples ) ;
#line 72
int wavfile_seek_samples(WavFile *wf , int32_t offset , int whence ) ;
#line 74
int wavfile_seek_time_ms(WavFile *wf , int32_t offset , int whence ) ;
#line 76
int wavfile_position(WavFile *wf ) ;
#line 78
void wavfile_print(FILE *st , WavFile *wf ) ;
#line 35 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
__inline static uint32_t read4le(FILE *fp ) 
{ 
  uint32_t x ;

  {
  {
  {
#line 39
  fread((void */* __restrict  */)(& x), (size_t )4, (size_t )1, (FILE */* __restrict  */)fp);
  }
  }
#line 40
  return (x);
}
}
#line 43 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
__inline static uint16_t read2le(FILE *fp ) 
{ 
  uint16_t x ;

  {
  {
  {
#line 47
  fread((void */* __restrict  */)(& x), (size_t )2, (size_t )1, (FILE */* __restrict  */)fp);
  }
  }
#line 48
  return (x);
}
}
#line 51 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
int wavfile_init(WavFile *wf , FILE *fp ) 
{ 
  int id ;
  int chunksize ;
  int found_fmt ;
  int found_data ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  uint32_t tmp___8 ;
  uint16_t tmp___9 ;
  uint16_t tmp___10 ;
  uint16_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 56
  if ((unsigned long )wf == (unsigned long )((void *)0)) {
#line 56
    return (-1);
  } else
#line 56
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 56
    return (-1);
  }
  {
  {
#line 58
  memset((void *)wf, 0, (size_t )sizeof(WavFile ));
  }
#line 59
  wf->fp = fp;
#line 62
  wf->file_size = (uint32_t )0;
  {
#line 63
  tmp = fseek(fp, 0L, 2);
  }
  }
#line 63
  if (tmp) {
#line 63
    tmp___0 = 0;
  } else {
#line 63
    tmp___0 = 1;
  }
#line 63
  wf->seekable = tmp___0;
#line 64
  if (wf->seekable) {
    {
    {
#line 65
    tmp___1 = ftell(fp);
    }
#line 65
    wf->file_size = (uint32_t )tmp___1;
    {
#line 66
    fseek(fp, 0L, 0);
    }
    }
  }
  {
#line 69
  wf->filepos = (uint32_t )0;
  {
#line 70
  tmp___2 = read4le(fp);
  }
#line 70
  id = (int )tmp___2;
#line 71
  wf->filepos += 4U;
  }
#line 72
  if (id != 1179011410) {
#line 72
    return (-1);
  }
  {
  {
#line 73
  read4le(fp);
  }
#line 74
  wf->filepos += 4U;
  {
#line 75
  tmp___3 = read4le(fp);
  }
#line 75
  id = (int )tmp___3;
#line 76
  wf->filepos += 4U;
  }
#line 77
  if (id != 1163280727) {
#line 77
    return (-1);
  }
#line 78
  found_fmt = 0;
#line 78
  found_data = found_fmt;
  {
  {
#line 79
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 79
    if (! (! found_data)) {
#line 79
      goto while_break;
    }
    {
    {
#line 80
    tmp___4 = read4le(fp);
    }
#line 80
    id = (int )tmp___4;
#line 81
    wf->filepos += 4U;
    {
#line 82
    tmp___5 = read4le(fp);
    }
#line 82
    chunksize = (int )tmp___5;
#line 83
    wf->filepos += 4U;
    }
#line 84
    if (id == 0) {
#line 84
      return (-1);
    } else
#line 84
    if (chunksize == 0) {
#line 84
      return (-1);
    }
    {
#line 86
    if (id == 544501094) {
#line 86
      goto case_544501094;
    }
#line 134
    if (id == 1635017060) {
#line 134
      goto case_1635017060;
    }
#line 141
    goto switch_default;
    case_544501094: /* CIL Label */ 
#line 87
    if (chunksize < 16) {
#line 87
      return (-1);
    }
    {
    {
#line 88
    tmp___6 = read2le(fp);
    }
#line 88
    wf->format = (int )tmp___6;
    {
#line 89
    tmp___7 = read2le(fp);
    }
#line 89
    wf->channels = (int )tmp___7;
    {
#line 90
    tmp___8 = read4le(fp);
    }
#line 90
    wf->sample_rate = (int )tmp___8;
    {
#line 91
    read4le(fp);
    }
    {
#line 92
    tmp___9 = read2le(fp);
    }
#line 92
    wf->block_align = (int )tmp___9;
    {
#line 93
    tmp___10 = read2le(fp);
    }
#line 93
    wf->bit_width = (int )tmp___10;
#line 94
    wf->filepos += 16U;
    }
#line 95
    if (! wf->channels) {
#line 96
      return (-1);
    } else
#line 95
    if (! wf->sample_rate) {
#line 96
      return (-1);
    } else
#line 95
    if (! wf->block_align) {
#line 96
      return (-1);
    } else
#line 95
    if (! wf->bit_width) {
#line 96
      return (-1);
    }
#line 98
    chunksize -= 16;
#line 101
    wf->ch_mask = (uint32_t )0;
#line 102
    if (wf->format == 65534) {
#line 102
      if (chunksize >= 10) {
        {
        {
#line 103
        read4le(fp);
        }
        {
#line 104
        wf->ch_mask = read4le(fp);
        }
        {
#line 105
        tmp___11 = read2le(fp);
        }
#line 105
        wf->format = (int )tmp___11;
#line 106
        wf->filepos += 10U;
#line 107
        chunksize -= 10;
        }
      }
    }
#line 110
    if (wf->format == 1) {
#line 111
      wf->block_align = ((wf->bit_width + 7) >> 3) * wf->channels;
    } else
#line 110
    if (wf->format == 3) {
#line 111
      wf->block_align = ((wf->bit_width + 7) >> 3) * wf->channels;
    }
#line 117
    if (wf->ch_mask == 0U) {
      {
#line 119
      if (wf->channels == 1) {
#line 119
        goto case_1;
      }
#line 120
      if (wf->channels == 2) {
#line 120
        goto case_2;
      }
#line 121
      if (wf->channels == 3) {
#line 121
        goto case_3;
      }
#line 122
      if (wf->channels == 4) {
#line 122
        goto case_4;
      }
#line 123
      if (wf->channels == 5) {
#line 123
        goto case_5;
      }
#line 124
      if (wf->channels == 6) {
#line 124
        goto case_6;
      }
#line 118
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 119
      wf->ch_mask = (uint32_t )4;
#line 119
      goto switch_break___0;
      case_2: /* CIL Label */ 
#line 120
      wf->ch_mask = (uint32_t )3;
#line 120
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 121
      wf->ch_mask = (uint32_t )7;
#line 121
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 122
      wf->ch_mask = (uint32_t )263;
#line 122
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 123
      wf->ch_mask = (uint32_t )55;
#line 123
      goto switch_break___0;
      case_6: /* CIL Label */ 
#line 124
      wf->ch_mask = (uint32_t )63;
#line 124
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 128
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 128
      tmp___12 = chunksize;
#line 128
      chunksize --;
#line 128
      if (! (tmp___12 > 0)) {
#line 128
        goto while_break___0;
      }
      {
      {
#line 129
      fgetc(fp);
      }
#line 130
      (wf->filepos) ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    found_fmt = 1;
#line 133
    goto switch_break;
    case_1635017060: /* CIL Label */ 
#line 135
    if (! found_fmt) {
#line 135
      return (-1);
    }
#line 136
    wf->data_size = (uint32_t )chunksize;
#line 137
    wf->data_start = wf->filepos;
#line 138
    wf->samples = wf->data_size / (uint32_t )wf->block_align;
#line 139
    found_data = 1;
#line 140
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 142
    if (wf->seekable) {
      {
      {
#line 143
      fseek(fp, (long )chunksize, 1);
      }
      }
    } else {
      {
      {
#line 145
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 145
        tmp___13 = chunksize;
#line 145
        chunksize --;
#line 145
        if (! (tmp___13 > 0)) {
#line 145
          goto while_break___1;
        }
        {
        {
#line 146
        fgetc(fp);
        }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 149
    wf->filepos += (uint32_t )chunksize;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  wf->source_format = (enum WavSampleFormat )-1;
#line 154
  wf->read_format = wf->source_format;
#line 155
  if (wf->format == 1) {
#line 155
    goto _L;
  } else
#line 155
  if (wf->format == 3) {
    _L: /* CIL Label */ 
    {
#line 157
    if (wf->bit_width == 8) {
#line 157
      goto case_8;
    }
#line 158
    if (wf->bit_width == 16) {
#line 158
      goto case_16;
    }
#line 159
    if (wf->bit_width == 20) {
#line 159
      goto case_20;
    }
#line 160
    if (wf->bit_width == 24) {
#line 160
      goto case_24;
    }
#line 161
    if (wf->bit_width == 32) {
#line 161
      goto case_32;
    }
#line 168
    if (wf->bit_width == 64) {
#line 168
      goto case_64;
    }
#line 156
    goto switch_break___1;
    case_8: /* CIL Label */ 
#line 157
    wf->source_format = (enum WavSampleFormat )0;
#line 157
    goto switch_break___1;
    case_16: /* CIL Label */ 
#line 158
    wf->source_format = (enum WavSampleFormat )1;
#line 158
    goto switch_break___1;
    case_20: /* CIL Label */ 
#line 159
    wf->source_format = (enum WavSampleFormat )2;
#line 159
    goto switch_break___1;
    case_24: /* CIL Label */ 
#line 160
    wf->source_format = (enum WavSampleFormat )3;
#line 160
    goto switch_break___1;
    case_32: /* CIL Label */ 
#line 162
    if (wf->format == 3) {
#line 163
      wf->source_format = (enum WavSampleFormat )5;
    } else
#line 164
    if (wf->format == 1) {
#line 165
      wf->source_format = (enum WavSampleFormat )4;
    }
#line 167
    goto switch_break___1;
    case_64: /* CIL Label */ 
#line 169
    if (wf->format == 3) {
#line 170
      wf->source_format = (enum WavSampleFormat )6;
    }
#line 172
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 176
  return (0);
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_u8(uint8_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  int16_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 184
  if ((int )fmt == 0) {
    {
    {
#line 185
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )n);
    }
    }
  } else
#line 186
  if ((int )fmt == 1) {
#line 187
    src = (int16_t *)src_v;
#line 188
    i = 0;
    {
    {
#line 188
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < n)) {
#line 188
        goto while_break;
      }
#line 189
      *(dest + i) = (uint8_t )(((int )*(src + i) >> 8) + 128);
#line 188
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 191
  if ((int )fmt == 2) {
#line 192
    src___0 = (int32_t *)src_v;
#line 193
    i = 0;
    {
    {
#line 193
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (i < n)) {
#line 193
        goto while_break___0;
      }
#line 194
      *(dest + i) = (uint8_t )((*(src___0 + i) >> 12) + 128);
#line 193
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 196
  if ((int )fmt == 3) {
#line 197
    src___1 = (int32_t *)src_v;
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (i < n)) {
#line 198
        goto while_break___1;
      }
#line 199
      *(dest + i) = (uint8_t )((*(src___1 + i) >> 16) + 128);
#line 198
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 201
  if ((int )fmt == 4) {
#line 202
    src___2 = (int32_t *)src_v;
#line 203
    i = 0;
    {
    {
#line 203
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 203
      if (! (i < n)) {
#line 203
        goto while_break___2;
      }
#line 204
      *(dest + i) = (uint8_t )((*(src___2 + i) >> 24) + 128);
#line 203
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 206
  if ((int )fmt == 5) {
#line 207
    src___3 = (float *)src_v;
#line 208
    i = 0;
    {
    {
#line 208
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 208
      if (! (i < n)) {
#line 208
        goto while_break___3;
      }
#line 209
      if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
        tmp___1 = (float )255;
      } else {
#line 209
        tmp___1 = *(src___3 + i) * (float )128 + (float )128;
      }
#line 209
      if (tmp___1 > (float )0) {
#line 209
        if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
          tmp___0 = (float )255;
        } else {
#line 209
          tmp___0 = *(src___3 + i) * (float )128 + (float )128;
        }
#line 209
        v = (int )tmp___0;
      } else {
#line 209
        v = 0;
      }
#line 210
      *(dest + i) = (uint8_t )v;
#line 208
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 212
  if ((int )fmt == 6) {
#line 213
    src___4 = (double *)src_v;
#line 214
    i = 0;
    {
    {
#line 214
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 214
      if (! (i < n)) {
#line 214
        goto while_break___4;
      }
#line 215
      if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
        tmp___4 = (double )255;
      } else {
#line 215
        tmp___4 = *(src___4 + i) * (double )128 + (double )128;
      }
#line 215
      if (tmp___4 > (double )0) {
#line 215
        if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
          tmp___3 = (double )255;
        } else {
#line 215
          tmp___3 = *(src___4 + i) * (double )128 + (double )128;
        }
#line 215
        v = (int )tmp___3;
      } else {
#line 215
        v = 0;
      }
#line 216
      *(dest + i) = (uint8_t )v;
#line 214
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 219
  return;
}
}
#line 221 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s16(int16_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 226
  if ((int )fmt == 0) {
#line 227
    src = (uint8_t *)src_v;
#line 228
    i = 0;
    {
    {
#line 228
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n)) {
#line 228
        goto while_break;
      }
#line 229
      *(dest + i) = (int16_t )(((int )*(src + i) - 128) << 8);
#line 228
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 231
  if ((int )fmt == 1) {
    {
    {
#line 232
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int16_t )));
    }
    }
  } else
#line 233
  if ((int )fmt == 2) {
#line 234
    src___0 = (int32_t *)src_v;
#line 235
    i = 0;
    {
    {
#line 235
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (i < n)) {
#line 235
        goto while_break___0;
      }
#line 236
      *(dest + i) = (int16_t )(*(src___0 + i) >> 4);
#line 235
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 238
  if ((int )fmt == 3) {
#line 239
    src___1 = (int32_t *)src_v;
#line 240
    i = 0;
    {
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 240
      if (! (i < n)) {
#line 240
        goto while_break___1;
      }
#line 241
      *(dest + i) = (int16_t )(*(src___1 + i) >> 8);
#line 240
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 243
  if ((int )fmt == 4) {
#line 244
    src___2 = (int32_t *)src_v;
#line 245
    i = 0;
    {
    {
#line 245
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___2;
      }
#line 246
      *(dest + i) = (int16_t )(*(src___2 + i) >> 16);
#line 245
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 248
  if ((int )fmt == 5) {
#line 249
    src___3 = (float *)src_v;
#line 250
    i = 0;
    {
    {
#line 250
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 250
      if (! (i < n)) {
#line 250
        goto while_break___3;
      }
#line 251
      if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
        tmp___1 = (float )32767;
      } else {
#line 251
        tmp___1 = *(src___3 + i) * (float )32768;
      }
#line 251
      if (tmp___1 > (float )-32768) {
#line 251
        if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
          tmp___0 = (float )32767;
        } else {
#line 251
          tmp___0 = *(src___3 + i) * (float )32768;
        }
#line 251
        v = (int )tmp___0;
      } else {
#line 251
        v = -32768;
      }
#line 252
      *(dest + i) = (int16_t )v;
#line 250
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 254
  if ((int )fmt == 6) {
#line 255
    src___4 = (double *)src_v;
#line 256
    i = 0;
    {
    {
#line 256
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 256
      if (! (i < n)) {
#line 256
        goto while_break___4;
      }
#line 257
      if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
        tmp___4 = (double )32767;
      } else {
#line 257
        tmp___4 = *(src___4 + i) * (double )32768;
      }
#line 257
      if (tmp___4 > (double )-32768) {
#line 257
        if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
          tmp___3 = (double )32767;
        } else {
#line 257
          tmp___3 = *(src___4 + i) * (double )32768;
        }
#line 257
        v = (int )tmp___3;
      } else {
#line 257
        v = -32768;
      }
#line 258
      *(dest + i) = (int16_t )v;
#line 256
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s20(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 268
  if ((int )fmt == 0) {
#line 269
    src = (uint8_t *)src_v;
#line 270
    i = 0;
    {
    {
#line 270
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 270
      if (! (i < n)) {
#line 270
        goto while_break;
      }
#line 271
      *(dest + i) = ((int )*(src + i) - 128) << 12;
#line 270
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 273
  if ((int )fmt == 1) {
#line 274
    src___0 = (int16_t *)src_v;
#line 275
    i = 0;
    {
    {
#line 275
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! (i < n)) {
#line 275
        goto while_break___0;
      }
#line 276
      *(dest + i) = (int )*(src___0 + i) << 4;
#line 275
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 278
  if ((int )fmt == 2) {
    {
    {
#line 279
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 280
  if ((int )fmt == 3) {
#line 281
    src___1 = (int32_t *)src_v;
#line 282
    i = 0;
    {
    {
#line 282
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (i < n)) {
#line 282
        goto while_break___1;
      }
#line 283
      *(dest + i) = *(src___1 + i) >> 4;
#line 282
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 285
  if ((int )fmt == 4) {
#line 286
    src___2 = (int32_t *)src_v;
#line 287
    i = 0;
    {
    {
#line 287
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 287
      if (! (i < n)) {
#line 287
        goto while_break___2;
      }
#line 288
      *(dest + i) = *(src___2 + i) >> 12;
#line 287
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 290
  if ((int )fmt == 5) {
#line 291
    src___3 = (float *)src_v;
#line 292
    i = 0;
    {
    {
#line 292
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 292
      if (! (i < n)) {
#line 292
        goto while_break___3;
      }
#line 293
      if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
        tmp___1 = (float )524287;
      } else {
#line 293
        tmp___1 = *(src___3 + i) * (float )524288;
      }
#line 293
      if (tmp___1 > (float )-524288) {
#line 293
        if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
          tmp___0 = (float )524287;
        } else {
#line 293
          tmp___0 = *(src___3 + i) * (float )524288;
        }
#line 293
        v = (int )tmp___0;
      } else {
#line 293
        v = -524288;
      }
#line 294
      *(dest + i) = v;
#line 292
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 296
  if ((int )fmt == 6) {
#line 297
    src___4 = (double *)src_v;
#line 298
    i = 0;
    {
    {
#line 298
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 298
      if (! (i < n)) {
#line 298
        goto while_break___4;
      }
#line 299
      if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
        tmp___4 = (double )524287;
      } else {
#line 299
        tmp___4 = *(src___4 + i) * (double )524288;
      }
#line 299
      if (tmp___4 > (double )-524288) {
#line 299
        if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
          tmp___3 = (double )524287;
        } else {
#line 299
          tmp___3 = *(src___4 + i) * (double )524288;
        }
#line 299
        v = (int )tmp___3;
      } else {
#line 299
        v = -524288;
      }
#line 300
      *(dest + i) = v;
#line 298
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s24(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 310
  if ((int )fmt == 0) {
#line 311
    src = (uint8_t *)src_v;
#line 312
    i = 0;
    {
    {
#line 312
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 312
      if (! (i < n)) {
#line 312
        goto while_break;
      }
#line 313
      *(dest + i) = ((int )*(src + i) - 128) << 16;
#line 312
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 315
  if ((int )fmt == 1) {
#line 316
    src___0 = (int16_t *)src_v;
#line 317
    i = 0;
    {
    {
#line 317
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! (i < n)) {
#line 317
        goto while_break___0;
      }
#line 318
      *(dest + i) = (int )*(src___0 + i) << 8;
#line 317
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 320
  if ((int )fmt == 2) {
#line 321
    src___1 = (int32_t *)src_v;
#line 322
    i = 0;
    {
    {
#line 322
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (i < n)) {
#line 322
        goto while_break___1;
      }
#line 323
      *(dest + i) = *(src___1 + i) << 4;
#line 322
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 325
  if ((int )fmt == 3) {
    {
    {
#line 326
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 327
  if ((int )fmt == 4) {
#line 328
    src___2 = (int32_t *)src_v;
#line 329
    i = 0;
    {
    {
#line 329
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (i < n)) {
#line 329
        goto while_break___2;
      }
#line 330
      *(dest + i) = *(src___2 + i) >> 8;
#line 329
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 332
  if ((int )fmt == 5) {
#line 333
    src___3 = (float *)src_v;
#line 334
    i = 0;
    {
    {
#line 334
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 334
      if (! (i < n)) {
#line 334
        goto while_break___3;
      }
#line 335
      if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
        tmp___1 = (float )8388607;
      } else {
#line 335
        tmp___1 = *(src___3 + i) * (float )8388608;
      }
#line 335
      if (tmp___1 > (float )-8388608) {
#line 335
        if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
          tmp___0 = (float )8388607;
        } else {
#line 335
          tmp___0 = *(src___3 + i) * (float )8388608;
        }
#line 335
        v = (int )tmp___0;
      } else {
#line 335
        v = -8388608;
      }
#line 336
      *(dest + i) = v;
#line 334
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 338
  if ((int )fmt == 6) {
#line 339
    src___4 = (double *)src_v;
#line 340
    i = 0;
    {
    {
#line 340
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 340
      if (! (i < n)) {
#line 340
        goto while_break___4;
      }
#line 341
      if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
        tmp___4 = (double )8388607;
      } else {
#line 341
        tmp___4 = *(src___4 + i) * (double )8388608;
      }
#line 341
      if (tmp___4 > (double )-8388608) {
#line 341
        if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
          tmp___3 = (double )8388607;
        } else {
#line 341
          tmp___3 = *(src___4 + i) * (double )8388608;
        }
#line 341
        v = (int )tmp___3;
      } else {
#line 341
        v = -8388608;
      }
#line 342
      *(dest + i) = v;
#line 340
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 345
  return;
}
}
#line 347 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s32(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  double *src___4 ;

  {
#line 352
  if ((int )fmt == 0) {
#line 353
    src = (uint8_t *)src_v;
#line 354
    i = 0;
    {
    {
#line 354
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 354
      if (! (i < n)) {
#line 354
        goto while_break;
      }
#line 355
      *(dest + i) = ((int )*(src + i) - 128) << 24;
#line 354
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 357
  if ((int )fmt == 1) {
#line 358
    src___0 = (int16_t *)src_v;
#line 359
    i = 0;
    {
    {
#line 359
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (i < n)) {
#line 359
        goto while_break___0;
      }
#line 360
      *(dest + i) = (int )*(src___0 + i) << 16;
#line 359
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 362
  if ((int )fmt == 2) {
#line 363
    src___1 = (int32_t *)src_v;
#line 364
    i = 0;
    {
    {
#line 364
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (i < n)) {
#line 364
        goto while_break___1;
      }
#line 365
      *(dest + i) = *(src___1 + i) << 12;
#line 364
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 367
  if ((int )fmt == 3) {
#line 368
    src___2 = (int32_t *)src_v;
#line 369
    i = 0;
    {
    {
#line 369
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 369
      if (! (i < n)) {
#line 369
        goto while_break___2;
      }
#line 370
      *(dest + i) = *(src___2 + i) << 8;
#line 369
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 372
  if ((int )fmt == 4) {
    {
    {
#line 373
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 374
  if ((int )fmt == 5) {
#line 375
    src___3 = (float *)src_v;
#line 376
    i = 0;
    {
    {
#line 376
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 376
      if (! (i < n)) {
#line 376
        goto while_break___3;
      }
#line 377
      v = (int )(*(src___3 + i) * (float )2147483648LL);
#line 378
      *(dest + i) = v;
#line 376
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 380
  if ((int )fmt == 6) {
#line 381
    src___4 = (double *)src_v;
#line 382
    i = 0;
    {
    {
#line 382
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 382
      if (! (i < n)) {
#line 382
        goto while_break___4;
      }
#line 383
      v = (int )(*(src___4 + i) * (double )2147483648LL);
#line 384
      *(dest + i) = v;
#line 382
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_float(float *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  double *src___4 ;

  {
#line 394
  if ((int )fmt == 0) {
#line 395
    src = (uint8_t *)src_v;
#line 396
    i = 0;
    {
    {
#line 396
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 396
      if (! (i < n)) {
#line 396
        goto while_break;
      }
#line 397
      *(dest + i) = (float )(((double )*(src + i) - 128.0) / 128.0);
#line 396
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 399
  if ((int )fmt == 1) {
#line 400
    src___0 = (int16_t *)src_v;
#line 401
    i = 0;
    {
    {
#line 401
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (i < n)) {
#line 401
        goto while_break___0;
      }
#line 402
      *(dest + i) = (float )((double )*(src___0 + i) / 32768.0);
#line 401
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 404
  if ((int )fmt == 2) {
#line 405
    src___1 = (int32_t *)src_v;
#line 406
    i = 0;
    {
    {
#line 406
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 406
      if (! (i < n)) {
#line 406
        goto while_break___1;
      }
#line 407
      *(dest + i) = (float )((double )*(src___1 + i) / 524288.0);
#line 406
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 409
  if ((int )fmt == 3) {
#line 410
    src___2 = (int32_t *)src_v;
#line 411
    i = 0;
    {
    {
#line 411
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 411
      if (! (i < n)) {
#line 411
        goto while_break___2;
      }
#line 412
      *(dest + i) = (float )((double )*(src___2 + i) / 8388608.0);
#line 411
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 414
  if ((int )fmt == 4) {
#line 415
    src___3 = (int32_t *)src_v;
#line 416
    i = 0;
    {
    {
#line 416
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 416
      if (! (i < n)) {
#line 416
        goto while_break___3;
      }
#line 417
      *(dest + i) = (float )((double )*(src___3 + i) / 2147483648.0);
#line 416
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 419
  if ((int )fmt == 5) {
    {
    {
#line 420
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(float )));
    }
    }
  } else
#line 421
  if ((int )fmt == 6) {
#line 422
    src___4 = (double *)src_v;
#line 423
    i = 0;
    {
    {
#line 423
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 423
      if (! (i < n)) {
#line 423
        goto while_break___4;
      }
#line 424
      *(dest + i) = (float )*(src___4 + i);
#line 423
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_double(double *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  float *src___4 ;

  {
#line 434
  if ((int )fmt == 0) {
#line 435
    src = (uint8_t *)src_v;
#line 436
    i = 0;
    {
    {
#line 436
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 436
      if (! (i < n)) {
#line 436
        goto while_break;
      }
#line 437
      *(dest + i) = ((double )*(src + i) - 128.0) / 128.0;
#line 436
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 439
  if ((int )fmt == 1) {
#line 440
    src___0 = (int16_t *)src_v;
#line 441
    i = 0;
    {
    {
#line 441
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 441
      if (! (i < n)) {
#line 441
        goto while_break___0;
      }
#line 442
      *(dest + i) = (double )*(src___0 + i) / 32768.0;
#line 441
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 444
  if ((int )fmt == 2) {
#line 445
    src___1 = (int32_t *)src_v;
#line 446
    i = 0;
    {
    {
#line 446
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 446
      if (! (i < n)) {
#line 446
        goto while_break___1;
      }
#line 447
      *(dest + i) = (double )*(src___1 + i) / 524288.0;
#line 446
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 449
  if ((int )fmt == 3) {
#line 450
    src___2 = (int32_t *)src_v;
#line 451
    i = 0;
    {
    {
#line 451
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 451
      if (! (i < n)) {
#line 451
        goto while_break___2;
      }
#line 452
      *(dest + i) = (double )*(src___2 + i) / 8388608.0;
#line 451
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 454
  if ((int )fmt == 4) {
#line 455
    src___3 = (int32_t *)src_v;
#line 456
    i = 0;
    {
    {
#line 456
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 456
      if (! (i < n)) {
#line 456
        goto while_break___3;
      }
#line 457
      *(dest + i) = (double )*(src___3 + i) / 2147483648.0;
#line 456
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 459
  if ((int )fmt == 5) {
#line 460
    src___4 = (float *)src_v;
#line 461
    i = 0;
    {
    {
#line 461
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 461
      if (! (i < n)) {
#line 461
        goto while_break___4;
      }
#line 462
      *(dest + i) = (double )*(src___4 + i);
#line 461
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 464
  if ((int )fmt == 6) {
    {
    {
#line 465
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(double )));
    }
    }
  }
#line 467
  return;
}
}
#line 469 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert(enum WavSampleFormat dest_fmt , void *dest , enum WavSampleFormat src_fmt ,
                        void *src , int n ) 
{ 


  {
  {
#line 474
  if ((int )dest_fmt == 0) {
#line 474
    goto case_0;
  }
#line 477
  if ((int )dest_fmt == 1) {
#line 477
    goto case_1;
  }
#line 480
  if ((int )dest_fmt == 2) {
#line 480
    goto case_2;
  }
#line 483
  if ((int )dest_fmt == 3) {
#line 483
    goto case_3;
  }
#line 486
  if ((int )dest_fmt == 4) {
#line 486
    goto case_4;
  }
#line 489
  if ((int )dest_fmt == 5) {
#line 489
    goto case_5;
  }
#line 492
  if ((int )dest_fmt == 6) {
#line 492
    goto case_6;
  }
#line 473
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 475
  fmt_convert_to_u8((uint8_t *)dest, src, n, src_fmt);
  }
  }
#line 476
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 478
  fmt_convert_to_s16((int16_t *)dest, src, n, src_fmt);
  }
  }
#line 479
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 481
  fmt_convert_to_s20((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 484
  fmt_convert_to_s24((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 485
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 487
  fmt_convert_to_s32((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 488
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 490
  fmt_convert_to_float((float *)dest, src, n, src_fmt);
  }
  }
#line 491
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  {
#line 493
  fmt_convert_to_double((double *)dest, src, n, src_fmt);
  }
  }
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 498 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
int wavfile_read_samples(WavFile *wf , void *output , int num_samples ) 
{ 
  int nr ;
  int i ;
  int j ;
  int bps ;
  int nsmp ;
  int v ;
  int convert ;
  int read_size ;
  uint8_t *buffer ;
  void *tmp ;
  size_t tmp___0 ;
  int32_t *input ;
  void *tmp___1 ;
  char *__cil_tmp17 ;

  {
#line 502
  convert = 1;
#line 506
  if ((unsigned long )wf == (unsigned long )((void *)0)) {
#line 506
    return (-1);
  } else
#line 506
  if ((unsigned long )wf->fp == (unsigned long )((void *)0)) {
#line 506
    return (-1);
  } else
#line 506
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 506
    return (-1);
  }
#line 507
  if (wf->block_align <= 0) {
#line 507
    return (-1);
  }
#line 509
  read_size = wf->block_align * num_samples;
#line 510
  if (wf->filepos + (uint32_t )read_size >= wf->data_start + wf->data_size) {
#line 511
    read_size = (int )((wf->data_start + wf->data_size) - wf->filepos);
#line 512
    num_samples = read_size / wf->block_align;
  }
#line 514
  if (num_samples < 0) {
#line 514
    return (-1);
  }
#line 515
  if (num_samples == 0) {
#line 515
    return (0);
  }
#line 517
  convert = (int )wf->read_format != (int )wf->source_format;
#line 518
  if (convert) {
    {
    {
#line 519
    tmp = calloc((size_t )read_size, (size_t )1);
    }
#line 519
    buffer = (uint8_t *)tmp;
    }
  } else {
#line 521
    buffer = (uint8_t *)output;
  }
  {
  {
#line 524
  tmp___0 = fread((void */* __restrict  */)buffer, (size_t )wf->block_align, (size_t )num_samples,
                  (FILE */* __restrict  */)wf->fp);
  }
#line 524
  nr = (int )tmp___0;
#line 525
  wf->filepos += (uint32_t )(nr * wf->block_align);
#line 526
  nsmp = nr * wf->channels;
#line 528
  bps = wf->block_align / wf->channels;
  }
#line 529
  if (bps == 1) {
#line 530
    if ((int )wf->source_format != 0) {
#line 530
      return (-1);
    }
#line 531
    if (convert) {
      {
      {
#line 532
      fmt_convert(wf->read_format, output, wf->source_format, (void *)buffer, nsmp);
      }
      }
    }
  } else
#line 534
  if (bps == 2) {
#line 541
    if ((int )wf->source_format != 1) {
#line 541
      return (-1);
    }
#line 542
    if (convert) {
      {
      {
#line 543
      fmt_convert(wf->read_format, output, wf->source_format, (void *)((int16_t *)buffer),
                  nsmp);
      }
      }
    }
  } else
#line 545
  if (bps == 3) {
    {
    {
#line 546
    tmp___1 = calloc((size_t )nsmp, (size_t )sizeof(int32_t ));
    }
#line 546
    input = (int32_t *)tmp___1;
#line 547
    i = 0;
#line 547
    j = 0;
    }
    {
    {
#line 547
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 547
      if (! (i < nsmp * bps)) {
#line 547
        goto while_break;
      }
#line 548
      v = ((int )*(buffer + i) + ((int )*(buffer + (i + 1)) << 8)) + ((int )*(buffer + (i + 2)) << 16);
#line 549
      if (wf->bit_width == 20) {
#line 550
        if (v >= 1 << 19) {
#line 550
          v -= 1 << 20;
        }
      } else
#line 551
      if (wf->bit_width == 24) {
#line 552
        if (v >= 1 << 23) {
#line 552
          v -= 1 << 24;
        }
      } else {
        {
        {
#line 554
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unsupported bit width: %d\n",
                wf->bit_width);
        }
        }
#line 555
        return (-1);
      }
#line 557
      *(input + j) = v;
#line 547
      i += bps;
#line 547
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 559
    if ((int )wf->source_format != 2) {
#line 559
      if ((int )wf->source_format != 3) {
#line 561
        return (-1);
      }
    }
#line 563
    if (convert) {
      {
      {
#line 564
      fmt_convert(wf->read_format, output, wf->source_format, (void *)input, nsmp);
      }
      }
    }
    {
    {
#line 566
    free((void *)input);
    }
    }
  } else
#line 567
  if (bps == 4) {
#line 574
    if (wf->format == 3) {
#line 575
      if ((int )wf->source_format != 5) {
#line 575
        return (-1);
      }
#line 576
      if (convert) {
        {
        {
#line 577
        fmt_convert(wf->read_format, output, wf->source_format, (void *)((float *)buffer),
                    nsmp);
        }
        }
      }
    } else {
#line 580
      if ((int )wf->source_format != 4) {
#line 580
        return (-1);
      }
#line 581
      if (convert) {
        {
        {
#line 582
        fmt_convert(wf->read_format, output, wf->source_format, (void *)((int32_t *)buffer),
                    nsmp);
        }
        }
      }
    }
  } else
#line 585
  if (wf->format == 3) {
#line 585
    if (bps == 8) {
#line 592
      if ((int )wf->source_format != 6) {
#line 592
        return (-1);
      }
#line 593
      if (convert) {
        {
        {
#line 594
        fmt_convert(wf->read_format, output, wf->source_format, (void *)((double *)buffer),
                    nsmp);
        }
        }
      }
    }
  }
#line 597
  if (convert) {
    {
    {
#line 598
    free((void *)buffer);
    }
    }
  }
#line 601
  return (nr);
}
}
#line 604 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
int wavfile_seek_samples(WavFile *wf , int32_t offset , int whence ) 
{ 
  int byte_offset ;
  int pos ;
  int cur ;
  int tmp ;

  {
#line 609
  if ((unsigned long )wf == (unsigned long )((void *)0)) {
#line 609
    return (-1);
  } else
#line 609
  if ((unsigned long )wf->fp == (unsigned long )((void *)0)) {
#line 609
    return (-1);
  }
#line 610
  if (wf->block_align <= 0) {
#line 610
    return (-1);
  }
#line 611
  if (wf->data_start == 0U) {
#line 611
    return (-1);
  } else
#line 611
  if (wf->data_size == 0U) {
#line 611
    return (-1);
  }
#line 612
  byte_offset = offset * wf->block_align;
#line 613
  pos = (int )wf->data_start;
  {
#line 615
  if (whence == 0) {
#line 615
    goto case_0;
  }
#line 618
  if (whence == 1) {
#line 618
    goto case_1;
  }
#line 626
  if (whence == 2) {
#line 626
    goto case_2;
  }
#line 629
  goto switch_default;
  case_0: /* CIL Label */ 
#line 616
  pos = (int )(wf->data_start + (uint32_t )byte_offset);
#line 617
  goto switch_break;
  case_1: /* CIL Label */ 
#line 619
  cur = (int )wf->filepos;
  {
  {
#line 620
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 620
    if (! ((uint32_t )cur < wf->data_start)) {
#line 620
      goto while_break;
    }
    {
    {
#line 621
    fgetc(wf->fp);
    }
#line 622
    cur ++;
#line 623
    (wf->filepos) ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  pos = cur + byte_offset;
  case_2: /* CIL Label */ 
#line 627
  pos = (int )((wf->data_start + wf->data_size) - (uint32_t )byte_offset);
#line 628
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 629
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 631
  if ((uint32_t )pos < wf->data_start) {
#line 632
    pos = 0;
  }
#line 634
  if ((uint32_t )pos >= wf->data_start + wf->data_size) {
#line 635
    pos = (int )((wf->data_start + wf->data_size) - 1U);
  }
#line 637
  if (! wf->seekable) {
#line 638
    if ((uint32_t )pos < wf->filepos) {
#line 638
      return (-1);
    }
    {
    {
#line 639
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 639
      if (! (wf->filepos < (uint32_t )pos)) {
#line 639
        goto while_break___0;
      }
      {
      {
#line 640
      fgetc(wf->fp);
      }
#line 641
      (wf->filepos) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 644
    tmp = fseek(wf->fp, (long )pos, 0);
    }
    }
#line 644
    if (tmp) {
#line 644
      return (-1);
    }
  }
#line 646
  return (0);
}
}
#line 649 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
int wavfile_seek_time_ms(WavFile *wf , int32_t offset , int whence ) 
{ 
  int32_t samples ;
  int tmp ;

  {
#line 653
  if ((unsigned long )wf == (unsigned long )((void *)0)) {
#line 653
    return (-1);
  } else
#line 653
  if (wf->sample_rate == 0) {
#line 653
    return (-1);
  }
  {
#line 654
  samples = (offset * wf->sample_rate) / 1000;
  {
#line 655
  tmp = wavfile_seek_samples(wf, samples, whence);
  }
  }
#line 655
  return (tmp);
}
}
#line 658 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
int wavfile_position(WavFile *wf ) 
{ 
  int cur ;

  {
#line 663
  if ((unsigned long )wf == (unsigned long )((void *)0)) {
#line 663
    return (0);
  }
#line 664
  if (wf->data_start == 0U) {
#line 664
    return (0);
  } else
#line 664
  if (wf->data_size == 0U) {
#line 664
    return (0);
  }
#line 666
  cur = (int )((wf->filepos - wf->data_start) / (uint32_t )wf->block_align);
#line 667
  if (cur <= 0) {
#line 667
    return (0);
  }
#line 668
  cur /= wf->block_align;
#line 669
  return (cur);
}
}
#line 672 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
void wavfile_print(FILE *st , WavFile *wf ) 
{ 
  char *type ;
  char *chan ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 676
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 676
    return;
  } else
#line 676
  if ((unsigned long )wf == (unsigned long )((void *)0)) {
#line 676
    return;
  }
#line 677
  if (wf->format == 1) {
#line 678
    if (wf->bit_width > 8) {
#line 678
      type = (char *)"Signed";
    } else {
#line 679
      type = (char *)"Unsigned";
    }
  } else
#line 680
  if (wf->format == 3) {
#line 681
    type = (char *)"Floating-point";
  } else {
#line 683
    type = (char *)"[unsupported type]";
  }
  {
#line 686
  if (wf->channels == 1) {
#line 686
    goto case_1;
  }
#line 687
  if (wf->channels == 2) {
#line 687
    goto case_2;
  }
#line 688
  if (wf->channels == 3) {
#line 688
    goto case_3;
  }
#line 689
  if (wf->channels == 4) {
#line 689
    goto case_4;
  }
#line 690
  if (wf->channels == 5) {
#line 690
    goto case_5;
  }
#line 691
  if (wf->channels == 6) {
#line 691
    goto case_6;
  }
#line 692
  goto switch_default;
  case_1: /* CIL Label */ 
#line 686
  chan = (char *)"mono";
#line 686
  goto switch_break;
  case_2: /* CIL Label */ 
#line 687
  chan = (char *)"stereo";
#line 687
  goto switch_break;
  case_3: /* CIL Label */ 
#line 688
  chan = (char *)"3-channel";
#line 688
  goto switch_break;
  case_4: /* CIL Label */ 
#line 689
  chan = (char *)"4-channel";
#line 689
  goto switch_break;
  case_5: /* CIL Label */ 
#line 690
  chan = (char *)"5-channel";
#line 690
  goto switch_break;
  case_6: /* CIL Label */ 
#line 691
  chan = (char *)"6-channel";
#line 691
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 692
  chan = (char *)"multi-channel";
#line 692
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 694
  fprintf((FILE */* __restrict  */)st, (char const   */* __restrict  */)"%s %d-bit %d Hz %s\n",
          type, wf->bit_width, wf->sample_rate, chan);
  }
  }
#line 696
  return;
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_u8___0(uint8_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  int16_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 184
  if ((int )fmt == 0) {
    {
    {
#line 185
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )n);
    }
    }
  } else
#line 186
  if ((int )fmt == 1) {
#line 187
    src = (int16_t *)src_v;
#line 188
    i = 0;
    {
    {
#line 188
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < n)) {
#line 188
        goto while_break;
      }
#line 189
      *(dest + i) = (uint8_t )(((int )*(src + i) >> 8) + 128);
#line 188
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 191
  if ((int )fmt == 2) {
#line 192
    src___0 = (int32_t *)src_v;
#line 193
    i = 0;
    {
    {
#line 193
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (i < n)) {
#line 193
        goto while_break___0;
      }
#line 194
      *(dest + i) = (uint8_t )((*(src___0 + i) >> 12) + 128);
#line 193
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 196
  if ((int )fmt == 3) {
#line 197
    src___1 = (int32_t *)src_v;
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (i < n)) {
#line 198
        goto while_break___1;
      }
#line 199
      *(dest + i) = (uint8_t )((*(src___1 + i) >> 16) + 128);
#line 198
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 201
  if ((int )fmt == 4) {
#line 202
    src___2 = (int32_t *)src_v;
#line 203
    i = 0;
    {
    {
#line 203
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 203
      if (! (i < n)) {
#line 203
        goto while_break___2;
      }
#line 204
      *(dest + i) = (uint8_t )((*(src___2 + i) >> 24) + 128);
#line 203
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 206
  if ((int )fmt == 5) {
#line 207
    src___3 = (float *)src_v;
#line 208
    i = 0;
    {
    {
#line 208
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 208
      if (! (i < n)) {
#line 208
        goto while_break___3;
      }
#line 209
      if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
        tmp___1 = (float )255;
      } else {
#line 209
        tmp___1 = *(src___3 + i) * (float )128 + (float )128;
      }
#line 209
      if (tmp___1 > (float )0) {
#line 209
        if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
          tmp___0 = (float )255;
        } else {
#line 209
          tmp___0 = *(src___3 + i) * (float )128 + (float )128;
        }
#line 209
        v = (int )tmp___0;
      } else {
#line 209
        v = 0;
      }
#line 210
      *(dest + i) = (uint8_t )v;
#line 208
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 212
  if ((int )fmt == 6) {
#line 213
    src___4 = (double *)src_v;
#line 214
    i = 0;
    {
    {
#line 214
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 214
      if (! (i < n)) {
#line 214
        goto while_break___4;
      }
#line 215
      if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
        tmp___4 = (double )255;
      } else {
#line 215
        tmp___4 = *(src___4 + i) * (double )128 + (double )128;
      }
#line 215
      if (tmp___4 > (double )0) {
#line 215
        if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
          tmp___3 = (double )255;
        } else {
#line 215
          tmp___3 = *(src___4 + i) * (double )128 + (double )128;
        }
#line 215
        v = (int )tmp___3;
      } else {
#line 215
        v = 0;
      }
#line 216
      *(dest + i) = (uint8_t )v;
#line 214
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 219
  return;
}
}
#line 221 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s16___0(int16_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 226
  if ((int )fmt == 0) {
#line 227
    src = (uint8_t *)src_v;
#line 228
    i = 0;
    {
    {
#line 228
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n)) {
#line 228
        goto while_break;
      }
#line 229
      *(dest + i) = (int16_t )(((int )*(src + i) - 128) << 8);
#line 228
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 231
  if ((int )fmt == 1) {
    {
    {
#line 232
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int16_t )));
    }
    }
  } else
#line 233
  if ((int )fmt == 2) {
#line 234
    src___0 = (int32_t *)src_v;
#line 235
    i = 0;
    {
    {
#line 235
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (i < n)) {
#line 235
        goto while_break___0;
      }
#line 236
      *(dest + i) = (int16_t )(*(src___0 + i) >> 4);
#line 235
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 238
  if ((int )fmt == 3) {
#line 239
    src___1 = (int32_t *)src_v;
#line 240
    i = 0;
    {
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 240
      if (! (i < n)) {
#line 240
        goto while_break___1;
      }
#line 241
      *(dest + i) = (int16_t )(*(src___1 + i) >> 8);
#line 240
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 243
  if ((int )fmt == 4) {
#line 244
    src___2 = (int32_t *)src_v;
#line 245
    i = 0;
    {
    {
#line 245
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___2;
      }
#line 246
      *(dest + i) = (int16_t )(*(src___2 + i) >> 16);
#line 245
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 248
  if ((int )fmt == 5) {
#line 249
    src___3 = (float *)src_v;
#line 250
    i = 0;
    {
    {
#line 250
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 250
      if (! (i < n)) {
#line 250
        goto while_break___3;
      }
#line 251
      if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
        tmp___1 = (float )32767;
      } else {
#line 251
        tmp___1 = *(src___3 + i) * (float )32768;
      }
#line 251
      if (tmp___1 > (float )-32768) {
#line 251
        if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
          tmp___0 = (float )32767;
        } else {
#line 251
          tmp___0 = *(src___3 + i) * (float )32768;
        }
#line 251
        v = (int )tmp___0;
      } else {
#line 251
        v = -32768;
      }
#line 252
      *(dest + i) = (int16_t )v;
#line 250
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 254
  if ((int )fmt == 6) {
#line 255
    src___4 = (double *)src_v;
#line 256
    i = 0;
    {
    {
#line 256
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 256
      if (! (i < n)) {
#line 256
        goto while_break___4;
      }
#line 257
      if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
        tmp___4 = (double )32767;
      } else {
#line 257
        tmp___4 = *(src___4 + i) * (double )32768;
      }
#line 257
      if (tmp___4 > (double )-32768) {
#line 257
        if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
          tmp___3 = (double )32767;
        } else {
#line 257
          tmp___3 = *(src___4 + i) * (double )32768;
        }
#line 257
        v = (int )tmp___3;
      } else {
#line 257
        v = -32768;
      }
#line 258
      *(dest + i) = (int16_t )v;
#line 256
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s20___0(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 268
  if ((int )fmt == 0) {
#line 269
    src = (uint8_t *)src_v;
#line 270
    i = 0;
    {
    {
#line 270
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 270
      if (! (i < n)) {
#line 270
        goto while_break;
      }
#line 271
      *(dest + i) = ((int )*(src + i) - 128) << 12;
#line 270
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 273
  if ((int )fmt == 1) {
#line 274
    src___0 = (int16_t *)src_v;
#line 275
    i = 0;
    {
    {
#line 275
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! (i < n)) {
#line 275
        goto while_break___0;
      }
#line 276
      *(dest + i) = (int )*(src___0 + i) << 4;
#line 275
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 278
  if ((int )fmt == 2) {
    {
    {
#line 279
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 280
  if ((int )fmt == 3) {
#line 281
    src___1 = (int32_t *)src_v;
#line 282
    i = 0;
    {
    {
#line 282
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (i < n)) {
#line 282
        goto while_break___1;
      }
#line 283
      *(dest + i) = *(src___1 + i) >> 4;
#line 282
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 285
  if ((int )fmt == 4) {
#line 286
    src___2 = (int32_t *)src_v;
#line 287
    i = 0;
    {
    {
#line 287
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 287
      if (! (i < n)) {
#line 287
        goto while_break___2;
      }
#line 288
      *(dest + i) = *(src___2 + i) >> 12;
#line 287
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 290
  if ((int )fmt == 5) {
#line 291
    src___3 = (float *)src_v;
#line 292
    i = 0;
    {
    {
#line 292
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 292
      if (! (i < n)) {
#line 292
        goto while_break___3;
      }
#line 293
      if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
        tmp___1 = (float )524287;
      } else {
#line 293
        tmp___1 = *(src___3 + i) * (float )524288;
      }
#line 293
      if (tmp___1 > (float )-524288) {
#line 293
        if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
          tmp___0 = (float )524287;
        } else {
#line 293
          tmp___0 = *(src___3 + i) * (float )524288;
        }
#line 293
        v = (int )tmp___0;
      } else {
#line 293
        v = -524288;
      }
#line 294
      *(dest + i) = v;
#line 292
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 296
  if ((int )fmt == 6) {
#line 297
    src___4 = (double *)src_v;
#line 298
    i = 0;
    {
    {
#line 298
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 298
      if (! (i < n)) {
#line 298
        goto while_break___4;
      }
#line 299
      if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
        tmp___4 = (double )524287;
      } else {
#line 299
        tmp___4 = *(src___4 + i) * (double )524288;
      }
#line 299
      if (tmp___4 > (double )-524288) {
#line 299
        if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
          tmp___3 = (double )524287;
        } else {
#line 299
          tmp___3 = *(src___4 + i) * (double )524288;
        }
#line 299
        v = (int )tmp___3;
      } else {
#line 299
        v = -524288;
      }
#line 300
      *(dest + i) = v;
#line 298
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s24___0(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 310
  if ((int )fmt == 0) {
#line 311
    src = (uint8_t *)src_v;
#line 312
    i = 0;
    {
    {
#line 312
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 312
      if (! (i < n)) {
#line 312
        goto while_break;
      }
#line 313
      *(dest + i) = ((int )*(src + i) - 128) << 16;
#line 312
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 315
  if ((int )fmt == 1) {
#line 316
    src___0 = (int16_t *)src_v;
#line 317
    i = 0;
    {
    {
#line 317
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! (i < n)) {
#line 317
        goto while_break___0;
      }
#line 318
      *(dest + i) = (int )*(src___0 + i) << 8;
#line 317
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 320
  if ((int )fmt == 2) {
#line 321
    src___1 = (int32_t *)src_v;
#line 322
    i = 0;
    {
    {
#line 322
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (i < n)) {
#line 322
        goto while_break___1;
      }
#line 323
      *(dest + i) = *(src___1 + i) << 4;
#line 322
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 325
  if ((int )fmt == 3) {
    {
    {
#line 326
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 327
  if ((int )fmt == 4) {
#line 328
    src___2 = (int32_t *)src_v;
#line 329
    i = 0;
    {
    {
#line 329
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (i < n)) {
#line 329
        goto while_break___2;
      }
#line 330
      *(dest + i) = *(src___2 + i) >> 8;
#line 329
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 332
  if ((int )fmt == 5) {
#line 333
    src___3 = (float *)src_v;
#line 334
    i = 0;
    {
    {
#line 334
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 334
      if (! (i < n)) {
#line 334
        goto while_break___3;
      }
#line 335
      if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
        tmp___1 = (float )8388607;
      } else {
#line 335
        tmp___1 = *(src___3 + i) * (float )8388608;
      }
#line 335
      if (tmp___1 > (float )-8388608) {
#line 335
        if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
          tmp___0 = (float )8388607;
        } else {
#line 335
          tmp___0 = *(src___3 + i) * (float )8388608;
        }
#line 335
        v = (int )tmp___0;
      } else {
#line 335
        v = -8388608;
      }
#line 336
      *(dest + i) = v;
#line 334
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 338
  if ((int )fmt == 6) {
#line 339
    src___4 = (double *)src_v;
#line 340
    i = 0;
    {
    {
#line 340
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 340
      if (! (i < n)) {
#line 340
        goto while_break___4;
      }
#line 341
      if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
        tmp___4 = (double )8388607;
      } else {
#line 341
        tmp___4 = *(src___4 + i) * (double )8388608;
      }
#line 341
      if (tmp___4 > (double )-8388608) {
#line 341
        if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
          tmp___3 = (double )8388607;
        } else {
#line 341
          tmp___3 = *(src___4 + i) * (double )8388608;
        }
#line 341
        v = (int )tmp___3;
      } else {
#line 341
        v = -8388608;
      }
#line 342
      *(dest + i) = v;
#line 340
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 345
  return;
}
}
#line 347 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s32___0(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  double *src___4 ;

  {
#line 352
  if ((int )fmt == 0) {
#line 353
    src = (uint8_t *)src_v;
#line 354
    i = 0;
    {
    {
#line 354
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 354
      if (! (i < n)) {
#line 354
        goto while_break;
      }
#line 355
      *(dest + i) = ((int )*(src + i) - 128) << 24;
#line 354
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 357
  if ((int )fmt == 1) {
#line 358
    src___0 = (int16_t *)src_v;
#line 359
    i = 0;
    {
    {
#line 359
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (i < n)) {
#line 359
        goto while_break___0;
      }
#line 360
      *(dest + i) = (int )*(src___0 + i) << 16;
#line 359
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 362
  if ((int )fmt == 2) {
#line 363
    src___1 = (int32_t *)src_v;
#line 364
    i = 0;
    {
    {
#line 364
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (i < n)) {
#line 364
        goto while_break___1;
      }
#line 365
      *(dest + i) = *(src___1 + i) << 12;
#line 364
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 367
  if ((int )fmt == 3) {
#line 368
    src___2 = (int32_t *)src_v;
#line 369
    i = 0;
    {
    {
#line 369
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 369
      if (! (i < n)) {
#line 369
        goto while_break___2;
      }
#line 370
      *(dest + i) = *(src___2 + i) << 8;
#line 369
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 372
  if ((int )fmt == 4) {
    {
    {
#line 373
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 374
  if ((int )fmt == 5) {
#line 375
    src___3 = (float *)src_v;
#line 376
    i = 0;
    {
    {
#line 376
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 376
      if (! (i < n)) {
#line 376
        goto while_break___3;
      }
#line 377
      v = (int )(*(src___3 + i) * (float )2147483648LL);
#line 378
      *(dest + i) = v;
#line 376
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 380
  if ((int )fmt == 6) {
#line 381
    src___4 = (double *)src_v;
#line 382
    i = 0;
    {
    {
#line 382
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 382
      if (! (i < n)) {
#line 382
        goto while_break___4;
      }
#line 383
      v = (int )(*(src___4 + i) * (double )2147483648LL);
#line 384
      *(dest + i) = v;
#line 382
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_float___0(float *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  double *src___4 ;

  {
#line 394
  if ((int )fmt == 0) {
#line 395
    src = (uint8_t *)src_v;
#line 396
    i = 0;
    {
    {
#line 396
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 396
      if (! (i < n)) {
#line 396
        goto while_break;
      }
#line 397
      *(dest + i) = (float )(((double )*(src + i) - 128.0) / 128.0);
#line 396
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 399
  if ((int )fmt == 1) {
#line 400
    src___0 = (int16_t *)src_v;
#line 401
    i = 0;
    {
    {
#line 401
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (i < n)) {
#line 401
        goto while_break___0;
      }
#line 402
      *(dest + i) = (float )((double )*(src___0 + i) / 32768.0);
#line 401
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 404
  if ((int )fmt == 2) {
#line 405
    src___1 = (int32_t *)src_v;
#line 406
    i = 0;
    {
    {
#line 406
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 406
      if (! (i < n)) {
#line 406
        goto while_break___1;
      }
#line 407
      *(dest + i) = (float )((double )*(src___1 + i) / 524288.0);
#line 406
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 409
  if ((int )fmt == 3) {
#line 410
    src___2 = (int32_t *)src_v;
#line 411
    i = 0;
    {
    {
#line 411
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 411
      if (! (i < n)) {
#line 411
        goto while_break___2;
      }
#line 412
      *(dest + i) = (float )((double )*(src___2 + i) / 8388608.0);
#line 411
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 414
  if ((int )fmt == 4) {
#line 415
    src___3 = (int32_t *)src_v;
#line 416
    i = 0;
    {
    {
#line 416
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 416
      if (! (i < n)) {
#line 416
        goto while_break___3;
      }
#line 417
      *(dest + i) = (float )((double )*(src___3 + i) / 2147483648.0);
#line 416
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 419
  if ((int )fmt == 5) {
    {
    {
#line 420
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(float )));
    }
    }
  } else
#line 421
  if ((int )fmt == 6) {
#line 422
    src___4 = (double *)src_v;
#line 423
    i = 0;
    {
    {
#line 423
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 423
      if (! (i < n)) {
#line 423
        goto while_break___4;
      }
#line 424
      *(dest + i) = (float )*(src___4 + i);
#line 423
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_double___0(double *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  float *src___4 ;

  {
#line 434
  if ((int )fmt == 0) {
#line 435
    src = (uint8_t *)src_v;
#line 436
    i = 0;
    {
    {
#line 436
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 436
      if (! (i < n)) {
#line 436
        goto while_break;
      }
#line 437
      *(dest + i) = ((double )*(src + i) - 128.0) / 128.0;
#line 436
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 439
  if ((int )fmt == 1) {
#line 440
    src___0 = (int16_t *)src_v;
#line 441
    i = 0;
    {
    {
#line 441
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 441
      if (! (i < n)) {
#line 441
        goto while_break___0;
      }
#line 442
      *(dest + i) = (double )*(src___0 + i) / 32768.0;
#line 441
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 444
  if ((int )fmt == 2) {
#line 445
    src___1 = (int32_t *)src_v;
#line 446
    i = 0;
    {
    {
#line 446
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 446
      if (! (i < n)) {
#line 446
        goto while_break___1;
      }
#line 447
      *(dest + i) = (double )*(src___1 + i) / 524288.0;
#line 446
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 449
  if ((int )fmt == 3) {
#line 450
    src___2 = (int32_t *)src_v;
#line 451
    i = 0;
    {
    {
#line 451
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 451
      if (! (i < n)) {
#line 451
        goto while_break___2;
      }
#line 452
      *(dest + i) = (double )*(src___2 + i) / 8388608.0;
#line 451
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 454
  if ((int )fmt == 4) {
#line 455
    src___3 = (int32_t *)src_v;
#line 456
    i = 0;
    {
    {
#line 456
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 456
      if (! (i < n)) {
#line 456
        goto while_break___3;
      }
#line 457
      *(dest + i) = (double )*(src___3 + i) / 2147483648.0;
#line 456
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 459
  if ((int )fmt == 5) {
#line 460
    src___4 = (float *)src_v;
#line 461
    i = 0;
    {
    {
#line 461
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 461
      if (! (i < n)) {
#line 461
        goto while_break___4;
      }
#line 462
      *(dest + i) = (double )*(src___4 + i);
#line 461
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 464
  if ((int )fmt == 6) {
    {
    {
#line 465
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(double )));
    }
    }
  }
#line 467
  return;
}
}
#line 469 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert___0(enum WavSampleFormat dest_fmt , void *dest , enum WavSampleFormat src_fmt ,
                            void *src , int n ) 
{ 


  {
  {
#line 474
  if ((int )dest_fmt == 0) {
#line 474
    goto case_0;
  }
#line 477
  if ((int )dest_fmt == 1) {
#line 477
    goto case_1;
  }
#line 480
  if ((int )dest_fmt == 2) {
#line 480
    goto case_2;
  }
#line 483
  if ((int )dest_fmt == 3) {
#line 483
    goto case_3;
  }
#line 486
  if ((int )dest_fmt == 4) {
#line 486
    goto case_4;
  }
#line 489
  if ((int )dest_fmt == 5) {
#line 489
    goto case_5;
  }
#line 492
  if ((int )dest_fmt == 6) {
#line 492
    goto case_6;
  }
#line 473
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 475
  fmt_convert_to_u8___0((uint8_t *)dest, src, n, src_fmt);
  }
  }
#line 476
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 478
  fmt_convert_to_s16___0((int16_t *)dest, src, n, src_fmt);
  }
  }
#line 479
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 481
  fmt_convert_to_s20___0((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 484
  fmt_convert_to_s24___0((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 485
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 487
  fmt_convert_to_s32___0((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 488
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 490
  fmt_convert_to_float___0((float *)dest, src, n, src_fmt);
  }
  }
#line 491
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  {
#line 493
  fmt_convert_to_double___0((double *)dest, src, n, src_fmt);
  }
  }
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 766 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 64 "../common.h"
__inline static int log2i(uint32_t v ) 
{ 
  int i ;
  int n ;

  {
#line 68
  n = 0;
#line 69
  if (v & 4294901760U) {
#line 69
    v >>= 16;
#line 69
    n += 16;
  }
#line 70
  if (v & 65280U) {
#line 70
    v >>= 8;
#line 70
    n += 8;
  }
#line 71
  i = 2;
  {
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < 256)) {
#line 71
      goto while_break;
    }
#line 72
    if (v >= (uint32_t )i) {
#line 72
      n ++;
    } else {
#line 73
      goto while_break;
    }
#line 71
    i <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (n);
}
}
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 183 "/home/wslee/benchmarks/sound/flake-0.11/libflake/flake.h"
int flake_set_defaults(FlakeEncodeParams *params ) ;
#line 189
int flake_validate_params(FlakeContext *s ) ;
#line 191
int flake_encode_init(FlakeContext *s ) ;
#line 193
int flake_encode_frame(FlakeContext *s , unsigned char *frame_buffer , short *samples ) ;
#line 196
void flake_encode_close(FlakeContext *s ) ;
#line 42 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.h"
int find_optimal_rice_param(uint32_t sum , int n ) ;
#line 24 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.h"
void md5_init(MD5Context *ctx ) ;
#line 28
void md5_final(uint8_t *result , MD5Context *ctx ) ;
#line 30
void md5_accumulate(MD5Context *ctx , void const   *signal , int ch , int nsamples ) ;
#line 88 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.h"
int encode_frame(FlakeContext *s , uint8_t *frame_buffer , int16_t *samples ) ;
#line 15 "../bswap.h"
__inline static uint32_t bswap_32(uint32_t x ) 
{ 


  {
#line 16
  x = ((x << 8) & 4278255360U) | ((x >> 8) & 16711935U);
#line 17
  return ((x >> 16) | (x << 16));
}
}
#line 40 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
__inline static void bitwriter_init(BitWriter *bw , void *buf , int len ) 
{ 


  {
#line 43
  if (len < 0) {
#line 44
    len = 0;
#line 45
    buf = (void *)0;
  }
#line 47
  bw->buffer = (uint8_t *)buf;
#line 48
  bw->buf_end = bw->buffer + len;
#line 49
  bw->buf_ptr = bw->buffer;
#line 50
  bw->bit_left = 32;
#line 51
  bw->bit_buf = (uint32_t )0;
#line 52
  bw->eof = 0;
#line 53
  return;
}
}
#line 55 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
__inline static uint32_t bitwriter_count(BitWriter *bw ) 
{ 


  {
#line 59
  return ((uint32_t )((((((bw->buf_ptr - bw->buffer) << 3) + 32L) - (long )bw->bit_left) + 7L) >> 3));
}
}
#line 62 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
__inline static void bitwriter_flush(BitWriter *bw ) 
{ 


  {
#line 65
  bw->bit_buf <<= bw->bit_left;
  {
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 66
    if (bw->bit_left < 32) {
#line 66
      if (! (! bw->eof)) {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
#line 67
    if ((unsigned long )bw->buf_ptr >= (unsigned long )bw->buf_end) {
#line 68
      bw->eof = 1;
#line 69
      goto while_break;
    }
#line 71
    if ((unsigned long )bw->buffer != (unsigned long )((void *)0)) {
#line 72
      *(bw->buf_ptr) = (uint8_t )(bw->bit_buf >> 24);
    }
#line 74
    (bw->buf_ptr) ++;
#line 75
    bw->bit_buf <<= 8;
#line 76
    bw->bit_left += 8;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  bw->bit_left = 32;
#line 79
  bw->bit_buf = (uint32_t )0;
#line 80
  return;
}
}
#line 82 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
__inline static void bitwriter_writebits(BitWriter *bw , int bits , uint32_t val ) 
{ 
  uint32_t bb ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 85
  bb = (uint32_t )0;
#line 86
  if (! (bits == 32)) {
#line 86
    if (! (val < 1U << bits)) {
      {
      {
#line 86
      __assert_fail("bits == 32 || val < (1U << bits)", "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h",
                    86U, "bitwriter_writebits");
      }
      }
    }
  }
#line 88
  if (bits == 0) {
#line 88
    return;
  } else
#line 88
  if (bw->eof) {
#line 88
    return;
  }
#line 89
  if ((unsigned long )(bw->buf_ptr + 3) >= (unsigned long )bw->buf_end) {
#line 90
    bw->eof = 1;
#line 91
    return;
  }
#line 93
  if (bits < bw->bit_left) {
#line 94
    bw->bit_buf = (bw->bit_buf << bits) | val;
#line 95
    bw->bit_left -= bits;
  } else {
#line 97
    if (bw->bit_left == 32) {
#line 98
      if (! (bits == 32)) {
        {
        {
#line 98
        __assert_fail("bits == 32", "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h",
                      98U, "bitwriter_writebits");
        }
        }
      }
#line 99
      bb = val;
    } else {
#line 101
      bb = (bw->bit_buf << bw->bit_left) | (val >> (bits - bw->bit_left));
#line 102
      bw->bit_left += 32 - bits;
    }
#line 104
    if ((unsigned long )bw->buffer != (unsigned long )((void *)0)) {
      {
      {
#line 105
      *((uint32_t *)bw->buf_ptr) = bswap_32(bb);
      }
      }
    }
#line 107
    bw->buf_ptr += 4;
#line 108
    bw->bit_buf = val;
  }
#line 110
  return;
}
}
#line 112 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
__inline static void bitwriter_writebits_signed(BitWriter *bw , int bits , int32_t val ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 115
  if (bits >= 0) {
#line 115
    if (! (bits <= 31)) {
      {
      {
#line 115
      __assert_fail("bits >= 0 && bits <= 31", "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h",
                    115U, "bitwriter_writebits_signed");
      }
      }
    }
  } else {
    {
    {
#line 115
    __assert_fail("bits >= 0 && bits <= 31", "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h",
                  115U, "bitwriter_writebits_signed");
    }
    }
  }
  {
  {
#line 116
  bitwriter_writebits(bw, bits, (uint32_t )((unsigned long long )val & ((1ULL << bits) - 1ULL)));
  }
  }
#line 117
  return;
}
}
#line 119 "/home/wslee/benchmarks/sound/flake-0.11/libflake/bitio.h"
__inline static void bitwriter_write_rice_signed(BitWriter *bw , int k , int32_t val ) 
{ 
  int v ;
  int q ;

  {
#line 124
  if (k < 0) {
#line 124
    return;
  }
#line 127
  v = -2 * val - 1;
#line 128
  v ^= v >> 31;
#line 131
  q = (v >> k) + 1;
  {
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 132
    if (! (q > 31)) {
#line 132
      goto while_break;
    }
    {
    {
#line 133
    bitwriter_writebits(bw, 31, (uint32_t )0);
    }
#line 134
    q -= 31;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 136
  bitwriter_writebits(bw, q, (uint32_t )1);
  }
  {
#line 139
  bitwriter_writebits(bw, k, (uint32_t )(v & ((1 << k) - 1)));
  }
  }
#line 140
  return;
}
}
#line 25 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.h"
void crc_init(void) ;
#line 27
uint8_t calc_crc8(uint8_t const   *data , uint32_t len ) ;
#line 29
uint16_t calc_crc16(uint8_t const   *data , uint32_t len ) ;
#line 27 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.h"
int encode_residual(FlacEncodeContext *ctx , int ch ) ;
#line 29
void reencode_residual_verbatim(FlacEncodeContext *ctx , int ch ) ;
#line 25 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.h"
int encode_frame_vbs(FlakeContext *s , uint8_t *frame_buffer , int16_t *samples ) ;
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_samplerates[16]  = 
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )8000,      (int const   )16000,      (int const   )22050,      (int const   )24000, 
        (int const   )32000,      (int const   )44100,      (int const   )48000,      (int const   )96000, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_bitdepths[8]  = 
#line 39
  {      (int const   )0,      (int const   )8,      (int const   )12,      (int const   )0, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )0};
#line 43 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_blocksizes[15]  = 
#line 43
  {      (int const   )0,      (int const   )192,      (int const   )576,      (int const   )1152, 
        (int const   )2304,      (int const   )4608,      (int const   )0,      (int const   )0, 
        (int const   )256,      (int const   )512,      (int const   )1024,      (int const   )2048, 
        (int const   )4096,      (int const   )8192,      (int const   )16384};
#line 55 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_streaminfo(FlacEncodeContext *ctx , uint8_t *streaminfo , int last ) 
{ 


  {
  {
  {
#line 58
  memset((void *)streaminfo, 0, (size_t )38);
  }
  {
#line 59
  bitwriter_init(ctx->bw, (void *)streaminfo, 38);
  }
  {
#line 62
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 63
  bitwriter_writebits(ctx->bw, 7, (uint32_t )0);
  }
  {
#line 64
  bitwriter_writebits(ctx->bw, 24, (uint32_t )34);
  }
  }
#line 66
  if (ctx->params.variable_block_size) {
    {
    {
#line 67
    bitwriter_writebits(ctx->bw, 16, (uint32_t )0);
    }
    }
  } else {
    {
    {
#line 69
    bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
    }
    }
  }
  {
  {
#line 71
  bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
  }
  {
#line 72
  bitwriter_writebits(ctx->bw, 24, (uint32_t )0);
  }
  {
#line 73
  bitwriter_writebits(ctx->bw, 24, (uint32_t )ctx->max_frame_size);
  }
  {
#line 74
  bitwriter_writebits(ctx->bw, 20, (uint32_t )ctx->samplerate);
  }
  {
#line 75
  bitwriter_writebits(ctx->bw, 3, (uint32_t )(ctx->channels - 1));
  }
  {
#line 76
  bitwriter_writebits(ctx->bw, 5, (uint32_t )(ctx->bps - 1));
  }
  }
#line 79
  if (ctx->sample_count > 0U) {
    {
    {
#line 80
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 81
    bitwriter_writebits(ctx->bw, 32, ctx->sample_count);
    }
    }
  } else {
    {
    {
#line 83
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 84
    bitwriter_writebits(ctx->bw, 32, (uint32_t )0);
    }
    }
  }
#line 86
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_padding(FlacEncodeContext *ctx , uint8_t *padding , int last , int padlen ) 
{ 


  {
  {
  {
#line 94
  bitwriter_init(ctx->bw, (void *)padding, 4);
  }
  {
#line 97
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 98
  bitwriter_writebits(ctx->bw, 7, (uint32_t )1);
  }
  {
#line 99
  bitwriter_writebits(ctx->bw, 24, (uint32_t )padlen);
  }
  }
#line 101
  return (padlen + 4);
}
}
#line 104 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static char const   *vendor_string  =    "Flake0.11";
#line 110 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_vorbis_comment(FlacEncodeContext *ctx , uint8_t *comment , int last ) 
{ 
  int vendor_len ;
  uint8_t vlen_le[4] ;
  size_t tmp ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 116
  tmp = strlen(vendor_string);
  }
#line 116
  vendor_len = (int )tmp;
  {
#line 117
  bitwriter_init(ctx->bw, (void *)comment, 4);
  }
  {
#line 120
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 121
  bitwriter_writebits(ctx->bw, 7, (uint32_t )4);
  }
  {
#line 122
  bitwriter_writebits(ctx->bw, 24, (uint32_t )(vendor_len + 8));
  }
#line 126
  vlen_le[0] = (uint8_t )(vendor_len & 255);
#line 127
  vlen_le[1] = (uint8_t )((vendor_len >> 8) & 255);
#line 128
  vlen_le[2] = (uint8_t )((vendor_len >> 16) & 255);
#line 129
  vlen_le[3] = (uint8_t )((vendor_len >> 24) & 255);
  {
#line 130
  memcpy((void */* __restrict  */)(comment + 4), (void const   */* __restrict  */)(vlen_le),
         (size_t )4);
  }
  {
#line 132
  memcpy((void */* __restrict  */)(comment + 8), (void const   */* __restrict  */)vendor_string,
         (size_t )vendor_len);
  }
  {
#line 134
  memset((void *)(comment + (vendor_len + 8)), 0, (size_t )4);
  }
  }
#line 136
  return (vendor_len + 12);
}
}
#line 142 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_headers(FlacEncodeContext *ctx , uint8_t *header ) 
{ 
  int header_size ;
  int last ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 147
  header_size = 0;
#line 148
  last = 0;
#line 151
  *(header + 0) = (uint8_t )102;
#line 152
  *(header + 1) = (uint8_t )76;
#line 153
  *(header + 2) = (uint8_t )97;
#line 154
  *(header + 3) = (uint8_t )67;
#line 155
  header_size += 4;
  {
#line 158
  write_streaminfo(ctx, header + header_size, last);
  }
#line 159
  header_size += 38;
  }
#line 162
  if (ctx->params.padding_size == 0) {
#line 162
    last = 1;
  }
  {
  {
#line 163
  tmp = write_vorbis_comment(ctx, header + header_size, last);
  }
#line 163
  header_size += tmp;
  }
#line 166
  if (ctx->params.padding_size > 0) {
    {
#line 167
    last = 1;
    {
#line 168
    tmp___0 = write_padding(ctx, header + header_size, last, ctx->params.padding_size);
    }
#line 168
    header_size += tmp___0;
    }
  }
#line 172
  return (header_size);
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int select_blocksize(int samplerate , int time_ms ) 
{ 
  int i ;
  int target ;
  int blocksize ;

  {
#line 184
  blocksize = (int )flac_blocksizes[1];
#line 185
  target = (samplerate * time_ms) / 1000;
#line 186
  i = 0;
  {
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 16)) {
#line 186
      goto while_break;
    }
#line 187
    if (target >= (int )flac_blocksizes[i]) {
#line 187
      if (flac_blocksizes[i] > (int const   )blocksize) {
#line 188
        blocksize = (int )flac_blocksizes[i];
      }
    }
#line 186
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (blocksize);
}
}
#line 194 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
int flake_set_defaults(FlakeEncodeParams *params ) 
{ 
  int lvl ;

  {
#line 199
  if (! params) {
#line 200
    return (-1);
  }
#line 202
  lvl = params->compression;
#line 203
  if (lvl < 0) {
#line 203
    goto _L;
  } else
#line 203
  if (lvl > 12) {
    _L: /* CIL Label */ 
#line 203
    if (lvl != 99) {
#line 204
      return (-1);
    }
  }
#line 208
  params->order_method = 1;
#line 209
  params->stereo_method = 1;
#line 210
  params->block_size = 0;
#line 211
  params->block_time_ms = 105;
#line 212
  params->prediction_type = 2;
#line 213
  params->min_prediction_order = 1;
#line 214
  params->max_prediction_order = 8;
#line 215
  params->min_partition_order = 0;
#line 216
  params->max_partition_order = 6;
#line 217
  params->padding_size = 4096;
#line 218
  params->variable_block_size = 0;
  {
#line 222
  if (lvl == 0) {
#line 222
    goto case_0;
  }
#line 231
  if (lvl == 1) {
#line 231
    goto case_1;
  }
#line 239
  if (lvl == 2) {
#line 239
    goto case_2;
  }
#line 247
  if (lvl == 3) {
#line 247
    goto case_3;
  }
#line 251
  if (lvl == 4) {
#line 251
    goto case_4;
  }
#line 254
  if (lvl == 5) {
#line 254
    goto case_5;
  }
#line 256
  if (lvl == 6) {
#line 256
    goto case_6;
  }
#line 260
  if (lvl == 7) {
#line 260
    goto case_7;
  }
#line 264
  if (lvl == 8) {
#line 264
    goto case_8;
  }
#line 269
  if (lvl == 9) {
#line 269
    goto case_9;
  }
#line 274
  if (lvl == 10) {
#line 274
    goto case_10;
  }
#line 279
  if (lvl == 11) {
#line 279
    goto case_11;
  }
#line 284
  if (lvl == 12) {
#line 284
    goto case_12;
  }
#line 289
  if (lvl == 99) {
#line 289
    goto case_99;
  }
#line 221
  goto switch_break;
  case_0: /* CIL Label */ 
#line 223
  params->stereo_method = 0;
#line 224
  params->block_time_ms = 27;
#line 225
  params->prediction_type = 1;
#line 226
  params->min_prediction_order = 2;
#line 227
  params->max_prediction_order = 2;
#line 228
  params->min_partition_order = 4;
#line 229
  params->max_partition_order = 4;
#line 230
  goto switch_break;
  case_1: /* CIL Label */ 
#line 232
  params->block_time_ms = 27;
#line 233
  params->prediction_type = 1;
#line 234
  params->min_prediction_order = 2;
#line 235
  params->max_prediction_order = 3;
#line 236
  params->min_partition_order = 2;
#line 237
  params->max_partition_order = 2;
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
#line 240
  params->block_time_ms = 27;
#line 241
  params->prediction_type = 1;
#line 242
  params->min_prediction_order = 2;
#line 243
  params->max_prediction_order = 4;
#line 244
  params->min_partition_order = 0;
#line 245
  params->max_partition_order = 3;
#line 246
  goto switch_break;
  case_3: /* CIL Label */ 
#line 248
  params->max_prediction_order = 6;
#line 249
  params->max_partition_order = 3;
#line 250
  goto switch_break;
  case_4: /* CIL Label */ 
#line 252
  params->max_partition_order = 3;
#line 253
  goto switch_break;
  case_5: /* CIL Label */ 
#line 255
  goto switch_break;
  case_6: /* CIL Label */ 
#line 257
  params->order_method = 2;
#line 258
  params->max_partition_order = 8;
#line 259
  goto switch_break;
  case_7: /* CIL Label */ 
#line 261
  params->order_method = 3;
#line 262
  params->max_partition_order = 8;
#line 263
  goto switch_break;
  case_8: /* CIL Label */ 
#line 265
  params->order_method = 3;
#line 266
  params->max_prediction_order = 12;
#line 267
  params->max_partition_order = 8;
#line 268
  goto switch_break;
  case_9: /* CIL Label */ 
#line 270
  params->order_method = 6;
#line 271
  params->max_prediction_order = 12;
#line 272
  params->max_partition_order = 8;
#line 273
  goto switch_break;
  case_10: /* CIL Label */ 
#line 275
  params->order_method = 5;
#line 276
  params->max_prediction_order = 12;
#line 277
  params->max_partition_order = 8;
#line 278
  goto switch_break;
  case_11: /* CIL Label */ 
#line 280
  params->order_method = 6;
#line 281
  params->max_prediction_order = 32;
#line 282
  params->max_partition_order = 8;
#line 283
  goto switch_break;
  case_12: /* CIL Label */ 
#line 285
  params->order_method = 5;
#line 286
  params->max_prediction_order = 32;
#line 287
  params->max_partition_order = 8;
#line 288
  goto switch_break;
  case_99: /* CIL Label */ 
#line 290
  params->order_method = 5;
#line 291
  params->block_time_ms = 186;
#line 292
  params->max_prediction_order = 32;
#line 293
  params->max_partition_order = 8;
#line 294
  params->variable_block_size = 2;
#line 295
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 298
  return (0);
}
}
#line 301 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
int flake_validate_params(FlakeContext *s ) 
{ 
  int i ;
  int subset ;
  int bs ;
  FlakeEncodeParams *params ;

  {
#line 305
  subset = 0;
#line 309
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 310
    return (-1);
  }
#line 312
  params = & s->params;
#line 314
  if (s->channels < 1) {
#line 315
    return (-1);
  } else
#line 314
  if (s->channels > 8) {
#line 315
    return (-1);
  }
#line 318
  if (s->sample_rate < 1) {
#line 319
    return (-1);
  } else
#line 318
  if (s->sample_rate > 655350) {
#line 319
    return (-1);
  }
#line 321
  i = 4;
  {
  {
#line 321
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 321
    if (! (i < 12)) {
#line 321
      goto while_break;
    }
#line 322
    if (s->sample_rate == (int )flac_samplerates[i]) {
#line 323
      goto while_break;
    }
#line 321
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (i == 12) {
#line 327
    subset = 1;
  }
#line 330
  if (s->bits_per_sample < 4) {
#line 331
    return (-1);
  } else
#line 330
  if (s->bits_per_sample > 32) {
#line 331
    return (-1);
  }
#line 333
  i = 1;
  {
  {
#line 333
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 333
    if (! (i < 8)) {
#line 333
      goto while_break___0;
    }
#line 334
    if (s->bits_per_sample == (int )flac_bitdepths[i]) {
#line 335
      goto while_break___0;
    }
#line 333
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 337
  if (i == 8) {
#line 338
    subset = 1;
  }
#line 341
  if (params->compression < 0) {
#line 341
    goto _L;
  } else
#line 341
  if (params->compression > 12) {
    _L: /* CIL Label */ 
#line 341
    if (params->compression != 99) {
#line 343
      return (-1);
    }
  }
#line 346
  if (params->order_method < 0) {
#line 347
    return (-1);
  } else
#line 346
  if (params->order_method > 6) {
#line 347
    return (-1);
  }
#line 350
  if (params->stereo_method < 0) {
#line 351
    return (-1);
  } else
#line 350
  if (params->stereo_method > 1) {
#line 351
    return (-1);
  }
#line 354
  if (params->block_time_ms < 0) {
#line 355
    return (-1);
  }
#line 358
  bs = params->block_size;
#line 359
  if (bs == 0) {
    {
    {
#line 360
    bs = select_blocksize(s->sample_rate, params->block_time_ms);
    }
    }
  }
#line 362
  if (bs < 16) {
#line 363
    return (-1);
  } else
#line 362
  if (bs > 65535) {
#line 363
    return (-1);
  }
#line 365
  i = 0;
  {
  {
#line 365
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 365
    if (! (i < 15)) {
#line 365
      goto while_break___1;
    }
#line 366
    if (bs == (int )flac_blocksizes[i]) {
#line 367
      goto while_break___1;
    }
#line 365
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 369
  if (i == 15) {
#line 370
    subset = 1;
  } else
#line 369
  if (s->sample_rate <= 48000) {
#line 369
    if (bs > 4608) {
#line 370
      subset = 1;
    }
  }
#line 373
  if (params->prediction_type < 0) {
#line 374
    return (-1);
  } else
#line 373
  if (params->prediction_type > 2) {
#line 374
    return (-1);
  }
#line 377
  if (params->min_prediction_order > params->max_prediction_order) {
#line 378
    return (-1);
  }
#line 380
  if (params->prediction_type == 1) {
#line 381
    if (params->min_prediction_order < 0) {
#line 383
      return (-1);
    } else
#line 381
    if (params->min_prediction_order > 4) {
#line 383
      return (-1);
    }
#line 385
    if (params->max_prediction_order < 0) {
#line 387
      return (-1);
    } else
#line 385
    if (params->max_prediction_order > 4) {
#line 387
      return (-1);
    }
  } else {
#line 390
    if (params->min_prediction_order < 1) {
#line 392
      return (-1);
    } else
#line 390
    if (params->min_prediction_order > 32) {
#line 392
      return (-1);
    }
#line 394
    if (params->max_prediction_order < 1) {
#line 396
      return (-1);
    } else
#line 394
    if (params->max_prediction_order > 32) {
#line 396
      return (-1);
    }
#line 398
    if (s->sample_rate <= 48000) {
#line 398
      if (params->max_prediction_order > 12) {
#line 399
        subset = 1;
      }
    }
  }
#line 403
  if (params->min_partition_order > params->max_partition_order) {
#line 404
    return (-1);
  }
#line 406
  if (params->min_partition_order < 0) {
#line 407
    return (-1);
  } else
#line 406
  if (params->min_partition_order > 8) {
#line 407
    return (-1);
  }
#line 409
  if (params->max_partition_order < 0) {
#line 410
    return (-1);
  } else
#line 409
  if (params->max_partition_order > 8) {
#line 410
    return (-1);
  }
#line 413
  if (params->padding_size < 0) {
#line 414
    return (-1);
  } else
#line 413
  if (params->padding_size >= 1 << 24) {
#line 414
    return (-1);
  }
#line 417
  if (params->variable_block_size < 0) {
#line 418
    return (-1);
  } else
#line 417
  if (params->variable_block_size > 2) {
#line 418
    return (-1);
  }
#line 420
  if (params->variable_block_size > 0) {
#line 421
    subset = 1;
  }
#line 424
  return (subset);
}
}
#line 430 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
int flake_encode_init(FlakeContext *s ) 
{ 
  FlacEncodeContext *ctx ;
  int i ;
  int header_len ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 436
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 437
    return (-1);
  }
  {
  {
#line 441
  tmp = calloc((size_t )1, (size_t )sizeof(FlacEncodeContext ));
  }
#line 441
  ctx = (FlacEncodeContext *)tmp;
#line 442
  s->private_ctx = (void *)ctx;
  {
#line 444
  tmp___0 = flake_validate_params(s);
  }
  }
#line 444
  if (tmp___0 < 0) {
#line 445
    return (-1);
  }
#line 448
  ctx->channels = s->channels;
#line 449
  ctx->ch_code = s->channels - 1;
#line 452
  i = 4;
  {
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 452
    if (! (i < 12)) {
#line 452
      goto while_break;
    }
#line 453
    if (s->sample_rate == (int )flac_samplerates[i]) {
#line 454
      ctx->samplerate = (int )flac_samplerates[i];
#line 455
      ctx->sr_code[0] = i;
#line 456
      ctx->sr_code[1] = 0;
#line 457
      goto while_break;
    }
#line 452
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if (i == 12) {
#line 462
    ctx->samplerate = s->sample_rate;
#line 463
    if (ctx->samplerate % 1000 == 0) {
#line 463
      if (ctx->samplerate <= 255000) {
#line 464
        ctx->sr_code[0] = 12;
#line 465
        ctx->sr_code[1] = ctx->samplerate / 1000;
      } else {
#line 463
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 466
    if (ctx->samplerate % 10 == 0) {
#line 466
      if (ctx->samplerate <= 655350) {
#line 467
        ctx->sr_code[0] = 14;
#line 468
        ctx->sr_code[1] = s->sample_rate / 10;
      } else {
#line 466
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 469
    if (ctx->samplerate < 65535) {
#line 470
      ctx->sr_code[0] = 13;
#line 471
      ctx->sr_code[1] = ctx->samplerate;
    }
  }
#line 475
  i = 1;
  {
  {
#line 475
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 475
    if (! (i < 8)) {
#line 475
      goto while_break___0;
    }
#line 476
    if (s->bits_per_sample == (int )flac_bitdepths[i]) {
#line 477
      ctx->bps = (int )flac_bitdepths[i];
#line 478
      ctx->bps_code = i;
#line 479
      goto while_break___0;
    }
#line 475
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 482
  if (i == 8) {
#line 482
    return (-1);
  }
#line 484
  if (ctx->bps != 16) {
#line 484
    return (-1);
  }
#line 486
  ctx->sample_count = s->samples;
#line 488
  if (s->params.block_size == 0) {
    {
    {
#line 489
    s->params.block_size = select_blocksize(ctx->samplerate, s->params.block_time_ms);
    }
    }
  }
#line 492
  ctx->params = s->params;
#line 495
  if (ctx->params.block_size <= 192) {
#line 495
    ctx->lpc_precision = 7;
  } else
#line 496
  if (ctx->params.block_size <= 384) {
#line 496
    ctx->lpc_precision = 8;
  } else
#line 497
  if (ctx->params.block_size <= 576) {
#line 497
    ctx->lpc_precision = 9;
  } else
#line 498
  if (ctx->params.block_size <= 1152) {
#line 498
    ctx->lpc_precision = 10;
  } else
#line 499
  if (ctx->params.block_size <= 2304) {
#line 499
    ctx->lpc_precision = 11;
  } else
#line 500
  if (ctx->params.block_size <= 4608) {
#line 500
    ctx->lpc_precision = 12;
  } else
#line 501
  if (ctx->params.block_size <= 8192) {
#line 501
    ctx->lpc_precision = 13;
  } else
#line 502
  if (ctx->params.block_size <= 16384) {
#line 502
    ctx->lpc_precision = 14;
  } else {
#line 503
    ctx->lpc_precision = 15;
  }
#line 506
  if (ctx->channels == 2) {
#line 507
    ctx->max_frame_size = 16 + ((ctx->params.block_size * ((ctx->bps + ctx->bps) + 1) + 7) >> 3);
  } else {
#line 509
    ctx->max_frame_size = 16 + (((ctx->params.block_size * ctx->channels) * ctx->bps + 7) >> 3);
  }
  {
#line 511
  s->max_frame_size = ctx->max_frame_size;
  {
#line 514
  tmp___1 = calloc((size_t )sizeof(BitWriter ), (size_t )1);
  }
#line 514
  ctx->bw = (struct BitWriter *)tmp___1;
  {
#line 515
  tmp___2 = calloc((size_t )(ctx->params.padding_size + 1024), (size_t )1);
  }
#line 515
  s->header = (unsigned char *)tmp___2;
#line 516
  header_len = -1;
  }
#line 517
  if ((unsigned long )s->header != (unsigned long )((void *)0)) {
    {
    {
#line 518
    header_len = write_headers(ctx, s->header);
    }
    }
  }
  {
#line 521
  ctx->frame_count = (uint32_t )0;
  {
#line 524
  crc_init();
  }
  {
#line 525
  md5_init(& ctx->md5ctx);
  }
  }
#line 527
  return (header_len);
}
}
#line 533 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int init_frame(FlacEncodeContext *ctx ) 
{ 
  int i ;
  int ch ;
  FlacFrame *frame ;

  {
#line 539
  frame = & ctx->frame;
#line 541
  if (ctx->params.block_time_ms < 0) {
#line 542
    return (-1);
  }
#line 544
  if (ctx->params.block_size == 0) {
    {
    {
#line 545
    ctx->params.block_size = select_blocksize(ctx->samplerate, ctx->params.block_time_ms);
    }
    }
  }
#line 547
  if (ctx->params.block_size < 1) {
#line 549
    return (-1);
  } else
#line 547
  if (ctx->params.block_size > 65535) {
#line 549
    return (-1);
  }
#line 553
  if (ctx->channels == 2) {
#line 554
    ctx->max_frame_size = 16 + ((ctx->params.block_size * ((ctx->bps + ctx->bps) + 1) + 7) >> 3);
  } else {
#line 556
    ctx->max_frame_size = 16 + (((ctx->params.block_size * ctx->channels) * ctx->bps + 7) >> 3);
  }
#line 560
  i = 15;
#line 561
  if (! ctx->params.variable_block_size) {
#line 562
    i = 0;
    {
    {
#line 562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 562
      if (! (i < 15)) {
#line 562
        goto while_break;
      }
#line 563
      if (ctx->params.block_size == (int )flac_blocksizes[i]) {
#line 564
        frame->blocksize = (int )flac_blocksizes[i];
#line 565
        frame->bs_code[0] = i;
#line 566
        frame->bs_code[1] = -1;
#line 567
        goto while_break;
      }
#line 562
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 571
  if (i == 15) {
#line 572
    frame->blocksize = ctx->params.block_size;
#line 573
    if (frame->blocksize <= 256) {
#line 574
      frame->bs_code[0] = 6;
#line 575
      frame->bs_code[1] = frame->blocksize - 1;
    } else {
#line 577
      frame->bs_code[0] = 7;
#line 578
      frame->bs_code[1] = frame->blocksize - 1;
    }
  }
#line 583
  ch = 0;
  {
  {
#line 583
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (ch < ctx->channels)) {
#line 583
      goto while_break___0;
    }
#line 584
    frame->subframes[ch].obits = ctx->bps;
#line 583
    ch ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 593 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void update_md5_checksum(FlacEncodeContext *ctx , int16_t *samples ) 
{ 


  {
  {
  {
#line 596
  md5_accumulate(& ctx->md5ctx, (void const   *)samples, ctx->channels, ctx->params.block_size);
  }
  }
#line 597
  return;
}
}
#line 602 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void copy_samples(FlacEncodeContext *ctx , int16_t *samples ) 
{ 
  int i ;
  int j ;
  int ch ;
  FlacFrame *frame ;

  {
#line 608
  frame = & ctx->frame;
#line 609
  i = 0;
#line 609
  j = 0;
  {
  {
#line 609
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i < frame->blocksize)) {
#line 609
      goto while_break;
    }
#line 610
    ch = 0;
    {
    {
#line 610
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 610
      if (! (ch < ctx->channels)) {
#line 610
        goto while_break___0;
      }
#line 611
      frame->subframes[ch].samples[i] = (int32_t )*(samples + j);
#line 610
      ch ++;
#line 610
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 609
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return;
}
}
#line 619 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int calc_decorr_scores(int32_t *left_ch , int32_t *right_ch , int n ) 
{ 
  int i ;
  int best ;
  int32_t lt ;
  int32_t rt ;
  uint64_t sum[4] ;
  uint64_t score[4] ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 629
  sum[3] = (uint64_t )0;
#line 629
  sum[2] = sum[3];
#line 629
  sum[1] = sum[2];
#line 629
  sum[0] = sum[1];
#line 630
  i = 2;
  {
  {
#line 630
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < n)) {
#line 630
      goto while_break;
    }
    {
#line 631
    lt = (*(left_ch + i) - 2 * *(left_ch + (i - 1))) + *(left_ch + (i - 2));
#line 632
    rt = (*(right_ch + i) - 2 * *(right_ch + (i - 1))) + *(right_ch + (i - 2));
    {
#line 633
    tmp = abs((lt + rt) >> 1);
    }
#line 633
    sum[2] += (uint64_t )tmp;
    {
#line 634
    tmp___0 = abs(lt - rt);
    }
#line 634
    sum[3] += (uint64_t )tmp___0;
    {
#line 635
    tmp___1 = abs(lt);
    }
#line 635
    sum[0] += (uint64_t )tmp___1;
    {
#line 636
    tmp___2 = abs(rt);
    }
#line 636
    sum[1] += (uint64_t )tmp___2;
#line 630
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  i = 0;
  {
  {
#line 639
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (i < 4)) {
#line 639
      goto while_break___0;
    }
    {
    {
#line 640
    k = find_optimal_rice_param((uint32_t )(2ULL * sum[i]), n);
    }
#line 641
    sum[i] = (uint64_t )(n * (k + 1)) + ((2ULL * sum[i] - (uint64_t )(n >> 1)) >> k);
#line 639
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 645
  score[0] = sum[0] + sum[1];
#line 646
  score[1] = sum[0] + sum[3];
#line 647
  score[2] = sum[1] + sum[3];
#line 648
  score[3] = sum[2] + sum[3];
#line 651
  best = 0;
#line 652
  i = 1;
  {
  {
#line 652
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 652
    if (! (i < 4)) {
#line 652
      goto while_break___1;
    }
#line 653
    if (score[i] < score[best]) {
#line 654
      best = i;
    }
#line 652
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 658
  if (best == 0) {
#line 658
    goto case_0;
  }
#line 659
  if (best == 1) {
#line 659
    goto case_1;
  }
#line 660
  if (best == 2) {
#line 660
    goto case_2;
  }
#line 661
  if (best == 3) {
#line 661
    goto case_3;
  }
#line 657
  goto switch_break;
  case_0: /* CIL Label */ 
#line 658
  return (1);
  case_1: /* CIL Label */ 
#line 659
  return (8);
  case_2: /* CIL Label */ 
#line 660
  return (9);
  case_3: /* CIL Label */ 
#line 661
  return (10);
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (1);
}
}
#line 669 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void channel_decorrelation(FlacEncodeContext *ctx ) 
{ 
  int i ;
  FlacFrame *frame ;
  int32_t *left ;
  int32_t *right ;
  int32_t tmp ;

  {
#line 677
  frame = & ctx->frame;
#line 678
  left = frame->subframes[0].samples;
#line 679
  right = frame->subframes[1].samples;
#line 681
  if (ctx->channels != 2) {
#line 682
    frame->ch_mode = 0;
#line 683
    return;
  }
#line 685
  if (frame->blocksize <= 32) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  } else
#line 685
  if (ctx->params.stereo_method == 0) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  }
  {
  {
#line 691
  frame->ch_mode = calc_decorr_scores(left, right, frame->blocksize);
  }
  }
#line 694
  if (frame->ch_mode == 1) {
#line 695
    return;
  }
#line 697
  if (frame->ch_mode == 10) {
#line 698
    i = 0;
    {
    {
#line 698
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 698
      if (! (i < frame->blocksize)) {
#line 698
        goto while_break;
      }
#line 699
      tmp = *(left + i);
#line 700
      *(left + i) = (*(left + i) + *(right + i)) >> 1;
#line 701
      *(right + i) = tmp - *(right + i);
#line 698
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    (frame->subframes[1].obits) ++;
  } else
#line 704
  if (frame->ch_mode == 8) {
#line 705
    i = 0;
    {
    {
#line 705
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 705
      if (! (i < frame->blocksize)) {
#line 705
        goto while_break___0;
      }
#line 706
      *(right + i) = *(left + i) - *(right + i);
#line 705
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    (frame->subframes[1].obits) ++;
  } else
#line 709
  if (frame->ch_mode == 9) {
#line 710
    i = 0;
    {
    {
#line 710
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 710
      if (! (i < frame->blocksize)) {
#line 710
        goto while_break___1;
      }
#line 711
      *(left + i) -= *(right + i);
#line 710
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 713
    (frame->subframes[0].obits) ++;
  }
#line 715
  return;
}
}
#line 721 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_utf8(BitWriter *bw , uint32_t val ) 
{ 
  int bytes ;
  int shift ;
  int tmp ;

  {
#line 726
  if (val < 128U) {
    {
    {
#line 727
    bitwriter_writebits(bw, 8, val);
    }
    }
#line 728
    return;
  }
  {
  {
#line 730
  tmp = log2i(val);
  }
#line 730
  bytes = (tmp + 4) / 5;
#line 731
  shift = (bytes - 1) * 6;
  {
#line 732
  bitwriter_writebits(bw, 8, (unsigned int )(256 - (256 >> bytes)) | (val >> shift));
  }
  }
  {
  {
#line 733
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 733
    if (! (shift >= 6)) {
#line 733
      goto while_break;
    }
    {
#line 734
    shift -= 6;
    {
#line 735
    bitwriter_writebits(bw, 8, 128U | ((val >> shift) & 63U));
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return;
}
}
#line 739 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_header(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  uint8_t crc ;
  uint32_t tmp ;

  {
  {
#line 745
  frame = & ctx->frame;
  {
#line 747
  bitwriter_writebits(ctx->bw, 16, (uint32_t )65528);
  }
  {
#line 748
  bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->bs_code[0]);
  }
  {
#line 749
  bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->sr_code[0]);
  }
  }
#line 750
  if (frame->ch_mode == 0) {
    {
    {
#line 751
    bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->ch_code);
    }
    }
  } else {
    {
    {
#line 753
    bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->ch_mode);
    }
    }
  }
  {
  {
#line 755
  bitwriter_writebits(ctx->bw, 3, (uint32_t )ctx->bps_code);
  }
  {
#line 756
  bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
  }
  {
#line 757
  write_utf8(ctx->bw, ctx->frame_count);
  }
  }
#line 760
  if (frame->bs_code[1] >= 0) {
#line 761
    if (frame->bs_code[1] < 256) {
      {
      {
#line 762
      bitwriter_writebits(ctx->bw, 8, (uint32_t )frame->bs_code[1]);
      }
      }
    } else {
      {
      {
#line 764
      bitwriter_writebits(ctx->bw, 16, (uint32_t )frame->bs_code[1]);
      }
      }
    }
  }
#line 769
  if (ctx->sr_code[1] > 0) {
#line 770
    if (ctx->sr_code[1] < 256) {
      {
      {
#line 771
      bitwriter_writebits(ctx->bw, 8, (uint32_t )ctx->sr_code[1]);
      }
      }
    } else {
      {
      {
#line 773
      bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->sr_code[1]);
      }
      }
    }
  }
  {
  {
#line 778
  bitwriter_flush(ctx->bw);
  }
  {
#line 779
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 779
  crc = calc_crc8((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 780
  bitwriter_writebits(ctx->bw, 8, (uint32_t )crc);
  }
  }
#line 781
  return;
}
}
#line 783 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_residual(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int j ;
  int p ;
  int k ;
  int porder ;
  int psize ;
  int res_cnt ;
  FlacFrame *frame ;
  FlacSubframe *sub ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 791
  frame = & ctx->frame;
#line 792
  sub = & frame->subframes[ch];
  {
#line 795
  bitwriter_writebits(ctx->bw, 2, (uint32_t )0);
  }
#line 798
  porder = sub->rc.porder;
#line 799
  psize = frame->blocksize >> porder;
  }
#line 800
  if (! (porder >= 0)) {
    {
    {
#line 800
    __assert_fail("porder >= 0", "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c",
                  800U, "output_residual");
    }
    }
  }
  {
  {
#line 801
  bitwriter_writebits(ctx->bw, 4, (uint32_t )porder);
  }
#line 802
  res_cnt = psize - sub->order;
#line 805
  j = sub->order;
#line 806
  p = 0;
  }
  {
  {
#line 806
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 806
    if (! (p < 1 << porder)) {
#line 806
      goto while_break;
    }
    {
#line 807
    k = sub->rc.params[p];
    {
#line 808
    bitwriter_writebits(ctx->bw, 4, (uint32_t )k);
    }
    }
#line 809
    if (p == 1) {
#line 809
      res_cnt = psize;
    }
#line 810
    i = 0;
    {
    {
#line 810
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 810
      if (i < res_cnt) {
#line 810
        if (! (j < frame->blocksize)) {
#line 810
          goto while_break___0;
        }
      } else {
#line 810
        goto while_break___0;
      }
      {
      {
#line 811
      bitwriter_write_rice_signed(ctx->bw, k, sub->residual[j]);
      }
#line 810
      i ++;
#line 810
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 806
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return;
}
}
#line 816 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_constant(FlacEncodeContext *ctx , int ch ) 
{ 
  FlacSubframe *sub ;

  {
  {
#line 821
  sub = & ctx->frame.subframes[ch];
  {
#line 822
  bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[0]);
  }
  }
#line 823
  return;
}
}
#line 825 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_verbatim(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int n ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 832
  frame = & ctx->frame;
#line 833
  sub = & frame->subframes[ch];
#line 834
  n = frame->blocksize;
#line 836
  i = 0;
  {
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < n)) {
#line 836
      goto while_break;
    }
    {
    {
#line 837
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 836
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 841 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_fixed(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 848
  frame = & ctx->frame;
#line 849
  sub = & frame->subframes[ch];
#line 852
  i = 0;
  {
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < sub->order)) {
#line 852
      goto while_break;
    }
    {
    {
#line 853
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 852
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 857
  output_residual(ctx, ch);
  }
  }
#line 858
  return;
}
}
#line 860 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_lpc(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int cbits ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 867
  frame = & ctx->frame;
#line 868
  sub = & frame->subframes[ch];
#line 871
  i = 0;
  {
  {
#line 871
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < sub->order)) {
#line 871
      goto while_break;
    }
    {
    {
#line 872
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 871
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 876
  cbits = ctx->lpc_precision;
  {
#line 877
  bitwriter_writebits(ctx->bw, 4, (uint32_t )(cbits - 1));
  }
  {
#line 878
  bitwriter_writebits_signed(ctx->bw, 5, sub->shift);
  }
#line 879
  i = 0;
  }
  {
  {
#line 879
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 879
    if (! (i < sub->order)) {
#line 879
      goto while_break___0;
    }
    {
    {
#line 880
    bitwriter_writebits_signed(ctx->bw, cbits, sub->coefs[i]);
    }
#line 879
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 884
  output_residual(ctx, ch);
  }
  }
#line 885
  return;
}
}
#line 887 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframes(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  int i ;
  int ch ;

  {
#line 893
  frame = & ctx->frame;
#line 895
  i = 0;
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    if (! (i < ctx->channels)) {
#line 895
      goto while_break;
    }
    {
#line 896
    ch = i;
    {
#line 899
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    {
#line 900
    bitwriter_writebits(ctx->bw, 6, (uint32_t )frame->subframes[ch].type_code);
    }
    {
#line 901
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    }
    {
#line 905
    if (frame->subframes[ch].type == 0) {
#line 905
      goto case_0;
    }
#line 907
    if (frame->subframes[ch].type == 1) {
#line 907
      goto case_1;
    }
#line 909
    if (frame->subframes[ch].type == 8) {
#line 909
      goto case_8;
    }
#line 911
    if (frame->subframes[ch].type == 32) {
#line 911
      goto case_32;
    }
#line 904
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 905
    output_subframe_constant(ctx, ch);
    }
    }
#line 906
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 907
    output_subframe_verbatim(ctx, ch);
    }
    }
#line 908
    goto switch_break;
    case_8: /* CIL Label */ 
    {
    {
#line 909
    output_subframe_fixed(ctx, ch);
    }
    }
#line 910
    goto switch_break;
    case_32: /* CIL Label */ 
    {
    {
#line 911
    output_subframe_lpc(ctx, ch);
    }
    }
#line 912
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 895
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_footer(FlacEncodeContext *ctx ) 
{ 
  uint16_t crc ;
  uint32_t tmp ;

  {
  {
  {
#line 921
  bitwriter_flush(ctx->bw);
  }
  {
#line 922
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 922
  crc = calc_crc16((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 923
  bitwriter_writebits(ctx->bw, 16, (uint32_t )crc);
  }
  {
#line 924
  bitwriter_flush(ctx->bw);
  }
  }
#line 925
  return;
}
}
#line 927 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
int encode_frame(FlakeContext *s , uint8_t *frame_buffer , int16_t *samples ) 
{ 
  int i ;
  int ch ;
  FlacEncodeContext *ctx ;
  int tmp ;
  int tmp___0 ;
  uint32_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 933
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 934
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 934
    return (-1);
  }
  {
#line 936
  ctx->params.block_size = s->params.block_size;
  {
#line 937
  tmp = init_frame(ctx);
  }
  }
#line 937
  if (tmp) {
#line 938
    return (-1);
  }
#line 940
  s->params.block_size = ctx->params.block_size;
#line 942
  if ((unsigned long )frame_buffer != (unsigned long )((void *)0)) {
    {
    {
#line 943
    update_md5_checksum(ctx, samples);
    }
    }
  }
  {
  {
#line 946
  copy_samples(ctx, samples);
  }
  {
#line 948
  channel_decorrelation(ctx);
  }
#line 950
  ch = 0;
  }
  {
  {
#line 950
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 950
    if (! (ch < ctx->channels)) {
#line 950
      goto while_break;
    }
    {
    {
#line 951
    tmp___0 = encode_residual(ctx, ch);
    }
    }
#line 951
    if (tmp___0 < 0) {
#line 952
      return (-1);
    }
#line 950
    ch ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 956
  bitwriter_init(ctx->bw, (void *)frame_buffer, ctx->max_frame_size);
  }
  {
#line 957
  output_frame_header(ctx);
  }
  {
#line 958
  output_subframes(ctx);
  }
  {
#line 959
  output_frame_footer(ctx);
  }
  }
#line 961
  if ((ctx->bw)->eof) {
#line 963
    i = 0;
    {
    {
#line 963
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 963
      if (! (i < ctx->channels)) {
#line 963
        goto while_break___0;
      }
      {
#line 964
      ch = i;
      {
#line 965
      reencode_residual_verbatim(ctx, ch);
      }
#line 963
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 967
    bitwriter_init(ctx->bw, (void *)frame_buffer, ctx->max_frame_size);
    }
    {
#line 968
    output_frame_header(ctx);
    }
    {
#line 969
    output_subframes(ctx);
    }
    {
#line 970
    output_frame_footer(ctx);
    }
    }
#line 973
    if (! (! (ctx->bw)->eof)) {
      {
      {
#line 973
      __assert_fail("!ctx->bw->eof", "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c",
                    973U, "encode_frame");
      }
      }
    }
  }
#line 975
  if ((unsigned long )frame_buffer != (unsigned long )((void *)0)) {
#line 976
    if (ctx->params.variable_block_size) {
#line 977
      ctx->frame_count += (uint32_t )s->params.block_size;
    } else {
#line 979
      (ctx->frame_count) ++;
    }
  }
  {
  {
#line 982
  tmp___1 = bitwriter_count(ctx->bw);
  }
  }
#line 982
  return ((int )tmp___1);
}
}
#line 985 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
int flake_encode_frame(FlakeContext *s , unsigned char *frame_buffer , short *samples ) 
{ 
  int fs ;
  FlacEncodeContext *ctx ;

  {
#line 991
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 992
  fs = -1;
#line 993
  if (ctx->params.variable_block_size > 0) {
#line 993
    if (! (s->params.block_size & 7)) {
#line 993
      if (s->params.block_size >= 128) {
        {
        {
#line 995
        fs = encode_frame_vbs(s, frame_buffer, samples);
        }
        }
      } else {
        {
        {
#line 997
        fs = encode_frame(s, frame_buffer, samples);
        }
        }
      }
    } else {
      {
      {
#line 997
      fs = encode_frame(s, frame_buffer, samples);
      }
      }
    }
  } else {
    {
    {
#line 997
    fs = encode_frame(s, frame_buffer, samples);
    }
    }
  }
#line 999
  return (fs);
}
}
#line 1002 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
void flake_encode_close(FlakeContext *s ) 
{ 
  FlacEncodeContext *ctx ;

  {
#line 1007
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1007
    return;
  }
#line 1008
  if ((unsigned long )s->private_ctx == (unsigned long )((void *)0)) {
#line 1008
    return;
  }
#line 1009
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 1010
  if (ctx) {
    {
    {
#line 1011
    md5_final(s->md5digest, & ctx->md5ctx);
    }
    }
#line 1012
    if (ctx->bw) {
      {
      {
#line 1012
      free((void *)ctx->bw);
      }
      }
    }
    {
    {
#line 1013
    free((void *)ctx);
    }
    }
  }
#line 1015
  if (s->header) {
    {
    {
#line 1015
    free((void *)s->header);
    }
    }
  }
#line 1016
  s->private_ctx = (void *)0;
#line 1017
  return;
}
}
#line 26 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.h"
void md5_update(MD5Context *ctx , void const   *data , uint32_t size ) ;
#line 33
void md5_print(uint8_t *digest ) ;
#line 54 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
static void const   *body(MD5Context *ctx , void const   *data , uint32_t size ) 
{ 
  uint8_t const   *ptr ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;

  {
#line 61
  ptr = (uint8_t const   *)data;
#line 63
  a = ctx->a;
#line 64
  b = ctx->b;
#line 65
  c = ctx->c;
#line 66
  d = ctx->d;
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 69
    saved_a = a;
#line 70
    saved_b = b;
#line 71
    saved_c = c;
#line 72
    saved_d = d;
#line 75
    tmp = (((uint32_t )*(ptr + 0) | ((uint32_t )*(ptr + 1) << 8)) | ((uint32_t )*(ptr + 2) << 16)) | ((uint32_t )*(ptr + 3) << 24);
#line 75
    ctx->block[0] = tmp;
#line 75
    a += ((d ^ (b & (c ^ d))) + tmp) + 3614090360U;
#line 75
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 75
    a += b;
#line 76
    tmp___0 = (((uint32_t )*(ptr + 4) | ((uint32_t )*(ptr + 5) << 8)) | ((uint32_t )*(ptr + 6) << 16)) | ((uint32_t )*(ptr + 7) << 24);
#line 76
    ctx->block[1] = tmp___0;
#line 76
    d += ((c ^ (a & (b ^ c))) + tmp___0) + 3905402710U;
#line 76
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 76
    d += a;
#line 77
    tmp___1 = (((uint32_t )*(ptr + 8) | ((uint32_t )*(ptr + 9) << 8)) | ((uint32_t )*(ptr + 10) << 16)) | ((uint32_t )*(ptr + 11) << 24);
#line 77
    ctx->block[2] = tmp___1;
#line 77
    c += ((b ^ (d & (a ^ b))) + tmp___1) + 606105819U;
#line 77
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 77
    c += d;
#line 78
    tmp___2 = (((uint32_t )*(ptr + 12) | ((uint32_t )*(ptr + 13) << 8)) | ((uint32_t )*(ptr + 14) << 16)) | ((uint32_t )*(ptr + 15) << 24);
#line 78
    ctx->block[3] = tmp___2;
#line 78
    b += ((a ^ (c & (d ^ a))) + tmp___2) + 3250441966U;
#line 78
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 78
    b += c;
#line 79
    tmp___3 = (((uint32_t )*(ptr + 16) | ((uint32_t )*(ptr + 17) << 8)) | ((uint32_t )*(ptr + 18) << 16)) | ((uint32_t )*(ptr + 19) << 24);
#line 79
    ctx->block[4] = tmp___3;
#line 79
    a += ((d ^ (b & (c ^ d))) + tmp___3) + 4118548399U;
#line 79
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 79
    a += b;
#line 80
    tmp___4 = (((uint32_t )*(ptr + 20) | ((uint32_t )*(ptr + 21) << 8)) | ((uint32_t )*(ptr + 22) << 16)) | ((uint32_t )*(ptr + 23) << 24);
#line 80
    ctx->block[5] = tmp___4;
#line 80
    d += ((c ^ (a & (b ^ c))) + tmp___4) + 1200080426U;
#line 80
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 80
    d += a;
#line 81
    tmp___5 = (((uint32_t )*(ptr + 24) | ((uint32_t )*(ptr + 25) << 8)) | ((uint32_t )*(ptr + 26) << 16)) | ((uint32_t )*(ptr + 27) << 24);
#line 81
    ctx->block[6] = tmp___5;
#line 81
    c += ((b ^ (d & (a ^ b))) + tmp___5) + 2821735955U;
#line 81
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 81
    c += d;
#line 82
    tmp___6 = (((uint32_t )*(ptr + 28) | ((uint32_t )*(ptr + 29) << 8)) | ((uint32_t )*(ptr + 30) << 16)) | ((uint32_t )*(ptr + 31) << 24);
#line 82
    ctx->block[7] = tmp___6;
#line 82
    b += ((a ^ (c & (d ^ a))) + tmp___6) + 4249261313U;
#line 82
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 82
    b += c;
#line 83
    tmp___7 = (((uint32_t )*(ptr + 32) | ((uint32_t )*(ptr + 33) << 8)) | ((uint32_t )*(ptr + 34) << 16)) | ((uint32_t )*(ptr + 35) << 24);
#line 83
    ctx->block[8] = tmp___7;
#line 83
    a += ((d ^ (b & (c ^ d))) + tmp___7) + 1770035416U;
#line 83
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 83
    a += b;
#line 84
    tmp___8 = (((uint32_t )*(ptr + 36) | ((uint32_t )*(ptr + 37) << 8)) | ((uint32_t )*(ptr + 38) << 16)) | ((uint32_t )*(ptr + 39) << 24);
#line 84
    ctx->block[9] = tmp___8;
#line 84
    d += ((c ^ (a & (b ^ c))) + tmp___8) + 2336552879U;
#line 84
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 84
    d += a;
#line 85
    tmp___9 = (((uint32_t )*(ptr + 40) | ((uint32_t )*(ptr + 41) << 8)) | ((uint32_t )*(ptr + 42) << 16)) | ((uint32_t )*(ptr + 43) << 24);
#line 85
    ctx->block[10] = tmp___9;
#line 85
    c += ((b ^ (d & (a ^ b))) + tmp___9) + 4294925233U;
#line 85
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 85
    c += d;
#line 86
    tmp___10 = (((uint32_t )*(ptr + 44) | ((uint32_t )*(ptr + 45) << 8)) | ((uint32_t )*(ptr + 46) << 16)) | ((uint32_t )*(ptr + 47) << 24);
#line 86
    ctx->block[11] = tmp___10;
#line 86
    b += ((a ^ (c & (d ^ a))) + tmp___10) + 2304563134U;
#line 86
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 86
    b += c;
#line 87
    tmp___11 = (((uint32_t )*(ptr + 48) | ((uint32_t )*(ptr + 49) << 8)) | ((uint32_t )*(ptr + 50) << 16)) | ((uint32_t )*(ptr + 51) << 24);
#line 87
    ctx->block[12] = tmp___11;
#line 87
    a += ((d ^ (b & (c ^ d))) + tmp___11) + 1804603682U;
#line 87
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 87
    a += b;
#line 88
    tmp___12 = (((uint32_t )*(ptr + 52) | ((uint32_t )*(ptr + 53) << 8)) | ((uint32_t )*(ptr + 54) << 16)) | ((uint32_t )*(ptr + 55) << 24);
#line 88
    ctx->block[13] = tmp___12;
#line 88
    d += ((c ^ (a & (b ^ c))) + tmp___12) + 4254626195U;
#line 88
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 88
    d += a;
#line 89
    tmp___13 = (((uint32_t )*(ptr + 56) | ((uint32_t )*(ptr + 57) << 8)) | ((uint32_t )*(ptr + 58) << 16)) | ((uint32_t )*(ptr + 59) << 24);
#line 89
    ctx->block[14] = tmp___13;
#line 89
    c += ((b ^ (d & (a ^ b))) + tmp___13) + 2792965006U;
#line 89
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 89
    c += d;
#line 90
    tmp___14 = (((uint32_t )*(ptr + 60) | ((uint32_t )*(ptr + 61) << 8)) | ((uint32_t )*(ptr + 62) << 16)) | ((uint32_t )*(ptr + 63) << 24);
#line 90
    ctx->block[15] = tmp___14;
#line 90
    b += ((a ^ (c & (d ^ a))) + tmp___14) + 1236535329U;
#line 90
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 90
    b += c;
#line 93
    a += ((c ^ (d & (b ^ c))) + ctx->block[1]) + 4129170786U;
#line 93
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 93
    a += b;
#line 94
    d += ((b ^ (c & (a ^ b))) + ctx->block[6]) + 3225465664U;
#line 94
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 94
    d += a;
#line 95
    c += ((a ^ (b & (d ^ a))) + ctx->block[11]) + 643717713U;
#line 95
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 95
    c += d;
#line 96
    b += ((d ^ (a & (c ^ d))) + ctx->block[0]) + 3921069994U;
#line 96
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 96
    b += c;
#line 97
    a += ((c ^ (d & (b ^ c))) + ctx->block[5]) + 3593408605U;
#line 97
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 97
    a += b;
#line 98
    d += ((b ^ (c & (a ^ b))) + ctx->block[10]) + 38016083U;
#line 98
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 98
    d += a;
#line 99
    c += ((a ^ (b & (d ^ a))) + ctx->block[15]) + 3634488961U;
#line 99
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 99
    c += d;
#line 100
    b += ((d ^ (a & (c ^ d))) + ctx->block[4]) + 3889429448U;
#line 100
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 100
    b += c;
#line 101
    a += ((c ^ (d & (b ^ c))) + ctx->block[9]) + 568446438U;
#line 101
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 101
    a += b;
#line 102
    d += ((b ^ (c & (a ^ b))) + ctx->block[14]) + 3275163606U;
#line 102
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 102
    d += a;
#line 103
    c += ((a ^ (b & (d ^ a))) + ctx->block[3]) + 4107603335U;
#line 103
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 103
    c += d;
#line 104
    b += ((d ^ (a & (c ^ d))) + ctx->block[8]) + 1163531501U;
#line 104
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 104
    b += c;
#line 105
    a += ((c ^ (d & (b ^ c))) + ctx->block[13]) + 2850285829U;
#line 105
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 105
    a += b;
#line 106
    d += ((b ^ (c & (a ^ b))) + ctx->block[2]) + 4243563512U;
#line 106
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 106
    d += a;
#line 107
    c += ((a ^ (b & (d ^ a))) + ctx->block[7]) + 1735328473U;
#line 107
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 107
    c += d;
#line 108
    b += ((d ^ (a & (c ^ d))) + ctx->block[12]) + 2368359562U;
#line 108
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 108
    b += c;
#line 111
    a += (((b ^ c) ^ d) + ctx->block[5]) + 4294588738U;
#line 111
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 111
    a += b;
#line 112
    d += (((a ^ b) ^ c) + ctx->block[8]) + 2272392833U;
#line 112
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 112
    d += a;
#line 113
    c += (((d ^ a) ^ b) + ctx->block[11]) + 1839030562U;
#line 113
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 113
    c += d;
#line 114
    b += (((c ^ d) ^ a) + ctx->block[14]) + 4259657740U;
#line 114
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 114
    b += c;
#line 115
    a += (((b ^ c) ^ d) + ctx->block[1]) + 2763975236U;
#line 115
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 115
    a += b;
#line 116
    d += (((a ^ b) ^ c) + ctx->block[4]) + 1272893353U;
#line 116
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 116
    d += a;
#line 117
    c += (((d ^ a) ^ b) + ctx->block[7]) + 4139469664U;
#line 117
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 117
    c += d;
#line 118
    b += (((c ^ d) ^ a) + ctx->block[10]) + 3200236656U;
#line 118
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 118
    b += c;
#line 119
    a += (((b ^ c) ^ d) + ctx->block[13]) + 681279174U;
#line 119
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 119
    a += b;
#line 120
    d += (((a ^ b) ^ c) + ctx->block[0]) + 3936430074U;
#line 120
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 120
    d += a;
#line 121
    c += (((d ^ a) ^ b) + ctx->block[3]) + 3572445317U;
#line 121
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 121
    c += d;
#line 122
    b += (((c ^ d) ^ a) + ctx->block[6]) + 76029189U;
#line 122
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 122
    b += c;
#line 123
    a += (((b ^ c) ^ d) + ctx->block[9]) + 3654602809U;
#line 123
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 123
    a += b;
#line 124
    d += (((a ^ b) ^ c) + ctx->block[12]) + 3873151461U;
#line 124
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 124
    d += a;
#line 125
    c += (((d ^ a) ^ b) + ctx->block[15]) + 530742520U;
#line 125
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 125
    c += d;
#line 126
    b += (((c ^ d) ^ a) + ctx->block[2]) + 3299628645U;
#line 126
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 126
    b += c;
#line 129
    a += ((c ^ (b | ~ d)) + ctx->block[0]) + 4096336452U;
#line 129
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 129
    a += b;
#line 130
    d += ((b ^ (a | ~ c)) + ctx->block[7]) + 1126891415U;
#line 130
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 130
    d += a;
#line 131
    c += ((a ^ (d | ~ b)) + ctx->block[14]) + 2878612391U;
#line 131
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 131
    c += d;
#line 132
    b += ((d ^ (c | ~ a)) + ctx->block[5]) + 4237533241U;
#line 132
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 132
    b += c;
#line 133
    a += ((c ^ (b | ~ d)) + ctx->block[12]) + 1700485571U;
#line 133
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 133
    a += b;
#line 134
    d += ((b ^ (a | ~ c)) + ctx->block[3]) + 2399980690U;
#line 134
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 134
    d += a;
#line 135
    c += ((a ^ (d | ~ b)) + ctx->block[10]) + 4293915773U;
#line 135
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 135
    c += d;
#line 136
    b += ((d ^ (c | ~ a)) + ctx->block[1]) + 2240044497U;
#line 136
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 136
    b += c;
#line 137
    a += ((c ^ (b | ~ d)) + ctx->block[8]) + 1873313359U;
#line 137
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 137
    a += b;
#line 138
    d += ((b ^ (a | ~ c)) + ctx->block[15]) + 4264355552U;
#line 138
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 138
    d += a;
#line 139
    c += ((a ^ (d | ~ b)) + ctx->block[6]) + 2734768916U;
#line 139
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 139
    c += d;
#line 140
    b += ((d ^ (c | ~ a)) + ctx->block[13]) + 1309151649U;
#line 140
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 140
    b += c;
#line 141
    a += ((c ^ (b | ~ d)) + ctx->block[4]) + 4149444226U;
#line 141
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 141
    a += b;
#line 142
    d += ((b ^ (a | ~ c)) + ctx->block[11]) + 3174756917U;
#line 142
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 142
    d += a;
#line 143
    c += ((a ^ (d | ~ b)) + ctx->block[2]) + 718787259U;
#line 143
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 143
    c += d;
#line 144
    b += ((d ^ (c | ~ a)) + ctx->block[9]) + 3951481745U;
#line 144
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 144
    b += c;
#line 146
    a += saved_a;
#line 147
    b += saved_b;
#line 148
    c += saved_c;
#line 149
    d += saved_d;
#line 151
    ptr += 64;
#line 68
    size -= 64U;
#line 68
    if (! size) {
#line 68
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  ctx->a = a;
#line 155
  ctx->b = b;
#line 156
  ctx->c = c;
#line 157
  ctx->d = d;
#line 159
  return ((void const   *)ptr);
}
}
#line 162 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
void md5_init(MD5Context *ctx ) 
{ 


  {
#line 165
  ctx->a = (uint32_t )1732584193;
#line 166
  ctx->b = 4023233417U;
#line 167
  ctx->c = 2562383102U;
#line 168
  ctx->d = (uint32_t )271733878;
#line 170
  ctx->lo = (uint32_t )0;
#line 171
  ctx->hi = (uint32_t )0;
#line 172
  return;
}
}
#line 174 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
void md5_update(MD5Context *ctx , void const   *data , uint32_t size ) 
{ 
  uint32_t saved_lo ;
  uint32_t used ;
  uint32_t free___0 ;
  uint32_t tmp ;

  {
#line 180
  saved_lo = ctx->lo;
#line 181
  tmp = (saved_lo + size) & 536870911U;
#line 181
  ctx->lo = tmp;
#line 181
  if (tmp < saved_lo) {
#line 182
    (ctx->hi) ++;
  }
#line 183
  ctx->hi += size >> 29;
#line 185
  used = saved_lo & 63U;
#line 187
  if (used) {
#line 188
    free___0 = 64U - used;
#line 190
    if (size < free___0) {
      {
      {
#line 191
      memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
             size);
      }
      }
#line 192
      return;
    }
    {
    {
#line 195
    memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
           free___0);
    }
#line 196
    data = (void const   *)((uint8_t *)data + free___0);
#line 197
    size -= free___0;
    {
#line 198
    body(ctx, (void const   *)(ctx->buffer), (uint32_t )64);
    }
    }
  }
#line 201
  if (size >= 64U) {
    {
    {
#line 202
    data = body(ctx, data, size & 4294967232U);
    }
#line 203
    size &= 63U;
    }
  }
  {
  {
#line 206
  memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)data,
         size);
  }
  }
#line 207
  return;
}
}
#line 209 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
void md5_final(uint8_t *result , MD5Context *ctx ) 
{ 
  uint32_t used ;
  uint32_t free___0 ;
  uint32_t tmp ;

  {
#line 214
  used = ctx->lo & 63U;
#line 216
  tmp = used;
#line 216
  used ++;
#line 216
  ctx->buffer[tmp] = (uint8_t )128;
#line 218
  free___0 = 64U - used;
#line 220
  if (free___0 < 8U) {
    {
    {
#line 221
    memset((void *)(& ctx->buffer[used]), 0, free___0);
    }
    {
#line 222
    body(ctx, (void const   *)(ctx->buffer), (uint32_t )64);
    }
#line 223
    used = (uint32_t )0;
#line 224
    free___0 = (uint32_t )64;
    }
  }
  {
  {
#line 227
  memset((void *)(& ctx->buffer[used]), 0, free___0 - 8U);
  }
#line 229
  ctx->lo <<= 3;
#line 230
  ctx->buffer[56] = (uint8_t )ctx->lo;
#line 231
  ctx->buffer[57] = (uint8_t )(ctx->lo >> 8);
#line 232
  ctx->buffer[58] = (uint8_t )(ctx->lo >> 16);
#line 233
  ctx->buffer[59] = (uint8_t )(ctx->lo >> 24);
#line 234
  ctx->buffer[60] = (uint8_t )ctx->hi;
#line 235
  ctx->buffer[61] = (uint8_t )(ctx->hi >> 8);
#line 236
  ctx->buffer[62] = (uint8_t )(ctx->hi >> 16);
#line 237
  ctx->buffer[63] = (uint8_t )(ctx->hi >> 24);
  {
#line 239
  body(ctx, (void const   *)(ctx->buffer), (uint32_t )64);
  }
#line 241
  *(result + 0) = (uint8_t )ctx->a;
#line 242
  *(result + 1) = (uint8_t )(ctx->a >> 8);
#line 243
  *(result + 2) = (uint8_t )(ctx->a >> 16);
#line 244
  *(result + 3) = (uint8_t )(ctx->a >> 24);
#line 245
  *(result + 4) = (uint8_t )ctx->b;
#line 246
  *(result + 5) = (uint8_t )(ctx->b >> 8);
#line 247
  *(result + 6) = (uint8_t )(ctx->b >> 16);
#line 248
  *(result + 7) = (uint8_t )(ctx->b >> 24);
#line 249
  *(result + 8) = (uint8_t )ctx->c;
#line 250
  *(result + 9) = (uint8_t )(ctx->c >> 8);
#line 251
  *(result + 10) = (uint8_t )(ctx->c >> 16);
#line 252
  *(result + 11) = (uint8_t )(ctx->c >> 24);
#line 253
  *(result + 12) = (uint8_t )ctx->d;
#line 254
  *(result + 13) = (uint8_t )(ctx->d >> 8);
#line 255
  *(result + 14) = (uint8_t )(ctx->d >> 16);
#line 256
  *(result + 15) = (uint8_t )(ctx->d >> 24);
  {
#line 258
  memset((void *)ctx, 0, (size_t )sizeof(*ctx));
  }
  }
#line 259
  return;
}
}
#line 264 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
void md5_accumulate(MD5Context *ctx , void const   *signal , int ch , int nsamples ) 
{ 
  int data_bytes ;

  {
  {
#line 267
  data_bytes = (ch * nsamples) * 2;
  {
#line 279
  md5_update(ctx, signal, (uint32_t )data_bytes);
  }
  }
#line 281
  return;
}
}
#line 283 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
void md5_print(uint8_t *digest ) 
{ 
  int i ;
  char *__cil_tmp3 ;

  {
#line 288
  i = 0;
  {
  {
#line 288
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 288
    if (! (i < 16)) {
#line 288
      goto while_break;
    }
    {
    {
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%02x",
            (int )*(digest + i));
    }
#line 288
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 44 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.h"
uint32_t calc_rice_params_fixed(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                                int n , int pred_order , int bps ) ;
#line 48
uint32_t calc_rice_params_lpc(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                              int n , int pred_order , int bps , int precision ) ;
#line 27 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.h"
int lpc_calc_coefs(int32_t const   *samples , int blocksize , int max_order , int precision ,
                   int omethod , int32_t (*coefs)[32] , int *shift ) ;
#line 28 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_verbatim(int32_t *res , int32_t *smp , int n ) 
{ 


  {
  {
  {
#line 31
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 32
  return;
}
}
#line 34 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_fixed(int32_t *res , int32_t *smp , int n , int order ) 
{ 
  int i ;

  {
  {
#line 40
  if (order == 0) {
#line 40
    goto case_0;
  }
#line 43
  if (order == 1) {
#line 43
    goto case_1;
  }
#line 49
  if (order == 2) {
#line 49
    goto case_2;
  }
#line 56
  if (order == 3) {
#line 56
    goto case_3;
  }
#line 64
  if (order == 4) {
#line 64
    goto case_4;
  }
#line 73
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 41
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 42
  return;
  case_1: /* CIL Label */ 
#line 44
  *(res + 0) = *(smp + 0);
#line 45
  i = 1;
  {
  {
#line 45
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < n)) {
#line 45
      goto while_break;
    }
#line 46
    *(res + i) = *(smp + i) - *(smp + (i - 1));
#line 45
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
  case_2: /* CIL Label */ 
#line 50
  *(res + 0) = *(smp + 0);
#line 51
  *(res + 1) = *(smp + 1);
#line 52
  i = 2;
  {
  {
#line 52
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 52
    if (! (i < n)) {
#line 52
      goto while_break___0;
    }
#line 53
    *(res + i) = (*(smp + i) - 2 * *(smp + (i - 1))) + *(smp + (i - 2));
#line 52
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  return;
  case_3: /* CIL Label */ 
#line 57
  *(res + 0) = *(smp + 0);
#line 58
  *(res + 1) = *(smp + 1);
#line 59
  *(res + 2) = *(smp + 2);
#line 60
  i = 3;
  {
  {
#line 60
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! (i < n)) {
#line 60
      goto while_break___1;
    }
#line 61
    *(res + i) = ((*(smp + i) - 3 * *(smp + (i - 1))) + 3 * *(smp + (i - 2))) - *(smp + (i - 3));
#line 60
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  return;
  case_4: /* CIL Label */ 
#line 65
  *(res + 0) = *(smp + 0);
#line 66
  *(res + 1) = *(smp + 1);
#line 67
  *(res + 2) = *(smp + 2);
#line 68
  *(res + 3) = *(smp + 3);
#line 69
  i = 4;
  {
  {
#line 69
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (i < n)) {
#line 69
      goto while_break___2;
    }
#line 70
    *(res + i) = (((*(smp + i) - 4 * *(smp + (i - 1))) + 6 * *(smp + (i - 2))) - 4 * *(smp + (i - 3))) + *(smp + (i - 4));
#line 69
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 72
  return;
  switch_default: /* CIL Label */ 
#line 73
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_lpc(int32_t *res , int32_t *smp , int n , int order ,
                                int32_t *coefs , int shift ) 
{ 
  int i ;
  int32_t pred ;

  {
#line 84
  i = 0;
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < order)) {
#line 84
      goto while_break;
    }
#line 85
    *(res + i) = *(smp + i);
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  i = order;
  {
  {
#line 87
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < n)) {
#line 87
      goto while_break___0;
    }
#line 88
    pred = 0;
    {
#line 92
    if (order == 32) {
#line 92
      goto case_32;
    }
#line 93
    if (order == 31) {
#line 93
      goto case_31;
    }
#line 94
    if (order == 30) {
#line 94
      goto case_30;
    }
#line 95
    if (order == 29) {
#line 95
      goto case_29;
    }
#line 96
    if (order == 28) {
#line 96
      goto case_28;
    }
#line 97
    if (order == 27) {
#line 97
      goto case_27;
    }
#line 98
    if (order == 26) {
#line 98
      goto case_26;
    }
#line 99
    if (order == 25) {
#line 99
      goto case_25;
    }
#line 100
    if (order == 24) {
#line 100
      goto case_24;
    }
#line 101
    if (order == 23) {
#line 101
      goto case_23;
    }
#line 102
    if (order == 22) {
#line 102
      goto case_22;
    }
#line 103
    if (order == 21) {
#line 103
      goto case_21;
    }
#line 104
    if (order == 20) {
#line 104
      goto case_20;
    }
#line 105
    if (order == 19) {
#line 105
      goto case_19;
    }
#line 106
    if (order == 18) {
#line 106
      goto case_18;
    }
#line 107
    if (order == 17) {
#line 107
      goto case_17;
    }
#line 108
    if (order == 16) {
#line 108
      goto case_16;
    }
#line 109
    if (order == 15) {
#line 109
      goto case_15;
    }
#line 110
    if (order == 14) {
#line 110
      goto case_14;
    }
#line 111
    if (order == 13) {
#line 111
      goto case_13;
    }
#line 112
    if (order == 12) {
#line 112
      goto case_12;
    }
#line 113
    if (order == 11) {
#line 113
      goto case_11;
    }
#line 114
    if (order == 10) {
#line 114
      goto case_10;
    }
#line 115
    if (order == 9) {
#line 115
      goto case_9;
    }
#line 116
    if (order == 8) {
#line 116
      goto case_8;
    }
#line 117
    if (order == 7) {
#line 117
      goto case_7;
    }
#line 118
    if (order == 6) {
#line 118
      goto case_6;
    }
#line 119
    if (order == 5) {
#line 119
      goto case_5;
    }
#line 120
    if (order == 4) {
#line 120
      goto case_4;
    }
#line 121
    if (order == 3) {
#line 121
      goto case_3;
    }
#line 122
    if (order == 2) {
#line 122
      goto case_2;
    }
#line 123
    if (order == 1) {
#line 123
      goto case_1;
    }
#line 125
    goto switch_default;
    case_32: /* CIL Label */ 
#line 92
    pred += *(coefs + 31) * *(smp + (i - 32));
    case_31: /* CIL Label */ 
#line 93
    pred += *(coefs + 30) * *(smp + (i - 31));
    case_30: /* CIL Label */ 
#line 94
    pred += *(coefs + 29) * *(smp + (i - 30));
    case_29: /* CIL Label */ 
#line 95
    pred += *(coefs + 28) * *(smp + (i - 29));
    case_28: /* CIL Label */ 
#line 96
    pred += *(coefs + 27) * *(smp + (i - 28));
    case_27: /* CIL Label */ 
#line 97
    pred += *(coefs + 26) * *(smp + (i - 27));
    case_26: /* CIL Label */ 
#line 98
    pred += *(coefs + 25) * *(smp + (i - 26));
    case_25: /* CIL Label */ 
#line 99
    pred += *(coefs + 24) * *(smp + (i - 25));
    case_24: /* CIL Label */ 
#line 100
    pred += *(coefs + 23) * *(smp + (i - 24));
    case_23: /* CIL Label */ 
#line 101
    pred += *(coefs + 22) * *(smp + (i - 23));
    case_22: /* CIL Label */ 
#line 102
    pred += *(coefs + 21) * *(smp + (i - 22));
    case_21: /* CIL Label */ 
#line 103
    pred += *(coefs + 20) * *(smp + (i - 21));
    case_20: /* CIL Label */ 
#line 104
    pred += *(coefs + 19) * *(smp + (i - 20));
    case_19: /* CIL Label */ 
#line 105
    pred += *(coefs + 18) * *(smp + (i - 19));
    case_18: /* CIL Label */ 
#line 106
    pred += *(coefs + 17) * *(smp + (i - 18));
    case_17: /* CIL Label */ 
#line 107
    pred += *(coefs + 16) * *(smp + (i - 17));
    case_16: /* CIL Label */ 
#line 108
    pred += *(coefs + 15) * *(smp + (i - 16));
    case_15: /* CIL Label */ 
#line 109
    pred += *(coefs + 14) * *(smp + (i - 15));
    case_14: /* CIL Label */ 
#line 110
    pred += *(coefs + 13) * *(smp + (i - 14));
    case_13: /* CIL Label */ 
#line 111
    pred += *(coefs + 12) * *(smp + (i - 13));
    case_12: /* CIL Label */ 
#line 112
    pred += *(coefs + 11) * *(smp + (i - 12));
    case_11: /* CIL Label */ 
#line 113
    pred += *(coefs + 10) * *(smp + (i - 11));
    case_10: /* CIL Label */ 
#line 114
    pred += *(coefs + 9) * *(smp + (i - 10));
    case_9: /* CIL Label */ 
#line 115
    pred += *(coefs + 8) * *(smp + (i - 9));
    case_8: /* CIL Label */ 
#line 116
    pred += *(coefs + 7) * *(smp + (i - 8));
    case_7: /* CIL Label */ 
#line 117
    pred += *(coefs + 6) * *(smp + (i - 7));
    case_6: /* CIL Label */ 
#line 118
    pred += *(coefs + 5) * *(smp + (i - 6));
    case_5: /* CIL Label */ 
#line 119
    pred += *(coefs + 4) * *(smp + (i - 5));
    case_4: /* CIL Label */ 
#line 120
    pred += *(coefs + 3) * *(smp + (i - 4));
    case_3: /* CIL Label */ 
#line 121
    pred += *(coefs + 2) * *(smp + (i - 3));
    case_2: /* CIL Label */ 
#line 122
    pred += *(coefs + 1) * *(smp + (i - 2));
    case_1: /* CIL Label */ 
#line 123
    pred += *(coefs + 0) * *(smp + (i - 1));
    switch_default: /* CIL Label */ 
#line 125
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 127
    *(res + i) = *(smp + i) - (pred >> shift);
#line 87
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
int encode_residual(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  FlacFrame *frame ;
  FlacSubframe *sub ;
  int32_t coefs[32][32] ;
  int shift[32] ;
  int n ;
  int max_order ;
  int opt_order ;
  int min_porder ;
  int max_porder ;
  int min_order ;
  int32_t *res ;
  int32_t *smp ;
  int est_order ;
  int omethod ;
  int tmp ;
  int tmp___0 ;
  uint32_t bits[5] ;
  uint32_t tmp___1 ;
  int levels ;
  uint32_t bits___0[8] ;
  int order ;
  int opt_index ;
  uint32_t bits___1[32] ;
  uint32_t bits___2[32] ;
  int step ;
  int last ;
  uint32_t tmp___2 ;
  void *__cil_tmp31 ;
  int __cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;

  {
#line 144
  frame = & ctx->frame;
#line 145
  sub = & frame->subframes[ch];
#line 146
  res = sub->residual;
#line 147
  smp = sub->samples;
#line 148
  n = frame->blocksize;
#line 151
  i = 1;
  {
  {
#line 151
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < n)) {
#line 151
      goto while_break;
    }
#line 152
    if (*(smp + i) != *(smp + 0)) {
#line 152
      goto while_break;
    }
#line 151
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (i == n) {
#line 155
    tmp = 0;
#line 155
    sub->type_code = tmp;
#line 155
    sub->type = tmp;
#line 156
    *(res + 0) = *(smp + 0);
#line 157
    return (sub->obits);
  }
#line 161
  if (n < 5) {
    {
#line 162
    tmp___0 = 1;
#line 162
    sub->type_code = tmp___0;
#line 162
    sub->type = tmp___0;
    {
#line 163
    encode_residual_verbatim(res, smp, n);
    }
    }
#line 164
    return (sub->obits * n);
  } else
#line 161
  if (ctx->params.prediction_type == 0) {
    {
#line 162
    tmp___0 = 1;
#line 162
    sub->type_code = tmp___0;
#line 162
    sub->type = tmp___0;
    {
#line 163
    encode_residual_verbatim(res, smp, n);
    }
    }
#line 164
    return (sub->obits * n);
  }
#line 167
  omethod = ctx->params.order_method;
#line 168
  min_order = ctx->params.min_prediction_order;
#line 169
  max_order = ctx->params.max_prediction_order;
#line 170
  opt_order = max_order;
#line 171
  min_porder = ctx->params.min_partition_order;
#line 172
  max_porder = ctx->params.max_partition_order;
#line 175
  if (ctx->params.prediction_type == 1) {
#line 175
    goto _L;
  } else
#line 175
  if (n <= max_order) {
    _L: /* CIL Label */ 
#line 177
    if (max_order > 4) {
#line 177
      max_order = 4;
    }
#line 178
    opt_order = min_order;
#line 179
    bits[opt_order] = 4294967295U;
#line 180
    i = min_order;
    {
    {
#line 180
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 180
      if (! (i <= max_order)) {
#line 180
        goto while_break___0;
      }
      {
      {
#line 181
      encode_residual_fixed(res, smp, n, i);
      }
      {
#line 182
      bits[i] = calc_rice_params_fixed(& sub->rc, min_porder, max_porder, res, n,
                                       i, sub->obits);
      }
      }
#line 184
      if (bits[i] < bits[opt_order]) {
#line 185
        opt_order = i;
      }
#line 180
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    sub->order = opt_order;
#line 189
    sub->type = 8;
#line 190
    sub->type_code = sub->type | sub->order;
#line 191
    if (sub->order != max_order) {
      {
      {
#line 192
      encode_residual_fixed(res, smp, n, sub->order);
      }
      {
#line 193
      tmp___1 = calc_rice_params_fixed(& sub->rc, min_porder, max_porder, res, n,
                                       sub->order, sub->obits);
      }
      }
#line 193
      return ((int )tmp___1);
    }
#line 196
    return ((int )bits[sub->order]);
  }
  {
  {
#line 200
  est_order = lpc_calc_coefs((int32_t const   *)smp, n, max_order, ctx->lpc_precision,
                             omethod, coefs, shift);
  }
  }
#line 203
  if (omethod == 0) {
#line 205
    opt_order = max_order;
  } else
#line 206
  if (omethod == 1) {
#line 208
    opt_order = est_order;
  } else
#line 209
  if (omethod == 2) {
#line 209
    goto _L___0;
  } else
#line 209
  if (omethod == 3) {
#line 209
    goto _L___0;
  } else
#line 209
  if (omethod == 4) {
    _L___0: /* CIL Label */ 
#line 212
    levels = 1 << (omethod - 1);
#line 215
    opt_index = levels - 1;
#line 216
    opt_order = max_order - 1;
#line 217
    bits___0[opt_index] = 4294967295U;
#line 218
    i = opt_index;
    {
    {
#line 218
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 218
      if (! (i >= 0)) {
#line 218
        goto while_break___1;
      }
#line 219
      order = (min_order + (((max_order - min_order) + 1) * (i + 1)) / levels) - 1;
#line 220
      if (order < 0) {
#line 220
        order = 0;
      }
      {
      {
#line 221
      encode_residual_lpc(res, smp, n, order + 1, coefs[order], shift[order]);
      }
      {
#line 222
      bits___0[i] = calc_rice_params_lpc(& sub->rc, min_porder, max_porder, res, n,
                                         order + 1, sub->obits, ctx->lpc_precision);
      }
      }
#line 225
      if (bits___0[i] < bits___0[opt_index]) {
#line 226
        opt_index = i;
#line 227
        opt_order = order;
      }
#line 218
      i --;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 230
    opt_order ++;
  } else
#line 231
  if (omethod == 5) {
#line 234
    opt_order = 0;
#line 235
    bits___1[0] = 4294967295U;
#line 236
    i = 0;
    {
    {
#line 236
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 236
      if (! (i < max_order)) {
#line 236
        goto while_break___2;
      }
      {
      {
#line 237
      encode_residual_lpc(res, smp, n, i + 1, coefs[i], shift[i]);
      }
      {
#line 238
      bits___1[i] = calc_rice_params_lpc(& sub->rc, min_porder, max_porder, res, n,
                                         i + 1, sub->obits, ctx->lpc_precision);
      }
      }
#line 241
      if (bits___1[i] < bits___1[opt_order]) {
#line 242
        opt_order = i;
      }
#line 236
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 245
    opt_order ++;
  } else
#line 246
  if (omethod == 6) {
    {
#line 251
    opt_order = (min_order - 1) + (max_order - min_order) / 3;
    {
#line 252
    memset((void *)(bits___2), -1, (size_t )sizeof(bits___2));
    }
#line 254
    step = 16;
    }
    {
    {
#line 254
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 254
      if (! (step > 0)) {
#line 254
        goto while_break___3;
      }
#line 255
      last = opt_order;
#line 256
      i = last - step;
      {
      {
#line 256
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 256
        if (! (i <= last + step)) {
#line 256
          goto while_break___4;
        }
#line 257
        if (i < min_order - 1) {
#line 258
          goto __Cont;
        } else
#line 257
        if (i >= max_order) {
#line 258
          goto __Cont;
        } else
#line 257
        if (bits___2[i] < 4294967295U) {
#line 258
          goto __Cont;
        }
        {
        {
#line 259
        encode_residual_lpc(res, smp, n, i + 1, coefs[i], shift[i]);
        }
        {
#line 260
        bits___2[i] = calc_rice_params_lpc(& sub->rc, min_porder, max_porder, res,
                                           n, i + 1, sub->obits, ctx->lpc_precision);
        }
        }
#line 263
        if (bits___2[i] < bits___2[opt_order]) {
#line 264
          opt_order = i;
        }
        __Cont: /* CIL Label */ 
#line 256
        i += step;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 254
      step >>= 1;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 268
    opt_order ++;
  } else {
#line 270
    return (-1);
  }
#line 273
  sub->order = opt_order;
#line 274
  sub->type = 32;
#line 275
  sub->type_code = sub->type | (sub->order - 1);
#line 276
  sub->shift = shift[sub->order - 1];
#line 277
  i = 0;
  {
  {
#line 277
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 277
    if (! (i < sub->order)) {
#line 277
      goto while_break___5;
    }
#line 278
    sub->coefs[i] = coefs[sub->order - 1][i];
#line 277
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
  {
#line 280
  encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift);
  }
  {
#line 281
  tmp___2 = calc_rice_params_lpc(& sub->rc, min_porder, max_porder, res, n, sub->order,
                                 sub->obits, ctx->lpc_precision);
  }
  }
#line 281
  return ((int )tmp___2);
}
}
#line 285 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
void reencode_residual_verbatim(FlacEncodeContext *ctx , int ch ) 
{ 
  FlacFrame *frame ;
  FlacSubframe *sub ;
  int tmp ;

  {
  {
#line 291
  frame = & ctx->frame;
#line 292
  sub = & frame->subframes[ch];
#line 294
  tmp = 1;
#line 294
  sub->type_code = tmp;
#line 294
  sub->type = tmp;
  {
#line 295
  encode_residual_verbatim(sub->residual, sub->samples, frame->blocksize);
  }
  }
#line 296
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static void crc_init_table(uint16_t *table , int bits , int poly ) 
{ 
  int i ;
  int j ;
  int crc ;

  {
#line 29
  poly += 1 << bits;
#line 30
  i = 0;
  {
  {
#line 30
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < 256)) {
#line 30
      goto while_break;
    }
#line 31
    crc = i;
#line 32
    j = 0;
    {
    {
#line 32
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 32
      if (! (j < bits)) {
#line 32
        goto while_break___0;
      }
#line 33
      if (crc & (1 << (bits - 1))) {
#line 34
        crc = (crc << 1) ^ poly;
      } else {
#line 36
        crc <<= 1;
      }
#line 32
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    *(table + i) = (uint16_t )(crc & ((1 << bits) - 1));
#line 30
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc8tab[256]  ;
#line 50 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc16tab[256]  ;
#line 52 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
void crc_init(void) 
{ 


  {
  {
  {
#line 55
  crc_init_table(crc8tab, 8, 7);
  }
  {
#line 56
  crc_init_table(crc16tab, 16, 32773);
  }
  }
#line 57
  return;
}
}
#line 59 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t calc_crc(uint16_t const   *table , int bits , uint8_t const   *data ,
                         uint32_t len ) 
{ 
  uint16_t crc ;
  uint16_t v1 ;
  uint16_t v2 ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 64
  crc = (uint16_t )0;
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    tmp___0 = len;
#line 65
    len --;
#line 65
    if (! tmp___0) {
#line 65
      goto while_break;
    }
#line 66
    v1 = (uint16_t )(((int )crc << 8) & ((1 << bits) - 1));
#line 67
    tmp = data;
#line 67
    data ++;
#line 67
    v2 = (uint16_t )(((int )crc >> (bits - 8)) ^ (int )*tmp);
#line 68
    if (! ((int )v2 < 256)) {
      {
      {
#line 68
      __assert_fail("v2 < 256", "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c",
                    68U, "calc_crc");
      }
      }
    }
#line 69
    crc = (uint16_t )((int )v1 ^ (int )*(table + v2));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (crc);
}
}
#line 74 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
uint8_t calc_crc8(uint8_t const   *data , uint32_t len ) 
{ 
  uint8_t crc ;
  uint16_t tmp ;

  {
#line 79
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 79
    return ((uint8_t )0);
  }
  {
  {
#line 81
  tmp = calc_crc((uint16_t const   *)(crc8tab), 8, data, len);
  }
#line 81
  crc = (uint8_t )tmp;
  }
#line 82
  return (crc);
}
}
#line 85 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
uint16_t calc_crc16(uint8_t const   *data , uint32_t len ) 
{ 
  uint16_t crc ;

  {
#line 90
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 90
    return ((uint16_t )0);
  }
  {
  {
#line 92
  crc = calc_crc((uint16_t const   *)(crc16tab), 16, data, len);
  }
  }
#line 93
  return (crc);
}
}
#line 36 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v1(int16_t *samples , int channels , int block_size , int *frames ,
                           int *sizes ) 
{ 
  int i ;
  int ch ;
  int j ;
  int n ;
  int64_t res[8] ;
  int layout[8] ;
  int16_t *sptr ;
  int16_t *sptr0 ;
  int16_t *sptr1 ;
  int16_t *sptr2 ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
#line 41
  n = block_size >> 3;
#line 47
  i = 0;
  {
  {
#line 47
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 8)) {
#line 47
      goto while_break;
    }
#line 48
    sptr = samples + (i * n) * channels;
#line 49
    res[i] = (int64_t )0;
#line 50
    ch = 0;
    {
    {
#line 50
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (ch < channels)) {
#line 50
        goto while_break___0;
      }
#line 51
      sptr0 = sptr + (2 * channels + ch);
#line 52
      sptr1 = sptr0 - channels;
#line 53
      sptr2 = sptr1 - channels;
#line 54
      j = 2;
      {
      {
#line 54
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (j < n)) {
#line 54
          goto while_break___1;
        }
        {
        {
#line 55
        tmp = abs(((int )*sptr0 - 2 * (int )*sptr1) + (int )*sptr2);
        }
#line 55
        res[i] += (int64_t )tmp;
#line 56
        sptr0 += channels;
#line 57
        sptr1 += channels;
#line 58
        sptr2 += channels;
#line 54
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 50
      ch ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    res[i] /= (int64_t )channels;
#line 62
    (res[i]) ++;
#line 47
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  memset((void *)(layout), 0, (size_t )(8UL * sizeof(int )));
  }
#line 67
  layout[0] = 1;
#line 68
  i = 0;
  }
  {
  {
#line 68
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 68
    if (! (i < 7)) {
#line 68
      goto while_break___2;
    }
    {
    {
#line 69
    tmp___0 = abs((int )(res[i] - res[i + 1]));
    }
    }
#line 69
    if ((int64_t )(tmp___0 * 200) / res[i] > 100L) {
#line 70
      layout[i + 1] = 1;
    }
#line 68
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  *(frames + 0) = 0;
  {
#line 76
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 77
  i = 0;
  }
  {
  {
#line 77
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 77
    if (! (i < 8)) {
#line 77
      goto while_break___3;
    }
#line 78
    if (layout[i]) {
#line 79
      (*(frames + 0)) ++;
    }
#line 81
    *(sizes + (*(frames + 0) - 1)) += n;
#line 77
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v2(FlakeContext *s , int16_t *samples , int *frames , int *sizes ) 
{ 
  int fsizes[4][8] ;
  int layout[8] ;
  int i ;
  int j ;
  int n ;
  int ch ;
  FlacEncodeContext *ctx ;
  int levels ;
  int bs ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 91
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 92
  ch = ctx->channels;
#line 95
  i = 0;
  {
  {
#line 95
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 4)) {
#line 95
      goto while_break;
    }
#line 97
    levels = 1 << i;
#line 98
    s->params.block_size /= levels;
#line 99
    bs = s->params.block_size;
#line 100
    j = 0;
    {
    {
#line 100
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < levels)) {
#line 100
        goto while_break___0;
      }
      {
      {
#line 101
      fsizes[i][j] = encode_frame(s, (uint8_t *)((void *)0), samples + (bs * j) * ch);
      }
#line 100
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    s->params.block_size *= levels;
#line 95
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = 0;
  {
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i < 8)) {
#line 107
      goto while_break___1;
    }
#line 107
    layout[i] = 1;
#line 107
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 109
  if (fsizes[2][0] < fsizes[3][0] + fsizes[3][1]) {
#line 110
    layout[1] = 0;
  }
#line 112
  if (fsizes[2][1] < fsizes[3][2] + fsizes[3][3]) {
#line 113
    layout[3] = 0;
  }
#line 115
  if (fsizes[2][2] < fsizes[3][4] + fsizes[3][5]) {
#line 116
    layout[5] = 0;
  }
#line 118
  if (fsizes[2][3] < fsizes[3][6] + fsizes[3][7]) {
#line 119
    layout[7] = 0;
  }
#line 122
  if (layout[1] == 0) {
#line 122
    if (layout[3] == 0) {
#line 123
      if (fsizes[1][0] < fsizes[2][0] + fsizes[2][1]) {
#line 124
        layout[2] = 0;
      }
    }
  }
#line 127
  if (layout[5] == 0) {
#line 127
    if (layout[7] == 0) {
#line 128
      if (fsizes[1][1] < fsizes[2][2] + fsizes[2][3]) {
#line 129
        layout[6] = 0;
      }
    }
  }
#line 133
  if (layout[2] == 0) {
#line 133
    if (layout[6] == 0) {
#line 134
      if (fsizes[0][0] < fsizes[1][0] + fsizes[1][1]) {
#line 135
        layout[4] = 0;
      }
    }
  }
  {
#line 140
  n = s->params.block_size >> 3;
#line 141
  *(frames + 0) = 0;
  {
#line 142
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 143
  i = 0;
  }
  {
  {
#line 143
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < 8)) {
#line 143
      goto while_break___2;
    }
#line 144
    if (layout[i]) {
#line 145
      (*(frames + 0)) ++;
    }
#line 147
    *(sizes + (*(frames + 0) - 1)) += n;
#line 143
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
int encode_frame_vbs(FlakeContext *s , uint8_t *frame_buffer , int16_t *samples ) 
{ 
  int fs ;
  int frames ;
  int sizes[8] ;
  FlacEncodeContext *ctx ;
  int i ;
  int fpos ;
  int spos ;
  int bs ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 159
  ctx = (FlacEncodeContext *)s->private_ctx;
  {
#line 162
  if (ctx->params.variable_block_size == 1) {
#line 162
    goto case_1;
  }
#line 164
  if (ctx->params.variable_block_size == 2) {
#line 164
    goto case_2;
  }
#line 166
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  {
#line 162
  split_frame_v1(samples, s->channels, s->params.block_size, & frames, (int *)(sizes));
  }
  }
#line 163
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 164
  split_frame_v2(s, samples, & frames, (int *)(sizes));
  }
  }
#line 165
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 166
  frames = 1;
#line 167
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 169
  if (frames > 1) {
#line 171
    fpos = 0;
#line 172
    spos = 0;
#line 173
    bs = s->params.block_size;
#line 174
    i = 0;
    {
    {
#line 174
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 174
      if (! (i < frames)) {
#line 174
        goto while_break;
      }
      {
#line 175
      s->params.block_size = sizes[i];
      {
#line 176
      fs = encode_frame(s, frame_buffer + fpos, samples + spos * ctx->channels);
      }
      }
#line 177
      if (fs < 0) {
#line 177
        return (-1);
      }
#line 178
      fpos += fs;
#line 179
      spos += sizes[i];
#line 174
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 181
    s->params.block_size = bs;
#line 182
    if (! (spos == bs)) {
      {
      {
#line 182
      __assert_fail("spos == bs", "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c",
                    182U, "encode_frame_vbs");
      }
      }
    }
#line 183
    return (fpos);
  }
  {
  {
#line 185
  fs = encode_frame(s, frame_buffer, samples);
  }
  }
#line 186
  return (fs);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 29 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
int find_optimal_rice_param(uint32_t sum , int n ) 
{ 
  int k ;
  int k_opt ;
  uint32_t nbits[15] ;
  void *__cil_tmp6 ;

  {
#line 35
  k_opt = 0;
#line 36
  nbits[0] = 4294967295U;
#line 37
  k = 0;
  {
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 37
    if (! (k <= 14)) {
#line 37
      goto while_break;
    }
#line 38
    nbits[k] = (uint32_t )(n * (k + 1)) + ((sum - (uint32_t )(n >> 1)) >> k);
#line 39
    if (nbits[k] < nbits[k_opt]) {
#line 40
      k_opt = k;
    }
#line 37
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (k_opt);
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_optimal_rice_params(RiceContext *rc , int porder , uint32_t *sums ,
                                         int n , int pred_order ) 
{ 
  int i ;
  int k ;
  int cnt ;
  int part ;
  uint32_t all_bits ;

  {
#line 54
  part = 1 << porder;
#line 55
  all_bits = (uint32_t )0;
#line 57
  cnt = (n >> porder) - pred_order;
#line 58
  i = 0;
  {
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < part)) {
#line 58
      goto while_break;
    }
#line 59
    if (i == 1) {
#line 59
      cnt = n >> porder;
    }
    {
    {
#line 60
    k = find_optimal_rice_param(*(sums + i), cnt);
    }
#line 61
    rc->params[i] = k;
#line 62
    all_bits += (uint32_t )(cnt * (k + 1)) + ((*(sums + i) - (uint32_t )(cnt >> 1)) >> k);
#line 58
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  all_bits += (uint32_t )(4 * part);
#line 66
  rc->porder = porder;
#line 68
  return (all_bits);
}
}
#line 71 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static void calc_sums(int pmin , int pmax , uint32_t *data , int n , int pred_order ,
                      uint32_t (*sums)[1 << 8] ) 
{ 
  int i ;
  int j ;
  int parts ;
  int cnt ;
  uint32_t *res ;

  {
#line 80
  parts = 1 << pmax;
#line 81
  res = data + pred_order;
#line 82
  cnt = (n >> pmax) - pred_order;
#line 83
  i = 0;
  {
  {
#line 83
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < parts)) {
#line 83
      goto while_break;
    }
#line 84
    if (i == 1) {
#line 84
      cnt = n >> pmax;
    }
#line 85
    if (i > 0) {
#line 85
      res = data + i * cnt;
    }
#line 86
    (*(sums + pmax))[i] = (uint32_t )0;
#line 87
    j = 0;
    {
    {
#line 87
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 87
      if (! (j < cnt)) {
#line 87
        goto while_break___0;
      }
#line 88
      (*(sums + pmax))[i] += *(res + j);
#line 87
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = pmax - 1;
  {
  {
#line 92
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (i >= pmin)) {
#line 92
      goto while_break___1;
    }
#line 93
    parts = 1 << i;
#line 94
    j = 0;
    {
    {
#line 94
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (j < parts)) {
#line 94
        goto while_break___2;
      }
#line 95
      (*(sums + i))[j] = (*(sums + (i + 1)))[2 * j] + (*(sums + (i + 1)))[2 * j + 1];
#line 94
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 92
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_rice_params(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                                 int n , int pred_order ) 
{ 
  int i ;
  uint32_t bits[9] ;
  int opt_porder ;
  RiceContext tmp_rc ;
  uint32_t *udata ;
  uint32_t sums[9][1 << 8] ;
  void *tmp ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 111
  if (pmin >= 0) {
#line 111
    if (! (pmin <= 8)) {
      {
      {
#line 111
      __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    111U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 111
    __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  111U, "calc_rice_params");
    }
    }
  }
#line 112
  if (pmax >= 0) {
#line 112
    if (! (pmax <= 8)) {
      {
      {
#line 112
      __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    112U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 112
    __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  112U, "calc_rice_params");
    }
    }
  }
#line 113
  if (! (pmin <= pmax)) {
    {
    {
#line 113
    __assert_fail("pmin <= pmax", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  113U, "calc_rice_params");
    }
    }
  }
  {
  {
#line 115
  tmp = malloc((size_t )((unsigned long )n * sizeof(uint32_t )));
  }
#line 115
  udata = (uint32_t *)tmp;
#line 116
  i = 0;
  }
  {
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < n)) {
#line 116
      goto while_break;
    }
#line 117
    *(udata + i) = (uint32_t )(2 * *(data + i) ^ (*(data + i) >> 31));
#line 116
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 120
  calc_sums(pmin, pmax, udata, n, pred_order, sums);
  }
#line 122
  opt_porder = pmin;
#line 123
  bits[pmin] = 4294967295U;
#line 124
  i = pmin;
  }
  {
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (i <= pmax)) {
#line 124
      goto while_break___0;
    }
    {
    {
#line 125
    bits[i] = calc_optimal_rice_params(& tmp_rc, i, sums[i], n, pred_order);
    }
    }
#line 126
    if (bits[i] <= bits[opt_porder]) {
#line 127
      opt_porder = i;
#line 128
      *rc = tmp_rc;
    }
#line 124
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 132
  free((void *)udata);
  }
  }
#line 133
  return (bits[opt_porder]);
}
}
#line 136 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static int get_max_p_order(int max_porder , int n , int order ) 
{ 
  int porder ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 139
  tmp___2 = log2i((uint32_t )(n ^ (n - 1)));
  }
  }
#line 139
  if (max_porder > tmp___2) {
    {
    {
#line 139
    tmp___0 = log2i((uint32_t )(n ^ (n - 1)));
    }
#line 139
    tmp___1 = tmp___0;
    }
  } else {
#line 139
    tmp___1 = max_porder;
  }
#line 139
  porder = tmp___1;
#line 140
  if (order > 0) {
    {
    {
#line 141
    tmp___5 = log2i((uint32_t )(n / order));
    }
    }
#line 141
    if (porder > tmp___5) {
      {
      {
#line 141
      tmp___4 = log2i((uint32_t )(n / order));
      }
#line 141
      porder = tmp___4;
      }
    } else {
#line 141
      porder = porder;
    }
  }
#line 142
  return (porder);
}
}
#line 145 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
uint32_t calc_rice_params_fixed(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                                int n , int pred_order , int bps ) 
{ 
  uint32_t bits ;
  uint32_t tmp ;

  {
  {
  {
#line 150
  pmin = get_max_p_order(pmin, n, pred_order);
  }
  {
#line 151
  pmax = get_max_p_order(pmax, n, pred_order);
  }
#line 152
  bits = (uint32_t )(pred_order * bps + 6);
  {
#line 153
  tmp = calc_rice_params(rc, pmin, pmax, data, n, pred_order);
  }
#line 153
  bits += tmp;
  }
#line 154
  return (bits);
}
}
#line 157 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
uint32_t calc_rice_params_lpc(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                              int n , int pred_order , int bps , int precision ) 
{ 
  uint32_t bits ;
  uint32_t tmp ;

  {
  {
  {
#line 162
  pmin = get_max_p_order(pmin, n, pred_order);
  }
  {
#line 163
  pmax = get_max_p_order(pmax, n, pred_order);
  }
#line 164
  bits = (uint32_t )((((pred_order * bps + 4) + 5) + pred_order * precision) + 6);
  {
#line 165
  tmp = calc_rice_params(rc, pmin, pmax, data, n, pred_order);
  }
#line 165
  bits += tmp;
  }
#line 166
  return (bits);
}
}
#line 182 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 28 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
__inline static void apply_welch_window(int32_t const   *data , int len , double *w_data ) 
{ 
  int i ;
  double c ;
  double w ;

  {
#line 34
  c = 2.0 / ((double )len - 1.0) - 1.0;
#line 35
  i = 0;
  {
  {
#line 35
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 35
    if (! (i < len >> 1)) {
#line 35
      goto while_break;
    }
#line 36
    w = 1.0 - (c - (double )i) * (c - (double )i);
#line 37
    *(w_data + i) = (double )*(data + i) * w;
#line 38
    *(w_data + ((len - 1) - i)) = (double )*(data + ((len - 1) - i)) * w;
#line 35
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_autocorr(int32_t const   *data , int len , int lag , double *autoc ) 
{ 
  int i ;
  int j ;
  double *data1 ;
  double temp ;
  double temp2 ;
  void *tmp ;

  {
  {
  {
#line 53
  tmp = malloc((size_t )((unsigned long )(len + 16) * sizeof(double )));
  }
#line 53
  data1 = (double *)tmp;
  {
#line 54
  apply_welch_window(data, len, data1);
  }
#line 55
  *(data1 + len) = (double )0;
#line 57
  i = 0;
  }
  {
  {
#line 57
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= lag)) {
#line 57
      goto while_break;
    }
#line 58
    temp = 1.0;
#line 59
    temp2 = 1.0;
#line 60
    j = 0;
    {
    {
#line 60
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (j <= lag - i)) {
#line 60
        goto while_break___0;
      }
#line 61
      temp += *(data1 + (j + i)) * *(data1 + j);
#line 60
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    j = lag + 1;
    {
    {
#line 63
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 63
      if (! (j <= len - 1)) {
#line 63
        goto while_break___1;
      }
#line 64
      temp += *(data1 + j) * *(data1 + (j - i));
#line 65
      temp2 += *(data1 + (j + 1)) * *(data1 + ((j + 1) - i));
#line 63
      j += 2;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 67
    *(autoc + i) = temp + temp2;
#line 57
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 70
  free((void *)data1);
  }
  }
#line 71
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_lpc_coefs(double const   *autoc , int max_order , double *ref ,
                              double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  int i2 ;
  double r ;
  double err ;
  double tmp ;
  double lpc_tmp[32] ;
  void *__cil_tmp12 ;

  {
#line 85
  i = 0;
  {
  {
#line 85
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < max_order)) {
#line 85
      goto while_break;
    }
#line 85
    lpc_tmp[i] = (double )0;
#line 85
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  err = 1.0;
#line 87
  if (autoc) {
#line 88
    err = (double )*(autoc + 0);
  }
#line 91
  i = 0;
  {
  {
#line 91
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < max_order)) {
#line 91
      goto while_break___0;
    }
#line 92
    if (ref) {
#line 93
      r = *(ref + i);
    } else {
#line 95
      r = (double )(- *(autoc + (i + 1)));
#line 96
      j = 0;
      {
      {
#line 96
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 96
        if (! (j < i)) {
#line 96
          goto while_break___1;
        }
#line 97
        r -= lpc_tmp[j] * (double )*(autoc + (i - j));
#line 96
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 99
      r /= err;
#line 100
      err *= 1.0 - r * r;
    }
#line 103
    i2 = i >> 1;
#line 104
    lpc_tmp[i] = r;
#line 105
    j = 0;
    {
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 105
      if (! (j < i2)) {
#line 105
        goto while_break___2;
      }
#line 106
      tmp = lpc_tmp[j];
#line 107
      lpc_tmp[j] += r * lpc_tmp[(i - 1) - j];
#line 108
      lpc_tmp[(i - 1) - j] += r * tmp;
#line 105
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 110
    if (i & 1) {
#line 111
      lpc_tmp[j] += lpc_tmp[j] * r;
    }
#line 114
    j = 0;
    {
    {
#line 114
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 114
      if (! (j <= i)) {
#line 114
        goto while_break___3;
      }
#line 115
      (*(lpc + i))[j] = - lpc_tmp[j];
#line 114
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 91
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 126 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static int compute_lpc_coefs_est(double const   *autoc , int max_order , double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  double error ;
  double gen[2][32] ;
  double ref[32] ;
  int order_est ;
  double tmp ;
  double tmp___0 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 137
  i = 0;
  {
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < max_order)) {
#line 137
      goto while_break;
    }
#line 137
    tmp = (double )*(autoc + (i + 1));
#line 137
    gen[1][i] = tmp;
#line 137
    gen[0][i] = tmp;
#line 137
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  error = (double )*(autoc + 0);
#line 139
  ref[0] = - gen[1][0] / error;
#line 140
  error += gen[1][0] * ref[0];
#line 141
  i = 1;
  {
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (i < max_order)) {
#line 141
      goto while_break___0;
    }
#line 142
    j = 0;
    {
    {
#line 142
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 142
      if (! (j < max_order - i)) {
#line 142
        goto while_break___1;
      }
#line 143
      gen[1][j] = gen[1][j + 1] + ref[i - 1] * gen[0][j];
#line 144
      gen[0][j] = gen[1][j + 1] * ref[i - 1] + gen[0][j];
#line 142
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 146
    ref[i] = - gen[1][0] / error;
#line 147
    error += gen[1][0] * ref[i];
#line 141
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  order_est = 1;
#line 152
  i = max_order - 1;
  {
  {
#line 152
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 152
    if (! (i >= 0)) {
#line 152
      goto while_break___2;
    }
    {
    {
#line 153
    tmp___0 = fabs(ref[i]);
    }
    }
#line 153
    if (tmp___0 > 0.10) {
#line 154
      order_est = i + 1;
#line 155
      goto while_break___2;
    }
#line 152
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 160
  compute_lpc_coefs((double const   *)((void *)0), order_est, ref, lpc);
  }
  }
#line 162
  return (order_est);
}
}
#line 168 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void quantize_lpc_coefs(double *lpc_in , int order , int precision , int32_t *lpc_out ,
                               int *shift ) 
{ 
  int i ;
  double d ;
  double cmax ;
  double error ;
  int32_t qmax ;
  int sh ;
  int q ;
  double scale ;

  {
#line 178
  qmax = (1 << (precision - 1)) - 1;
#line 181
  cmax = 0.0;
#line 182
  i = 0;
  {
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < order)) {
#line 182
      goto while_break;
    }
    {
    {
#line 183
    d = fabs(*(lpc_in + i));
    }
    }
#line 184
    if (d > cmax) {
#line 185
      cmax = d;
    }
#line 182
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (cmax * (double )(1 << 15) < 1.0) {
    {
#line 189
    *shift = 0;
    {
#line 190
    memset((void *)lpc_out, 0, (size_t )(sizeof(int32_t ) * (unsigned long )order));
    }
    }
#line 191
    return;
  }
#line 195
  sh = 15;
  {
  {
#line 196
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 196
    if (cmax * (double )(1 << sh) > (double )qmax) {
#line 196
      if (! (sh > 0)) {
#line 196
        goto while_break___0;
      }
    } else {
#line 196
      goto while_break___0;
    }
#line 197
    sh --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  if (sh == 0) {
#line 202
    if (cmax > (double )qmax) {
#line 203
      scale = (double )qmax / cmax;
#line 204
      i = 0;
      {
      {
#line 204
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i < order)) {
#line 204
          goto while_break___1;
        }
#line 205
        *(lpc_in + i) *= scale;
#line 204
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 210
  error = (double )0;
#line 211
  i = 0;
  {
  {
#line 211
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 211
    if (! (i < order)) {
#line 211
      goto while_break___2;
    }
#line 212
    error += *(lpc_in + i) * (double )(1 << sh);
#line 213
    q = (int )(error + 0.5);
#line 214
    if (q <= - qmax) {
#line 214
      q = - qmax + 1;
    }
#line 215
    if (q > qmax) {
#line 215
      q = qmax;
    }
#line 216
    error -= (double )q;
#line 217
    *(lpc_out + i) = q;
#line 211
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 219
  *shift = sh;
#line 220
  return;
}
}
#line 225 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
int lpc_calc_coefs(int32_t const   *samples , int blocksize , int max_order , int precision ,
                   int omethod , int32_t (*coefs)[32] , int *shift ) 
{ 
  double autoc[33] ;
  double lpc[32][32] ;
  int i ;
  int opt_order ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  int __cil_tmp14 ;
  void *__cil_tmp15 ;

  {
  {
  {
#line 235
  compute_autocorr(samples, blocksize, max_order + 1, autoc);
  }
#line 237
  opt_order = max_order;
  }
#line 238
  if (omethod == 1) {
    {
    {
#line 239
    opt_order = compute_lpc_coefs_est((double const   *)(autoc), max_order, lpc);
    }
    }
  } else {
    {
    {
#line 241
    compute_lpc_coefs((double const   *)(autoc), max_order, (double *)((void *)0),
                      lpc);
    }
    }
  }
  {
#line 246
  if (omethod == 1) {
#line 246
    goto case_1;
  }
#line 246
  if (omethod == 0) {
#line 246
    goto case_1;
  }
#line 250
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 247
  i = opt_order - 1;
  {
#line 248
  quantize_lpc_coefs(lpc[i], i + 1, precision, *(coefs + i), shift + i);
  }
  }
#line 249
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 251
  i = 0;
  {
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < max_order)) {
#line 251
      goto while_break;
    }
    {
    {
#line 252
    quantize_lpc_coefs(lpc[i], i + 1, precision, *(coefs + i), shift + i);
    }
#line 251
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 257
  return (opt_order);
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 404
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strnlen)(char const   *s ,
                                                                                       size_t maxlen )  __attribute__((__pure__)) ;
#line 38 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_usage(FILE *out ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 41
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"usage: flake [options] <input.wav> [-o output.flac]\ntype \'flake -h\' for more details.\n\n");
  }
  }
#line 43
  return;
}
}
#line 45 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_help(FILE *out ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 48
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"usage: flake [options] <input.wav> [-o output.flac]\noptions:\n       [-h]         Print out list of commandline options\n       [-q]         Quiet mode\n       [-p #]       Padding bytes to put in header (default: 4096)\n       [-0 ... -12] Compression level (default: 5)\n                        0 = -b 1152 -t 1 -l 2,2 -m 0 -r 4,4 -s 0\n                        1 = -b 1152 -t 1 -l 3,4 -m 1 -r 2,2 -s 1\n                        2 = -b 1152 -t 1 -l 2,4 -m 1 -r 3   -s 1\n                        3 = -b 4608 -t 2 -l 6   -m 1 -r 3   -s 1\n                        4 = -b 4608 -t 2 -l 8   -m 1 -r 3   -s 1\n                        5 = -b 4608 -t 2 -l 8   -m 1 -r 6   -s 1\n                        6 = -b 4608 -t 2 -l 8   -m 2 -r 8   -s 1\n                        7 = -b 4608 -t 2 -l 8   -m 3 -r 8   -s 1\n                        8 = -b 4608 -t 2 -l 12  -m 3 -r 8   -s 1\n                        9 = -b 4608 -t 2 -l 12  -m 6 -r 8   -s 1\n                       10 = -b 4608 -t 2 -l 12  -m 5 -r 8   -s 1\n                       11 = -b 4608 -t 2 -l 32  -m 6 -r 8   -s 1\n                       12 = -b 4608 -t 2 -l 32  -m 5 -r 8   -s 1\n       [-b #]       Block size [16 - 65535] (default: 4608)\n       [-t #]       Prediction type\n                        0 = no prediction / verbatim\n                        1 = fixed prediction\n                        2 = Levinson-Durbin recursion (default)\n       [-l #[,#]]   Prediction order {max} or {min},{max} (default: 1,8)\n       [-m #]       Prediction order selection method\n                        0 = maximum\n                        1 = estimate (default)\n                        2 = 2-level\n                        3 = 4-level\n                        4 = 8-level\n                        5 = full search\n                        6 = log search\n       [-r #[,#]]   Rice partition order {max} or {min},{max} (default: 0,6)\n       [-s #]       Stereo decorrelation method\n                        0 = independent L+R channels\n                        1 = mid-side (default)\n       [-v #]       Variable block size\n                        0 = fixed (default)\n                        1 = variable, method 1\n                        2 = variable, method 2\n\n");
  }
  }
#line 90
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int parse_number(char *arg , int max ) 
{ 
  int i ;
  int m ;
  int n ;
  int digits ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 120
  m = 0;
#line 121
  n = 0;
#line 123
  i = 0;
  {
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < max)) {
#line 123
      goto while_break;
    }
#line 124
    if ((int )*(arg + i) == 0) {
#line 124
      goto while_break;
    }
#line 125
    if (m == 0) {
#line 125
      m = 1;
    } else {
#line 126
      m *= 10;
    }
#line 123
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((int )*(arg + i) != 0) {
#line 128
    return (-1);
  }
#line 129
  digits = i;
#line 130
  i = 0;
  {
  {
#line 130
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (i < digits)) {
#line 130
      goto while_break___0;
    }
#line 131
    if ((int )*(arg + i) < 48) {
      {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid digit: %c (ASCII:0x%02X)\n",
              (int )*(arg + i), (int )*(arg + i));
      }
      }
#line 133
      return (-1);
    } else
#line 131
    if ((int )*(arg + i) > 57) {
      {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid digit: %c (ASCII:0x%02X)\n",
              (int )*(arg + i), (int )*(arg + i));
      }
      }
#line 133
      return (-1);
    }
#line 135
    n += ((int )*(arg + i) - 48) * m;
#line 136
    m /= 10;
#line 130
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  return (n);
}
}
#line 145
static int parse_commandline(int argc , char **argv , CommandOptions *opts ) ;
#line 145 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static char const   *param_str  =    "bhlmopqrstv";
#line 141 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int parse_commandline(int argc , char **argv , CommandOptions *opts ) 
{ 
  int i ;
  int max_digits ;
  int ifc ;
  void *tmp ;
  char *tmp___0 ;
  char *po ;
  char *tmp___1 ;
  char *tmp___2 ;
  int olen ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *po___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int ext ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 146
  max_digits = 8;
#line 147
  ifc = 0;
#line 149
  opts->filelist = (FilePair *)((void *)0);
#line 150
  if (argc < 2) {
#line 151
    return (1);
  }
  {
  {
#line 154
  tmp = calloc((size_t )((unsigned long )argc * sizeof(FilePair )), (size_t )1);
  }
#line 154
  opts->filelist = (FilePair *)tmp;
#line 155
  opts->input_count = 0;
#line 156
  opts->found_output = 0;
#line 157
  opts->compr = 5;
#line 158
  opts->omethod = -1;
#line 159
  opts->ptype = -1;
#line 160
  opts->omin = -1;
#line 161
  opts->omax = -1;
#line 162
  opts->pomin = -1;
#line 163
  opts->pomax = -1;
#line 164
  opts->bsize = -1;
#line 165
  opts->stmethod = -1;
#line 166
  opts->padding = -1;
#line 167
  opts->vbs = -1;
#line 168
  opts->quiet = 0;
#line 170
  i = 1;
  }
  {
  {
#line 170
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < argc)) {
#line 170
      goto while_break;
    }
#line 171
    if ((int )*(*(argv + i) + 0) == 45) {
#line 171
      if ((int )*(*(argv + i) + 1) != 0) {
#line 172
        if ((int )*(*(argv + i) + 1) >= 48) {
#line 172
          if ((int )*(*(argv + i) + 1) <= 57) {
#line 173
            if ((int )*(*(argv + i) + 2) != 0) {
#line 173
              if ((int )*(*(argv + i) + 3) != 0) {
#line 174
                (opts->filelist + ifc)->infile = *(argv + i);
#line 175
                ifc ++;
              } else {
#line 173
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
              {
#line 177
              opts->compr = parse_number(*(argv + i) + 1, max_digits);
              }
              }
#line 178
              if (opts->compr < 0) {
#line 178
                return (1);
              }
            }
          } else {
#line 172
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 183
          if ((int )*(*(argv + i) + 2) != 0) {
#line 184
            (opts->filelist + ifc)->infile = *(argv + i);
#line 185
            ifc ++;
#line 186
            goto __Cont;
          }
          {
          {
#line 189
          tmp___0 = strchr(param_str, (int )*(*(argv + i) + 1));
          }
          }
#line 189
          if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
            {
            {
#line 190
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid option: -%c\n",
                    (int )*(*(argv + i) + 1));
            }
            }
#line 191
            return (1);
          }
#line 194
          if ((int )*(*(argv + i) + 1) == 104) {
#line 195
            return (2);
          }
#line 197
          i ++;
#line 198
          if (i >= argc) {
            {
            {
#line 199
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"incomplete option: -%c\n",
                    (int )*(*(argv + (i - 1)) + 1));
            }
            }
#line 200
            return (1);
          }
          {
#line 204
          if ((int )*(*(argv + (i - 1)) + 1) == 98) {
#line 204
            goto case_98;
          }
#line 208
          if ((int )*(*(argv + (i - 1)) + 1) == 108) {
#line 208
            goto case_108;
          }
#line 228
          if ((int )*(*(argv + (i - 1)) + 1) == 109) {
#line 228
            goto case_109;
          }
#line 232
          if ((int )*(*(argv + (i - 1)) + 1) == 111) {
#line 232
            goto case_111;
          }
#line 242
          if ((int )*(*(argv + (i - 1)) + 1) == 112) {
#line 242
            goto case_112;
          }
#line 246
          if ((int )*(*(argv + (i - 1)) + 1) == 113) {
#line 246
            goto case_113;
          }
#line 250
          if ((int )*(*(argv + (i - 1)) + 1) == 114) {
#line 250
            goto case_114;
          }
#line 264
          if ((int )*(*(argv + (i - 1)) + 1) == 115) {
#line 264
            goto case_115;
          }
#line 268
          if ((int )*(*(argv + (i - 1)) + 1) == 116) {
#line 268
            goto case_116;
          }
#line 272
          if ((int )*(*(argv + (i - 1)) + 1) == 118) {
#line 272
            goto case_118;
          }
#line 203
          goto switch_break;
          case_98: /* CIL Label */ 
          {
          {
#line 205
          opts->bsize = parse_number(*(argv + i), max_digits);
          }
          }
#line 206
          if (opts->bsize < 0) {
#line 206
            return (1);
          }
#line 207
          goto switch_break;
          case_108: /* CIL Label */ 
          {
          {
#line 209
          tmp___2 = strchr((char const   *)*(argv + i), ',');
          }
          }
#line 209
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
#line 210
            opts->omin = 0;
            {
#line 211
            opts->omax = parse_number(*(argv + i), max_digits);
            }
            }
#line 212
            if (opts->omax < 0) {
#line 212
              return (1);
            }
          } else {
            {
            {
#line 214
            tmp___1 = strchr((char const   *)*(argv + i), ',');
            }
#line 214
            po = tmp___1;
#line 215
            *(po + 0) = (char )'\000';
            {
#line 216
            opts->omin = parse_number(*(argv + i), max_digits);
            }
            }
#line 217
            if (opts->omin < 0) {
#line 217
              return (1);
            }
            {
            {
#line 218
            opts->omax = parse_number(po + 1, max_digits);
            }
            }
#line 219
            if (opts->omax < 0) {
#line 219
              return (1);
            }
          }
#line 222
          if (opts->ptype == 1) {
#line 223
            if (opts->omax > 4) {
#line 223
              opts->omax = 4;
            }
          } else
#line 224
          if (opts->ptype == 2) {
#line 225
            if (opts->omin == 0) {
#line 225
              opts->omin = 1;
            }
          }
#line 227
          goto switch_break;
          case_109: /* CIL Label */ 
          {
          {
#line 229
          opts->omethod = parse_number(*(argv + i), max_digits);
          }
          }
#line 230
          if (opts->omethod < 0) {
#line 230
            return (1);
          }
#line 231
          goto switch_break;
          case_111: /* CIL Label */ 
#line 233
          if (opts->found_output) {
#line 234
            return (1);
          } else {
            {
            {
#line 236
            tmp___3 = strnlen((char const   *)*(argv + i), (size_t )4096);
            }
#line 236
            olen = (int )(tmp___3 + 1U);
            {
#line 237
            tmp___4 = calloc((size_t )1, (size_t )(olen + 5));
            }
#line 237
            (opts->filelist + 0)->outfile = (char *)tmp___4;
            {
#line 238
            strncpy((char */* __restrict  */)(opts->filelist + 0)->outfile, (char const   */* __restrict  */)*(argv + i),
                    (size_t )olen);
            }
#line 239
            opts->found_output = 1;
            }
          }
#line 241
          goto switch_break;
          case_112: /* CIL Label */ 
          {
          {
#line 243
          opts->padding = parse_number(*(argv + i), max_digits);
          }
          }
#line 244
          if (opts->padding < 0) {
#line 244
            return (1);
          }
#line 245
          goto switch_break;
          case_113: /* CIL Label */ 
#line 247
          i --;
#line 248
          opts->quiet = 1;
#line 249
          goto switch_break;
          case_114: /* CIL Label */ 
          {
          {
#line 251
          tmp___6 = strchr((char const   *)*(argv + i), ',');
          }
          }
#line 251
          if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
            {
#line 252
            opts->pomin = 0;
            {
#line 253
            opts->pomax = parse_number(*(argv + i), max_digits);
            }
            }
#line 254
            if (opts->pomax < 0) {
#line 254
              return (1);
            }
          } else {
            {
            {
#line 256
            tmp___5 = strchr((char const   *)*(argv + i), ',');
            }
#line 256
            po___0 = tmp___5;
#line 257
            *(po___0 + 0) = (char )'\000';
            {
#line 258
            opts->pomin = parse_number(*(argv + i), max_digits);
            }
            }
#line 259
            if (opts->pomin < 0) {
#line 259
              return (1);
            }
            {
            {
#line 260
            opts->pomax = parse_number(po___0 + 1, max_digits);
            }
            }
#line 261
            if (opts->pomax < 0) {
#line 261
              return (1);
            }
          }
#line 263
          goto switch_break;
          case_115: /* CIL Label */ 
          {
          {
#line 265
          opts->stmethod = parse_number(*(argv + i), max_digits);
          }
          }
#line 266
          if (opts->stmethod < 0) {
#line 266
            return (1);
          }
#line 267
          goto switch_break;
          case_116: /* CIL Label */ 
          {
          {
#line 269
          opts->ptype = parse_number(*(argv + i), max_digits);
          }
          }
#line 270
          if (opts->ptype < 0) {
#line 270
            return (1);
          }
#line 271
          goto switch_break;
          case_118: /* CIL Label */ 
          {
          {
#line 273
          opts->vbs = parse_number(*(argv + i), max_digits);
          }
          }
#line 274
          if (opts->vbs < 0) {
#line 274
            return (1);
          }
#line 275
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
#line 281
        (opts->filelist + ifc)->infile = *(argv + i);
#line 282
        ifc ++;
      }
    } else {
#line 281
      (opts->filelist + ifc)->infile = *(argv + i);
#line 282
      ifc ++;
    }
    __Cont: /* CIL Label */ 
#line 170
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (! ifc) {
    {
    {
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error parsing filenames.\n");
    }
    }
#line 287
    return (1);
  }
#line 289
  if (opts->found_output) {
#line 289
    if (ifc > 1) {
      {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot specify output file when using multiple input files\n");
      }
      }
#line 291
      return (1);
    }
  }
#line 293
  if (! opts->found_output) {
#line 295
    i = 0;
    {
    {
#line 295
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (i < ifc)) {
#line 295
        goto while_break___0;
      }
      {
      {
#line 296
      tmp___7 = strnlen((char const   *)(opts->filelist + i)->infile, (size_t )4096);
      }
#line 296
      ext = (int )tmp___7;
      {
#line 297
      tmp___8 = calloc((size_t )1, (size_t )(ext + 6));
      }
#line 297
      (opts->filelist + i)->outfile = (char *)tmp___8;
      {
#line 298
      strncpy((char */* __restrict  */)(opts->filelist + i)->outfile, (char const   */* __restrict  */)(opts->filelist + i)->infile,
              (size_t )(ext + 1));
      }
#line 299
      *((opts->filelist + i)->outfile + ext) = (char )'\000';
      }
      {
      {
#line 300
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 300
        if (ext > 0) {
#line 300
          if (! ((int )*((opts->filelist + i)->outfile + ext) != 46)) {
#line 300
            goto while_break___1;
          }
        } else {
#line 300
          goto while_break___1;
        }
#line 300
        ext --;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 301
      if (ext >= 4091) {
        {
        {
#line 302
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input filename too long\n");
        }
        }
#line 303
        return (1);
      }
      {
      {
#line 305
      strncpy((char */* __restrict  */)((opts->filelist + i)->outfile + ext), (char const   */* __restrict  */)".flac",
              (size_t )6);
      }
#line 295
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 310
  i = 0;
  {
  {
#line 310
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 310
    if (! (i < ifc)) {
#line 310
      goto while_break___2;
    }
    {
    {
#line 311
    tmp___10 = strncmp((char const   *)(opts->filelist + i)->infile, "-", (size_t )2);
    }
    }
#line 311
    if (tmp___10) {
      {
      {
#line 311
      tmp___11 = strncmp((char const   *)(opts->filelist + i)->outfile, "-", (size_t )2);
      }
      }
#line 311
      if (tmp___11) {
        {
        {
#line 312
        tmp___9 = strcmp((char const   *)(opts->filelist + i)->infile, (char const   *)(opts->filelist + i)->outfile);
        }
        }
#line 312
        if (! tmp___9) {
          {
          {
#line 313
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output filename cannot match input filename\n");
          }
          }
#line 314
          return (1);
        }
      }
    }
#line 310
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 319
  opts->input_count = ifc;
#line 320
  return (0);
}
}
#line 323 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_params(FlakeContext *s ) 
{ 
  char *omethod_s ;
  char *stmethod_s ;
  char *ptype_s ;
  char *vbs_s ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 328
  vbs_s = (char *)"ERROR";
  {
#line 330
  if (s->params.variable_block_size == 0) {
#line 330
    goto case_0;
  }
#line 331
  if (s->params.variable_block_size == 1) {
#line 331
    goto case_1;
  }
#line 332
  if (s->params.variable_block_size == 2) {
#line 332
    goto case_2;
  }
#line 329
  goto switch_break;
  case_0: /* CIL Label */ 
#line 330
  vbs_s = (char *)"none";
#line 330
  goto switch_break;
  case_1: /* CIL Label */ 
#line 331
  vbs_s = (char *)"method 1";
#line 331
  goto switch_break;
  case_2: /* CIL Label */ 
#line 332
  vbs_s = (char *)"method 2";
#line 332
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 334
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"variable block size: %s\n",
          vbs_s);
  }
#line 335
  ptype_s = (char *)"ERROR";
  }
  {
#line 337
  if (s->params.prediction_type == 0) {
#line 337
    goto case_0___0;
  }
#line 338
  if (s->params.prediction_type == 1) {
#line 338
    goto case_1___0;
  }
#line 339
  if (s->params.prediction_type == 2) {
#line 339
    goto case_2___0;
  }
#line 336
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 337
  ptype_s = (char *)"none (verbatim mode)";
#line 337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 338
  ptype_s = (char *)"fixed";
#line 338
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 339
  ptype_s = (char *)"levinson-durbin";
#line 339
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
  {
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prediction type: %s\n",
          ptype_s);
  }
  }
#line 342
  if (s->params.prediction_type != 0) {
    {
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prediction order: %d,%d\n",
            s->params.min_prediction_order, s->params.max_prediction_order);
    }
    {
#line 345
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"partition order: %d,%d\n",
            s->params.min_partition_order, s->params.max_partition_order);
    }
#line 347
    omethod_s = (char *)"ERROR";
    }
    {
#line 349
    if (s->params.order_method == 0) {
#line 349
      goto case_0___1;
    }
#line 350
    if (s->params.order_method == 1) {
#line 350
      goto case_1___1;
    }
#line 351
    if (s->params.order_method == 2) {
#line 351
      goto case_2___1;
    }
#line 352
    if (s->params.order_method == 3) {
#line 352
      goto case_3;
    }
#line 353
    if (s->params.order_method == 4) {
#line 353
      goto case_4;
    }
#line 354
    if (s->params.order_method == 5) {
#line 354
      goto case_5;
    }
#line 355
    if (s->params.order_method == 6) {
#line 355
      goto case_6;
    }
#line 348
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 349
    omethod_s = (char *)"maximum";
#line 349
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 350
    omethod_s = (char *)"estimate";
#line 350
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 351
    omethod_s = (char *)"2-level";
#line 351
    goto switch_break___1;
    case_3: /* CIL Label */ 
#line 352
    omethod_s = (char *)"4-level";
#line 352
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 353
    omethod_s = (char *)"8-level";
#line 353
    goto switch_break___1;
    case_5: /* CIL Label */ 
#line 354
    omethod_s = (char *)"full search";
#line 354
    goto switch_break___1;
    case_6: /* CIL Label */ 
#line 355
    omethod_s = (char *)"log search";
#line 355
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
    {
#line 357
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"order method: %s\n",
            omethod_s);
    }
    }
  }
#line 359
  if (s->channels == 2) {
#line 360
    stmethod_s = (char *)"ERROR";
    {
#line 362
    if (s->params.stereo_method == 0) {
#line 362
      goto case_0___2;
    }
#line 363
    if (s->params.stereo_method == 1) {
#line 363
      goto case_1___2;
    }
#line 361
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
#line 362
    stmethod_s = (char *)"independent";
#line 362
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
#line 363
    stmethod_s = (char *)"mid-side";
#line 363
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stereo method: %s\n",
            stmethod_s);
    }
    }
  }
  {
  {
#line 367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"header padding: %d\n",
          s->params.padding_size);
  }
  }
#line 368
  return;
}
}
#line 370 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int encode_file(CommandOptions *opts , FilePair *files , int first_file ) 
{ 
  FlakeContext s ;
  WavFile wf ;
  int header_size ;
  int subset ;
  int bs_zero ;
  uint8_t *frame ;
  int16_t *wav ;
  int percent ;
  uint32_t nr ;
  uint32_t fs ;
  uint32_t samplecount ;
  uint32_t bytecount ;
  int t0 ;
  int t1 ;
  float kb ;
  float sec ;
  float kbps ;
  float wav_bytes ;
  int tmp ;
  int tmp___0 ;
  int64_t tms ;
  int th ;
  int tm ;
  int ts ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t sc ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
  {
#line 383
  tmp = wavfile_init(& wf, files->ifp);
  }
  }
#line 383
  if (tmp) {
    {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid input file: %s\n",
            files->infile);
    }
    }
#line 385
    return (1);
  }
  {
#line 387
  wf.read_format = (enum WavSampleFormat )1;
#line 390
  s.channels = wf.channels;
#line 391
  s.sample_rate = wf.sample_rate;
#line 392
  s.bits_per_sample = 16;
#line 393
  s.samples = wf.samples;
#line 396
  s.params.compression = opts->compr;
  {
#line 397
  tmp___0 = flake_set_defaults(& s.params);
  }
  }
#line 397
  if (tmp___0) {
#line 398
    return (1);
  }
#line 400
  if (opts->bsize >= 0) {
#line 400
    s.params.block_size = opts->bsize;
  }
#line 401
  if (opts->omethod >= 0) {
#line 401
    s.params.order_method = opts->omethod;
  }
#line 402
  if (opts->stmethod >= 0) {
#line 402
    s.params.stereo_method = opts->stmethod;
  }
#line 403
  if (opts->ptype >= 0) {
#line 403
    s.params.prediction_type = opts->ptype;
  }
#line 404
  if (opts->omin >= 0) {
#line 404
    s.params.min_prediction_order = opts->omin;
  }
#line 405
  if (opts->omax >= 0) {
#line 405
    s.params.max_prediction_order = opts->omax;
  }
#line 406
  if (opts->pomin >= 0) {
#line 406
    s.params.min_partition_order = opts->pomin;
  }
#line 407
  if (opts->pomax >= 0) {
#line 407
    s.params.max_partition_order = opts->pomax;
  }
#line 408
  if (opts->padding >= 0) {
#line 408
    s.params.padding_size = opts->padding;
  }
#line 409
  if (opts->vbs >= 0) {
#line 409
    s.params.variable_block_size = opts->vbs;
  }
  {
  {
#line 411
  subset = flake_validate_params(& s);
  }
  }
#line 412
  if (subset < 0) {
    {
    {
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: invalid encoding parameters.\n");
    }
    }
#line 414
    return (1);
  }
  {
#line 416
  bs_zero = s.params.block_size == 0;
  {
#line 419
  header_size = flake_encode_init(& s);
  }
  }
#line 420
  if (header_size < 0) {
    {
    {
#line 421
    flake_encode_close(& s);
    }
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error initializing encoder.\n");
    }
    }
#line 423
    return (1);
  }
  {
  {
#line 425
  fwrite((void const   */* __restrict  */)s.header, (size_t )1, (size_t )header_size,
         (FILE */* __restrict  */)files->ofp);
  }
  }
#line 428
  if (first_file) {
#line 428
    if (! opts->quiet) {
#line 429
      if (subset == 1) {
        {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n WARNING! The chosen encoding options are\n not FLAC Subset compliant. Therefore, the\n encoded file(s) may not work properly with\n some FLAC players and decoders.\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n");
        }
        }
      }
#line 437
      if (bs_zero) {
        {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block time: %dms\n",
                s.params.block_time_ms);
        }
        }
      } else {
        {
        {
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block size: %d\n",
                s.params.block_size);
        }
        }
      }
      {
      {
#line 442
      print_params(& s);
      }
      }
    }
  }
#line 445
  if (! opts->quiet) {
    {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file:  \"%s\"\n",
            files->infile);
    }
    {
#line 448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output file: \"%s\"\n",
            files->outfile);
    }
    {
#line 449
    wavfile_print(stderr, & wf);
    }
    }
#line 450
    if (wf.bit_width != 16) {
      {
      {
#line 451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING! converting to 16-bit (not lossless)\n");
      }
      }
    }
#line 453
    if (wf.samples > 0U) {
      {
#line 456
      tms = (int64_t )(((double )wf.samples * 1000.0) / (double )wf.sample_rate);
#line 457
      ts = (int )(tms / 1000L);
#line 458
      tms %= 1000L;
#line 459
      tm = ts / 60;
#line 460
      ts %= 60;
#line 461
      th = tm / 60;
#line 462
      tm %= 60;
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"samples: %u (",
              wf.samples);
      }
      }
#line 464
      if (th) {
        {
        {
#line 464
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dh",
                th);
        }
        }
      }
      {
      {
#line 465
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dm",
              tm);
      }
      {
#line 466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d.%03ds)\n",
              ts, (int )tms);
      }
      }
    } else {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"samples: unknown\n");
      }
      }
    }
#line 470
    if (bs_zero) {
      {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block size: %d\n",
              s.params.block_size);
      }
      }
    }
  }
  {
  {
#line 475
  tmp___1 = malloc((size_t )s.max_frame_size);
  }
#line 475
  frame = (uint8_t *)tmp___1;
  {
#line 476
  tmp___2 = malloc((size_t )((unsigned long )(s.params.block_size * wf.channels) * sizeof(int16_t )));
  }
#line 476
  wav = (int16_t *)tmp___2;
#line 478
  percent = 0;
#line 478
  t0 = percent;
#line 478
  samplecount = (uint32_t )t0;
#line 479
  wav_bytes = (float )0;
#line 480
  bytecount = (uint32_t )header_size;
  {
#line 481
  tmp___3 = wavfile_read_samples(& wf, (void *)wav, s.params.block_size);
  }
#line 481
  nr = (uint32_t )tmp___3;
  }
  {
  {
#line 482
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 482
    if (! (nr > 0U)) {
#line 482
      goto while_break;
    }
    {
#line 483
    s.params.block_size = (int )nr;
    {
#line 484
    tmp___4 = flake_encode_frame(& s, frame, wav);
    }
#line 484
    fs = (uint32_t )tmp___4;
    }
#line 485
    if (fs < 0U) {
      {
      {
#line 486
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error encoding frame\n");
      }
      }
    } else
#line 487
    if (fs > 0U) {
      {
      {
#line 488
      fwrite((void const   */* __restrict  */)frame, (size_t )1, fs, (FILE */* __restrict  */)files->ofp);
      }
#line 489
      samplecount += (uint32_t )s.params.block_size;
#line 490
      bytecount += fs;
#line 491
      t1 = (int )(samplecount / (uint32_t )s.sample_rate);
      }
#line 492
      if (t1 > t0) {
#line 493
        kb = (float )(((double )bytecount * 8.0) / 1000.0);
#line 494
        sec = (float )samplecount / (float )s.sample_rate;
#line 495
        if (samplecount > 0U) {
#line 495
          kbps = kb / sec;
        } else {
#line 496
          kbps = kb;
        }
#line 497
        if (s.samples > 0U) {
#line 498
          percent = (int )(((double )samplecount * 100.5) / (double )s.samples);
        }
#line 500
        wav_bytes = (float )(samplecount * (uint32_t )wf.block_align);
#line 501
        if (! opts->quiet) {
          {
          {
#line 502
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rprogress: %3d%% | ratio: %1.3f | bitrate: %4.1f kbps ",
                  percent, (double )((float )bytecount / wav_bytes), (double )kbps);
          }
          }
        }
      }
#line 507
      t0 = t1;
    }
    {
    {
#line 509
    tmp___5 = wavfile_read_samples(& wf, (void *)wav, s.params.block_size);
    }
#line 509
    nr = (uint32_t )tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if (! opts->quiet) {
    {
    {
#line 512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| bytes: %d \n\n",
            bytecount);
    }
    }
  }
  {
  {
#line 515
  flake_encode_close(& s);
  }
  {
#line 518
  tmp___7 = fseek(files->ofp, 22L, 0);
  }
  }
#line 518
  if (! tmp___7) {
    {
    {
#line 519
    tmp___6 = bswap_32(samplecount);
    }
#line 519
    sc = tmp___6;
    {
#line 520
    fwrite((void const   */* __restrict  */)(& sc), (size_t )4, (size_t )1, (FILE */* __restrict  */)files->ofp);
    }
    {
#line 521
    fwrite((void const   */* __restrict  */)(s.md5digest), (size_t )1, (size_t )16,
           (FILE */* __restrict  */)files->ofp);
    }
    }
  }
  {
  {
#line 524
  free((void *)wav);
  }
  {
#line 525
  free((void *)frame);
  }
  }
#line 527
  return (0);
}
}
#line 530 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int open_files(FilePair *files ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 533
  tmp = strncmp((char const   *)files->infile, "-", (size_t )2);
  }
  }
#line 533
  if (tmp) {
    {
    {
#line 539
    files->ifp = fopen((char const   */* __restrict  */)files->infile, (char const   */* __restrict  */)"rb");
    }
    }
#line 540
    if (! files->ifp) {
      {
      {
#line 541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening input file: %s\n",
              files->infile);
      }
      }
#line 542
      return (1);
    }
  } else {
#line 537
    files->ifp = stdin;
  }
  {
  {
#line 545
  tmp___0 = strncmp((char const   *)files->outfile, "-", (size_t )2);
  }
  }
#line 545
  if (tmp___0) {
    {
    {
#line 551
    files->ofp = fopen((char const   */* __restrict  */)files->outfile, (char const   */* __restrict  */)"wb");
    }
    }
#line 552
    if (! files->ofp) {
      {
      {
#line 553
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening output file: %s\n",
              files->outfile);
      }
      }
#line 554
      return (1);
    }
  } else {
#line 549
    files->ofp = stdout;
  }
#line 557
  return (0);
}
}
#line 560 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void filelist_cleanup(CommandOptions *opts ) 
{ 
  int i ;

  {
#line 565
  if (opts->filelist) {
#line 566
    i = 0;
    {
    {
#line 566
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 566
      if (! (i < opts->input_count)) {
#line 566
        goto while_break;
      }
#line 567
      if ((opts->filelist + i)->outfile) {
        {
        {
#line 567
        free((void *)(opts->filelist + i)->outfile);
        }
        }
      }
#line 566
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 569
    free((void *)opts->filelist);
    }
    }
  }
#line 571
  return;
}
}
#line 573 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
int main(int argc , char **argv ) 
{ 
  CommandOptions opts ;
  int i ;
  int err ;
  int tmp ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 579
  memset((void *)(& opts), 0, (size_t )sizeof(CommandOptions ));
  }
  {
#line 580
  err = parse_commandline(argc, argv, & opts);
  }
  }
#line 581
  if (! opts.quiet) {
    {
    {
#line 582
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFlake: FLAC audio encoder\nversion 0.11\n(c) 2006-2007 Justin Ruggles\n\n");
    }
    }
  }
#line 586
  if (err == 2) {
    {
    {
#line 587
    print_help(stdout);
    }
    {
#line 588
    filelist_cleanup(& opts);
    }
    }
#line 589
    return (0);
  } else
#line 590
  if (err) {
    {
    {
#line 591
    print_usage(stderr);
    }
    {
#line 592
    filelist_cleanup(& opts);
    }
    }
#line 593
    return (1);
  }
#line 596
  i = 0;
  {
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 596
    if (! (i < opts.input_count)) {
#line 596
      goto while_break;
    }
    {
    {
#line 597
    tmp = open_files(opts.filelist + i);
    }
    }
#line 597
    if (tmp) {
#line 598
      err = 1;
#line 599
      goto while_break;
    }
    {
    {
#line 601
    err = encode_file(& opts, opts.filelist + i, i == 0);
    }
    {
#line 602
    fclose((opts.filelist + i)->ofp);
    }
    {
#line 603
    fclose((opts.filelist + i)->ifp);
    }
    }
#line 604
    if (err) {
#line 604
      goto while_break;
    }
#line 596
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 607
  filelist_cleanup(& opts);
  }
  }
#line 609
  return (err);
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_u8___1(uint8_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  int16_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 184
  if ((int )fmt == 0) {
    {
    {
#line 185
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )n);
    }
    }
  } else
#line 186
  if ((int )fmt == 1) {
#line 187
    src = (int16_t *)src_v;
#line 188
    i = 0;
    {
    {
#line 188
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < n)) {
#line 188
        goto while_break;
      }
#line 189
      *(dest + i) = (uint8_t )(((int )*(src + i) >> 8) + 128);
#line 188
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 191
  if ((int )fmt == 2) {
#line 192
    src___0 = (int32_t *)src_v;
#line 193
    i = 0;
    {
    {
#line 193
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (i < n)) {
#line 193
        goto while_break___0;
      }
#line 194
      *(dest + i) = (uint8_t )((*(src___0 + i) >> 12) + 128);
#line 193
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 196
  if ((int )fmt == 3) {
#line 197
    src___1 = (int32_t *)src_v;
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (i < n)) {
#line 198
        goto while_break___1;
      }
#line 199
      *(dest + i) = (uint8_t )((*(src___1 + i) >> 16) + 128);
#line 198
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 201
  if ((int )fmt == 4) {
#line 202
    src___2 = (int32_t *)src_v;
#line 203
    i = 0;
    {
    {
#line 203
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 203
      if (! (i < n)) {
#line 203
        goto while_break___2;
      }
#line 204
      *(dest + i) = (uint8_t )((*(src___2 + i) >> 24) + 128);
#line 203
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 206
  if ((int )fmt == 5) {
#line 207
    src___3 = (float *)src_v;
#line 208
    i = 0;
    {
    {
#line 208
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 208
      if (! (i < n)) {
#line 208
        goto while_break___3;
      }
#line 209
      if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
        tmp___1 = (float )255;
      } else {
#line 209
        tmp___1 = *(src___3 + i) * (float )128 + (float )128;
      }
#line 209
      if (tmp___1 > (float )0) {
#line 209
        if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
          tmp___0 = (float )255;
        } else {
#line 209
          tmp___0 = *(src___3 + i) * (float )128 + (float )128;
        }
#line 209
        v = (int )tmp___0;
      } else {
#line 209
        v = 0;
      }
#line 210
      *(dest + i) = (uint8_t )v;
#line 208
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 212
  if ((int )fmt == 6) {
#line 213
    src___4 = (double *)src_v;
#line 214
    i = 0;
    {
    {
#line 214
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 214
      if (! (i < n)) {
#line 214
        goto while_break___4;
      }
#line 215
      if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
        tmp___4 = (double )255;
      } else {
#line 215
        tmp___4 = *(src___4 + i) * (double )128 + (double )128;
      }
#line 215
      if (tmp___4 > (double )0) {
#line 215
        if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
          tmp___3 = (double )255;
        } else {
#line 215
          tmp___3 = *(src___4 + i) * (double )128 + (double )128;
        }
#line 215
        v = (int )tmp___3;
      } else {
#line 215
        v = 0;
      }
#line 216
      *(dest + i) = (uint8_t )v;
#line 214
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 219
  return;
}
}
#line 221 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s16___1(int16_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 226
  if ((int )fmt == 0) {
#line 227
    src = (uint8_t *)src_v;
#line 228
    i = 0;
    {
    {
#line 228
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n)) {
#line 228
        goto while_break;
      }
#line 229
      *(dest + i) = (int16_t )(((int )*(src + i) - 128) << 8);
#line 228
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 231
  if ((int )fmt == 1) {
    {
    {
#line 232
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int16_t )));
    }
    }
  } else
#line 233
  if ((int )fmt == 2) {
#line 234
    src___0 = (int32_t *)src_v;
#line 235
    i = 0;
    {
    {
#line 235
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (i < n)) {
#line 235
        goto while_break___0;
      }
#line 236
      *(dest + i) = (int16_t )(*(src___0 + i) >> 4);
#line 235
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 238
  if ((int )fmt == 3) {
#line 239
    src___1 = (int32_t *)src_v;
#line 240
    i = 0;
    {
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 240
      if (! (i < n)) {
#line 240
        goto while_break___1;
      }
#line 241
      *(dest + i) = (int16_t )(*(src___1 + i) >> 8);
#line 240
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 243
  if ((int )fmt == 4) {
#line 244
    src___2 = (int32_t *)src_v;
#line 245
    i = 0;
    {
    {
#line 245
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___2;
      }
#line 246
      *(dest + i) = (int16_t )(*(src___2 + i) >> 16);
#line 245
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 248
  if ((int )fmt == 5) {
#line 249
    src___3 = (float *)src_v;
#line 250
    i = 0;
    {
    {
#line 250
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 250
      if (! (i < n)) {
#line 250
        goto while_break___3;
      }
#line 251
      if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
        tmp___1 = (float )32767;
      } else {
#line 251
        tmp___1 = *(src___3 + i) * (float )32768;
      }
#line 251
      if (tmp___1 > (float )-32768) {
#line 251
        if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
          tmp___0 = (float )32767;
        } else {
#line 251
          tmp___0 = *(src___3 + i) * (float )32768;
        }
#line 251
        v = (int )tmp___0;
      } else {
#line 251
        v = -32768;
      }
#line 252
      *(dest + i) = (int16_t )v;
#line 250
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 254
  if ((int )fmt == 6) {
#line 255
    src___4 = (double *)src_v;
#line 256
    i = 0;
    {
    {
#line 256
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 256
      if (! (i < n)) {
#line 256
        goto while_break___4;
      }
#line 257
      if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
        tmp___4 = (double )32767;
      } else {
#line 257
        tmp___4 = *(src___4 + i) * (double )32768;
      }
#line 257
      if (tmp___4 > (double )-32768) {
#line 257
        if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
          tmp___3 = (double )32767;
        } else {
#line 257
          tmp___3 = *(src___4 + i) * (double )32768;
        }
#line 257
        v = (int )tmp___3;
      } else {
#line 257
        v = -32768;
      }
#line 258
      *(dest + i) = (int16_t )v;
#line 256
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s20___1(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 268
  if ((int )fmt == 0) {
#line 269
    src = (uint8_t *)src_v;
#line 270
    i = 0;
    {
    {
#line 270
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 270
      if (! (i < n)) {
#line 270
        goto while_break;
      }
#line 271
      *(dest + i) = ((int )*(src + i) - 128) << 12;
#line 270
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 273
  if ((int )fmt == 1) {
#line 274
    src___0 = (int16_t *)src_v;
#line 275
    i = 0;
    {
    {
#line 275
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! (i < n)) {
#line 275
        goto while_break___0;
      }
#line 276
      *(dest + i) = (int )*(src___0 + i) << 4;
#line 275
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 278
  if ((int )fmt == 2) {
    {
    {
#line 279
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 280
  if ((int )fmt == 3) {
#line 281
    src___1 = (int32_t *)src_v;
#line 282
    i = 0;
    {
    {
#line 282
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (i < n)) {
#line 282
        goto while_break___1;
      }
#line 283
      *(dest + i) = *(src___1 + i) >> 4;
#line 282
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 285
  if ((int )fmt == 4) {
#line 286
    src___2 = (int32_t *)src_v;
#line 287
    i = 0;
    {
    {
#line 287
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 287
      if (! (i < n)) {
#line 287
        goto while_break___2;
      }
#line 288
      *(dest + i) = *(src___2 + i) >> 12;
#line 287
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 290
  if ((int )fmt == 5) {
#line 291
    src___3 = (float *)src_v;
#line 292
    i = 0;
    {
    {
#line 292
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 292
      if (! (i < n)) {
#line 292
        goto while_break___3;
      }
#line 293
      if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
        tmp___1 = (float )524287;
      } else {
#line 293
        tmp___1 = *(src___3 + i) * (float )524288;
      }
#line 293
      if (tmp___1 > (float )-524288) {
#line 293
        if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
          tmp___0 = (float )524287;
        } else {
#line 293
          tmp___0 = *(src___3 + i) * (float )524288;
        }
#line 293
        v = (int )tmp___0;
      } else {
#line 293
        v = -524288;
      }
#line 294
      *(dest + i) = v;
#line 292
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 296
  if ((int )fmt == 6) {
#line 297
    src___4 = (double *)src_v;
#line 298
    i = 0;
    {
    {
#line 298
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 298
      if (! (i < n)) {
#line 298
        goto while_break___4;
      }
#line 299
      if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
        tmp___4 = (double )524287;
      } else {
#line 299
        tmp___4 = *(src___4 + i) * (double )524288;
      }
#line 299
      if (tmp___4 > (double )-524288) {
#line 299
        if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
          tmp___3 = (double )524287;
        } else {
#line 299
          tmp___3 = *(src___4 + i) * (double )524288;
        }
#line 299
        v = (int )tmp___3;
      } else {
#line 299
        v = -524288;
      }
#line 300
      *(dest + i) = v;
#line 298
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s24___1(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 310
  if ((int )fmt == 0) {
#line 311
    src = (uint8_t *)src_v;
#line 312
    i = 0;
    {
    {
#line 312
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 312
      if (! (i < n)) {
#line 312
        goto while_break;
      }
#line 313
      *(dest + i) = ((int )*(src + i) - 128) << 16;
#line 312
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 315
  if ((int )fmt == 1) {
#line 316
    src___0 = (int16_t *)src_v;
#line 317
    i = 0;
    {
    {
#line 317
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! (i < n)) {
#line 317
        goto while_break___0;
      }
#line 318
      *(dest + i) = (int )*(src___0 + i) << 8;
#line 317
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 320
  if ((int )fmt == 2) {
#line 321
    src___1 = (int32_t *)src_v;
#line 322
    i = 0;
    {
    {
#line 322
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (i < n)) {
#line 322
        goto while_break___1;
      }
#line 323
      *(dest + i) = *(src___1 + i) << 4;
#line 322
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 325
  if ((int )fmt == 3) {
    {
    {
#line 326
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 327
  if ((int )fmt == 4) {
#line 328
    src___2 = (int32_t *)src_v;
#line 329
    i = 0;
    {
    {
#line 329
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (i < n)) {
#line 329
        goto while_break___2;
      }
#line 330
      *(dest + i) = *(src___2 + i) >> 8;
#line 329
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 332
  if ((int )fmt == 5) {
#line 333
    src___3 = (float *)src_v;
#line 334
    i = 0;
    {
    {
#line 334
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 334
      if (! (i < n)) {
#line 334
        goto while_break___3;
      }
#line 335
      if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
        tmp___1 = (float )8388607;
      } else {
#line 335
        tmp___1 = *(src___3 + i) * (float )8388608;
      }
#line 335
      if (tmp___1 > (float )-8388608) {
#line 335
        if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
          tmp___0 = (float )8388607;
        } else {
#line 335
          tmp___0 = *(src___3 + i) * (float )8388608;
        }
#line 335
        v = (int )tmp___0;
      } else {
#line 335
        v = -8388608;
      }
#line 336
      *(dest + i) = v;
#line 334
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 338
  if ((int )fmt == 6) {
#line 339
    src___4 = (double *)src_v;
#line 340
    i = 0;
    {
    {
#line 340
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 340
      if (! (i < n)) {
#line 340
        goto while_break___4;
      }
#line 341
      if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
        tmp___4 = (double )8388607;
      } else {
#line 341
        tmp___4 = *(src___4 + i) * (double )8388608;
      }
#line 341
      if (tmp___4 > (double )-8388608) {
#line 341
        if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
          tmp___3 = (double )8388607;
        } else {
#line 341
          tmp___3 = *(src___4 + i) * (double )8388608;
        }
#line 341
        v = (int )tmp___3;
      } else {
#line 341
        v = -8388608;
      }
#line 342
      *(dest + i) = v;
#line 340
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 345
  return;
}
}
#line 347 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s32___1(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  double *src___4 ;

  {
#line 352
  if ((int )fmt == 0) {
#line 353
    src = (uint8_t *)src_v;
#line 354
    i = 0;
    {
    {
#line 354
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 354
      if (! (i < n)) {
#line 354
        goto while_break;
      }
#line 355
      *(dest + i) = ((int )*(src + i) - 128) << 24;
#line 354
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 357
  if ((int )fmt == 1) {
#line 358
    src___0 = (int16_t *)src_v;
#line 359
    i = 0;
    {
    {
#line 359
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (i < n)) {
#line 359
        goto while_break___0;
      }
#line 360
      *(dest + i) = (int )*(src___0 + i) << 16;
#line 359
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 362
  if ((int )fmt == 2) {
#line 363
    src___1 = (int32_t *)src_v;
#line 364
    i = 0;
    {
    {
#line 364
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (i < n)) {
#line 364
        goto while_break___1;
      }
#line 365
      *(dest + i) = *(src___1 + i) << 12;
#line 364
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 367
  if ((int )fmt == 3) {
#line 368
    src___2 = (int32_t *)src_v;
#line 369
    i = 0;
    {
    {
#line 369
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 369
      if (! (i < n)) {
#line 369
        goto while_break___2;
      }
#line 370
      *(dest + i) = *(src___2 + i) << 8;
#line 369
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 372
  if ((int )fmt == 4) {
    {
    {
#line 373
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 374
  if ((int )fmt == 5) {
#line 375
    src___3 = (float *)src_v;
#line 376
    i = 0;
    {
    {
#line 376
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 376
      if (! (i < n)) {
#line 376
        goto while_break___3;
      }
#line 377
      v = (int )(*(src___3 + i) * (float )2147483648LL);
#line 378
      *(dest + i) = v;
#line 376
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 380
  if ((int )fmt == 6) {
#line 381
    src___4 = (double *)src_v;
#line 382
    i = 0;
    {
    {
#line 382
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 382
      if (! (i < n)) {
#line 382
        goto while_break___4;
      }
#line 383
      v = (int )(*(src___4 + i) * (double )2147483648LL);
#line 384
      *(dest + i) = v;
#line 382
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_float___1(float *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  double *src___4 ;

  {
#line 394
  if ((int )fmt == 0) {
#line 395
    src = (uint8_t *)src_v;
#line 396
    i = 0;
    {
    {
#line 396
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 396
      if (! (i < n)) {
#line 396
        goto while_break;
      }
#line 397
      *(dest + i) = (float )(((double )*(src + i) - 128.0) / 128.0);
#line 396
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 399
  if ((int )fmt == 1) {
#line 400
    src___0 = (int16_t *)src_v;
#line 401
    i = 0;
    {
    {
#line 401
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (i < n)) {
#line 401
        goto while_break___0;
      }
#line 402
      *(dest + i) = (float )((double )*(src___0 + i) / 32768.0);
#line 401
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 404
  if ((int )fmt == 2) {
#line 405
    src___1 = (int32_t *)src_v;
#line 406
    i = 0;
    {
    {
#line 406
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 406
      if (! (i < n)) {
#line 406
        goto while_break___1;
      }
#line 407
      *(dest + i) = (float )((double )*(src___1 + i) / 524288.0);
#line 406
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 409
  if ((int )fmt == 3) {
#line 410
    src___2 = (int32_t *)src_v;
#line 411
    i = 0;
    {
    {
#line 411
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 411
      if (! (i < n)) {
#line 411
        goto while_break___2;
      }
#line 412
      *(dest + i) = (float )((double )*(src___2 + i) / 8388608.0);
#line 411
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 414
  if ((int )fmt == 4) {
#line 415
    src___3 = (int32_t *)src_v;
#line 416
    i = 0;
    {
    {
#line 416
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 416
      if (! (i < n)) {
#line 416
        goto while_break___3;
      }
#line 417
      *(dest + i) = (float )((double )*(src___3 + i) / 2147483648.0);
#line 416
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 419
  if ((int )fmt == 5) {
    {
    {
#line 420
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(float )));
    }
    }
  } else
#line 421
  if ((int )fmt == 6) {
#line 422
    src___4 = (double *)src_v;
#line 423
    i = 0;
    {
    {
#line 423
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 423
      if (! (i < n)) {
#line 423
        goto while_break___4;
      }
#line 424
      *(dest + i) = (float )*(src___4 + i);
#line 423
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_double___1(double *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  float *src___4 ;

  {
#line 434
  if ((int )fmt == 0) {
#line 435
    src = (uint8_t *)src_v;
#line 436
    i = 0;
    {
    {
#line 436
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 436
      if (! (i < n)) {
#line 436
        goto while_break;
      }
#line 437
      *(dest + i) = ((double )*(src + i) - 128.0) / 128.0;
#line 436
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 439
  if ((int )fmt == 1) {
#line 440
    src___0 = (int16_t *)src_v;
#line 441
    i = 0;
    {
    {
#line 441
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 441
      if (! (i < n)) {
#line 441
        goto while_break___0;
      }
#line 442
      *(dest + i) = (double )*(src___0 + i) / 32768.0;
#line 441
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 444
  if ((int )fmt == 2) {
#line 445
    src___1 = (int32_t *)src_v;
#line 446
    i = 0;
    {
    {
#line 446
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 446
      if (! (i < n)) {
#line 446
        goto while_break___1;
      }
#line 447
      *(dest + i) = (double )*(src___1 + i) / 524288.0;
#line 446
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 449
  if ((int )fmt == 3) {
#line 450
    src___2 = (int32_t *)src_v;
#line 451
    i = 0;
    {
    {
#line 451
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 451
      if (! (i < n)) {
#line 451
        goto while_break___2;
      }
#line 452
      *(dest + i) = (double )*(src___2 + i) / 8388608.0;
#line 451
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 454
  if ((int )fmt == 4) {
#line 455
    src___3 = (int32_t *)src_v;
#line 456
    i = 0;
    {
    {
#line 456
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 456
      if (! (i < n)) {
#line 456
        goto while_break___3;
      }
#line 457
      *(dest + i) = (double )*(src___3 + i) / 2147483648.0;
#line 456
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 459
  if ((int )fmt == 5) {
#line 460
    src___4 = (float *)src_v;
#line 461
    i = 0;
    {
    {
#line 461
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 461
      if (! (i < n)) {
#line 461
        goto while_break___4;
      }
#line 462
      *(dest + i) = (double )*(src___4 + i);
#line 461
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 464
  if ((int )fmt == 6) {
    {
    {
#line 465
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(double )));
    }
    }
  }
#line 467
  return;
}
}
#line 469 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert___1(enum WavSampleFormat dest_fmt , void *dest , enum WavSampleFormat src_fmt ,
                            void *src , int n ) 
{ 


  {
  {
#line 474
  if ((int )dest_fmt == 0) {
#line 474
    goto case_0;
  }
#line 477
  if ((int )dest_fmt == 1) {
#line 477
    goto case_1;
  }
#line 480
  if ((int )dest_fmt == 2) {
#line 480
    goto case_2;
  }
#line 483
  if ((int )dest_fmt == 3) {
#line 483
    goto case_3;
  }
#line 486
  if ((int )dest_fmt == 4) {
#line 486
    goto case_4;
  }
#line 489
  if ((int )dest_fmt == 5) {
#line 489
    goto case_5;
  }
#line 492
  if ((int )dest_fmt == 6) {
#line 492
    goto case_6;
  }
#line 473
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 475
  fmt_convert_to_u8___1((uint8_t *)dest, src, n, src_fmt);
  }
  }
#line 476
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 478
  fmt_convert_to_s16___1((int16_t *)dest, src, n, src_fmt);
  }
  }
#line 479
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 481
  fmt_convert_to_s20___1((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 484
  fmt_convert_to_s24___1((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 485
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 487
  fmt_convert_to_s32___1((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 488
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 490
  fmt_convert_to_float___1((float *)dest, src, n, src_fmt);
  }
  }
#line 491
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  {
#line 493
  fmt_convert_to_double___1((double *)dest, src, n, src_fmt);
  }
  }
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_samplerates___0[16]  = 
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )8000,      (int const   )16000,      (int const   )22050,      (int const   )24000, 
        (int const   )32000,      (int const   )44100,      (int const   )48000,      (int const   )96000, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_bitdepths___0[8]  = 
#line 39
  {      (int const   )0,      (int const   )8,      (int const   )12,      (int const   )0, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )0};
#line 43 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_blocksizes___0[15]  = 
#line 43
  {      (int const   )0,      (int const   )192,      (int const   )576,      (int const   )1152, 
        (int const   )2304,      (int const   )4608,      (int const   )0,      (int const   )0, 
        (int const   )256,      (int const   )512,      (int const   )1024,      (int const   )2048, 
        (int const   )4096,      (int const   )8192,      (int const   )16384};
#line 55 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_streaminfo___0(FlacEncodeContext *ctx , uint8_t *streaminfo , int last ) 
{ 


  {
  {
  {
#line 58
  memset((void *)streaminfo, 0, (size_t )38);
  }
  {
#line 59
  bitwriter_init(ctx->bw, (void *)streaminfo, 38);
  }
  {
#line 62
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 63
  bitwriter_writebits(ctx->bw, 7, (uint32_t )0);
  }
  {
#line 64
  bitwriter_writebits(ctx->bw, 24, (uint32_t )34);
  }
  }
#line 66
  if (ctx->params.variable_block_size) {
    {
    {
#line 67
    bitwriter_writebits(ctx->bw, 16, (uint32_t )0);
    }
    }
  } else {
    {
    {
#line 69
    bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
    }
    }
  }
  {
  {
#line 71
  bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
  }
  {
#line 72
  bitwriter_writebits(ctx->bw, 24, (uint32_t )0);
  }
  {
#line 73
  bitwriter_writebits(ctx->bw, 24, (uint32_t )ctx->max_frame_size);
  }
  {
#line 74
  bitwriter_writebits(ctx->bw, 20, (uint32_t )ctx->samplerate);
  }
  {
#line 75
  bitwriter_writebits(ctx->bw, 3, (uint32_t )(ctx->channels - 1));
  }
  {
#line 76
  bitwriter_writebits(ctx->bw, 5, (uint32_t )(ctx->bps - 1));
  }
  }
#line 79
  if (ctx->sample_count > 0U) {
    {
    {
#line 80
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 81
    bitwriter_writebits(ctx->bw, 32, ctx->sample_count);
    }
    }
  } else {
    {
    {
#line 83
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 84
    bitwriter_writebits(ctx->bw, 32, (uint32_t )0);
    }
    }
  }
#line 86
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_padding___0(FlacEncodeContext *ctx , uint8_t *padding , int last ,
                             int padlen ) 
{ 


  {
  {
  {
#line 94
  bitwriter_init(ctx->bw, (void *)padding, 4);
  }
  {
#line 97
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 98
  bitwriter_writebits(ctx->bw, 7, (uint32_t )1);
  }
  {
#line 99
  bitwriter_writebits(ctx->bw, 24, (uint32_t )padlen);
  }
  }
#line 101
  return (padlen + 4);
}
}
#line 104 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static char const   *vendor_string___0  =    "Flake0.11";
#line 110 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_vorbis_comment___0(FlacEncodeContext *ctx , uint8_t *comment , int last ) 
{ 
  int vendor_len ;
  uint8_t vlen_le[4] ;
  size_t tmp ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 116
  tmp = strlen(vendor_string___0);
  }
#line 116
  vendor_len = (int )tmp;
  {
#line 117
  bitwriter_init(ctx->bw, (void *)comment, 4);
  }
  {
#line 120
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 121
  bitwriter_writebits(ctx->bw, 7, (uint32_t )4);
  }
  {
#line 122
  bitwriter_writebits(ctx->bw, 24, (uint32_t )(vendor_len + 8));
  }
#line 126
  vlen_le[0] = (uint8_t )(vendor_len & 255);
#line 127
  vlen_le[1] = (uint8_t )((vendor_len >> 8) & 255);
#line 128
  vlen_le[2] = (uint8_t )((vendor_len >> 16) & 255);
#line 129
  vlen_le[3] = (uint8_t )((vendor_len >> 24) & 255);
  {
#line 130
  memcpy((void */* __restrict  */)(comment + 4), (void const   */* __restrict  */)(vlen_le),
         (size_t )4);
  }
  {
#line 132
  memcpy((void */* __restrict  */)(comment + 8), (void const   */* __restrict  */)vendor_string___0,
         (size_t )vendor_len);
  }
  {
#line 134
  memset((void *)(comment + (vendor_len + 8)), 0, (size_t )4);
  }
  }
#line 136
  return (vendor_len + 12);
}
}
#line 142 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_headers___0(FlacEncodeContext *ctx , uint8_t *header ) 
{ 
  int header_size ;
  int last ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 147
  header_size = 0;
#line 148
  last = 0;
#line 151
  *(header + 0) = (uint8_t )102;
#line 152
  *(header + 1) = (uint8_t )76;
#line 153
  *(header + 2) = (uint8_t )97;
#line 154
  *(header + 3) = (uint8_t )67;
#line 155
  header_size += 4;
  {
#line 158
  write_streaminfo___0(ctx, header + header_size, last);
  }
#line 159
  header_size += 38;
  }
#line 162
  if (ctx->params.padding_size == 0) {
#line 162
    last = 1;
  }
  {
  {
#line 163
  tmp = write_vorbis_comment___0(ctx, header + header_size, last);
  }
#line 163
  header_size += tmp;
  }
#line 166
  if (ctx->params.padding_size > 0) {
    {
#line 167
    last = 1;
    {
#line 168
    tmp___0 = write_padding___0(ctx, header + header_size, last, ctx->params.padding_size);
    }
#line 168
    header_size += tmp___0;
    }
  }
#line 172
  return (header_size);
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int select_blocksize___0(int samplerate , int time_ms ) 
{ 
  int i ;
  int target ;
  int blocksize ;

  {
#line 184
  blocksize = (int )flac_blocksizes___0[1];
#line 185
  target = (samplerate * time_ms) / 1000;
#line 186
  i = 0;
  {
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 16)) {
#line 186
      goto while_break;
    }
#line 187
    if (target >= (int )flac_blocksizes___0[i]) {
#line 187
      if (flac_blocksizes___0[i] > (int const   )blocksize) {
#line 188
        blocksize = (int )flac_blocksizes___0[i];
      }
    }
#line 186
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (blocksize);
}
}
#line 533 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int init_frame___0(FlacEncodeContext *ctx ) 
{ 
  int i ;
  int ch ;
  FlacFrame *frame ;

  {
#line 539
  frame = & ctx->frame;
#line 541
  if (ctx->params.block_time_ms < 0) {
#line 542
    return (-1);
  }
#line 544
  if (ctx->params.block_size == 0) {
    {
    {
#line 545
    ctx->params.block_size = select_blocksize___0(ctx->samplerate, ctx->params.block_time_ms);
    }
    }
  }
#line 547
  if (ctx->params.block_size < 1) {
#line 549
    return (-1);
  } else
#line 547
  if (ctx->params.block_size > 65535) {
#line 549
    return (-1);
  }
#line 553
  if (ctx->channels == 2) {
#line 554
    ctx->max_frame_size = 16 + ((ctx->params.block_size * ((ctx->bps + ctx->bps) + 1) + 7) >> 3);
  } else {
#line 556
    ctx->max_frame_size = 16 + (((ctx->params.block_size * ctx->channels) * ctx->bps + 7) >> 3);
  }
#line 560
  i = 15;
#line 561
  if (! ctx->params.variable_block_size) {
#line 562
    i = 0;
    {
    {
#line 562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 562
      if (! (i < 15)) {
#line 562
        goto while_break;
      }
#line 563
      if (ctx->params.block_size == (int )flac_blocksizes___0[i]) {
#line 564
        frame->blocksize = (int )flac_blocksizes___0[i];
#line 565
        frame->bs_code[0] = i;
#line 566
        frame->bs_code[1] = -1;
#line 567
        goto while_break;
      }
#line 562
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 571
  if (i == 15) {
#line 572
    frame->blocksize = ctx->params.block_size;
#line 573
    if (frame->blocksize <= 256) {
#line 574
      frame->bs_code[0] = 6;
#line 575
      frame->bs_code[1] = frame->blocksize - 1;
    } else {
#line 577
      frame->bs_code[0] = 7;
#line 578
      frame->bs_code[1] = frame->blocksize - 1;
    }
  }
#line 583
  ch = 0;
  {
  {
#line 583
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (ch < ctx->channels)) {
#line 583
      goto while_break___0;
    }
#line 584
    frame->subframes[ch].obits = ctx->bps;
#line 583
    ch ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 593 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void update_md5_checksum___0(FlacEncodeContext *ctx , int16_t *samples ) 
{ 


  {
  {
  {
#line 596
  md5_accumulate(& ctx->md5ctx, (void const   *)samples, ctx->channels, ctx->params.block_size);
  }
  }
#line 597
  return;
}
}
#line 602 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void copy_samples___0(FlacEncodeContext *ctx , int16_t *samples ) 
{ 
  int i ;
  int j ;
  int ch ;
  FlacFrame *frame ;

  {
#line 608
  frame = & ctx->frame;
#line 609
  i = 0;
#line 609
  j = 0;
  {
  {
#line 609
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i < frame->blocksize)) {
#line 609
      goto while_break;
    }
#line 610
    ch = 0;
    {
    {
#line 610
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 610
      if (! (ch < ctx->channels)) {
#line 610
        goto while_break___0;
      }
#line 611
      frame->subframes[ch].samples[i] = (int32_t )*(samples + j);
#line 610
      ch ++;
#line 610
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 609
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return;
}
}
#line 619 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int calc_decorr_scores___0(int32_t *left_ch , int32_t *right_ch , int n ) 
{ 
  int i ;
  int best ;
  int32_t lt ;
  int32_t rt ;
  uint64_t sum[4] ;
  uint64_t score[4] ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 629
  sum[3] = (uint64_t )0;
#line 629
  sum[2] = sum[3];
#line 629
  sum[1] = sum[2];
#line 629
  sum[0] = sum[1];
#line 630
  i = 2;
  {
  {
#line 630
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < n)) {
#line 630
      goto while_break;
    }
    {
#line 631
    lt = (*(left_ch + i) - 2 * *(left_ch + (i - 1))) + *(left_ch + (i - 2));
#line 632
    rt = (*(right_ch + i) - 2 * *(right_ch + (i - 1))) + *(right_ch + (i - 2));
    {
#line 633
    tmp = abs((lt + rt) >> 1);
    }
#line 633
    sum[2] += (uint64_t )tmp;
    {
#line 634
    tmp___0 = abs(lt - rt);
    }
#line 634
    sum[3] += (uint64_t )tmp___0;
    {
#line 635
    tmp___1 = abs(lt);
    }
#line 635
    sum[0] += (uint64_t )tmp___1;
    {
#line 636
    tmp___2 = abs(rt);
    }
#line 636
    sum[1] += (uint64_t )tmp___2;
#line 630
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  i = 0;
  {
  {
#line 639
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (i < 4)) {
#line 639
      goto while_break___0;
    }
    {
    {
#line 640
    k = find_optimal_rice_param((uint32_t )(2ULL * sum[i]), n);
    }
#line 641
    sum[i] = (uint64_t )(n * (k + 1)) + ((2ULL * sum[i] - (uint64_t )(n >> 1)) >> k);
#line 639
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 645
  score[0] = sum[0] + sum[1];
#line 646
  score[1] = sum[0] + sum[3];
#line 647
  score[2] = sum[1] + sum[3];
#line 648
  score[3] = sum[2] + sum[3];
#line 651
  best = 0;
#line 652
  i = 1;
  {
  {
#line 652
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 652
    if (! (i < 4)) {
#line 652
      goto while_break___1;
    }
#line 653
    if (score[i] < score[best]) {
#line 654
      best = i;
    }
#line 652
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 658
  if (best == 0) {
#line 658
    goto case_0;
  }
#line 659
  if (best == 1) {
#line 659
    goto case_1;
  }
#line 660
  if (best == 2) {
#line 660
    goto case_2;
  }
#line 661
  if (best == 3) {
#line 661
    goto case_3;
  }
#line 657
  goto switch_break;
  case_0: /* CIL Label */ 
#line 658
  return (1);
  case_1: /* CIL Label */ 
#line 659
  return (8);
  case_2: /* CIL Label */ 
#line 660
  return (9);
  case_3: /* CIL Label */ 
#line 661
  return (10);
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (1);
}
}
#line 669 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void channel_decorrelation___0(FlacEncodeContext *ctx ) 
{ 
  int i ;
  FlacFrame *frame ;
  int32_t *left ;
  int32_t *right ;
  int32_t tmp ;

  {
#line 677
  frame = & ctx->frame;
#line 678
  left = frame->subframes[0].samples;
#line 679
  right = frame->subframes[1].samples;
#line 681
  if (ctx->channels != 2) {
#line 682
    frame->ch_mode = 0;
#line 683
    return;
  }
#line 685
  if (frame->blocksize <= 32) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  } else
#line 685
  if (ctx->params.stereo_method == 0) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  }
  {
  {
#line 691
  frame->ch_mode = calc_decorr_scores___0(left, right, frame->blocksize);
  }
  }
#line 694
  if (frame->ch_mode == 1) {
#line 695
    return;
  }
#line 697
  if (frame->ch_mode == 10) {
#line 698
    i = 0;
    {
    {
#line 698
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 698
      if (! (i < frame->blocksize)) {
#line 698
        goto while_break;
      }
#line 699
      tmp = *(left + i);
#line 700
      *(left + i) = (*(left + i) + *(right + i)) >> 1;
#line 701
      *(right + i) = tmp - *(right + i);
#line 698
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    (frame->subframes[1].obits) ++;
  } else
#line 704
  if (frame->ch_mode == 8) {
#line 705
    i = 0;
    {
    {
#line 705
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 705
      if (! (i < frame->blocksize)) {
#line 705
        goto while_break___0;
      }
#line 706
      *(right + i) = *(left + i) - *(right + i);
#line 705
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    (frame->subframes[1].obits) ++;
  } else
#line 709
  if (frame->ch_mode == 9) {
#line 710
    i = 0;
    {
    {
#line 710
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 710
      if (! (i < frame->blocksize)) {
#line 710
        goto while_break___1;
      }
#line 711
      *(left + i) -= *(right + i);
#line 710
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 713
    (frame->subframes[0].obits) ++;
  }
#line 715
  return;
}
}
#line 721 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_utf8___0(BitWriter *bw , uint32_t val ) 
{ 
  int bytes ;
  int shift ;
  int tmp ;

  {
#line 726
  if (val < 128U) {
    {
    {
#line 727
    bitwriter_writebits(bw, 8, val);
    }
    }
#line 728
    return;
  }
  {
  {
#line 730
  tmp = log2i(val);
  }
#line 730
  bytes = (tmp + 4) / 5;
#line 731
  shift = (bytes - 1) * 6;
  {
#line 732
  bitwriter_writebits(bw, 8, (unsigned int )(256 - (256 >> bytes)) | (val >> shift));
  }
  }
  {
  {
#line 733
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 733
    if (! (shift >= 6)) {
#line 733
      goto while_break;
    }
    {
#line 734
    shift -= 6;
    {
#line 735
    bitwriter_writebits(bw, 8, 128U | ((val >> shift) & 63U));
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return;
}
}
#line 739 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_header___0(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  uint8_t crc ;
  uint32_t tmp ;

  {
  {
#line 745
  frame = & ctx->frame;
  {
#line 747
  bitwriter_writebits(ctx->bw, 16, (uint32_t )65528);
  }
  {
#line 748
  bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->bs_code[0]);
  }
  {
#line 749
  bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->sr_code[0]);
  }
  }
#line 750
  if (frame->ch_mode == 0) {
    {
    {
#line 751
    bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->ch_code);
    }
    }
  } else {
    {
    {
#line 753
    bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->ch_mode);
    }
    }
  }
  {
  {
#line 755
  bitwriter_writebits(ctx->bw, 3, (uint32_t )ctx->bps_code);
  }
  {
#line 756
  bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
  }
  {
#line 757
  write_utf8___0(ctx->bw, ctx->frame_count);
  }
  }
#line 760
  if (frame->bs_code[1] >= 0) {
#line 761
    if (frame->bs_code[1] < 256) {
      {
      {
#line 762
      bitwriter_writebits(ctx->bw, 8, (uint32_t )frame->bs_code[1]);
      }
      }
    } else {
      {
      {
#line 764
      bitwriter_writebits(ctx->bw, 16, (uint32_t )frame->bs_code[1]);
      }
      }
    }
  }
#line 769
  if (ctx->sr_code[1] > 0) {
#line 770
    if (ctx->sr_code[1] < 256) {
      {
      {
#line 771
      bitwriter_writebits(ctx->bw, 8, (uint32_t )ctx->sr_code[1]);
      }
      }
    } else {
      {
      {
#line 773
      bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->sr_code[1]);
      }
      }
    }
  }
  {
  {
#line 778
  bitwriter_flush(ctx->bw);
  }
  {
#line 779
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 779
  crc = calc_crc8((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 780
  bitwriter_writebits(ctx->bw, 8, (uint32_t )crc);
  }
  }
#line 781
  return;
}
}
#line 783 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_residual___0(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int j ;
  int p ;
  int k ;
  int porder ;
  int psize ;
  int res_cnt ;
  FlacFrame *frame ;
  FlacSubframe *sub ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 791
  frame = & ctx->frame;
#line 792
  sub = & frame->subframes[ch];
  {
#line 795
  bitwriter_writebits(ctx->bw, 2, (uint32_t )0);
  }
#line 798
  porder = sub->rc.porder;
#line 799
  psize = frame->blocksize >> porder;
  }
#line 800
  if (! (porder >= 0)) {
    {
    {
#line 800
    __assert_fail("porder >= 0", "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c",
                  800U, "output_residual");
    }
    }
  }
  {
  {
#line 801
  bitwriter_writebits(ctx->bw, 4, (uint32_t )porder);
  }
#line 802
  res_cnt = psize - sub->order;
#line 805
  j = sub->order;
#line 806
  p = 0;
  }
  {
  {
#line 806
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 806
    if (! (p < 1 << porder)) {
#line 806
      goto while_break;
    }
    {
#line 807
    k = sub->rc.params[p];
    {
#line 808
    bitwriter_writebits(ctx->bw, 4, (uint32_t )k);
    }
    }
#line 809
    if (p == 1) {
#line 809
      res_cnt = psize;
    }
#line 810
    i = 0;
    {
    {
#line 810
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 810
      if (i < res_cnt) {
#line 810
        if (! (j < frame->blocksize)) {
#line 810
          goto while_break___0;
        }
      } else {
#line 810
        goto while_break___0;
      }
      {
      {
#line 811
      bitwriter_write_rice_signed(ctx->bw, k, sub->residual[j]);
      }
#line 810
      i ++;
#line 810
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 806
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return;
}
}
#line 816 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_constant___0(FlacEncodeContext *ctx , int ch ) 
{ 
  FlacSubframe *sub ;

  {
  {
#line 821
  sub = & ctx->frame.subframes[ch];
  {
#line 822
  bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[0]);
  }
  }
#line 823
  return;
}
}
#line 825 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_verbatim___0(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int n ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 832
  frame = & ctx->frame;
#line 833
  sub = & frame->subframes[ch];
#line 834
  n = frame->blocksize;
#line 836
  i = 0;
  {
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < n)) {
#line 836
      goto while_break;
    }
    {
    {
#line 837
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 836
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 841 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_fixed___0(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 848
  frame = & ctx->frame;
#line 849
  sub = & frame->subframes[ch];
#line 852
  i = 0;
  {
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < sub->order)) {
#line 852
      goto while_break;
    }
    {
    {
#line 853
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 852
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 857
  output_residual___0(ctx, ch);
  }
  }
#line 858
  return;
}
}
#line 860 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_lpc___0(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int cbits ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 867
  frame = & ctx->frame;
#line 868
  sub = & frame->subframes[ch];
#line 871
  i = 0;
  {
  {
#line 871
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < sub->order)) {
#line 871
      goto while_break;
    }
    {
    {
#line 872
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 871
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 876
  cbits = ctx->lpc_precision;
  {
#line 877
  bitwriter_writebits(ctx->bw, 4, (uint32_t )(cbits - 1));
  }
  {
#line 878
  bitwriter_writebits_signed(ctx->bw, 5, sub->shift);
  }
#line 879
  i = 0;
  }
  {
  {
#line 879
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 879
    if (! (i < sub->order)) {
#line 879
      goto while_break___0;
    }
    {
    {
#line 880
    bitwriter_writebits_signed(ctx->bw, cbits, sub->coefs[i]);
    }
#line 879
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 884
  output_residual___0(ctx, ch);
  }
  }
#line 885
  return;
}
}
#line 887 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframes___0(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  int i ;
  int ch ;

  {
#line 893
  frame = & ctx->frame;
#line 895
  i = 0;
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    if (! (i < ctx->channels)) {
#line 895
      goto while_break;
    }
    {
#line 896
    ch = i;
    {
#line 899
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    {
#line 900
    bitwriter_writebits(ctx->bw, 6, (uint32_t )frame->subframes[ch].type_code);
    }
    {
#line 901
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    }
    {
#line 905
    if (frame->subframes[ch].type == 0) {
#line 905
      goto case_0;
    }
#line 907
    if (frame->subframes[ch].type == 1) {
#line 907
      goto case_1;
    }
#line 909
    if (frame->subframes[ch].type == 8) {
#line 909
      goto case_8;
    }
#line 911
    if (frame->subframes[ch].type == 32) {
#line 911
      goto case_32;
    }
#line 904
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 905
    output_subframe_constant___0(ctx, ch);
    }
    }
#line 906
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 907
    output_subframe_verbatim___0(ctx, ch);
    }
    }
#line 908
    goto switch_break;
    case_8: /* CIL Label */ 
    {
    {
#line 909
    output_subframe_fixed___0(ctx, ch);
    }
    }
#line 910
    goto switch_break;
    case_32: /* CIL Label */ 
    {
    {
#line 911
    output_subframe_lpc___0(ctx, ch);
    }
    }
#line 912
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 895
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_footer___0(FlacEncodeContext *ctx ) 
{ 
  uint16_t crc ;
  uint32_t tmp ;

  {
  {
  {
#line 921
  bitwriter_flush(ctx->bw);
  }
  {
#line 922
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 922
  crc = calc_crc16((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 923
  bitwriter_writebits(ctx->bw, 16, (uint32_t )crc);
  }
  {
#line 924
  bitwriter_flush(ctx->bw);
  }
  }
#line 925
  return;
}
}
#line 54 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
static void const   *body___0(MD5Context *ctx , void const   *data , uint32_t size ) 
{ 
  uint8_t const   *ptr ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;

  {
#line 61
  ptr = (uint8_t const   *)data;
#line 63
  a = ctx->a;
#line 64
  b = ctx->b;
#line 65
  c = ctx->c;
#line 66
  d = ctx->d;
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 69
    saved_a = a;
#line 70
    saved_b = b;
#line 71
    saved_c = c;
#line 72
    saved_d = d;
#line 75
    tmp = (((uint32_t )*(ptr + 0) | ((uint32_t )*(ptr + 1) << 8)) | ((uint32_t )*(ptr + 2) << 16)) | ((uint32_t )*(ptr + 3) << 24);
#line 75
    ctx->block[0] = tmp;
#line 75
    a += ((d ^ (b & (c ^ d))) + tmp) + 3614090360U;
#line 75
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 75
    a += b;
#line 76
    tmp___0 = (((uint32_t )*(ptr + 4) | ((uint32_t )*(ptr + 5) << 8)) | ((uint32_t )*(ptr + 6) << 16)) | ((uint32_t )*(ptr + 7) << 24);
#line 76
    ctx->block[1] = tmp___0;
#line 76
    d += ((c ^ (a & (b ^ c))) + tmp___0) + 3905402710U;
#line 76
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 76
    d += a;
#line 77
    tmp___1 = (((uint32_t )*(ptr + 8) | ((uint32_t )*(ptr + 9) << 8)) | ((uint32_t )*(ptr + 10) << 16)) | ((uint32_t )*(ptr + 11) << 24);
#line 77
    ctx->block[2] = tmp___1;
#line 77
    c += ((b ^ (d & (a ^ b))) + tmp___1) + 606105819U;
#line 77
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 77
    c += d;
#line 78
    tmp___2 = (((uint32_t )*(ptr + 12) | ((uint32_t )*(ptr + 13) << 8)) | ((uint32_t )*(ptr + 14) << 16)) | ((uint32_t )*(ptr + 15) << 24);
#line 78
    ctx->block[3] = tmp___2;
#line 78
    b += ((a ^ (c & (d ^ a))) + tmp___2) + 3250441966U;
#line 78
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 78
    b += c;
#line 79
    tmp___3 = (((uint32_t )*(ptr + 16) | ((uint32_t )*(ptr + 17) << 8)) | ((uint32_t )*(ptr + 18) << 16)) | ((uint32_t )*(ptr + 19) << 24);
#line 79
    ctx->block[4] = tmp___3;
#line 79
    a += ((d ^ (b & (c ^ d))) + tmp___3) + 4118548399U;
#line 79
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 79
    a += b;
#line 80
    tmp___4 = (((uint32_t )*(ptr + 20) | ((uint32_t )*(ptr + 21) << 8)) | ((uint32_t )*(ptr + 22) << 16)) | ((uint32_t )*(ptr + 23) << 24);
#line 80
    ctx->block[5] = tmp___4;
#line 80
    d += ((c ^ (a & (b ^ c))) + tmp___4) + 1200080426U;
#line 80
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 80
    d += a;
#line 81
    tmp___5 = (((uint32_t )*(ptr + 24) | ((uint32_t )*(ptr + 25) << 8)) | ((uint32_t )*(ptr + 26) << 16)) | ((uint32_t )*(ptr + 27) << 24);
#line 81
    ctx->block[6] = tmp___5;
#line 81
    c += ((b ^ (d & (a ^ b))) + tmp___5) + 2821735955U;
#line 81
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 81
    c += d;
#line 82
    tmp___6 = (((uint32_t )*(ptr + 28) | ((uint32_t )*(ptr + 29) << 8)) | ((uint32_t )*(ptr + 30) << 16)) | ((uint32_t )*(ptr + 31) << 24);
#line 82
    ctx->block[7] = tmp___6;
#line 82
    b += ((a ^ (c & (d ^ a))) + tmp___6) + 4249261313U;
#line 82
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 82
    b += c;
#line 83
    tmp___7 = (((uint32_t )*(ptr + 32) | ((uint32_t )*(ptr + 33) << 8)) | ((uint32_t )*(ptr + 34) << 16)) | ((uint32_t )*(ptr + 35) << 24);
#line 83
    ctx->block[8] = tmp___7;
#line 83
    a += ((d ^ (b & (c ^ d))) + tmp___7) + 1770035416U;
#line 83
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 83
    a += b;
#line 84
    tmp___8 = (((uint32_t )*(ptr + 36) | ((uint32_t )*(ptr + 37) << 8)) | ((uint32_t )*(ptr + 38) << 16)) | ((uint32_t )*(ptr + 39) << 24);
#line 84
    ctx->block[9] = tmp___8;
#line 84
    d += ((c ^ (a & (b ^ c))) + tmp___8) + 2336552879U;
#line 84
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 84
    d += a;
#line 85
    tmp___9 = (((uint32_t )*(ptr + 40) | ((uint32_t )*(ptr + 41) << 8)) | ((uint32_t )*(ptr + 42) << 16)) | ((uint32_t )*(ptr + 43) << 24);
#line 85
    ctx->block[10] = tmp___9;
#line 85
    c += ((b ^ (d & (a ^ b))) + tmp___9) + 4294925233U;
#line 85
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 85
    c += d;
#line 86
    tmp___10 = (((uint32_t )*(ptr + 44) | ((uint32_t )*(ptr + 45) << 8)) | ((uint32_t )*(ptr + 46) << 16)) | ((uint32_t )*(ptr + 47) << 24);
#line 86
    ctx->block[11] = tmp___10;
#line 86
    b += ((a ^ (c & (d ^ a))) + tmp___10) + 2304563134U;
#line 86
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 86
    b += c;
#line 87
    tmp___11 = (((uint32_t )*(ptr + 48) | ((uint32_t )*(ptr + 49) << 8)) | ((uint32_t )*(ptr + 50) << 16)) | ((uint32_t )*(ptr + 51) << 24);
#line 87
    ctx->block[12] = tmp___11;
#line 87
    a += ((d ^ (b & (c ^ d))) + tmp___11) + 1804603682U;
#line 87
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 87
    a += b;
#line 88
    tmp___12 = (((uint32_t )*(ptr + 52) | ((uint32_t )*(ptr + 53) << 8)) | ((uint32_t )*(ptr + 54) << 16)) | ((uint32_t )*(ptr + 55) << 24);
#line 88
    ctx->block[13] = tmp___12;
#line 88
    d += ((c ^ (a & (b ^ c))) + tmp___12) + 4254626195U;
#line 88
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 88
    d += a;
#line 89
    tmp___13 = (((uint32_t )*(ptr + 56) | ((uint32_t )*(ptr + 57) << 8)) | ((uint32_t )*(ptr + 58) << 16)) | ((uint32_t )*(ptr + 59) << 24);
#line 89
    ctx->block[14] = tmp___13;
#line 89
    c += ((b ^ (d & (a ^ b))) + tmp___13) + 2792965006U;
#line 89
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 89
    c += d;
#line 90
    tmp___14 = (((uint32_t )*(ptr + 60) | ((uint32_t )*(ptr + 61) << 8)) | ((uint32_t )*(ptr + 62) << 16)) | ((uint32_t )*(ptr + 63) << 24);
#line 90
    ctx->block[15] = tmp___14;
#line 90
    b += ((a ^ (c & (d ^ a))) + tmp___14) + 1236535329U;
#line 90
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 90
    b += c;
#line 93
    a += ((c ^ (d & (b ^ c))) + ctx->block[1]) + 4129170786U;
#line 93
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 93
    a += b;
#line 94
    d += ((b ^ (c & (a ^ b))) + ctx->block[6]) + 3225465664U;
#line 94
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 94
    d += a;
#line 95
    c += ((a ^ (b & (d ^ a))) + ctx->block[11]) + 643717713U;
#line 95
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 95
    c += d;
#line 96
    b += ((d ^ (a & (c ^ d))) + ctx->block[0]) + 3921069994U;
#line 96
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 96
    b += c;
#line 97
    a += ((c ^ (d & (b ^ c))) + ctx->block[5]) + 3593408605U;
#line 97
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 97
    a += b;
#line 98
    d += ((b ^ (c & (a ^ b))) + ctx->block[10]) + 38016083U;
#line 98
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 98
    d += a;
#line 99
    c += ((a ^ (b & (d ^ a))) + ctx->block[15]) + 3634488961U;
#line 99
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 99
    c += d;
#line 100
    b += ((d ^ (a & (c ^ d))) + ctx->block[4]) + 3889429448U;
#line 100
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 100
    b += c;
#line 101
    a += ((c ^ (d & (b ^ c))) + ctx->block[9]) + 568446438U;
#line 101
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 101
    a += b;
#line 102
    d += ((b ^ (c & (a ^ b))) + ctx->block[14]) + 3275163606U;
#line 102
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 102
    d += a;
#line 103
    c += ((a ^ (b & (d ^ a))) + ctx->block[3]) + 4107603335U;
#line 103
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 103
    c += d;
#line 104
    b += ((d ^ (a & (c ^ d))) + ctx->block[8]) + 1163531501U;
#line 104
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 104
    b += c;
#line 105
    a += ((c ^ (d & (b ^ c))) + ctx->block[13]) + 2850285829U;
#line 105
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 105
    a += b;
#line 106
    d += ((b ^ (c & (a ^ b))) + ctx->block[2]) + 4243563512U;
#line 106
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 106
    d += a;
#line 107
    c += ((a ^ (b & (d ^ a))) + ctx->block[7]) + 1735328473U;
#line 107
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 107
    c += d;
#line 108
    b += ((d ^ (a & (c ^ d))) + ctx->block[12]) + 2368359562U;
#line 108
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 108
    b += c;
#line 111
    a += (((b ^ c) ^ d) + ctx->block[5]) + 4294588738U;
#line 111
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 111
    a += b;
#line 112
    d += (((a ^ b) ^ c) + ctx->block[8]) + 2272392833U;
#line 112
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 112
    d += a;
#line 113
    c += (((d ^ a) ^ b) + ctx->block[11]) + 1839030562U;
#line 113
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 113
    c += d;
#line 114
    b += (((c ^ d) ^ a) + ctx->block[14]) + 4259657740U;
#line 114
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 114
    b += c;
#line 115
    a += (((b ^ c) ^ d) + ctx->block[1]) + 2763975236U;
#line 115
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 115
    a += b;
#line 116
    d += (((a ^ b) ^ c) + ctx->block[4]) + 1272893353U;
#line 116
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 116
    d += a;
#line 117
    c += (((d ^ a) ^ b) + ctx->block[7]) + 4139469664U;
#line 117
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 117
    c += d;
#line 118
    b += (((c ^ d) ^ a) + ctx->block[10]) + 3200236656U;
#line 118
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 118
    b += c;
#line 119
    a += (((b ^ c) ^ d) + ctx->block[13]) + 681279174U;
#line 119
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 119
    a += b;
#line 120
    d += (((a ^ b) ^ c) + ctx->block[0]) + 3936430074U;
#line 120
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 120
    d += a;
#line 121
    c += (((d ^ a) ^ b) + ctx->block[3]) + 3572445317U;
#line 121
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 121
    c += d;
#line 122
    b += (((c ^ d) ^ a) + ctx->block[6]) + 76029189U;
#line 122
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 122
    b += c;
#line 123
    a += (((b ^ c) ^ d) + ctx->block[9]) + 3654602809U;
#line 123
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 123
    a += b;
#line 124
    d += (((a ^ b) ^ c) + ctx->block[12]) + 3873151461U;
#line 124
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 124
    d += a;
#line 125
    c += (((d ^ a) ^ b) + ctx->block[15]) + 530742520U;
#line 125
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 125
    c += d;
#line 126
    b += (((c ^ d) ^ a) + ctx->block[2]) + 3299628645U;
#line 126
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 126
    b += c;
#line 129
    a += ((c ^ (b | ~ d)) + ctx->block[0]) + 4096336452U;
#line 129
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 129
    a += b;
#line 130
    d += ((b ^ (a | ~ c)) + ctx->block[7]) + 1126891415U;
#line 130
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 130
    d += a;
#line 131
    c += ((a ^ (d | ~ b)) + ctx->block[14]) + 2878612391U;
#line 131
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 131
    c += d;
#line 132
    b += ((d ^ (c | ~ a)) + ctx->block[5]) + 4237533241U;
#line 132
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 132
    b += c;
#line 133
    a += ((c ^ (b | ~ d)) + ctx->block[12]) + 1700485571U;
#line 133
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 133
    a += b;
#line 134
    d += ((b ^ (a | ~ c)) + ctx->block[3]) + 2399980690U;
#line 134
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 134
    d += a;
#line 135
    c += ((a ^ (d | ~ b)) + ctx->block[10]) + 4293915773U;
#line 135
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 135
    c += d;
#line 136
    b += ((d ^ (c | ~ a)) + ctx->block[1]) + 2240044497U;
#line 136
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 136
    b += c;
#line 137
    a += ((c ^ (b | ~ d)) + ctx->block[8]) + 1873313359U;
#line 137
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 137
    a += b;
#line 138
    d += ((b ^ (a | ~ c)) + ctx->block[15]) + 4264355552U;
#line 138
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 138
    d += a;
#line 139
    c += ((a ^ (d | ~ b)) + ctx->block[6]) + 2734768916U;
#line 139
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 139
    c += d;
#line 140
    b += ((d ^ (c | ~ a)) + ctx->block[13]) + 1309151649U;
#line 140
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 140
    b += c;
#line 141
    a += ((c ^ (b | ~ d)) + ctx->block[4]) + 4149444226U;
#line 141
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 141
    a += b;
#line 142
    d += ((b ^ (a | ~ c)) + ctx->block[11]) + 3174756917U;
#line 142
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 142
    d += a;
#line 143
    c += ((a ^ (d | ~ b)) + ctx->block[2]) + 718787259U;
#line 143
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 143
    c += d;
#line 144
    b += ((d ^ (c | ~ a)) + ctx->block[9]) + 3951481745U;
#line 144
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 144
    b += c;
#line 146
    a += saved_a;
#line 147
    b += saved_b;
#line 148
    c += saved_c;
#line 149
    d += saved_d;
#line 151
    ptr += 64;
#line 68
    size -= 64U;
#line 68
    if (! size) {
#line 68
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  ctx->a = a;
#line 155
  ctx->b = b;
#line 156
  ctx->c = c;
#line 157
  ctx->d = d;
#line 159
  return ((void const   *)ptr);
}
}
#line 28 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_verbatim___0(int32_t *res , int32_t *smp , int n ) 
{ 


  {
  {
  {
#line 31
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 32
  return;
}
}
#line 34 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_fixed___0(int32_t *res , int32_t *smp , int n , int order ) 
{ 
  int i ;

  {
  {
#line 40
  if (order == 0) {
#line 40
    goto case_0;
  }
#line 43
  if (order == 1) {
#line 43
    goto case_1;
  }
#line 49
  if (order == 2) {
#line 49
    goto case_2;
  }
#line 56
  if (order == 3) {
#line 56
    goto case_3;
  }
#line 64
  if (order == 4) {
#line 64
    goto case_4;
  }
#line 73
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 41
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 42
  return;
  case_1: /* CIL Label */ 
#line 44
  *(res + 0) = *(smp + 0);
#line 45
  i = 1;
  {
  {
#line 45
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < n)) {
#line 45
      goto while_break;
    }
#line 46
    *(res + i) = *(smp + i) - *(smp + (i - 1));
#line 45
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
  case_2: /* CIL Label */ 
#line 50
  *(res + 0) = *(smp + 0);
#line 51
  *(res + 1) = *(smp + 1);
#line 52
  i = 2;
  {
  {
#line 52
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 52
    if (! (i < n)) {
#line 52
      goto while_break___0;
    }
#line 53
    *(res + i) = (*(smp + i) - 2 * *(smp + (i - 1))) + *(smp + (i - 2));
#line 52
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  return;
  case_3: /* CIL Label */ 
#line 57
  *(res + 0) = *(smp + 0);
#line 58
  *(res + 1) = *(smp + 1);
#line 59
  *(res + 2) = *(smp + 2);
#line 60
  i = 3;
  {
  {
#line 60
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! (i < n)) {
#line 60
      goto while_break___1;
    }
#line 61
    *(res + i) = ((*(smp + i) - 3 * *(smp + (i - 1))) + 3 * *(smp + (i - 2))) - *(smp + (i - 3));
#line 60
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  return;
  case_4: /* CIL Label */ 
#line 65
  *(res + 0) = *(smp + 0);
#line 66
  *(res + 1) = *(smp + 1);
#line 67
  *(res + 2) = *(smp + 2);
#line 68
  *(res + 3) = *(smp + 3);
#line 69
  i = 4;
  {
  {
#line 69
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (i < n)) {
#line 69
      goto while_break___2;
    }
#line 70
    *(res + i) = (((*(smp + i) - 4 * *(smp + (i - 1))) + 6 * *(smp + (i - 2))) - 4 * *(smp + (i - 3))) + *(smp + (i - 4));
#line 69
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 72
  return;
  switch_default: /* CIL Label */ 
#line 73
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_lpc___0(int32_t *res , int32_t *smp , int n , int order ,
                                    int32_t *coefs , int shift ) 
{ 
  int i ;
  int32_t pred ;

  {
#line 84
  i = 0;
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < order)) {
#line 84
      goto while_break;
    }
#line 85
    *(res + i) = *(smp + i);
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  i = order;
  {
  {
#line 87
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < n)) {
#line 87
      goto while_break___0;
    }
#line 88
    pred = 0;
    {
#line 92
    if (order == 32) {
#line 92
      goto case_32;
    }
#line 93
    if (order == 31) {
#line 93
      goto case_31;
    }
#line 94
    if (order == 30) {
#line 94
      goto case_30;
    }
#line 95
    if (order == 29) {
#line 95
      goto case_29;
    }
#line 96
    if (order == 28) {
#line 96
      goto case_28;
    }
#line 97
    if (order == 27) {
#line 97
      goto case_27;
    }
#line 98
    if (order == 26) {
#line 98
      goto case_26;
    }
#line 99
    if (order == 25) {
#line 99
      goto case_25;
    }
#line 100
    if (order == 24) {
#line 100
      goto case_24;
    }
#line 101
    if (order == 23) {
#line 101
      goto case_23;
    }
#line 102
    if (order == 22) {
#line 102
      goto case_22;
    }
#line 103
    if (order == 21) {
#line 103
      goto case_21;
    }
#line 104
    if (order == 20) {
#line 104
      goto case_20;
    }
#line 105
    if (order == 19) {
#line 105
      goto case_19;
    }
#line 106
    if (order == 18) {
#line 106
      goto case_18;
    }
#line 107
    if (order == 17) {
#line 107
      goto case_17;
    }
#line 108
    if (order == 16) {
#line 108
      goto case_16;
    }
#line 109
    if (order == 15) {
#line 109
      goto case_15;
    }
#line 110
    if (order == 14) {
#line 110
      goto case_14;
    }
#line 111
    if (order == 13) {
#line 111
      goto case_13;
    }
#line 112
    if (order == 12) {
#line 112
      goto case_12;
    }
#line 113
    if (order == 11) {
#line 113
      goto case_11;
    }
#line 114
    if (order == 10) {
#line 114
      goto case_10;
    }
#line 115
    if (order == 9) {
#line 115
      goto case_9;
    }
#line 116
    if (order == 8) {
#line 116
      goto case_8;
    }
#line 117
    if (order == 7) {
#line 117
      goto case_7;
    }
#line 118
    if (order == 6) {
#line 118
      goto case_6;
    }
#line 119
    if (order == 5) {
#line 119
      goto case_5;
    }
#line 120
    if (order == 4) {
#line 120
      goto case_4;
    }
#line 121
    if (order == 3) {
#line 121
      goto case_3;
    }
#line 122
    if (order == 2) {
#line 122
      goto case_2;
    }
#line 123
    if (order == 1) {
#line 123
      goto case_1;
    }
#line 125
    goto switch_default;
    case_32: /* CIL Label */ 
#line 92
    pred += *(coefs + 31) * *(smp + (i - 32));
    case_31: /* CIL Label */ 
#line 93
    pred += *(coefs + 30) * *(smp + (i - 31));
    case_30: /* CIL Label */ 
#line 94
    pred += *(coefs + 29) * *(smp + (i - 30));
    case_29: /* CIL Label */ 
#line 95
    pred += *(coefs + 28) * *(smp + (i - 29));
    case_28: /* CIL Label */ 
#line 96
    pred += *(coefs + 27) * *(smp + (i - 28));
    case_27: /* CIL Label */ 
#line 97
    pred += *(coefs + 26) * *(smp + (i - 27));
    case_26: /* CIL Label */ 
#line 98
    pred += *(coefs + 25) * *(smp + (i - 26));
    case_25: /* CIL Label */ 
#line 99
    pred += *(coefs + 24) * *(smp + (i - 25));
    case_24: /* CIL Label */ 
#line 100
    pred += *(coefs + 23) * *(smp + (i - 24));
    case_23: /* CIL Label */ 
#line 101
    pred += *(coefs + 22) * *(smp + (i - 23));
    case_22: /* CIL Label */ 
#line 102
    pred += *(coefs + 21) * *(smp + (i - 22));
    case_21: /* CIL Label */ 
#line 103
    pred += *(coefs + 20) * *(smp + (i - 21));
    case_20: /* CIL Label */ 
#line 104
    pred += *(coefs + 19) * *(smp + (i - 20));
    case_19: /* CIL Label */ 
#line 105
    pred += *(coefs + 18) * *(smp + (i - 19));
    case_18: /* CIL Label */ 
#line 106
    pred += *(coefs + 17) * *(smp + (i - 18));
    case_17: /* CIL Label */ 
#line 107
    pred += *(coefs + 16) * *(smp + (i - 17));
    case_16: /* CIL Label */ 
#line 108
    pred += *(coefs + 15) * *(smp + (i - 16));
    case_15: /* CIL Label */ 
#line 109
    pred += *(coefs + 14) * *(smp + (i - 15));
    case_14: /* CIL Label */ 
#line 110
    pred += *(coefs + 13) * *(smp + (i - 14));
    case_13: /* CIL Label */ 
#line 111
    pred += *(coefs + 12) * *(smp + (i - 13));
    case_12: /* CIL Label */ 
#line 112
    pred += *(coefs + 11) * *(smp + (i - 12));
    case_11: /* CIL Label */ 
#line 113
    pred += *(coefs + 10) * *(smp + (i - 11));
    case_10: /* CIL Label */ 
#line 114
    pred += *(coefs + 9) * *(smp + (i - 10));
    case_9: /* CIL Label */ 
#line 115
    pred += *(coefs + 8) * *(smp + (i - 9));
    case_8: /* CIL Label */ 
#line 116
    pred += *(coefs + 7) * *(smp + (i - 8));
    case_7: /* CIL Label */ 
#line 117
    pred += *(coefs + 6) * *(smp + (i - 7));
    case_6: /* CIL Label */ 
#line 118
    pred += *(coefs + 5) * *(smp + (i - 6));
    case_5: /* CIL Label */ 
#line 119
    pred += *(coefs + 4) * *(smp + (i - 5));
    case_4: /* CIL Label */ 
#line 120
    pred += *(coefs + 3) * *(smp + (i - 4));
    case_3: /* CIL Label */ 
#line 121
    pred += *(coefs + 2) * *(smp + (i - 3));
    case_2: /* CIL Label */ 
#line 122
    pred += *(coefs + 1) * *(smp + (i - 2));
    case_1: /* CIL Label */ 
#line 123
    pred += *(coefs + 0) * *(smp + (i - 1));
    switch_default: /* CIL Label */ 
#line 125
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 127
    *(res + i) = *(smp + i) - (pred >> shift);
#line 87
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static void crc_init_table___0(uint16_t *table , int bits , int poly ) 
{ 
  int i ;
  int j ;
  int crc ;

  {
#line 29
  poly += 1 << bits;
#line 30
  i = 0;
  {
  {
#line 30
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < 256)) {
#line 30
      goto while_break;
    }
#line 31
    crc = i;
#line 32
    j = 0;
    {
    {
#line 32
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 32
      if (! (j < bits)) {
#line 32
        goto while_break___0;
      }
#line 33
      if (crc & (1 << (bits - 1))) {
#line 34
        crc = (crc << 1) ^ poly;
      } else {
#line 36
        crc <<= 1;
      }
#line 32
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    *(table + i) = (uint16_t )(crc & ((1 << bits) - 1));
#line 30
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc8tab___0[256]  ;
#line 50 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc16tab___0[256]  ;
#line 59 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t calc_crc___0(uint16_t const   *table , int bits , uint8_t const   *data ,
                             uint32_t len ) 
{ 
  uint16_t crc ;
  uint16_t v1 ;
  uint16_t v2 ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 64
  crc = (uint16_t )0;
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    tmp___0 = len;
#line 65
    len --;
#line 65
    if (! tmp___0) {
#line 65
      goto while_break;
    }
#line 66
    v1 = (uint16_t )(((int )crc << 8) & ((1 << bits) - 1));
#line 67
    tmp = data;
#line 67
    data ++;
#line 67
    v2 = (uint16_t )(((int )crc >> (bits - 8)) ^ (int )*tmp);
#line 68
    if (! ((int )v2 < 256)) {
      {
      {
#line 68
      __assert_fail("v2 < 256", "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c",
                    68U, "calc_crc");
      }
      }
    }
#line 69
    crc = (uint16_t )((int )v1 ^ (int )*(table + v2));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (crc);
}
}
#line 36 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v1___0(int16_t *samples , int channels , int block_size ,
                               int *frames , int *sizes ) 
{ 
  int i ;
  int ch ;
  int j ;
  int n ;
  int64_t res[8] ;
  int layout[8] ;
  int16_t *sptr ;
  int16_t *sptr0 ;
  int16_t *sptr1 ;
  int16_t *sptr2 ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
#line 41
  n = block_size >> 3;
#line 47
  i = 0;
  {
  {
#line 47
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 8)) {
#line 47
      goto while_break;
    }
#line 48
    sptr = samples + (i * n) * channels;
#line 49
    res[i] = (int64_t )0;
#line 50
    ch = 0;
    {
    {
#line 50
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (ch < channels)) {
#line 50
        goto while_break___0;
      }
#line 51
      sptr0 = sptr + (2 * channels + ch);
#line 52
      sptr1 = sptr0 - channels;
#line 53
      sptr2 = sptr1 - channels;
#line 54
      j = 2;
      {
      {
#line 54
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (j < n)) {
#line 54
          goto while_break___1;
        }
        {
        {
#line 55
        tmp = abs(((int )*sptr0 - 2 * (int )*sptr1) + (int )*sptr2);
        }
#line 55
        res[i] += (int64_t )tmp;
#line 56
        sptr0 += channels;
#line 57
        sptr1 += channels;
#line 58
        sptr2 += channels;
#line 54
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 50
      ch ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    res[i] /= (int64_t )channels;
#line 62
    (res[i]) ++;
#line 47
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  memset((void *)(layout), 0, (size_t )(8UL * sizeof(int )));
  }
#line 67
  layout[0] = 1;
#line 68
  i = 0;
  }
  {
  {
#line 68
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 68
    if (! (i < 7)) {
#line 68
      goto while_break___2;
    }
    {
    {
#line 69
    tmp___0 = abs((int )(res[i] - res[i + 1]));
    }
    }
#line 69
    if ((int64_t )(tmp___0 * 200) / res[i] > 100L) {
#line 70
      layout[i + 1] = 1;
    }
#line 68
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  *(frames + 0) = 0;
  {
#line 76
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 77
  i = 0;
  }
  {
  {
#line 77
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 77
    if (! (i < 8)) {
#line 77
      goto while_break___3;
    }
#line 78
    if (layout[i]) {
#line 79
      (*(frames + 0)) ++;
    }
#line 81
    *(sizes + (*(frames + 0) - 1)) += n;
#line 77
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v2___0(FlakeContext *s , int16_t *samples , int *frames ,
                               int *sizes ) 
{ 
  int fsizes[4][8] ;
  int layout[8] ;
  int i ;
  int j ;
  int n ;
  int ch ;
  FlacEncodeContext *ctx ;
  int levels ;
  int bs ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 91
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 92
  ch = ctx->channels;
#line 95
  i = 0;
  {
  {
#line 95
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 4)) {
#line 95
      goto while_break;
    }
#line 97
    levels = 1 << i;
#line 98
    s->params.block_size /= levels;
#line 99
    bs = s->params.block_size;
#line 100
    j = 0;
    {
    {
#line 100
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < levels)) {
#line 100
        goto while_break___0;
      }
      {
      {
#line 101
      fsizes[i][j] = encode_frame(s, (uint8_t *)((void *)0), samples + (bs * j) * ch);
      }
#line 100
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    s->params.block_size *= levels;
#line 95
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = 0;
  {
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i < 8)) {
#line 107
      goto while_break___1;
    }
#line 107
    layout[i] = 1;
#line 107
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 109
  if (fsizes[2][0] < fsizes[3][0] + fsizes[3][1]) {
#line 110
    layout[1] = 0;
  }
#line 112
  if (fsizes[2][1] < fsizes[3][2] + fsizes[3][3]) {
#line 113
    layout[3] = 0;
  }
#line 115
  if (fsizes[2][2] < fsizes[3][4] + fsizes[3][5]) {
#line 116
    layout[5] = 0;
  }
#line 118
  if (fsizes[2][3] < fsizes[3][6] + fsizes[3][7]) {
#line 119
    layout[7] = 0;
  }
#line 122
  if (layout[1] == 0) {
#line 122
    if (layout[3] == 0) {
#line 123
      if (fsizes[1][0] < fsizes[2][0] + fsizes[2][1]) {
#line 124
        layout[2] = 0;
      }
    }
  }
#line 127
  if (layout[5] == 0) {
#line 127
    if (layout[7] == 0) {
#line 128
      if (fsizes[1][1] < fsizes[2][2] + fsizes[2][3]) {
#line 129
        layout[6] = 0;
      }
    }
  }
#line 133
  if (layout[2] == 0) {
#line 133
    if (layout[6] == 0) {
#line 134
      if (fsizes[0][0] < fsizes[1][0] + fsizes[1][1]) {
#line 135
        layout[4] = 0;
      }
    }
  }
  {
#line 140
  n = s->params.block_size >> 3;
#line 141
  *(frames + 0) = 0;
  {
#line 142
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 143
  i = 0;
  }
  {
  {
#line 143
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < 8)) {
#line 143
      goto while_break___2;
    }
#line 144
    if (layout[i]) {
#line 145
      (*(frames + 0)) ++;
    }
#line 147
    *(sizes + (*(frames + 0) - 1)) += n;
#line 143
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_optimal_rice_params___0(RiceContext *rc , int porder , uint32_t *sums ,
                                             int n , int pred_order ) 
{ 
  int i ;
  int k ;
  int cnt ;
  int part ;
  uint32_t all_bits ;

  {
#line 54
  part = 1 << porder;
#line 55
  all_bits = (uint32_t )0;
#line 57
  cnt = (n >> porder) - pred_order;
#line 58
  i = 0;
  {
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < part)) {
#line 58
      goto while_break;
    }
#line 59
    if (i == 1) {
#line 59
      cnt = n >> porder;
    }
    {
    {
#line 60
    k = find_optimal_rice_param(*(sums + i), cnt);
    }
#line 61
    rc->params[i] = k;
#line 62
    all_bits += (uint32_t )(cnt * (k + 1)) + ((*(sums + i) - (uint32_t )(cnt >> 1)) >> k);
#line 58
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  all_bits += (uint32_t )(4 * part);
#line 66
  rc->porder = porder;
#line 68
  return (all_bits);
}
}
#line 71 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static void calc_sums___0(int pmin , int pmax , uint32_t *data , int n , int pred_order ,
                          uint32_t (*sums)[1 << 8] ) 
{ 
  int i ;
  int j ;
  int parts ;
  int cnt ;
  uint32_t *res ;

  {
#line 80
  parts = 1 << pmax;
#line 81
  res = data + pred_order;
#line 82
  cnt = (n >> pmax) - pred_order;
#line 83
  i = 0;
  {
  {
#line 83
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < parts)) {
#line 83
      goto while_break;
    }
#line 84
    if (i == 1) {
#line 84
      cnt = n >> pmax;
    }
#line 85
    if (i > 0) {
#line 85
      res = data + i * cnt;
    }
#line 86
    (*(sums + pmax))[i] = (uint32_t )0;
#line 87
    j = 0;
    {
    {
#line 87
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 87
      if (! (j < cnt)) {
#line 87
        goto while_break___0;
      }
#line 88
      (*(sums + pmax))[i] += *(res + j);
#line 87
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = pmax - 1;
  {
  {
#line 92
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (i >= pmin)) {
#line 92
      goto while_break___1;
    }
#line 93
    parts = 1 << i;
#line 94
    j = 0;
    {
    {
#line 94
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (j < parts)) {
#line 94
        goto while_break___2;
      }
#line 95
      (*(sums + i))[j] = (*(sums + (i + 1)))[2 * j] + (*(sums + (i + 1)))[2 * j + 1];
#line 94
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 92
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_rice_params___0(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                                     int n , int pred_order ) 
{ 
  int i ;
  uint32_t bits[9] ;
  int opt_porder ;
  RiceContext tmp_rc ;
  uint32_t *udata ;
  uint32_t sums[9][1 << 8] ;
  void *tmp ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 111
  if (pmin >= 0) {
#line 111
    if (! (pmin <= 8)) {
      {
      {
#line 111
      __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    111U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 111
    __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  111U, "calc_rice_params");
    }
    }
  }
#line 112
  if (pmax >= 0) {
#line 112
    if (! (pmax <= 8)) {
      {
      {
#line 112
      __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    112U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 112
    __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  112U, "calc_rice_params");
    }
    }
  }
#line 113
  if (! (pmin <= pmax)) {
    {
    {
#line 113
    __assert_fail("pmin <= pmax", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  113U, "calc_rice_params");
    }
    }
  }
  {
  {
#line 115
  tmp = malloc((size_t )((unsigned long )n * sizeof(uint32_t )));
  }
#line 115
  udata = (uint32_t *)tmp;
#line 116
  i = 0;
  }
  {
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < n)) {
#line 116
      goto while_break;
    }
#line 117
    *(udata + i) = (uint32_t )(2 * *(data + i) ^ (*(data + i) >> 31));
#line 116
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 120
  calc_sums___0(pmin, pmax, udata, n, pred_order, sums);
  }
#line 122
  opt_porder = pmin;
#line 123
  bits[pmin] = 4294967295U;
#line 124
  i = pmin;
  }
  {
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (i <= pmax)) {
#line 124
      goto while_break___0;
    }
    {
    {
#line 125
    bits[i] = calc_optimal_rice_params___0(& tmp_rc, i, sums[i], n, pred_order);
    }
    }
#line 126
    if (bits[i] <= bits[opt_porder]) {
#line 127
      opt_porder = i;
#line 128
      *rc = tmp_rc;
    }
#line 124
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 132
  free((void *)udata);
  }
  }
#line 133
  return (bits[opt_porder]);
}
}
#line 136 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static int get_max_p_order___0(int max_porder , int n , int order ) 
{ 
  int porder ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 139
  tmp___2 = log2i((uint32_t )(n ^ (n - 1)));
  }
  }
#line 139
  if (max_porder > tmp___2) {
    {
    {
#line 139
    tmp___0 = log2i((uint32_t )(n ^ (n - 1)));
    }
#line 139
    tmp___1 = tmp___0;
    }
  } else {
#line 139
    tmp___1 = max_porder;
  }
#line 139
  porder = tmp___1;
#line 140
  if (order > 0) {
    {
    {
#line 141
    tmp___5 = log2i((uint32_t )(n / order));
    }
    }
#line 141
    if (porder > tmp___5) {
      {
      {
#line 141
      tmp___4 = log2i((uint32_t )(n / order));
      }
#line 141
      porder = tmp___4;
      }
    } else {
#line 141
      porder = porder;
    }
  }
#line 142
  return (porder);
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_autocorr___0(int32_t const   *data , int len , int lag , double *autoc ) 
{ 
  int i ;
  int j ;
  double *data1 ;
  double temp ;
  double temp2 ;
  void *tmp ;

  {
  {
  {
#line 53
  tmp = malloc((size_t )((unsigned long )(len + 16) * sizeof(double )));
  }
#line 53
  data1 = (double *)tmp;
  {
#line 54
  apply_welch_window(data, len, data1);
  }
#line 55
  *(data1 + len) = (double )0;
#line 57
  i = 0;
  }
  {
  {
#line 57
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= lag)) {
#line 57
      goto while_break;
    }
#line 58
    temp = 1.0;
#line 59
    temp2 = 1.0;
#line 60
    j = 0;
    {
    {
#line 60
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (j <= lag - i)) {
#line 60
        goto while_break___0;
      }
#line 61
      temp += *(data1 + (j + i)) * *(data1 + j);
#line 60
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    j = lag + 1;
    {
    {
#line 63
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 63
      if (! (j <= len - 1)) {
#line 63
        goto while_break___1;
      }
#line 64
      temp += *(data1 + j) * *(data1 + (j - i));
#line 65
      temp2 += *(data1 + (j + 1)) * *(data1 + ((j + 1) - i));
#line 63
      j += 2;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 67
    *(autoc + i) = temp + temp2;
#line 57
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 70
  free((void *)data1);
  }
  }
#line 71
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_lpc_coefs___0(double const   *autoc , int max_order , double *ref ,
                                  double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  int i2 ;
  double r ;
  double err ;
  double tmp ;
  double lpc_tmp[32] ;
  void *__cil_tmp12 ;

  {
#line 85
  i = 0;
  {
  {
#line 85
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < max_order)) {
#line 85
      goto while_break;
    }
#line 85
    lpc_tmp[i] = (double )0;
#line 85
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  err = 1.0;
#line 87
  if (autoc) {
#line 88
    err = (double )*(autoc + 0);
  }
#line 91
  i = 0;
  {
  {
#line 91
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < max_order)) {
#line 91
      goto while_break___0;
    }
#line 92
    if (ref) {
#line 93
      r = *(ref + i);
    } else {
#line 95
      r = (double )(- *(autoc + (i + 1)));
#line 96
      j = 0;
      {
      {
#line 96
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 96
        if (! (j < i)) {
#line 96
          goto while_break___1;
        }
#line 97
        r -= lpc_tmp[j] * (double )*(autoc + (i - j));
#line 96
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 99
      r /= err;
#line 100
      err *= 1.0 - r * r;
    }
#line 103
    i2 = i >> 1;
#line 104
    lpc_tmp[i] = r;
#line 105
    j = 0;
    {
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 105
      if (! (j < i2)) {
#line 105
        goto while_break___2;
      }
#line 106
      tmp = lpc_tmp[j];
#line 107
      lpc_tmp[j] += r * lpc_tmp[(i - 1) - j];
#line 108
      lpc_tmp[(i - 1) - j] += r * tmp;
#line 105
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 110
    if (i & 1) {
#line 111
      lpc_tmp[j] += lpc_tmp[j] * r;
    }
#line 114
    j = 0;
    {
    {
#line 114
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 114
      if (! (j <= i)) {
#line 114
        goto while_break___3;
      }
#line 115
      (*(lpc + i))[j] = - lpc_tmp[j];
#line 114
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 91
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 126 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static int compute_lpc_coefs_est___0(double const   *autoc , int max_order , double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  double error ;
  double gen[2][32] ;
  double ref[32] ;
  int order_est ;
  double tmp ;
  double tmp___0 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 137
  i = 0;
  {
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < max_order)) {
#line 137
      goto while_break;
    }
#line 137
    tmp = (double )*(autoc + (i + 1));
#line 137
    gen[1][i] = tmp;
#line 137
    gen[0][i] = tmp;
#line 137
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  error = (double )*(autoc + 0);
#line 139
  ref[0] = - gen[1][0] / error;
#line 140
  error += gen[1][0] * ref[0];
#line 141
  i = 1;
  {
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (i < max_order)) {
#line 141
      goto while_break___0;
    }
#line 142
    j = 0;
    {
    {
#line 142
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 142
      if (! (j < max_order - i)) {
#line 142
        goto while_break___1;
      }
#line 143
      gen[1][j] = gen[1][j + 1] + ref[i - 1] * gen[0][j];
#line 144
      gen[0][j] = gen[1][j + 1] * ref[i - 1] + gen[0][j];
#line 142
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 146
    ref[i] = - gen[1][0] / error;
#line 147
    error += gen[1][0] * ref[i];
#line 141
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  order_est = 1;
#line 152
  i = max_order - 1;
  {
  {
#line 152
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 152
    if (! (i >= 0)) {
#line 152
      goto while_break___2;
    }
    {
    {
#line 153
    tmp___0 = fabs(ref[i]);
    }
    }
#line 153
    if (tmp___0 > 0.10) {
#line 154
      order_est = i + 1;
#line 155
      goto while_break___2;
    }
#line 152
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 160
  compute_lpc_coefs___0((double const   *)((void *)0), order_est, ref, lpc);
  }
  }
#line 162
  return (order_est);
}
}
#line 168 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void quantize_lpc_coefs___0(double *lpc_in , int order , int precision , int32_t *lpc_out ,
                                   int *shift ) 
{ 
  int i ;
  double d ;
  double cmax ;
  double error ;
  int32_t qmax ;
  int sh ;
  int q ;
  double scale ;

  {
#line 178
  qmax = (1 << (precision - 1)) - 1;
#line 181
  cmax = 0.0;
#line 182
  i = 0;
  {
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < order)) {
#line 182
      goto while_break;
    }
    {
    {
#line 183
    d = fabs(*(lpc_in + i));
    }
    }
#line 184
    if (d > cmax) {
#line 185
      cmax = d;
    }
#line 182
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (cmax * (double )(1 << 15) < 1.0) {
    {
#line 189
    *shift = 0;
    {
#line 190
    memset((void *)lpc_out, 0, (size_t )(sizeof(int32_t ) * (unsigned long )order));
    }
    }
#line 191
    return;
  }
#line 195
  sh = 15;
  {
  {
#line 196
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 196
    if (cmax * (double )(1 << sh) > (double )qmax) {
#line 196
      if (! (sh > 0)) {
#line 196
        goto while_break___0;
      }
    } else {
#line 196
      goto while_break___0;
    }
#line 197
    sh --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  if (sh == 0) {
#line 202
    if (cmax > (double )qmax) {
#line 203
      scale = (double )qmax / cmax;
#line 204
      i = 0;
      {
      {
#line 204
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i < order)) {
#line 204
          goto while_break___1;
        }
#line 205
        *(lpc_in + i) *= scale;
#line 204
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 210
  error = (double )0;
#line 211
  i = 0;
  {
  {
#line 211
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 211
    if (! (i < order)) {
#line 211
      goto while_break___2;
    }
#line 212
    error += *(lpc_in + i) * (double )(1 << sh);
#line 213
    q = (int )(error + 0.5);
#line 214
    if (q <= - qmax) {
#line 214
      q = - qmax + 1;
    }
#line 215
    if (q > qmax) {
#line 215
      q = qmax;
    }
#line 216
    error -= (double )q;
#line 217
    *(lpc_out + i) = q;
#line 211
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 219
  *shift = sh;
#line 220
  return;
}
}
#line 38 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_usage___0(FILE *out ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 41
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"usage: flake [options] <input.wav> [-o output.flac]\ntype \'flake -h\' for more details.\n\n");
  }
  }
#line 43
  return;
}
}
#line 45 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_help___0(FILE *out ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 48
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"usage: flake [options] <input.wav> [-o output.flac]\noptions:\n       [-h]         Print out list of commandline options\n       [-q]         Quiet mode\n       [-p #]       Padding bytes to put in header (default: 4096)\n       [-0 ... -12] Compression level (default: 5)\n                        0 = -b 1152 -t 1 -l 2,2 -m 0 -r 4,4 -s 0\n                        1 = -b 1152 -t 1 -l 3,4 -m 1 -r 2,2 -s 1\n                        2 = -b 1152 -t 1 -l 2,4 -m 1 -r 3   -s 1\n                        3 = -b 4608 -t 2 -l 6   -m 1 -r 3   -s 1\n                        4 = -b 4608 -t 2 -l 8   -m 1 -r 3   -s 1\n                        5 = -b 4608 -t 2 -l 8   -m 1 -r 6   -s 1\n                        6 = -b 4608 -t 2 -l 8   -m 2 -r 8   -s 1\n                        7 = -b 4608 -t 2 -l 8   -m 3 -r 8   -s 1\n                        8 = -b 4608 -t 2 -l 12  -m 3 -r 8   -s 1\n                        9 = -b 4608 -t 2 -l 12  -m 6 -r 8   -s 1\n                       10 = -b 4608 -t 2 -l 12  -m 5 -r 8   -s 1\n                       11 = -b 4608 -t 2 -l 32  -m 6 -r 8   -s 1\n                       12 = -b 4608 -t 2 -l 32  -m 5 -r 8   -s 1\n       [-b #]       Block size [16 - 65535] (default: 4608)\n       [-t #]       Prediction type\n                        0 = no prediction / verbatim\n                        1 = fixed prediction\n                        2 = Levinson-Durbin recursion (default)\n       [-l #[,#]]   Prediction order {max} or {min},{max} (default: 1,8)\n       [-m #]       Prediction order selection method\n                        0 = maximum\n                        1 = estimate (default)\n                        2 = 2-level\n                        3 = 4-level\n                        4 = 8-level\n                        5 = full search\n                        6 = log search\n       [-r #[,#]]   Rice partition order {max} or {min},{max} (default: 0,6)\n       [-s #]       Stereo decorrelation method\n                        0 = independent L+R channels\n                        1 = mid-side (default)\n       [-v #]       Variable block size\n                        0 = fixed (default)\n                        1 = variable, method 1\n                        2 = variable, method 2\n\n");
  }
  }
#line 90
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int parse_number___0(char *arg , int max ) 
{ 
  int i ;
  int m ;
  int n ;
  int digits ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 120
  m = 0;
#line 121
  n = 0;
#line 123
  i = 0;
  {
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < max)) {
#line 123
      goto while_break;
    }
#line 124
    if ((int )*(arg + i) == 0) {
#line 124
      goto while_break;
    }
#line 125
    if (m == 0) {
#line 125
      m = 1;
    } else {
#line 126
      m *= 10;
    }
#line 123
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((int )*(arg + i) != 0) {
#line 128
    return (-1);
  }
#line 129
  digits = i;
#line 130
  i = 0;
  {
  {
#line 130
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (i < digits)) {
#line 130
      goto while_break___0;
    }
#line 131
    if ((int )*(arg + i) < 48) {
      {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid digit: %c (ASCII:0x%02X)\n",
              (int )*(arg + i), (int )*(arg + i));
      }
      }
#line 133
      return (-1);
    } else
#line 131
    if ((int )*(arg + i) > 57) {
      {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid digit: %c (ASCII:0x%02X)\n",
              (int )*(arg + i), (int )*(arg + i));
      }
      }
#line 133
      return (-1);
    }
#line 135
    n += ((int )*(arg + i) - 48) * m;
#line 136
    m /= 10;
#line 130
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  return (n);
}
}
#line 145
static int parse_commandline___0(int argc , char **argv , CommandOptions *opts ) ;
#line 145 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static char const   *param_str___0  =    "bhlmopqrstv";
#line 141 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int parse_commandline___0(int argc , char **argv , CommandOptions *opts ) 
{ 
  int i ;
  int max_digits ;
  int ifc ;
  void *tmp ;
  char *tmp___0 ;
  char *po ;
  char *tmp___1 ;
  char *tmp___2 ;
  int olen ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *po___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int ext ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 146
  max_digits = 8;
#line 147
  ifc = 0;
#line 149
  opts->filelist = (FilePair *)((void *)0);
#line 150
  if (argc < 2) {
#line 151
    return (1);
  }
  {
  {
#line 154
  tmp = calloc((size_t )((unsigned long )argc * sizeof(FilePair )), (size_t )1);
  }
#line 154
  opts->filelist = (FilePair *)tmp;
#line 155
  opts->input_count = 0;
#line 156
  opts->found_output = 0;
#line 157
  opts->compr = 5;
#line 158
  opts->omethod = -1;
#line 159
  opts->ptype = -1;
#line 160
  opts->omin = -1;
#line 161
  opts->omax = -1;
#line 162
  opts->pomin = -1;
#line 163
  opts->pomax = -1;
#line 164
  opts->bsize = -1;
#line 165
  opts->stmethod = -1;
#line 166
  opts->padding = -1;
#line 167
  opts->vbs = -1;
#line 168
  opts->quiet = 0;
#line 170
  i = 1;
  }
  {
  {
#line 170
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < argc)) {
#line 170
      goto while_break;
    }
#line 171
    if ((int )*(*(argv + i) + 0) == 45) {
#line 171
      if ((int )*(*(argv + i) + 1) != 0) {
#line 172
        if ((int )*(*(argv + i) + 1) >= 48) {
#line 172
          if ((int )*(*(argv + i) + 1) <= 57) {
#line 173
            if ((int )*(*(argv + i) + 2) != 0) {
#line 173
              if ((int )*(*(argv + i) + 3) != 0) {
#line 174
                (opts->filelist + ifc)->infile = *(argv + i);
#line 175
                ifc ++;
              } else {
#line 173
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
              {
#line 177
              opts->compr = parse_number___0(*(argv + i) + 1, max_digits);
              }
              }
#line 178
              if (opts->compr < 0) {
#line 178
                return (1);
              }
            }
          } else {
#line 172
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 183
          if ((int )*(*(argv + i) + 2) != 0) {
#line 184
            (opts->filelist + ifc)->infile = *(argv + i);
#line 185
            ifc ++;
#line 186
            goto __Cont;
          }
          {
          {
#line 189
          tmp___0 = strchr(param_str___0, (int )*(*(argv + i) + 1));
          }
          }
#line 189
          if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
            {
            {
#line 190
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid option: -%c\n",
                    (int )*(*(argv + i) + 1));
            }
            }
#line 191
            return (1);
          }
#line 194
          if ((int )*(*(argv + i) + 1) == 104) {
#line 195
            return (2);
          }
#line 197
          i ++;
#line 198
          if (i >= argc) {
            {
            {
#line 199
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"incomplete option: -%c\n",
                    (int )*(*(argv + (i - 1)) + 1));
            }
            }
#line 200
            return (1);
          }
          {
#line 204
          if ((int )*(*(argv + (i - 1)) + 1) == 98) {
#line 204
            goto case_98;
          }
#line 208
          if ((int )*(*(argv + (i - 1)) + 1) == 108) {
#line 208
            goto case_108;
          }
#line 228
          if ((int )*(*(argv + (i - 1)) + 1) == 109) {
#line 228
            goto case_109;
          }
#line 232
          if ((int )*(*(argv + (i - 1)) + 1) == 111) {
#line 232
            goto case_111;
          }
#line 242
          if ((int )*(*(argv + (i - 1)) + 1) == 112) {
#line 242
            goto case_112;
          }
#line 246
          if ((int )*(*(argv + (i - 1)) + 1) == 113) {
#line 246
            goto case_113;
          }
#line 250
          if ((int )*(*(argv + (i - 1)) + 1) == 114) {
#line 250
            goto case_114;
          }
#line 264
          if ((int )*(*(argv + (i - 1)) + 1) == 115) {
#line 264
            goto case_115;
          }
#line 268
          if ((int )*(*(argv + (i - 1)) + 1) == 116) {
#line 268
            goto case_116;
          }
#line 272
          if ((int )*(*(argv + (i - 1)) + 1) == 118) {
#line 272
            goto case_118;
          }
#line 203
          goto switch_break;
          case_98: /* CIL Label */ 
          {
          {
#line 205
          opts->bsize = parse_number___0(*(argv + i), max_digits);
          }
          }
#line 206
          if (opts->bsize < 0) {
#line 206
            return (1);
          }
#line 207
          goto switch_break;
          case_108: /* CIL Label */ 
          {
          {
#line 209
          tmp___2 = strchr((char const   *)*(argv + i), ',');
          }
          }
#line 209
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
#line 210
            opts->omin = 0;
            {
#line 211
            opts->omax = parse_number___0(*(argv + i), max_digits);
            }
            }
#line 212
            if (opts->omax < 0) {
#line 212
              return (1);
            }
          } else {
            {
            {
#line 214
            tmp___1 = strchr((char const   *)*(argv + i), ',');
            }
#line 214
            po = tmp___1;
#line 215
            *(po + 0) = (char )'\000';
            {
#line 216
            opts->omin = parse_number___0(*(argv + i), max_digits);
            }
            }
#line 217
            if (opts->omin < 0) {
#line 217
              return (1);
            }
            {
            {
#line 218
            opts->omax = parse_number___0(po + 1, max_digits);
            }
            }
#line 219
            if (opts->omax < 0) {
#line 219
              return (1);
            }
          }
#line 222
          if (opts->ptype == 1) {
#line 223
            if (opts->omax > 4) {
#line 223
              opts->omax = 4;
            }
          } else
#line 224
          if (opts->ptype == 2) {
#line 225
            if (opts->omin == 0) {
#line 225
              opts->omin = 1;
            }
          }
#line 227
          goto switch_break;
          case_109: /* CIL Label */ 
          {
          {
#line 229
          opts->omethod = parse_number___0(*(argv + i), max_digits);
          }
          }
#line 230
          if (opts->omethod < 0) {
#line 230
            return (1);
          }
#line 231
          goto switch_break;
          case_111: /* CIL Label */ 
#line 233
          if (opts->found_output) {
#line 234
            return (1);
          } else {
            {
            {
#line 236
            tmp___3 = strnlen((char const   *)*(argv + i), (size_t )4096);
            }
#line 236
            olen = (int )(tmp___3 + 1U);
            {
#line 237
            tmp___4 = calloc((size_t )1, (size_t )(olen + 5));
            }
#line 237
            (opts->filelist + 0)->outfile = (char *)tmp___4;
            {
#line 238
            strncpy((char */* __restrict  */)(opts->filelist + 0)->outfile, (char const   */* __restrict  */)*(argv + i),
                    (size_t )olen);
            }
#line 239
            opts->found_output = 1;
            }
          }
#line 241
          goto switch_break;
          case_112: /* CIL Label */ 
          {
          {
#line 243
          opts->padding = parse_number___0(*(argv + i), max_digits);
          }
          }
#line 244
          if (opts->padding < 0) {
#line 244
            return (1);
          }
#line 245
          goto switch_break;
          case_113: /* CIL Label */ 
#line 247
          i --;
#line 248
          opts->quiet = 1;
#line 249
          goto switch_break;
          case_114: /* CIL Label */ 
          {
          {
#line 251
          tmp___6 = strchr((char const   *)*(argv + i), ',');
          }
          }
#line 251
          if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
            {
#line 252
            opts->pomin = 0;
            {
#line 253
            opts->pomax = parse_number___0(*(argv + i), max_digits);
            }
            }
#line 254
            if (opts->pomax < 0) {
#line 254
              return (1);
            }
          } else {
            {
            {
#line 256
            tmp___5 = strchr((char const   *)*(argv + i), ',');
            }
#line 256
            po___0 = tmp___5;
#line 257
            *(po___0 + 0) = (char )'\000';
            {
#line 258
            opts->pomin = parse_number___0(*(argv + i), max_digits);
            }
            }
#line 259
            if (opts->pomin < 0) {
#line 259
              return (1);
            }
            {
            {
#line 260
            opts->pomax = parse_number___0(po___0 + 1, max_digits);
            }
            }
#line 261
            if (opts->pomax < 0) {
#line 261
              return (1);
            }
          }
#line 263
          goto switch_break;
          case_115: /* CIL Label */ 
          {
          {
#line 265
          opts->stmethod = parse_number___0(*(argv + i), max_digits);
          }
          }
#line 266
          if (opts->stmethod < 0) {
#line 266
            return (1);
          }
#line 267
          goto switch_break;
          case_116: /* CIL Label */ 
          {
          {
#line 269
          opts->ptype = parse_number___0(*(argv + i), max_digits);
          }
          }
#line 270
          if (opts->ptype < 0) {
#line 270
            return (1);
          }
#line 271
          goto switch_break;
          case_118: /* CIL Label */ 
          {
          {
#line 273
          opts->vbs = parse_number___0(*(argv + i), max_digits);
          }
          }
#line 274
          if (opts->vbs < 0) {
#line 274
            return (1);
          }
#line 275
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
#line 281
        (opts->filelist + ifc)->infile = *(argv + i);
#line 282
        ifc ++;
      }
    } else {
#line 281
      (opts->filelist + ifc)->infile = *(argv + i);
#line 282
      ifc ++;
    }
    __Cont: /* CIL Label */ 
#line 170
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (! ifc) {
    {
    {
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error parsing filenames.\n");
    }
    }
#line 287
    return (1);
  }
#line 289
  if (opts->found_output) {
#line 289
    if (ifc > 1) {
      {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot specify output file when using multiple input files\n");
      }
      }
#line 291
      return (1);
    }
  }
#line 293
  if (! opts->found_output) {
#line 295
    i = 0;
    {
    {
#line 295
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (i < ifc)) {
#line 295
        goto while_break___0;
      }
      {
      {
#line 296
      tmp___7 = strnlen((char const   *)(opts->filelist + i)->infile, (size_t )4096);
      }
#line 296
      ext = (int )tmp___7;
      {
#line 297
      tmp___8 = calloc((size_t )1, (size_t )(ext + 6));
      }
#line 297
      (opts->filelist + i)->outfile = (char *)tmp___8;
      {
#line 298
      strncpy((char */* __restrict  */)(opts->filelist + i)->outfile, (char const   */* __restrict  */)(opts->filelist + i)->infile,
              (size_t )(ext + 1));
      }
#line 299
      *((opts->filelist + i)->outfile + ext) = (char )'\000';
      }
      {
      {
#line 300
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 300
        if (ext > 0) {
#line 300
          if (! ((int )*((opts->filelist + i)->outfile + ext) != 46)) {
#line 300
            goto while_break___1;
          }
        } else {
#line 300
          goto while_break___1;
        }
#line 300
        ext --;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 301
      if (ext >= 4091) {
        {
        {
#line 302
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input filename too long\n");
        }
        }
#line 303
        return (1);
      }
      {
      {
#line 305
      strncpy((char */* __restrict  */)((opts->filelist + i)->outfile + ext), (char const   */* __restrict  */)".flac",
              (size_t )6);
      }
#line 295
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 310
  i = 0;
  {
  {
#line 310
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 310
    if (! (i < ifc)) {
#line 310
      goto while_break___2;
    }
    {
    {
#line 311
    tmp___10 = strncmp((char const   *)(opts->filelist + i)->infile, "-", (size_t )2);
    }
    }
#line 311
    if (tmp___10) {
      {
      {
#line 311
      tmp___11 = strncmp((char const   *)(opts->filelist + i)->outfile, "-", (size_t )2);
      }
      }
#line 311
      if (tmp___11) {
        {
        {
#line 312
        tmp___9 = strcmp((char const   *)(opts->filelist + i)->infile, (char const   *)(opts->filelist + i)->outfile);
        }
        }
#line 312
        if (! tmp___9) {
          {
          {
#line 313
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output filename cannot match input filename\n");
          }
          }
#line 314
          return (1);
        }
      }
    }
#line 310
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 319
  opts->input_count = ifc;
#line 320
  return (0);
}
}
#line 323 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_params___0(FlakeContext *s ) 
{ 
  char *omethod_s ;
  char *stmethod_s ;
  char *ptype_s ;
  char *vbs_s ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 328
  vbs_s = (char *)"ERROR";
  {
#line 330
  if (s->params.variable_block_size == 0) {
#line 330
    goto case_0;
  }
#line 331
  if (s->params.variable_block_size == 1) {
#line 331
    goto case_1;
  }
#line 332
  if (s->params.variable_block_size == 2) {
#line 332
    goto case_2;
  }
#line 329
  goto switch_break;
  case_0: /* CIL Label */ 
#line 330
  vbs_s = (char *)"none";
#line 330
  goto switch_break;
  case_1: /* CIL Label */ 
#line 331
  vbs_s = (char *)"method 1";
#line 331
  goto switch_break;
  case_2: /* CIL Label */ 
#line 332
  vbs_s = (char *)"method 2";
#line 332
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 334
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"variable block size: %s\n",
          vbs_s);
  }
#line 335
  ptype_s = (char *)"ERROR";
  }
  {
#line 337
  if (s->params.prediction_type == 0) {
#line 337
    goto case_0___0;
  }
#line 338
  if (s->params.prediction_type == 1) {
#line 338
    goto case_1___0;
  }
#line 339
  if (s->params.prediction_type == 2) {
#line 339
    goto case_2___0;
  }
#line 336
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 337
  ptype_s = (char *)"none (verbatim mode)";
#line 337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 338
  ptype_s = (char *)"fixed";
#line 338
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 339
  ptype_s = (char *)"levinson-durbin";
#line 339
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
  {
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prediction type: %s\n",
          ptype_s);
  }
  }
#line 342
  if (s->params.prediction_type != 0) {
    {
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prediction order: %d,%d\n",
            s->params.min_prediction_order, s->params.max_prediction_order);
    }
    {
#line 345
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"partition order: %d,%d\n",
            s->params.min_partition_order, s->params.max_partition_order);
    }
#line 347
    omethod_s = (char *)"ERROR";
    }
    {
#line 349
    if (s->params.order_method == 0) {
#line 349
      goto case_0___1;
    }
#line 350
    if (s->params.order_method == 1) {
#line 350
      goto case_1___1;
    }
#line 351
    if (s->params.order_method == 2) {
#line 351
      goto case_2___1;
    }
#line 352
    if (s->params.order_method == 3) {
#line 352
      goto case_3;
    }
#line 353
    if (s->params.order_method == 4) {
#line 353
      goto case_4;
    }
#line 354
    if (s->params.order_method == 5) {
#line 354
      goto case_5;
    }
#line 355
    if (s->params.order_method == 6) {
#line 355
      goto case_6;
    }
#line 348
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 349
    omethod_s = (char *)"maximum";
#line 349
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 350
    omethod_s = (char *)"estimate";
#line 350
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 351
    omethod_s = (char *)"2-level";
#line 351
    goto switch_break___1;
    case_3: /* CIL Label */ 
#line 352
    omethod_s = (char *)"4-level";
#line 352
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 353
    omethod_s = (char *)"8-level";
#line 353
    goto switch_break___1;
    case_5: /* CIL Label */ 
#line 354
    omethod_s = (char *)"full search";
#line 354
    goto switch_break___1;
    case_6: /* CIL Label */ 
#line 355
    omethod_s = (char *)"log search";
#line 355
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
    {
#line 357
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"order method: %s\n",
            omethod_s);
    }
    }
  }
#line 359
  if (s->channels == 2) {
#line 360
    stmethod_s = (char *)"ERROR";
    {
#line 362
    if (s->params.stereo_method == 0) {
#line 362
      goto case_0___2;
    }
#line 363
    if (s->params.stereo_method == 1) {
#line 363
      goto case_1___2;
    }
#line 361
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
#line 362
    stmethod_s = (char *)"independent";
#line 362
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
#line 363
    stmethod_s = (char *)"mid-side";
#line 363
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stereo method: %s\n",
            stmethod_s);
    }
    }
  }
  {
  {
#line 367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"header padding: %d\n",
          s->params.padding_size);
  }
  }
#line 368
  return;
}
}
#line 370 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int encode_file___0(CommandOptions *opts , FilePair *files , int first_file ) 
{ 
  FlakeContext s ;
  WavFile wf ;
  int header_size ;
  int subset ;
  int bs_zero ;
  uint8_t *frame ;
  int16_t *wav ;
  int percent ;
  uint32_t nr ;
  uint32_t fs ;
  uint32_t samplecount ;
  uint32_t bytecount ;
  int t0 ;
  int t1 ;
  float kb ;
  float sec ;
  float kbps ;
  float wav_bytes ;
  int tmp ;
  int tmp___0 ;
  int64_t tms ;
  int th ;
  int tm ;
  int ts ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t sc ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
  {
#line 383
  tmp = wavfile_init(& wf, files->ifp);
  }
  }
#line 383
  if (tmp) {
    {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid input file: %s\n",
            files->infile);
    }
    }
#line 385
    return (1);
  }
  {
#line 387
  wf.read_format = (enum WavSampleFormat )1;
#line 390
  s.channels = wf.channels;
#line 391
  s.sample_rate = wf.sample_rate;
#line 392
  s.bits_per_sample = 16;
#line 393
  s.samples = wf.samples;
#line 396
  s.params.compression = opts->compr;
  {
#line 397
  tmp___0 = flake_set_defaults(& s.params);
  }
  }
#line 397
  if (tmp___0) {
#line 398
    return (1);
  }
#line 400
  if (opts->bsize >= 0) {
#line 400
    s.params.block_size = opts->bsize;
  }
#line 401
  if (opts->omethod >= 0) {
#line 401
    s.params.order_method = opts->omethod;
  }
#line 402
  if (opts->stmethod >= 0) {
#line 402
    s.params.stereo_method = opts->stmethod;
  }
#line 403
  if (opts->ptype >= 0) {
#line 403
    s.params.prediction_type = opts->ptype;
  }
#line 404
  if (opts->omin >= 0) {
#line 404
    s.params.min_prediction_order = opts->omin;
  }
#line 405
  if (opts->omax >= 0) {
#line 405
    s.params.max_prediction_order = opts->omax;
  }
#line 406
  if (opts->pomin >= 0) {
#line 406
    s.params.min_partition_order = opts->pomin;
  }
#line 407
  if (opts->pomax >= 0) {
#line 407
    s.params.max_partition_order = opts->pomax;
  }
#line 408
  if (opts->padding >= 0) {
#line 408
    s.params.padding_size = opts->padding;
  }
#line 409
  if (opts->vbs >= 0) {
#line 409
    s.params.variable_block_size = opts->vbs;
  }
  {
  {
#line 411
  subset = flake_validate_params(& s);
  }
  }
#line 412
  if (subset < 0) {
    {
    {
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: invalid encoding parameters.\n");
    }
    }
#line 414
    return (1);
  }
  {
#line 416
  bs_zero = s.params.block_size == 0;
  {
#line 419
  header_size = flake_encode_init(& s);
  }
  }
#line 420
  if (header_size < 0) {
    {
    {
#line 421
    flake_encode_close(& s);
    }
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error initializing encoder.\n");
    }
    }
#line 423
    return (1);
  }
  {
  {
#line 425
  fwrite((void const   */* __restrict  */)s.header, (size_t )1, (size_t )header_size,
         (FILE */* __restrict  */)files->ofp);
  }
  }
#line 428
  if (first_file) {
#line 428
    if (! opts->quiet) {
#line 429
      if (subset == 1) {
        {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n WARNING! The chosen encoding options are\n not FLAC Subset compliant. Therefore, the\n encoded file(s) may not work properly with\n some FLAC players and decoders.\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n");
        }
        }
      }
#line 437
      if (bs_zero) {
        {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block time: %dms\n",
                s.params.block_time_ms);
        }
        }
      } else {
        {
        {
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block size: %d\n",
                s.params.block_size);
        }
        }
      }
      {
      {
#line 442
      print_params___0(& s);
      }
      }
    }
  }
#line 445
  if (! opts->quiet) {
    {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file:  \"%s\"\n",
            files->infile);
    }
    {
#line 448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output file: \"%s\"\n",
            files->outfile);
    }
    {
#line 449
    wavfile_print(stderr, & wf);
    }
    }
#line 450
    if (wf.bit_width != 16) {
      {
      {
#line 451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING! converting to 16-bit (not lossless)\n");
      }
      }
    }
#line 453
    if (wf.samples > 0U) {
      {
#line 456
      tms = (int64_t )(((double )wf.samples * 1000.0) / (double )wf.sample_rate);
#line 457
      ts = (int )(tms / 1000L);
#line 458
      tms %= 1000L;
#line 459
      tm = ts / 60;
#line 460
      ts %= 60;
#line 461
      th = tm / 60;
#line 462
      tm %= 60;
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"samples: %u (",
              wf.samples);
      }
      }
#line 464
      if (th) {
        {
        {
#line 464
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dh",
                th);
        }
        }
      }
      {
      {
#line 465
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dm",
              tm);
      }
      {
#line 466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d.%03ds)\n",
              ts, (int )tms);
      }
      }
    } else {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"samples: unknown\n");
      }
      }
    }
#line 470
    if (bs_zero) {
      {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block size: %d\n",
              s.params.block_size);
      }
      }
    }
  }
  {
  {
#line 475
  tmp___1 = malloc((size_t )s.max_frame_size);
  }
#line 475
  frame = (uint8_t *)tmp___1;
  {
#line 476
  tmp___2 = malloc((size_t )((unsigned long )(s.params.block_size * wf.channels) * sizeof(int16_t )));
  }
#line 476
  wav = (int16_t *)tmp___2;
#line 478
  percent = 0;
#line 478
  t0 = percent;
#line 478
  samplecount = (uint32_t )t0;
#line 479
  wav_bytes = (float )0;
#line 480
  bytecount = (uint32_t )header_size;
  {
#line 481
  tmp___3 = wavfile_read_samples(& wf, (void *)wav, s.params.block_size);
  }
#line 481
  nr = (uint32_t )tmp___3;
  }
  {
  {
#line 482
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 482
    if (! (nr > 0U)) {
#line 482
      goto while_break;
    }
    {
#line 483
    s.params.block_size = (int )nr;
    {
#line 484
    tmp___4 = flake_encode_frame(& s, frame, wav);
    }
#line 484
    fs = (uint32_t )tmp___4;
    }
#line 485
    if (fs < 0U) {
      {
      {
#line 486
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error encoding frame\n");
      }
      }
    } else
#line 487
    if (fs > 0U) {
      {
      {
#line 488
      fwrite((void const   */* __restrict  */)frame, (size_t )1, fs, (FILE */* __restrict  */)files->ofp);
      }
#line 489
      samplecount += (uint32_t )s.params.block_size;
#line 490
      bytecount += fs;
#line 491
      t1 = (int )(samplecount / (uint32_t )s.sample_rate);
      }
#line 492
      if (t1 > t0) {
#line 493
        kb = (float )(((double )bytecount * 8.0) / 1000.0);
#line 494
        sec = (float )samplecount / (float )s.sample_rate;
#line 495
        if (samplecount > 0U) {
#line 495
          kbps = kb / sec;
        } else {
#line 496
          kbps = kb;
        }
#line 497
        if (s.samples > 0U) {
#line 498
          percent = (int )(((double )samplecount * 100.5) / (double )s.samples);
        }
#line 500
        wav_bytes = (float )(samplecount * (uint32_t )wf.block_align);
#line 501
        if (! opts->quiet) {
          {
          {
#line 502
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rprogress: %3d%% | ratio: %1.3f | bitrate: %4.1f kbps ",
                  percent, (double )((float )bytecount / wav_bytes), (double )kbps);
          }
          }
        }
      }
#line 507
      t0 = t1;
    }
    {
    {
#line 509
    tmp___5 = wavfile_read_samples(& wf, (void *)wav, s.params.block_size);
    }
#line 509
    nr = (uint32_t )tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if (! opts->quiet) {
    {
    {
#line 512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| bytes: %d \n\n",
            bytecount);
    }
    }
  }
  {
  {
#line 515
  flake_encode_close(& s);
  }
  {
#line 518
  tmp___7 = fseek(files->ofp, 22L, 0);
  }
  }
#line 518
  if (! tmp___7) {
    {
    {
#line 519
    tmp___6 = bswap_32(samplecount);
    }
#line 519
    sc = tmp___6;
    {
#line 520
    fwrite((void const   */* __restrict  */)(& sc), (size_t )4, (size_t )1, (FILE */* __restrict  */)files->ofp);
    }
    {
#line 521
    fwrite((void const   */* __restrict  */)(s.md5digest), (size_t )1, (size_t )16,
           (FILE */* __restrict  */)files->ofp);
    }
    }
  }
  {
  {
#line 524
  free((void *)wav);
  }
  {
#line 525
  free((void *)frame);
  }
  }
#line 527
  return (0);
}
}
#line 530 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int open_files___0(FilePair *files ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 533
  tmp = strncmp((char const   *)files->infile, "-", (size_t )2);
  }
  }
#line 533
  if (tmp) {
    {
    {
#line 539
    files->ifp = fopen((char const   */* __restrict  */)files->infile, (char const   */* __restrict  */)"rb");
    }
    }
#line 540
    if (! files->ifp) {
      {
      {
#line 541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening input file: %s\n",
              files->infile);
      }
      }
#line 542
      return (1);
    }
  } else {
#line 537
    files->ifp = stdin;
  }
  {
  {
#line 545
  tmp___0 = strncmp((char const   *)files->outfile, "-", (size_t )2);
  }
  }
#line 545
  if (tmp___0) {
    {
    {
#line 551
    files->ofp = fopen((char const   */* __restrict  */)files->outfile, (char const   */* __restrict  */)"wb");
    }
    }
#line 552
    if (! files->ofp) {
      {
      {
#line 553
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening output file: %s\n",
              files->outfile);
      }
      }
#line 554
      return (1);
    }
  } else {
#line 549
    files->ofp = stdout;
  }
#line 557
  return (0);
}
}
#line 560 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void filelist_cleanup___0(CommandOptions *opts ) 
{ 
  int i ;

  {
#line 565
  if (opts->filelist) {
#line 566
    i = 0;
    {
    {
#line 566
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 566
      if (! (i < opts->input_count)) {
#line 566
        goto while_break;
      }
#line 567
      if ((opts->filelist + i)->outfile) {
        {
        {
#line 567
        free((void *)(opts->filelist + i)->outfile);
        }
        }
      }
#line 566
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 569
    free((void *)opts->filelist);
    }
    }
  }
#line 571
  return;
}
}
#line 38 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_usage___1(FILE *out ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 41
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"usage: flake [options] <input.wav> [-o output.flac]\ntype \'flake -h\' for more details.\n\n");
  }
  }
#line 43
  return;
}
}
#line 45 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_help___1(FILE *out ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 48
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"usage: flake [options] <input.wav> [-o output.flac]\noptions:\n       [-h]         Print out list of commandline options\n       [-q]         Quiet mode\n       [-p #]       Padding bytes to put in header (default: 4096)\n       [-0 ... -12] Compression level (default: 5)\n                        0 = -b 1152 -t 1 -l 2,2 -m 0 -r 4,4 -s 0\n                        1 = -b 1152 -t 1 -l 3,4 -m 1 -r 2,2 -s 1\n                        2 = -b 1152 -t 1 -l 2,4 -m 1 -r 3   -s 1\n                        3 = -b 4608 -t 2 -l 6   -m 1 -r 3   -s 1\n                        4 = -b 4608 -t 2 -l 8   -m 1 -r 3   -s 1\n                        5 = -b 4608 -t 2 -l 8   -m 1 -r 6   -s 1\n                        6 = -b 4608 -t 2 -l 8   -m 2 -r 8   -s 1\n                        7 = -b 4608 -t 2 -l 8   -m 3 -r 8   -s 1\n                        8 = -b 4608 -t 2 -l 12  -m 3 -r 8   -s 1\n                        9 = -b 4608 -t 2 -l 12  -m 6 -r 8   -s 1\n                       10 = -b 4608 -t 2 -l 12  -m 5 -r 8   -s 1\n                       11 = -b 4608 -t 2 -l 32  -m 6 -r 8   -s 1\n                       12 = -b 4608 -t 2 -l 32  -m 5 -r 8   -s 1\n       [-b #]       Block size [16 - 65535] (default: 4608)\n       [-t #]       Prediction type\n                        0 = no prediction / verbatim\n                        1 = fixed prediction\n                        2 = Levinson-Durbin recursion (default)\n       [-l #[,#]]   Prediction order {max} or {min},{max} (default: 1,8)\n       [-m #]       Prediction order selection method\n                        0 = maximum\n                        1 = estimate (default)\n                        2 = 2-level\n                        3 = 4-level\n                        4 = 8-level\n                        5 = full search\n                        6 = log search\n       [-r #[,#]]   Rice partition order {max} or {min},{max} (default: 0,6)\n       [-s #]       Stereo decorrelation method\n                        0 = independent L+R channels\n                        1 = mid-side (default)\n       [-v #]       Variable block size\n                        0 = fixed (default)\n                        1 = variable, method 1\n                        2 = variable, method 2\n\n");
  }
  }
#line 90
  return;
}
}
#line 117 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int parse_number___1(char *arg , int max ) 
{ 
  int i ;
  int m ;
  int n ;
  int digits ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 120
  m = 0;
#line 121
  n = 0;
#line 123
  i = 0;
  {
  {
#line 123
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < max)) {
#line 123
      goto while_break;
    }
#line 124
    if ((int )*(arg + i) == 0) {
#line 124
      goto while_break;
    }
#line 125
    if (m == 0) {
#line 125
      m = 1;
    } else {
#line 126
      m *= 10;
    }
#line 123
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  if ((int )*(arg + i) != 0) {
#line 128
    return (-1);
  }
#line 129
  digits = i;
#line 130
  i = 0;
  {
  {
#line 130
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (i < digits)) {
#line 130
      goto while_break___0;
    }
#line 131
    if ((int )*(arg + i) < 48) {
      {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid digit: %c (ASCII:0x%02X)\n",
              (int )*(arg + i), (int )*(arg + i));
      }
      }
#line 133
      return (-1);
    } else
#line 131
    if ((int )*(arg + i) > 57) {
      {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid digit: %c (ASCII:0x%02X)\n",
              (int )*(arg + i), (int )*(arg + i));
      }
      }
#line 133
      return (-1);
    }
#line 135
    n += ((int )*(arg + i) - 48) * m;
#line 136
    m /= 10;
#line 130
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  return (n);
}
}
#line 145
static int parse_commandline___1(int argc , char **argv , CommandOptions *opts ) ;
#line 145 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static char const   *param_str___1  =    "bhlmopqrstv";
#line 141 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int parse_commandline___1(int argc , char **argv , CommandOptions *opts ) 
{ 
  int i ;
  int max_digits ;
  int ifc ;
  void *tmp ;
  char *tmp___0 ;
  char *po ;
  char *tmp___1 ;
  char *tmp___2 ;
  int olen ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *po___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int ext ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 146
  max_digits = 8;
#line 147
  ifc = 0;
#line 149
  opts->filelist = (FilePair *)((void *)0);
#line 150
  if (argc < 2) {
#line 151
    return (1);
  }
  {
  {
#line 154
  tmp = calloc((size_t )((unsigned long )argc * sizeof(FilePair )), (size_t )1);
  }
#line 154
  opts->filelist = (FilePair *)tmp;
#line 155
  opts->input_count = 0;
#line 156
  opts->found_output = 0;
#line 157
  opts->compr = 5;
#line 158
  opts->omethod = -1;
#line 159
  opts->ptype = -1;
#line 160
  opts->omin = -1;
#line 161
  opts->omax = -1;
#line 162
  opts->pomin = -1;
#line 163
  opts->pomax = -1;
#line 164
  opts->bsize = -1;
#line 165
  opts->stmethod = -1;
#line 166
  opts->padding = -1;
#line 167
  opts->vbs = -1;
#line 168
  opts->quiet = 0;
#line 170
  i = 1;
  }
  {
  {
#line 170
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < argc)) {
#line 170
      goto while_break;
    }
#line 171
    if ((int )*(*(argv + i) + 0) == 45) {
#line 171
      if ((int )*(*(argv + i) + 1) != 0) {
#line 172
        if ((int )*(*(argv + i) + 1) >= 48) {
#line 172
          if ((int )*(*(argv + i) + 1) <= 57) {
#line 173
            if ((int )*(*(argv + i) + 2) != 0) {
#line 173
              if ((int )*(*(argv + i) + 3) != 0) {
#line 174
                (opts->filelist + ifc)->infile = *(argv + i);
#line 175
                ifc ++;
              } else {
#line 173
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
              {
#line 177
              opts->compr = parse_number___1(*(argv + i) + 1, max_digits);
              }
              }
#line 178
              if (opts->compr < 0) {
#line 178
                return (1);
              }
            }
          } else {
#line 172
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 183
          if ((int )*(*(argv + i) + 2) != 0) {
#line 184
            (opts->filelist + ifc)->infile = *(argv + i);
#line 185
            ifc ++;
#line 186
            goto __Cont;
          }
          {
          {
#line 189
          tmp___0 = strchr(param_str___1, (int )*(*(argv + i) + 1));
          }
          }
#line 189
          if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
            {
            {
#line 190
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid option: -%c\n",
                    (int )*(*(argv + i) + 1));
            }
            }
#line 191
            return (1);
          }
#line 194
          if ((int )*(*(argv + i) + 1) == 104) {
#line 195
            return (2);
          }
#line 197
          i ++;
#line 198
          if (i >= argc) {
            {
            {
#line 199
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"incomplete option: -%c\n",
                    (int )*(*(argv + (i - 1)) + 1));
            }
            }
#line 200
            return (1);
          }
          {
#line 204
          if ((int )*(*(argv + (i - 1)) + 1) == 98) {
#line 204
            goto case_98;
          }
#line 208
          if ((int )*(*(argv + (i - 1)) + 1) == 108) {
#line 208
            goto case_108;
          }
#line 228
          if ((int )*(*(argv + (i - 1)) + 1) == 109) {
#line 228
            goto case_109;
          }
#line 232
          if ((int )*(*(argv + (i - 1)) + 1) == 111) {
#line 232
            goto case_111;
          }
#line 242
          if ((int )*(*(argv + (i - 1)) + 1) == 112) {
#line 242
            goto case_112;
          }
#line 246
          if ((int )*(*(argv + (i - 1)) + 1) == 113) {
#line 246
            goto case_113;
          }
#line 250
          if ((int )*(*(argv + (i - 1)) + 1) == 114) {
#line 250
            goto case_114;
          }
#line 264
          if ((int )*(*(argv + (i - 1)) + 1) == 115) {
#line 264
            goto case_115;
          }
#line 268
          if ((int )*(*(argv + (i - 1)) + 1) == 116) {
#line 268
            goto case_116;
          }
#line 272
          if ((int )*(*(argv + (i - 1)) + 1) == 118) {
#line 272
            goto case_118;
          }
#line 203
          goto switch_break;
          case_98: /* CIL Label */ 
          {
          {
#line 205
          opts->bsize = parse_number___1(*(argv + i), max_digits);
          }
          }
#line 206
          if (opts->bsize < 0) {
#line 206
            return (1);
          }
#line 207
          goto switch_break;
          case_108: /* CIL Label */ 
          {
          {
#line 209
          tmp___2 = strchr((char const   *)*(argv + i), ',');
          }
          }
#line 209
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
#line 210
            opts->omin = 0;
            {
#line 211
            opts->omax = parse_number___1(*(argv + i), max_digits);
            }
            }
#line 212
            if (opts->omax < 0) {
#line 212
              return (1);
            }
          } else {
            {
            {
#line 214
            tmp___1 = strchr((char const   *)*(argv + i), ',');
            }
#line 214
            po = tmp___1;
#line 215
            *(po + 0) = (char )'\000';
            {
#line 216
            opts->omin = parse_number___1(*(argv + i), max_digits);
            }
            }
#line 217
            if (opts->omin < 0) {
#line 217
              return (1);
            }
            {
            {
#line 218
            opts->omax = parse_number___1(po + 1, max_digits);
            }
            }
#line 219
            if (opts->omax < 0) {
#line 219
              return (1);
            }
          }
#line 222
          if (opts->ptype == 1) {
#line 223
            if (opts->omax > 4) {
#line 223
              opts->omax = 4;
            }
          } else
#line 224
          if (opts->ptype == 2) {
#line 225
            if (opts->omin == 0) {
#line 225
              opts->omin = 1;
            }
          }
#line 227
          goto switch_break;
          case_109: /* CIL Label */ 
          {
          {
#line 229
          opts->omethod = parse_number___1(*(argv + i), max_digits);
          }
          }
#line 230
          if (opts->omethod < 0) {
#line 230
            return (1);
          }
#line 231
          goto switch_break;
          case_111: /* CIL Label */ 
#line 233
          if (opts->found_output) {
#line 234
            return (1);
          } else {
            {
            {
#line 236
            tmp___3 = strnlen((char const   *)*(argv + i), (size_t )4096);
            }
#line 236
            olen = (int )(tmp___3 + 1U);
            {
#line 237
            tmp___4 = calloc((size_t )1, (size_t )(olen + 5));
            }
#line 237
            (opts->filelist + 0)->outfile = (char *)tmp___4;
            {
#line 238
            strncpy((char */* __restrict  */)(opts->filelist + 0)->outfile, (char const   */* __restrict  */)*(argv + i),
                    (size_t )olen);
            }
#line 239
            opts->found_output = 1;
            }
          }
#line 241
          goto switch_break;
          case_112: /* CIL Label */ 
          {
          {
#line 243
          opts->padding = parse_number___1(*(argv + i), max_digits);
          }
          }
#line 244
          if (opts->padding < 0) {
#line 244
            return (1);
          }
#line 245
          goto switch_break;
          case_113: /* CIL Label */ 
#line 247
          i --;
#line 248
          opts->quiet = 1;
#line 249
          goto switch_break;
          case_114: /* CIL Label */ 
          {
          {
#line 251
          tmp___6 = strchr((char const   *)*(argv + i), ',');
          }
          }
#line 251
          if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
            {
#line 252
            opts->pomin = 0;
            {
#line 253
            opts->pomax = parse_number___1(*(argv + i), max_digits);
            }
            }
#line 254
            if (opts->pomax < 0) {
#line 254
              return (1);
            }
          } else {
            {
            {
#line 256
            tmp___5 = strchr((char const   *)*(argv + i), ',');
            }
#line 256
            po___0 = tmp___5;
#line 257
            *(po___0 + 0) = (char )'\000';
            {
#line 258
            opts->pomin = parse_number___1(*(argv + i), max_digits);
            }
            }
#line 259
            if (opts->pomin < 0) {
#line 259
              return (1);
            }
            {
            {
#line 260
            opts->pomax = parse_number___1(po___0 + 1, max_digits);
            }
            }
#line 261
            if (opts->pomax < 0) {
#line 261
              return (1);
            }
          }
#line 263
          goto switch_break;
          case_115: /* CIL Label */ 
          {
          {
#line 265
          opts->stmethod = parse_number___1(*(argv + i), max_digits);
          }
          }
#line 266
          if (opts->stmethod < 0) {
#line 266
            return (1);
          }
#line 267
          goto switch_break;
          case_116: /* CIL Label */ 
          {
          {
#line 269
          opts->ptype = parse_number___1(*(argv + i), max_digits);
          }
          }
#line 270
          if (opts->ptype < 0) {
#line 270
            return (1);
          }
#line 271
          goto switch_break;
          case_118: /* CIL Label */ 
          {
          {
#line 273
          opts->vbs = parse_number___1(*(argv + i), max_digits);
          }
          }
#line 274
          if (opts->vbs < 0) {
#line 274
            return (1);
          }
#line 275
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
#line 281
        (opts->filelist + ifc)->infile = *(argv + i);
#line 282
        ifc ++;
      }
    } else {
#line 281
      (opts->filelist + ifc)->infile = *(argv + i);
#line 282
      ifc ++;
    }
    __Cont: /* CIL Label */ 
#line 170
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (! ifc) {
    {
    {
#line 286
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error parsing filenames.\n");
    }
    }
#line 287
    return (1);
  }
#line 289
  if (opts->found_output) {
#line 289
    if (ifc > 1) {
      {
      {
#line 290
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot specify output file when using multiple input files\n");
      }
      }
#line 291
      return (1);
    }
  }
#line 293
  if (! opts->found_output) {
#line 295
    i = 0;
    {
    {
#line 295
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (i < ifc)) {
#line 295
        goto while_break___0;
      }
      {
      {
#line 296
      tmp___7 = strnlen((char const   *)(opts->filelist + i)->infile, (size_t )4096);
      }
#line 296
      ext = (int )tmp___7;
      {
#line 297
      tmp___8 = calloc((size_t )1, (size_t )(ext + 6));
      }
#line 297
      (opts->filelist + i)->outfile = (char *)tmp___8;
      {
#line 298
      strncpy((char */* __restrict  */)(opts->filelist + i)->outfile, (char const   */* __restrict  */)(opts->filelist + i)->infile,
              (size_t )(ext + 1));
      }
#line 299
      *((opts->filelist + i)->outfile + ext) = (char )'\000';
      }
      {
      {
#line 300
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 300
        if (ext > 0) {
#line 300
          if (! ((int )*((opts->filelist + i)->outfile + ext) != 46)) {
#line 300
            goto while_break___1;
          }
        } else {
#line 300
          goto while_break___1;
        }
#line 300
        ext --;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 301
      if (ext >= 4091) {
        {
        {
#line 302
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input filename too long\n");
        }
        }
#line 303
        return (1);
      }
      {
      {
#line 305
      strncpy((char */* __restrict  */)((opts->filelist + i)->outfile + ext), (char const   */* __restrict  */)".flac",
              (size_t )6);
      }
#line 295
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 310
  i = 0;
  {
  {
#line 310
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 310
    if (! (i < ifc)) {
#line 310
      goto while_break___2;
    }
    {
    {
#line 311
    tmp___10 = strncmp((char const   *)(opts->filelist + i)->infile, "-", (size_t )2);
    }
    }
#line 311
    if (tmp___10) {
      {
      {
#line 311
      tmp___11 = strncmp((char const   *)(opts->filelist + i)->outfile, "-", (size_t )2);
      }
      }
#line 311
      if (tmp___11) {
        {
        {
#line 312
        tmp___9 = strcmp((char const   *)(opts->filelist + i)->infile, (char const   *)(opts->filelist + i)->outfile);
        }
        }
#line 312
        if (! tmp___9) {
          {
          {
#line 313
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output filename cannot match input filename\n");
          }
          }
#line 314
          return (1);
        }
      }
    }
#line 310
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 319
  opts->input_count = ifc;
#line 320
  return (0);
}
}
#line 323 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void print_params___1(FlakeContext *s ) 
{ 
  char *omethod_s ;
  char *stmethod_s ;
  char *ptype_s ;
  char *vbs_s ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 328
  vbs_s = (char *)"ERROR";
  {
#line 330
  if (s->params.variable_block_size == 0) {
#line 330
    goto case_0;
  }
#line 331
  if (s->params.variable_block_size == 1) {
#line 331
    goto case_1;
  }
#line 332
  if (s->params.variable_block_size == 2) {
#line 332
    goto case_2;
  }
#line 329
  goto switch_break;
  case_0: /* CIL Label */ 
#line 330
  vbs_s = (char *)"none";
#line 330
  goto switch_break;
  case_1: /* CIL Label */ 
#line 331
  vbs_s = (char *)"method 1";
#line 331
  goto switch_break;
  case_2: /* CIL Label */ 
#line 332
  vbs_s = (char *)"method 2";
#line 332
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 334
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"variable block size: %s\n",
          vbs_s);
  }
#line 335
  ptype_s = (char *)"ERROR";
  }
  {
#line 337
  if (s->params.prediction_type == 0) {
#line 337
    goto case_0___0;
  }
#line 338
  if (s->params.prediction_type == 1) {
#line 338
    goto case_1___0;
  }
#line 339
  if (s->params.prediction_type == 2) {
#line 339
    goto case_2___0;
  }
#line 336
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 337
  ptype_s = (char *)"none (verbatim mode)";
#line 337
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 338
  ptype_s = (char *)"fixed";
#line 338
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 339
  ptype_s = (char *)"levinson-durbin";
#line 339
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
  {
#line 341
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prediction type: %s\n",
          ptype_s);
  }
  }
#line 342
  if (s->params.prediction_type != 0) {
    {
    {
#line 343
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prediction order: %d,%d\n",
            s->params.min_prediction_order, s->params.max_prediction_order);
    }
    {
#line 345
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"partition order: %d,%d\n",
            s->params.min_partition_order, s->params.max_partition_order);
    }
#line 347
    omethod_s = (char *)"ERROR";
    }
    {
#line 349
    if (s->params.order_method == 0) {
#line 349
      goto case_0___1;
    }
#line 350
    if (s->params.order_method == 1) {
#line 350
      goto case_1___1;
    }
#line 351
    if (s->params.order_method == 2) {
#line 351
      goto case_2___1;
    }
#line 352
    if (s->params.order_method == 3) {
#line 352
      goto case_3;
    }
#line 353
    if (s->params.order_method == 4) {
#line 353
      goto case_4;
    }
#line 354
    if (s->params.order_method == 5) {
#line 354
      goto case_5;
    }
#line 355
    if (s->params.order_method == 6) {
#line 355
      goto case_6;
    }
#line 348
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 349
    omethod_s = (char *)"maximum";
#line 349
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 350
    omethod_s = (char *)"estimate";
#line 350
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 351
    omethod_s = (char *)"2-level";
#line 351
    goto switch_break___1;
    case_3: /* CIL Label */ 
#line 352
    omethod_s = (char *)"4-level";
#line 352
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 353
    omethod_s = (char *)"8-level";
#line 353
    goto switch_break___1;
    case_5: /* CIL Label */ 
#line 354
    omethod_s = (char *)"full search";
#line 354
    goto switch_break___1;
    case_6: /* CIL Label */ 
#line 355
    omethod_s = (char *)"log search";
#line 355
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
    {
#line 357
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"order method: %s\n",
            omethod_s);
    }
    }
  }
#line 359
  if (s->channels == 2) {
#line 360
    stmethod_s = (char *)"ERROR";
    {
#line 362
    if (s->params.stereo_method == 0) {
#line 362
      goto case_0___2;
    }
#line 363
    if (s->params.stereo_method == 1) {
#line 363
      goto case_1___2;
    }
#line 361
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
#line 362
    stmethod_s = (char *)"independent";
#line 362
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
#line 363
    stmethod_s = (char *)"mid-side";
#line 363
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
    {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stereo method: %s\n",
            stmethod_s);
    }
    }
  }
  {
  {
#line 367
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"header padding: %d\n",
          s->params.padding_size);
  }
  }
#line 368
  return;
}
}
#line 370 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int encode_file___1(CommandOptions *opts , FilePair *files , int first_file ) 
{ 
  FlakeContext s ;
  WavFile wf ;
  int header_size ;
  int subset ;
  int bs_zero ;
  uint8_t *frame ;
  int16_t *wav ;
  int percent ;
  uint32_t nr ;
  uint32_t fs ;
  uint32_t samplecount ;
  uint32_t bytecount ;
  int t0 ;
  int t1 ;
  float kb ;
  float sec ;
  float kbps ;
  float wav_bytes ;
  int tmp ;
  int tmp___0 ;
  int64_t tms ;
  int th ;
  int tm ;
  int ts ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t sc ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
  {
#line 383
  tmp = wavfile_init(& wf, files->ifp);
  }
  }
#line 383
  if (tmp) {
    {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid input file: %s\n",
            files->infile);
    }
    }
#line 385
    return (1);
  }
  {
#line 387
  wf.read_format = (enum WavSampleFormat )1;
#line 390
  s.channels = wf.channels;
#line 391
  s.sample_rate = wf.sample_rate;
#line 392
  s.bits_per_sample = 16;
#line 393
  s.samples = wf.samples;
#line 396
  s.params.compression = opts->compr;
  {
#line 397
  tmp___0 = flake_set_defaults(& s.params);
  }
  }
#line 397
  if (tmp___0) {
#line 398
    return (1);
  }
#line 400
  if (opts->bsize >= 0) {
#line 400
    s.params.block_size = opts->bsize;
  }
#line 401
  if (opts->omethod >= 0) {
#line 401
    s.params.order_method = opts->omethod;
  }
#line 402
  if (opts->stmethod >= 0) {
#line 402
    s.params.stereo_method = opts->stmethod;
  }
#line 403
  if (opts->ptype >= 0) {
#line 403
    s.params.prediction_type = opts->ptype;
  }
#line 404
  if (opts->omin >= 0) {
#line 404
    s.params.min_prediction_order = opts->omin;
  }
#line 405
  if (opts->omax >= 0) {
#line 405
    s.params.max_prediction_order = opts->omax;
  }
#line 406
  if (opts->pomin >= 0) {
#line 406
    s.params.min_partition_order = opts->pomin;
  }
#line 407
  if (opts->pomax >= 0) {
#line 407
    s.params.max_partition_order = opts->pomax;
  }
#line 408
  if (opts->padding >= 0) {
#line 408
    s.params.padding_size = opts->padding;
  }
#line 409
  if (opts->vbs >= 0) {
#line 409
    s.params.variable_block_size = opts->vbs;
  }
  {
  {
#line 411
  subset = flake_validate_params(& s);
  }
  }
#line 412
  if (subset < 0) {
    {
    {
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: invalid encoding parameters.\n");
    }
    }
#line 414
    return (1);
  }
  {
#line 416
  bs_zero = s.params.block_size == 0;
  {
#line 419
  header_size = flake_encode_init(& s);
  }
  }
#line 420
  if (header_size < 0) {
    {
    {
#line 421
    flake_encode_close(& s);
    }
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error initializing encoder.\n");
    }
    }
#line 423
    return (1);
  }
  {
  {
#line 425
  fwrite((void const   */* __restrict  */)s.header, (size_t )1, (size_t )header_size,
         (FILE */* __restrict  */)files->ofp);
  }
  }
#line 428
  if (first_file) {
#line 428
    if (! opts->quiet) {
#line 429
      if (subset == 1) {
        {
        {
#line 430
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n WARNING! The chosen encoding options are\n not FLAC Subset compliant. Therefore, the\n encoded file(s) may not work properly with\n some FLAC players and decoders.\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n");
        }
        }
      }
#line 437
      if (bs_zero) {
        {
        {
#line 438
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block time: %dms\n",
                s.params.block_time_ms);
        }
        }
      } else {
        {
        {
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block size: %d\n",
                s.params.block_size);
        }
        }
      }
      {
      {
#line 442
      print_params___1(& s);
      }
      }
    }
  }
#line 445
  if (! opts->quiet) {
    {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"input file:  \"%s\"\n",
            files->infile);
    }
    {
#line 448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output file: \"%s\"\n",
            files->outfile);
    }
    {
#line 449
    wavfile_print(stderr, & wf);
    }
    }
#line 450
    if (wf.bit_width != 16) {
      {
      {
#line 451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING! converting to 16-bit (not lossless)\n");
      }
      }
    }
#line 453
    if (wf.samples > 0U) {
      {
#line 456
      tms = (int64_t )(((double )wf.samples * 1000.0) / (double )wf.sample_rate);
#line 457
      ts = (int )(tms / 1000L);
#line 458
      tms %= 1000L;
#line 459
      tm = ts / 60;
#line 460
      ts %= 60;
#line 461
      th = tm / 60;
#line 462
      tm %= 60;
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"samples: %u (",
              wf.samples);
      }
      }
#line 464
      if (th) {
        {
        {
#line 464
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dh",
                th);
        }
        }
      }
      {
      {
#line 465
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%dm",
              tm);
      }
      {
#line 466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d.%03ds)\n",
              ts, (int )tms);
      }
      }
    } else {
      {
      {
#line 468
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"samples: unknown\n");
      }
      }
    }
#line 470
    if (bs_zero) {
      {
      {
#line 471
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"block size: %d\n",
              s.params.block_size);
      }
      }
    }
  }
  {
  {
#line 475
  tmp___1 = malloc((size_t )s.max_frame_size);
  }
#line 475
  frame = (uint8_t *)tmp___1;
  {
#line 476
  tmp___2 = malloc((size_t )((unsigned long )(s.params.block_size * wf.channels) * sizeof(int16_t )));
  }
#line 476
  wav = (int16_t *)tmp___2;
#line 478
  percent = 0;
#line 478
  t0 = percent;
#line 478
  samplecount = (uint32_t )t0;
#line 479
  wav_bytes = (float )0;
#line 480
  bytecount = (uint32_t )header_size;
  {
#line 481
  tmp___3 = wavfile_read_samples(& wf, (void *)wav, s.params.block_size);
  }
#line 481
  nr = (uint32_t )tmp___3;
  }
  {
  {
#line 482
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 482
    if (! (nr > 0U)) {
#line 482
      goto while_break;
    }
    {
#line 483
    s.params.block_size = (int )nr;
    {
#line 484
    tmp___4 = flake_encode_frame(& s, frame, wav);
    }
#line 484
    fs = (uint32_t )tmp___4;
    }
#line 485
    if (fs < 0U) {
      {
      {
#line 486
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error encoding frame\n");
      }
      }
    } else
#line 487
    if (fs > 0U) {
      {
      {
#line 488
      fwrite((void const   */* __restrict  */)frame, (size_t )1, fs, (FILE */* __restrict  */)files->ofp);
      }
#line 489
      samplecount += (uint32_t )s.params.block_size;
#line 490
      bytecount += fs;
#line 491
      t1 = (int )(samplecount / (uint32_t )s.sample_rate);
      }
#line 492
      if (t1 > t0) {
#line 493
        kb = (float )(((double )bytecount * 8.0) / 1000.0);
#line 494
        sec = (float )samplecount / (float )s.sample_rate;
#line 495
        if (samplecount > 0U) {
#line 495
          kbps = kb / sec;
        } else {
#line 496
          kbps = kb;
        }
#line 497
        if (s.samples > 0U) {
#line 498
          percent = (int )(((double )samplecount * 100.5) / (double )s.samples);
        }
#line 500
        wav_bytes = (float )(samplecount * (uint32_t )wf.block_align);
#line 501
        if (! opts->quiet) {
          {
          {
#line 502
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rprogress: %3d%% | ratio: %1.3f | bitrate: %4.1f kbps ",
                  percent, (double )((float )bytecount / wav_bytes), (double )kbps);
          }
          }
        }
      }
#line 507
      t0 = t1;
    }
    {
    {
#line 509
    tmp___5 = wavfile_read_samples(& wf, (void *)wav, s.params.block_size);
    }
#line 509
    nr = (uint32_t )tmp___5;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if (! opts->quiet) {
    {
    {
#line 512
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"| bytes: %d \n\n",
            bytecount);
    }
    }
  }
  {
  {
#line 515
  flake_encode_close(& s);
  }
  {
#line 518
  tmp___7 = fseek(files->ofp, 22L, 0);
  }
  }
#line 518
  if (! tmp___7) {
    {
    {
#line 519
    tmp___6 = bswap_32(samplecount);
    }
#line 519
    sc = tmp___6;
    {
#line 520
    fwrite((void const   */* __restrict  */)(& sc), (size_t )4, (size_t )1, (FILE */* __restrict  */)files->ofp);
    }
    {
#line 521
    fwrite((void const   */* __restrict  */)(s.md5digest), (size_t )1, (size_t )16,
           (FILE */* __restrict  */)files->ofp);
    }
    }
  }
  {
  {
#line 524
  free((void *)wav);
  }
  {
#line 525
  free((void *)frame);
  }
  }
#line 527
  return (0);
}
}
#line 530 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static int open_files___1(FilePair *files ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 533
  tmp = strncmp((char const   *)files->infile, "-", (size_t )2);
  }
  }
#line 533
  if (tmp) {
    {
    {
#line 539
    files->ifp = fopen((char const   */* __restrict  */)files->infile, (char const   */* __restrict  */)"rb");
    }
    }
#line 540
    if (! files->ifp) {
      {
      {
#line 541
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening input file: %s\n",
              files->infile);
      }
      }
#line 542
      return (1);
    }
  } else {
#line 537
    files->ifp = stdin;
  }
  {
  {
#line 545
  tmp___0 = strncmp((char const   *)files->outfile, "-", (size_t )2);
  }
  }
#line 545
  if (tmp___0) {
    {
    {
#line 551
    files->ofp = fopen((char const   */* __restrict  */)files->outfile, (char const   */* __restrict  */)"wb");
    }
    }
#line 552
    if (! files->ofp) {
      {
      {
#line 553
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error opening output file: %s\n",
              files->outfile);
      }
      }
#line 554
      return (1);
    }
  } else {
#line 549
    files->ofp = stdout;
  }
#line 557
  return (0);
}
}
#line 560 "/home/wslee/benchmarks/sound/flake-0.11/flake/flake.c"
static void filelist_cleanup___1(CommandOptions *opts ) 
{ 
  int i ;

  {
#line 565
  if (opts->filelist) {
#line 566
    i = 0;
    {
    {
#line 566
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 566
      if (! (i < opts->input_count)) {
#line 566
        goto while_break;
      }
#line 567
      if ((opts->filelist + i)->outfile) {
        {
        {
#line 567
        free((void *)(opts->filelist + i)->outfile);
        }
        }
      }
#line 566
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 569
    free((void *)opts->filelist);
    }
    }
  }
#line 571
  return;
}
}
#line 28 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_verbatim___1(int32_t *res , int32_t *smp , int n ) 
{ 


  {
  {
  {
#line 31
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 32
  return;
}
}
#line 34 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_fixed___1(int32_t *res , int32_t *smp , int n , int order ) 
{ 
  int i ;

  {
  {
#line 40
  if (order == 0) {
#line 40
    goto case_0;
  }
#line 43
  if (order == 1) {
#line 43
    goto case_1;
  }
#line 49
  if (order == 2) {
#line 49
    goto case_2;
  }
#line 56
  if (order == 3) {
#line 56
    goto case_3;
  }
#line 64
  if (order == 4) {
#line 64
    goto case_4;
  }
#line 73
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 41
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 42
  return;
  case_1: /* CIL Label */ 
#line 44
  *(res + 0) = *(smp + 0);
#line 45
  i = 1;
  {
  {
#line 45
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < n)) {
#line 45
      goto while_break;
    }
#line 46
    *(res + i) = *(smp + i) - *(smp + (i - 1));
#line 45
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
  case_2: /* CIL Label */ 
#line 50
  *(res + 0) = *(smp + 0);
#line 51
  *(res + 1) = *(smp + 1);
#line 52
  i = 2;
  {
  {
#line 52
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 52
    if (! (i < n)) {
#line 52
      goto while_break___0;
    }
#line 53
    *(res + i) = (*(smp + i) - 2 * *(smp + (i - 1))) + *(smp + (i - 2));
#line 52
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  return;
  case_3: /* CIL Label */ 
#line 57
  *(res + 0) = *(smp + 0);
#line 58
  *(res + 1) = *(smp + 1);
#line 59
  *(res + 2) = *(smp + 2);
#line 60
  i = 3;
  {
  {
#line 60
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! (i < n)) {
#line 60
      goto while_break___1;
    }
#line 61
    *(res + i) = ((*(smp + i) - 3 * *(smp + (i - 1))) + 3 * *(smp + (i - 2))) - *(smp + (i - 3));
#line 60
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  return;
  case_4: /* CIL Label */ 
#line 65
  *(res + 0) = *(smp + 0);
#line 66
  *(res + 1) = *(smp + 1);
#line 67
  *(res + 2) = *(smp + 2);
#line 68
  *(res + 3) = *(smp + 3);
#line 69
  i = 4;
  {
  {
#line 69
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (i < n)) {
#line 69
      goto while_break___2;
    }
#line 70
    *(res + i) = (((*(smp + i) - 4 * *(smp + (i - 1))) + 6 * *(smp + (i - 2))) - 4 * *(smp + (i - 3))) + *(smp + (i - 4));
#line 69
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 72
  return;
  switch_default: /* CIL Label */ 
#line 73
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_lpc___1(int32_t *res , int32_t *smp , int n , int order ,
                                    int32_t *coefs , int shift ) 
{ 
  int i ;
  int32_t pred ;

  {
#line 84
  i = 0;
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < order)) {
#line 84
      goto while_break;
    }
#line 85
    *(res + i) = *(smp + i);
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  i = order;
  {
  {
#line 87
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < n)) {
#line 87
      goto while_break___0;
    }
#line 88
    pred = 0;
    {
#line 92
    if (order == 32) {
#line 92
      goto case_32;
    }
#line 93
    if (order == 31) {
#line 93
      goto case_31;
    }
#line 94
    if (order == 30) {
#line 94
      goto case_30;
    }
#line 95
    if (order == 29) {
#line 95
      goto case_29;
    }
#line 96
    if (order == 28) {
#line 96
      goto case_28;
    }
#line 97
    if (order == 27) {
#line 97
      goto case_27;
    }
#line 98
    if (order == 26) {
#line 98
      goto case_26;
    }
#line 99
    if (order == 25) {
#line 99
      goto case_25;
    }
#line 100
    if (order == 24) {
#line 100
      goto case_24;
    }
#line 101
    if (order == 23) {
#line 101
      goto case_23;
    }
#line 102
    if (order == 22) {
#line 102
      goto case_22;
    }
#line 103
    if (order == 21) {
#line 103
      goto case_21;
    }
#line 104
    if (order == 20) {
#line 104
      goto case_20;
    }
#line 105
    if (order == 19) {
#line 105
      goto case_19;
    }
#line 106
    if (order == 18) {
#line 106
      goto case_18;
    }
#line 107
    if (order == 17) {
#line 107
      goto case_17;
    }
#line 108
    if (order == 16) {
#line 108
      goto case_16;
    }
#line 109
    if (order == 15) {
#line 109
      goto case_15;
    }
#line 110
    if (order == 14) {
#line 110
      goto case_14;
    }
#line 111
    if (order == 13) {
#line 111
      goto case_13;
    }
#line 112
    if (order == 12) {
#line 112
      goto case_12;
    }
#line 113
    if (order == 11) {
#line 113
      goto case_11;
    }
#line 114
    if (order == 10) {
#line 114
      goto case_10;
    }
#line 115
    if (order == 9) {
#line 115
      goto case_9;
    }
#line 116
    if (order == 8) {
#line 116
      goto case_8;
    }
#line 117
    if (order == 7) {
#line 117
      goto case_7;
    }
#line 118
    if (order == 6) {
#line 118
      goto case_6;
    }
#line 119
    if (order == 5) {
#line 119
      goto case_5;
    }
#line 120
    if (order == 4) {
#line 120
      goto case_4;
    }
#line 121
    if (order == 3) {
#line 121
      goto case_3;
    }
#line 122
    if (order == 2) {
#line 122
      goto case_2;
    }
#line 123
    if (order == 1) {
#line 123
      goto case_1;
    }
#line 125
    goto switch_default;
    case_32: /* CIL Label */ 
#line 92
    pred += *(coefs + 31) * *(smp + (i - 32));
    case_31: /* CIL Label */ 
#line 93
    pred += *(coefs + 30) * *(smp + (i - 31));
    case_30: /* CIL Label */ 
#line 94
    pred += *(coefs + 29) * *(smp + (i - 30));
    case_29: /* CIL Label */ 
#line 95
    pred += *(coefs + 28) * *(smp + (i - 29));
    case_28: /* CIL Label */ 
#line 96
    pred += *(coefs + 27) * *(smp + (i - 28));
    case_27: /* CIL Label */ 
#line 97
    pred += *(coefs + 26) * *(smp + (i - 27));
    case_26: /* CIL Label */ 
#line 98
    pred += *(coefs + 25) * *(smp + (i - 26));
    case_25: /* CIL Label */ 
#line 99
    pred += *(coefs + 24) * *(smp + (i - 25));
    case_24: /* CIL Label */ 
#line 100
    pred += *(coefs + 23) * *(smp + (i - 24));
    case_23: /* CIL Label */ 
#line 101
    pred += *(coefs + 22) * *(smp + (i - 23));
    case_22: /* CIL Label */ 
#line 102
    pred += *(coefs + 21) * *(smp + (i - 22));
    case_21: /* CIL Label */ 
#line 103
    pred += *(coefs + 20) * *(smp + (i - 21));
    case_20: /* CIL Label */ 
#line 104
    pred += *(coefs + 19) * *(smp + (i - 20));
    case_19: /* CIL Label */ 
#line 105
    pred += *(coefs + 18) * *(smp + (i - 19));
    case_18: /* CIL Label */ 
#line 106
    pred += *(coefs + 17) * *(smp + (i - 18));
    case_17: /* CIL Label */ 
#line 107
    pred += *(coefs + 16) * *(smp + (i - 17));
    case_16: /* CIL Label */ 
#line 108
    pred += *(coefs + 15) * *(smp + (i - 16));
    case_15: /* CIL Label */ 
#line 109
    pred += *(coefs + 14) * *(smp + (i - 15));
    case_14: /* CIL Label */ 
#line 110
    pred += *(coefs + 13) * *(smp + (i - 14));
    case_13: /* CIL Label */ 
#line 111
    pred += *(coefs + 12) * *(smp + (i - 13));
    case_12: /* CIL Label */ 
#line 112
    pred += *(coefs + 11) * *(smp + (i - 12));
    case_11: /* CIL Label */ 
#line 113
    pred += *(coefs + 10) * *(smp + (i - 11));
    case_10: /* CIL Label */ 
#line 114
    pred += *(coefs + 9) * *(smp + (i - 10));
    case_9: /* CIL Label */ 
#line 115
    pred += *(coefs + 8) * *(smp + (i - 9));
    case_8: /* CIL Label */ 
#line 116
    pred += *(coefs + 7) * *(smp + (i - 8));
    case_7: /* CIL Label */ 
#line 117
    pred += *(coefs + 6) * *(smp + (i - 7));
    case_6: /* CIL Label */ 
#line 118
    pred += *(coefs + 5) * *(smp + (i - 6));
    case_5: /* CIL Label */ 
#line 119
    pred += *(coefs + 4) * *(smp + (i - 5));
    case_4: /* CIL Label */ 
#line 120
    pred += *(coefs + 3) * *(smp + (i - 4));
    case_3: /* CIL Label */ 
#line 121
    pred += *(coefs + 2) * *(smp + (i - 3));
    case_2: /* CIL Label */ 
#line 122
    pred += *(coefs + 1) * *(smp + (i - 2));
    case_1: /* CIL Label */ 
#line 123
    pred += *(coefs + 0) * *(smp + (i - 1));
    switch_default: /* CIL Label */ 
#line 125
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 127
    *(res + i) = *(smp + i) - (pred >> shift);
#line 87
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 54 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
static void const   *body___1(MD5Context *ctx , void const   *data , uint32_t size ) 
{ 
  uint8_t const   *ptr ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;

  {
#line 61
  ptr = (uint8_t const   *)data;
#line 63
  a = ctx->a;
#line 64
  b = ctx->b;
#line 65
  c = ctx->c;
#line 66
  d = ctx->d;
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 69
    saved_a = a;
#line 70
    saved_b = b;
#line 71
    saved_c = c;
#line 72
    saved_d = d;
#line 75
    tmp = (((uint32_t )*(ptr + 0) | ((uint32_t )*(ptr + 1) << 8)) | ((uint32_t )*(ptr + 2) << 16)) | ((uint32_t )*(ptr + 3) << 24);
#line 75
    ctx->block[0] = tmp;
#line 75
    a += ((d ^ (b & (c ^ d))) + tmp) + 3614090360U;
#line 75
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 75
    a += b;
#line 76
    tmp___0 = (((uint32_t )*(ptr + 4) | ((uint32_t )*(ptr + 5) << 8)) | ((uint32_t )*(ptr + 6) << 16)) | ((uint32_t )*(ptr + 7) << 24);
#line 76
    ctx->block[1] = tmp___0;
#line 76
    d += ((c ^ (a & (b ^ c))) + tmp___0) + 3905402710U;
#line 76
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 76
    d += a;
#line 77
    tmp___1 = (((uint32_t )*(ptr + 8) | ((uint32_t )*(ptr + 9) << 8)) | ((uint32_t )*(ptr + 10) << 16)) | ((uint32_t )*(ptr + 11) << 24);
#line 77
    ctx->block[2] = tmp___1;
#line 77
    c += ((b ^ (d & (a ^ b))) + tmp___1) + 606105819U;
#line 77
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 77
    c += d;
#line 78
    tmp___2 = (((uint32_t )*(ptr + 12) | ((uint32_t )*(ptr + 13) << 8)) | ((uint32_t )*(ptr + 14) << 16)) | ((uint32_t )*(ptr + 15) << 24);
#line 78
    ctx->block[3] = tmp___2;
#line 78
    b += ((a ^ (c & (d ^ a))) + tmp___2) + 3250441966U;
#line 78
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 78
    b += c;
#line 79
    tmp___3 = (((uint32_t )*(ptr + 16) | ((uint32_t )*(ptr + 17) << 8)) | ((uint32_t )*(ptr + 18) << 16)) | ((uint32_t )*(ptr + 19) << 24);
#line 79
    ctx->block[4] = tmp___3;
#line 79
    a += ((d ^ (b & (c ^ d))) + tmp___3) + 4118548399U;
#line 79
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 79
    a += b;
#line 80
    tmp___4 = (((uint32_t )*(ptr + 20) | ((uint32_t )*(ptr + 21) << 8)) | ((uint32_t )*(ptr + 22) << 16)) | ((uint32_t )*(ptr + 23) << 24);
#line 80
    ctx->block[5] = tmp___4;
#line 80
    d += ((c ^ (a & (b ^ c))) + tmp___4) + 1200080426U;
#line 80
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 80
    d += a;
#line 81
    tmp___5 = (((uint32_t )*(ptr + 24) | ((uint32_t )*(ptr + 25) << 8)) | ((uint32_t )*(ptr + 26) << 16)) | ((uint32_t )*(ptr + 27) << 24);
#line 81
    ctx->block[6] = tmp___5;
#line 81
    c += ((b ^ (d & (a ^ b))) + tmp___5) + 2821735955U;
#line 81
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 81
    c += d;
#line 82
    tmp___6 = (((uint32_t )*(ptr + 28) | ((uint32_t )*(ptr + 29) << 8)) | ((uint32_t )*(ptr + 30) << 16)) | ((uint32_t )*(ptr + 31) << 24);
#line 82
    ctx->block[7] = tmp___6;
#line 82
    b += ((a ^ (c & (d ^ a))) + tmp___6) + 4249261313U;
#line 82
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 82
    b += c;
#line 83
    tmp___7 = (((uint32_t )*(ptr + 32) | ((uint32_t )*(ptr + 33) << 8)) | ((uint32_t )*(ptr + 34) << 16)) | ((uint32_t )*(ptr + 35) << 24);
#line 83
    ctx->block[8] = tmp___7;
#line 83
    a += ((d ^ (b & (c ^ d))) + tmp___7) + 1770035416U;
#line 83
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 83
    a += b;
#line 84
    tmp___8 = (((uint32_t )*(ptr + 36) | ((uint32_t )*(ptr + 37) << 8)) | ((uint32_t )*(ptr + 38) << 16)) | ((uint32_t )*(ptr + 39) << 24);
#line 84
    ctx->block[9] = tmp___8;
#line 84
    d += ((c ^ (a & (b ^ c))) + tmp___8) + 2336552879U;
#line 84
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 84
    d += a;
#line 85
    tmp___9 = (((uint32_t )*(ptr + 40) | ((uint32_t )*(ptr + 41) << 8)) | ((uint32_t )*(ptr + 42) << 16)) | ((uint32_t )*(ptr + 43) << 24);
#line 85
    ctx->block[10] = tmp___9;
#line 85
    c += ((b ^ (d & (a ^ b))) + tmp___9) + 4294925233U;
#line 85
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 85
    c += d;
#line 86
    tmp___10 = (((uint32_t )*(ptr + 44) | ((uint32_t )*(ptr + 45) << 8)) | ((uint32_t )*(ptr + 46) << 16)) | ((uint32_t )*(ptr + 47) << 24);
#line 86
    ctx->block[11] = tmp___10;
#line 86
    b += ((a ^ (c & (d ^ a))) + tmp___10) + 2304563134U;
#line 86
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 86
    b += c;
#line 87
    tmp___11 = (((uint32_t )*(ptr + 48) | ((uint32_t )*(ptr + 49) << 8)) | ((uint32_t )*(ptr + 50) << 16)) | ((uint32_t )*(ptr + 51) << 24);
#line 87
    ctx->block[12] = tmp___11;
#line 87
    a += ((d ^ (b & (c ^ d))) + tmp___11) + 1804603682U;
#line 87
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 87
    a += b;
#line 88
    tmp___12 = (((uint32_t )*(ptr + 52) | ((uint32_t )*(ptr + 53) << 8)) | ((uint32_t )*(ptr + 54) << 16)) | ((uint32_t )*(ptr + 55) << 24);
#line 88
    ctx->block[13] = tmp___12;
#line 88
    d += ((c ^ (a & (b ^ c))) + tmp___12) + 4254626195U;
#line 88
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 88
    d += a;
#line 89
    tmp___13 = (((uint32_t )*(ptr + 56) | ((uint32_t )*(ptr + 57) << 8)) | ((uint32_t )*(ptr + 58) << 16)) | ((uint32_t )*(ptr + 59) << 24);
#line 89
    ctx->block[14] = tmp___13;
#line 89
    c += ((b ^ (d & (a ^ b))) + tmp___13) + 2792965006U;
#line 89
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 89
    c += d;
#line 90
    tmp___14 = (((uint32_t )*(ptr + 60) | ((uint32_t )*(ptr + 61) << 8)) | ((uint32_t )*(ptr + 62) << 16)) | ((uint32_t )*(ptr + 63) << 24);
#line 90
    ctx->block[15] = tmp___14;
#line 90
    b += ((a ^ (c & (d ^ a))) + tmp___14) + 1236535329U;
#line 90
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 90
    b += c;
#line 93
    a += ((c ^ (d & (b ^ c))) + ctx->block[1]) + 4129170786U;
#line 93
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 93
    a += b;
#line 94
    d += ((b ^ (c & (a ^ b))) + ctx->block[6]) + 3225465664U;
#line 94
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 94
    d += a;
#line 95
    c += ((a ^ (b & (d ^ a))) + ctx->block[11]) + 643717713U;
#line 95
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 95
    c += d;
#line 96
    b += ((d ^ (a & (c ^ d))) + ctx->block[0]) + 3921069994U;
#line 96
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 96
    b += c;
#line 97
    a += ((c ^ (d & (b ^ c))) + ctx->block[5]) + 3593408605U;
#line 97
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 97
    a += b;
#line 98
    d += ((b ^ (c & (a ^ b))) + ctx->block[10]) + 38016083U;
#line 98
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 98
    d += a;
#line 99
    c += ((a ^ (b & (d ^ a))) + ctx->block[15]) + 3634488961U;
#line 99
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 99
    c += d;
#line 100
    b += ((d ^ (a & (c ^ d))) + ctx->block[4]) + 3889429448U;
#line 100
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 100
    b += c;
#line 101
    a += ((c ^ (d & (b ^ c))) + ctx->block[9]) + 568446438U;
#line 101
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 101
    a += b;
#line 102
    d += ((b ^ (c & (a ^ b))) + ctx->block[14]) + 3275163606U;
#line 102
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 102
    d += a;
#line 103
    c += ((a ^ (b & (d ^ a))) + ctx->block[3]) + 4107603335U;
#line 103
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 103
    c += d;
#line 104
    b += ((d ^ (a & (c ^ d))) + ctx->block[8]) + 1163531501U;
#line 104
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 104
    b += c;
#line 105
    a += ((c ^ (d & (b ^ c))) + ctx->block[13]) + 2850285829U;
#line 105
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 105
    a += b;
#line 106
    d += ((b ^ (c & (a ^ b))) + ctx->block[2]) + 4243563512U;
#line 106
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 106
    d += a;
#line 107
    c += ((a ^ (b & (d ^ a))) + ctx->block[7]) + 1735328473U;
#line 107
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 107
    c += d;
#line 108
    b += ((d ^ (a & (c ^ d))) + ctx->block[12]) + 2368359562U;
#line 108
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 108
    b += c;
#line 111
    a += (((b ^ c) ^ d) + ctx->block[5]) + 4294588738U;
#line 111
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 111
    a += b;
#line 112
    d += (((a ^ b) ^ c) + ctx->block[8]) + 2272392833U;
#line 112
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 112
    d += a;
#line 113
    c += (((d ^ a) ^ b) + ctx->block[11]) + 1839030562U;
#line 113
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 113
    c += d;
#line 114
    b += (((c ^ d) ^ a) + ctx->block[14]) + 4259657740U;
#line 114
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 114
    b += c;
#line 115
    a += (((b ^ c) ^ d) + ctx->block[1]) + 2763975236U;
#line 115
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 115
    a += b;
#line 116
    d += (((a ^ b) ^ c) + ctx->block[4]) + 1272893353U;
#line 116
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 116
    d += a;
#line 117
    c += (((d ^ a) ^ b) + ctx->block[7]) + 4139469664U;
#line 117
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 117
    c += d;
#line 118
    b += (((c ^ d) ^ a) + ctx->block[10]) + 3200236656U;
#line 118
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 118
    b += c;
#line 119
    a += (((b ^ c) ^ d) + ctx->block[13]) + 681279174U;
#line 119
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 119
    a += b;
#line 120
    d += (((a ^ b) ^ c) + ctx->block[0]) + 3936430074U;
#line 120
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 120
    d += a;
#line 121
    c += (((d ^ a) ^ b) + ctx->block[3]) + 3572445317U;
#line 121
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 121
    c += d;
#line 122
    b += (((c ^ d) ^ a) + ctx->block[6]) + 76029189U;
#line 122
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 122
    b += c;
#line 123
    a += (((b ^ c) ^ d) + ctx->block[9]) + 3654602809U;
#line 123
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 123
    a += b;
#line 124
    d += (((a ^ b) ^ c) + ctx->block[12]) + 3873151461U;
#line 124
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 124
    d += a;
#line 125
    c += (((d ^ a) ^ b) + ctx->block[15]) + 530742520U;
#line 125
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 125
    c += d;
#line 126
    b += (((c ^ d) ^ a) + ctx->block[2]) + 3299628645U;
#line 126
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 126
    b += c;
#line 129
    a += ((c ^ (b | ~ d)) + ctx->block[0]) + 4096336452U;
#line 129
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 129
    a += b;
#line 130
    d += ((b ^ (a | ~ c)) + ctx->block[7]) + 1126891415U;
#line 130
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 130
    d += a;
#line 131
    c += ((a ^ (d | ~ b)) + ctx->block[14]) + 2878612391U;
#line 131
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 131
    c += d;
#line 132
    b += ((d ^ (c | ~ a)) + ctx->block[5]) + 4237533241U;
#line 132
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 132
    b += c;
#line 133
    a += ((c ^ (b | ~ d)) + ctx->block[12]) + 1700485571U;
#line 133
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 133
    a += b;
#line 134
    d += ((b ^ (a | ~ c)) + ctx->block[3]) + 2399980690U;
#line 134
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 134
    d += a;
#line 135
    c += ((a ^ (d | ~ b)) + ctx->block[10]) + 4293915773U;
#line 135
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 135
    c += d;
#line 136
    b += ((d ^ (c | ~ a)) + ctx->block[1]) + 2240044497U;
#line 136
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 136
    b += c;
#line 137
    a += ((c ^ (b | ~ d)) + ctx->block[8]) + 1873313359U;
#line 137
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 137
    a += b;
#line 138
    d += ((b ^ (a | ~ c)) + ctx->block[15]) + 4264355552U;
#line 138
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 138
    d += a;
#line 139
    c += ((a ^ (d | ~ b)) + ctx->block[6]) + 2734768916U;
#line 139
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 139
    c += d;
#line 140
    b += ((d ^ (c | ~ a)) + ctx->block[13]) + 1309151649U;
#line 140
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 140
    b += c;
#line 141
    a += ((c ^ (b | ~ d)) + ctx->block[4]) + 4149444226U;
#line 141
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 141
    a += b;
#line 142
    d += ((b ^ (a | ~ c)) + ctx->block[11]) + 3174756917U;
#line 142
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 142
    d += a;
#line 143
    c += ((a ^ (d | ~ b)) + ctx->block[2]) + 718787259U;
#line 143
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 143
    c += d;
#line 144
    b += ((d ^ (c | ~ a)) + ctx->block[9]) + 3951481745U;
#line 144
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 144
    b += c;
#line 146
    a += saved_a;
#line 147
    b += saved_b;
#line 148
    c += saved_c;
#line 149
    d += saved_d;
#line 151
    ptr += 64;
#line 68
    size -= 64U;
#line 68
    if (! size) {
#line 68
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  ctx->a = a;
#line 155
  ctx->b = b;
#line 156
  ctx->c = c;
#line 157
  ctx->d = d;
#line 159
  return ((void const   *)ptr);
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_autocorr___1(int32_t const   *data , int len , int lag , double *autoc ) 
{ 
  int i ;
  int j ;
  double *data1 ;
  double temp ;
  double temp2 ;
  void *tmp ;

  {
  {
  {
#line 53
  tmp = malloc((size_t )((unsigned long )(len + 16) * sizeof(double )));
  }
#line 53
  data1 = (double *)tmp;
  {
#line 54
  apply_welch_window(data, len, data1);
  }
#line 55
  *(data1 + len) = (double )0;
#line 57
  i = 0;
  }
  {
  {
#line 57
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= lag)) {
#line 57
      goto while_break;
    }
#line 58
    temp = 1.0;
#line 59
    temp2 = 1.0;
#line 60
    j = 0;
    {
    {
#line 60
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (j <= lag - i)) {
#line 60
        goto while_break___0;
      }
#line 61
      temp += *(data1 + (j + i)) * *(data1 + j);
#line 60
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    j = lag + 1;
    {
    {
#line 63
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 63
      if (! (j <= len - 1)) {
#line 63
        goto while_break___1;
      }
#line 64
      temp += *(data1 + j) * *(data1 + (j - i));
#line 65
      temp2 += *(data1 + (j + 1)) * *(data1 + ((j + 1) - i));
#line 63
      j += 2;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 67
    *(autoc + i) = temp + temp2;
#line 57
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 70
  free((void *)data1);
  }
  }
#line 71
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_lpc_coefs___1(double const   *autoc , int max_order , double *ref ,
                                  double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  int i2 ;
  double r ;
  double err ;
  double tmp ;
  double lpc_tmp[32] ;
  void *__cil_tmp12 ;

  {
#line 85
  i = 0;
  {
  {
#line 85
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < max_order)) {
#line 85
      goto while_break;
    }
#line 85
    lpc_tmp[i] = (double )0;
#line 85
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  err = 1.0;
#line 87
  if (autoc) {
#line 88
    err = (double )*(autoc + 0);
  }
#line 91
  i = 0;
  {
  {
#line 91
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < max_order)) {
#line 91
      goto while_break___0;
    }
#line 92
    if (ref) {
#line 93
      r = *(ref + i);
    } else {
#line 95
      r = (double )(- *(autoc + (i + 1)));
#line 96
      j = 0;
      {
      {
#line 96
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 96
        if (! (j < i)) {
#line 96
          goto while_break___1;
        }
#line 97
        r -= lpc_tmp[j] * (double )*(autoc + (i - j));
#line 96
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 99
      r /= err;
#line 100
      err *= 1.0 - r * r;
    }
#line 103
    i2 = i >> 1;
#line 104
    lpc_tmp[i] = r;
#line 105
    j = 0;
    {
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 105
      if (! (j < i2)) {
#line 105
        goto while_break___2;
      }
#line 106
      tmp = lpc_tmp[j];
#line 107
      lpc_tmp[j] += r * lpc_tmp[(i - 1) - j];
#line 108
      lpc_tmp[(i - 1) - j] += r * tmp;
#line 105
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 110
    if (i & 1) {
#line 111
      lpc_tmp[j] += lpc_tmp[j] * r;
    }
#line 114
    j = 0;
    {
    {
#line 114
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 114
      if (! (j <= i)) {
#line 114
        goto while_break___3;
      }
#line 115
      (*(lpc + i))[j] = - lpc_tmp[j];
#line 114
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 91
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 126 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static int compute_lpc_coefs_est___1(double const   *autoc , int max_order , double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  double error ;
  double gen[2][32] ;
  double ref[32] ;
  int order_est ;
  double tmp ;
  double tmp___0 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 137
  i = 0;
  {
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < max_order)) {
#line 137
      goto while_break;
    }
#line 137
    tmp = (double )*(autoc + (i + 1));
#line 137
    gen[1][i] = tmp;
#line 137
    gen[0][i] = tmp;
#line 137
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  error = (double )*(autoc + 0);
#line 139
  ref[0] = - gen[1][0] / error;
#line 140
  error += gen[1][0] * ref[0];
#line 141
  i = 1;
  {
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (i < max_order)) {
#line 141
      goto while_break___0;
    }
#line 142
    j = 0;
    {
    {
#line 142
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 142
      if (! (j < max_order - i)) {
#line 142
        goto while_break___1;
      }
#line 143
      gen[1][j] = gen[1][j + 1] + ref[i - 1] * gen[0][j];
#line 144
      gen[0][j] = gen[1][j + 1] * ref[i - 1] + gen[0][j];
#line 142
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 146
    ref[i] = - gen[1][0] / error;
#line 147
    error += gen[1][0] * ref[i];
#line 141
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  order_est = 1;
#line 152
  i = max_order - 1;
  {
  {
#line 152
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 152
    if (! (i >= 0)) {
#line 152
      goto while_break___2;
    }
    {
    {
#line 153
    tmp___0 = fabs(ref[i]);
    }
    }
#line 153
    if (tmp___0 > 0.10) {
#line 154
      order_est = i + 1;
#line 155
      goto while_break___2;
    }
#line 152
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 160
  compute_lpc_coefs___1((double const   *)((void *)0), order_est, ref, lpc);
  }
  }
#line 162
  return (order_est);
}
}
#line 168 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void quantize_lpc_coefs___1(double *lpc_in , int order , int precision , int32_t *lpc_out ,
                                   int *shift ) 
{ 
  int i ;
  double d ;
  double cmax ;
  double error ;
  int32_t qmax ;
  int sh ;
  int q ;
  double scale ;

  {
#line 178
  qmax = (1 << (precision - 1)) - 1;
#line 181
  cmax = 0.0;
#line 182
  i = 0;
  {
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < order)) {
#line 182
      goto while_break;
    }
    {
    {
#line 183
    d = fabs(*(lpc_in + i));
    }
    }
#line 184
    if (d > cmax) {
#line 185
      cmax = d;
    }
#line 182
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (cmax * (double )(1 << 15) < 1.0) {
    {
#line 189
    *shift = 0;
    {
#line 190
    memset((void *)lpc_out, 0, (size_t )(sizeof(int32_t ) * (unsigned long )order));
    }
    }
#line 191
    return;
  }
#line 195
  sh = 15;
  {
  {
#line 196
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 196
    if (cmax * (double )(1 << sh) > (double )qmax) {
#line 196
      if (! (sh > 0)) {
#line 196
        goto while_break___0;
      }
    } else {
#line 196
      goto while_break___0;
    }
#line 197
    sh --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  if (sh == 0) {
#line 202
    if (cmax > (double )qmax) {
#line 203
      scale = (double )qmax / cmax;
#line 204
      i = 0;
      {
      {
#line 204
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i < order)) {
#line 204
          goto while_break___1;
        }
#line 205
        *(lpc_in + i) *= scale;
#line 204
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 210
  error = (double )0;
#line 211
  i = 0;
  {
  {
#line 211
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 211
    if (! (i < order)) {
#line 211
      goto while_break___2;
    }
#line 212
    error += *(lpc_in + i) * (double )(1 << sh);
#line 213
    q = (int )(error + 0.5);
#line 214
    if (q <= - qmax) {
#line 214
      q = - qmax + 1;
    }
#line 215
    if (q > qmax) {
#line 215
      q = qmax;
    }
#line 216
    error -= (double )q;
#line 217
    *(lpc_out + i) = q;
#line 211
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 219
  *shift = sh;
#line 220
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static void crc_init_table___1(uint16_t *table , int bits , int poly ) 
{ 
  int i ;
  int j ;
  int crc ;

  {
#line 29
  poly += 1 << bits;
#line 30
  i = 0;
  {
  {
#line 30
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < 256)) {
#line 30
      goto while_break;
    }
#line 31
    crc = i;
#line 32
    j = 0;
    {
    {
#line 32
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 32
      if (! (j < bits)) {
#line 32
        goto while_break___0;
      }
#line 33
      if (crc & (1 << (bits - 1))) {
#line 34
        crc = (crc << 1) ^ poly;
      } else {
#line 36
        crc <<= 1;
      }
#line 32
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    *(table + i) = (uint16_t )(crc & ((1 << bits) - 1));
#line 30
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc8tab___1[256]  ;
#line 50 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc16tab___1[256]  ;
#line 59 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t calc_crc___1(uint16_t const   *table , int bits , uint8_t const   *data ,
                             uint32_t len ) 
{ 
  uint16_t crc ;
  uint16_t v1 ;
  uint16_t v2 ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 64
  crc = (uint16_t )0;
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    tmp___0 = len;
#line 65
    len --;
#line 65
    if (! tmp___0) {
#line 65
      goto while_break;
    }
#line 66
    v1 = (uint16_t )(((int )crc << 8) & ((1 << bits) - 1));
#line 67
    tmp = data;
#line 67
    data ++;
#line 67
    v2 = (uint16_t )(((int )crc >> (bits - 8)) ^ (int )*tmp);
#line 68
    if (! ((int )v2 < 256)) {
      {
      {
#line 68
      __assert_fail("v2 < 256", "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c",
                    68U, "calc_crc");
      }
      }
    }
#line 69
    crc = (uint16_t )((int )v1 ^ (int )*(table + v2));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (crc);
}
}
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_samplerates___1[16]  = 
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )8000,      (int const   )16000,      (int const   )22050,      (int const   )24000, 
        (int const   )32000,      (int const   )44100,      (int const   )48000,      (int const   )96000, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_bitdepths___1[8]  = 
#line 39
  {      (int const   )0,      (int const   )8,      (int const   )12,      (int const   )0, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )0};
#line 43 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_blocksizes___1[15]  = 
#line 43
  {      (int const   )0,      (int const   )192,      (int const   )576,      (int const   )1152, 
        (int const   )2304,      (int const   )4608,      (int const   )0,      (int const   )0, 
        (int const   )256,      (int const   )512,      (int const   )1024,      (int const   )2048, 
        (int const   )4096,      (int const   )8192,      (int const   )16384};
#line 55 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_streaminfo___1(FlacEncodeContext *ctx , uint8_t *streaminfo , int last ) 
{ 


  {
  {
  {
#line 58
  memset((void *)streaminfo, 0, (size_t )38);
  }
  {
#line 59
  bitwriter_init(ctx->bw, (void *)streaminfo, 38);
  }
  {
#line 62
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 63
  bitwriter_writebits(ctx->bw, 7, (uint32_t )0);
  }
  {
#line 64
  bitwriter_writebits(ctx->bw, 24, (uint32_t )34);
  }
  }
#line 66
  if (ctx->params.variable_block_size) {
    {
    {
#line 67
    bitwriter_writebits(ctx->bw, 16, (uint32_t )0);
    }
    }
  } else {
    {
    {
#line 69
    bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
    }
    }
  }
  {
  {
#line 71
  bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
  }
  {
#line 72
  bitwriter_writebits(ctx->bw, 24, (uint32_t )0);
  }
  {
#line 73
  bitwriter_writebits(ctx->bw, 24, (uint32_t )ctx->max_frame_size);
  }
  {
#line 74
  bitwriter_writebits(ctx->bw, 20, (uint32_t )ctx->samplerate);
  }
  {
#line 75
  bitwriter_writebits(ctx->bw, 3, (uint32_t )(ctx->channels - 1));
  }
  {
#line 76
  bitwriter_writebits(ctx->bw, 5, (uint32_t )(ctx->bps - 1));
  }
  }
#line 79
  if (ctx->sample_count > 0U) {
    {
    {
#line 80
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 81
    bitwriter_writebits(ctx->bw, 32, ctx->sample_count);
    }
    }
  } else {
    {
    {
#line 83
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 84
    bitwriter_writebits(ctx->bw, 32, (uint32_t )0);
    }
    }
  }
#line 86
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_padding___1(FlacEncodeContext *ctx , uint8_t *padding , int last ,
                             int padlen ) 
{ 


  {
  {
  {
#line 94
  bitwriter_init(ctx->bw, (void *)padding, 4);
  }
  {
#line 97
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 98
  bitwriter_writebits(ctx->bw, 7, (uint32_t )1);
  }
  {
#line 99
  bitwriter_writebits(ctx->bw, 24, (uint32_t )padlen);
  }
  }
#line 101
  return (padlen + 4);
}
}
#line 104 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static char const   *vendor_string___1  =    "Flake0.11";
#line 110 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_vorbis_comment___1(FlacEncodeContext *ctx , uint8_t *comment , int last ) 
{ 
  int vendor_len ;
  uint8_t vlen_le[4] ;
  size_t tmp ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 116
  tmp = strlen(vendor_string___1);
  }
#line 116
  vendor_len = (int )tmp;
  {
#line 117
  bitwriter_init(ctx->bw, (void *)comment, 4);
  }
  {
#line 120
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 121
  bitwriter_writebits(ctx->bw, 7, (uint32_t )4);
  }
  {
#line 122
  bitwriter_writebits(ctx->bw, 24, (uint32_t )(vendor_len + 8));
  }
#line 126
  vlen_le[0] = (uint8_t )(vendor_len & 255);
#line 127
  vlen_le[1] = (uint8_t )((vendor_len >> 8) & 255);
#line 128
  vlen_le[2] = (uint8_t )((vendor_len >> 16) & 255);
#line 129
  vlen_le[3] = (uint8_t )((vendor_len >> 24) & 255);
  {
#line 130
  memcpy((void */* __restrict  */)(comment + 4), (void const   */* __restrict  */)(vlen_le),
         (size_t )4);
  }
  {
#line 132
  memcpy((void */* __restrict  */)(comment + 8), (void const   */* __restrict  */)vendor_string___1,
         (size_t )vendor_len);
  }
  {
#line 134
  memset((void *)(comment + (vendor_len + 8)), 0, (size_t )4);
  }
  }
#line 136
  return (vendor_len + 12);
}
}
#line 142 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_headers___1(FlacEncodeContext *ctx , uint8_t *header ) 
{ 
  int header_size ;
  int last ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 147
  header_size = 0;
#line 148
  last = 0;
#line 151
  *(header + 0) = (uint8_t )102;
#line 152
  *(header + 1) = (uint8_t )76;
#line 153
  *(header + 2) = (uint8_t )97;
#line 154
  *(header + 3) = (uint8_t )67;
#line 155
  header_size += 4;
  {
#line 158
  write_streaminfo___1(ctx, header + header_size, last);
  }
#line 159
  header_size += 38;
  }
#line 162
  if (ctx->params.padding_size == 0) {
#line 162
    last = 1;
  }
  {
  {
#line 163
  tmp = write_vorbis_comment___1(ctx, header + header_size, last);
  }
#line 163
  header_size += tmp;
  }
#line 166
  if (ctx->params.padding_size > 0) {
    {
#line 167
    last = 1;
    {
#line 168
    tmp___0 = write_padding___1(ctx, header + header_size, last, ctx->params.padding_size);
    }
#line 168
    header_size += tmp___0;
    }
  }
#line 172
  return (header_size);
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int select_blocksize___1(int samplerate , int time_ms ) 
{ 
  int i ;
  int target ;
  int blocksize ;

  {
#line 184
  blocksize = (int )flac_blocksizes___1[1];
#line 185
  target = (samplerate * time_ms) / 1000;
#line 186
  i = 0;
  {
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 16)) {
#line 186
      goto while_break;
    }
#line 187
    if (target >= (int )flac_blocksizes___1[i]) {
#line 187
      if (flac_blocksizes___1[i] > (int const   )blocksize) {
#line 188
        blocksize = (int )flac_blocksizes___1[i];
      }
    }
#line 186
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (blocksize);
}
}
#line 533 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int init_frame___1(FlacEncodeContext *ctx ) 
{ 
  int i ;
  int ch ;
  FlacFrame *frame ;

  {
#line 539
  frame = & ctx->frame;
#line 541
  if (ctx->params.block_time_ms < 0) {
#line 542
    return (-1);
  }
#line 544
  if (ctx->params.block_size == 0) {
    {
    {
#line 545
    ctx->params.block_size = select_blocksize___1(ctx->samplerate, ctx->params.block_time_ms);
    }
    }
  }
#line 547
  if (ctx->params.block_size < 1) {
#line 549
    return (-1);
  } else
#line 547
  if (ctx->params.block_size > 65535) {
#line 549
    return (-1);
  }
#line 553
  if (ctx->channels == 2) {
#line 554
    ctx->max_frame_size = 16 + ((ctx->params.block_size * ((ctx->bps + ctx->bps) + 1) + 7) >> 3);
  } else {
#line 556
    ctx->max_frame_size = 16 + (((ctx->params.block_size * ctx->channels) * ctx->bps + 7) >> 3);
  }
#line 560
  i = 15;
#line 561
  if (! ctx->params.variable_block_size) {
#line 562
    i = 0;
    {
    {
#line 562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 562
      if (! (i < 15)) {
#line 562
        goto while_break;
      }
#line 563
      if (ctx->params.block_size == (int )flac_blocksizes___1[i]) {
#line 564
        frame->blocksize = (int )flac_blocksizes___1[i];
#line 565
        frame->bs_code[0] = i;
#line 566
        frame->bs_code[1] = -1;
#line 567
        goto while_break;
      }
#line 562
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 571
  if (i == 15) {
#line 572
    frame->blocksize = ctx->params.block_size;
#line 573
    if (frame->blocksize <= 256) {
#line 574
      frame->bs_code[0] = 6;
#line 575
      frame->bs_code[1] = frame->blocksize - 1;
    } else {
#line 577
      frame->bs_code[0] = 7;
#line 578
      frame->bs_code[1] = frame->blocksize - 1;
    }
  }
#line 583
  ch = 0;
  {
  {
#line 583
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (ch < ctx->channels)) {
#line 583
      goto while_break___0;
    }
#line 584
    frame->subframes[ch].obits = ctx->bps;
#line 583
    ch ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 593 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void update_md5_checksum___1(FlacEncodeContext *ctx , int16_t *samples ) 
{ 


  {
  {
  {
#line 596
  md5_accumulate(& ctx->md5ctx, (void const   *)samples, ctx->channels, ctx->params.block_size);
  }
  }
#line 597
  return;
}
}
#line 602 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void copy_samples___1(FlacEncodeContext *ctx , int16_t *samples ) 
{ 
  int i ;
  int j ;
  int ch ;
  FlacFrame *frame ;

  {
#line 608
  frame = & ctx->frame;
#line 609
  i = 0;
#line 609
  j = 0;
  {
  {
#line 609
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i < frame->blocksize)) {
#line 609
      goto while_break;
    }
#line 610
    ch = 0;
    {
    {
#line 610
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 610
      if (! (ch < ctx->channels)) {
#line 610
        goto while_break___0;
      }
#line 611
      frame->subframes[ch].samples[i] = (int32_t )*(samples + j);
#line 610
      ch ++;
#line 610
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 609
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return;
}
}
#line 619 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int calc_decorr_scores___1(int32_t *left_ch , int32_t *right_ch , int n ) 
{ 
  int i ;
  int best ;
  int32_t lt ;
  int32_t rt ;
  uint64_t sum[4] ;
  uint64_t score[4] ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 629
  sum[3] = (uint64_t )0;
#line 629
  sum[2] = sum[3];
#line 629
  sum[1] = sum[2];
#line 629
  sum[0] = sum[1];
#line 630
  i = 2;
  {
  {
#line 630
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < n)) {
#line 630
      goto while_break;
    }
    {
#line 631
    lt = (*(left_ch + i) - 2 * *(left_ch + (i - 1))) + *(left_ch + (i - 2));
#line 632
    rt = (*(right_ch + i) - 2 * *(right_ch + (i - 1))) + *(right_ch + (i - 2));
    {
#line 633
    tmp = abs((lt + rt) >> 1);
    }
#line 633
    sum[2] += (uint64_t )tmp;
    {
#line 634
    tmp___0 = abs(lt - rt);
    }
#line 634
    sum[3] += (uint64_t )tmp___0;
    {
#line 635
    tmp___1 = abs(lt);
    }
#line 635
    sum[0] += (uint64_t )tmp___1;
    {
#line 636
    tmp___2 = abs(rt);
    }
#line 636
    sum[1] += (uint64_t )tmp___2;
#line 630
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  i = 0;
  {
  {
#line 639
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (i < 4)) {
#line 639
      goto while_break___0;
    }
    {
    {
#line 640
    k = find_optimal_rice_param((uint32_t )(2ULL * sum[i]), n);
    }
#line 641
    sum[i] = (uint64_t )(n * (k + 1)) + ((2ULL * sum[i] - (uint64_t )(n >> 1)) >> k);
#line 639
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 645
  score[0] = sum[0] + sum[1];
#line 646
  score[1] = sum[0] + sum[3];
#line 647
  score[2] = sum[1] + sum[3];
#line 648
  score[3] = sum[2] + sum[3];
#line 651
  best = 0;
#line 652
  i = 1;
  {
  {
#line 652
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 652
    if (! (i < 4)) {
#line 652
      goto while_break___1;
    }
#line 653
    if (score[i] < score[best]) {
#line 654
      best = i;
    }
#line 652
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 658
  if (best == 0) {
#line 658
    goto case_0;
  }
#line 659
  if (best == 1) {
#line 659
    goto case_1;
  }
#line 660
  if (best == 2) {
#line 660
    goto case_2;
  }
#line 661
  if (best == 3) {
#line 661
    goto case_3;
  }
#line 657
  goto switch_break;
  case_0: /* CIL Label */ 
#line 658
  return (1);
  case_1: /* CIL Label */ 
#line 659
  return (8);
  case_2: /* CIL Label */ 
#line 660
  return (9);
  case_3: /* CIL Label */ 
#line 661
  return (10);
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (1);
}
}
#line 669 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void channel_decorrelation___1(FlacEncodeContext *ctx ) 
{ 
  int i ;
  FlacFrame *frame ;
  int32_t *left ;
  int32_t *right ;
  int32_t tmp ;

  {
#line 677
  frame = & ctx->frame;
#line 678
  left = frame->subframes[0].samples;
#line 679
  right = frame->subframes[1].samples;
#line 681
  if (ctx->channels != 2) {
#line 682
    frame->ch_mode = 0;
#line 683
    return;
  }
#line 685
  if (frame->blocksize <= 32) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  } else
#line 685
  if (ctx->params.stereo_method == 0) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  }
  {
  {
#line 691
  frame->ch_mode = calc_decorr_scores___1(left, right, frame->blocksize);
  }
  }
#line 694
  if (frame->ch_mode == 1) {
#line 695
    return;
  }
#line 697
  if (frame->ch_mode == 10) {
#line 698
    i = 0;
    {
    {
#line 698
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 698
      if (! (i < frame->blocksize)) {
#line 698
        goto while_break;
      }
#line 699
      tmp = *(left + i);
#line 700
      *(left + i) = (*(left + i) + *(right + i)) >> 1;
#line 701
      *(right + i) = tmp - *(right + i);
#line 698
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    (frame->subframes[1].obits) ++;
  } else
#line 704
  if (frame->ch_mode == 8) {
#line 705
    i = 0;
    {
    {
#line 705
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 705
      if (! (i < frame->blocksize)) {
#line 705
        goto while_break___0;
      }
#line 706
      *(right + i) = *(left + i) - *(right + i);
#line 705
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    (frame->subframes[1].obits) ++;
  } else
#line 709
  if (frame->ch_mode == 9) {
#line 710
    i = 0;
    {
    {
#line 710
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 710
      if (! (i < frame->blocksize)) {
#line 710
        goto while_break___1;
      }
#line 711
      *(left + i) -= *(right + i);
#line 710
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 713
    (frame->subframes[0].obits) ++;
  }
#line 715
  return;
}
}
#line 721 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_utf8___1(BitWriter *bw , uint32_t val ) 
{ 
  int bytes ;
  int shift ;
  int tmp ;

  {
#line 726
  if (val < 128U) {
    {
    {
#line 727
    bitwriter_writebits(bw, 8, val);
    }
    }
#line 728
    return;
  }
  {
  {
#line 730
  tmp = log2i(val);
  }
#line 730
  bytes = (tmp + 4) / 5;
#line 731
  shift = (bytes - 1) * 6;
  {
#line 732
  bitwriter_writebits(bw, 8, (unsigned int )(256 - (256 >> bytes)) | (val >> shift));
  }
  }
  {
  {
#line 733
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 733
    if (! (shift >= 6)) {
#line 733
      goto while_break;
    }
    {
#line 734
    shift -= 6;
    {
#line 735
    bitwriter_writebits(bw, 8, 128U | ((val >> shift) & 63U));
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return;
}
}
#line 739 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_header___1(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  uint8_t crc ;
  uint32_t tmp ;

  {
  {
#line 745
  frame = & ctx->frame;
  {
#line 747
  bitwriter_writebits(ctx->bw, 16, (uint32_t )65528);
  }
  {
#line 748
  bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->bs_code[0]);
  }
  {
#line 749
  bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->sr_code[0]);
  }
  }
#line 750
  if (frame->ch_mode == 0) {
    {
    {
#line 751
    bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->ch_code);
    }
    }
  } else {
    {
    {
#line 753
    bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->ch_mode);
    }
    }
  }
  {
  {
#line 755
  bitwriter_writebits(ctx->bw, 3, (uint32_t )ctx->bps_code);
  }
  {
#line 756
  bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
  }
  {
#line 757
  write_utf8___1(ctx->bw, ctx->frame_count);
  }
  }
#line 760
  if (frame->bs_code[1] >= 0) {
#line 761
    if (frame->bs_code[1] < 256) {
      {
      {
#line 762
      bitwriter_writebits(ctx->bw, 8, (uint32_t )frame->bs_code[1]);
      }
      }
    } else {
      {
      {
#line 764
      bitwriter_writebits(ctx->bw, 16, (uint32_t )frame->bs_code[1]);
      }
      }
    }
  }
#line 769
  if (ctx->sr_code[1] > 0) {
#line 770
    if (ctx->sr_code[1] < 256) {
      {
      {
#line 771
      bitwriter_writebits(ctx->bw, 8, (uint32_t )ctx->sr_code[1]);
      }
      }
    } else {
      {
      {
#line 773
      bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->sr_code[1]);
      }
      }
    }
  }
  {
  {
#line 778
  bitwriter_flush(ctx->bw);
  }
  {
#line 779
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 779
  crc = calc_crc8((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 780
  bitwriter_writebits(ctx->bw, 8, (uint32_t )crc);
  }
  }
#line 781
  return;
}
}
#line 783 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_residual___1(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int j ;
  int p ;
  int k ;
  int porder ;
  int psize ;
  int res_cnt ;
  FlacFrame *frame ;
  FlacSubframe *sub ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 791
  frame = & ctx->frame;
#line 792
  sub = & frame->subframes[ch];
  {
#line 795
  bitwriter_writebits(ctx->bw, 2, (uint32_t )0);
  }
#line 798
  porder = sub->rc.porder;
#line 799
  psize = frame->blocksize >> porder;
  }
#line 800
  if (! (porder >= 0)) {
    {
    {
#line 800
    __assert_fail("porder >= 0", "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c",
                  800U, "output_residual");
    }
    }
  }
  {
  {
#line 801
  bitwriter_writebits(ctx->bw, 4, (uint32_t )porder);
  }
#line 802
  res_cnt = psize - sub->order;
#line 805
  j = sub->order;
#line 806
  p = 0;
  }
  {
  {
#line 806
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 806
    if (! (p < 1 << porder)) {
#line 806
      goto while_break;
    }
    {
#line 807
    k = sub->rc.params[p];
    {
#line 808
    bitwriter_writebits(ctx->bw, 4, (uint32_t )k);
    }
    }
#line 809
    if (p == 1) {
#line 809
      res_cnt = psize;
    }
#line 810
    i = 0;
    {
    {
#line 810
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 810
      if (i < res_cnt) {
#line 810
        if (! (j < frame->blocksize)) {
#line 810
          goto while_break___0;
        }
      } else {
#line 810
        goto while_break___0;
      }
      {
      {
#line 811
      bitwriter_write_rice_signed(ctx->bw, k, sub->residual[j]);
      }
#line 810
      i ++;
#line 810
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 806
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return;
}
}
#line 816 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_constant___1(FlacEncodeContext *ctx , int ch ) 
{ 
  FlacSubframe *sub ;

  {
  {
#line 821
  sub = & ctx->frame.subframes[ch];
  {
#line 822
  bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[0]);
  }
  }
#line 823
  return;
}
}
#line 825 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_verbatim___1(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int n ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 832
  frame = & ctx->frame;
#line 833
  sub = & frame->subframes[ch];
#line 834
  n = frame->blocksize;
#line 836
  i = 0;
  {
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < n)) {
#line 836
      goto while_break;
    }
    {
    {
#line 837
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 836
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 841 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_fixed___1(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 848
  frame = & ctx->frame;
#line 849
  sub = & frame->subframes[ch];
#line 852
  i = 0;
  {
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < sub->order)) {
#line 852
      goto while_break;
    }
    {
    {
#line 853
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 852
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 857
  output_residual___1(ctx, ch);
  }
  }
#line 858
  return;
}
}
#line 860 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_lpc___1(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int cbits ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 867
  frame = & ctx->frame;
#line 868
  sub = & frame->subframes[ch];
#line 871
  i = 0;
  {
  {
#line 871
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < sub->order)) {
#line 871
      goto while_break;
    }
    {
    {
#line 872
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 871
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 876
  cbits = ctx->lpc_precision;
  {
#line 877
  bitwriter_writebits(ctx->bw, 4, (uint32_t )(cbits - 1));
  }
  {
#line 878
  bitwriter_writebits_signed(ctx->bw, 5, sub->shift);
  }
#line 879
  i = 0;
  }
  {
  {
#line 879
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 879
    if (! (i < sub->order)) {
#line 879
      goto while_break___0;
    }
    {
    {
#line 880
    bitwriter_writebits_signed(ctx->bw, cbits, sub->coefs[i]);
    }
#line 879
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 884
  output_residual___1(ctx, ch);
  }
  }
#line 885
  return;
}
}
#line 887 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframes___1(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  int i ;
  int ch ;

  {
#line 893
  frame = & ctx->frame;
#line 895
  i = 0;
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    if (! (i < ctx->channels)) {
#line 895
      goto while_break;
    }
    {
#line 896
    ch = i;
    {
#line 899
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    {
#line 900
    bitwriter_writebits(ctx->bw, 6, (uint32_t )frame->subframes[ch].type_code);
    }
    {
#line 901
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    }
    {
#line 905
    if (frame->subframes[ch].type == 0) {
#line 905
      goto case_0;
    }
#line 907
    if (frame->subframes[ch].type == 1) {
#line 907
      goto case_1;
    }
#line 909
    if (frame->subframes[ch].type == 8) {
#line 909
      goto case_8;
    }
#line 911
    if (frame->subframes[ch].type == 32) {
#line 911
      goto case_32;
    }
#line 904
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 905
    output_subframe_constant___1(ctx, ch);
    }
    }
#line 906
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 907
    output_subframe_verbatim___1(ctx, ch);
    }
    }
#line 908
    goto switch_break;
    case_8: /* CIL Label */ 
    {
    {
#line 909
    output_subframe_fixed___1(ctx, ch);
    }
    }
#line 910
    goto switch_break;
    case_32: /* CIL Label */ 
    {
    {
#line 911
    output_subframe_lpc___1(ctx, ch);
    }
    }
#line 912
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 895
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_footer___1(FlacEncodeContext *ctx ) 
{ 
  uint16_t crc ;
  uint32_t tmp ;

  {
  {
  {
#line 921
  bitwriter_flush(ctx->bw);
  }
  {
#line 922
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 922
  crc = calc_crc16((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 923
  bitwriter_writebits(ctx->bw, 16, (uint32_t )crc);
  }
  {
#line 924
  bitwriter_flush(ctx->bw);
  }
  }
#line 925
  return;
}
}
#line 36 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v1___1(int16_t *samples , int channels , int block_size ,
                               int *frames , int *sizes ) 
{ 
  int i ;
  int ch ;
  int j ;
  int n ;
  int64_t res[8] ;
  int layout[8] ;
  int16_t *sptr ;
  int16_t *sptr0 ;
  int16_t *sptr1 ;
  int16_t *sptr2 ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
#line 41
  n = block_size >> 3;
#line 47
  i = 0;
  {
  {
#line 47
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 8)) {
#line 47
      goto while_break;
    }
#line 48
    sptr = samples + (i * n) * channels;
#line 49
    res[i] = (int64_t )0;
#line 50
    ch = 0;
    {
    {
#line 50
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (ch < channels)) {
#line 50
        goto while_break___0;
      }
#line 51
      sptr0 = sptr + (2 * channels + ch);
#line 52
      sptr1 = sptr0 - channels;
#line 53
      sptr2 = sptr1 - channels;
#line 54
      j = 2;
      {
      {
#line 54
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (j < n)) {
#line 54
          goto while_break___1;
        }
        {
        {
#line 55
        tmp = abs(((int )*sptr0 - 2 * (int )*sptr1) + (int )*sptr2);
        }
#line 55
        res[i] += (int64_t )tmp;
#line 56
        sptr0 += channels;
#line 57
        sptr1 += channels;
#line 58
        sptr2 += channels;
#line 54
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 50
      ch ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    res[i] /= (int64_t )channels;
#line 62
    (res[i]) ++;
#line 47
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  memset((void *)(layout), 0, (size_t )(8UL * sizeof(int )));
  }
#line 67
  layout[0] = 1;
#line 68
  i = 0;
  }
  {
  {
#line 68
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 68
    if (! (i < 7)) {
#line 68
      goto while_break___2;
    }
    {
    {
#line 69
    tmp___0 = abs((int )(res[i] - res[i + 1]));
    }
    }
#line 69
    if ((int64_t )(tmp___0 * 200) / res[i] > 100L) {
#line 70
      layout[i + 1] = 1;
    }
#line 68
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  *(frames + 0) = 0;
  {
#line 76
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 77
  i = 0;
  }
  {
  {
#line 77
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 77
    if (! (i < 8)) {
#line 77
      goto while_break___3;
    }
#line 78
    if (layout[i]) {
#line 79
      (*(frames + 0)) ++;
    }
#line 81
    *(sizes + (*(frames + 0) - 1)) += n;
#line 77
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v2___1(FlakeContext *s , int16_t *samples , int *frames ,
                               int *sizes ) 
{ 
  int fsizes[4][8] ;
  int layout[8] ;
  int i ;
  int j ;
  int n ;
  int ch ;
  FlacEncodeContext *ctx ;
  int levels ;
  int bs ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 91
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 92
  ch = ctx->channels;
#line 95
  i = 0;
  {
  {
#line 95
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 4)) {
#line 95
      goto while_break;
    }
#line 97
    levels = 1 << i;
#line 98
    s->params.block_size /= levels;
#line 99
    bs = s->params.block_size;
#line 100
    j = 0;
    {
    {
#line 100
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < levels)) {
#line 100
        goto while_break___0;
      }
      {
      {
#line 101
      fsizes[i][j] = encode_frame(s, (uint8_t *)((void *)0), samples + (bs * j) * ch);
      }
#line 100
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    s->params.block_size *= levels;
#line 95
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = 0;
  {
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i < 8)) {
#line 107
      goto while_break___1;
    }
#line 107
    layout[i] = 1;
#line 107
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 109
  if (fsizes[2][0] < fsizes[3][0] + fsizes[3][1]) {
#line 110
    layout[1] = 0;
  }
#line 112
  if (fsizes[2][1] < fsizes[3][2] + fsizes[3][3]) {
#line 113
    layout[3] = 0;
  }
#line 115
  if (fsizes[2][2] < fsizes[3][4] + fsizes[3][5]) {
#line 116
    layout[5] = 0;
  }
#line 118
  if (fsizes[2][3] < fsizes[3][6] + fsizes[3][7]) {
#line 119
    layout[7] = 0;
  }
#line 122
  if (layout[1] == 0) {
#line 122
    if (layout[3] == 0) {
#line 123
      if (fsizes[1][0] < fsizes[2][0] + fsizes[2][1]) {
#line 124
        layout[2] = 0;
      }
    }
  }
#line 127
  if (layout[5] == 0) {
#line 127
    if (layout[7] == 0) {
#line 128
      if (fsizes[1][1] < fsizes[2][2] + fsizes[2][3]) {
#line 129
        layout[6] = 0;
      }
    }
  }
#line 133
  if (layout[2] == 0) {
#line 133
    if (layout[6] == 0) {
#line 134
      if (fsizes[0][0] < fsizes[1][0] + fsizes[1][1]) {
#line 135
        layout[4] = 0;
      }
    }
  }
  {
#line 140
  n = s->params.block_size >> 3;
#line 141
  *(frames + 0) = 0;
  {
#line 142
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 143
  i = 0;
  }
  {
  {
#line 143
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < 8)) {
#line 143
      goto while_break___2;
    }
#line 144
    if (layout[i]) {
#line 145
      (*(frames + 0)) ++;
    }
#line 147
    *(sizes + (*(frames + 0) - 1)) += n;
#line 143
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 28 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_verbatim___2(int32_t *res , int32_t *smp , int n ) 
{ 


  {
  {
  {
#line 31
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 32
  return;
}
}
#line 34 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_fixed___2(int32_t *res , int32_t *smp , int n , int order ) 
{ 
  int i ;

  {
  {
#line 40
  if (order == 0) {
#line 40
    goto case_0;
  }
#line 43
  if (order == 1) {
#line 43
    goto case_1;
  }
#line 49
  if (order == 2) {
#line 49
    goto case_2;
  }
#line 56
  if (order == 3) {
#line 56
    goto case_3;
  }
#line 64
  if (order == 4) {
#line 64
    goto case_4;
  }
#line 73
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 41
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)smp, (size_t )((unsigned long )n * sizeof(int32_t )));
  }
  }
#line 42
  return;
  case_1: /* CIL Label */ 
#line 44
  *(res + 0) = *(smp + 0);
#line 45
  i = 1;
  {
  {
#line 45
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < n)) {
#line 45
      goto while_break;
    }
#line 46
    *(res + i) = *(smp + i) - *(smp + (i - 1));
#line 45
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
  case_2: /* CIL Label */ 
#line 50
  *(res + 0) = *(smp + 0);
#line 51
  *(res + 1) = *(smp + 1);
#line 52
  i = 2;
  {
  {
#line 52
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 52
    if (! (i < n)) {
#line 52
      goto while_break___0;
    }
#line 53
    *(res + i) = (*(smp + i) - 2 * *(smp + (i - 1))) + *(smp + (i - 2));
#line 52
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 55
  return;
  case_3: /* CIL Label */ 
#line 57
  *(res + 0) = *(smp + 0);
#line 58
  *(res + 1) = *(smp + 1);
#line 59
  *(res + 2) = *(smp + 2);
#line 60
  i = 3;
  {
  {
#line 60
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! (i < n)) {
#line 60
      goto while_break___1;
    }
#line 61
    *(res + i) = ((*(smp + i) - 3 * *(smp + (i - 1))) + 3 * *(smp + (i - 2))) - *(smp + (i - 3));
#line 60
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 63
  return;
  case_4: /* CIL Label */ 
#line 65
  *(res + 0) = *(smp + 0);
#line 66
  *(res + 1) = *(smp + 1);
#line 67
  *(res + 2) = *(smp + 2);
#line 68
  *(res + 3) = *(smp + 3);
#line 69
  i = 4;
  {
  {
#line 69
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 69
    if (! (i < n)) {
#line 69
      goto while_break___2;
    }
#line 70
    *(res + i) = (((*(smp + i) - 4 * *(smp + (i - 1))) + 6 * *(smp + (i - 2))) - 4 * *(smp + (i - 3))) + *(smp + (i - 4));
#line 69
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 72
  return;
  switch_default: /* CIL Label */ 
#line 73
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/optimize.c"
static void encode_residual_lpc___2(int32_t *res , int32_t *smp , int n , int order ,
                                    int32_t *coefs , int shift ) 
{ 
  int i ;
  int32_t pred ;

  {
#line 84
  i = 0;
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < order)) {
#line 84
      goto while_break;
    }
#line 85
    *(res + i) = *(smp + i);
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  i = order;
  {
  {
#line 87
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < n)) {
#line 87
      goto while_break___0;
    }
#line 88
    pred = 0;
    {
#line 92
    if (order == 32) {
#line 92
      goto case_32;
    }
#line 93
    if (order == 31) {
#line 93
      goto case_31;
    }
#line 94
    if (order == 30) {
#line 94
      goto case_30;
    }
#line 95
    if (order == 29) {
#line 95
      goto case_29;
    }
#line 96
    if (order == 28) {
#line 96
      goto case_28;
    }
#line 97
    if (order == 27) {
#line 97
      goto case_27;
    }
#line 98
    if (order == 26) {
#line 98
      goto case_26;
    }
#line 99
    if (order == 25) {
#line 99
      goto case_25;
    }
#line 100
    if (order == 24) {
#line 100
      goto case_24;
    }
#line 101
    if (order == 23) {
#line 101
      goto case_23;
    }
#line 102
    if (order == 22) {
#line 102
      goto case_22;
    }
#line 103
    if (order == 21) {
#line 103
      goto case_21;
    }
#line 104
    if (order == 20) {
#line 104
      goto case_20;
    }
#line 105
    if (order == 19) {
#line 105
      goto case_19;
    }
#line 106
    if (order == 18) {
#line 106
      goto case_18;
    }
#line 107
    if (order == 17) {
#line 107
      goto case_17;
    }
#line 108
    if (order == 16) {
#line 108
      goto case_16;
    }
#line 109
    if (order == 15) {
#line 109
      goto case_15;
    }
#line 110
    if (order == 14) {
#line 110
      goto case_14;
    }
#line 111
    if (order == 13) {
#line 111
      goto case_13;
    }
#line 112
    if (order == 12) {
#line 112
      goto case_12;
    }
#line 113
    if (order == 11) {
#line 113
      goto case_11;
    }
#line 114
    if (order == 10) {
#line 114
      goto case_10;
    }
#line 115
    if (order == 9) {
#line 115
      goto case_9;
    }
#line 116
    if (order == 8) {
#line 116
      goto case_8;
    }
#line 117
    if (order == 7) {
#line 117
      goto case_7;
    }
#line 118
    if (order == 6) {
#line 118
      goto case_6;
    }
#line 119
    if (order == 5) {
#line 119
      goto case_5;
    }
#line 120
    if (order == 4) {
#line 120
      goto case_4;
    }
#line 121
    if (order == 3) {
#line 121
      goto case_3;
    }
#line 122
    if (order == 2) {
#line 122
      goto case_2;
    }
#line 123
    if (order == 1) {
#line 123
      goto case_1;
    }
#line 125
    goto switch_default;
    case_32: /* CIL Label */ 
#line 92
    pred += *(coefs + 31) * *(smp + (i - 32));
    case_31: /* CIL Label */ 
#line 93
    pred += *(coefs + 30) * *(smp + (i - 31));
    case_30: /* CIL Label */ 
#line 94
    pred += *(coefs + 29) * *(smp + (i - 30));
    case_29: /* CIL Label */ 
#line 95
    pred += *(coefs + 28) * *(smp + (i - 29));
    case_28: /* CIL Label */ 
#line 96
    pred += *(coefs + 27) * *(smp + (i - 28));
    case_27: /* CIL Label */ 
#line 97
    pred += *(coefs + 26) * *(smp + (i - 27));
    case_26: /* CIL Label */ 
#line 98
    pred += *(coefs + 25) * *(smp + (i - 26));
    case_25: /* CIL Label */ 
#line 99
    pred += *(coefs + 24) * *(smp + (i - 25));
    case_24: /* CIL Label */ 
#line 100
    pred += *(coefs + 23) * *(smp + (i - 24));
    case_23: /* CIL Label */ 
#line 101
    pred += *(coefs + 22) * *(smp + (i - 23));
    case_22: /* CIL Label */ 
#line 102
    pred += *(coefs + 21) * *(smp + (i - 22));
    case_21: /* CIL Label */ 
#line 103
    pred += *(coefs + 20) * *(smp + (i - 21));
    case_20: /* CIL Label */ 
#line 104
    pred += *(coefs + 19) * *(smp + (i - 20));
    case_19: /* CIL Label */ 
#line 105
    pred += *(coefs + 18) * *(smp + (i - 19));
    case_18: /* CIL Label */ 
#line 106
    pred += *(coefs + 17) * *(smp + (i - 18));
    case_17: /* CIL Label */ 
#line 107
    pred += *(coefs + 16) * *(smp + (i - 17));
    case_16: /* CIL Label */ 
#line 108
    pred += *(coefs + 15) * *(smp + (i - 16));
    case_15: /* CIL Label */ 
#line 109
    pred += *(coefs + 14) * *(smp + (i - 15));
    case_14: /* CIL Label */ 
#line 110
    pred += *(coefs + 13) * *(smp + (i - 14));
    case_13: /* CIL Label */ 
#line 111
    pred += *(coefs + 12) * *(smp + (i - 13));
    case_12: /* CIL Label */ 
#line 112
    pred += *(coefs + 11) * *(smp + (i - 12));
    case_11: /* CIL Label */ 
#line 113
    pred += *(coefs + 10) * *(smp + (i - 11));
    case_10: /* CIL Label */ 
#line 114
    pred += *(coefs + 9) * *(smp + (i - 10));
    case_9: /* CIL Label */ 
#line 115
    pred += *(coefs + 8) * *(smp + (i - 9));
    case_8: /* CIL Label */ 
#line 116
    pred += *(coefs + 7) * *(smp + (i - 8));
    case_7: /* CIL Label */ 
#line 117
    pred += *(coefs + 6) * *(smp + (i - 7));
    case_6: /* CIL Label */ 
#line 118
    pred += *(coefs + 5) * *(smp + (i - 6));
    case_5: /* CIL Label */ 
#line 119
    pred += *(coefs + 4) * *(smp + (i - 5));
    case_4: /* CIL Label */ 
#line 120
    pred += *(coefs + 3) * *(smp + (i - 4));
    case_3: /* CIL Label */ 
#line 121
    pred += *(coefs + 2) * *(smp + (i - 3));
    case_2: /* CIL Label */ 
#line 122
    pred += *(coefs + 1) * *(smp + (i - 2));
    case_1: /* CIL Label */ 
#line 123
    pred += *(coefs + 0) * *(smp + (i - 1));
    switch_default: /* CIL Label */ 
#line 125
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 127
    *(res + i) = *(smp + i) - (pred >> shift);
#line 87
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 54 "/home/wslee/benchmarks/sound/flake-0.11/libflake/md5.c"
static void const   *body___2(MD5Context *ctx , void const   *data , uint32_t size ) 
{ 
  uint8_t const   *ptr ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;

  {
#line 61
  ptr = (uint8_t const   *)data;
#line 63
  a = ctx->a;
#line 64
  b = ctx->b;
#line 65
  c = ctx->c;
#line 66
  d = ctx->d;
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 69
    saved_a = a;
#line 70
    saved_b = b;
#line 71
    saved_c = c;
#line 72
    saved_d = d;
#line 75
    tmp = (((uint32_t )*(ptr + 0) | ((uint32_t )*(ptr + 1) << 8)) | ((uint32_t )*(ptr + 2) << 16)) | ((uint32_t )*(ptr + 3) << 24);
#line 75
    ctx->block[0] = tmp;
#line 75
    a += ((d ^ (b & (c ^ d))) + tmp) + 3614090360U;
#line 75
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 75
    a += b;
#line 76
    tmp___0 = (((uint32_t )*(ptr + 4) | ((uint32_t )*(ptr + 5) << 8)) | ((uint32_t )*(ptr + 6) << 16)) | ((uint32_t )*(ptr + 7) << 24);
#line 76
    ctx->block[1] = tmp___0;
#line 76
    d += ((c ^ (a & (b ^ c))) + tmp___0) + 3905402710U;
#line 76
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 76
    d += a;
#line 77
    tmp___1 = (((uint32_t )*(ptr + 8) | ((uint32_t )*(ptr + 9) << 8)) | ((uint32_t )*(ptr + 10) << 16)) | ((uint32_t )*(ptr + 11) << 24);
#line 77
    ctx->block[2] = tmp___1;
#line 77
    c += ((b ^ (d & (a ^ b))) + tmp___1) + 606105819U;
#line 77
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 77
    c += d;
#line 78
    tmp___2 = (((uint32_t )*(ptr + 12) | ((uint32_t )*(ptr + 13) << 8)) | ((uint32_t )*(ptr + 14) << 16)) | ((uint32_t )*(ptr + 15) << 24);
#line 78
    ctx->block[3] = tmp___2;
#line 78
    b += ((a ^ (c & (d ^ a))) + tmp___2) + 3250441966U;
#line 78
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 78
    b += c;
#line 79
    tmp___3 = (((uint32_t )*(ptr + 16) | ((uint32_t )*(ptr + 17) << 8)) | ((uint32_t )*(ptr + 18) << 16)) | ((uint32_t )*(ptr + 19) << 24);
#line 79
    ctx->block[4] = tmp___3;
#line 79
    a += ((d ^ (b & (c ^ d))) + tmp___3) + 4118548399U;
#line 79
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 79
    a += b;
#line 80
    tmp___4 = (((uint32_t )*(ptr + 20) | ((uint32_t )*(ptr + 21) << 8)) | ((uint32_t )*(ptr + 22) << 16)) | ((uint32_t )*(ptr + 23) << 24);
#line 80
    ctx->block[5] = tmp___4;
#line 80
    d += ((c ^ (a & (b ^ c))) + tmp___4) + 1200080426U;
#line 80
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 80
    d += a;
#line 81
    tmp___5 = (((uint32_t )*(ptr + 24) | ((uint32_t )*(ptr + 25) << 8)) | ((uint32_t )*(ptr + 26) << 16)) | ((uint32_t )*(ptr + 27) << 24);
#line 81
    ctx->block[6] = tmp___5;
#line 81
    c += ((b ^ (d & (a ^ b))) + tmp___5) + 2821735955U;
#line 81
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 81
    c += d;
#line 82
    tmp___6 = (((uint32_t )*(ptr + 28) | ((uint32_t )*(ptr + 29) << 8)) | ((uint32_t )*(ptr + 30) << 16)) | ((uint32_t )*(ptr + 31) << 24);
#line 82
    ctx->block[7] = tmp___6;
#line 82
    b += ((a ^ (c & (d ^ a))) + tmp___6) + 4249261313U;
#line 82
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 82
    b += c;
#line 83
    tmp___7 = (((uint32_t )*(ptr + 32) | ((uint32_t )*(ptr + 33) << 8)) | ((uint32_t )*(ptr + 34) << 16)) | ((uint32_t )*(ptr + 35) << 24);
#line 83
    ctx->block[8] = tmp___7;
#line 83
    a += ((d ^ (b & (c ^ d))) + tmp___7) + 1770035416U;
#line 83
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 83
    a += b;
#line 84
    tmp___8 = (((uint32_t )*(ptr + 36) | ((uint32_t )*(ptr + 37) << 8)) | ((uint32_t )*(ptr + 38) << 16)) | ((uint32_t )*(ptr + 39) << 24);
#line 84
    ctx->block[9] = tmp___8;
#line 84
    d += ((c ^ (a & (b ^ c))) + tmp___8) + 2336552879U;
#line 84
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 84
    d += a;
#line 85
    tmp___9 = (((uint32_t )*(ptr + 40) | ((uint32_t )*(ptr + 41) << 8)) | ((uint32_t )*(ptr + 42) << 16)) | ((uint32_t )*(ptr + 43) << 24);
#line 85
    ctx->block[10] = tmp___9;
#line 85
    c += ((b ^ (d & (a ^ b))) + tmp___9) + 4294925233U;
#line 85
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 85
    c += d;
#line 86
    tmp___10 = (((uint32_t )*(ptr + 44) | ((uint32_t )*(ptr + 45) << 8)) | ((uint32_t )*(ptr + 46) << 16)) | ((uint32_t )*(ptr + 47) << 24);
#line 86
    ctx->block[11] = tmp___10;
#line 86
    b += ((a ^ (c & (d ^ a))) + tmp___10) + 2304563134U;
#line 86
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 86
    b += c;
#line 87
    tmp___11 = (((uint32_t )*(ptr + 48) | ((uint32_t )*(ptr + 49) << 8)) | ((uint32_t )*(ptr + 50) << 16)) | ((uint32_t )*(ptr + 51) << 24);
#line 87
    ctx->block[12] = tmp___11;
#line 87
    a += ((d ^ (b & (c ^ d))) + tmp___11) + 1804603682U;
#line 87
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 87
    a += b;
#line 88
    tmp___12 = (((uint32_t )*(ptr + 52) | ((uint32_t )*(ptr + 53) << 8)) | ((uint32_t )*(ptr + 54) << 16)) | ((uint32_t )*(ptr + 55) << 24);
#line 88
    ctx->block[13] = tmp___12;
#line 88
    d += ((c ^ (a & (b ^ c))) + tmp___12) + 4254626195U;
#line 88
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 88
    d += a;
#line 89
    tmp___13 = (((uint32_t )*(ptr + 56) | ((uint32_t )*(ptr + 57) << 8)) | ((uint32_t )*(ptr + 58) << 16)) | ((uint32_t )*(ptr + 59) << 24);
#line 89
    ctx->block[14] = tmp___13;
#line 89
    c += ((b ^ (d & (a ^ b))) + tmp___13) + 2792965006U;
#line 89
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 89
    c += d;
#line 90
    tmp___14 = (((uint32_t )*(ptr + 60) | ((uint32_t )*(ptr + 61) << 8)) | ((uint32_t )*(ptr + 62) << 16)) | ((uint32_t )*(ptr + 63) << 24);
#line 90
    ctx->block[15] = tmp___14;
#line 90
    b += ((a ^ (c & (d ^ a))) + tmp___14) + 1236535329U;
#line 90
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 90
    b += c;
#line 93
    a += ((c ^ (d & (b ^ c))) + ctx->block[1]) + 4129170786U;
#line 93
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 93
    a += b;
#line 94
    d += ((b ^ (c & (a ^ b))) + ctx->block[6]) + 3225465664U;
#line 94
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 94
    d += a;
#line 95
    c += ((a ^ (b & (d ^ a))) + ctx->block[11]) + 643717713U;
#line 95
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 95
    c += d;
#line 96
    b += ((d ^ (a & (c ^ d))) + ctx->block[0]) + 3921069994U;
#line 96
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 96
    b += c;
#line 97
    a += ((c ^ (d & (b ^ c))) + ctx->block[5]) + 3593408605U;
#line 97
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 97
    a += b;
#line 98
    d += ((b ^ (c & (a ^ b))) + ctx->block[10]) + 38016083U;
#line 98
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 98
    d += a;
#line 99
    c += ((a ^ (b & (d ^ a))) + ctx->block[15]) + 3634488961U;
#line 99
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 99
    c += d;
#line 100
    b += ((d ^ (a & (c ^ d))) + ctx->block[4]) + 3889429448U;
#line 100
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 100
    b += c;
#line 101
    a += ((c ^ (d & (b ^ c))) + ctx->block[9]) + 568446438U;
#line 101
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 101
    a += b;
#line 102
    d += ((b ^ (c & (a ^ b))) + ctx->block[14]) + 3275163606U;
#line 102
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 102
    d += a;
#line 103
    c += ((a ^ (b & (d ^ a))) + ctx->block[3]) + 4107603335U;
#line 103
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 103
    c += d;
#line 104
    b += ((d ^ (a & (c ^ d))) + ctx->block[8]) + 1163531501U;
#line 104
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 104
    b += c;
#line 105
    a += ((c ^ (d & (b ^ c))) + ctx->block[13]) + 2850285829U;
#line 105
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 105
    a += b;
#line 106
    d += ((b ^ (c & (a ^ b))) + ctx->block[2]) + 4243563512U;
#line 106
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 106
    d += a;
#line 107
    c += ((a ^ (b & (d ^ a))) + ctx->block[7]) + 1735328473U;
#line 107
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 107
    c += d;
#line 108
    b += ((d ^ (a & (c ^ d))) + ctx->block[12]) + 2368359562U;
#line 108
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 108
    b += c;
#line 111
    a += (((b ^ c) ^ d) + ctx->block[5]) + 4294588738U;
#line 111
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 111
    a += b;
#line 112
    d += (((a ^ b) ^ c) + ctx->block[8]) + 2272392833U;
#line 112
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 112
    d += a;
#line 113
    c += (((d ^ a) ^ b) + ctx->block[11]) + 1839030562U;
#line 113
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 113
    c += d;
#line 114
    b += (((c ^ d) ^ a) + ctx->block[14]) + 4259657740U;
#line 114
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 114
    b += c;
#line 115
    a += (((b ^ c) ^ d) + ctx->block[1]) + 2763975236U;
#line 115
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 115
    a += b;
#line 116
    d += (((a ^ b) ^ c) + ctx->block[4]) + 1272893353U;
#line 116
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 116
    d += a;
#line 117
    c += (((d ^ a) ^ b) + ctx->block[7]) + 4139469664U;
#line 117
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 117
    c += d;
#line 118
    b += (((c ^ d) ^ a) + ctx->block[10]) + 3200236656U;
#line 118
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 118
    b += c;
#line 119
    a += (((b ^ c) ^ d) + ctx->block[13]) + 681279174U;
#line 119
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 119
    a += b;
#line 120
    d += (((a ^ b) ^ c) + ctx->block[0]) + 3936430074U;
#line 120
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 120
    d += a;
#line 121
    c += (((d ^ a) ^ b) + ctx->block[3]) + 3572445317U;
#line 121
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 121
    c += d;
#line 122
    b += (((c ^ d) ^ a) + ctx->block[6]) + 76029189U;
#line 122
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 122
    b += c;
#line 123
    a += (((b ^ c) ^ d) + ctx->block[9]) + 3654602809U;
#line 123
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 123
    a += b;
#line 124
    d += (((a ^ b) ^ c) + ctx->block[12]) + 3873151461U;
#line 124
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 124
    d += a;
#line 125
    c += (((d ^ a) ^ b) + ctx->block[15]) + 530742520U;
#line 125
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 125
    c += d;
#line 126
    b += (((c ^ d) ^ a) + ctx->block[2]) + 3299628645U;
#line 126
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 126
    b += c;
#line 129
    a += ((c ^ (b | ~ d)) + ctx->block[0]) + 4096336452U;
#line 129
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 129
    a += b;
#line 130
    d += ((b ^ (a | ~ c)) + ctx->block[7]) + 1126891415U;
#line 130
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 130
    d += a;
#line 131
    c += ((a ^ (d | ~ b)) + ctx->block[14]) + 2878612391U;
#line 131
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 131
    c += d;
#line 132
    b += ((d ^ (c | ~ a)) + ctx->block[5]) + 4237533241U;
#line 132
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 132
    b += c;
#line 133
    a += ((c ^ (b | ~ d)) + ctx->block[12]) + 1700485571U;
#line 133
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 133
    a += b;
#line 134
    d += ((b ^ (a | ~ c)) + ctx->block[3]) + 2399980690U;
#line 134
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 134
    d += a;
#line 135
    c += ((a ^ (d | ~ b)) + ctx->block[10]) + 4293915773U;
#line 135
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 135
    c += d;
#line 136
    b += ((d ^ (c | ~ a)) + ctx->block[1]) + 2240044497U;
#line 136
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 136
    b += c;
#line 137
    a += ((c ^ (b | ~ d)) + ctx->block[8]) + 1873313359U;
#line 137
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 137
    a += b;
#line 138
    d += ((b ^ (a | ~ c)) + ctx->block[15]) + 4264355552U;
#line 138
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 138
    d += a;
#line 139
    c += ((a ^ (d | ~ b)) + ctx->block[6]) + 2734768916U;
#line 139
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 139
    c += d;
#line 140
    b += ((d ^ (c | ~ a)) + ctx->block[13]) + 1309151649U;
#line 140
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 140
    b += c;
#line 141
    a += ((c ^ (b | ~ d)) + ctx->block[4]) + 4149444226U;
#line 141
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 141
    a += b;
#line 142
    d += ((b ^ (a | ~ c)) + ctx->block[11]) + 3174756917U;
#line 142
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 142
    d += a;
#line 143
    c += ((a ^ (d | ~ b)) + ctx->block[2]) + 718787259U;
#line 143
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 143
    c += d;
#line 144
    b += ((d ^ (c | ~ a)) + ctx->block[9]) + 3951481745U;
#line 144
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 144
    b += c;
#line 146
    a += saved_a;
#line 147
    b += saved_b;
#line 148
    c += saved_c;
#line 149
    d += saved_d;
#line 151
    ptr += 64;
#line 68
    size -= 64U;
#line 68
    if (! size) {
#line 68
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  ctx->a = a;
#line 155
  ctx->b = b;
#line 156
  ctx->c = c;
#line 157
  ctx->d = d;
#line 159
  return ((void const   *)ptr);
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_autocorr___2(int32_t const   *data , int len , int lag , double *autoc ) 
{ 
  int i ;
  int j ;
  double *data1 ;
  double temp ;
  double temp2 ;
  void *tmp ;

  {
  {
  {
#line 53
  tmp = malloc((size_t )((unsigned long )(len + 16) * sizeof(double )));
  }
#line 53
  data1 = (double *)tmp;
  {
#line 54
  apply_welch_window(data, len, data1);
  }
#line 55
  *(data1 + len) = (double )0;
#line 57
  i = 0;
  }
  {
  {
#line 57
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= lag)) {
#line 57
      goto while_break;
    }
#line 58
    temp = 1.0;
#line 59
    temp2 = 1.0;
#line 60
    j = 0;
    {
    {
#line 60
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (j <= lag - i)) {
#line 60
        goto while_break___0;
      }
#line 61
      temp += *(data1 + (j + i)) * *(data1 + j);
#line 60
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    j = lag + 1;
    {
    {
#line 63
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 63
      if (! (j <= len - 1)) {
#line 63
        goto while_break___1;
      }
#line 64
      temp += *(data1 + j) * *(data1 + (j - i));
#line 65
      temp2 += *(data1 + (j + 1)) * *(data1 + ((j + 1) - i));
#line 63
      j += 2;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 67
    *(autoc + i) = temp + temp2;
#line 57
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 70
  free((void *)data1);
  }
  }
#line 71
  return;
}
}
#line 77 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void compute_lpc_coefs___2(double const   *autoc , int max_order , double *ref ,
                                  double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  int i2 ;
  double r ;
  double err ;
  double tmp ;
  double lpc_tmp[32] ;
  void *__cil_tmp12 ;

  {
#line 85
  i = 0;
  {
  {
#line 85
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < max_order)) {
#line 85
      goto while_break;
    }
#line 85
    lpc_tmp[i] = (double )0;
#line 85
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  err = 1.0;
#line 87
  if (autoc) {
#line 88
    err = (double )*(autoc + 0);
  }
#line 91
  i = 0;
  {
  {
#line 91
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < max_order)) {
#line 91
      goto while_break___0;
    }
#line 92
    if (ref) {
#line 93
      r = *(ref + i);
    } else {
#line 95
      r = (double )(- *(autoc + (i + 1)));
#line 96
      j = 0;
      {
      {
#line 96
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 96
        if (! (j < i)) {
#line 96
          goto while_break___1;
        }
#line 97
        r -= lpc_tmp[j] * (double )*(autoc + (i - j));
#line 96
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 99
      r /= err;
#line 100
      err *= 1.0 - r * r;
    }
#line 103
    i2 = i >> 1;
#line 104
    lpc_tmp[i] = r;
#line 105
    j = 0;
    {
    {
#line 105
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 105
      if (! (j < i2)) {
#line 105
        goto while_break___2;
      }
#line 106
      tmp = lpc_tmp[j];
#line 107
      lpc_tmp[j] += r * lpc_tmp[(i - 1) - j];
#line 108
      lpc_tmp[(i - 1) - j] += r * tmp;
#line 105
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 110
    if (i & 1) {
#line 111
      lpc_tmp[j] += lpc_tmp[j] * r;
    }
#line 114
    j = 0;
    {
    {
#line 114
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 114
      if (! (j <= i)) {
#line 114
        goto while_break___3;
      }
#line 115
      (*(lpc + i))[j] = - lpc_tmp[j];
#line 114
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 91
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 126 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static int compute_lpc_coefs_est___2(double const   *autoc , int max_order , double (*lpc)[32] ) 
{ 
  int i ;
  int j ;
  double error ;
  double gen[2][32] ;
  double ref[32] ;
  int order_est ;
  double tmp ;
  double tmp___0 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;

  {
#line 137
  i = 0;
  {
  {
#line 137
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < max_order)) {
#line 137
      goto while_break;
    }
#line 137
    tmp = (double )*(autoc + (i + 1));
#line 137
    gen[1][i] = tmp;
#line 137
    gen[0][i] = tmp;
#line 137
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  error = (double )*(autoc + 0);
#line 139
  ref[0] = - gen[1][0] / error;
#line 140
  error += gen[1][0] * ref[0];
#line 141
  i = 1;
  {
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (i < max_order)) {
#line 141
      goto while_break___0;
    }
#line 142
    j = 0;
    {
    {
#line 142
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 142
      if (! (j < max_order - i)) {
#line 142
        goto while_break___1;
      }
#line 143
      gen[1][j] = gen[1][j + 1] + ref[i - 1] * gen[0][j];
#line 144
      gen[0][j] = gen[1][j + 1] * ref[i - 1] + gen[0][j];
#line 142
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 146
    ref[i] = - gen[1][0] / error;
#line 147
    error += gen[1][0] * ref[i];
#line 141
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  order_est = 1;
#line 152
  i = max_order - 1;
  {
  {
#line 152
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 152
    if (! (i >= 0)) {
#line 152
      goto while_break___2;
    }
    {
    {
#line 153
    tmp___0 = fabs(ref[i]);
    }
    }
#line 153
    if (tmp___0 > 0.10) {
#line 154
      order_est = i + 1;
#line 155
      goto while_break___2;
    }
#line 152
    i --;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 160
  compute_lpc_coefs___2((double const   *)((void *)0), order_est, ref, lpc);
  }
  }
#line 162
  return (order_est);
}
}
#line 168 "/home/wslee/benchmarks/sound/flake-0.11/libflake/lpc.c"
static void quantize_lpc_coefs___2(double *lpc_in , int order , int precision , int32_t *lpc_out ,
                                   int *shift ) 
{ 
  int i ;
  double d ;
  double cmax ;
  double error ;
  int32_t qmax ;
  int sh ;
  int q ;
  double scale ;

  {
#line 178
  qmax = (1 << (precision - 1)) - 1;
#line 181
  cmax = 0.0;
#line 182
  i = 0;
  {
  {
#line 182
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < order)) {
#line 182
      goto while_break;
    }
    {
    {
#line 183
    d = fabs(*(lpc_in + i));
    }
    }
#line 184
    if (d > cmax) {
#line 185
      cmax = d;
    }
#line 182
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (cmax * (double )(1 << 15) < 1.0) {
    {
#line 189
    *shift = 0;
    {
#line 190
    memset((void *)lpc_out, 0, (size_t )(sizeof(int32_t ) * (unsigned long )order));
    }
    }
#line 191
    return;
  }
#line 195
  sh = 15;
  {
  {
#line 196
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 196
    if (cmax * (double )(1 << sh) > (double )qmax) {
#line 196
      if (! (sh > 0)) {
#line 196
        goto while_break___0;
      }
    } else {
#line 196
      goto while_break___0;
    }
#line 197
    sh --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  if (sh == 0) {
#line 202
    if (cmax > (double )qmax) {
#line 203
      scale = (double )qmax / cmax;
#line 204
      i = 0;
      {
      {
#line 204
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i < order)) {
#line 204
          goto while_break___1;
        }
#line 205
        *(lpc_in + i) *= scale;
#line 204
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 210
  error = (double )0;
#line 211
  i = 0;
  {
  {
#line 211
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 211
    if (! (i < order)) {
#line 211
      goto while_break___2;
    }
#line 212
    error += *(lpc_in + i) * (double )(1 << sh);
#line 213
    q = (int )(error + 0.5);
#line 214
    if (q <= - qmax) {
#line 214
      q = - qmax + 1;
    }
#line 215
    if (q > qmax) {
#line 215
      q = qmax;
    }
#line 216
    error -= (double )q;
#line 217
    *(lpc_out + i) = q;
#line 211
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 219
  *shift = sh;
#line 220
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static void crc_init_table___2(uint16_t *table , int bits , int poly ) 
{ 
  int i ;
  int j ;
  int crc ;

  {
#line 29
  poly += 1 << bits;
#line 30
  i = 0;
  {
  {
#line 30
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 30
    if (! (i < 256)) {
#line 30
      goto while_break;
    }
#line 31
    crc = i;
#line 32
    j = 0;
    {
    {
#line 32
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 32
      if (! (j < bits)) {
#line 32
        goto while_break___0;
      }
#line 33
      if (crc & (1 << (bits - 1))) {
#line 34
        crc = (crc << 1) ^ poly;
      } else {
#line 36
        crc <<= 1;
      }
#line 32
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    *(table + i) = (uint16_t )(crc & ((1 << bits) - 1));
#line 30
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc8tab___2[256]  ;
#line 50 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t crc16tab___2[256]  ;
#line 59 "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c"
static uint16_t calc_crc___2(uint16_t const   *table , int bits , uint8_t const   *data ,
                             uint32_t len ) 
{ 
  uint16_t crc ;
  uint16_t v1 ;
  uint16_t v2 ;
  uint8_t const   *tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 64
  crc = (uint16_t )0;
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    tmp___0 = len;
#line 65
    len --;
#line 65
    if (! tmp___0) {
#line 65
      goto while_break;
    }
#line 66
    v1 = (uint16_t )(((int )crc << 8) & ((1 << bits) - 1));
#line 67
    tmp = data;
#line 67
    data ++;
#line 67
    v2 = (uint16_t )(((int )crc >> (bits - 8)) ^ (int )*tmp);
#line 68
    if (! ((int )v2 < 256)) {
      {
      {
#line 68
      __assert_fail("v2 < 256", "/home/wslee/benchmarks/sound/flake-0.11/libflake/crc.c",
                    68U, "calc_crc");
      }
      }
    }
#line 69
    crc = (uint16_t )((int )v1 ^ (int )*(table + v2));
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (crc);
}
}
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_samplerates___2[16]  = 
#line 33 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )8000,      (int const   )16000,      (int const   )22050,      (int const   )24000, 
        (int const   )32000,      (int const   )44100,      (int const   )48000,      (int const   )96000, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0};
#line 39 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_bitdepths___2[8]  = 
#line 39
  {      (int const   )0,      (int const   )8,      (int const   )12,      (int const   )0, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )0};
#line 43 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int const   flac_blocksizes___2[15]  = 
#line 43
  {      (int const   )0,      (int const   )192,      (int const   )576,      (int const   )1152, 
        (int const   )2304,      (int const   )4608,      (int const   )0,      (int const   )0, 
        (int const   )256,      (int const   )512,      (int const   )1024,      (int const   )2048, 
        (int const   )4096,      (int const   )8192,      (int const   )16384};
#line 55 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_streaminfo___2(FlacEncodeContext *ctx , uint8_t *streaminfo , int last ) 
{ 


  {
  {
  {
#line 58
  memset((void *)streaminfo, 0, (size_t )38);
  }
  {
#line 59
  bitwriter_init(ctx->bw, (void *)streaminfo, 38);
  }
  {
#line 62
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 63
  bitwriter_writebits(ctx->bw, 7, (uint32_t )0);
  }
  {
#line 64
  bitwriter_writebits(ctx->bw, 24, (uint32_t )34);
  }
  }
#line 66
  if (ctx->params.variable_block_size) {
    {
    {
#line 67
    bitwriter_writebits(ctx->bw, 16, (uint32_t )0);
    }
    }
  } else {
    {
    {
#line 69
    bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
    }
    }
  }
  {
  {
#line 71
  bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->params.block_size);
  }
  {
#line 72
  bitwriter_writebits(ctx->bw, 24, (uint32_t )0);
  }
  {
#line 73
  bitwriter_writebits(ctx->bw, 24, (uint32_t )ctx->max_frame_size);
  }
  {
#line 74
  bitwriter_writebits(ctx->bw, 20, (uint32_t )ctx->samplerate);
  }
  {
#line 75
  bitwriter_writebits(ctx->bw, 3, (uint32_t )(ctx->channels - 1));
  }
  {
#line 76
  bitwriter_writebits(ctx->bw, 5, (uint32_t )(ctx->bps - 1));
  }
  }
#line 79
  if (ctx->sample_count > 0U) {
    {
    {
#line 80
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 81
    bitwriter_writebits(ctx->bw, 32, ctx->sample_count);
    }
    }
  } else {
    {
    {
#line 83
    bitwriter_writebits(ctx->bw, 4, (uint32_t )0);
    }
    {
#line 84
    bitwriter_writebits(ctx->bw, 32, (uint32_t )0);
    }
    }
  }
#line 86
  return;
}
}
#line 91 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_padding___2(FlacEncodeContext *ctx , uint8_t *padding , int last ,
                             int padlen ) 
{ 


  {
  {
  {
#line 94
  bitwriter_init(ctx->bw, (void *)padding, 4);
  }
  {
#line 97
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 98
  bitwriter_writebits(ctx->bw, 7, (uint32_t )1);
  }
  {
#line 99
  bitwriter_writebits(ctx->bw, 24, (uint32_t )padlen);
  }
  }
#line 101
  return (padlen + 4);
}
}
#line 104 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static char const   *vendor_string___2  =    "Flake0.11";
#line 110 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_vorbis_comment___2(FlacEncodeContext *ctx , uint8_t *comment , int last ) 
{ 
  int vendor_len ;
  uint8_t vlen_le[4] ;
  size_t tmp ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 116
  tmp = strlen(vendor_string___2);
  }
#line 116
  vendor_len = (int )tmp;
  {
#line 117
  bitwriter_init(ctx->bw, (void *)comment, 4);
  }
  {
#line 120
  bitwriter_writebits(ctx->bw, 1, (uint32_t )last);
  }
  {
#line 121
  bitwriter_writebits(ctx->bw, 7, (uint32_t )4);
  }
  {
#line 122
  bitwriter_writebits(ctx->bw, 24, (uint32_t )(vendor_len + 8));
  }
#line 126
  vlen_le[0] = (uint8_t )(vendor_len & 255);
#line 127
  vlen_le[1] = (uint8_t )((vendor_len >> 8) & 255);
#line 128
  vlen_le[2] = (uint8_t )((vendor_len >> 16) & 255);
#line 129
  vlen_le[3] = (uint8_t )((vendor_len >> 24) & 255);
  {
#line 130
  memcpy((void */* __restrict  */)(comment + 4), (void const   */* __restrict  */)(vlen_le),
         (size_t )4);
  }
  {
#line 132
  memcpy((void */* __restrict  */)(comment + 8), (void const   */* __restrict  */)vendor_string___2,
         (size_t )vendor_len);
  }
  {
#line 134
  memset((void *)(comment + (vendor_len + 8)), 0, (size_t )4);
  }
  }
#line 136
  return (vendor_len + 12);
}
}
#line 142 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int write_headers___2(FlacEncodeContext *ctx , uint8_t *header ) 
{ 
  int header_size ;
  int last ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 147
  header_size = 0;
#line 148
  last = 0;
#line 151
  *(header + 0) = (uint8_t )102;
#line 152
  *(header + 1) = (uint8_t )76;
#line 153
  *(header + 2) = (uint8_t )97;
#line 154
  *(header + 3) = (uint8_t )67;
#line 155
  header_size += 4;
  {
#line 158
  write_streaminfo___2(ctx, header + header_size, last);
  }
#line 159
  header_size += 38;
  }
#line 162
  if (ctx->params.padding_size == 0) {
#line 162
    last = 1;
  }
  {
  {
#line 163
  tmp = write_vorbis_comment___2(ctx, header + header_size, last);
  }
#line 163
  header_size += tmp;
  }
#line 166
  if (ctx->params.padding_size > 0) {
    {
#line 167
    last = 1;
    {
#line 168
    tmp___0 = write_padding___2(ctx, header + header_size, last, ctx->params.padding_size);
    }
#line 168
    header_size += tmp___0;
    }
  }
#line 172
  return (header_size);
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int select_blocksize___2(int samplerate , int time_ms ) 
{ 
  int i ;
  int target ;
  int blocksize ;

  {
#line 184
  blocksize = (int )flac_blocksizes___2[1];
#line 185
  target = (samplerate * time_ms) / 1000;
#line 186
  i = 0;
  {
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 16)) {
#line 186
      goto while_break;
    }
#line 187
    if (target >= (int )flac_blocksizes___2[i]) {
#line 187
      if (flac_blocksizes___2[i] > (int const   )blocksize) {
#line 188
        blocksize = (int )flac_blocksizes___2[i];
      }
    }
#line 186
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (blocksize);
}
}
#line 533 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int init_frame___2(FlacEncodeContext *ctx ) 
{ 
  int i ;
  int ch ;
  FlacFrame *frame ;

  {
#line 539
  frame = & ctx->frame;
#line 541
  if (ctx->params.block_time_ms < 0) {
#line 542
    return (-1);
  }
#line 544
  if (ctx->params.block_size == 0) {
    {
    {
#line 545
    ctx->params.block_size = select_blocksize___2(ctx->samplerate, ctx->params.block_time_ms);
    }
    }
  }
#line 547
  if (ctx->params.block_size < 1) {
#line 549
    return (-1);
  } else
#line 547
  if (ctx->params.block_size > 65535) {
#line 549
    return (-1);
  }
#line 553
  if (ctx->channels == 2) {
#line 554
    ctx->max_frame_size = 16 + ((ctx->params.block_size * ((ctx->bps + ctx->bps) + 1) + 7) >> 3);
  } else {
#line 556
    ctx->max_frame_size = 16 + (((ctx->params.block_size * ctx->channels) * ctx->bps + 7) >> 3);
  }
#line 560
  i = 15;
#line 561
  if (! ctx->params.variable_block_size) {
#line 562
    i = 0;
    {
    {
#line 562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 562
      if (! (i < 15)) {
#line 562
        goto while_break;
      }
#line 563
      if (ctx->params.block_size == (int )flac_blocksizes___2[i]) {
#line 564
        frame->blocksize = (int )flac_blocksizes___2[i];
#line 565
        frame->bs_code[0] = i;
#line 566
        frame->bs_code[1] = -1;
#line 567
        goto while_break;
      }
#line 562
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 571
  if (i == 15) {
#line 572
    frame->blocksize = ctx->params.block_size;
#line 573
    if (frame->blocksize <= 256) {
#line 574
      frame->bs_code[0] = 6;
#line 575
      frame->bs_code[1] = frame->blocksize - 1;
    } else {
#line 577
      frame->bs_code[0] = 7;
#line 578
      frame->bs_code[1] = frame->blocksize - 1;
    }
  }
#line 583
  ch = 0;
  {
  {
#line 583
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 583
    if (! (ch < ctx->channels)) {
#line 583
      goto while_break___0;
    }
#line 584
    frame->subframes[ch].obits = ctx->bps;
#line 583
    ch ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 593 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void update_md5_checksum___2(FlacEncodeContext *ctx , int16_t *samples ) 
{ 


  {
  {
  {
#line 596
  md5_accumulate(& ctx->md5ctx, (void const   *)samples, ctx->channels, ctx->params.block_size);
  }
  }
#line 597
  return;
}
}
#line 602 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void copy_samples___2(FlacEncodeContext *ctx , int16_t *samples ) 
{ 
  int i ;
  int j ;
  int ch ;
  FlacFrame *frame ;

  {
#line 608
  frame = & ctx->frame;
#line 609
  i = 0;
#line 609
  j = 0;
  {
  {
#line 609
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i < frame->blocksize)) {
#line 609
      goto while_break;
    }
#line 610
    ch = 0;
    {
    {
#line 610
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 610
      if (! (ch < ctx->channels)) {
#line 610
        goto while_break___0;
      }
#line 611
      frame->subframes[ch].samples[i] = (int32_t )*(samples + j);
#line 610
      ch ++;
#line 610
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 609
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 614
  return;
}
}
#line 619 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static int calc_decorr_scores___2(int32_t *left_ch , int32_t *right_ch , int n ) 
{ 
  int i ;
  int best ;
  int32_t lt ;
  int32_t rt ;
  uint64_t sum[4] ;
  uint64_t score[4] ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;

  {
#line 629
  sum[3] = (uint64_t )0;
#line 629
  sum[2] = sum[3];
#line 629
  sum[1] = sum[2];
#line 629
  sum[0] = sum[1];
#line 630
  i = 2;
  {
  {
#line 630
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < n)) {
#line 630
      goto while_break;
    }
    {
#line 631
    lt = (*(left_ch + i) - 2 * *(left_ch + (i - 1))) + *(left_ch + (i - 2));
#line 632
    rt = (*(right_ch + i) - 2 * *(right_ch + (i - 1))) + *(right_ch + (i - 2));
    {
#line 633
    tmp = abs((lt + rt) >> 1);
    }
#line 633
    sum[2] += (uint64_t )tmp;
    {
#line 634
    tmp___0 = abs(lt - rt);
    }
#line 634
    sum[3] += (uint64_t )tmp___0;
    {
#line 635
    tmp___1 = abs(lt);
    }
#line 635
    sum[0] += (uint64_t )tmp___1;
    {
#line 636
    tmp___2 = abs(rt);
    }
#line 636
    sum[1] += (uint64_t )tmp___2;
#line 630
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  i = 0;
  {
  {
#line 639
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (i < 4)) {
#line 639
      goto while_break___0;
    }
    {
    {
#line 640
    k = find_optimal_rice_param((uint32_t )(2ULL * sum[i]), n);
    }
#line 641
    sum[i] = (uint64_t )(n * (k + 1)) + ((2ULL * sum[i] - (uint64_t )(n >> 1)) >> k);
#line 639
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 645
  score[0] = sum[0] + sum[1];
#line 646
  score[1] = sum[0] + sum[3];
#line 647
  score[2] = sum[1] + sum[3];
#line 648
  score[3] = sum[2] + sum[3];
#line 651
  best = 0;
#line 652
  i = 1;
  {
  {
#line 652
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 652
    if (! (i < 4)) {
#line 652
      goto while_break___1;
    }
#line 653
    if (score[i] < score[best]) {
#line 654
      best = i;
    }
#line 652
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 658
  if (best == 0) {
#line 658
    goto case_0;
  }
#line 659
  if (best == 1) {
#line 659
    goto case_1;
  }
#line 660
  if (best == 2) {
#line 660
    goto case_2;
  }
#line 661
  if (best == 3) {
#line 661
    goto case_3;
  }
#line 657
  goto switch_break;
  case_0: /* CIL Label */ 
#line 658
  return (1);
  case_1: /* CIL Label */ 
#line 659
  return (8);
  case_2: /* CIL Label */ 
#line 660
  return (9);
  case_3: /* CIL Label */ 
#line 661
  return (10);
  switch_break: /* CIL Label */ ;
  }
#line 663
  return (1);
}
}
#line 669 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void channel_decorrelation___2(FlacEncodeContext *ctx ) 
{ 
  int i ;
  FlacFrame *frame ;
  int32_t *left ;
  int32_t *right ;
  int32_t tmp ;

  {
#line 677
  frame = & ctx->frame;
#line 678
  left = frame->subframes[0].samples;
#line 679
  right = frame->subframes[1].samples;
#line 681
  if (ctx->channels != 2) {
#line 682
    frame->ch_mode = 0;
#line 683
    return;
  }
#line 685
  if (frame->blocksize <= 32) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  } else
#line 685
  if (ctx->params.stereo_method == 0) {
#line 686
    frame->ch_mode = 1;
#line 687
    return;
  }
  {
  {
#line 691
  frame->ch_mode = calc_decorr_scores___2(left, right, frame->blocksize);
  }
  }
#line 694
  if (frame->ch_mode == 1) {
#line 695
    return;
  }
#line 697
  if (frame->ch_mode == 10) {
#line 698
    i = 0;
    {
    {
#line 698
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 698
      if (! (i < frame->blocksize)) {
#line 698
        goto while_break;
      }
#line 699
      tmp = *(left + i);
#line 700
      *(left + i) = (*(left + i) + *(right + i)) >> 1;
#line 701
      *(right + i) = tmp - *(right + i);
#line 698
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 703
    (frame->subframes[1].obits) ++;
  } else
#line 704
  if (frame->ch_mode == 8) {
#line 705
    i = 0;
    {
    {
#line 705
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 705
      if (! (i < frame->blocksize)) {
#line 705
        goto while_break___0;
      }
#line 706
      *(right + i) = *(left + i) - *(right + i);
#line 705
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    (frame->subframes[1].obits) ++;
  } else
#line 709
  if (frame->ch_mode == 9) {
#line 710
    i = 0;
    {
    {
#line 710
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 710
      if (! (i < frame->blocksize)) {
#line 710
        goto while_break___1;
      }
#line 711
      *(left + i) -= *(right + i);
#line 710
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 713
    (frame->subframes[0].obits) ++;
  }
#line 715
  return;
}
}
#line 721 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void write_utf8___2(BitWriter *bw , uint32_t val ) 
{ 
  int bytes ;
  int shift ;
  int tmp ;

  {
#line 726
  if (val < 128U) {
    {
    {
#line 727
    bitwriter_writebits(bw, 8, val);
    }
    }
#line 728
    return;
  }
  {
  {
#line 730
  tmp = log2i(val);
  }
#line 730
  bytes = (tmp + 4) / 5;
#line 731
  shift = (bytes - 1) * 6;
  {
#line 732
  bitwriter_writebits(bw, 8, (unsigned int )(256 - (256 >> bytes)) | (val >> shift));
  }
  }
  {
  {
#line 733
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 733
    if (! (shift >= 6)) {
#line 733
      goto while_break;
    }
    {
#line 734
    shift -= 6;
    {
#line 735
    bitwriter_writebits(bw, 8, 128U | ((val >> shift) & 63U));
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return;
}
}
#line 739 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_header___2(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  uint8_t crc ;
  uint32_t tmp ;

  {
  {
#line 745
  frame = & ctx->frame;
  {
#line 747
  bitwriter_writebits(ctx->bw, 16, (uint32_t )65528);
  }
  {
#line 748
  bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->bs_code[0]);
  }
  {
#line 749
  bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->sr_code[0]);
  }
  }
#line 750
  if (frame->ch_mode == 0) {
    {
    {
#line 751
    bitwriter_writebits(ctx->bw, 4, (uint32_t )ctx->ch_code);
    }
    }
  } else {
    {
    {
#line 753
    bitwriter_writebits(ctx->bw, 4, (uint32_t )frame->ch_mode);
    }
    }
  }
  {
  {
#line 755
  bitwriter_writebits(ctx->bw, 3, (uint32_t )ctx->bps_code);
  }
  {
#line 756
  bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
  }
  {
#line 757
  write_utf8___2(ctx->bw, ctx->frame_count);
  }
  }
#line 760
  if (frame->bs_code[1] >= 0) {
#line 761
    if (frame->bs_code[1] < 256) {
      {
      {
#line 762
      bitwriter_writebits(ctx->bw, 8, (uint32_t )frame->bs_code[1]);
      }
      }
    } else {
      {
      {
#line 764
      bitwriter_writebits(ctx->bw, 16, (uint32_t )frame->bs_code[1]);
      }
      }
    }
  }
#line 769
  if (ctx->sr_code[1] > 0) {
#line 770
    if (ctx->sr_code[1] < 256) {
      {
      {
#line 771
      bitwriter_writebits(ctx->bw, 8, (uint32_t )ctx->sr_code[1]);
      }
      }
    } else {
      {
      {
#line 773
      bitwriter_writebits(ctx->bw, 16, (uint32_t )ctx->sr_code[1]);
      }
      }
    }
  }
  {
  {
#line 778
  bitwriter_flush(ctx->bw);
  }
  {
#line 779
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 779
  crc = calc_crc8((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 780
  bitwriter_writebits(ctx->bw, 8, (uint32_t )crc);
  }
  }
#line 781
  return;
}
}
#line 783 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_residual___2(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int j ;
  int p ;
  int k ;
  int porder ;
  int psize ;
  int res_cnt ;
  FlacFrame *frame ;
  FlacSubframe *sub ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 791
  frame = & ctx->frame;
#line 792
  sub = & frame->subframes[ch];
  {
#line 795
  bitwriter_writebits(ctx->bw, 2, (uint32_t )0);
  }
#line 798
  porder = sub->rc.porder;
#line 799
  psize = frame->blocksize >> porder;
  }
#line 800
  if (! (porder >= 0)) {
    {
    {
#line 800
    __assert_fail("porder >= 0", "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c",
                  800U, "output_residual");
    }
    }
  }
  {
  {
#line 801
  bitwriter_writebits(ctx->bw, 4, (uint32_t )porder);
  }
#line 802
  res_cnt = psize - sub->order;
#line 805
  j = sub->order;
#line 806
  p = 0;
  }
  {
  {
#line 806
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 806
    if (! (p < 1 << porder)) {
#line 806
      goto while_break;
    }
    {
#line 807
    k = sub->rc.params[p];
    {
#line 808
    bitwriter_writebits(ctx->bw, 4, (uint32_t )k);
    }
    }
#line 809
    if (p == 1) {
#line 809
      res_cnt = psize;
    }
#line 810
    i = 0;
    {
    {
#line 810
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 810
      if (i < res_cnt) {
#line 810
        if (! (j < frame->blocksize)) {
#line 810
          goto while_break___0;
        }
      } else {
#line 810
        goto while_break___0;
      }
      {
      {
#line 811
      bitwriter_write_rice_signed(ctx->bw, k, sub->residual[j]);
      }
#line 810
      i ++;
#line 810
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 806
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  return;
}
}
#line 816 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_constant___2(FlacEncodeContext *ctx , int ch ) 
{ 
  FlacSubframe *sub ;

  {
  {
#line 821
  sub = & ctx->frame.subframes[ch];
  {
#line 822
  bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[0]);
  }
  }
#line 823
  return;
}
}
#line 825 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_verbatim___2(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int n ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 832
  frame = & ctx->frame;
#line 833
  sub = & frame->subframes[ch];
#line 834
  n = frame->blocksize;
#line 836
  i = 0;
  {
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < n)) {
#line 836
      goto while_break;
    }
    {
    {
#line 837
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 836
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return;
}
}
#line 841 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_fixed___2(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 848
  frame = & ctx->frame;
#line 849
  sub = & frame->subframes[ch];
#line 852
  i = 0;
  {
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < sub->order)) {
#line 852
      goto while_break;
    }
    {
    {
#line 853
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 852
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 857
  output_residual___2(ctx, ch);
  }
  }
#line 858
  return;
}
}
#line 860 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframe_lpc___2(FlacEncodeContext *ctx , int ch ) 
{ 
  int i ;
  int cbits ;
  FlacFrame *frame ;
  FlacSubframe *sub ;

  {
#line 867
  frame = & ctx->frame;
#line 868
  sub = & frame->subframes[ch];
#line 871
  i = 0;
  {
  {
#line 871
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 871
    if (! (i < sub->order)) {
#line 871
      goto while_break;
    }
    {
    {
#line 872
    bitwriter_writebits_signed(ctx->bw, sub->obits, sub->residual[i]);
    }
#line 871
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 876
  cbits = ctx->lpc_precision;
  {
#line 877
  bitwriter_writebits(ctx->bw, 4, (uint32_t )(cbits - 1));
  }
  {
#line 878
  bitwriter_writebits_signed(ctx->bw, 5, sub->shift);
  }
#line 879
  i = 0;
  }
  {
  {
#line 879
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 879
    if (! (i < sub->order)) {
#line 879
      goto while_break___0;
    }
    {
    {
#line 880
    bitwriter_writebits_signed(ctx->bw, cbits, sub->coefs[i]);
    }
#line 879
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 884
  output_residual___2(ctx, ch);
  }
  }
#line 885
  return;
}
}
#line 887 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_subframes___2(FlacEncodeContext *ctx ) 
{ 
  FlacFrame *frame ;
  int i ;
  int ch ;

  {
#line 893
  frame = & ctx->frame;
#line 895
  i = 0;
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    if (! (i < ctx->channels)) {
#line 895
      goto while_break;
    }
    {
#line 896
    ch = i;
    {
#line 899
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    {
#line 900
    bitwriter_writebits(ctx->bw, 6, (uint32_t )frame->subframes[ch].type_code);
    }
    {
#line 901
    bitwriter_writebits(ctx->bw, 1, (uint32_t )0);
    }
    }
    {
#line 905
    if (frame->subframes[ch].type == 0) {
#line 905
      goto case_0;
    }
#line 907
    if (frame->subframes[ch].type == 1) {
#line 907
      goto case_1;
    }
#line 909
    if (frame->subframes[ch].type == 8) {
#line 909
      goto case_8;
    }
#line 911
    if (frame->subframes[ch].type == 32) {
#line 911
      goto case_32;
    }
#line 904
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 905
    output_subframe_constant___2(ctx, ch);
    }
    }
#line 906
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 907
    output_subframe_verbatim___2(ctx, ch);
    }
    }
#line 908
    goto switch_break;
    case_8: /* CIL Label */ 
    {
    {
#line 909
    output_subframe_fixed___2(ctx, ch);
    }
    }
#line 910
    goto switch_break;
    case_32: /* CIL Label */ 
    {
    {
#line 911
    output_subframe_lpc___2(ctx, ch);
    }
    }
#line 912
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 895
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/flake-0.11/libflake/encode.c"
static void output_frame_footer___2(FlacEncodeContext *ctx ) 
{ 
  uint16_t crc ;
  uint32_t tmp ;

  {
  {
  {
#line 921
  bitwriter_flush(ctx->bw);
  }
  {
#line 922
  tmp = bitwriter_count(ctx->bw);
  }
  {
#line 922
  crc = calc_crc16((uint8_t const   *)(ctx->bw)->buffer, tmp);
  }
  {
#line 923
  bitwriter_writebits(ctx->bw, 16, (uint32_t )crc);
  }
  {
#line 924
  bitwriter_flush(ctx->bw);
  }
  }
#line 925
  return;
}
}
#line 36 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v1___2(int16_t *samples , int channels , int block_size ,
                               int *frames , int *sizes ) 
{ 
  int i ;
  int ch ;
  int j ;
  int n ;
  int64_t res[8] ;
  int layout[8] ;
  int16_t *sptr ;
  int16_t *sptr0 ;
  int16_t *sptr1 ;
  int16_t *sptr2 ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;

  {
#line 41
  n = block_size >> 3;
#line 47
  i = 0;
  {
  {
#line 47
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 8)) {
#line 47
      goto while_break;
    }
#line 48
    sptr = samples + (i * n) * channels;
#line 49
    res[i] = (int64_t )0;
#line 50
    ch = 0;
    {
    {
#line 50
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 50
      if (! (ch < channels)) {
#line 50
        goto while_break___0;
      }
#line 51
      sptr0 = sptr + (2 * channels + ch);
#line 52
      sptr1 = sptr0 - channels;
#line 53
      sptr2 = sptr1 - channels;
#line 54
      j = 2;
      {
      {
#line 54
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 54
        if (! (j < n)) {
#line 54
          goto while_break___1;
        }
        {
        {
#line 55
        tmp = abs(((int )*sptr0 - 2 * (int )*sptr1) + (int )*sptr2);
        }
#line 55
        res[i] += (int64_t )tmp;
#line 56
        sptr0 += channels;
#line 57
        sptr1 += channels;
#line 58
        sptr2 += channels;
#line 54
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 50
      ch ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    res[i] /= (int64_t )channels;
#line 62
    (res[i]) ++;
#line 47
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  memset((void *)(layout), 0, (size_t )(8UL * sizeof(int )));
  }
#line 67
  layout[0] = 1;
#line 68
  i = 0;
  }
  {
  {
#line 68
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 68
    if (! (i < 7)) {
#line 68
      goto while_break___2;
    }
    {
    {
#line 69
    tmp___0 = abs((int )(res[i] - res[i + 1]));
    }
    }
#line 69
    if ((int64_t )(tmp___0 * 200) / res[i] > 100L) {
#line 70
      layout[i + 1] = 1;
    }
#line 68
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 75
  *(frames + 0) = 0;
  {
#line 76
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 77
  i = 0;
  }
  {
  {
#line 77
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 77
    if (! (i < 8)) {
#line 77
      goto while_break___3;
    }
#line 78
    if (layout[i]) {
#line 79
      (*(frames + 0)) ++;
    }
#line 81
    *(sizes + (*(frames + 0) - 1)) += n;
#line 77
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 85 "/home/wslee/benchmarks/sound/flake-0.11/libflake/vbs.c"
static void split_frame_v2___2(FlakeContext *s , int16_t *samples , int *frames ,
                               int *sizes ) 
{ 
  int fsizes[4][8] ;
  int layout[8] ;
  int i ;
  int j ;
  int n ;
  int ch ;
  FlacEncodeContext *ctx ;
  int levels ;
  int bs ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 91
  ctx = (FlacEncodeContext *)s->private_ctx;
#line 92
  ch = ctx->channels;
#line 95
  i = 0;
  {
  {
#line 95
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < 4)) {
#line 95
      goto while_break;
    }
#line 97
    levels = 1 << i;
#line 98
    s->params.block_size /= levels;
#line 99
    bs = s->params.block_size;
#line 100
    j = 0;
    {
    {
#line 100
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 100
      if (! (j < levels)) {
#line 100
        goto while_break___0;
      }
      {
      {
#line 101
      fsizes[i][j] = encode_frame(s, (uint8_t *)((void *)0), samples + (bs * j) * ch);
      }
#line 100
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 103
    s->params.block_size *= levels;
#line 95
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  i = 0;
  {
  {
#line 107
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i < 8)) {
#line 107
      goto while_break___1;
    }
#line 107
    layout[i] = 1;
#line 107
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 109
  if (fsizes[2][0] < fsizes[3][0] + fsizes[3][1]) {
#line 110
    layout[1] = 0;
  }
#line 112
  if (fsizes[2][1] < fsizes[3][2] + fsizes[3][3]) {
#line 113
    layout[3] = 0;
  }
#line 115
  if (fsizes[2][2] < fsizes[3][4] + fsizes[3][5]) {
#line 116
    layout[5] = 0;
  }
#line 118
  if (fsizes[2][3] < fsizes[3][6] + fsizes[3][7]) {
#line 119
    layout[7] = 0;
  }
#line 122
  if (layout[1] == 0) {
#line 122
    if (layout[3] == 0) {
#line 123
      if (fsizes[1][0] < fsizes[2][0] + fsizes[2][1]) {
#line 124
        layout[2] = 0;
      }
    }
  }
#line 127
  if (layout[5] == 0) {
#line 127
    if (layout[7] == 0) {
#line 128
      if (fsizes[1][1] < fsizes[2][2] + fsizes[2][3]) {
#line 129
        layout[6] = 0;
      }
    }
  }
#line 133
  if (layout[2] == 0) {
#line 133
    if (layout[6] == 0) {
#line 134
      if (fsizes[0][0] < fsizes[1][0] + fsizes[1][1]) {
#line 135
        layout[4] = 0;
      }
    }
  }
  {
#line 140
  n = s->params.block_size >> 3;
#line 141
  *(frames + 0) = 0;
  {
#line 142
  memset((void *)sizes, 0, (size_t )(8UL * sizeof(int )));
  }
#line 143
  i = 0;
  }
  {
  {
#line 143
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < 8)) {
#line 143
      goto while_break___2;
    }
#line 144
    if (layout[i]) {
#line 145
      (*(frames + 0)) ++;
    }
#line 147
    *(sizes + (*(frames + 0) - 1)) += n;
#line 143
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_optimal_rice_params___1(RiceContext *rc , int porder , uint32_t *sums ,
                                             int n , int pred_order ) 
{ 
  int i ;
  int k ;
  int cnt ;
  int part ;
  uint32_t all_bits ;

  {
#line 54
  part = 1 << porder;
#line 55
  all_bits = (uint32_t )0;
#line 57
  cnt = (n >> porder) - pred_order;
#line 58
  i = 0;
  {
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < part)) {
#line 58
      goto while_break;
    }
#line 59
    if (i == 1) {
#line 59
      cnt = n >> porder;
    }
    {
    {
#line 60
    k = find_optimal_rice_param(*(sums + i), cnt);
    }
#line 61
    rc->params[i] = k;
#line 62
    all_bits += (uint32_t )(cnt * (k + 1)) + ((*(sums + i) - (uint32_t )(cnt >> 1)) >> k);
#line 58
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  all_bits += (uint32_t )(4 * part);
#line 66
  rc->porder = porder;
#line 68
  return (all_bits);
}
}
#line 71 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static void calc_sums___1(int pmin , int pmax , uint32_t *data , int n , int pred_order ,
                          uint32_t (*sums)[1 << 8] ) 
{ 
  int i ;
  int j ;
  int parts ;
  int cnt ;
  uint32_t *res ;

  {
#line 80
  parts = 1 << pmax;
#line 81
  res = data + pred_order;
#line 82
  cnt = (n >> pmax) - pred_order;
#line 83
  i = 0;
  {
  {
#line 83
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < parts)) {
#line 83
      goto while_break;
    }
#line 84
    if (i == 1) {
#line 84
      cnt = n >> pmax;
    }
#line 85
    if (i > 0) {
#line 85
      res = data + i * cnt;
    }
#line 86
    (*(sums + pmax))[i] = (uint32_t )0;
#line 87
    j = 0;
    {
    {
#line 87
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 87
      if (! (j < cnt)) {
#line 87
        goto while_break___0;
      }
#line 88
      (*(sums + pmax))[i] += *(res + j);
#line 87
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = pmax - 1;
  {
  {
#line 92
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (i >= pmin)) {
#line 92
      goto while_break___1;
    }
#line 93
    parts = 1 << i;
#line 94
    j = 0;
    {
    {
#line 94
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (j < parts)) {
#line 94
        goto while_break___2;
      }
#line 95
      (*(sums + i))[j] = (*(sums + (i + 1)))[2 * j] + (*(sums + (i + 1)))[2 * j + 1];
#line 94
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 92
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_rice_params___1(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                                     int n , int pred_order ) 
{ 
  int i ;
  uint32_t bits[9] ;
  int opt_porder ;
  RiceContext tmp_rc ;
  uint32_t *udata ;
  uint32_t sums[9][1 << 8] ;
  void *tmp ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 111
  if (pmin >= 0) {
#line 111
    if (! (pmin <= 8)) {
      {
      {
#line 111
      __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    111U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 111
    __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  111U, "calc_rice_params");
    }
    }
  }
#line 112
  if (pmax >= 0) {
#line 112
    if (! (pmax <= 8)) {
      {
      {
#line 112
      __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    112U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 112
    __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  112U, "calc_rice_params");
    }
    }
  }
#line 113
  if (! (pmin <= pmax)) {
    {
    {
#line 113
    __assert_fail("pmin <= pmax", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  113U, "calc_rice_params");
    }
    }
  }
  {
  {
#line 115
  tmp = malloc((size_t )((unsigned long )n * sizeof(uint32_t )));
  }
#line 115
  udata = (uint32_t *)tmp;
#line 116
  i = 0;
  }
  {
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < n)) {
#line 116
      goto while_break;
    }
#line 117
    *(udata + i) = (uint32_t )(2 * *(data + i) ^ (*(data + i) >> 31));
#line 116
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 120
  calc_sums___1(pmin, pmax, udata, n, pred_order, sums);
  }
#line 122
  opt_porder = pmin;
#line 123
  bits[pmin] = 4294967295U;
#line 124
  i = pmin;
  }
  {
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (i <= pmax)) {
#line 124
      goto while_break___0;
    }
    {
    {
#line 125
    bits[i] = calc_optimal_rice_params___1(& tmp_rc, i, sums[i], n, pred_order);
    }
    }
#line 126
    if (bits[i] <= bits[opt_porder]) {
#line 127
      opt_porder = i;
#line 128
      *rc = tmp_rc;
    }
#line 124
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 132
  free((void *)udata);
  }
  }
#line 133
  return (bits[opt_porder]);
}
}
#line 136 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static int get_max_p_order___1(int max_porder , int n , int order ) 
{ 
  int porder ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 139
  tmp___2 = log2i((uint32_t )(n ^ (n - 1)));
  }
  }
#line 139
  if (max_porder > tmp___2) {
    {
    {
#line 139
    tmp___0 = log2i((uint32_t )(n ^ (n - 1)));
    }
#line 139
    tmp___1 = tmp___0;
    }
  } else {
#line 139
    tmp___1 = max_porder;
  }
#line 139
  porder = tmp___1;
#line 140
  if (order > 0) {
    {
    {
#line 141
    tmp___5 = log2i((uint32_t )(n / order));
    }
    }
#line 141
    if (porder > tmp___5) {
      {
      {
#line 141
      tmp___4 = log2i((uint32_t )(n / order));
      }
#line 141
      porder = tmp___4;
      }
    } else {
#line 141
      porder = porder;
    }
  }
#line 142
  return (porder);
}
}
#line 46 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_optimal_rice_params___2(RiceContext *rc , int porder , uint32_t *sums ,
                                             int n , int pred_order ) 
{ 
  int i ;
  int k ;
  int cnt ;
  int part ;
  uint32_t all_bits ;

  {
#line 54
  part = 1 << porder;
#line 55
  all_bits = (uint32_t )0;
#line 57
  cnt = (n >> porder) - pred_order;
#line 58
  i = 0;
  {
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < part)) {
#line 58
      goto while_break;
    }
#line 59
    if (i == 1) {
#line 59
      cnt = n >> porder;
    }
    {
    {
#line 60
    k = find_optimal_rice_param(*(sums + i), cnt);
    }
#line 61
    rc->params[i] = k;
#line 62
    all_bits += (uint32_t )(cnt * (k + 1)) + ((*(sums + i) - (uint32_t )(cnt >> 1)) >> k);
#line 58
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  all_bits += (uint32_t )(4 * part);
#line 66
  rc->porder = porder;
#line 68
  return (all_bits);
}
}
#line 71 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static void calc_sums___2(int pmin , int pmax , uint32_t *data , int n , int pred_order ,
                          uint32_t (*sums)[1 << 8] ) 
{ 
  int i ;
  int j ;
  int parts ;
  int cnt ;
  uint32_t *res ;

  {
#line 80
  parts = 1 << pmax;
#line 81
  res = data + pred_order;
#line 82
  cnt = (n >> pmax) - pred_order;
#line 83
  i = 0;
  {
  {
#line 83
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < parts)) {
#line 83
      goto while_break;
    }
#line 84
    if (i == 1) {
#line 84
      cnt = n >> pmax;
    }
#line 85
    if (i > 0) {
#line 85
      res = data + i * cnt;
    }
#line 86
    (*(sums + pmax))[i] = (uint32_t )0;
#line 87
    j = 0;
    {
    {
#line 87
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 87
      if (! (j < cnt)) {
#line 87
        goto while_break___0;
      }
#line 88
      (*(sums + pmax))[i] += *(res + j);
#line 87
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = pmax - 1;
  {
  {
#line 92
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 92
    if (! (i >= pmin)) {
#line 92
      goto while_break___1;
    }
#line 93
    parts = 1 << i;
#line 94
    j = 0;
    {
    {
#line 94
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 94
      if (! (j < parts)) {
#line 94
        goto while_break___2;
      }
#line 95
      (*(sums + i))[j] = (*(sums + (i + 1)))[2 * j] + (*(sums + (i + 1)))[2 * j + 1];
#line 94
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 92
    i --;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static uint32_t calc_rice_params___2(RiceContext *rc , int pmin , int pmax , int32_t *data ,
                                     int n , int pred_order ) 
{ 
  int i ;
  uint32_t bits[9] ;
  int opt_porder ;
  RiceContext tmp_rc ;
  uint32_t *udata ;
  uint32_t sums[9][1 << 8] ;
  void *tmp ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 111
  if (pmin >= 0) {
#line 111
    if (! (pmin <= 8)) {
      {
      {
#line 111
      __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    111U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 111
    __assert_fail("pmin >= 0 && pmin <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  111U, "calc_rice_params");
    }
    }
  }
#line 112
  if (pmax >= 0) {
#line 112
    if (! (pmax <= 8)) {
      {
      {
#line 112
      __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                    112U, "calc_rice_params");
      }
      }
    }
  } else {
    {
    {
#line 112
    __assert_fail("pmax >= 0 && pmax <= 8", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  112U, "calc_rice_params");
    }
    }
  }
#line 113
  if (! (pmin <= pmax)) {
    {
    {
#line 113
    __assert_fail("pmin <= pmax", "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c",
                  113U, "calc_rice_params");
    }
    }
  }
  {
  {
#line 115
  tmp = malloc((size_t )((unsigned long )n * sizeof(uint32_t )));
  }
#line 115
  udata = (uint32_t *)tmp;
#line 116
  i = 0;
  }
  {
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < n)) {
#line 116
      goto while_break;
    }
#line 117
    *(udata + i) = (uint32_t )(2 * *(data + i) ^ (*(data + i) >> 31));
#line 116
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 120
  calc_sums___2(pmin, pmax, udata, n, pred_order, sums);
  }
#line 122
  opt_porder = pmin;
#line 123
  bits[pmin] = 4294967295U;
#line 124
  i = pmin;
  }
  {
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 124
    if (! (i <= pmax)) {
#line 124
      goto while_break___0;
    }
    {
    {
#line 125
    bits[i] = calc_optimal_rice_params___2(& tmp_rc, i, sums[i], n, pred_order);
    }
    }
#line 126
    if (bits[i] <= bits[opt_porder]) {
#line 127
      opt_porder = i;
#line 128
      *rc = tmp_rc;
    }
#line 124
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 132
  free((void *)udata);
  }
  }
#line 133
  return (bits[opt_porder]);
}
}
#line 136 "/home/wslee/benchmarks/sound/flake-0.11/libflake/rice.c"
static int get_max_p_order___2(int max_porder , int n , int order ) 
{ 
  int porder ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 139
  tmp___2 = log2i((uint32_t )(n ^ (n - 1)));
  }
  }
#line 139
  if (max_porder > tmp___2) {
    {
    {
#line 139
    tmp___0 = log2i((uint32_t )(n ^ (n - 1)));
    }
#line 139
    tmp___1 = tmp___0;
    }
  } else {
#line 139
    tmp___1 = max_porder;
  }
#line 139
  porder = tmp___1;
#line 140
  if (order > 0) {
    {
    {
#line 141
    tmp___5 = log2i((uint32_t )(n / order));
    }
    }
#line 141
    if (porder > tmp___5) {
      {
      {
#line 141
      tmp___4 = log2i((uint32_t )(n / order));
      }
#line 141
      porder = tmp___4;
      }
    } else {
#line 141
      porder = porder;
    }
  }
#line 142
  return (porder);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 11 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
static char *get_format_name(int id ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;

  {
#line 14
  if (id < 0) {
#line 14
    return ((char *)((void *)0));
  } else
#line 14
  if (id > 65535) {
#line 14
    return ((char *)((void *)0));
  }
  {
#line 16
  if (id == 0) {
#line 16
    goto case_0;
  }
#line 17
  if (id == 1) {
#line 17
    goto case_1;
  }
#line 18
  if (id == 2) {
#line 18
    goto case_2;
  }
#line 19
  if (id == 3) {
#line 19
    goto case_3;
  }
#line 20
  if (id == 4) {
#line 20
    goto case_4;
  }
#line 21
  if (id == 5) {
#line 21
    goto case_5;
  }
#line 22
  if (id == 6) {
#line 22
    goto case_6;
  }
#line 23
  if (id == 7) {
#line 23
    goto case_7;
  }
#line 24
  if (id == 8) {
#line 24
    goto case_8;
  }
#line 25
  if (id == 9) {
#line 25
    goto case_9;
  }
#line 26
  if (id == 10) {
#line 26
    goto case_10;
  }
#line 27
  if (id == 11) {
#line 27
    goto case_11;
  }
#line 29
  if (id == 16) {
#line 29
    goto case_16;
  }
#line 30
  if (id == 17) {
#line 30
    goto case_17;
  }
#line 31
  if (id == 18) {
#line 31
    goto case_18;
  }
#line 32
  if (id == 19) {
#line 32
    goto case_19;
  }
#line 33
  if (id == 20) {
#line 33
    goto case_20;
  }
#line 34
  if (id == 21) {
#line 34
    goto case_21;
  }
#line 35
  if (id == 22) {
#line 35
    goto case_22;
  }
#line 36
  if (id == 23) {
#line 36
    goto case_23;
  }
#line 37
  if (id == 24) {
#line 37
    goto case_24;
  }
#line 38
  if (id == 25) {
#line 38
    goto case_25;
  }
#line 40
  if (id == 32) {
#line 40
    goto case_32;
  }
#line 41
  if (id == 33) {
#line 41
    goto case_33;
  }
#line 42
  if (id == 34) {
#line 42
    goto case_34;
  }
#line 43
  if (id == 35) {
#line 43
    goto case_35;
  }
#line 44
  if (id == 36) {
#line 44
    goto case_36;
  }
#line 45
  if (id == 37) {
#line 45
    goto case_37;
  }
#line 46
  if (id == 38) {
#line 46
    goto case_38;
  }
#line 47
  if (id == 39) {
#line 47
    goto case_39;
  }
#line 48
  if (id == 40) {
#line 48
    goto case_40;
  }
#line 50
  if (id == 48) {
#line 50
    goto case_48;
  }
#line 51
  if (id == 49) {
#line 51
    goto case_49;
  }
#line 52
  if (id == 50) {
#line 52
    goto case_50;
  }
#line 53
  if (id == 51) {
#line 53
    goto case_51;
  }
#line 54
  if (id == 52) {
#line 54
    goto case_52;
  }
#line 55
  if (id == 53) {
#line 55
    goto case_53;
  }
#line 56
  if (id == 54) {
#line 56
    goto case_54;
  }
#line 57
  if (id == 55) {
#line 57
    goto case_55;
  }
#line 58
  if (id == 56) {
#line 58
    goto case_56;
  }
#line 59
  if (id == 57) {
#line 59
    goto case_57;
  }
#line 60
  if (id == 58) {
#line 60
    goto case_58;
  }
#line 61
  if (id == 59) {
#line 61
    goto case_59;
  }
#line 62
  if (id == 60) {
#line 62
    goto case_60;
  }
#line 63
  if (id == 61) {
#line 63
    goto case_61;
  }
#line 65
  if (id == 64) {
#line 65
    goto case_64;
  }
#line 66
  if (id == 65) {
#line 66
    goto case_65;
  }
#line 67
  if (id == 66) {
#line 67
    goto case_66;
  }
#line 68
  if (id == 67) {
#line 68
    goto case_67;
  }
#line 69
  if (id == 68) {
#line 69
    goto case_68;
  }
#line 70
  if (id == 69) {
#line 70
    goto case_69;
  }
#line 72
  if (id == 80) {
#line 72
    goto case_80;
  }
#line 74
  if (id == 82) {
#line 74
    goto case_82;
  }
#line 75
  if (id == 83) {
#line 75
    goto case_83;
  }
#line 77
  if (id == 85) {
#line 77
    goto case_85;
  }
#line 79
  if (id == 89) {
#line 79
    goto case_89;
  }
#line 81
  if (id == 96) {
#line 81
    goto case_96;
  }
#line 82
  if (id == 97) {
#line 82
    goto case_97;
  }
#line 83
  if (id == 98) {
#line 83
    goto case_98;
  }
#line 84
  if (id == 99) {
#line 84
    goto case_99;
  }
#line 85
  if (id == 100) {
#line 85
    goto case_100;
  }
#line 86
  if (id == 101) {
#line 86
    goto case_101;
  }
#line 87
  if (id == 102) {
#line 87
    goto case_102;
  }
#line 88
  if (id == 103) {
#line 88
    goto case_103;
  }
#line 90
  if (id == 105) {
#line 90
    goto case_105;
  }
#line 92
  if (id == 112) {
#line 92
    goto case_112;
  }
#line 93
  if (id == 113) {
#line 93
    goto case_113;
  }
#line 94
  if (id == 114) {
#line 94
    goto case_114;
  }
#line 95
  if (id == 115) {
#line 95
    goto case_115;
  }
#line 96
  if (id == 116) {
#line 96
    goto case_116;
  }
#line 97
  if (id == 117) {
#line 97
    goto case_117;
  }
#line 98
  if (id == 118) {
#line 98
    goto case_118;
  }
#line 99
  if (id == 119) {
#line 99
    goto case_119;
  }
#line 100
  if (id == 120) {
#line 100
    goto case_120;
  }
#line 101
  if (id == 121) {
#line 101
    goto case_121;
  }
#line 103
  if (id == 128) {
#line 103
    goto case_128;
  }
#line 104
  if (id == 129) {
#line 104
    goto case_129;
  }
#line 105
  if (id == 130) {
#line 105
    goto case_130;
  }
#line 106
  if (id == 131) {
#line 106
    goto case_131;
  }
#line 107
  if (id == 132) {
#line 107
    goto case_132;
  }
#line 108
  if (id == 133) {
#line 108
    goto case_133;
  }
#line 109
  if (id == 134) {
#line 109
    goto case_134;
  }
#line 111
  if (id == 136) {
#line 111
    goto case_136;
  }
#line 112
  if (id == 137) {
#line 112
    goto case_137;
  }
#line 114
  if (id == 145) {
#line 114
    goto case_145;
  }
#line 115
  if (id == 146) {
#line 115
    goto case_146;
  }
#line 116
  if (id == 147) {
#line 116
    goto case_147;
  }
#line 117
  if (id == 148) {
#line 117
    goto case_148;
  }
#line 119
  if (id == 151) {
#line 119
    goto case_151;
  }
#line 120
  if (id == 152) {
#line 120
    goto case_152;
  }
#line 121
  if (id == 153) {
#line 121
    goto case_153;
  }
#line 123
  if (id == 255) {
#line 123
    goto case_255;
  }
#line 125
  if (id == 256) {
#line 125
    goto case_256;
  }
#line 126
  if (id == 257) {
#line 126
    goto case_257;
  }
#line 127
  if (id == 258) {
#line 127
    goto case_258;
  }
#line 128
  if (id == 259) {
#line 128
    goto case_259;
  }
#line 130
  if (id == 273) {
#line 130
    goto case_273;
  }
#line 131
  if (id == 274) {
#line 131
    goto case_274;
  }
#line 133
  if (id == 291) {
#line 133
    goto case_291;
  }
#line 135
  if (id == 293) {
#line 135
    goto case_293;
  }
#line 137
  if (id == 304) {
#line 137
    goto case_304;
  }
#line 138
  if (id == 305) {
#line 138
    goto case_305;
  }
#line 139
  if (id == 306) {
#line 139
    goto case_306;
  }
#line 140
  if (id == 307) {
#line 140
    goto case_307;
  }
#line 141
  if (id == 308) {
#line 141
    goto case_308;
  }
#line 142
  if (id == 309) {
#line 142
    goto case_309;
  }
#line 144
  if (id == 320) {
#line 144
    goto case_320;
  }
#line 146
  if (id == 336) {
#line 146
    goto case_336;
  }
#line 147
  if (id == 337) {
#line 147
    goto case_337;
  }
#line 149
  if (id == 341) {
#line 149
    goto case_341;
  }
#line 151
  if (id == 352) {
#line 151
    goto case_352;
  }
#line 152
  if (id == 353) {
#line 152
    goto case_353;
  }
#line 153
  if (id == 354) {
#line 153
    goto case_354;
  }
#line 154
  if (id == 355) {
#line 154
    goto case_355;
  }
#line 155
  if (id == 356) {
#line 155
    goto case_356;
  }
#line 157
  if (id == 384) {
#line 157
    goto case_384;
  }
#line 159
  if (id == 400) {
#line 159
    goto case_400;
  }
#line 161
  if (id == 512) {
#line 161
    goto case_512;
  }
#line 163
  if (id == 514) {
#line 163
    goto case_514;
  }
#line 164
  if (id == 515) {
#line 164
    goto case_515;
  }
#line 166
  if (id == 528) {
#line 166
    goto case_528;
  }
#line 168
  if (id == 533) {
#line 168
    goto case_533;
  }
#line 169
  if (id == 534) {
#line 169
    goto case_534;
  }
#line 171
  if (id == 544) {
#line 171
    goto case_544;
  }
#line 173
  if (id == 560) {
#line 173
    goto case_560;
  }
#line 175
  if (id == 576) {
#line 175
    goto case_576;
  }
#line 177
  if (id == 592) {
#line 177
    goto case_592;
  }
#line 178
  if (id == 593) {
#line 178
    goto case_593;
  }
#line 180
  if (id == 608) {
#line 180
    goto case_608;
  }
#line 182
  if (id == 624) {
#line 182
    goto case_624;
  }
#line 183
  if (id == 625) {
#line 183
    goto case_625;
  }
#line 184
  if (id == 626) {
#line 184
    goto case_626;
  }
#line 185
  if (id == 627) {
#line 185
    goto case_627;
  }
#line 187
  if (id == 768) {
#line 187
    goto case_768;
  }
#line 189
  if (id == 1024) {
#line 189
    goto case_1024;
  }
#line 190
  if (id == 1025) {
#line 190
    goto case_1025;
  }
#line 192
  if (id == 1104) {
#line 192
    goto case_1104;
  }
#line 194
  if (id == 1664) {
#line 194
    goto case_1664;
  }
#line 195
  if (id == 1665) {
#line 195
    goto case_1665;
  }
#line 197
  if (id == 2222) {
#line 197
    goto case_2222;
  }
#line 199
  if (id == 4096) {
#line 199
    goto case_4096;
  }
#line 200
  if (id == 4097) {
#line 200
    goto case_4097;
  }
#line 201
  if (id == 4098) {
#line 201
    goto case_4098;
  }
#line 202
  if (id == 4099) {
#line 202
    goto case_4099;
  }
#line 203
  if (id == 4100) {
#line 203
    goto case_4100;
  }
#line 205
  if (id == 4352) {
#line 205
    goto case_4352;
  }
#line 206
  if (id == 4353) {
#line 206
    goto case_4353;
  }
#line 207
  if (id == 4354) {
#line 207
    goto case_4354;
  }
#line 208
  if (id == 4355) {
#line 208
    goto case_4355;
  }
#line 209
  if (id == 4356) {
#line 209
    goto case_4356;
  }
#line 211
  if (id == 5120) {
#line 211
    goto case_5120;
  }
#line 212
  if (id == 5121) {
#line 212
    goto case_5121;
  }
#line 214
  if (id == 5376) {
#line 214
    goto case_5376;
  }
#line 216
  if (id == 6172) {
#line 216
    goto case_6172;
  }
#line 218
  if (id == 6513) {
#line 218
    goto case_6513;
  }
#line 220
  if (id == 8132) {
#line 220
    goto case_8132;
  }
#line 222
  if (id == 8192) {
#line 222
    goto case_8192;
  }
#line 223
  if (id == 8193) {
#line 223
    goto case_8193;
  }
#line 224
  if (id == 8194) {
#line 224
    goto case_8194;
  }
#line 225
  if (id == 8195) {
#line 225
    goto case_8195;
  }
#line 226
  if (id == 8196) {
#line 226
    goto case_8196;
  }
#line 227
  if (id == 8197) {
#line 227
    goto case_8197;
  }
#line 228
  if (id == 8198) {
#line 228
    goto case_8198;
  }
#line 229
  if (id == 8199) {
#line 229
    goto case_8199;
  }
#line 231
  if (id == 8264) {
#line 231
    goto case_8264;
  }
#line 233
  if (id == 16707) {
#line 233
    goto case_16707;
  }
#line 235
  if (id == 16897) {
#line 235
    goto case_16897;
  }
#line 237
  if (id == 22127) {
#line 237
    goto case_22127;
  }
#line 239
  if (id == 22358) {
#line 239
    goto case_22358;
  }
#line 241
  if (id == 26447) {
#line 241
    goto case_26447;
  }
#line 242
  if (id == 26448) {
#line 242
    goto case_26448;
  }
#line 243
  if (id == 26449) {
#line 243
    goto case_26449;
  }
#line 244
  if (id == 26479) {
#line 244
    goto case_26479;
  }
#line 245
  if (id == 26480) {
#line 245
    goto case_26480;
  }
#line 246
  if (id == 26481) {
#line 246
    goto case_26481;
  }
#line 248
  if (id == 31265) {
#line 248
    goto case_31265;
  }
#line 249
  if (id == 31266) {
#line 249
    goto case_31266;
  }
#line 251
  if (id == 28781) {
#line 251
    goto case_28781;
  }
#line 253
  if (id == 30625) {
#line 253
    goto case_30625;
  }
#line 255
  if (id == 41222) {
#line 255
    goto case_41222;
  }
#line 257
  if (id == 41225) {
#line 257
    goto case_41225;
  }
#line 259
  if (id == 61868) {
#line 259
    goto case_61868;
  }
#line 261
  if (id == 65534) {
#line 261
    goto case_65534;
  }
#line 262
  if (id == 65535) {
#line 262
    goto case_65535;
  }
#line 264
  goto switch_default;
  case_0: /* CIL Label */ 
#line 16
  return ((char *)"Microsoft Unknown Wave Format");
  case_1: /* CIL Label */ 
#line 17
  return ((char *)"Microsoft PCM");
  case_2: /* CIL Label */ 
#line 18
  return ((char *)"Microsoft ADPCM");
  case_3: /* CIL Label */ 
#line 19
  return ((char *)"IEEE Float");
  case_4: /* CIL Label */ 
#line 20
  return ((char *)"Compaq Computer VSELP");
  case_5: /* CIL Label */ 
#line 21
  return ((char *)"IBM CVSD");
  case_6: /* CIL Label */ 
#line 22
  return ((char *)"Microsoft A-Law");
  case_7: /* CIL Label */ 
#line 23
  return ((char *)"Microsoft mu-Law");
  case_8: /* CIL Label */ 
#line 24
  return ((char *)"Microsoft DTS");
  case_9: /* CIL Label */ 
#line 25
  return ((char *)"Microsoft DRM Encrypted Audio");
  case_10: /* CIL Label */ 
#line 26
  return ((char *)"Windows Media Audio 9 Voice");
  case_11: /* CIL Label */ 
#line 27
  return ((char *)"Windows Media RT Voice");
  case_16: /* CIL Label */ 
#line 29
  return ((char *)"OKI ADPCM");
  case_17: /* CIL Label */ 
#line 30
  return ((char *)"Intel DVI/IMA ADPCM");
  case_18: /* CIL Label */ 
#line 31
  return ((char *)"Videologic MediaSpace ADPCM");
  case_19: /* CIL Label */ 
#line 32
  return ((char *)"Sierra ADPCM");
  case_20: /* CIL Label */ 
#line 33
  return ((char *)"Antex G.723 ADPCM");
  case_21: /* CIL Label */ 
#line 34
  return ((char *)"DSP Solutions DigiSTD");
  case_22: /* CIL Label */ 
#line 35
  return ((char *)"DSP Solutions DigiFIX");
  case_23: /* CIL Label */ 
#line 36
  return ((char *)"Dialogic OKI ADPCM");
  case_24: /* CIL Label */ 
#line 37
  return ((char *)"MediaVision ADPCM");
  case_25: /* CIL Label */ 
#line 38
  return ((char *)"Hewlett-Packard CU");
  case_32: /* CIL Label */ 
#line 40
  return ((char *)"Yamaha ADPCM");
  case_33: /* CIL Label */ 
#line 41
  return ((char *)"Speech Compression Sonarc");
  case_34: /* CIL Label */ 
#line 42
  return ((char *)"DSP Group TrueSpeech");
  case_35: /* CIL Label */ 
#line 43
  return ((char *)"Echo Speech EchoSC1");
  case_36: /* CIL Label */ 
#line 44
  return ((char *)"Audiofile AF36");
  case_37: /* CIL Label */ 
#line 45
  return ((char *)"Audio Processing Technology APTX");
  case_38: /* CIL Label */ 
#line 46
  return ((char *)"AudioFile AF10");
  case_39: /* CIL Label */ 
#line 47
  return ((char *)"Prosody 1612");
  case_40: /* CIL Label */ 
#line 48
  return ((char *)"LRC");
  case_48: /* CIL Label */ 
#line 50
  return ((char *)"Dolby AC2");
  case_49: /* CIL Label */ 
#line 51
  return ((char *)"Microsoft GSM 6.10");
  case_50: /* CIL Label */ 
#line 52
  return ((char *)"MSNAudio");
  case_51: /* CIL Label */ 
#line 53
  return ((char *)"Antex ADPCME");
  case_52: /* CIL Label */ 
#line 54
  return ((char *)"Control Resources VQLPC");
  case_53: /* CIL Label */ 
#line 55
  return ((char *)"DigiREAL");
  case_54: /* CIL Label */ 
#line 56
  return ((char *)"DigiADPCM");
  case_55: /* CIL Label */ 
#line 57
  return ((char *)"Control Resources CR10");
  case_56: /* CIL Label */ 
#line 58
  return ((char *)"Natural MicroSystems VBXADPCM");
  case_57: /* CIL Label */ 
#line 59
  return ((char *)"Crystal IMA ADPCM");
  case_58: /* CIL Label */ 
#line 60
  return ((char *)"EchoSC3");
  case_59: /* CIL Label */ 
#line 61
  return ((char *)"Rockwell ADPCM");
  case_60: /* CIL Label */ 
#line 62
  return ((char *)"Rockwell Digit LK");
  case_61: /* CIL Label */ 
#line 63
  return ((char *)"Xebec");
  case_64: /* CIL Label */ 
#line 65
  return ((char *)"Antex Electronics G.721 ADPCM");
  case_65: /* CIL Label */ 
#line 66
  return ((char *)"G.728 CELP");
  case_66: /* CIL Label */ 
#line 67
  return ((char *)"MS G.723");
  case_67: /* CIL Label */ 
#line 68
  return ((char *)"MS G.723.1");
  case_68: /* CIL Label */ 
#line 69
  return ((char *)"MS G.729");
  case_69: /* CIL Label */ 
#line 70
  return ((char *)"SP G.726");
  case_80: /* CIL Label */ 
#line 72
  return ((char *)"MPEG Layer-2 or Layer-1");
  case_82: /* CIL Label */ 
#line 74
  return ((char *)"RT24");
  case_83: /* CIL Label */ 
#line 75
  return ((char *)"PAC");
  case_85: /* CIL Label */ 
#line 77
  return ((char *)"MPEG Layer-3");
  case_89: /* CIL Label */ 
#line 79
  return ((char *)"Lucent G.723");
  case_96: /* CIL Label */ 
#line 81
  return ((char *)"Cirrus");
  case_97: /* CIL Label */ 
#line 82
  return ((char *)"ESPCM");
  case_98: /* CIL Label */ 
#line 83
  return ((char *)"Voxware");
  case_99: /* CIL Label */ 
#line 84
  return ((char *)"Canopus Atrac");
  case_100: /* CIL Label */ 
#line 85
  return ((char *)"G.726 ADPCM");
  case_101: /* CIL Label */ 
#line 86
  return ((char *)"G.722 ADPCM");
  case_102: /* CIL Label */ 
#line 87
  return ((char *)"DSAT");
  case_103: /* CIL Label */ 
#line 88
  return ((char *)"DSAT Display");
  case_105: /* CIL Label */ 
#line 90
  return ((char *)"Voxware Byte Aligned");
  case_112: /* CIL Label */ 
#line 92
  return ((char *)"Voxware AC8");
  case_113: /* CIL Label */ 
#line 93
  return ((char *)"Voxware AC10");
  case_114: /* CIL Label */ 
#line 94
  return ((char *)"Voxware AC16");
  case_115: /* CIL Label */ 
#line 95
  return ((char *)"Voxware AC20");
  case_116: /* CIL Label */ 
#line 96
  return ((char *)"Voxware MetaVoice");
  case_117: /* CIL Label */ 
#line 97
  return ((char *)"Voxware MetaSound");
  case_118: /* CIL Label */ 
#line 98
  return ((char *)"Voxware RT29HW");
  case_119: /* CIL Label */ 
#line 99
  return ((char *)"Voxware VR12");
  case_120: /* CIL Label */ 
#line 100
  return ((char *)"Voxware VR18");
  case_121: /* CIL Label */ 
#line 101
  return ((char *)"Voxware TQ40");
  case_128: /* CIL Label */ 
#line 103
  return ((char *)"Softsound");
  case_129: /* CIL Label */ 
#line 104
  return ((char *)"Voxware TQ60");
  case_130: /* CIL Label */ 
#line 105
  return ((char *)"MSRT24");
  case_131: /* CIL Label */ 
#line 106
  return ((char *)"G.729A");
  case_132: /* CIL Label */ 
#line 107
  return ((char *)"MVI MV12");
  case_133: /* CIL Label */ 
#line 108
  return ((char *)"DF G.726");
  case_134: /* CIL Label */ 
#line 109
  return ((char *)"DF GSM610");
  case_136: /* CIL Label */ 
#line 111
  return ((char *)"ISIAudio");
  case_137: /* CIL Label */ 
#line 112
  return ((char *)"Onlive");
  case_145: /* CIL Label */ 
#line 114
  return ((char *)"SBC24");
  case_146: /* CIL Label */ 
#line 115
  return ((char *)"Dolby AC3 SPDIF");
  case_147: /* CIL Label */ 
#line 116
  return ((char *)"MediaSonic G.723");
  case_148: /* CIL Label */ 
#line 117
  return ((char *)"Aculab PLC  Prosody 8kbps");
  case_151: /* CIL Label */ 
#line 119
  return ((char *)"ZyXEL ADPCM");
  case_152: /* CIL Label */ 
#line 120
  return ((char *)"Philips LPCBB");
  case_153: /* CIL Label */ 
#line 121
  return ((char *)"Packed");
  case_255: /* CIL Label */ 
#line 123
  return ((char *)"AAC");
  case_256: /* CIL Label */ 
#line 125
  return ((char *)"Rhetorex ADPCM");
  case_257: /* CIL Label */ 
#line 126
  return ((char *)"IBM mu-law");
  case_258: /* CIL Label */ 
#line 127
  return ((char *)"IBM A-law");
  case_259: /* CIL Label */ 
#line 128
  return ((char *)"IBM AVC ADPCM");
  case_273: /* CIL Label */ 
#line 130
  return ((char *)"Vivo G.723");
  case_274: /* CIL Label */ 
#line 131
  return ((char *)"Vivo Siren");
  case_291: /* CIL Label */ 
#line 133
  return ((char *)"Digital G.723");
  case_293: /* CIL Label */ 
#line 135
  return ((char *)"Sanyo LD ADPCM");
  case_304: /* CIL Label */ 
#line 137
  return ((char *)"Sipro Lab Telecom ACELP NET / RealAudio 4.0/5.0)");
  case_305: /* CIL Label */ 
#line 138
  return ((char *)"Sipro Lab Telecom ACELP 4800");
  case_306: /* CIL Label */ 
#line 139
  return ((char *)"Sipro Lab Telecom ACELP 8V3");
  case_307: /* CIL Label */ 
#line 140
  return ((char *)"Sipro Lab Telecom G.729");
  case_308: /* CIL Label */ 
#line 141
  return ((char *)"Sipro Lab Telecom G.729A");
  case_309: /* CIL Label */ 
#line 142
  return ((char *)"Sipro Lab Telecom Kelvin");
  case_320: /* CIL Label */ 
#line 144
  return ((char *)"Windows Media Video V8");
  case_336: /* CIL Label */ 
#line 146
  return ((char *)"Qualcomm PureVoice");
  case_337: /* CIL Label */ 
#line 147
  return ((char *)"Qualcomm HalfRate");
  case_341: /* CIL Label */ 
#line 149
  return ((char *)"Ring Zero Systems TUB GSM");
  case_352: /* CIL Label */ 
#line 151
  return ((char *)"Microsoft Audio 1");
  case_353: /* CIL Label */ 
#line 152
  return ((char *)"Windows Media 7/8/9");
  case_354: /* CIL Label */ 
#line 153
  return ((char *)"Windows Media 9 Professional");
  case_355: /* CIL Label */ 
#line 154
  return ((char *)"Windows Media 9 Lossess");
  case_356: /* CIL Label */ 
#line 155
  return ((char *)"Windows Media Professional over S/PDIF");
  case_384: /* CIL Label */ 
#line 157
  return ((char *)"MPEG-2 AAC");
  case_400: /* CIL Label */ 
#line 159
  return ((char *)"DTS");
  case_512: /* CIL Label */ 
#line 161
  return ((char *)"Creative Labs ADPCM");
  case_514: /* CIL Label */ 
#line 163
  return ((char *)"Creative Labs FastSpeech8");
  case_515: /* CIL Label */ 
#line 164
  return ((char *)"Creative Labs FastSpeech10");
  case_528: /* CIL Label */ 
#line 166
  return ((char *)"UHER Informatic GmbH ADPCM");
  case_533: /* CIL Label */ 
#line 168
  return ((char *)"Ulead DV Audio NTSC");
  case_534: /* CIL Label */ 
#line 169
  return ((char *)"Ulead DV Audio PAL");
  case_544: /* CIL Label */ 
#line 171
  return ((char *)"Quarterdeck");
  case_560: /* CIL Label */ 
#line 173
  return ((char *)"I-link Worldwide VC");
  case_576: /* CIL Label */ 
#line 175
  return ((char *)"Aureal RAW Sport");
  case_592: /* CIL Label */ 
#line 177
  return ((char *)"Interactive Products HSX");
  case_593: /* CIL Label */ 
#line 178
  return ((char *)"Interactive Products RPELP");
  case_608: /* CIL Label */ 
#line 180
  return ((char *)"Consistent Software CS2");
  case_624: /* CIL Label */ 
#line 182
  return ((char *)"Sony SCX / RealAudio 8.0");
  case_625: /* CIL Label */ 
#line 183
  return ((char *)"Sony SCY");
  case_626: /* CIL Label */ 
#line 184
  return ((char *)"Sony ATRAC3");
  case_627: /* CIL Label */ 
#line 185
  return ((char *)"Sony SPC");
  case_768: /* CIL Label */ 
#line 187
  return ((char *)"Fujitsu FM Towns Snd");
  case_1024: /* CIL Label */ 
#line 189
  return ((char *)"BTV Digital");
  case_1025: /* CIL Label */ 
#line 190
  return ((char *)"Intel Music Coder");
  case_1104: /* CIL Label */ 
#line 192
  return ((char *)"QDesign Music");
  case_1664: /* CIL Label */ 
#line 194
  return ((char *)"VME VMPCM");
  case_1665: /* CIL Label */ 
#line 195
  return ((char *)"AT&T Labs TPC");
  case_2222: /* CIL Label */ 
#line 197
  return ((char *)"ClearJump LiteWave");
  case_4096: /* CIL Label */ 
#line 199
  return ((char *)"Olivetti GSM");
  case_4097: /* CIL Label */ 
#line 200
  return ((char *)"Olivetti ADPCM");
  case_4098: /* CIL Label */ 
#line 201
  return ((char *)"Olivetti CELP");
  case_4099: /* CIL Label */ 
#line 202
  return ((char *)"Olivetti SBC");
  case_4100: /* CIL Label */ 
#line 203
  return ((char *)"Olivetti OPR");
  case_4352: /* CIL Label */ 
#line 205
  return ((char *)"L&H Codec");
  case_4353: /* CIL Label */ 
#line 206
  return ((char *)"L&H CELP");
  case_4354: /* CIL Label */ 
#line 207
  return ((char *)"L&H SBC 0x1102");
  case_4355: /* CIL Label */ 
#line 208
  return ((char *)"L&H SBC 0x1103");
  case_4356: /* CIL Label */ 
#line 209
  return ((char *)"L&H SBC 0x1104");
  case_5120: /* CIL Label */ 
#line 211
  return ((char *)"Norris");
  case_5121: /* CIL Label */ 
#line 212
  return ((char *)"AT&T ISIAudio");
  case_5376: /* CIL Label */ 
#line 214
  return ((char *)"Soundspace Music Compression");
  case_6172: /* CIL Label */ 
#line 216
  return ((char *)"VoxWare RT24 Speech");
  case_6513: /* CIL Label */ 
#line 218
  return ((char *)"Sonic Foundry Perfect Clarity Audio (PCA)");
  case_8132: /* CIL Label */ 
#line 220
  return ((char *)"NCT Soft ALF2CD");
  case_8192: /* CIL Label */ 
#line 222
  return ((char *)"Dolby AC3");
  case_8193: /* CIL Label */ 
#line 223
  return ((char *)"Dolby DTS");
  case_8194: /* CIL Label */ 
#line 224
  return ((char *)"RealAudio 1.0 (14.4K)");
  case_8195: /* CIL Label */ 
#line 225
  return ((char *)"RealAudio 2.0 (28.8K)");
  case_8196: /* CIL Label */ 
#line 226
  return ((char *)"RealAudio G2 (Cook)");
  case_8197: /* CIL Label */ 
#line 227
  return ((char *)"RealAudio 3.0 (DolbyNet AC3)");
  case_8198: /* CIL Label */ 
#line 228
  return ((char *)"RealAudio 10.0 (LC-AAC)");
  case_8199: /* CIL Label */ 
#line 229
  return ((char *)"RealAudio 10.0 (HE-AAC)");
  case_8264: /* CIL Label */ 
#line 231
  return ((char *)"Sonic");
  case_16707: /* CIL Label */ 
#line 233
  return ((char *)"Divio AAC");
  case_16897: /* CIL Label */ 
#line 235
  return ((char *)"Nokia AMR");
  case_22127: /* CIL Label */ 
#line 237
  return ((char *)"Vorbis");
  case_22358: /* CIL Label */ 
#line 239
  return ((char *)"WavPack");
  case_26447: /* CIL Label */ 
#line 241
  return ((char *)"Ogg Vorbis 1");
  case_26448: /* CIL Label */ 
#line 242
  return ((char *)"Ogg Vorbis 2");
  case_26449: /* CIL Label */ 
#line 243
  return ((char *)"Ogg Vorbis 3");
  case_26479: /* CIL Label */ 
#line 244
  return ((char *)"Ogg Vorbis 1+");
  case_26480: /* CIL Label */ 
#line 245
  return ((char *)"Ogg Vorbis 2+");
  case_26481: /* CIL Label */ 
#line 246
  return ((char *)"Ogg Vorbis 3+");
  case_31265: /* CIL Label */ 
#line 248
  return ((char *)"Adaptive Multirate");
  case_31266: /* CIL Label */ 
#line 249
  return ((char *)"Adaptive Multirate w/ silence detection");
  case_28781: /* CIL Label */ 
#line 251
  return ((char *)"AAC");
  case_30625: /* CIL Label */ 
#line 253
  return ((char *)"TTA");
  case_41222: /* CIL Label */ 
#line 255
  return ((char *)"MPEG-4 AAC");
  case_41225: /* CIL Label */ 
#line 257
  return ((char *)"Speex");
  case_61868: /* CIL Label */ 
#line 259
  return ((char *)"FLAC");
  case_65534: /* CIL Label */ 
#line 261
  return ((char *)"{ Extensible }");
  case_65535: /* CIL Label */ 
#line 262
  return ((char *)"{ Development }");
  switch_default: /* CIL Label */ 
#line 264
  return ((char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 273 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
static void wavinfo_print(WavInfo *wi ) 
{ 
  char *type ;
  int samples ;
  int leftover ;
  float playtime ;
  WavFile *wf ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 279
  wf = & wi->wf;
  {
#line 281
  type = get_format_name(wf->format);
  }
  {
#line 283
  printf((char const   */* __restrict  */)"\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
  }
  {
#line 284
  printf((char const   */* __restrict  */)"File:\n");
  }
  {
#line 285
  printf((char const   */* __restrict  */)"   Name:          %s\n", wi->fname);
  }
  }
#line 286
  if (wf->seekable) {
    {
    {
#line 287
    printf((char const   */* __restrict  */)"   File Size:     %d\n", wf->file_size);
    }
    }
  } else {
    {
    {
#line 289
    printf((char const   */* __restrict  */)"   File Size:     unknown\n");
    }
    }
  }
  {
  {
#line 291
  printf((char const   */* __restrict  */)"Format:\n");
  }
  }
#line 292
  if ((unsigned long )type == (unsigned long )((void *)0)) {
    {
    {
#line 293
    printf((char const   */* __restrict  */)"   Type:          unknown - 0x%04X\n",
           wf->format);
    }
    }
  } else {
    {
    {
#line 295
    printf((char const   */* __restrict  */)"   Type:          %s\n", type);
    }
    }
  }
  {
  {
#line 297
  printf((char const   */* __restrict  */)"   Channels:      %d\n", wf->channels);
  }
  {
#line 298
  printf((char const   */* __restrict  */)"   Sample Rate:   %d Hz\n", wf->sample_rate);
  }
  {
#line 299
  printf((char const   */* __restrict  */)"   Avg bytes/sec: %d\n", wf->bytes_per_sec);
  }
  {
#line 300
  printf((char const   */* __restrict  */)"   Block Align:   %d bytes\n", wf->block_align);
  }
  {
#line 301
  printf((char const   */* __restrict  */)"   Bit Width:     %d\n", wf->bit_width);
  }
  {
#line 302
  printf((char const   */* __restrict  */)"Data:\n");
  }
  {
#line 303
  printf((char const   */* __restrict  */)"   Start:         %d\n", wf->data_start);
  }
  {
#line 304
  printf((char const   */* __restrict  */)"   Data Size:     %d\n", wf->data_size);
  }
#line 305
  leftover = (int )((wf->file_size - wf->data_size) - wf->data_start);
  }
#line 306
  if (leftover < 0) {
#line 307
    if (! wf->seekable) {
      {
      {
#line 308
      printf((char const   */* __restrict  */)"   [ warning! unable to verify true data size ]\n");
      }
      }
    } else {
      {
      {
#line 310
      printf((char const   */* __restrict  */)"   [ warning! reported data size is larger than file size ]\n");
      }
      }
    }
  } else
#line 312
  if (leftover > 0) {
    {
    {
#line 313
    printf((char const   */* __restrict  */)"   Leftover:  %d bytes\n", leftover);
    }
    }
  }
#line 315
  if (wf->format == 1) {
    {
#line 316
    samples = (int )(wf->data_size / (uint32_t )wf->block_align);
#line 317
    playtime = (float )samples / (float )wf->sample_rate;
    {
#line 318
    printf((char const   */* __restrict  */)"   Samples:       %d\n", samples);
    }
    {
#line 319
    printf((char const   */* __restrict  */)"   Playing Time:  %0.2f sec\n", (double )playtime);
    }
    }
  } else
#line 315
  if (wf->format == 3) {
    {
#line 316
    samples = (int )(wf->data_size / (uint32_t )wf->block_align);
#line 317
    playtime = (float )samples / (float )wf->sample_rate;
    {
#line 318
    printf((char const   */* __restrict  */)"   Samples:       %d\n", samples);
    }
    {
#line 319
    printf((char const   */* __restrict  */)"   Playing Time:  %0.2f sec\n", (double )playtime);
    }
    }
  } else {
    {
    {
#line 321
    printf((char const   */* __restrict  */)"   Samples:       unknown\n");
    }
    {
#line 322
    printf((char const   */* __restrict  */)"   Playing Time:  unknown\n");
    }
    }
  }
  {
  {
#line 324
  printf((char const   */* __restrict  */)"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n");
  }
  }
#line 325
  return;
}
}
#line 327 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
static void wavfile_error(char *msg ) 
{ 
  char *__cil_tmp2 ;

  {
#line 330
  if ((unsigned long )msg != (unsigned long )((void *)0)) {
    {
    {
#line 331
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
    }
    }
  }
  {
  {
#line 333
  exit(1);
  }
  }
}
}
#line 179 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_u8___2(uint8_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  int16_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 184
  if ((int )fmt == 0) {
    {
    {
#line 185
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )n);
    }
    }
  } else
#line 186
  if ((int )fmt == 1) {
#line 187
    src = (int16_t *)src_v;
#line 188
    i = 0;
    {
    {
#line 188
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < n)) {
#line 188
        goto while_break;
      }
#line 189
      *(dest + i) = (uint8_t )(((int )*(src + i) >> 8) + 128);
#line 188
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 191
  if ((int )fmt == 2) {
#line 192
    src___0 = (int32_t *)src_v;
#line 193
    i = 0;
    {
    {
#line 193
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (i < n)) {
#line 193
        goto while_break___0;
      }
#line 194
      *(dest + i) = (uint8_t )((*(src___0 + i) >> 12) + 128);
#line 193
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 196
  if ((int )fmt == 3) {
#line 197
    src___1 = (int32_t *)src_v;
#line 198
    i = 0;
    {
    {
#line 198
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 198
      if (! (i < n)) {
#line 198
        goto while_break___1;
      }
#line 199
      *(dest + i) = (uint8_t )((*(src___1 + i) >> 16) + 128);
#line 198
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 201
  if ((int )fmt == 4) {
#line 202
    src___2 = (int32_t *)src_v;
#line 203
    i = 0;
    {
    {
#line 203
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 203
      if (! (i < n)) {
#line 203
        goto while_break___2;
      }
#line 204
      *(dest + i) = (uint8_t )((*(src___2 + i) >> 24) + 128);
#line 203
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 206
  if ((int )fmt == 5) {
#line 207
    src___3 = (float *)src_v;
#line 208
    i = 0;
    {
    {
#line 208
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 208
      if (! (i < n)) {
#line 208
        goto while_break___3;
      }
#line 209
      if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
        tmp___1 = (float )255;
      } else {
#line 209
        tmp___1 = *(src___3 + i) * (float )128 + (float )128;
      }
#line 209
      if (tmp___1 > (float )0) {
#line 209
        if (*(src___3 + i) * (float )128 + (float )128 > (float )255) {
#line 209
          tmp___0 = (float )255;
        } else {
#line 209
          tmp___0 = *(src___3 + i) * (float )128 + (float )128;
        }
#line 209
        v = (int )tmp___0;
      } else {
#line 209
        v = 0;
      }
#line 210
      *(dest + i) = (uint8_t )v;
#line 208
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 212
  if ((int )fmt == 6) {
#line 213
    src___4 = (double *)src_v;
#line 214
    i = 0;
    {
    {
#line 214
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 214
      if (! (i < n)) {
#line 214
        goto while_break___4;
      }
#line 215
      if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
        tmp___4 = (double )255;
      } else {
#line 215
        tmp___4 = *(src___4 + i) * (double )128 + (double )128;
      }
#line 215
      if (tmp___4 > (double )0) {
#line 215
        if (*(src___4 + i) * (double )128 + (double )128 > (double )255) {
#line 215
          tmp___3 = (double )255;
        } else {
#line 215
          tmp___3 = *(src___4 + i) * (double )128 + (double )128;
        }
#line 215
        v = (int )tmp___3;
      } else {
#line 215
        v = 0;
      }
#line 216
      *(dest + i) = (uint8_t )v;
#line 214
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 219
  return;
}
}
#line 221 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s16___2(int16_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int32_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 226
  if ((int )fmt == 0) {
#line 227
    src = (uint8_t *)src_v;
#line 228
    i = 0;
    {
    {
#line 228
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 228
      if (! (i < n)) {
#line 228
        goto while_break;
      }
#line 229
      *(dest + i) = (int16_t )(((int )*(src + i) - 128) << 8);
#line 228
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 231
  if ((int )fmt == 1) {
    {
    {
#line 232
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int16_t )));
    }
    }
  } else
#line 233
  if ((int )fmt == 2) {
#line 234
    src___0 = (int32_t *)src_v;
#line 235
    i = 0;
    {
    {
#line 235
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 235
      if (! (i < n)) {
#line 235
        goto while_break___0;
      }
#line 236
      *(dest + i) = (int16_t )(*(src___0 + i) >> 4);
#line 235
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 238
  if ((int )fmt == 3) {
#line 239
    src___1 = (int32_t *)src_v;
#line 240
    i = 0;
    {
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 240
      if (! (i < n)) {
#line 240
        goto while_break___1;
      }
#line 241
      *(dest + i) = (int16_t )(*(src___1 + i) >> 8);
#line 240
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 243
  if ((int )fmt == 4) {
#line 244
    src___2 = (int32_t *)src_v;
#line 245
    i = 0;
    {
    {
#line 245
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 245
      if (! (i < n)) {
#line 245
        goto while_break___2;
      }
#line 246
      *(dest + i) = (int16_t )(*(src___2 + i) >> 16);
#line 245
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 248
  if ((int )fmt == 5) {
#line 249
    src___3 = (float *)src_v;
#line 250
    i = 0;
    {
    {
#line 250
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 250
      if (! (i < n)) {
#line 250
        goto while_break___3;
      }
#line 251
      if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
        tmp___1 = (float )32767;
      } else {
#line 251
        tmp___1 = *(src___3 + i) * (float )32768;
      }
#line 251
      if (tmp___1 > (float )-32768) {
#line 251
        if (*(src___3 + i) * (float )32768 > (float )32767) {
#line 251
          tmp___0 = (float )32767;
        } else {
#line 251
          tmp___0 = *(src___3 + i) * (float )32768;
        }
#line 251
        v = (int )tmp___0;
      } else {
#line 251
        v = -32768;
      }
#line 252
      *(dest + i) = (int16_t )v;
#line 250
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 254
  if ((int )fmt == 6) {
#line 255
    src___4 = (double *)src_v;
#line 256
    i = 0;
    {
    {
#line 256
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 256
      if (! (i < n)) {
#line 256
        goto while_break___4;
      }
#line 257
      if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
        tmp___4 = (double )32767;
      } else {
#line 257
        tmp___4 = *(src___4 + i) * (double )32768;
      }
#line 257
      if (tmp___4 > (double )-32768) {
#line 257
        if (*(src___4 + i) * (double )32768 > (double )32767) {
#line 257
          tmp___3 = (double )32767;
        } else {
#line 257
          tmp___3 = *(src___4 + i) * (double )32768;
        }
#line 257
        v = (int )tmp___3;
      } else {
#line 257
        v = -32768;
      }
#line 258
      *(dest + i) = (int16_t )v;
#line 256
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s20___2(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 268
  if ((int )fmt == 0) {
#line 269
    src = (uint8_t *)src_v;
#line 270
    i = 0;
    {
    {
#line 270
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 270
      if (! (i < n)) {
#line 270
        goto while_break;
      }
#line 271
      *(dest + i) = ((int )*(src + i) - 128) << 12;
#line 270
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 273
  if ((int )fmt == 1) {
#line 274
    src___0 = (int16_t *)src_v;
#line 275
    i = 0;
    {
    {
#line 275
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! (i < n)) {
#line 275
        goto while_break___0;
      }
#line 276
      *(dest + i) = (int )*(src___0 + i) << 4;
#line 275
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 278
  if ((int )fmt == 2) {
    {
    {
#line 279
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 280
  if ((int )fmt == 3) {
#line 281
    src___1 = (int32_t *)src_v;
#line 282
    i = 0;
    {
    {
#line 282
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 282
      if (! (i < n)) {
#line 282
        goto while_break___1;
      }
#line 283
      *(dest + i) = *(src___1 + i) >> 4;
#line 282
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 285
  if ((int )fmt == 4) {
#line 286
    src___2 = (int32_t *)src_v;
#line 287
    i = 0;
    {
    {
#line 287
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 287
      if (! (i < n)) {
#line 287
        goto while_break___2;
      }
#line 288
      *(dest + i) = *(src___2 + i) >> 12;
#line 287
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 290
  if ((int )fmt == 5) {
#line 291
    src___3 = (float *)src_v;
#line 292
    i = 0;
    {
    {
#line 292
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 292
      if (! (i < n)) {
#line 292
        goto while_break___3;
      }
#line 293
      if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
        tmp___1 = (float )524287;
      } else {
#line 293
        tmp___1 = *(src___3 + i) * (float )524288;
      }
#line 293
      if (tmp___1 > (float )-524288) {
#line 293
        if (*(src___3 + i) * (float )524288 > (float )524287) {
#line 293
          tmp___0 = (float )524287;
        } else {
#line 293
          tmp___0 = *(src___3 + i) * (float )524288;
        }
#line 293
        v = (int )tmp___0;
      } else {
#line 293
        v = -524288;
      }
#line 294
      *(dest + i) = v;
#line 292
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 296
  if ((int )fmt == 6) {
#line 297
    src___4 = (double *)src_v;
#line 298
    i = 0;
    {
    {
#line 298
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 298
      if (! (i < n)) {
#line 298
        goto while_break___4;
      }
#line 299
      if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
        tmp___4 = (double )524287;
      } else {
#line 299
        tmp___4 = *(src___4 + i) * (double )524288;
      }
#line 299
      if (tmp___4 > (double )-524288) {
#line 299
        if (*(src___4 + i) * (double )524288 > (double )524287) {
#line 299
          tmp___3 = (double )524287;
        } else {
#line 299
          tmp___3 = *(src___4 + i) * (double )524288;
        }
#line 299
        v = (int )tmp___3;
      } else {
#line 299
        v = -524288;
      }
#line 300
      *(dest + i) = v;
#line 298
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s24___2(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  float tmp___0 ;
  float tmp___1 ;
  double *src___4 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 310
  if ((int )fmt == 0) {
#line 311
    src = (uint8_t *)src_v;
#line 312
    i = 0;
    {
    {
#line 312
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 312
      if (! (i < n)) {
#line 312
        goto while_break;
      }
#line 313
      *(dest + i) = ((int )*(src + i) - 128) << 16;
#line 312
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 315
  if ((int )fmt == 1) {
#line 316
    src___0 = (int16_t *)src_v;
#line 317
    i = 0;
    {
    {
#line 317
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! (i < n)) {
#line 317
        goto while_break___0;
      }
#line 318
      *(dest + i) = (int )*(src___0 + i) << 8;
#line 317
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 320
  if ((int )fmt == 2) {
#line 321
    src___1 = (int32_t *)src_v;
#line 322
    i = 0;
    {
    {
#line 322
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! (i < n)) {
#line 322
        goto while_break___1;
      }
#line 323
      *(dest + i) = *(src___1 + i) << 4;
#line 322
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 325
  if ((int )fmt == 3) {
    {
    {
#line 326
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 327
  if ((int )fmt == 4) {
#line 328
    src___2 = (int32_t *)src_v;
#line 329
    i = 0;
    {
    {
#line 329
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (i < n)) {
#line 329
        goto while_break___2;
      }
#line 330
      *(dest + i) = *(src___2 + i) >> 8;
#line 329
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 332
  if ((int )fmt == 5) {
#line 333
    src___3 = (float *)src_v;
#line 334
    i = 0;
    {
    {
#line 334
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 334
      if (! (i < n)) {
#line 334
        goto while_break___3;
      }
#line 335
      if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
        tmp___1 = (float )8388607;
      } else {
#line 335
        tmp___1 = *(src___3 + i) * (float )8388608;
      }
#line 335
      if (tmp___1 > (float )-8388608) {
#line 335
        if (*(src___3 + i) * (float )8388608 > (float )8388607) {
#line 335
          tmp___0 = (float )8388607;
        } else {
#line 335
          tmp___0 = *(src___3 + i) * (float )8388608;
        }
#line 335
        v = (int )tmp___0;
      } else {
#line 335
        v = -8388608;
      }
#line 336
      *(dest + i) = v;
#line 334
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 338
  if ((int )fmt == 6) {
#line 339
    src___4 = (double *)src_v;
#line 340
    i = 0;
    {
    {
#line 340
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 340
      if (! (i < n)) {
#line 340
        goto while_break___4;
      }
#line 341
      if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
        tmp___4 = (double )8388607;
      } else {
#line 341
        tmp___4 = *(src___4 + i) * (double )8388608;
      }
#line 341
      if (tmp___4 > (double )-8388608) {
#line 341
        if (*(src___4 + i) * (double )8388608 > (double )8388607) {
#line 341
          tmp___3 = (double )8388607;
        } else {
#line 341
          tmp___3 = *(src___4 + i) * (double )8388608;
        }
#line 341
        v = (int )tmp___3;
      } else {
#line 341
        v = -8388608;
      }
#line 342
      *(dest + i) = v;
#line 340
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 345
  return;
}
}
#line 347 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_s32___2(int32_t *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  int v ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  float *src___3 ;
  double *src___4 ;

  {
#line 352
  if ((int )fmt == 0) {
#line 353
    src = (uint8_t *)src_v;
#line 354
    i = 0;
    {
    {
#line 354
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 354
      if (! (i < n)) {
#line 354
        goto while_break;
      }
#line 355
      *(dest + i) = ((int )*(src + i) - 128) << 24;
#line 354
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 357
  if ((int )fmt == 1) {
#line 358
    src___0 = (int16_t *)src_v;
#line 359
    i = 0;
    {
    {
#line 359
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 359
      if (! (i < n)) {
#line 359
        goto while_break___0;
      }
#line 360
      *(dest + i) = (int )*(src___0 + i) << 16;
#line 359
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 362
  if ((int )fmt == 2) {
#line 363
    src___1 = (int32_t *)src_v;
#line 364
    i = 0;
    {
    {
#line 364
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (i < n)) {
#line 364
        goto while_break___1;
      }
#line 365
      *(dest + i) = *(src___1 + i) << 12;
#line 364
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 367
  if ((int )fmt == 3) {
#line 368
    src___2 = (int32_t *)src_v;
#line 369
    i = 0;
    {
    {
#line 369
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 369
      if (! (i < n)) {
#line 369
        goto while_break___2;
      }
#line 370
      *(dest + i) = *(src___2 + i) << 8;
#line 369
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 372
  if ((int )fmt == 4) {
    {
    {
#line 373
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(int32_t )));
    }
    }
  } else
#line 374
  if ((int )fmt == 5) {
#line 375
    src___3 = (float *)src_v;
#line 376
    i = 0;
    {
    {
#line 376
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 376
      if (! (i < n)) {
#line 376
        goto while_break___3;
      }
#line 377
      v = (int )(*(src___3 + i) * (float )2147483648LL);
#line 378
      *(dest + i) = v;
#line 376
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 380
  if ((int )fmt == 6) {
#line 381
    src___4 = (double *)src_v;
#line 382
    i = 0;
    {
    {
#line 382
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 382
      if (! (i < n)) {
#line 382
        goto while_break___4;
      }
#line 383
      v = (int )(*(src___4 + i) * (double )2147483648LL);
#line 384
      *(dest + i) = v;
#line 382
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 387
  return;
}
}
#line 389 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_float___2(float *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  double *src___4 ;

  {
#line 394
  if ((int )fmt == 0) {
#line 395
    src = (uint8_t *)src_v;
#line 396
    i = 0;
    {
    {
#line 396
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 396
      if (! (i < n)) {
#line 396
        goto while_break;
      }
#line 397
      *(dest + i) = (float )(((double )*(src + i) - 128.0) / 128.0);
#line 396
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 399
  if ((int )fmt == 1) {
#line 400
    src___0 = (int16_t *)src_v;
#line 401
    i = 0;
    {
    {
#line 401
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (i < n)) {
#line 401
        goto while_break___0;
      }
#line 402
      *(dest + i) = (float )((double )*(src___0 + i) / 32768.0);
#line 401
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 404
  if ((int )fmt == 2) {
#line 405
    src___1 = (int32_t *)src_v;
#line 406
    i = 0;
    {
    {
#line 406
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 406
      if (! (i < n)) {
#line 406
        goto while_break___1;
      }
#line 407
      *(dest + i) = (float )((double )*(src___1 + i) / 524288.0);
#line 406
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 409
  if ((int )fmt == 3) {
#line 410
    src___2 = (int32_t *)src_v;
#line 411
    i = 0;
    {
    {
#line 411
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 411
      if (! (i < n)) {
#line 411
        goto while_break___2;
      }
#line 412
      *(dest + i) = (float )((double )*(src___2 + i) / 8388608.0);
#line 411
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 414
  if ((int )fmt == 4) {
#line 415
    src___3 = (int32_t *)src_v;
#line 416
    i = 0;
    {
    {
#line 416
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 416
      if (! (i < n)) {
#line 416
        goto while_break___3;
      }
#line 417
      *(dest + i) = (float )((double )*(src___3 + i) / 2147483648.0);
#line 416
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 419
  if ((int )fmt == 5) {
    {
    {
#line 420
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(float )));
    }
    }
  } else
#line 421
  if ((int )fmt == 6) {
#line 422
    src___4 = (double *)src_v;
#line 423
    i = 0;
    {
    {
#line 423
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 423
      if (! (i < n)) {
#line 423
        goto while_break___4;
      }
#line 424
      *(dest + i) = (float )*(src___4 + i);
#line 423
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert_to_double___2(double *dest , void *src_v , int n , enum WavSampleFormat fmt ) 
{ 
  int i ;
  uint8_t *src ;
  int16_t *src___0 ;
  int32_t *src___1 ;
  int32_t *src___2 ;
  int32_t *src___3 ;
  float *src___4 ;

  {
#line 434
  if ((int )fmt == 0) {
#line 435
    src = (uint8_t *)src_v;
#line 436
    i = 0;
    {
    {
#line 436
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 436
      if (! (i < n)) {
#line 436
        goto while_break;
      }
#line 437
      *(dest + i) = ((double )*(src + i) - 128.0) / 128.0;
#line 436
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 439
  if ((int )fmt == 1) {
#line 440
    src___0 = (int16_t *)src_v;
#line 441
    i = 0;
    {
    {
#line 441
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 441
      if (! (i < n)) {
#line 441
        goto while_break___0;
      }
#line 442
      *(dest + i) = (double )*(src___0 + i) / 32768.0;
#line 441
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 444
  if ((int )fmt == 2) {
#line 445
    src___1 = (int32_t *)src_v;
#line 446
    i = 0;
    {
    {
#line 446
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 446
      if (! (i < n)) {
#line 446
        goto while_break___1;
      }
#line 447
      *(dest + i) = (double )*(src___1 + i) / 524288.0;
#line 446
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 449
  if ((int )fmt == 3) {
#line 450
    src___2 = (int32_t *)src_v;
#line 451
    i = 0;
    {
    {
#line 451
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 451
      if (! (i < n)) {
#line 451
        goto while_break___2;
      }
#line 452
      *(dest + i) = (double )*(src___2 + i) / 8388608.0;
#line 451
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 454
  if ((int )fmt == 4) {
#line 455
    src___3 = (int32_t *)src_v;
#line 456
    i = 0;
    {
    {
#line 456
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 456
      if (! (i < n)) {
#line 456
        goto while_break___3;
      }
#line 457
      *(dest + i) = (double )*(src___3 + i) / 2147483648.0;
#line 456
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 459
  if ((int )fmt == 5) {
#line 460
    src___4 = (float *)src_v;
#line 461
    i = 0;
    {
    {
#line 461
    while (1) {
      while_continue___10: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 461
      if (! (i < n)) {
#line 461
        goto while_break___4;
      }
#line 462
      *(dest + i) = (double )*(src___4 + i);
#line 461
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 464
  if ((int )fmt == 6) {
    {
    {
#line 465
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src_v,
           (size_t )((unsigned long )n * sizeof(double )));
    }
    }
  }
#line 467
  return;
}
}
#line 469 "/home/wslee/benchmarks/sound/flake-0.11/flake/wav.c"
static void fmt_convert___2(enum WavSampleFormat dest_fmt , void *dest , enum WavSampleFormat src_fmt ,
                            void *src , int n ) 
{ 


  {
  {
#line 474
  if ((int )dest_fmt == 0) {
#line 474
    goto case_0;
  }
#line 477
  if ((int )dest_fmt == 1) {
#line 477
    goto case_1;
  }
#line 480
  if ((int )dest_fmt == 2) {
#line 480
    goto case_2;
  }
#line 483
  if ((int )dest_fmt == 3) {
#line 483
    goto case_3;
  }
#line 486
  if ((int )dest_fmt == 4) {
#line 486
    goto case_4;
  }
#line 489
  if ((int )dest_fmt == 5) {
#line 489
    goto case_5;
  }
#line 492
  if ((int )dest_fmt == 6) {
#line 492
    goto case_6;
  }
#line 473
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 475
  fmt_convert_to_u8___2((uint8_t *)dest, src, n, src_fmt);
  }
  }
#line 476
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 478
  fmt_convert_to_s16___2((int16_t *)dest, src, n, src_fmt);
  }
  }
#line 479
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 481
  fmt_convert_to_s20___2((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 482
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 484
  fmt_convert_to_s24___2((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 485
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 487
  fmt_convert_to_s32___2((int32_t *)dest, src, n, src_fmt);
  }
  }
#line 488
  goto switch_break;
  case_5: /* CIL Label */ 
  {
  {
#line 490
  fmt_convert_to_float___2((float *)dest, src, n, src_fmt);
  }
  }
#line 491
  goto switch_break;
  case_6: /* CIL Label */ 
  {
  {
#line 493
  fmt_convert_to_double___2((double *)dest, src, n, src_fmt);
  }
  }
#line 494
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 11 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
static char *get_format_name___0(int id ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;

  {
#line 14
  if (id < 0) {
#line 14
    return ((char *)((void *)0));
  } else
#line 14
  if (id > 65535) {
#line 14
    return ((char *)((void *)0));
  }
  {
#line 16
  if (id == 0) {
#line 16
    goto case_0;
  }
#line 17
  if (id == 1) {
#line 17
    goto case_1;
  }
#line 18
  if (id == 2) {
#line 18
    goto case_2;
  }
#line 19
  if (id == 3) {
#line 19
    goto case_3;
  }
#line 20
  if (id == 4) {
#line 20
    goto case_4;
  }
#line 21
  if (id == 5) {
#line 21
    goto case_5;
  }
#line 22
  if (id == 6) {
#line 22
    goto case_6;
  }
#line 23
  if (id == 7) {
#line 23
    goto case_7;
  }
#line 24
  if (id == 8) {
#line 24
    goto case_8;
  }
#line 25
  if (id == 9) {
#line 25
    goto case_9;
  }
#line 26
  if (id == 10) {
#line 26
    goto case_10;
  }
#line 27
  if (id == 11) {
#line 27
    goto case_11;
  }
#line 29
  if (id == 16) {
#line 29
    goto case_16;
  }
#line 30
  if (id == 17) {
#line 30
    goto case_17;
  }
#line 31
  if (id == 18) {
#line 31
    goto case_18;
  }
#line 32
  if (id == 19) {
#line 32
    goto case_19;
  }
#line 33
  if (id == 20) {
#line 33
    goto case_20;
  }
#line 34
  if (id == 21) {
#line 34
    goto case_21;
  }
#line 35
  if (id == 22) {
#line 35
    goto case_22;
  }
#line 36
  if (id == 23) {
#line 36
    goto case_23;
  }
#line 37
  if (id == 24) {
#line 37
    goto case_24;
  }
#line 38
  if (id == 25) {
#line 38
    goto case_25;
  }
#line 40
  if (id == 32) {
#line 40
    goto case_32;
  }
#line 41
  if (id == 33) {
#line 41
    goto case_33;
  }
#line 42
  if (id == 34) {
#line 42
    goto case_34;
  }
#line 43
  if (id == 35) {
#line 43
    goto case_35;
  }
#line 44
  if (id == 36) {
#line 44
    goto case_36;
  }
#line 45
  if (id == 37) {
#line 45
    goto case_37;
  }
#line 46
  if (id == 38) {
#line 46
    goto case_38;
  }
#line 47
  if (id == 39) {
#line 47
    goto case_39;
  }
#line 48
  if (id == 40) {
#line 48
    goto case_40;
  }
#line 50
  if (id == 48) {
#line 50
    goto case_48;
  }
#line 51
  if (id == 49) {
#line 51
    goto case_49;
  }
#line 52
  if (id == 50) {
#line 52
    goto case_50;
  }
#line 53
  if (id == 51) {
#line 53
    goto case_51;
  }
#line 54
  if (id == 52) {
#line 54
    goto case_52;
  }
#line 55
  if (id == 53) {
#line 55
    goto case_53;
  }
#line 56
  if (id == 54) {
#line 56
    goto case_54;
  }
#line 57
  if (id == 55) {
#line 57
    goto case_55;
  }
#line 58
  if (id == 56) {
#line 58
    goto case_56;
  }
#line 59
  if (id == 57) {
#line 59
    goto case_57;
  }
#line 60
  if (id == 58) {
#line 60
    goto case_58;
  }
#line 61
  if (id == 59) {
#line 61
    goto case_59;
  }
#line 62
  if (id == 60) {
#line 62
    goto case_60;
  }
#line 63
  if (id == 61) {
#line 63
    goto case_61;
  }
#line 65
  if (id == 64) {
#line 65
    goto case_64;
  }
#line 66
  if (id == 65) {
#line 66
    goto case_65;
  }
#line 67
  if (id == 66) {
#line 67
    goto case_66;
  }
#line 68
  if (id == 67) {
#line 68
    goto case_67;
  }
#line 69
  if (id == 68) {
#line 69
    goto case_68;
  }
#line 70
  if (id == 69) {
#line 70
    goto case_69;
  }
#line 72
  if (id == 80) {
#line 72
    goto case_80;
  }
#line 74
  if (id == 82) {
#line 74
    goto case_82;
  }
#line 75
  if (id == 83) {
#line 75
    goto case_83;
  }
#line 77
  if (id == 85) {
#line 77
    goto case_85;
  }
#line 79
  if (id == 89) {
#line 79
    goto case_89;
  }
#line 81
  if (id == 96) {
#line 81
    goto case_96;
  }
#line 82
  if (id == 97) {
#line 82
    goto case_97;
  }
#line 83
  if (id == 98) {
#line 83
    goto case_98;
  }
#line 84
  if (id == 99) {
#line 84
    goto case_99;
  }
#line 85
  if (id == 100) {
#line 85
    goto case_100;
  }
#line 86
  if (id == 101) {
#line 86
    goto case_101;
  }
#line 87
  if (id == 102) {
#line 87
    goto case_102;
  }
#line 88
  if (id == 103) {
#line 88
    goto case_103;
  }
#line 90
  if (id == 105) {
#line 90
    goto case_105;
  }
#line 92
  if (id == 112) {
#line 92
    goto case_112;
  }
#line 93
  if (id == 113) {
#line 93
    goto case_113;
  }
#line 94
  if (id == 114) {
#line 94
    goto case_114;
  }
#line 95
  if (id == 115) {
#line 95
    goto case_115;
  }
#line 96
  if (id == 116) {
#line 96
    goto case_116;
  }
#line 97
  if (id == 117) {
#line 97
    goto case_117;
  }
#line 98
  if (id == 118) {
#line 98
    goto case_118;
  }
#line 99
  if (id == 119) {
#line 99
    goto case_119;
  }
#line 100
  if (id == 120) {
#line 100
    goto case_120;
  }
#line 101
  if (id == 121) {
#line 101
    goto case_121;
  }
#line 103
  if (id == 128) {
#line 103
    goto case_128;
  }
#line 104
  if (id == 129) {
#line 104
    goto case_129;
  }
#line 105
  if (id == 130) {
#line 105
    goto case_130;
  }
#line 106
  if (id == 131) {
#line 106
    goto case_131;
  }
#line 107
  if (id == 132) {
#line 107
    goto case_132;
  }
#line 108
  if (id == 133) {
#line 108
    goto case_133;
  }
#line 109
  if (id == 134) {
#line 109
    goto case_134;
  }
#line 111
  if (id == 136) {
#line 111
    goto case_136;
  }
#line 112
  if (id == 137) {
#line 112
    goto case_137;
  }
#line 114
  if (id == 145) {
#line 114
    goto case_145;
  }
#line 115
  if (id == 146) {
#line 115
    goto case_146;
  }
#line 116
  if (id == 147) {
#line 116
    goto case_147;
  }
#line 117
  if (id == 148) {
#line 117
    goto case_148;
  }
#line 119
  if (id == 151) {
#line 119
    goto case_151;
  }
#line 120
  if (id == 152) {
#line 120
    goto case_152;
  }
#line 121
  if (id == 153) {
#line 121
    goto case_153;
  }
#line 123
  if (id == 255) {
#line 123
    goto case_255;
  }
#line 125
  if (id == 256) {
#line 125
    goto case_256;
  }
#line 126
  if (id == 257) {
#line 126
    goto case_257;
  }
#line 127
  if (id == 258) {
#line 127
    goto case_258;
  }
#line 128
  if (id == 259) {
#line 128
    goto case_259;
  }
#line 130
  if (id == 273) {
#line 130
    goto case_273;
  }
#line 131
  if (id == 274) {
#line 131
    goto case_274;
  }
#line 133
  if (id == 291) {
#line 133
    goto case_291;
  }
#line 135
  if (id == 293) {
#line 135
    goto case_293;
  }
#line 137
  if (id == 304) {
#line 137
    goto case_304;
  }
#line 138
  if (id == 305) {
#line 138
    goto case_305;
  }
#line 139
  if (id == 306) {
#line 139
    goto case_306;
  }
#line 140
  if (id == 307) {
#line 140
    goto case_307;
  }
#line 141
  if (id == 308) {
#line 141
    goto case_308;
  }
#line 142
  if (id == 309) {
#line 142
    goto case_309;
  }
#line 144
  if (id == 320) {
#line 144
    goto case_320;
  }
#line 146
  if (id == 336) {
#line 146
    goto case_336;
  }
#line 147
  if (id == 337) {
#line 147
    goto case_337;
  }
#line 149
  if (id == 341) {
#line 149
    goto case_341;
  }
#line 151
  if (id == 352) {
#line 151
    goto case_352;
  }
#line 152
  if (id == 353) {
#line 152
    goto case_353;
  }
#line 153
  if (id == 354) {
#line 153
    goto case_354;
  }
#line 154
  if (id == 355) {
#line 154
    goto case_355;
  }
#line 155
  if (id == 356) {
#line 155
    goto case_356;
  }
#line 157
  if (id == 384) {
#line 157
    goto case_384;
  }
#line 159
  if (id == 400) {
#line 159
    goto case_400;
  }
#line 161
  if (id == 512) {
#line 161
    goto case_512;
  }
#line 163
  if (id == 514) {
#line 163
    goto case_514;
  }
#line 164
  if (id == 515) {
#line 164
    goto case_515;
  }
#line 166
  if (id == 528) {
#line 166
    goto case_528;
  }
#line 168
  if (id == 533) {
#line 168
    goto case_533;
  }
#line 169
  if (id == 534) {
#line 169
    goto case_534;
  }
#line 171
  if (id == 544) {
#line 171
    goto case_544;
  }
#line 173
  if (id == 560) {
#line 173
    goto case_560;
  }
#line 175
  if (id == 576) {
#line 175
    goto case_576;
  }
#line 177
  if (id == 592) {
#line 177
    goto case_592;
  }
#line 178
  if (id == 593) {
#line 178
    goto case_593;
  }
#line 180
  if (id == 608) {
#line 180
    goto case_608;
  }
#line 182
  if (id == 624) {
#line 182
    goto case_624;
  }
#line 183
  if (id == 625) {
#line 183
    goto case_625;
  }
#line 184
  if (id == 626) {
#line 184
    goto case_626;
  }
#line 185
  if (id == 627) {
#line 185
    goto case_627;
  }
#line 187
  if (id == 768) {
#line 187
    goto case_768;
  }
#line 189
  if (id == 1024) {
#line 189
    goto case_1024;
  }
#line 190
  if (id == 1025) {
#line 190
    goto case_1025;
  }
#line 192
  if (id == 1104) {
#line 192
    goto case_1104;
  }
#line 194
  if (id == 1664) {
#line 194
    goto case_1664;
  }
#line 195
  if (id == 1665) {
#line 195
    goto case_1665;
  }
#line 197
  if (id == 2222) {
#line 197
    goto case_2222;
  }
#line 199
  if (id == 4096) {
#line 199
    goto case_4096;
  }
#line 200
  if (id == 4097) {
#line 200
    goto case_4097;
  }
#line 201
  if (id == 4098) {
#line 201
    goto case_4098;
  }
#line 202
  if (id == 4099) {
#line 202
    goto case_4099;
  }
#line 203
  if (id == 4100) {
#line 203
    goto case_4100;
  }
#line 205
  if (id == 4352) {
#line 205
    goto case_4352;
  }
#line 206
  if (id == 4353) {
#line 206
    goto case_4353;
  }
#line 207
  if (id == 4354) {
#line 207
    goto case_4354;
  }
#line 208
  if (id == 4355) {
#line 208
    goto case_4355;
  }
#line 209
  if (id == 4356) {
#line 209
    goto case_4356;
  }
#line 211
  if (id == 5120) {
#line 211
    goto case_5120;
  }
#line 212
  if (id == 5121) {
#line 212
    goto case_5121;
  }
#line 214
  if (id == 5376) {
#line 214
    goto case_5376;
  }
#line 216
  if (id == 6172) {
#line 216
    goto case_6172;
  }
#line 218
  if (id == 6513) {
#line 218
    goto case_6513;
  }
#line 220
  if (id == 8132) {
#line 220
    goto case_8132;
  }
#line 222
  if (id == 8192) {
#line 222
    goto case_8192;
  }
#line 223
  if (id == 8193) {
#line 223
    goto case_8193;
  }
#line 224
  if (id == 8194) {
#line 224
    goto case_8194;
  }
#line 225
  if (id == 8195) {
#line 225
    goto case_8195;
  }
#line 226
  if (id == 8196) {
#line 226
    goto case_8196;
  }
#line 227
  if (id == 8197) {
#line 227
    goto case_8197;
  }
#line 228
  if (id == 8198) {
#line 228
    goto case_8198;
  }
#line 229
  if (id == 8199) {
#line 229
    goto case_8199;
  }
#line 231
  if (id == 8264) {
#line 231
    goto case_8264;
  }
#line 233
  if (id == 16707) {
#line 233
    goto case_16707;
  }
#line 235
  if (id == 16897) {
#line 235
    goto case_16897;
  }
#line 237
  if (id == 22127) {
#line 237
    goto case_22127;
  }
#line 239
  if (id == 22358) {
#line 239
    goto case_22358;
  }
#line 241
  if (id == 26447) {
#line 241
    goto case_26447;
  }
#line 242
  if (id == 26448) {
#line 242
    goto case_26448;
  }
#line 243
  if (id == 26449) {
#line 243
    goto case_26449;
  }
#line 244
  if (id == 26479) {
#line 244
    goto case_26479;
  }
#line 245
  if (id == 26480) {
#line 245
    goto case_26480;
  }
#line 246
  if (id == 26481) {
#line 246
    goto case_26481;
  }
#line 248
  if (id == 31265) {
#line 248
    goto case_31265;
  }
#line 249
  if (id == 31266) {
#line 249
    goto case_31266;
  }
#line 251
  if (id == 28781) {
#line 251
    goto case_28781;
  }
#line 253
  if (id == 30625) {
#line 253
    goto case_30625;
  }
#line 255
  if (id == 41222) {
#line 255
    goto case_41222;
  }
#line 257
  if (id == 41225) {
#line 257
    goto case_41225;
  }
#line 259
  if (id == 61868) {
#line 259
    goto case_61868;
  }
#line 261
  if (id == 65534) {
#line 261
    goto case_65534;
  }
#line 262
  if (id == 65535) {
#line 262
    goto case_65535;
  }
#line 264
  goto switch_default;
  case_0: /* CIL Label */ 
#line 16
  return ((char *)"Microsoft Unknown Wave Format");
  case_1: /* CIL Label */ 
#line 17
  return ((char *)"Microsoft PCM");
  case_2: /* CIL Label */ 
#line 18
  return ((char *)"Microsoft ADPCM");
  case_3: /* CIL Label */ 
#line 19
  return ((char *)"IEEE Float");
  case_4: /* CIL Label */ 
#line 20
  return ((char *)"Compaq Computer VSELP");
  case_5: /* CIL Label */ 
#line 21
  return ((char *)"IBM CVSD");
  case_6: /* CIL Label */ 
#line 22
  return ((char *)"Microsoft A-Law");
  case_7: /* CIL Label */ 
#line 23
  return ((char *)"Microsoft mu-Law");
  case_8: /* CIL Label */ 
#line 24
  return ((char *)"Microsoft DTS");
  case_9: /* CIL Label */ 
#line 25
  return ((char *)"Microsoft DRM Encrypted Audio");
  case_10: /* CIL Label */ 
#line 26
  return ((char *)"Windows Media Audio 9 Voice");
  case_11: /* CIL Label */ 
#line 27
  return ((char *)"Windows Media RT Voice");
  case_16: /* CIL Label */ 
#line 29
  return ((char *)"OKI ADPCM");
  case_17: /* CIL Label */ 
#line 30
  return ((char *)"Intel DVI/IMA ADPCM");
  case_18: /* CIL Label */ 
#line 31
  return ((char *)"Videologic MediaSpace ADPCM");
  case_19: /* CIL Label */ 
#line 32
  return ((char *)"Sierra ADPCM");
  case_20: /* CIL Label */ 
#line 33
  return ((char *)"Antex G.723 ADPCM");
  case_21: /* CIL Label */ 
#line 34
  return ((char *)"DSP Solutions DigiSTD");
  case_22: /* CIL Label */ 
#line 35
  return ((char *)"DSP Solutions DigiFIX");
  case_23: /* CIL Label */ 
#line 36
  return ((char *)"Dialogic OKI ADPCM");
  case_24: /* CIL Label */ 
#line 37
  return ((char *)"MediaVision ADPCM");
  case_25: /* CIL Label */ 
#line 38
  return ((char *)"Hewlett-Packard CU");
  case_32: /* CIL Label */ 
#line 40
  return ((char *)"Yamaha ADPCM");
  case_33: /* CIL Label */ 
#line 41
  return ((char *)"Speech Compression Sonarc");
  case_34: /* CIL Label */ 
#line 42
  return ((char *)"DSP Group TrueSpeech");
  case_35: /* CIL Label */ 
#line 43
  return ((char *)"Echo Speech EchoSC1");
  case_36: /* CIL Label */ 
#line 44
  return ((char *)"Audiofile AF36");
  case_37: /* CIL Label */ 
#line 45
  return ((char *)"Audio Processing Technology APTX");
  case_38: /* CIL Label */ 
#line 46
  return ((char *)"AudioFile AF10");
  case_39: /* CIL Label */ 
#line 47
  return ((char *)"Prosody 1612");
  case_40: /* CIL Label */ 
#line 48
  return ((char *)"LRC");
  case_48: /* CIL Label */ 
#line 50
  return ((char *)"Dolby AC2");
  case_49: /* CIL Label */ 
#line 51
  return ((char *)"Microsoft GSM 6.10");
  case_50: /* CIL Label */ 
#line 52
  return ((char *)"MSNAudio");
  case_51: /* CIL Label */ 
#line 53
  return ((char *)"Antex ADPCME");
  case_52: /* CIL Label */ 
#line 54
  return ((char *)"Control Resources VQLPC");
  case_53: /* CIL Label */ 
#line 55
  return ((char *)"DigiREAL");
  case_54: /* CIL Label */ 
#line 56
  return ((char *)"DigiADPCM");
  case_55: /* CIL Label */ 
#line 57
  return ((char *)"Control Resources CR10");
  case_56: /* CIL Label */ 
#line 58
  return ((char *)"Natural MicroSystems VBXADPCM");
  case_57: /* CIL Label */ 
#line 59
  return ((char *)"Crystal IMA ADPCM");
  case_58: /* CIL Label */ 
#line 60
  return ((char *)"EchoSC3");
  case_59: /* CIL Label */ 
#line 61
  return ((char *)"Rockwell ADPCM");
  case_60: /* CIL Label */ 
#line 62
  return ((char *)"Rockwell Digit LK");
  case_61: /* CIL Label */ 
#line 63
  return ((char *)"Xebec");
  case_64: /* CIL Label */ 
#line 65
  return ((char *)"Antex Electronics G.721 ADPCM");
  case_65: /* CIL Label */ 
#line 66
  return ((char *)"G.728 CELP");
  case_66: /* CIL Label */ 
#line 67
  return ((char *)"MS G.723");
  case_67: /* CIL Label */ 
#line 68
  return ((char *)"MS G.723.1");
  case_68: /* CIL Label */ 
#line 69
  return ((char *)"MS G.729");
  case_69: /* CIL Label */ 
#line 70
  return ((char *)"SP G.726");
  case_80: /* CIL Label */ 
#line 72
  return ((char *)"MPEG Layer-2 or Layer-1");
  case_82: /* CIL Label */ 
#line 74
  return ((char *)"RT24");
  case_83: /* CIL Label */ 
#line 75
  return ((char *)"PAC");
  case_85: /* CIL Label */ 
#line 77
  return ((char *)"MPEG Layer-3");
  case_89: /* CIL Label */ 
#line 79
  return ((char *)"Lucent G.723");
  case_96: /* CIL Label */ 
#line 81
  return ((char *)"Cirrus");
  case_97: /* CIL Label */ 
#line 82
  return ((char *)"ESPCM");
  case_98: /* CIL Label */ 
#line 83
  return ((char *)"Voxware");
  case_99: /* CIL Label */ 
#line 84
  return ((char *)"Canopus Atrac");
  case_100: /* CIL Label */ 
#line 85
  return ((char *)"G.726 ADPCM");
  case_101: /* CIL Label */ 
#line 86
  return ((char *)"G.722 ADPCM");
  case_102: /* CIL Label */ 
#line 87
  return ((char *)"DSAT");
  case_103: /* CIL Label */ 
#line 88
  return ((char *)"DSAT Display");
  case_105: /* CIL Label */ 
#line 90
  return ((char *)"Voxware Byte Aligned");
  case_112: /* CIL Label */ 
#line 92
  return ((char *)"Voxware AC8");
  case_113: /* CIL Label */ 
#line 93
  return ((char *)"Voxware AC10");
  case_114: /* CIL Label */ 
#line 94
  return ((char *)"Voxware AC16");
  case_115: /* CIL Label */ 
#line 95
  return ((char *)"Voxware AC20");
  case_116: /* CIL Label */ 
#line 96
  return ((char *)"Voxware MetaVoice");
  case_117: /* CIL Label */ 
#line 97
  return ((char *)"Voxware MetaSound");
  case_118: /* CIL Label */ 
#line 98
  return ((char *)"Voxware RT29HW");
  case_119: /* CIL Label */ 
#line 99
  return ((char *)"Voxware VR12");
  case_120: /* CIL Label */ 
#line 100
  return ((char *)"Voxware VR18");
  case_121: /* CIL Label */ 
#line 101
  return ((char *)"Voxware TQ40");
  case_128: /* CIL Label */ 
#line 103
  return ((char *)"Softsound");
  case_129: /* CIL Label */ 
#line 104
  return ((char *)"Voxware TQ60");
  case_130: /* CIL Label */ 
#line 105
  return ((char *)"MSRT24");
  case_131: /* CIL Label */ 
#line 106
  return ((char *)"G.729A");
  case_132: /* CIL Label */ 
#line 107
  return ((char *)"MVI MV12");
  case_133: /* CIL Label */ 
#line 108
  return ((char *)"DF G.726");
  case_134: /* CIL Label */ 
#line 109
  return ((char *)"DF GSM610");
  case_136: /* CIL Label */ 
#line 111
  return ((char *)"ISIAudio");
  case_137: /* CIL Label */ 
#line 112
  return ((char *)"Onlive");
  case_145: /* CIL Label */ 
#line 114
  return ((char *)"SBC24");
  case_146: /* CIL Label */ 
#line 115
  return ((char *)"Dolby AC3 SPDIF");
  case_147: /* CIL Label */ 
#line 116
  return ((char *)"MediaSonic G.723");
  case_148: /* CIL Label */ 
#line 117
  return ((char *)"Aculab PLC  Prosody 8kbps");
  case_151: /* CIL Label */ 
#line 119
  return ((char *)"ZyXEL ADPCM");
  case_152: /* CIL Label */ 
#line 120
  return ((char *)"Philips LPCBB");
  case_153: /* CIL Label */ 
#line 121
  return ((char *)"Packed");
  case_255: /* CIL Label */ 
#line 123
  return ((char *)"AAC");
  case_256: /* CIL Label */ 
#line 125
  return ((char *)"Rhetorex ADPCM");
  case_257: /* CIL Label */ 
#line 126
  return ((char *)"IBM mu-law");
  case_258: /* CIL Label */ 
#line 127
  return ((char *)"IBM A-law");
  case_259: /* CIL Label */ 
#line 128
  return ((char *)"IBM AVC ADPCM");
  case_273: /* CIL Label */ 
#line 130
  return ((char *)"Vivo G.723");
  case_274: /* CIL Label */ 
#line 131
  return ((char *)"Vivo Siren");
  case_291: /* CIL Label */ 
#line 133
  return ((char *)"Digital G.723");
  case_293: /* CIL Label */ 
#line 135
  return ((char *)"Sanyo LD ADPCM");
  case_304: /* CIL Label */ 
#line 137
  return ((char *)"Sipro Lab Telecom ACELP NET / RealAudio 4.0/5.0)");
  case_305: /* CIL Label */ 
#line 138
  return ((char *)"Sipro Lab Telecom ACELP 4800");
  case_306: /* CIL Label */ 
#line 139
  return ((char *)"Sipro Lab Telecom ACELP 8V3");
  case_307: /* CIL Label */ 
#line 140
  return ((char *)"Sipro Lab Telecom G.729");
  case_308: /* CIL Label */ 
#line 141
  return ((char *)"Sipro Lab Telecom G.729A");
  case_309: /* CIL Label */ 
#line 142
  return ((char *)"Sipro Lab Telecom Kelvin");
  case_320: /* CIL Label */ 
#line 144
  return ((char *)"Windows Media Video V8");
  case_336: /* CIL Label */ 
#line 146
  return ((char *)"Qualcomm PureVoice");
  case_337: /* CIL Label */ 
#line 147
  return ((char *)"Qualcomm HalfRate");
  case_341: /* CIL Label */ 
#line 149
  return ((char *)"Ring Zero Systems TUB GSM");
  case_352: /* CIL Label */ 
#line 151
  return ((char *)"Microsoft Audio 1");
  case_353: /* CIL Label */ 
#line 152
  return ((char *)"Windows Media 7/8/9");
  case_354: /* CIL Label */ 
#line 153
  return ((char *)"Windows Media 9 Professional");
  case_355: /* CIL Label */ 
#line 154
  return ((char *)"Windows Media 9 Lossess");
  case_356: /* CIL Label */ 
#line 155
  return ((char *)"Windows Media Professional over S/PDIF");
  case_384: /* CIL Label */ 
#line 157
  return ((char *)"MPEG-2 AAC");
  case_400: /* CIL Label */ 
#line 159
  return ((char *)"DTS");
  case_512: /* CIL Label */ 
#line 161
  return ((char *)"Creative Labs ADPCM");
  case_514: /* CIL Label */ 
#line 163
  return ((char *)"Creative Labs FastSpeech8");
  case_515: /* CIL Label */ 
#line 164
  return ((char *)"Creative Labs FastSpeech10");
  case_528: /* CIL Label */ 
#line 166
  return ((char *)"UHER Informatic GmbH ADPCM");
  case_533: /* CIL Label */ 
#line 168
  return ((char *)"Ulead DV Audio NTSC");
  case_534: /* CIL Label */ 
#line 169
  return ((char *)"Ulead DV Audio PAL");
  case_544: /* CIL Label */ 
#line 171
  return ((char *)"Quarterdeck");
  case_560: /* CIL Label */ 
#line 173
  return ((char *)"I-link Worldwide VC");
  case_576: /* CIL Label */ 
#line 175
  return ((char *)"Aureal RAW Sport");
  case_592: /* CIL Label */ 
#line 177
  return ((char *)"Interactive Products HSX");
  case_593: /* CIL Label */ 
#line 178
  return ((char *)"Interactive Products RPELP");
  case_608: /* CIL Label */ 
#line 180
  return ((char *)"Consistent Software CS2");
  case_624: /* CIL Label */ 
#line 182
  return ((char *)"Sony SCX / RealAudio 8.0");
  case_625: /* CIL Label */ 
#line 183
  return ((char *)"Sony SCY");
  case_626: /* CIL Label */ 
#line 184
  return ((char *)"Sony ATRAC3");
  case_627: /* CIL Label */ 
#line 185
  return ((char *)"Sony SPC");
  case_768: /* CIL Label */ 
#line 187
  return ((char *)"Fujitsu FM Towns Snd");
  case_1024: /* CIL Label */ 
#line 189
  return ((char *)"BTV Digital");
  case_1025: /* CIL Label */ 
#line 190
  return ((char *)"Intel Music Coder");
  case_1104: /* CIL Label */ 
#line 192
  return ((char *)"QDesign Music");
  case_1664: /* CIL Label */ 
#line 194
  return ((char *)"VME VMPCM");
  case_1665: /* CIL Label */ 
#line 195
  return ((char *)"AT&T Labs TPC");
  case_2222: /* CIL Label */ 
#line 197
  return ((char *)"ClearJump LiteWave");
  case_4096: /* CIL Label */ 
#line 199
  return ((char *)"Olivetti GSM");
  case_4097: /* CIL Label */ 
#line 200
  return ((char *)"Olivetti ADPCM");
  case_4098: /* CIL Label */ 
#line 201
  return ((char *)"Olivetti CELP");
  case_4099: /* CIL Label */ 
#line 202
  return ((char *)"Olivetti SBC");
  case_4100: /* CIL Label */ 
#line 203
  return ((char *)"Olivetti OPR");
  case_4352: /* CIL Label */ 
#line 205
  return ((char *)"L&H Codec");
  case_4353: /* CIL Label */ 
#line 206
  return ((char *)"L&H CELP");
  case_4354: /* CIL Label */ 
#line 207
  return ((char *)"L&H SBC 0x1102");
  case_4355: /* CIL Label */ 
#line 208
  return ((char *)"L&H SBC 0x1103");
  case_4356: /* CIL Label */ 
#line 209
  return ((char *)"L&H SBC 0x1104");
  case_5120: /* CIL Label */ 
#line 211
  return ((char *)"Norris");
  case_5121: /* CIL Label */ 
#line 212
  return ((char *)"AT&T ISIAudio");
  case_5376: /* CIL Label */ 
#line 214
  return ((char *)"Soundspace Music Compression");
  case_6172: /* CIL Label */ 
#line 216
  return ((char *)"VoxWare RT24 Speech");
  case_6513: /* CIL Label */ 
#line 218
  return ((char *)"Sonic Foundry Perfect Clarity Audio (PCA)");
  case_8132: /* CIL Label */ 
#line 220
  return ((char *)"NCT Soft ALF2CD");
  case_8192: /* CIL Label */ 
#line 222
  return ((char *)"Dolby AC3");
  case_8193: /* CIL Label */ 
#line 223
  return ((char *)"Dolby DTS");
  case_8194: /* CIL Label */ 
#line 224
  return ((char *)"RealAudio 1.0 (14.4K)");
  case_8195: /* CIL Label */ 
#line 225
  return ((char *)"RealAudio 2.0 (28.8K)");
  case_8196: /* CIL Label */ 
#line 226
  return ((char *)"RealAudio G2 (Cook)");
  case_8197: /* CIL Label */ 
#line 227
  return ((char *)"RealAudio 3.0 (DolbyNet AC3)");
  case_8198: /* CIL Label */ 
#line 228
  return ((char *)"RealAudio 10.0 (LC-AAC)");
  case_8199: /* CIL Label */ 
#line 229
  return ((char *)"RealAudio 10.0 (HE-AAC)");
  case_8264: /* CIL Label */ 
#line 231
  return ((char *)"Sonic");
  case_16707: /* CIL Label */ 
#line 233
  return ((char *)"Divio AAC");
  case_16897: /* CIL Label */ 
#line 235
  return ((char *)"Nokia AMR");
  case_22127: /* CIL Label */ 
#line 237
  return ((char *)"Vorbis");
  case_22358: /* CIL Label */ 
#line 239
  return ((char *)"WavPack");
  case_26447: /* CIL Label */ 
#line 241
  return ((char *)"Ogg Vorbis 1");
  case_26448: /* CIL Label */ 
#line 242
  return ((char *)"Ogg Vorbis 2");
  case_26449: /* CIL Label */ 
#line 243
  return ((char *)"Ogg Vorbis 3");
  case_26479: /* CIL Label */ 
#line 244
  return ((char *)"Ogg Vorbis 1+");
  case_26480: /* CIL Label */ 
#line 245
  return ((char *)"Ogg Vorbis 2+");
  case_26481: /* CIL Label */ 
#line 246
  return ((char *)"Ogg Vorbis 3+");
  case_31265: /* CIL Label */ 
#line 248
  return ((char *)"Adaptive Multirate");
  case_31266: /* CIL Label */ 
#line 249
  return ((char *)"Adaptive Multirate w/ silence detection");
  case_28781: /* CIL Label */ 
#line 251
  return ((char *)"AAC");
  case_30625: /* CIL Label */ 
#line 253
  return ((char *)"TTA");
  case_41222: /* CIL Label */ 
#line 255
  return ((char *)"MPEG-4 AAC");
  case_41225: /* CIL Label */ 
#line 257
  return ((char *)"Speex");
  case_61868: /* CIL Label */ 
#line 259
  return ((char *)"FLAC");
  case_65534: /* CIL Label */ 
#line 261
  return ((char *)"{ Extensible }");
  case_65535: /* CIL Label */ 
#line 262
  return ((char *)"{ Development }");
  switch_default: /* CIL Label */ 
#line 264
  return ((char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 273 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
static void wavinfo_print___0(WavInfo *wi ) 
{ 
  char *type ;
  int samples ;
  int leftover ;
  float playtime ;
  WavFile *wf ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 279
  wf = & wi->wf;
  {
#line 281
  type = get_format_name___0(wf->format);
  }
  {
#line 283
  printf((char const   */* __restrict  */)"\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
  }
  {
#line 284
  printf((char const   */* __restrict  */)"File:\n");
  }
  {
#line 285
  printf((char const   */* __restrict  */)"   Name:          %s\n", wi->fname);
  }
  }
#line 286
  if (wf->seekable) {
    {
    {
#line 287
    printf((char const   */* __restrict  */)"   File Size:     %d\n", wf->file_size);
    }
    }
  } else {
    {
    {
#line 289
    printf((char const   */* __restrict  */)"   File Size:     unknown\n");
    }
    }
  }
  {
  {
#line 291
  printf((char const   */* __restrict  */)"Format:\n");
  }
  }
#line 292
  if ((unsigned long )type == (unsigned long )((void *)0)) {
    {
    {
#line 293
    printf((char const   */* __restrict  */)"   Type:          unknown - 0x%04X\n",
           wf->format);
    }
    }
  } else {
    {
    {
#line 295
    printf((char const   */* __restrict  */)"   Type:          %s\n", type);
    }
    }
  }
  {
  {
#line 297
  printf((char const   */* __restrict  */)"   Channels:      %d\n", wf->channels);
  }
  {
#line 298
  printf((char const   */* __restrict  */)"   Sample Rate:   %d Hz\n", wf->sample_rate);
  }
  {
#line 299
  printf((char const   */* __restrict  */)"   Avg bytes/sec: %d\n", wf->bytes_per_sec);
  }
  {
#line 300
  printf((char const   */* __restrict  */)"   Block Align:   %d bytes\n", wf->block_align);
  }
  {
#line 301
  printf((char const   */* __restrict  */)"   Bit Width:     %d\n", wf->bit_width);
  }
  {
#line 302
  printf((char const   */* __restrict  */)"Data:\n");
  }
  {
#line 303
  printf((char const   */* __restrict  */)"   Start:         %d\n", wf->data_start);
  }
  {
#line 304
  printf((char const   */* __restrict  */)"   Data Size:     %d\n", wf->data_size);
  }
#line 305
  leftover = (int )((wf->file_size - wf->data_size) - wf->data_start);
  }
#line 306
  if (leftover < 0) {
#line 307
    if (! wf->seekable) {
      {
      {
#line 308
      printf((char const   */* __restrict  */)"   [ warning! unable to verify true data size ]\n");
      }
      }
    } else {
      {
      {
#line 310
      printf((char const   */* __restrict  */)"   [ warning! reported data size is larger than file size ]\n");
      }
      }
    }
  } else
#line 312
  if (leftover > 0) {
    {
    {
#line 313
    printf((char const   */* __restrict  */)"   Leftover:  %d bytes\n", leftover);
    }
    }
  }
#line 315
  if (wf->format == 1) {
    {
#line 316
    samples = (int )(wf->data_size / (uint32_t )wf->block_align);
#line 317
    playtime = (float )samples / (float )wf->sample_rate;
    {
#line 318
    printf((char const   */* __restrict  */)"   Samples:       %d\n", samples);
    }
    {
#line 319
    printf((char const   */* __restrict  */)"   Playing Time:  %0.2f sec\n", (double )playtime);
    }
    }
  } else
#line 315
  if (wf->format == 3) {
    {
#line 316
    samples = (int )(wf->data_size / (uint32_t )wf->block_align);
#line 317
    playtime = (float )samples / (float )wf->sample_rate;
    {
#line 318
    printf((char const   */* __restrict  */)"   Samples:       %d\n", samples);
    }
    {
#line 319
    printf((char const   */* __restrict  */)"   Playing Time:  %0.2f sec\n", (double )playtime);
    }
    }
  } else {
    {
    {
#line 321
    printf((char const   */* __restrict  */)"   Samples:       unknown\n");
    }
    {
#line 322
    printf((char const   */* __restrict  */)"   Playing Time:  unknown\n");
    }
    }
  }
  {
  {
#line 324
  printf((char const   */* __restrict  */)"=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n");
  }
  }
#line 325
  return;
}
}
#line 327 "/home/wslee/benchmarks/sound/flake-0.11/util/wavinfo.c"
static void wavfile_error___0(char *msg ) 
{ 
  char *__cil_tmp2 ;

  {
#line 330
  if ((unsigned long )msg != (unsigned long )((void *)0)) {
    {
    {
#line 331
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
    }
    }
  }
  {
  {
#line 333
  exit(1);
  }
  }
}
}
