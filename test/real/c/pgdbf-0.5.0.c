/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 195 "/usr/include/sys/types.h"
typedef signed char int8_t;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 198 "/usr/include/sys/types.h"
typedef long int64_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 123 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
struct __anonstruct_DBFHEADER_27 {
   int8_t signature ;
   int8_t year ;
   int8_t month ;
   int8_t day ;
   uint32_t recordcount ;
   uint16_t headerlength ;
   uint16_t recordlength ;
   int8_t reserved1[2] ;
   int8_t incomplete ;
   int8_t encrypted ;
   int8_t reserved2[4] ;
   int8_t reserved3[8] ;
   int8_t mdx ;
   int8_t language ;
   int8_t reserved4[2] ;
};
#line 123 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
typedef struct __anonstruct_DBFHEADER_27 DBFHEADER;
#line 141 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
struct __anonstruct_DBFFIELD_28 {
   char name[11] ;
   char type ;
   int32_t memaddress ;
   uint8_t length ;
   uint8_t decimals ;
   int16_t flags ;
   char workareaid ;
   char reserved1[2] ;
   char setfields ;
   char reserved2[7] ;
   char indexfield ;
};
#line 141 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
typedef struct __anonstruct_DBFFIELD_28 DBFFIELD;
#line 156 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
struct __anonstruct_MEMOHEADER_29 {
   char nextblock[4] ;
   char reserved1[2] ;
   char blocksize[2] ;
   char reserved2[504] ;
};
#line 156 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
typedef struct __anonstruct_MEMOHEADER_29 MEMOHEADER;
#line 164 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
struct __anonstruct_PGFIELD_30 {
   char *formatstring ;
   int memonumbering ;
};
#line 164 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
typedef struct __anonstruct_PGFIELD_30 PGFIELD;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 116
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 313
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 562
extern int putchar(int __c ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 58 "/usr/include/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
#line 77
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 38 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static char staticbuf[1048577]  ;
#line 44 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static char const   *RESERVEDWORDS[76]  = 
#line 44
  {      "all",      "analyse",      "analyze",      "and", 
        "any",      "array",      "as",      "asc", 
        "asymmetric",      "both",      "case",      "cast", 
        "check",      "collate",      "column",      "constraint", 
        "create",      "current_date",      "current_role",      "current_time", 
        "current_timestamp",      "current_user",      "default",      "deferrable", 
        "desc",      "distinct",      "do",      "else", 
        "end",      "except",      "false",      "for", 
        "foreign",      "from",      "grant",      "group", 
        "having",      "in",      "initially",      "intersect", 
        "into",      "leading",      "limit",      "localtime", 
        "localtimestamp",      "new",      "not",      "null", 
        "off",      "offset",      "old",      "on", 
        "only",      "or",      "order",      "placing", 
        "primary",      "references",      "returning",      "select", 
        "session_user",      "some",      "symmetric",      "table", 
        "then",      "to",      "trailing",      "true", 
        "union",      "unique",      "user",      "using", 
        "when",      "where",      "with",      (char const   *)((void *)0)};
#line 170 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static void exitwitherror(char const   *message , int const   systemerror ) 
{ 
  char *__cil_tmp3 ;

  {
#line 174
  if (systemerror) {
    {
    {
#line 175
    perror(message);
    }
    }
  } else {
    {
    {
#line 177
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            message);
    }
    }
  }
  {
  {
#line 179
  exit(1);
  }
  }
}
}
#line 182 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static void safeprintbuf(char const   *buf , size_t const   inputsize ) 
{ 
  char *targetbuf ;
  char const   *s ;
  char const   *lastchar ;
  char *t ;
  int realsize ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 190
  realsize = 0;
#line 193
  if ((int const   )*buf == 0) {
#line 194
    return;
  }
#line 198
  s = (buf + inputsize) - 1;
  {
  {
#line 198
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )s >= (unsigned long )buf)) {
#line 198
      goto while_break;
    }
#line 199
    if ((int const   )*s != 32) {
#line 199
      if ((int const   )*s != 0) {
#line 200
        goto while_break;
      }
    }
#line 198
    s --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if ((unsigned long )s < (unsigned long )buf) {
#line 205
    return;
  }
#line 208
  lastchar = s;
#line 209
  realsize = (int )((s - buf) + 1L);
#line 210
  if (realsize * 2 < 1048576) {
#line 211
    targetbuf = staticbuf;
  } else {
    {
    {
#line 213
    tmp = malloc((size_t )(realsize * 2 + 1));
    }
#line 213
    targetbuf = (char *)tmp;
    }
#line 214
    if ((unsigned long )targetbuf == (unsigned long )((void *)0)) {
      {
      {
#line 215
      exitwitherror("Unable to malloc the escape output buffer", (int const   )1);
      }
      }
    }
  }
#line 220
  t = targetbuf;
#line 221
  s = buf;
  {
  {
#line 221
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 221
    if (! ((unsigned long )s <= (unsigned long )lastchar)) {
#line 221
      goto while_break___0;
    }
    {
#line 223
    if ((int const   )*s == 92) {
#line 223
      goto case_92;
    }
#line 227
    if ((int const   )*s == 10) {
#line 227
      goto case_10;
    }
#line 231
    if ((int const   )*s == 13) {
#line 231
      goto case_13;
    }
#line 235
    if ((int const   )*s == 9) {
#line 235
      goto case_9;
    }
#line 239
    goto switch_default;
    case_92: /* CIL Label */ 
#line 224
    tmp___0 = t;
#line 224
    t ++;
#line 224
    *tmp___0 = (char )'\\';
#line 225
    tmp___1 = t;
#line 225
    t ++;
#line 225
    *tmp___1 = (char )'\\';
#line 226
    goto switch_break;
    case_10: /* CIL Label */ 
#line 228
    tmp___2 = t;
#line 228
    t ++;
#line 228
    *tmp___2 = (char )'\\';
#line 229
    tmp___3 = t;
#line 229
    t ++;
#line 229
    *tmp___3 = (char )'n';
#line 230
    goto switch_break;
    case_13: /* CIL Label */ 
#line 232
    tmp___4 = t;
#line 232
    t ++;
#line 232
    *tmp___4 = (char )'\\';
#line 233
    tmp___5 = t;
#line 233
    t ++;
#line 233
    *tmp___5 = (char )'r';
#line 234
    goto switch_break;
    case_9: /* CIL Label */ 
#line 236
    tmp___6 = t;
#line 236
    t ++;
#line 236
    *tmp___6 = (char )'\\';
#line 237
    tmp___7 = t;
#line 237
    t ++;
#line 237
    *tmp___7 = (char )'t';
#line 238
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 240
    tmp___8 = t;
#line 240
    t ++;
#line 240
    *tmp___8 = (char )*s;
    switch_break: /* CIL Label */ ;
    }
#line 221
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 243
  *t = (char )'\000';
  {
#line 244
  printf((char const   */* __restrict  */)"%s", targetbuf);
  }
  }
#line 246
  if ((unsigned long )targetbuf != (unsigned long )(staticbuf)) {
    {
    {
#line 247
    free((void *)targetbuf);
    }
    }
  }
#line 249
  return;
}
}
#line 275 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t nativeint32_t(int32_t const   rightend ) 
{ 


  {
#line 278
  return ((int32_t )rightend);
}
}
#line 281 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t swappedint32_t(int32_t const   wrongend ) 
{ 


  {
#line 284
  return ((int32_t )((((((unsigned int )wrongend & 4278190080U) >> 24) | (unsigned int )((wrongend & 16711680) >> 8)) | (unsigned int )((wrongend & 65280) << 8)) | (unsigned int )((wrongend & 255) << 24)));
}
}
#line 290 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int16_t nativeint16_t(int16_t const   rightend ) 
{ 


  {
#line 293
  return ((int16_t )rightend);
}
}
#line 296 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int16_t swappedint16_t(int16_t const   wrongend ) 
{ 


  {
#line 299
  return ((int16_t )((((int const   )wrongend & 65280) >> 8) | (((int const   )wrongend & 255) << 8)));
}
}
#line 305 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int64_t snativeint64_t(char const   *buf ) 
{ 
  int64_t output ;

  {
  {
  {
#line 309
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )8);
  }
  }
#line 310
  return (output);
}
}
#line 321 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t snativeint32_t(char const   *buf ) 
{ 
  int32_t output ;

  {
  {
  {
#line 325
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )4);
  }
  }
#line 326
  return (output);
}
}
#line 329 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t sswappedint32_t(char const   *buf ) 
{ 
  int32_t output ;
  int32_t tmp ;

  {
  {
  {
#line 333
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )4);
  }
  {
#line 334
  tmp = swappedint32_t((int32_t const   )output);
  }
  }
#line 334
  return (tmp);
}
}
#line 345 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int16_t sswappedint16_t(char const   *buf ) 
{ 
  int16_t output ;
  int16_t tmp ;

  {
  {
  {
#line 349
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )2);
  }
  {
#line 350
  tmp = swappedint16_t((int16_t const   )output);
  }
  }
#line 350
  return (tmp);
}
}
#line 403 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static double sdouble(char const   *buf ) 
{ 
  double output ;

  {
  {
  {
#line 407
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )8);
  }
  }
#line 408
  return (output);
}
}
#line 345 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.c"
extern int ( /* missing proto */  asprintf)() ;
#line 33 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.c"
int main(int argc , char **argv ) 
{ 
  char *dbffilename ;
  FILE *dbffile ;
  DBFHEADER dbfheader ;
  DBFFIELD *fields ;
  PGFIELD *pgfields ;
  size_t dbffieldsize ;
  size_t fieldcount ;
  unsigned int recordbase ;
  unsigned int dbfbatchsize ;
  unsigned int batchindex ;
  int skipbytes ;
  int fieldarraysize ;
  int fieldnum ;
  uint8_t terminator ;
  char *memofilename ;
  int memofd ;
  struct stat memostat ;
  int32_t memoblocknumber ;
  void *memomap ;
  char *memorecord ;
  size_t memoblocksize ;
  char *inputbuffer ;
  char *outputbuffer ;
  char *bufoffset ;
  char *s ;
  char *t ;
  int lastcharwasreplaced ;
  int32_t juliandays ;
  int32_t seconds ;
  int hours ;
  int minutes ;
  int i ;
  int isreservedname ;
  int printed ;
  size_t blocksread ;
  size_t longestfield ;
  int opt ;
  int optexitcode ;
  int usecreatetable ;
  int usedroptable ;
  int useifexists ;
  int usetransaction ;
  char *tablename ;
  char fieldname[11] ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int16_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int16_t tmp___14 ;
  int tmp___15 ;
  int16_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int16_t tmp___22 ;
  int16_t tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  int16_t tmp___26 ;
  int32_t tmp___27 ;
  int16_t tmp___28 ;
  double tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int32_t tmp___41 ;
  int32_t tmp___42 ;
  int32_t tmp___43 ;
  int64_t tmp___44 ;
  int tmp___45 ;
  int32_t tmp___46 ;
  unsigned short const   **tmp___47 ;
  int tmp___48 ;
  void *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;

  {
#line 55
  memofilename = (char *)((void *)0);
#line 60
  memomap = (void *)0;
#line 62
  memoblocksize = (size_t )0;
#line 70
  lastcharwasreplaced = 0;
#line 82
  longestfield = (size_t )32;
#line 88
  optexitcode = -1;
#line 92
  usecreatetable = 1;
#line 93
  usedroptable = 1;
#line 94
  useifexists = 0;
#line 95
  usetransaction = 1;
  {
  {
#line 102
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 102
    opt = getopt(argc, (char * const  *)argv, "cCdDehm:tT");
    }
    }
#line 102
    if (! (opt != -1)) {
#line 102
      goto while_break;
    }
    {
#line 104
    if (opt == 99) {
#line 104
      goto case_99;
    }
#line 107
    if (opt == 67) {
#line 107
      goto case_67;
    }
#line 110
    if (opt == 100) {
#line 110
      goto case_100;
    }
#line 113
    if (opt == 68) {
#line 113
      goto case_68;
    }
#line 116
    if (opt == 101) {
#line 116
      goto case_101;
    }
#line 119
    if (opt == 109) {
#line 119
      goto case_109;
    }
#line 122
    if (opt == 116) {
#line 122
      goto case_116;
    }
#line 125
    if (opt == 84) {
#line 125
      goto case_84;
    }
#line 129
    goto switch_default;
    case_99: /* CIL Label */ 
#line 105
    usecreatetable = 1;
#line 106
    goto switch_break;
    case_67: /* CIL Label */ 
#line 108
    usecreatetable = 0;
#line 109
    goto switch_break;
    case_100: /* CIL Label */ 
#line 111
    usedroptable = 1;
#line 112
    goto switch_break;
    case_68: /* CIL Label */ 
#line 114
    usedroptable = 0;
#line 115
    goto switch_break;
    case_101: /* CIL Label */ 
#line 117
    useifexists = 1;
#line 118
    goto switch_break;
    case_109: /* CIL Label */ 
#line 120
    memofilename = optarg;
#line 121
    goto switch_break;
    case_116: /* CIL Label */ 
#line 123
    usetransaction = 1;
#line 124
    goto switch_break;
    case_84: /* CIL Label */ 
#line 126
    usetransaction = 0;
#line 127
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 133
    if ((int )((char )opt) == 104) {
#line 133
      optexitcode = 0;
    } else {
#line 133
      optexitcode = 1;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (optexitcode != 0) {
#line 139
    if (optind > argc - 1) {
#line 140
      optexitcode = 1;
    }
  }
#line 143
  if (optexitcode != -1) {
    {
    {
#line 144
    printf((char const   */* __restrict  */)"Usage: %s [-cCdDehtT] [-m memofilename] filename [indexcolumn ...]\n",
           "pgdbf");
    }
    {
#line 145
    printf((char const   */* __restrict  */)"Convert the named XBase file into PostgreSQL format\n");
    }
    {
#line 146
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 147
    printf((char const   */* __restrict  */)"  -c  issue a \'CREATE TABLE\' command to create the table (default)\n");
    }
    {
#line 148
    printf((char const   */* __restrict  */)"  -C  do not issue a \'CREATE TABLE\' command\n");
    }
    {
#line 149
    printf((char const   */* __restrict  */)"  -d  issue a \'DROP TABLE\' command before creating the table (default)\n");
    }
    {
#line 150
    printf((char const   */* __restrict  */)"  -D  do not issue a \'DROP TABLE\' command\n");
    }
    {
#line 151
    printf((char const   */* __restrict  */)"  -e  use \'IF EXISTS\' when dropping tables (PostgreSQL 8.2+)\n");
    }
    {
#line 152
    printf((char const   */* __restrict  */)"  -h  print this message and exit\n");
    }
    {
#line 153
    printf((char const   */* __restrict  */)"  -m  the name of the associated memo file (if necessary)\n");
    }
    {
#line 154
    printf((char const   */* __restrict  */)"  -t  wrap a transaction around the entire series of statements (default)\n");
    }
    {
#line 155
    printf((char const   */* __restrict  */)"  -T  do not use an enclosing transaction\n");
    }
    {
#line 156
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 157
    printf((char const   */* __restrict  */)"%s is copyright 2009 Daycos.\n", "PgDBF 0.5.0");
    }
    {
#line 158
    printf((char const   */* __restrict  */)"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n");
    }
    {
#line 159
    printf((char const   */* __restrict  */)"This is free software: you are free to change and redistribute it.\n");
    }
    {
#line 160
    printf((char const   */* __restrict  */)"There is NO WARRANTY, to the extent permitted by law.\n");
    }
    {
#line 161
    printf((char const   */* __restrict  */)"Report bugs to <%s>\n", "kirk@daycos.com");
    }
    {
#line 162
    exit(optexitcode);
    }
    }
  }
#line 166
  if (! usecreatetable) {
#line 169
    usedroptable = 0;
  }
  {
#line 173
  dbffilename = *(argv + optind);
  {
#line 174
  tmp = strlen((char const   *)dbffilename);
  }
  {
#line 174
  tmp___0 = malloc(tmp + 1U);
  }
#line 174
  tablename = (char *)tmp___0;
  }
#line 175
  if ((unsigned long )tablename == (unsigned long )((void *)0)) {
    {
    {
#line 176
    exitwitherror("Unable to allocate the tablename buffer", (int const   )1);
    }
    }
  }
  {
  {
#line 181
  tmp___1 = strlen((char const   *)dbffilename);
  }
#line 181
  s = (dbffilename + tmp___1) - 1;
  }
  {
  {
#line 181
  while (1) {
    while_continue___15: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )s != (unsigned long )dbffilename)) {
#line 181
      goto while_break___0;
    }
#line 182
    if ((int )*s == 47) {
#line 183
      s ++;
#line 184
      goto while_break___0;
    }
#line 181
    s --;
  }
  while_break___15: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 187
  t = tablename;
  {
  {
#line 188
  while (1) {
    while_continue___16: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 188
    if (! *s) {
#line 188
      goto while_break___1;
    }
#line 189
    if ((int )*s == 46) {
#line 190
      goto while_break___1;
    }
    {
#line 192
    tmp___2 = t;
#line 192
    t ++;
#line 192
    tmp___3 = s;
#line 192
    s ++;
    {
#line 192
    tmp___4 = tolower((int )*tmp___3);
    }
#line 192
    *tmp___2 = (char )tmp___4;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 194
  *t = (char )'\000';
  {
#line 197
  dbffile = fopen((char const   */* __restrict  */)dbffilename, (char const   */* __restrict  */)"rb");
  }
  }
#line 198
  if ((unsigned long )dbffile == (unsigned long )((void *)0)) {
    {
    {
#line 199
    exitwitherror("Unable to open the DBF file", (int const   )1);
    }
    }
  }
  {
  {
#line 201
  tmp___5 = setvbuf((FILE */* __restrict  */)dbffile, (char */* __restrict  */)((void *)0),
                    0, (size_t )131072);
  }
  }
#line 201
  if (tmp___5) {
    {
    {
#line 202
    exitwitherror("Unable to set the buffer for the dbf file", (int const   )1);
    }
    }
  }
  {
  {
#line 204
  tmp___6 = fread((void */* __restrict  */)(& dbfheader), (size_t )sizeof(dbfheader),
                  (size_t )1, (FILE */* __restrict  */)dbffile);
  }
  }
#line 204
  if (tmp___6 != 1U) {
    {
    {
#line 205
    exitwitherror("Unable to read the entire DBF header", (int const   )1);
    }
    }
  }
#line 208
  if ((int )dbfheader.signature == 48) {
#line 212
    skipbytes = 263;
  } else {
#line 214
    skipbytes = 0;
  }
  {
#line 218
  dbffieldsize = (size_t )sizeof(DBFFIELD );
  {
#line 219
  tmp___7 = nativeint16_t((int16_t const   )dbfheader.headerlength);
  }
#line 219
  fieldarraysize = (int )((((unsigned long )tmp___7 - sizeof(dbfheader)) - (unsigned long )skipbytes) - 1UL);
  }
#line 220
  if ((unsigned int )fieldarraysize % dbffieldsize == 1U) {
#line 225
    skipbytes ++;
#line 226
    fieldarraysize --;
  } else
#line 227
  if ((unsigned int )fieldarraysize % dbffieldsize) {
    {
    {
#line 228
    exitwitherror("The field array size is not an even multiple of the database field size",
                  (int const   )0);
    }
    }
  }
  {
#line 230
  fieldcount = (size_t )fieldarraysize / dbffieldsize;
  {
#line 233
  tmp___8 = malloc((size_t )fieldarraysize);
  }
#line 233
  fields = (DBFFIELD *)tmp___8;
  }
#line 234
  if ((unsigned long )fields == (unsigned long )((void *)0)) {
    {
    {
#line 235
    exitwitherror("Unable to malloc the field descriptions", (int const   )1);
    }
    }
  }
  {
  {
#line 237
  tmp___9 = fread((void */* __restrict  */)fields, dbffieldsize, fieldcount, (FILE */* __restrict  */)dbffile);
  }
  }
#line 237
  if (tmp___9 != fieldcount) {
    {
    {
#line 238
    exitwitherror("Unable to read all of the field descriptions", (int const   )1);
    }
    }
  }
  {
  {
#line 242
  tmp___10 = malloc((size_t )((unsigned long )fieldcount * sizeof(PGFIELD )));
  }
#line 242
  pgfields = (PGFIELD *)tmp___10;
  }
#line 243
  if ((unsigned long )pgfields == (unsigned long )((void *)0)) {
    {
    {
#line 244
    exitwitherror("Unable to malloc the output parameter list", (int const   )1);
    }
    }
  }
#line 246
  i = 0;
  {
  {
#line 246
  while (1) {
    while_continue___17: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 246
    if (! ((size_t )i < fieldcount)) {
#line 246
      goto while_break___2;
    }
#line 247
    (pgfields + i)->formatstring = (char *)((void *)0);
#line 246
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 251
  tmp___11 = fread((void */* __restrict  */)(& terminator), (size_t )1, (size_t )1,
                   (FILE */* __restrict  */)dbffile);
  }
  }
#line 251
  if (tmp___11 != 1U) {
    {
    {
#line 252
    exitwitherror("Unable to read the terminator byte", (int const   )1);
    }
    }
  }
#line 254
  if ((int )terminator != 13) {
    {
    {
#line 255
    exitwitherror("Invalid terminator byte", (int const   )0);
    }
    }
  }
  {
  {
#line 259
  tmp___12 = fseek(dbffile, (long )skipbytes, 1);
  }
  }
#line 259
  if (tmp___12) {
    {
    {
#line 260
    exitwitherror("Unable to seek in the DBF file", (int const   )1);
    }
    }
  }
  {
  {
#line 264
  tmp___13 = ftell(dbffile);
  }
  {
#line 264
  tmp___14 = nativeint16_t((int16_t const   )dbfheader.headerlength);
  }
  }
#line 264
  if (tmp___13 != (long )tmp___14) {
    {
    {
#line 265
    exitwitherror("At an unexpected offset in the DBF file", (int const   )0);
    }
    }
  }
#line 269
  if ((unsigned long )memofilename != (unsigned long )((void *)0)) {
    {
    {
#line 270
    memofd = open((char const   *)memofilename, 0);
    }
    }
#line 271
    if (memofd == -1) {
      {
      {
#line 272
      exitwitherror("Unable to open the memofile", (int const   )1);
      }
      }
    }
    {
    {
#line 274
    tmp___15 = fstat(memofd, & memostat);
    }
    }
#line 274
    if (tmp___15 == -1) {
      {
      {
#line 275
      exitwitherror("Unable to fstat the memofile", (int const   )1);
      }
      }
    }
    {
    {
#line 277
    memomap = mmap((void *)0, (size_t )memostat.st_size, 1, 2, memofd, (__off_t )0);
    }
    }
#line 278
    if ((unsigned long )memomap == (unsigned long )((void *)-1)) {
      {
      {
#line 279
      exitwitherror("Unable to mmap the memofile", (int const   )1);
      }
      }
    }
#line 281
    if ((int )dbfheader.signature == -125) {
#line 282
      memoblocksize = (size_t )512;
    } else {
      {
      {
#line 284
      tmp___16 = sswappedint16_t((char const   *)(((MEMOHEADER *)memomap)->blocksize));
      }
#line 284
      memoblocksize = (size_t )tmp___16;
      }
    }
  }
#line 289
  if (usetransaction) {
    {
    {
#line 290
    printf((char const   */* __restrict  */)"BEGIN;\n");
    }
    }
  }
#line 294
  if (usedroptable) {
    {
    {
#line 295
    printf((char const   */* __restrict  */)"SET statement_timeout=60000; DROP TABLE");
    }
    }
#line 298
    if (useifexists) {
      {
      {
#line 299
      printf((char const   */* __restrict  */)" IF EXISTS");
      }
      }
    }
    {
    {
#line 301
    printf((char const   */* __restrict  */)" %s; SET statement_timeout=0;\n", tablename);
    }
    }
  }
#line 308
  if (usecreatetable) {
    {
    {
#line 308
    printf((char const   */* __restrict  */)"CREATE TABLE %s (", tablename);
    }
    }
  }
#line 309
  printed = 0;
#line 310
  fieldnum = 0;
  {
  {
#line 310
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 310
    if (! ((size_t )fieldnum < fieldcount)) {
#line 310
      goto while_break___3;
    }
#line 311
    if ((int )(fields + fieldnum)->type == 48) {
#line 312
      goto __Cont;
    }
#line 314
    if (printed) {
#line 314
      if (usecreatetable) {
#line 315
        if (usecreatetable) {
          {
          {
#line 315
          printf((char const   */* __restrict  */)", ");
          }
          }
        }
      } else {
#line 318
        printed = 1;
      }
    } else {
#line 318
      printed = 1;
    }
#line 321
    s = (fields + fieldnum)->name;
#line 322
    t = fieldname;
    {
    {
#line 323
    while (1) {
      while_continue___19: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 323
      if (! *s) {
#line 323
        goto while_break___4;
      }
      {
#line 324
      tmp___17 = t;
#line 324
      t ++;
#line 324
      tmp___18 = s;
#line 324
      s ++;
      {
#line 324
      tmp___19 = tolower((int )*tmp___18);
      }
#line 324
      *tmp___17 = (char )tmp___19;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 326
    *t = (char )'\000';
#line 330
    isreservedname = 0;
#line 331
    i = 0;
    {
    {
#line 331
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 331
      if (! RESERVEDWORDS[i]) {
#line 331
        goto while_break___5;
      }
      {
      {
#line 332
      tmp___20 = strcmp((char const   *)(fieldname), RESERVEDWORDS[i]);
      }
      }
#line 332
      if (! tmp___20) {
#line 333
        if (usecreatetable) {
          {
          {
#line 333
          printf((char const   */* __restrict  */)"%s_%s ", tablename, fieldname);
          }
          }
        }
#line 334
        isreservedname = 1;
#line 335
        goto while_break___5;
      }
#line 331
      i ++;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 338
    if (! isreservedname) {
#line 339
      if (usecreatetable) {
        {
        {
#line 339
        printf((char const   */* __restrict  */)"%s ", fieldname);
        }
        }
      }
    }
    {
#line 342
    if ((int )(fields + fieldnum)->type == 66) {
#line 342
      goto case_66;
    }
#line 350
    if ((int )(fields + fieldnum)->type == 67) {
#line 350
      goto case_67___0;
    }
#line 353
    if ((int )(fields + fieldnum)->type == 68) {
#line 353
      goto case_68___0;
    }
#line 356
    if ((int )(fields + fieldnum)->type == 70) {
#line 356
      goto case_70;
    }
#line 359
    if ((int )(fields + fieldnum)->type == 71) {
#line 359
      goto case_71;
    }
#line 362
    if ((int )(fields + fieldnum)->type == 73) {
#line 362
      goto case_73;
    }
#line 365
    if ((int )(fields + fieldnum)->type == 76) {
#line 365
      goto case_76;
    }
#line 368
    if ((int )(fields + fieldnum)->type == 77) {
#line 368
      goto case_77;
    }
#line 385
    if ((int )(fields + fieldnum)->type == 78) {
#line 385
      goto case_78;
    }
#line 391
    if ((int )(fields + fieldnum)->type == 84) {
#line 391
      goto case_84___0;
    }
#line 394
    if ((int )(fields + fieldnum)->type == 89) {
#line 394
      goto case_89;
    }
#line 397
    goto switch_default___0;
    case_66: /* CIL Label */ 
    {
    {
#line 345
    tmp___21 = asprintf(& (pgfields + fieldnum)->formatstring, "%%.%dlf", (int )(fields + fieldnum)->decimals);
    }
    }
#line 345
    if (tmp___21 < 0) {
      {
      {
#line 346
      exitwitherror("Unable to allocate a format string", (int const   )1);
      }
      }
    }
#line 348
    if (usecreatetable) {
      {
      {
#line 348
      printf((char const   */* __restrict  */)"DOUBLE PRECISION");
      }
      }
    }
#line 349
    goto switch_break___0;
    case_67___0: /* CIL Label */ 
#line 351
    if (usecreatetable) {
      {
      {
#line 351
      printf((char const   */* __restrict  */)"VARCHAR(%d)", (int )(fields + fieldnum)->length);
      }
      }
    }
#line 352
    goto switch_break___0;
    case_68___0: /* CIL Label */ 
#line 354
    if (usecreatetable) {
      {
      {
#line 354
      printf((char const   */* __restrict  */)"DATE");
      }
      }
    }
#line 355
    goto switch_break___0;
    case_70: /* CIL Label */ 
#line 357
    if (usecreatetable) {
      {
      {
#line 357
      printf((char const   */* __restrict  */)"NUMERIC(%d)", (int )(fields + fieldnum)->decimals);
      }
      }
    }
#line 358
    goto switch_break___0;
    case_71: /* CIL Label */ 
#line 360
    if (usecreatetable) {
      {
      {
#line 360
      printf((char const   */* __restrict  */)"BYTEA");
      }
      }
    }
#line 361
    goto switch_break___0;
    case_73: /* CIL Label */ 
#line 363
    if (usecreatetable) {
      {
      {
#line 363
      printf((char const   */* __restrict  */)"INTEGER");
      }
      }
    }
#line 364
    goto switch_break___0;
    case_76: /* CIL Label */ 
#line 367
    if (usecreatetable) {
      {
      {
#line 367
      printf((char const   */* __restrict  */)"BOOLEAN");
      }
      }
    }
#line 367
    goto switch_break___0;
    case_77: /* CIL Label */ 
#line 369
    if ((unsigned long )memofilename == (unsigned long )((void *)0)) {
      {
      {
#line 370
      printf((char const   */* __restrict  */)"\n");
      }
      {
#line 371
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Table %s has memo fields, but couldn\'t open the related memo file\n",
              tablename);
      }
      {
#line 372
      exit(1);
      }
      }
    }
#line 374
    if (usecreatetable) {
      {
      {
#line 374
      printf((char const   */* __restrict  */)"TEXT");
      }
      }
    }
#line 377
    if ((int )(fields + fieldnum)->length == 4) {
#line 378
      (pgfields + fieldnum)->memonumbering = 1;
    } else
#line 379
    if ((int )(fields + fieldnum)->length == 10) {
#line 380
      (pgfields + fieldnum)->memonumbering = 0;
    } else {
      {
      {
#line 382
      exitwitherror("Unknown memo record number style", (int const   )0);
      }
      }
    }
#line 384
    goto switch_break___0;
    case_78: /* CIL Label */ 
#line 389
    if (usecreatetable) {
      {
      {
#line 389
      printf((char const   */* __restrict  */)"TEXT");
      }
      }
    }
#line 390
    goto switch_break___0;
    case_84___0: /* CIL Label */ 
#line 392
    if (usecreatetable) {
      {
      {
#line 392
      printf((char const   */* __restrict  */)"TIMESTAMP");
      }
      }
    }
#line 393
    goto switch_break___0;
    case_89: /* CIL Label */ 
#line 395
    if (usecreatetable) {
      {
      {
#line 395
      printf((char const   */* __restrict  */)"DECIMAL(4)");
      }
      }
    }
#line 396
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 398
    if (usecreatetable) {
      {
      {
#line 398
      printf((char const   */* __restrict  */)"\n");
      }
      }
    }
    {
    {
#line 399
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unhandled field type: %c\n",
            (int )(fields + fieldnum)->type);
    }
    {
#line 400
    exit(1);
    }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 402
    if ((size_t )(fields + fieldnum)->length > longestfield) {
#line 403
      longestfield = (size_t )(fields + fieldnum)->length;
    }
    __Cont: /* CIL Label */ 
#line 310
    fieldnum ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 406
  if (usecreatetable) {
    {
    {
#line 406
    printf((char const   */* __restrict  */)");\n");
    }
    }
  }
  {
  {
#line 409
  printf((char const   */* __restrict  */)"\\COPY %s FROM STDIN\n", tablename);
  }
  {
#line 411
  tmp___22 = nativeint16_t((int16_t const   )dbfheader.recordlength);
  }
#line 411
  dbfbatchsize = (unsigned int )(131072 / (int )tmp___22);
  }
#line 412
  if (! dbfbatchsize) {
#line 413
    dbfbatchsize = 1U;
  }
  {
  {
#line 415
  tmp___23 = nativeint16_t((int16_t const   )dbfheader.recordlength);
  }
  {
#line 415
  tmp___24 = malloc((unsigned int )tmp___23 * dbfbatchsize);
  }
#line 415
  inputbuffer = (char *)tmp___24;
  }
#line 416
  if ((unsigned long )inputbuffer == (unsigned long )((void *)0)) {
    {
    {
#line 417
    exitwitherror("Unable to malloc a record buffer", (int const   )1);
    }
    }
  }
  {
  {
#line 419
  tmp___25 = malloc(longestfield + 1U);
  }
#line 419
  outputbuffer = (char *)tmp___25;
  }
#line 420
  if ((unsigned long )outputbuffer == (unsigned long )((void *)0)) {
    {
    {
#line 421
    exitwitherror("Unable to malloc the output buffer", (int const   )1);
    }
    }
  }
#line 426
  recordbase = 0U;
  {
  {
#line 426
  while (1) {
    while_continue___21: /* CIL Label */ ;
    while_continue___6: /* CIL Label */ ;
    {
    {
#line 426
    tmp___46 = nativeint32_t((int32_t const   )dbfheader.recordcount);
    }
    }
#line 426
    if (! (recordbase < (unsigned int )tmp___46)) {
#line 426
      goto while_break___6;
    }
    {
    {
#line 427
    tmp___26 = nativeint16_t((int16_t const   )dbfheader.recordlength);
    }
    {
#line 427
    blocksread = fread((void */* __restrict  */)inputbuffer, (size_t )tmp___26, dbfbatchsize,
                       (FILE */* __restrict  */)dbffile);
    }
    }
#line 428
    if (blocksread != dbfbatchsize) {
      {
      {
#line 428
      tmp___27 = nativeint32_t((int32_t const   )dbfheader.recordcount);
      }
      }
#line 428
      if (recordbase + blocksread < (unsigned int )tmp___27) {
        {
        {
#line 430
        exitwitherror("Unable to read an entire record", (int const   )1);
        }
        }
      }
    }
#line 432
    batchindex = 0U;
    {
    {
#line 432
    while (1) {
      while_continue___22: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 432
      if (! (batchindex < blocksread)) {
#line 432
        goto while_break___7;
      }
      {
      {
#line 433
      tmp___28 = nativeint16_t((int16_t const   )dbfheader.recordlength);
      }
#line 433
      bufoffset = inputbuffer + (unsigned int )tmp___28 * batchindex;
      }
#line 435
      if ((int )*(bufoffset + 0) == 42) {
#line 436
        goto __Cont___0;
      }
#line 438
      bufoffset ++;
#line 439
      fieldnum = 0;
      {
      {
#line 439
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 439
        if (! ((size_t )fieldnum < fieldcount)) {
#line 439
          goto while_break___8;
        }
#line 440
        if ((int )(fields + fieldnum)->type == 48) {
#line 441
          goto __Cont___1;
        }
#line 443
        if (fieldnum) {
          {
          {
#line 444
          printf((char const   */* __restrict  */)"\t");
          }
          }
        }
        {
#line 447
        if ((int )(fields + fieldnum)->type == 66) {
#line 447
          goto case_66___0;
        }
#line 451
        if ((int )(fields + fieldnum)->type == 67) {
#line 451
          goto case_67___1;
        }
#line 455
        if ((int )(fields + fieldnum)->type == 68) {
#line 455
          goto case_68___1;
        }
#line 475
        if ((int )(fields + fieldnum)->type == 71) {
#line 475
          goto case_71___0;
        }
#line 482
        if ((int )(fields + fieldnum)->type == 73) {
#line 482
          goto case_73___0;
        }
#line 486
        if ((int )(fields + fieldnum)->type == 76) {
#line 486
          goto case_76___0;
        }
#line 498
        if ((int )(fields + fieldnum)->type == 77) {
#line 498
          goto case_77___0;
        }
#line 525
        if ((int )(fields + fieldnum)->type == 78) {
#line 525
          goto case_78___0;
        }
#line 525
        if ((int )(fields + fieldnum)->type == 70) {
#line 525
          goto case_78___0;
        }
#line 540
        if ((int )(fields + fieldnum)->type == 84) {
#line 540
          goto case_84___2;
        }
#line 554
        if ((int )(fields + fieldnum)->type == 89) {
#line 554
          goto case_89___1;
        }
#line 446
        goto switch_break___1;
        case_66___0: /* CIL Label */ 
        {
        {
#line 449
        tmp___29 = sdouble((char const   *)bufoffset);
        }
        {
#line 449
        printf((char const   */* __restrict  */)(pgfields + fieldnum)->formatstring,
               tmp___29);
        }
        }
#line 450
        goto switch_break___1;
        case_67___1: /* CIL Label */ 
        {
        {
#line 453
        safeprintbuf((char const   *)bufoffset, (size_t const   )(fields + fieldnum)->length);
        }
        }
#line 454
        goto switch_break___1;
        case_68___1: /* CIL Label */ 
#line 457
        if ((int )*(bufoffset + 0) == 32) {
          {
          {
#line 458
          printf((char const   */* __restrict  */)"\\N");
          }
          }
        } else
#line 457
        if ((int )*(bufoffset + 0) == 0) {
          {
          {
#line 458
          printf((char const   */* __restrict  */)"\\N");
          }
          }
        } else {
          {
#line 460
          s = outputbuffer;
#line 461
          tmp___30 = s;
#line 461
          s ++;
#line 461
          *tmp___30 = *(bufoffset + 0);
#line 462
          tmp___31 = s;
#line 462
          s ++;
#line 462
          *tmp___31 = *(bufoffset + 1);
#line 463
          tmp___32 = s;
#line 463
          s ++;
#line 463
          *tmp___32 = *(bufoffset + 2);
#line 464
          tmp___33 = s;
#line 464
          s ++;
#line 464
          *tmp___33 = *(bufoffset + 3);
#line 465
          tmp___34 = s;
#line 465
          s ++;
#line 465
          *tmp___34 = (char )'-';
#line 466
          tmp___35 = s;
#line 466
          s ++;
#line 466
          *tmp___35 = *(bufoffset + 4);
#line 467
          tmp___36 = s;
#line 467
          s ++;
#line 467
          *tmp___36 = *(bufoffset + 5);
#line 468
          tmp___37 = s;
#line 468
          s ++;
#line 468
          *tmp___37 = (char )'-';
#line 469
          tmp___38 = s;
#line 469
          s ++;
#line 469
          *tmp___38 = *(bufoffset + 6);
#line 470
          tmp___39 = s;
#line 470
          s ++;
#line 470
          *tmp___39 = *(bufoffset + 7);
#line 471
          tmp___40 = s;
#line 471
          s ++;
#line 471
          *tmp___40 = (char )'\000';
          {
#line 472
          printf((char const   */* __restrict  */)"%s", outputbuffer);
          }
          }
        }
#line 474
        goto switch_break___1;
        case_71___0: /* CIL Label */ 
#line 481
        goto switch_break___1;
        case_73___0: /* CIL Label */ 
        {
        {
#line 484
        tmp___41 = snativeint32_t((char const   *)bufoffset);
        }
        {
#line 484
        printf((char const   */* __restrict  */)"%d", tmp___41);
        }
        }
#line 485
        goto switch_break___1;
        case_76___0: /* CIL Label */ 
        {
#line 490
        if ((int )*(bufoffset + 0) == 84) {
#line 490
          goto case_84___1;
        }
#line 490
        if ((int )*(bufoffset + 0) == 89) {
#line 490
          goto case_84___1;
        }
#line 493
        goto switch_default___1;
        case_84___1: /* CIL Label */ 
        case_89___0: /* CIL Label */ 
        {
        {
#line 491
        putchar('t');
        }
        }
#line 492
        goto switch_break___2;
        switch_default___1: /* CIL Label */ 
        {
        {
#line 494
        putchar('f');
        }
        }
#line 495
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 497
        goto switch_break___1;
        case_77___0: /* CIL Label */ 
#line 500
        if ((pgfields + fieldnum)->memonumbering == 1) {
          {
          {
#line 501
          memoblocknumber = snativeint32_t((char const   *)bufoffset);
          }
          }
        } else {
#line 503
          memoblocknumber = 0;
#line 504
          s = bufoffset;
#line 505
          i = 0;
          {
          {
#line 505
          while (1) {
            while_continue___24: /* CIL Label */ ;
            while_continue___9: /* CIL Label */ ;
#line 505
            if (! (i < 10)) {
#line 505
              goto while_break___9;
            }
#line 506
            if ((int )*s != 32) {
#line 509
              memoblocknumber = (memoblocknumber * 10 + (int32_t )*s) - 48;
            }
#line 511
            s ++;
#line 505
            i ++;
          }
          while_break___24: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 514
        if (memoblocknumber) {
#line 515
          memorecord = (char *)(memomap + memoblocksize * (size_t )memoblocknumber);
#line 516
          if ((int )dbfheader.signature == -125) {
            {
            {
#line 517
            t = strchr((char const   *)memorecord, 26);
            }
            {
#line 518
            safeprintbuf((char const   *)memorecord, (size_t const   )(t - memorecord));
            }
            }
          } else {
            {
            {
#line 520
            tmp___42 = sswappedint32_t((char const   *)(memorecord + 4));
            }
            {
#line 520
            safeprintbuf((char const   *)(memorecord + 8), (size_t const   )tmp___42);
            }
            }
          }
        }
#line 523
        goto switch_break___1;
        case_78___0: /* CIL Label */ 
        case_70___0: /* CIL Label */ 
        {
        {
#line 527
        strncpy((char */* __restrict  */)outputbuffer, (char const   */* __restrict  */)bufoffset,
                (size_t )(fields + fieldnum)->length);
        }
#line 528
        *(outputbuffer + (fields + fieldnum)->length) = (char )'\000';
#line 530
        s = outputbuffer;
        }
        {
        {
#line 531
        while (1) {
          while_continue___25: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
#line 531
          if (! ((int )*s == 32)) {
#line 531
            goto while_break___10;
          }
#line 532
          s ++;
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 534
        if ((int )*s == 0) {
          {
          {
#line 535
          printf((char const   */* __restrict  */)"\\N");
          }
          }
        } else {
          {
          {
#line 537
          printf((char const   */* __restrict  */)"%s", s);
          }
          }
        }
#line 539
        goto switch_break___1;
        case_84___2: /* CIL Label */ 
        {
        {
#line 542
        juliandays = snativeint32_t((char const   *)bufoffset);
        }
        {
#line 543
        tmp___43 = snativeint32_t((char const   *)(bufoffset + 4));
        }
#line 543
        seconds = (tmp___43 + 1) / 1000;
        }
#line 544
        if (juliandays) {
          {
#line 547
          hours = seconds / 3600;
#line 548
          seconds -= hours * 3600;
#line 549
          minutes = seconds / 60;
#line 550
          seconds -= minutes * 60;
          {
#line 551
          printf((char const   */* __restrict  */)"J%d %02d:%02d:%02d", juliandays,
                 hours, minutes, seconds);
          }
          }
        } else
#line 544
        if (seconds) {
          {
#line 547
          hours = seconds / 3600;
#line 548
          seconds -= hours * 3600;
#line 549
          minutes = seconds / 60;
#line 550
          seconds -= minutes * 60;
          {
#line 551
          printf((char const   */* __restrict  */)"J%d %02d:%02d:%02d", juliandays,
                 hours, minutes, seconds);
          }
          }
        } else {
          {
          {
#line 545
          printf((char const   */* __restrict  */)"\\N");
          }
          }
        }
#line 553
        goto switch_break___1;
        case_89___1: /* CIL Label */ 
        {
        {
#line 556
        tmp___44 = snativeint64_t((char const   *)bufoffset);
        }
        {
#line 556
        tmp___45 = sprintf((char */* __restrict  */)outputbuffer, (char const   */* __restrict  */)"%05jd",
                           tmp___44);
        }
#line 556
        t = outputbuffer + tmp___45;
#line 557
        *(t + 1) = (char )'\000';
#line 558
        *t = *(t - 1);
#line 559
        *(t - 1) = *(t - 2);
#line 560
        *(t - 2) = *(t - 3);
#line 561
        *(t - 3) = *(t - 4);
#line 562
        *(t - 4) = (char )'.';
        {
#line 563
        printf((char const   */* __restrict  */)"%s", outputbuffer);
        }
        }
#line 564
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 566
        bufoffset += (int )(fields + fieldnum)->length;
        __Cont___1: /* CIL Label */ 
#line 439
        fieldnum ++;
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
      {
#line 568
      printf((char const   */* __restrict  */)"\n");
      }
      }
      __Cont___0: /* CIL Label */ 
#line 432
      batchindex ++;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 426
    recordbase += dbfbatchsize;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
  {
#line 571
  free((void *)inputbuffer);
  }
  {
#line 572
  free((void *)outputbuffer);
  }
  {
#line 573
  printf((char const   */* __restrict  */)"\\.\n");
  }
  }
#line 576
  if (usetransaction) {
    {
    {
#line 577
    printf((char const   */* __restrict  */)"COMMIT;\n");
    }
    }
  }
#line 581
  i = optind + 1;
  {
  {
#line 581
  while (1) {
    while_continue___26: /* CIL Label */ ;
    while_continue___11: /* CIL Label */ ;
#line 581
    if (! (i < argc)) {
#line 581
      goto while_break___11;
    }
    {
    {
#line 582
    printf((char const   */* __restrict  */)"CREATE INDEX %s_", tablename);
    }
#line 583
    s = *(argv + i);
    }
    {
    {
#line 583
    while (1) {
      while_continue___27: /* CIL Label */ ;
      while_continue___12: /* CIL Label */ ;
#line 583
      if (! *s) {
#line 583
        goto while_break___12;
      }
      {
      {
#line 584
      tmp___47 = __ctype_b_loc();
      }
      }
#line 584
      if ((int const   )*(*tmp___47 + (int )*s) & 8) {
        {
        {
#line 585
        putchar((int )*s);
        }
#line 586
        lastcharwasreplaced = 0;
        }
      } else
#line 589
      if (! lastcharwasreplaced) {
        {
        {
#line 590
        putchar('_');
        }
#line 591
        lastcharwasreplaced = 1;
        }
      }
#line 583
      s ++;
    }
    while_break___27: /* CIL Label */ ;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
    {
#line 595
    printf((char const   */* __restrict  */)" ON %s(%s);\n", tablename, *(argv + i));
    }
#line 581
    i ++;
    }
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
  {
#line 598
  free((void *)tablename);
  }
  {
#line 599
  free((void *)fields);
  }
#line 600
  fieldnum = 0;
  }
  {
  {
#line 600
  while (1) {
    while_continue___28: /* CIL Label */ ;
    while_continue___13: /* CIL Label */ ;
#line 600
    if (! ((size_t )fieldnum < fieldcount)) {
#line 600
      goto while_break___13;
    }
#line 601
    if ((unsigned long )(pgfields + fieldnum)->formatstring != (unsigned long )((void *)0)) {
      {
      {
#line 602
      free((void *)(pgfields + fieldnum)->formatstring);
      }
      }
    }
#line 600
    fieldnum ++;
  }
  while_break___28: /* CIL Label */ ;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
  {
#line 605
  free((void *)pgfields);
  }
  {
#line 606
  fclose(dbffile);
  }
  }
#line 607
  if ((unsigned long )memomap != (unsigned long )((void *)0)) {
    {
    {
#line 608
    tmp___48 = munmap(memomap, (size_t )memostat.st_size);
    }
    }
#line 608
    if (tmp___48 == -1) {
      {
      {
#line 609
      exitwitherror("Unable to munmap the memofile", (int const   )1);
      }
      }
    }
    {
    {
#line 611
    close(memofd);
    }
    }
  }
#line 613
  return (0);
}
}
#line 38 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static char staticbuf___0[1048577]  ;
#line 44 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static char const   *RESERVEDWORDS___0[76]  = 
#line 44
  {      "all",      "analyse",      "analyze",      "and", 
        "any",      "array",      "as",      "asc", 
        "asymmetric",      "both",      "case",      "cast", 
        "check",      "collate",      "column",      "constraint", 
        "create",      "current_date",      "current_role",      "current_time", 
        "current_timestamp",      "current_user",      "default",      "deferrable", 
        "desc",      "distinct",      "do",      "else", 
        "end",      "except",      "false",      "for", 
        "foreign",      "from",      "grant",      "group", 
        "having",      "in",      "initially",      "intersect", 
        "into",      "leading",      "limit",      "localtime", 
        "localtimestamp",      "new",      "not",      "null", 
        "off",      "offset",      "old",      "on", 
        "only",      "or",      "order",      "placing", 
        "primary",      "references",      "returning",      "select", 
        "session_user",      "some",      "symmetric",      "table", 
        "then",      "to",      "trailing",      "true", 
        "union",      "unique",      "user",      "using", 
        "when",      "where",      "with",      (char const   *)((void *)0)};
#line 170 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static void exitwitherror___0(char const   *message , int const   systemerror ) 
{ 
  char *__cil_tmp3 ;

  {
#line 174
  if (systemerror) {
    {
    {
#line 175
    perror(message);
    }
    }
  } else {
    {
    {
#line 177
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            message);
    }
    }
  }
  {
  {
#line 179
  exit(1);
  }
  }
}
}
#line 182 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static void safeprintbuf___0(char const   *buf , size_t const   inputsize ) 
{ 
  char *targetbuf ;
  char const   *s ;
  char const   *lastchar ;
  char *t ;
  int realsize ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 190
  realsize = 0;
#line 193
  if ((int const   )*buf == 0) {
#line 194
    return;
  }
#line 198
  s = (buf + inputsize) - 1;
  {
  {
#line 198
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )s >= (unsigned long )buf)) {
#line 198
      goto while_break;
    }
#line 199
    if ((int const   )*s != 32) {
#line 199
      if ((int const   )*s != 0) {
#line 200
        goto while_break;
      }
    }
#line 198
    s --;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if ((unsigned long )s < (unsigned long )buf) {
#line 205
    return;
  }
#line 208
  lastchar = s;
#line 209
  realsize = (int )((s - buf) + 1L);
#line 210
  if (realsize * 2 < 1048576) {
#line 211
    targetbuf = staticbuf___0;
  } else {
    {
    {
#line 213
    tmp = malloc((size_t )(realsize * 2 + 1));
    }
#line 213
    targetbuf = (char *)tmp;
    }
#line 214
    if ((unsigned long )targetbuf == (unsigned long )((void *)0)) {
      {
      {
#line 215
      exitwitherror___0("Unable to malloc the escape output buffer", (int const   )1);
      }
      }
    }
  }
#line 220
  t = targetbuf;
#line 221
  s = buf;
  {
  {
#line 221
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 221
    if (! ((unsigned long )s <= (unsigned long )lastchar)) {
#line 221
      goto while_break___0;
    }
    {
#line 223
    if ((int const   )*s == 92) {
#line 223
      goto case_92;
    }
#line 227
    if ((int const   )*s == 10) {
#line 227
      goto case_10;
    }
#line 231
    if ((int const   )*s == 13) {
#line 231
      goto case_13;
    }
#line 235
    if ((int const   )*s == 9) {
#line 235
      goto case_9;
    }
#line 239
    goto switch_default;
    case_92: /* CIL Label */ 
#line 224
    tmp___0 = t;
#line 224
    t ++;
#line 224
    *tmp___0 = (char )'\\';
#line 225
    tmp___1 = t;
#line 225
    t ++;
#line 225
    *tmp___1 = (char )'\\';
#line 226
    goto switch_break;
    case_10: /* CIL Label */ 
#line 228
    tmp___2 = t;
#line 228
    t ++;
#line 228
    *tmp___2 = (char )'\\';
#line 229
    tmp___3 = t;
#line 229
    t ++;
#line 229
    *tmp___3 = (char )'n';
#line 230
    goto switch_break;
    case_13: /* CIL Label */ 
#line 232
    tmp___4 = t;
#line 232
    t ++;
#line 232
    *tmp___4 = (char )'\\';
#line 233
    tmp___5 = t;
#line 233
    t ++;
#line 233
    *tmp___5 = (char )'r';
#line 234
    goto switch_break;
    case_9: /* CIL Label */ 
#line 236
    tmp___6 = t;
#line 236
    t ++;
#line 236
    *tmp___6 = (char )'\\';
#line 237
    tmp___7 = t;
#line 237
    t ++;
#line 237
    *tmp___7 = (char )'t';
#line 238
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 240
    tmp___8 = t;
#line 240
    t ++;
#line 240
    *tmp___8 = (char )*s;
    switch_break: /* CIL Label */ ;
    }
#line 221
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 243
  *t = (char )'\000';
  {
#line 244
  printf((char const   */* __restrict  */)"%s", targetbuf);
  }
  }
#line 246
  if ((unsigned long )targetbuf != (unsigned long )(staticbuf___0)) {
    {
    {
#line 247
    free((void *)targetbuf);
    }
    }
  }
#line 249
  return;
}
}
#line 275 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t nativeint32_t___0(int32_t const   rightend ) 
{ 


  {
#line 278
  return ((int32_t )rightend);
}
}
#line 281 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t swappedint32_t___0(int32_t const   wrongend ) 
{ 


  {
#line 284
  return ((int32_t )((((((unsigned int )wrongend & 4278190080U) >> 24) | (unsigned int )((wrongend & 16711680) >> 8)) | (unsigned int )((wrongend & 65280) << 8)) | (unsigned int )((wrongend & 255) << 24)));
}
}
#line 290 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int16_t nativeint16_t___0(int16_t const   rightend ) 
{ 


  {
#line 293
  return ((int16_t )rightend);
}
}
#line 296 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int16_t swappedint16_t___0(int16_t const   wrongend ) 
{ 


  {
#line 299
  return ((int16_t )((((int const   )wrongend & 65280) >> 8) | (((int const   )wrongend & 255) << 8)));
}
}
#line 305 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int64_t snativeint64_t___0(char const   *buf ) 
{ 
  int64_t output ;

  {
  {
  {
#line 309
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )8);
  }
  }
#line 310
  return (output);
}
}
#line 321 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t snativeint32_t___0(char const   *buf ) 
{ 
  int32_t output ;

  {
  {
  {
#line 325
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )4);
  }
  }
#line 326
  return (output);
}
}
#line 329 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int32_t sswappedint32_t___0(char const   *buf ) 
{ 
  int32_t output ;
  int32_t tmp ;

  {
  {
  {
#line 333
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )4);
  }
  {
#line 334
  tmp = swappedint32_t___0((int32_t const   )output);
  }
  }
#line 334
  return (tmp);
}
}
#line 345 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static int16_t sswappedint16_t___0(char const   *buf ) 
{ 
  int16_t output ;
  int16_t tmp ;

  {
  {
  {
#line 349
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )2);
  }
  {
#line 350
  tmp = swappedint16_t___0((int16_t const   )output);
  }
  }
#line 350
  return (tmp);
}
}
#line 403 "/home/wslee/benchmarks/pgdbf-0.5.0/src/pgdbf.h"
static double sdouble___0(char const   *buf ) 
{ 
  double output ;

  {
  {
  {
#line 407
  memcpy((void */* __restrict  */)(& output), (void const   */* __restrict  */)buf,
         (size_t )8);
  }
  }
#line 408
  return (output);
}
}
