/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
typedef long flow_t;
#line 60 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
typedef long cost_t;
#line 91
struct arc;
#line 91 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
struct node {
   long number ;
   char *ident ;
   struct node *pred ;
   struct node *child ;
   struct node *sibling ;
   struct node *sibling_prev ;
   long depth ;
   long orientation ;
   struct arc *basic_arc ;
   struct arc *firstout ;
   struct arc *firstin ;
   cost_t potential ;
   flow_t flow ;
   size_t mark ;
   long time ;
};
#line 91 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
typedef struct node node_t;
#line 108 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
struct arc {
   node_t *tail ;
   node_t *head ;
   struct arc *nextout ;
   struct arc *nextin ;
   cost_t cost ;
   cost_t org_cost ;
   flow_t flow ;
   long ident ;
};
#line 108 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
typedef struct arc arc_t;
#line 68 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
struct basket {
   arc_t *a ;
   cost_t cost ;
   cost_t abs_cost ;
};
#line 68 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
typedef struct basket BASKET;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 119 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
struct network {
   char inputfile[200] ;
   char clustfile[200] ;
   long n ;
   long n_trips ;
   long max_m ;
   long m ;
   long m_org ;
   long m_impl ;
   long primal_unbounded ;
   long dual_unbounded ;
   long perturbed ;
   long feasible ;
   long eps ;
   long opt_tol ;
   long feas_tol ;
   long pert_val ;
   long bigM ;
   double optcost ;
   cost_t ignore_impl ;
   node_t *nodes ;
   node_t *stop_nodes ;
   arc_t *arcs ;
   arc_t *stop_arcs ;
   arc_t *dummy_arcs ;
   arc_t *stop_dummy ;
   long iterations ;
   long bound_exchanges ;
   long checksum ;
};
#line 119 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/defines.h"
typedef struct network network_t;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.h"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) ;
#line 35 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
cost_t bea_compute_red_cost(arc_t *arc ) 
{ 


  {
#line 41
  return ((arc->cost - (arc->tail)->potential) + (arc->head)->potential);
}
}
#line 51 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
int bea_is_dual_infeasible(arc_t *arc , cost_t red_cost ) 
{ 
  int tmp ;

  {
#line 58
  if (red_cost < 0L) {
#line 58
    if (arc->ident == 1L) {
#line 58
      tmp = 1;
    } else {
#line 58
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 58
  if (red_cost > 0L) {
#line 58
    if (arc->ident == 2L) {
#line 58
      tmp = 1;
    } else {
#line 58
      tmp = 0;
    }
  } else {
#line 58
    tmp = 0;
  }
#line 58
  return (tmp);
}
}
#line 75 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
static long basket_size  ;
#line 76 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
static BASKET basket[401]  ;
#line 77 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
static BASKET *perm[401]  ;
#line 82 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
void sort_basket(long min , long max ) 
{ 
  long l ;
  long r ;
  cost_t cut ;
  BASKET *xchange ;

  {
#line 92
  l = min;
#line 92
  r = max;
#line 94
  cut = (perm[(l + r) / 2L])->abs_cost;
  {
  {
#line 96
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 98
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! ((perm[l])->abs_cost > cut)) {
#line 98
        goto while_break___0;
      }
#line 99
      l ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 100
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 100
      if (! (cut > (perm[r])->abs_cost)) {
#line 100
        goto while_break___1;
      }
#line 101
      r --;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 103
    if (l < r) {
#line 105
      xchange = perm[l];
#line 106
      perm[l] = perm[r];
#line 107
      perm[r] = xchange;
    }
#line 109
    if (l <= r) {
#line 111
      l ++;
#line 111
      r --;
    }
#line 96
    if (! (l <= r)) {
#line 96
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (min < r) {
    {
    {
#line 118
    sort_basket(min, r);
    }
    }
  }
#line 119
  if (l < max) {
#line 119
    if (l <= 100L) {
      {
      {
#line 120
      sort_basket(l, max);
      }
      }
    }
  }
#line 121
  return;
}
}
#line 128 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
static long nr_group  ;
#line 129 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
static long group_pos  ;
#line 132 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
static long initialize  =    1L;
#line 136 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbeampp.c"
arc_t *primal_bea_mpp(long m , arc_t *arcs , arc_t *stop_arcs , cost_t *red_cost_of_bea ) 
{ 
  long i ;
  long next ;
  long old_group_pos ;
  arc_t *arc ;
  cost_t red_cost ;
  int tmp ;
  int tmp___0 ;

  {
#line 150
  if (initialize) {
#line 152
    i = 1L;
    {
    {
#line 152
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 152
      if (! (i < 401L)) {
#line 152
        goto while_break;
      }
#line 153
      perm[i] = & basket[i];
#line 152
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 154
    nr_group = (m - 1L) / 300L + 1L;
#line 155
    group_pos = 0L;
#line 156
    basket_size = 0L;
#line 157
    initialize = 0L;
  } else {
#line 161
    i = 2L;
#line 161
    next = 0L;
    {
    {
#line 161
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 161
      if (i <= 100L) {
#line 161
        if (! (i <= basket_size)) {
#line 161
          goto while_break___0;
        }
      } else {
#line 161
        goto while_break___0;
      }
      {
#line 163
      arc = (perm[i])->a;
      {
#line 164
      red_cost = bea_compute_red_cost(arc);
      }
      {
#line 165
      tmp = bea_is_dual_infeasible(arc, red_cost);
      }
      }
#line 165
      if (tmp) {
#line 167
        next ++;
#line 168
        (perm[next])->a = arc;
#line 169
        (perm[next])->cost = red_cost;
#line 170
        if (red_cost >= 0L) {
#line 170
          (perm[next])->abs_cost = red_cost;
        } else {
#line 170
          (perm[next])->abs_cost = - red_cost;
        }
      }
#line 161
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    basket_size = next;
  }
#line 176
  old_group_pos = group_pos;
  NEXT: 
#line 180
  arc = arcs + group_pos;
  {
  {
#line 181
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 181
    if (! ((unsigned long )arc < (unsigned long )stop_arcs)) {
#line 181
      goto while_break___1;
    }
#line 183
    if (arc->ident > 0L) {
      {
      {
#line 185
      red_cost = bea_compute_red_cost(arc);
      }
      {
#line 186
      tmp___0 = bea_is_dual_infeasible(arc, red_cost);
      }
      }
#line 186
      if (tmp___0) {
#line 188
        basket_size ++;
#line 189
        (perm[basket_size])->a = arc;
#line 190
        (perm[basket_size])->cost = red_cost;
#line 191
        if (red_cost >= 0L) {
#line 191
          (perm[basket_size])->abs_cost = red_cost;
        } else {
#line 191
          (perm[basket_size])->abs_cost = - red_cost;
        }
      }
    }
#line 181
    arc += nr_group;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  group_pos ++;
#line 197
  if (group_pos == nr_group) {
#line 198
    group_pos = 0L;
  }
#line 200
  if (basket_size < 100L) {
#line 200
    if (group_pos != old_group_pos) {
#line 201
      goto NEXT;
    }
  }
#line 203
  if (basket_size == 0L) {
#line 205
    initialize = 1L;
#line 206
    *red_cost_of_bea = (cost_t )0;
#line 207
    return ((arc_t *)((void *)0));
  }
  {
  {
#line 210
  sort_basket(1L, basket_size);
  }
#line 212
  *red_cost_of_bea = (perm[1])->cost;
  }
#line 213
  return ((perm[1])->a);
}
}
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbla.h"
node_t *primal_iminus(flow_t *delta , long *xchange , node_t *iplus , node_t *jplus ,
                      node_t **w ) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pflowup.h"
void primal_update_flow(node_t *iplus , node_t *jplus , node_t *w ) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/treeup.h"
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) ;
#line 23 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.h"
long refresh_potential(network_t *net___0 ) ;
#line 26
long primal_feasible(network_t *net___0 ) ;
#line 27
long dual_feasible(network_t *net___0 ) ;
#line 27 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/psimplex.h"
long primal_net_simplex(network_t *net___0 ) ;
#line 21 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/psimplex.c"
long primal_net_simplex(network_t *net___0 ) 
{ 
  flow_t delta ;
  flow_t new_flow ;
  long opt ;
  long xchange ;
  long new_orientation ;
  node_t *iplus ;
  node_t *jplus ;
  node_t *iminus ;
  node_t *jminus ;
  node_t *w ;
  arc_t *bea ;
  arc_t *bla ;
  arc_t *arcs ;
  arc_t *stop_arcs ;
  node_t *temp ;
  long m ;
  long new_set ;
  cost_t red_cost_of_bea ;
  long *iterations ;
  long *bound_exchanges ;
  long *checksum ;
  long tmp ;
  long tmp___0 ;
  char *__cil_tmp25 ;

  {
#line 29
  opt = 0L;
#line 39
  arcs = net___0->arcs;
#line 40
  stop_arcs = net___0->stop_arcs;
#line 42
  m = net___0->m;
#line 45
  iterations = & net___0->iterations;
#line 46
  bound_exchanges = & net___0->bound_exchanges;
#line 47
  checksum = & net___0->checksum;
  {
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 50
    if (! (! opt)) {
#line 50
      goto while_break;
    }
    {
    {
#line 52
    bea = primal_bea_mpp(m, arcs, stop_arcs, & red_cost_of_bea);
    }
    }
#line 52
    if (bea) {
#line 54
      (*iterations) ++;
#line 62
      if (red_cost_of_bea > 0L) {
#line 64
        iplus = bea->head;
#line 65
        jplus = bea->tail;
      } else {
#line 69
        iplus = bea->tail;
#line 70
        jplus = bea->head;
      }
      {
#line 73
      delta = (flow_t )1;
      {
#line 74
      iminus = primal_iminus(& delta, & xchange, iplus, jplus, & w);
      }
      }
#line 77
      if (! iminus) {
#line 79
        (*bound_exchanges) ++;
#line 81
        if (bea->ident == 2L) {
#line 82
          bea->ident = 1L;
        } else {
#line 84
          bea->ident = 2L;
        }
#line 86
        if (delta) {
          {
          {
#line 87
          primal_update_flow(iplus, jplus, w);
          }
          }
        }
      } else {
#line 91
        if (xchange) {
#line 93
          temp = jplus;
#line 94
          jplus = iplus;
#line 95
          iplus = temp;
        }
#line 98
        jminus = iminus->pred;
#line 100
        bla = iminus->basic_arc;
#line 102
        if (xchange != iminus->orientation) {
#line 103
          new_set = 1L;
        } else {
#line 105
          new_set = 2L;
        }
#line 107
        if (red_cost_of_bea > 0L) {
#line 108
          new_flow = 1L - delta;
        } else {
#line 110
          new_flow = delta;
        }
#line 112
        if ((unsigned long )bea->tail == (unsigned long )iplus) {
#line 113
          new_orientation = 1L;
        } else {
#line 115
          new_orientation = 0L;
        }
        {
        {
#line 117
        update_tree((long )(! xchange), new_orientation, delta, new_flow, iplus, jplus,
                    iminus, jminus, w, bea, red_cost_of_bea, net___0->feas_tol);
        }
#line 122
        bea->ident = 0L;
#line 123
        bla->ident = new_set;
        }
#line 125
        if (! ((*iterations - 1L) % 20L)) {
          {
          {
#line 127
          tmp = refresh_potential(net___0);
          }
#line 127
          *checksum += tmp;
          }
#line 128
          if (*checksum > 2000000000L) {
            {
            {
#line 130
            printf((char const   */* __restrict  */)"%ld\n", *checksum);
            }
            {
#line 131
            fflush(stdout);
            }
            }
          }
        }
      }
    } else {
#line 137
      opt = 1L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 141
  tmp___0 = refresh_potential(net___0);
  }
#line 141
  *checksum += tmp___0;
  {
#line 142
  primal_feasible(net___0);
  }
  {
#line 143
  dual_feasible(net___0);
  }
  }
#line 145
  return (0L);
}
}
#line 21 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pflowup.c"
void primal_update_flow(node_t *iplus , node_t *jplus , node_t *w ) 
{ 


  {
  {
  {
#line 32
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 32
    if (! ((unsigned long )iplus != (unsigned long )w)) {
#line 32
      goto while_break;
    }
#line 34
    if (iplus->orientation) {
#line 35
      iplus->flow = (flow_t )0;
    } else {
#line 37
      iplus->flow = (flow_t )1;
    }
#line 32
    iplus = iplus->pred;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 40
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 40
    if (! ((unsigned long )jplus != (unsigned long )w)) {
#line 40
      goto while_break___0;
    }
#line 42
    if (jplus->orientation) {
#line 43
      jplus->flow = (flow_t )1;
    } else {
#line 45
      jplus->flow = (flow_t )0;
    }
#line 40
    jplus = jplus->pred;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 47
  return;
}
}
#line 33 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pbla.c"
node_t *primal_iminus(flow_t *delta , long *xchange , node_t *iplus , node_t *jplus ,
                      node_t **w ) 
{ 
  node_t *iminus ;

  {
#line 49
  iminus = (node_t *)((void *)0);
  {
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 52
    if (! ((unsigned long )iplus != (unsigned long )jplus)) {
#line 52
      goto while_break;
    }
#line 54
    if (iplus->depth < jplus->depth) {
#line 56
      if (iplus->orientation) {
#line 57
        if (*delta > iplus->flow) {
#line 57
          iminus = iplus;
#line 57
          *delta = iplus->flow;
#line 57
          *xchange = 0L;
        }
      } else
#line 58
      if ((iplus->pred)->pred) {
#line 59
        if (*delta > 1L - iplus->flow) {
#line 59
          iminus = iplus;
#line 59
          *delta = 1L - iplus->flow;
#line 59
          *xchange = 0L;
        }
      }
#line 60
      iplus = iplus->pred;
    } else {
#line 64
      if (! jplus->orientation) {
#line 65
        if (*delta >= jplus->flow) {
#line 65
          iminus = jplus;
#line 65
          *delta = jplus->flow;
#line 65
          *xchange = 1L;
        }
      } else
#line 66
      if ((jplus->pred)->pred) {
#line 67
        if (*delta >= 1L - jplus->flow) {
#line 67
          iminus = jplus;
#line 67
          *delta = 1L - jplus->flow;
#line 67
          *xchange = 1L;
        }
      }
#line 68
      jplus = jplus->pred;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  *w = iplus;
#line 74
  return (iminus);
}
}
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/treeup.c"
void update_tree(long cycle_ori , long new_orientation , flow_t delta , flow_t new_flow ,
                 node_t *iplus , node_t *jplus , node_t *iminus , node_t *jminus ,
                 node_t *w , arc_t *bea , cost_t sigma , flow_t feas_tol ) 
{ 
  arc_t *basic_arc_temp ;
  arc_t *new_basic_arc ;
  node_t *father ;
  node_t *temp ;
  node_t *new_pred ;
  long orientation_temp ;
  long depth_temp ;
  long depth_iminus ;
  long new_depth ;
  flow_t flow_temp ;
  cost_t tmp ;

  {
#line 64
  if ((unsigned long )bea->tail == (unsigned long )jplus) {
#line 64
    if (sigma < 0L) {
#line 64
      goto _L;
    } else {
#line 64
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 64
  if ((unsigned long )bea->tail == (unsigned long )iplus) {
#line 64
    if (sigma > 0L) {
      _L: /* CIL Label */ 
#line 66
      if (sigma >= 0L) {
#line 66
        sigma = sigma;
      } else {
#line 66
        sigma = - sigma;
      }
    } else {
#line 64
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 68
    if (sigma >= 0L) {
#line 68
      tmp = sigma;
    } else {
#line 68
      tmp = - sigma;
    }
#line 68
    sigma = - tmp;
  }
#line 70
  father = iminus;
#line 71
  father->potential += sigma;
  RECURSION: 
#line 73
  temp = father->child;
#line 74
  if (temp) {
    ITERATION: 
#line 77
    temp->potential += sigma;
#line 78
    father = temp;
#line 79
    goto RECURSION;
  }
  TEST: 
#line 82
  if ((unsigned long )father == (unsigned long )iminus) {
#line 83
    goto CONTINUE;
  }
#line 84
  temp = father->sibling;
#line 85
  if (temp) {
#line 86
    goto ITERATION;
  }
#line 87
  father = father->pred;
#line 88
  goto TEST;
  CONTINUE: 
#line 94
  temp = iplus;
#line 95
  father = temp->pred;
#line 96
  depth_iminus = iminus->depth;
#line 96
  new_depth = depth_iminus;
#line 97
  new_pred = jplus;
#line 98
  new_basic_arc = bea;
  {
  {
#line 99
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 99
    if (! ((unsigned long )temp != (unsigned long )jminus)) {
#line 99
      goto while_break;
    }
#line 101
    if (temp->sibling) {
#line 102
      (temp->sibling)->sibling_prev = temp->sibling_prev;
    }
#line 103
    if (temp->sibling_prev) {
#line 104
      (temp->sibling_prev)->sibling = temp->sibling;
    } else {
#line 105
      father->child = temp->sibling;
    }
#line 108
    temp->pred = new_pred;
#line 109
    temp->sibling = new_pred->child;
#line 110
    if (temp->sibling) {
#line 111
      (temp->sibling)->sibling_prev = temp;
    }
#line 112
    new_pred->child = temp;
#line 113
    temp->sibling_prev = (struct node *)0;
#line 115
    orientation_temp = (long )(! temp->orientation);
#line 116
    if (orientation_temp == cycle_ori) {
#line 117
      flow_temp = temp->flow + delta;
    } else {
#line 119
      flow_temp = temp->flow - delta;
    }
#line 120
    basic_arc_temp = temp->basic_arc;
#line 121
    depth_temp = temp->depth;
#line 123
    temp->orientation = new_orientation;
#line 124
    temp->flow = new_flow;
#line 125
    temp->basic_arc = new_basic_arc;
#line 126
    temp->depth = new_depth;
#line 128
    new_pred = temp;
#line 129
    new_orientation = orientation_temp;
#line 130
    new_flow = flow_temp;
#line 131
    new_basic_arc = basic_arc_temp;
#line 132
    new_depth = depth_iminus - depth_temp;
#line 133
    temp = father;
#line 134
    father = temp->pred;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (delta > feas_tol) {
#line 139
    temp = jminus;
    {
    {
#line 139
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! ((unsigned long )temp != (unsigned long )w)) {
#line 139
        goto while_break___0;
      }
#line 141
      temp->depth -= depth_iminus;
#line 142
      if (temp->orientation != cycle_ori) {
#line 143
        temp->flow += delta;
      } else {
#line 145
        temp->flow -= delta;
      }
#line 139
      temp = temp->pred;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    temp = jplus;
    {
    {
#line 147
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 147
      if (! ((unsigned long )temp != (unsigned long )w)) {
#line 147
        goto while_break___1;
      }
#line 149
      temp->depth += depth_iminus;
#line 150
      if (temp->orientation == cycle_ori) {
#line 151
        temp->flow += delta;
      } else {
#line 153
        temp->flow -= delta;
      }
#line 147
      temp = temp->pred;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 158
    temp = jminus;
    {
    {
#line 158
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 158
      if (! ((unsigned long )temp != (unsigned long )w)) {
#line 158
        goto while_break___2;
      }
#line 159
      temp->depth -= depth_iminus;
#line 158
      temp = temp->pred;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 160
    temp = jplus;
    {
    {
#line 160
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 160
      if (! ((unsigned long )temp != (unsigned long )w)) {
#line 160
        goto while_break___3;
      }
#line 161
      temp->depth += depth_iminus;
#line 160
      temp = temp->pred;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 164
  return;
}
}
#line 206 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.h"
void refresh_neighbour_lists(network_t *net___0 ) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/output.h"
long write_circulations(char *outfile , network_t *net___0 ) ;
#line 23 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/output.c"
long write_circulations(char *outfile , network_t *net___0 ) 
{ 
  FILE *out ;
  arc_t *block ;
  arc_t *arc ;
  arc_t *arc2 ;
  arc_t *first_impl ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 34
  out = (FILE *)((void *)0);
#line 38
  first_impl = net___0->stop_arcs - net___0->m_impl;
  {
#line 40
  out = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
  }
  }
#line 40
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 41
    return (-1L);
  }
  {
  {
#line 43
  refresh_neighbour_lists(net___0);
  }
#line 45
  block = (net___0->nodes + net___0->n)->firstout;
  }
  {
  {
#line 45
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! block) {
#line 45
      goto while_break;
    }
#line 47
    if (block->flow) {
      {
      {
#line 49
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"()\n");
      }
#line 51
      arc = block;
      }
      {
      {
#line 52
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 52
        if (! arc) {
#line 52
          goto while_break___0;
        }
#line 54
        if ((unsigned long )arc >= (unsigned long )first_impl) {
          {
          {
#line 55
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"***\n");
          }
          }
        }
        {
        {
#line 57
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%ld\n",
                - (arc->head)->number);
        }
#line 58
        arc2 = (arc->head + net___0->n_trips)->firstout;
        }
        {
        {
#line 59
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 59
          if (! arc2) {
#line 59
            goto while_break___1;
          }
#line 60
          if (arc2->flow) {
#line 61
            goto while_break___1;
          }
#line 59
          arc2 = arc2->nextout;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 62
        if (! arc2) {
          {
          {
#line 64
          fclose(out);
          }
          }
#line 65
          return (-1L);
        }
#line 68
        if ((arc2->head)->number) {
#line 69
          arc = arc2;
        } else {
#line 71
          arc = (arc_t *)((void *)0);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 45
    block = block->nextout;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 78
  fclose(out);
  }
  }
#line 80
  return (0L);
}
}
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pstart.h"
long primal_start_artificial(network_t *net___0 ) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/pstart.c"
long primal_start_artificial(network_t *net___0 ) 
{ 
  node_t *node ;
  node_t *root ;
  arc_t *arc ;
  void *stop ;

  {
#line 33
  node = net___0->nodes;
#line 33
  root = node;
#line 33
  node ++;
#line 34
  root->basic_arc = (struct arc *)((void *)0);
#line 35
  root->pred = (struct node *)((void *)0);
#line 36
  root->child = node;
#line 37
  root->sibling = (struct node *)((void *)0);
#line 38
  root->sibling_prev = (struct node *)((void *)0);
#line 39
  root->depth = net___0->n + 1L;
#line 40
  root->orientation = 0L;
#line 41
  root->potential = -100000000L;
#line 42
  root->flow = (flow_t )0;
#line 44
  stop = (void *)net___0->stop_arcs;
#line 45
  arc = net___0->arcs;
  {
  {
#line 45
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )arc != (unsigned long )((arc_t *)stop))) {
#line 45
      goto while_break;
    }
#line 46
    if (arc->ident != -1L) {
#line 47
      arc->ident = 1L;
    }
#line 45
    arc ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  arc = net___0->dummy_arcs;
#line 50
  stop = (void *)net___0->stop_nodes;
  {
  {
#line 50
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! ((unsigned long )node != (unsigned long )((node_t *)stop))) {
#line 50
      goto while_break___0;
    }
#line 52
    node->basic_arc = arc;
#line 53
    node->pred = root;
#line 54
    node->child = (struct node *)((void *)0);
#line 55
    node->sibling = node + 1;
#line 56
    node->sibling_prev = node - 1;
#line 57
    node->depth = 1L;
#line 59
    arc->cost = 100000000L;
#line 60
    arc->ident = 0L;
#line 62
    node->orientation = 1L;
#line 63
    node->potential = (cost_t )0;
#line 64
    arc->tail = node;
#line 65
    arc->head = root;
#line 66
    node->flow = (flow_t )0;
#line 50
    arc ++;
#line 50
    node ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 69
  node --;
#line 69
  root ++;
#line 70
  node->sibling = (struct node *)((void *)0);
#line 71
  root->sibling_prev = (struct node *)((void *)0);
#line 73
  return (0L);
}
}
#line 567 "/usr/include/stdlib.h"
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 23 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.h"
long price_out_impl(network_t *net___0 ) ;
#line 24
long suspend_impl(network_t *net___0 , cost_t threshold , long all ) ;
#line 24 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.c"
long resize_prob(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  node_t *stop ;
  node_t *root ;
  long off ;
  void *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 38
  net___0->max_m += 300000L;
  {
#line 48
  tmp = realloc((void *)net___0->arcs, (size_t )((unsigned long )net___0->max_m * sizeof(arc_t )));
  }
#line 48
  arc = (arc_t *)tmp;
  }
#line 49
  if (! arc) {
    {
    {
#line 51
    printf((char const   */* __restrict  */)"network %s: not enough memory\n", net___0->inputfile);
    }
    {
#line 52
    fflush(stdout);
    }
    }
#line 53
    return (-1L);
  }
#line 59
  off = (long )arc - (long )net___0->arcs;
#line 62
  net___0->arcs = arc;
#line 63
  net___0->stop_arcs = arc + net___0->m;
#line 65
  node = net___0->nodes;
#line 65
  root = node;
#line 66
  node ++;
#line 66
  stop = (node_t *)((void *)net___0->stop_nodes);
  {
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 66
    if (! ((unsigned long )node < (unsigned long )stop)) {
#line 66
      goto while_break;
    }
#line 67
    if ((unsigned long )node->pred != (unsigned long )root) {
#line 71
      node->basic_arc = (arc_t *)((long )node->basic_arc + off);
    }
#line 66
    node ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (0L);
}
}
#line 83 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.c"
cost_t compute_red_cost(cost_t cost , node_t *tail , cost_t head_potential ) 
{ 


  {
#line 91
  return ((cost - tail->potential) + head_potential);
}
}
#line 101 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.c"
void insert_new_arc(arc_t *new , long newpos , node_t *tail , node_t *head , cost_t cost ,
                    cost_t red_cost ) 
{ 
  long pos ;

  {
#line 115
  (new + newpos)->tail = tail;
#line 116
  (new + newpos)->head = head;
#line 117
  (new + newpos)->org_cost = cost;
#line 118
  (new + newpos)->cost = cost;
#line 119
  (new + newpos)->flow = red_cost;
#line 121
  pos = newpos + 1L;
  {
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 122
    if (pos - 1L) {
#line 122
      if (! (red_cost > (new + (pos / 2L - 1L))->flow)) {
#line 122
        goto while_break;
      }
    } else {
#line 122
      goto while_break;
    }
#line 124
    (new + (pos - 1L))->tail = (new + (pos / 2L - 1L))->tail;
#line 125
    (new + (pos - 1L))->head = (new + (pos / 2L - 1L))->head;
#line 126
    (new + (pos - 1L))->cost = (new + (pos / 2L - 1L))->cost;
#line 127
    (new + (pos - 1L))->org_cost = (new + (pos / 2L - 1L))->cost;
#line 128
    (new + (pos - 1L))->flow = (new + (pos / 2L - 1L))->flow;
#line 130
    pos /= 2L;
#line 131
    (new + (pos - 1L))->tail = tail;
#line 132
    (new + (pos - 1L))->head = head;
#line 133
    (new + (pos - 1L))->cost = cost;
#line 134
    (new + (pos - 1L))->org_cost = cost;
#line 135
    (new + (pos - 1L))->flow = red_cost;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return;
}
}
#line 147 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.c"
void replace_weaker_arc(arc_t *new , node_t *tail , node_t *head , cost_t cost , cost_t red_cost ) 
{ 
  long pos ;
  long cmp ;

  {
#line 161
  (new + 0)->tail = tail;
#line 162
  (new + 0)->head = head;
#line 163
  (new + 0)->org_cost = cost;
#line 164
  (new + 0)->cost = cost;
#line 165
  (new + 0)->flow = red_cost;
#line 167
  pos = 1L;
#line 168
  if ((new + 1)->flow > (new + 2)->flow) {
#line 168
    cmp = 2L;
  } else {
#line 168
    cmp = 3L;
  }
  {
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 169
    if (cmp <= 300000L) {
#line 169
      if (! (red_cost < (new + (cmp - 1L))->flow)) {
#line 169
        goto while_break;
      }
    } else {
#line 169
      goto while_break;
    }
#line 171
    (new + (pos - 1L))->tail = (new + (cmp - 1L))->tail;
#line 172
    (new + (pos - 1L))->head = (new + (cmp - 1L))->head;
#line 173
    (new + (pos - 1L))->cost = (new + (cmp - 1L))->cost;
#line 174
    (new + (pos - 1L))->org_cost = (new + (cmp - 1L))->cost;
#line 175
    (new + (pos - 1L))->flow = (new + (cmp - 1L))->flow;
#line 177
    (new + (cmp - 1L))->tail = tail;
#line 178
    (new + (cmp - 1L))->head = head;
#line 179
    (new + (cmp - 1L))->cost = cost;
#line 180
    (new + (cmp - 1L))->org_cost = cost;
#line 181
    (new + (cmp - 1L))->flow = red_cost;
#line 182
    pos = cmp;
#line 183
    cmp *= 2L;
#line 184
    if (cmp + 1L <= 300000L) {
#line 185
      if ((new + (cmp - 1L))->flow < (new + cmp)->flow) {
#line 186
        cmp ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return;
}
}
#line 198 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.c"
long price_out_impl(network_t *net___0 ) 
{ 
  long i ;
  long trips ;
  long new_arcs ;
  long resized ;
  long latest ;
  long min_impl_duration ;
  register cost_t bigM ;
  register cost_t head_potential ;
  register cost_t arc_cost ;
  register cost_t red_cost ;
  register cost_t bigM_minus_min_impl_duration ;
  register arc_t *arcout ;
  register arc_t *arcin ;
  register arc_t *arcnew ;
  register arc_t *stop ;
  register arc_t *first_of_sparse_list ;
  register node_t *tail ;
  register node_t *head ;
  long tmp ;

  {
#line 206
  new_arcs = 0L;
#line 207
  resized = 0L;
#line 209
  min_impl_duration = 15L;
#line 211
  bigM = net___0->bigM;
#line 213
  arc_cost = (cost_t )30;
#line 221
  bigM_minus_min_impl_duration = bigM - min_impl_duration;
#line 223
  if (net___0->m + 300000L > net___0->max_m) {
#line 223
    if ((net___0->n_trips * net___0->n_trips) / 2L + net___0->m > net___0->max_m) {
      {
#line 226
      resized = 1L;
      {
#line 227
      tmp = resize_prob(net___0);
      }
      }
#line 227
      if (tmp) {
#line 228
        return (-1L);
      }
      {
      {
#line 230
      refresh_neighbour_lists(net___0);
      }
      }
    }
  }
#line 233
  arcnew = net___0->stop_arcs;
#line 234
  trips = net___0->n_trips;
#line 236
  arcout = net___0->arcs;
#line 237
  i = 0L;
  {
  {
#line 237
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 237
    if (i < trips) {
#line 237
      if (! ((arcout + 1)->ident == -1L)) {
#line 237
        goto while_break;
      }
    } else {
#line 237
      goto while_break;
    }
#line 237
    i ++;
#line 237
    arcout += 3;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  first_of_sparse_list = (arc_t *)((void *)0);
  {
  {
#line 239
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 239
    if (! (i < trips)) {
#line 239
      goto while_break___0;
    }
#line 241
    if ((arcout + 1)->ident != -1L) {
#line 243
      (((arcout->head)->firstout)->head)->mark = (size_t )first_of_sparse_list;
#line 244
      first_of_sparse_list = arcout + 1;
    }
#line 247
    if (arcout->ident == -1L) {
#line 248
      goto __Cont;
    }
#line 250
    head = arcout->head;
#line 251
    latest = (head->time - arcout->org_cost) + bigM_minus_min_impl_duration;
#line 254
    head_potential = head->potential;
#line 256
    arcin = (arc_t *)(first_of_sparse_list->tail)->mark;
    {
    {
#line 257
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 257
      if (! arcin) {
#line 257
        goto while_break___1;
      }
#line 259
      tail = arcin->tail;
#line 261
      if (tail->time + arcin->org_cost > latest) {
#line 263
        arcin = (arc_t *)tail->mark;
#line 264
        goto while_continue___1;
      }
      {
      {
#line 267
      red_cost = compute_red_cost(arc_cost, tail, head_potential);
      }
      }
#line 269
      if (red_cost < 0L) {
#line 271
        if (new_arcs < 300000L) {
          {
          {
#line 273
          insert_new_arc(arcnew, new_arcs, tail, head, arc_cost, red_cost);
          }
#line 275
          new_arcs ++;
          }
        } else
#line 277
        if ((arcnew + 0)->flow > red_cost) {
          {
          {
#line 278
          replace_weaker_arc(arcnew, tail, head, arc_cost, red_cost);
          }
          }
        }
      }
#line 282
      arcin = (arc_t *)tail->mark;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 239
    i ++;
#line 239
    arcout += 3;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  if (new_arcs) {
#line 288
    arcnew = net___0->stop_arcs;
#line 289
    net___0->stop_arcs += new_arcs;
#line 290
    stop = (arc_t *)((void *)net___0->stop_arcs);
#line 291
    if (resized) {
      {
      {
#line 293
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 293
        if (! ((unsigned long )arcnew != (unsigned long )stop)) {
#line 293
          goto while_break___2;
        }
#line 295
        arcnew->flow = (flow_t )0;
#line 296
        arcnew->ident = 1L;
#line 293
        arcnew ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 301
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 301
        if (! ((unsigned long )arcnew != (unsigned long )stop)) {
#line 301
          goto while_break___3;
        }
#line 303
        arcnew->flow = (flow_t )0;
#line 304
        arcnew->ident = 1L;
#line 305
        arcnew->nextout = (arcnew->tail)->firstout;
#line 306
        (arcnew->tail)->firstout = arcnew;
#line 307
        arcnew->nextin = (arcnew->head)->firstin;
#line 308
        (arcnew->head)->firstin = arcnew;
#line 301
        arcnew ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 312
    net___0->m += new_arcs;
#line 313
    net___0->m_impl += new_arcs;
  }
#line 317
  return (new_arcs);
}
}
#line 326 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/implicit.c"
long suspend_impl(network_t *net___0 , cost_t threshold , long all ) 
{ 
  long susp ;
  cost_t red_cost ;
  arc_t *new_arc ;
  arc_t *arc ;
  void *stop ;

  {
#line 342
  if (all) {
#line 343
    susp = net___0->m_impl;
  } else {
#line 346
    stop = (void *)net___0->stop_arcs;
#line 347
    new_arc = net___0->arcs + (net___0->m - net___0->m_impl);
#line 348
    susp = 0L;
#line 348
    arc = new_arc;
    {
    {
#line 348
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 348
      if (! ((unsigned long )arc < (unsigned long )((arc_t *)stop))) {
#line 348
        goto while_break;
      }
#line 350
      if (arc->ident == 1L) {
#line 351
        red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
      } else {
#line 355
        red_cost = (cost_t )-2;
#line 357
        if (arc->ident == 0L) {
#line 359
          if ((unsigned long )(arc->tail)->basic_arc == (unsigned long )arc) {
#line 360
            (arc->tail)->basic_arc = new_arc;
          } else {
#line 362
            (arc->head)->basic_arc = new_arc;
          }
        }
      }
#line 366
      if (red_cost > threshold) {
#line 367
        susp ++;
      } else {
#line 370
        *new_arc = *arc;
#line 371
        new_arc ++;
      }
#line 348
      arc ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 377
  if (susp) {
    {
#line 379
    net___0->m -= susp;
#line 380
    net___0->m_impl -= susp;
#line 381
    net___0->stop_arcs -= susp;
    {
#line 383
    refresh_neighbour_lists(net___0);
    }
    }
  }
#line 386
  return (susp);
}
}
#line 401 "/usr/include/stdio.h"
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
#line 526
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 558 "/usr/include/stdlib.h"
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 28 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.h"
long getfree(network_t *net___0 ) ;
#line 24 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/readmin.h"
long read_min(network_t *net___0 ) ;
#line 24 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/readmin.c"
long read_min(network_t *net___0 ) 
{ 
  FILE *in ;
  char instring[201] ;
  long t ;
  long h ;
  long c ;
  long i ;
  arc_t *arc ;
  node_t *node ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  cost_t tmp___4 ;
  cost_t tmp___5 ;
  cost_t tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 30
  in = (FILE *)((void *)0);
  {
#line 38
  in = fopen((char const   */* __restrict  */)(net___0->inputfile), (char const   */* __restrict  */)"r");
  }
  }
#line 38
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 39
    return (-1L);
  }
  {
  {
#line 41
  fgets((char */* __restrict  */)(instring), 200, (FILE */* __restrict  */)in);
  }
  {
#line 42
  tmp = sscanf((char const   */* __restrict  */)(instring), (char const   */* __restrict  */)"%ld %ld",
               & t, & h);
  }
  }
#line 42
  if (tmp != 2) {
#line 43
    return (-1L);
  }
  {
#line 46
  net___0->n_trips = t;
#line 47
  net___0->m_org = h;
#line 48
  net___0->n = (t + t) + 1L;
#line 49
  net___0->m = ((t + t) + t) + h;
#line 51
  net___0->max_m = 3014656L;
  {
#line 57
  tmp___0 = calloc((size_t )(net___0->n + 1L), (size_t )sizeof(node_t ));
  }
#line 57
  net___0->nodes = (node_t *)tmp___0;
  {
#line 58
  tmp___1 = calloc((size_t )net___0->n, (size_t )sizeof(arc_t ));
  }
#line 58
  net___0->dummy_arcs = (arc_t *)tmp___1;
  {
#line 59
  tmp___2 = calloc((size_t )net___0->max_m, (size_t )sizeof(arc_t ));
  }
#line 59
  net___0->arcs = (arc_t *)tmp___2;
  }
#line 61
  if (net___0->nodes) {
#line 61
    if (net___0->arcs) {
#line 61
      if (! net___0->dummy_arcs) {
        {
        {
#line 63
        printf((char const   */* __restrict  */)"read_min(): not enough memory\n");
        }
        {
#line 64
        getfree(net___0);
        }
        }
#line 65
        return (-1L);
      }
    } else {
      {
      {
#line 63
      printf((char const   */* __restrict  */)"read_min(): not enough memory\n");
      }
      {
#line 64
      getfree(net___0);
      }
      }
#line 65
      return (-1L);
    }
  } else {
    {
    {
#line 63
    printf((char const   */* __restrict  */)"read_min(): not enough memory\n");
    }
    {
#line 64
    getfree(net___0);
    }
    }
#line 65
    return (-1L);
  }
#line 84
  net___0->stop_nodes = (net___0->nodes + net___0->n) + 1;
#line 85
  net___0->stop_arcs = net___0->arcs + net___0->m;
#line 86
  net___0->stop_dummy = net___0->dummy_arcs + net___0->n;
#line 89
  node = net___0->nodes;
#line 90
  arc = net___0->arcs;
#line 92
  i = 1L;
  {
  {
#line 92
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i <= net___0->n_trips)) {
#line 92
      goto while_break;
    }
    {
    {
#line 94
    fgets((char */* __restrict  */)(instring), 200, (FILE */* __restrict  */)in);
    }
    {
#line 96
    tmp___3 = sscanf((char const   */* __restrict  */)(instring), (char const   */* __restrict  */)"%ld %ld",
                     & t, & h);
    }
    }
#line 96
    if (tmp___3 != 2) {
#line 97
      return (-1L);
    } else
#line 96
    if (t > h) {
#line 97
      return (-1L);
    }
#line 99
    (node + i)->number = - i;
#line 100
    (node + i)->flow = (flow_t )-1;
#line 102
    (node + (i + net___0->n_trips))->number = i;
#line 103
    (node + (i + net___0->n_trips))->flow = (flow_t )1;
#line 105
    (node + i)->time = t;
#line 106
    (node + (i + net___0->n_trips))->time = h;
#line 108
    arc->tail = node + net___0->n;
#line 109
    arc->head = node + i;
#line 110
    tmp___4 = net___0->bigM + 15L;
#line 110
    arc->cost = tmp___4;
#line 110
    arc->org_cost = tmp___4;
#line 111
    arc->nextout = (arc->tail)->firstout;
#line 112
    (arc->tail)->firstout = arc;
#line 113
    arc->nextin = (arc->head)->firstin;
#line 114
    (arc->head)->firstin = arc;
#line 115
    arc ++;
#line 117
    arc->tail = node + (i + net___0->n_trips);
#line 118
    arc->head = node + net___0->n;
#line 119
    tmp___5 = (cost_t )15;
#line 119
    arc->cost = tmp___5;
#line 119
    arc->org_cost = tmp___5;
#line 120
    arc->nextout = (arc->tail)->firstout;
#line 121
    (arc->tail)->firstout = arc;
#line 122
    arc->nextin = (arc->head)->firstin;
#line 123
    (arc->head)->firstin = arc;
#line 124
    arc ++;
#line 126
    arc->tail = node + i;
#line 127
    arc->head = node + (i + net___0->n_trips);
#line 128
    if (net___0->bigM > (long )1.0e7) {
#line 128
      tmp___7 = net___0->bigM;
    } else {
#line 128
      tmp___7 = (long )1.0e7;
    }
#line 128
    tmp___6 = 2L * tmp___7;
#line 128
    arc->cost = tmp___6;
#line 128
    arc->org_cost = tmp___6;
#line 129
    arc->nextout = (arc->tail)->firstout;
#line 130
    (arc->tail)->firstout = arc;
#line 131
    arc->nextin = (arc->head)->firstin;
#line 132
    (arc->head)->firstin = arc;
#line 133
    arc ++;
#line 92
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (i != net___0->n_trips + 1L) {
#line 138
    return (-1L);
  }
#line 141
  i = 0L;
  {
  {
#line 141
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 141
    if (! (i < net___0->m_org)) {
#line 141
      goto while_break___0;
    }
    {
    {
#line 143
    fgets((char */* __restrict  */)(instring), 200, (FILE */* __restrict  */)in);
    }
    {
#line 145
    tmp___8 = sscanf((char const   */* __restrict  */)(instring), (char const   */* __restrict  */)"%ld %ld %ld",
                     & t, & h, & c);
    }
    }
#line 145
    if (tmp___8 != 3) {
#line 146
      return (-1L);
    }
#line 148
    arc->tail = node + (t + net___0->n_trips);
#line 149
    arc->head = node + h;
#line 150
    arc->org_cost = c;
#line 151
    arc->cost = c;
#line 152
    arc->nextout = (arc->tail)->firstout;
#line 153
    (arc->tail)->firstout = arc;
#line 154
    arc->nextin = (arc->head)->firstin;
#line 155
    (arc->head)->firstin = arc;
#line 141
    i ++;
#line 141
    arc ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 159
  if ((unsigned long )net___0->stop_arcs != (unsigned long )arc) {
#line 161
    net___0->stop_arcs = arc;
#line 162
    arc = net___0->arcs;
#line 163
    net___0->m = 0L;
    {
    {
#line 163
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 163
      if (! ((unsigned long )arc < (unsigned long )net___0->stop_arcs)) {
#line 163
        goto while_break___1;
      }
#line 164
      (net___0->m) ++;
#line 163
      arc ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 165
    net___0->m_org = net___0->m;
  }
  {
  {
#line 168
  fclose(in);
  }
#line 171
  net___0->clustfile[0] = (char)0;
#line 173
  i = 1L;
  }
  {
  {
#line 173
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 173
    if (! (i <= net___0->n_trips)) {
#line 173
      goto while_break___2;
    }
#line 175
    if (net___0->bigM > (long )1.0e7) {
#line 175
      tmp___9 = net___0->bigM;
    } else {
#line 175
      tmp___9 = (long )1.0e7;
    }
#line 175
    (net___0->arcs + (3L * i - 1L))->cost = -2L * tmp___9;
#line 177
    if (net___0->bigM > (long )1.0e7) {
#line 177
      tmp___10 = net___0->bigM;
    } else {
#line 177
      tmp___10 = (long )1.0e7;
    }
#line 177
    (net___0->arcs + (3L * i - 1L))->org_cost = -2L * tmp___10;
#line 173
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 182
  return (0L);
}
}
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 569 "/usr/include/stdlib.h"
extern void free(void *__ptr ) ;
#line 24 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.h"
double flow_cost(network_t *net___0 ) ;
#line 25
double flow_org_cost(network_t *net___0 ) ;
#line 23 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
void refresh_neighbour_lists(network_t *net___0 ) 
{ 
  node_t *node ;
  arc_t *arc ;
  void *stop ;

  {
#line 35
  node = net___0->nodes;
#line 36
  stop = (void *)net___0->stop_nodes;
  {
  {
#line 36
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )node < (unsigned long )((node_t *)stop))) {
#line 36
      goto while_break;
    }
#line 38
    node->firstin = (arc_t *)((void *)0);
#line 39
    node->firstout = (arc_t *)((void *)0);
#line 36
    node ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  arc = net___0->arcs;
#line 43
  stop = (void *)net___0->stop_arcs;
  {
  {
#line 43
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 43
    if (! ((unsigned long )arc < (unsigned long )((arc_t *)stop))) {
#line 43
      goto while_break___0;
    }
#line 45
    arc->nextout = (arc->tail)->firstout;
#line 46
    (arc->tail)->firstout = arc;
#line 47
    arc->nextin = (arc->head)->firstin;
#line 48
    (arc->head)->firstin = arc;
#line 43
    arc ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 51
  return;
}
}
#line 64 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
long refresh_potential(network_t *net___0 ) 
{ 
  node_t *stop ;
  node_t *node ;
  node_t *tmp ;
  node_t *root ;
  long checksum ;

  {
#line 70
  stop = net___0->stop_nodes;
#line 72
  root = net___0->nodes;
#line 73
  checksum = 0L;
#line 75
  node = root;
#line 75
  stop = net___0->stop_nodes;
  {
  {
#line 75
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 75
    if (! ((unsigned long )node < (unsigned long )stop)) {
#line 75
      goto while_break;
    }
#line 76
    node->mark = (size_t )0;
#line 75
    node ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  root->potential = -100000000L;
#line 79
  node = root->child;
#line 79
  tmp = node;
  {
  {
#line 80
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )node != (unsigned long )root)) {
#line 80
      goto while_break___0;
    }
    {
    {
#line 82
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 82
      if (! node) {
#line 82
        goto while_break___1;
      }
#line 84
      if (node->orientation == 1L) {
#line 85
        node->potential = (node->basic_arc)->cost + (node->pred)->potential;
      } else {
#line 88
        node->potential = (node->pred)->potential - (node->basic_arc)->cost;
#line 89
        checksum ++;
      }
#line 92
      tmp = node;
#line 93
      node = node->child;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 96
    node = tmp;
    {
    {
#line 98
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 98
      if (! node->pred) {
#line 98
        goto while_break___2;
      }
#line 100
      tmp = node->sibling;
#line 101
      if (tmp) {
#line 103
        node = tmp;
#line 104
        goto while_break___2;
      } else {
#line 107
        node = node->pred;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  return (checksum);
}
}
#line 121 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
double flow_cost(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
#line 132
  fleet = 0L;
#line 133
  operational_cost = (cost_t )0;
#line 136
  stop = (void *)net___0->stop_arcs;
#line 137
  arc = net___0->arcs;
  {
  {
#line 137
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 137
    if (! ((unsigned long )arc != (unsigned long )((arc_t *)stop))) {
#line 137
      goto while_break;
    }
#line 139
    if (arc->ident == 2L) {
#line 140
      arc->flow = (flow_t )1;
    } else {
#line 142
      arc->flow = (flow_t )0;
    }
#line 137
    arc ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  stop = (void *)net___0->stop_nodes;
#line 146
  node = net___0->nodes;
#line 146
  node ++;
  {
  {
#line 146
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 146
    if (! ((unsigned long )node != (unsigned long )((node_t *)stop))) {
#line 146
      goto while_break___0;
    }
#line 147
    (node->basic_arc)->flow = node->flow;
#line 146
    node ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  stop = (void *)net___0->stop_arcs;
#line 150
  arc = net___0->arcs;
  {
  {
#line 150
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )arc != (unsigned long )((arc_t *)stop))) {
#line 150
      goto while_break___1;
    }
#line 152
    if (arc->flow) {
#line 154
      if ((arc->tail)->number < 0L) {
#line 154
        if (! ((arc->head)->number > 0L)) {
#line 154
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 156
      if (! (arc->tail)->number) {
#line 158
        operational_cost += arc->cost - net___0->bigM;
#line 159
        fleet ++;
      } else {
#line 162
        operational_cost += arc->cost;
      }
    }
#line 150
    arc ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 168
  return ((double )fleet * (double )net___0->bigM + (double )operational_cost);
}
}
#line 181 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
double flow_org_cost(network_t *net___0 ) 
{ 
  arc_t *arc ;
  node_t *node ;
  void *stop ;
  long fleet ;
  cost_t operational_cost ;

  {
#line 192
  fleet = 0L;
#line 193
  operational_cost = (cost_t )0;
#line 196
  stop = (void *)net___0->stop_arcs;
#line 197
  arc = net___0->arcs;
  {
  {
#line 197
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 197
    if (! ((unsigned long )arc != (unsigned long )((arc_t *)stop))) {
#line 197
      goto while_break;
    }
#line 199
    if (arc->ident == 2L) {
#line 200
      arc->flow = (flow_t )1;
    } else {
#line 202
      arc->flow = (flow_t )0;
    }
#line 197
    arc ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  stop = (void *)net___0->stop_nodes;
#line 206
  node = net___0->nodes;
#line 206
  node ++;
  {
  {
#line 206
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 206
    if (! ((unsigned long )node != (unsigned long )((node_t *)stop))) {
#line 206
      goto while_break___0;
    }
#line 207
    (node->basic_arc)->flow = node->flow;
#line 206
    node ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 209
  stop = (void *)net___0->stop_arcs;
#line 210
  arc = net___0->arcs;
  {
  {
#line 210
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 210
    if (! ((unsigned long )arc != (unsigned long )((arc_t *)stop))) {
#line 210
      goto while_break___1;
    }
#line 212
    if (arc->flow) {
#line 214
      if ((arc->tail)->number < 0L) {
#line 214
        if (! ((arc->head)->number > 0L)) {
#line 214
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 216
      if (! (arc->tail)->number) {
#line 218
        operational_cost += arc->org_cost - net___0->bigM;
#line 219
        fleet ++;
      } else {
#line 222
        operational_cost += arc->org_cost;
      }
    }
#line 210
    arc ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 227
  return ((double )fleet * (double )net___0->bigM + (double )operational_cost);
}
}
#line 240 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
long primal_feasible(network_t *net___0 ) 
{ 
  void *stop ;
  node_t *node ;
  arc_t *dummy ;
  arc_t *stop_dummy ;
  arc_t *arc ;
  flow_t flow ;
  flow_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 248
  dummy = net___0->dummy_arcs;
#line 249
  stop_dummy = net___0->stop_dummy;
#line 254
  node = net___0->nodes;
#line 255
  stop = (void *)net___0->stop_nodes;
#line 257
  node ++;
  {
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 257
    if (! ((unsigned long )node < (unsigned long )((node_t *)stop))) {
#line 257
      goto while_break;
    }
#line 259
    arc = node->basic_arc;
#line 260
    flow = node->flow;
#line 261
    if ((unsigned long )arc >= (unsigned long )dummy) {
#line 261
      if ((unsigned long )arc < (unsigned long )stop_dummy) {
#line 263
        if (flow >= 0L) {
#line 263
          tmp = flow;
        } else {
#line 263
          tmp = - flow;
        }
#line 263
        if (tmp > net___0->feas_tol) {
          {
          {
#line 265
          printf((char const   */* __restrict  */)"PRIMAL NETWORK SIMPLEX: ");
          }
          {
#line 266
          printf((char const   */* __restrict  */)"artificial arc with nonzero flow, node %ld (%ld)\n",
                 node->number, flow);
          }
          }
        }
      } else {
#line 261
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 272
    if (flow < - net___0->feas_tol) {
      {
      {
#line 275
      printf((char const   */* __restrict  */)"PRIMAL NETWORK SIMPLEX: ");
      }
      {
#line 276
      printf((char const   */* __restrict  */)"basis primal infeasible (%ld)\n", flow);
      }
#line 277
      net___0->feasible = 0L;
      }
#line 278
      return (1L);
    } else
#line 272
    if (flow - 1L > net___0->feas_tol) {
      {
      {
#line 275
      printf((char const   */* __restrict  */)"PRIMAL NETWORK SIMPLEX: ");
      }
      {
#line 276
      printf((char const   */* __restrict  */)"basis primal infeasible (%ld)\n", flow);
      }
#line 277
      net___0->feasible = 0L;
      }
#line 278
      return (1L);
    }
#line 257
    node ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  net___0->feasible = 1L;
#line 285
  return (0L);
}
}
#line 298 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
long dual_feasible(network_t *net___0 ) 
{ 
  arc_t *arc ;
  arc_t *stop ;
  cost_t red_cost ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 305
  stop = net___0->stop_arcs;
#line 310
  arc = net___0->arcs;
  {
  {
#line 310
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 310
    if (! ((unsigned long )arc < (unsigned long )stop)) {
#line 310
      goto while_break;
    }
#line 312
    red_cost = (arc->cost - (arc->tail)->potential) + (arc->head)->potential;
    {
#line 329
    if (arc->ident == 1L) {
#line 329
      goto case_1;
    }
#line 329
    if (arc->ident == 0L) {
#line 329
      goto case_1;
    }
#line 339
    if (arc->ident == 2L) {
#line 339
      goto case_2;
    }
#line 350
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 330
    if (red_cost < - net___0->feas_tol) {
#line 335
      goto DUAL_INFEAS;
    }
#line 338
    goto switch_break;
    case_2: /* CIL Label */ 
#line 340
    if (red_cost > net___0->feas_tol) {
#line 345
      goto DUAL_INFEAS;
    }
#line 348
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 351
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 310
    arc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (0L);
  DUAL_INFEAS: 
  {
  {
#line 358
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DUAL NETWORK SIMPLEX: ");
  }
  {
#line 359
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"basis dual infeasible\n");
  }
  }
#line 360
  return (1L);
}
}
#line 370 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcfutil.c"
long getfree(network_t *net___0 ) 
{ 
  node_t *tmp ;
  arc_t *tmp___0 ;
  arc_t *tmp___1 ;

  {
#line 378
  if (net___0->nodes) {
    {
    {
#line 378
    free((void *)net___0->nodes);
    }
    }
  }
#line 379
  if (net___0->arcs) {
    {
    {
#line 379
    free((void *)net___0->arcs);
    }
    }
  }
#line 380
  if (net___0->dummy_arcs) {
    {
    {
#line 380
    free((void *)net___0->dummy_arcs);
    }
    }
  }
#line 381
  tmp = (node_t *)((void *)0);
#line 381
  net___0->stop_nodes = tmp;
#line 381
  net___0->nodes = tmp;
#line 382
  tmp___0 = (arc_t *)((void *)0);
#line 382
  net___0->stop_arcs = tmp___0;
#line 382
  net___0->arcs = tmp___0;
#line 383
  tmp___1 = (arc_t *)((void *)0);
#line 383
  net___0->stop_dummy = tmp___1;
#line 383
  net___0->dummy_arcs = tmp___1;
#line 385
  return (0L);
}
}
#line 612 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 58 "/usr/include/string.h"
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 82
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcf.c"
network_t net  ;
#line 29 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcf.c"
long global_opt(void) 
{ 
  long new_arcs ;
  double tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 36
  new_arcs = -1L;
  {
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 39
    if (! new_arcs) {
#line 39
      goto while_break;
    }
    {
    {
#line 42
    printf((char const   */* __restrict  */)"active arcs                : %ld\n",
           net.m);
    }
    {
#line 45
    primal_net_simplex(& net);
    }
    {
#line 49
    printf((char const   */* __restrict  */)"simplex iterations         : %ld\n",
           net.iterations);
    }
    {
#line 50
    tmp = flow_cost(& net);
    }
    {
#line 50
    printf((char const   */* __restrict  */)"flow value                 : %0.0f\n",
           tmp);
    }
    {
#line 54
    new_arcs = price_out_impl(& net);
    }
    }
#line 57
    if (new_arcs) {
      {
      {
#line 58
      printf((char const   */* __restrict  */)"new implicit arcs          : %ld\n",
             new_arcs);
      }
      }
    }
#line 61
    if (new_arcs < 0L) {
      {
      {
#line 64
      printf((char const   */* __restrict  */)"not enough memory, exit(-1)\n");
      }
      {
#line 67
      exit(-1);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 76
  printf((char const   */* __restrict  */)"checksum                   : %ld\n", net.checksum);
  }
  }
#line 78
  return (0L);
}
}
#line 87 "/local/sparrow_test/test/SPEC2000/CINT2000/181.mcf/src/mcf.c"
int main(int argc , char **argv ) 
{ 
  long tmp ;
  long tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 94
  if (argc < 2) {
#line 95
    return (-1);
  }
  {
  {
#line 98
  printf((char const   */* __restrict  */)"\nMCF SPEC version 1.6.%s\n", "I");
  }
  {
#line 99
  printf((char const   */* __restrict  */)"by  Andreas Loebel\n");
  }
  {
#line 100
  printf((char const   */* __restrict  */)"Copyright (c) 1998,1999   ZIB Berlin\n");
  }
  {
#line 101
  printf((char const   */* __restrict  */)"All Rights Reserved.\n");
  }
  {
#line 102
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 105
  memset((void *)(& net), 0, (size_t )sizeof(network_t ));
  }
#line 106
  net.bigM = (long )1.0e7;
  {
#line 108
  strcpy((char */* __restrict  */)(net.inputfile), (char const   */* __restrict  */)*(argv + 1));
  }
  {
#line 110
  tmp = read_min(& net);
  }
  }
#line 110
  if (tmp) {
    {
    {
#line 112
    printf((char const   */* __restrict  */)"read error, exit\n");
    }
    {
#line 113
    getfree(& net);
    }
    }
#line 114
    return (-1);
  }
  {
  {
#line 119
  printf((char const   */* __restrict  */)"nodes                      : %ld\n", net.n_trips);
  }
  {
#line 123
  primal_start_artificial(& net);
  }
  {
#line 124
  global_opt();
  }
  {
#line 131
  printf((char const   */* __restrict  */)"optimal\n");
  }
  {
#line 136
  tmp___0 = write_circulations((char *)"mcf.out", & net);
  }
  }
#line 136
  if (tmp___0) {
    {
    {
#line 138
    getfree(& net);
    }
    }
#line 139
    return (-1);
  }
  {
  {
#line 143
  getfree(& net);
  }
  }
#line 144
  return (0);
}
}
