/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 14 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.h"
struct cfg_option {
   char *name ;
   void *ptr ;
   void ( __attribute__((__regparm__(3))) (*parse_fn))(void *ptr ) ;
};
#line 6 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.h"
enum plugout_endian {
    PLUGOUT_ENDIAN_BIG = 0,
    PLUGOUT_ENDIAN_LITTLE = 1,
    PLUGOUT_ENDIAN_NATIVE = 2
} ;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.h"
struct output_plugin {
   char *name ;
   char *description ;
   long flags ;
   long ( __attribute__((__regparm__(3))) (*open))(enum plugout_endian endian , long rate ) ;
   int ( __attribute__((__regparm__(3))) (*skip))(int subsong ) ;
   int ( __attribute__((__regparm__(3))) (*io))(long cycles , uint32_t addr , uint8_t val ) ;
   ssize_t ( __attribute__((__regparm__(3))) (*write))(void const   *buf , size_t count ) ;
   void ( __attribute__((__regparm__(3))) (*close))(void) ;
};
#line 195 "/usr/include/sys/types.h"
typedef signed char int8_t;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
struct __anonstruct_rn_29 {
   uint8_t c ;
   uint8_t b ;
   uint8_t e ;
   uint8_t d ;
   uint8_t l ;
   uint8_t h ;
   uint8_t a ;
   uint8_t f ;
   uint16_t sp ;
   uint16_t pc ;
};
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
union __anonunion_gbcpu_regs_u_28 {
   uint8_t ri[12] ;
   struct __anonstruct_rn_29 rn ;
};
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
typedef union __anonunion_gbcpu_regs_u_28 gbcpu_regs_u;
#line 99 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
typedef void ( __attribute__((__regparm__(3))) (*gbcpu_put_fn))(uint32_t addr , uint8_t val );
#line 100 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
typedef uint32_t ( __attribute__((__regparm__(3))) (*gbcpu_get_fn))(uint32_t addr );
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
struct opinfo;
#line 31 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
struct opinfo {
   void ( __attribute__((__regparm__(3))) (*fn))(uint32_t op , struct opinfo  const  *oi ) ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 17 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.h"
struct gbs;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.h"
struct gbs_subsong_info {
   uint32_t len ;
   char *title ;
};
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.h"
struct gbs {
   char *buf ;
   long version ;
   long songs ;
   long defaultsong ;
   uint16_t load ;
   uint16_t init ;
   uint16_t play ;
   uint16_t stack ;
   uint8_t tma ;
   uint8_t tmc ;
   char *title ;
   char *author ;
   char *copyright ;
   unsigned long codelen ;
   char *code ;
   char *exthdr ;
   size_t filesize ;
   uint32_t crc ;
   uint32_t crcnow ;
   struct gbs_subsong_info *subsong_info ;
   char *strings ;
   char v1strings[99] ;
   uint8_t *rom ;
   unsigned long romsize ;
   long long ticks ;
   int16_t lmin ;
   int16_t lmax ;
   int16_t lvol ;
   int16_t rmin ;
   int16_t rmax ;
   int16_t rvol ;
   long subsong_timeout ;
   long silence_timeout ;
   long fadeout ;
   long gap ;
   long long silence_start ;
   long subsong ;
   long ( __attribute__((__regparm__(3))) (*nextsubsong_cb))(struct gbs *gbs , void *priv ) ;
   void *nextsubsong_cb_priv ;
};
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 16 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.h"
struct gbhw_buffer {
   int16_t *data ;
   long pos ;
   long l_lvl ;
   long r_lvl ;
   long bytes ;
   long samples ;
   long cycles ;
};
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.h"
struct gbhw_channel {
   long mute ;
   long master ;
   long leftgate ;
   long rightgate ;
   long l_lvl ;
   long r_lvl ;
   long volume ;
   long env_dir ;
   long env_tc ;
   long env_ctr ;
   long sweep_dir ;
   long sweep_tc ;
   long sweep_ctr ;
   long sweep_shift ;
   long len ;
   long len_enable ;
   long div_tc ;
   long div_ctr ;
   long duty_tc ;
   long duty_ctr ;
};
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_7 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_7 __sigset_t;
#line 25 "/usr/include/bits/termios.h"
typedef unsigned char cc_t;
#line 26 "/usr/include/bits/termios.h"
typedef unsigned int speed_t;
#line 27 "/usr/include/bits/termios.h"
typedef unsigned int tcflag_t;
#line 30 "/usr/include/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_47 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_47 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 33 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.c"
typedef struct output_plugin  const  *output_plugin_const_t;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 471
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 116
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/common.h"
__inline static char *_(char const   *msgid ) 
{ 
  char *tmp ;

  {
  {
  {
#line 55
  tmp = gettext(msgid);
  }
  }
#line 55
  return (tmp);
}
}
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.h"
void ( __attribute__((__regparm__(3))) cfg_string)(void *ptr ) ;
#line 21
void ( __attribute__((__regparm__(3))) cfg_long)(void *ptr ) ;
#line 22
void ( __attribute__((__regparm__(3))) cfg_endian)(void *ptr ) ;
#line 23
void ( __attribute__((__regparm__(3))) cfg_parse)(char const   *fname , struct cfg_option  const  *options___1 ) ;
#line 24
char *( __attribute__((__regparm__(3))) get_userconfig)(char const   *cfgfile___1 ) ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_line  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_char  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static FILE *cfg_file  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextchar_state  ;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char ( __attribute__((__regparm__(3))) nextchar)(void) 
{ 
  long c___3 ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 30
  if (! ((unsigned long )cfg_file != (unsigned long )((void *)0))) {
    {
    {
#line 30
    __assert_fail("cfg_file != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c",
                  30U, "nextchar");
    }
    }
  }
  {
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 33
    tmp = fgetc(cfg_file);
    }
#line 33
    c___3 = (long )tmp;
    }
#line 33
    if (c___3 == -1L) {
#line 33
      return ((char)0);
    }
#line 35
    if (c___3 == 10L) {
#line 36
      cfg_char = 0L;
#line 37
      cfg_line ++;
    } else {
#line 38
      cfg_char ++;
    }
    {
#line 41
    if (nextchar_state == 0L) {
#line 41
      goto case_0;
    }
#line 45
    if (nextchar_state == 1L) {
#line 45
      goto case_1;
    }
#line 49
    if (nextchar_state == 2L) {
#line 49
      goto case_2;
    }
#line 40
    goto switch_break;
    case_0: /* CIL Label */ 
#line 42
    if (c___3 == 92L) {
#line 42
      nextchar_state = 1L;
    } else
#line 43
    if (c___3 == 35L) {
#line 43
      nextchar_state = 2L;
    }
#line 44
    goto switch_break;
    case_1: /* CIL Label */ 
#line 46
    nextchar_state = 0L;
#line 47
    if (c___3 == 110L) {
#line 47
      c___3 = (long )'\n';
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
#line 50
    if (c___3 == 0L) {
#line 50
      nextchar_state = 0L;
    } else
#line 50
    if (c___3 == 10L) {
#line 50
      nextchar_state = 0L;
    }
#line 51
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 32
    if (! (nextchar_state != 0L)) {
#line 32
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return ((char )c___3);
}
}
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long state  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextstate  ;
#line 60 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long c  ;
#line 61 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char const   *filename  ;
#line 63 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static void ( __attribute__((__regparm__(3))) err_expect)(char *s ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 65
  tmp = _("\'%s\' expected at %s line %ld char %ld.\n");
  }
  {
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, s,
          filename, cfg_line, cfg_char);
  }
  {
#line 67
  tmp___0 = nextchar();
  }
#line 67
  c = (long )tmp___0;
#line 68
  state = 0L;
#line 69
  nextstate = 1L;
  }
#line 70
  return;
}
}
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
void ( __attribute__((__regparm__(3))) cfg_endian)(void *ptr ) 
{ 
  enum plugout_endian *endian___1 ;
  int tmp ;
  char tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 74
  endian___1 = (enum plugout_endian *)ptr;
  {
#line 76
  tmp = tolower((int )c);
  }
#line 76
  c = (long )tmp;
  }
#line 77
  if (c != 98L) {
#line 77
    if (c != 108L) {
#line 77
      if (c != 110L) {
        {
        {
#line 78
        err_expect((char *)"[bln]");
        }
        }
#line 79
        return;
      }
    }
  }
  {
#line 83
  if (c == 98L) {
#line 83
    goto case_98;
  }
#line 84
  if (c == 108L) {
#line 84
    goto case_108;
  }
#line 85
  goto switch_default;
  case_98: /* CIL Label */ 
#line 83
  *endian___1 = (enum plugout_endian )0;
#line 83
  goto switch_break;
  case_108: /* CIL Label */ 
#line 84
  *endian___1 = (enum plugout_endian )1;
#line 84
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 85
  *endian___1 = (enum plugout_endian )2;
#line 85
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 88
  tmp___0 = nextchar();
  }
#line 88
  c = (long )tmp___0;
#line 89
  state = 0L;
#line 90
  nextstate = 1L;
  }
#line 91
  return;
}
}
#line 93 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
void ( __attribute__((__regparm__(3))) cfg_string)(void *ptr ) 
{ 
  char s[200] ;
  unsigned long n ;
  unsigned short const   **tmp ;
  unsigned long tmp___0 ;
  char tmp___1 ;
  unsigned short const   **tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 96
  n = 0UL;
  {
#line 98
  tmp = __ctype_b_loc();
  }
  }
#line 98
  if (! ((int const   )*(*tmp + (int )c) & 1024)) {
#line 98
    if (c != 45L) {
#line 98
      if (c != 95L) {
        {
        {
#line 99
        err_expect((char *)"[a-zA-Z_-]");
        }
        }
#line 100
        return;
      }
    }
  }
  {
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp___0 = n;
#line 103
    n ++;
#line 103
    s[tmp___0] = (char )c;
    {
#line 104
    tmp___1 = nextchar();
    }
#line 104
    c = (long )tmp___1;
    {
#line 102
    tmp___2 = __ctype_b_loc();
    }
    }
#line 102
    if ((int const   )*(*tmp___2 + (int )c) & 8) {
#line 102
      goto _L;
    } else
#line 102
    if (c == 45L) {
#line 102
      goto _L;
    } else
#line 102
    if (c == 95L) {
      _L: /* CIL Label */ 
#line 102
      if (! (n < sizeof(s) - 1UL)) {
#line 102
        goto while_break;
      }
    } else {
#line 102
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  s[n] = (char)0;
  {
#line 109
  *((char **)ptr) = strdup((char const   *)(s));
  }
#line 111
  state = 0L;
#line 112
  nextstate = 1L;
  }
#line 113
  return;
}
}
#line 115 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
void ( __attribute__((__regparm__(3))) cfg_long)(void *ptr ) 
{ 
  char num[20] ;
  unsigned long n ;
  unsigned short const   **tmp ;
  unsigned long tmp___0 ;
  char tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 118
  n = 0UL;
  {
#line 120
  tmp = __ctype_b_loc();
  }
  }
#line 120
  if (! ((int const   )*(*tmp + (int )c) & 2048)) {
    {
    {
#line 121
    err_expect((char *)"[0-9]");
    }
    }
#line 122
    return;
  }
  {
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 125
    tmp___0 = n;
#line 125
    n ++;
#line 125
    num[tmp___0] = (char )c;
    {
#line 126
    tmp___1 = nextchar();
    }
#line 126
    c = (long )tmp___1;
    {
#line 124
    tmp___2 = __ctype_b_loc();
    }
    }
#line 124
    if ((int const   )*(*tmp___2 + (int )c) & 2048) {
#line 124
      if (! (n < sizeof(num) - 1UL)) {
#line 124
        goto while_break;
      }
    } else {
#line 124
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  num[n] = (char)0;
  {
#line 131
  tmp___3 = atoi((char const   *)(num));
  }
#line 131
  *((long *)ptr) = (long )tmp___3;
#line 133
  state = 0L;
#line 134
  nextstate = 1L;
  }
#line 135
  return;
}
}
#line 137 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
void ( __attribute__((__regparm__(3))) cfg_parse)(char const   *fname , struct cfg_option  const  *options___1 ) 
{ 
  char tmp ;
  char option[200] ;
  unsigned int tmp___0 ;
  unsigned long n ;
  unsigned short const   **tmp___1 ;
  char tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned long tmp___5 ;
  char tmp___6 ;
  unsigned short const   **tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char tmp___11 ;
  char tmp___12 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 139
  filename = fname;
  {
#line 140
  cfg_file = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
  }
#line 141
  if ((unsigned long )cfg_file == (unsigned long )((void *)0)) {
#line 141
    return;
  }
  {
#line 143
  nextchar_state = 0L;
#line 144
  state = 0L;
#line 145
  nextstate = 1L;
#line 146
  cfg_line = 1L;
#line 147
  cfg_char = 0L;
  {
#line 148
  tmp = nextchar();
  }
#line 148
  c = (long )tmp;
#line 150
  option[0] = (char )'\000';
#line 150
  tmp___0 = 1U;
  }
  {
  {
#line 150
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 150
    if (tmp___0 >= 200U) {
#line 150
      goto while_break;
    }
#line 150
    option[tmp___0] = (char)0;
#line 150
    tmp___0 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 151
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
#line 154
    if (state == 0L) {
#line 154
      goto case_0;
    }
#line 159
    if (state == 1L) {
#line 159
      goto case_1;
    }
#line 176
    if (state == 2L) {
#line 176
      goto case_2;
    }
#line 185
    if (state == 3L) {
#line 185
      goto case_3;
    }
#line 153
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 155
    tmp___3 = __ctype_b_loc();
    }
    }
#line 155
    if ((int const   )*(*tmp___3 + (int )c) & 8192) {
      {
      {
#line 156
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 156
        tmp___1 = __ctype_b_loc();
        }
        {
#line 156
        tmp___2 = nextchar();
        }
#line 156
        c = (long )tmp___2;
        }
#line 156
        if (! ((int const   )*(*tmp___1 + (int )c) & 8192)) {
#line 156
          goto while_break___1;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 157
    state = nextstate;
#line 158
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 160
    n = 0UL;
    {
#line 161
    tmp___4 = __ctype_b_loc();
    }
    }
#line 161
    if (! ((int const   )*(*tmp___4 + (int )c) & 1024)) {
      {
      {
#line 162
      err_expect((char *)"[a-zA-Z]");
      }
      }
#line 163
      goto switch_break;
    }
    {
    {
#line 165
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
#line 166
      tmp___5 = n;
#line 166
      n ++;
#line 166
      option[tmp___5] = (char )c;
      {
#line 167
      tmp___6 = nextchar();
      }
#line 167
      c = (long )tmp___6;
      {
#line 165
      tmp___7 = __ctype_b_loc();
      }
      }
#line 165
      if ((int const   )*(*tmp___7 + (int )c) & 8) {
#line 165
        goto _L;
      } else
#line 165
      if (c == 45L) {
#line 165
        goto _L;
      } else
#line 165
      if (c == 95L) {
        _L: /* CIL Label */ 
#line 165
        if (! (n < sizeof(option) - 1UL)) {
#line 165
          goto while_break___2;
        }
      } else {
#line 165
        goto while_break___2;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 172
    option[n] = (char )'\000';
#line 173
    state = 0L;
#line 174
    nextstate = 2L;
#line 175
    goto switch_break;
    case_2: /* CIL Label */ 
#line 177
    if (c != 61L) {
      {
      {
#line 178
      err_expect((char *)"=");
      }
      }
#line 179
      goto switch_break;
    }
    {
#line 181
    state = 0L;
#line 182
    nextstate = 3L;
    {
#line 183
    tmp___8 = nextchar();
    }
#line 183
    c = (long )tmp___8;
    }
#line 184
    goto switch_break;
    case_3: /* CIL Label */ 
#line 186
    n = 0UL;
    {
    {
#line 187
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 187
      if ((unsigned long )(options___1 + n)->name != (unsigned long )((void *)0)) {
        {
        {
#line 187
        tmp___9 = strcmp((char const   *)(options___1 + n)->name, (char const   *)(option));
        }
        }
#line 187
        if (! (tmp___9 != 0)) {
#line 187
          goto while_break___3;
        }
      } else {
#line 187
        goto while_break___3;
      }
#line 188
      n ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 189
    if ((options___1 + n)->parse_fn) {
      {
      {
#line 190
      (*((options___1 + n)->parse_fn))((void *)(options___1 + n)->ptr);
      }
      }
    } else {
      {
      {
#line 192
      tmp___10 = _("Unknown option %s at %s line %ld.\n");
      }
      {
#line 192
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
              option, fname, cfg_line);
      }
      }
      {
      {
#line 193
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
        {
        {
#line 193
        tmp___11 = nextchar();
        }
#line 193
        c = (long )tmp___11;
        }
#line 193
        if (c != 10L) {
#line 193
          if (! (c != 0L)) {
#line 193
            goto while_break___4;
          }
        } else {
#line 193
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 194
      state = 0L;
#line 195
      nextstate = 1L;
    }
    {
    {
#line 197
    tmp___12 = nextchar();
    }
#line 197
    c = (long )tmp___12;
    }
#line 198
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 151
    if (! (c != 0L)) {
#line 151
      goto while_break___0;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 202
  fclose(cfg_file);
  }
  }
#line 203
  return;
}
}
#line 205 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
char *( __attribute__((__regparm__(3))) get_userconfig)(char const   *cfgfile___1 ) 
{ 
  char *homedir ;
  char *usercfg ;
  long length ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 210
  homedir = getenv("HOME");
  }
  }
#line 211
  if (! homedir) {
#line 211
    return ((char *)((void *)0));
  } else
#line 211
  if (! cfgfile___1) {
#line 211
    return ((char *)((void *)0));
  }
  {
  {
#line 213
  tmp = strlen((char const   *)homedir);
  }
  {
#line 213
  tmp___0 = strlen(cfgfile___1);
  }
#line 213
  length = (long )((tmp + tmp___0) + 2U);
  {
#line 214
  tmp___1 = malloc((size_t )length);
  }
#line 214
  usercfg = (char *)tmp___1;
  }
#line 215
  if ((unsigned long )usercfg == (unsigned long )((void *)0)) {
    {
    {
#line 216
    tmp___2 = _("Memory allocation failed!");
    }
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            tmp___2);
    }
    }
#line 217
    return ((char *)((void *)0));
  }
  {
  {
#line 219
  snprintf((char */* __restrict  */)usercfg, (size_t )length, (char const   */* __restrict  */)"%s/%s",
           homedir, cfgfile___1);
  }
  }
#line 221
  return (usercfg);
}
}
#line 688 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 110 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 30 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long ( __attribute__((__regparm__(3))) midi_open)(enum plugout_endian endian___1 ,
                                                         long rate___1 ) 
{ 


  {
#line 32
  return (0L);
}
}
#line 35 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static FILE *file  =    (FILE *)((void *)0);
#line 37 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long track_length  ;
#line 38 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long track_length_offset  ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long cycles_prev  =    0L;
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_u32(uint32_t x ) 
{ 
  uint8_t s[4] ;
  size_t tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 46
  s[0] = (uint8_t )(x >> 24);
#line 47
  s[1] = (uint8_t )(x >> 16);
#line 48
  s[2] = (uint8_t )(x >> 8);
#line 49
  s[3] = (uint8_t )x;
  {
#line 51
  tmp = fwrite((void const   */* __restrict  */)(s), (size_t )1, (size_t )4, (FILE */* __restrict  */)file);
  }
  }
#line 51
  if (tmp != 4U) {
#line 52
    return (1);
  }
#line 53
  return (0);
}
}
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_u16(uint16_t x ) 
{ 
  uint8_t s[2] ;
  size_t tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 60
  s[0] = (uint8_t )((int )x >> 8);
#line 61
  s[1] = (uint8_t )x;
  {
#line 63
  tmp = fwrite((void const   */* __restrict  */)(s), (size_t )1, (size_t )2, (FILE */* __restrict  */)file);
  }
  }
#line 63
  if (tmp != 2U) {
#line 64
    return (1);
  }
#line 65
  return (0);
}
}
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_varlen(unsigned long x ) 
{ 
  uint8_t s ;
  size_t tmp ;

  {
  {
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 73
    s = (uint8_t )(x & 127UL);
#line 74
    x >>= 7;
#line 75
    if (x) {
#line 76
      s = (uint8_t )((int )s | 128);
    }
    {
    {
#line 78
    tmp = fwrite((void const   */* __restrict  */)(& s), (size_t )1, (size_t )1, (FILE */* __restrict  */)file);
    }
    }
#line 78
    if (tmp != 1U) {
#line 79
      return (1);
    }
#line 81
    track_length ++;
#line 70
    if (! x) {
#line 70
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (0);
}
}
#line 87 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_event(long cycles , uint8_t const   *s , unsigned int n ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
  {
#line 89
  tmp = midi_write_varlen((unsigned long )((cycles - cycles_prev) >> 14));
  }
  }
#line 89
  if (tmp) {
#line 90
    return (1);
  }
  {
  {
#line 92
  tmp___0 = fwrite((void const   */* __restrict  */)s, (size_t )1, n, (FILE */* __restrict  */)file);
  }
  }
#line 92
  if (tmp___0 != n) {
#line 93
    return (1);
  }
#line 95
  track_length += (long )n;
#line 97
  cycles_prev = cycles;
#line 98
  return (0);
}
}
#line 101 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_open_track(int subsong ) 
{ 
  char *filename___3 ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 104
  tmp = malloc((size_t )32);
  }
#line 104
  filename___3 = (char *)tmp;
  }
#line 104
  if ((unsigned long )filename___3 == (unsigned long )((void *)0)) {
#line 105
    goto out;
  }
  {
  {
#line 107
  tmp___0 = snprintf((char */* __restrict  */)filename___3, (size_t )32, (char const   */* __restrict  */)"gbsplay-%d.mid",
                     subsong + 1);
  }
  }
#line 107
  if (tmp___0 >= 32) {
#line 108
    goto out;
  }
  {
  {
#line 110
  file = fopen((char const   */* __restrict  */)filename___3, (char const   */* __restrict  */)"wb");
  }
  }
#line 111
  if (! file) {
    {
    {
#line 112
    free((void *)filename___3);
    }
    }
#line 113
    goto out;
  }
  {
  {
#line 116
  free((void *)filename___3);
  }
  {
#line 119
  tmp___1 = fwrite((void const   */* __restrict  */)"MThd", (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)file);
  }
  }
#line 119
  if (tmp___1 != 4U) {
#line 120
    goto out_file;
  }
  {
  {
#line 123
  tmp___2 = midi_write_u32((uint32_t )6);
  }
  }
#line 123
  if (tmp___2) {
#line 124
    goto out_file;
  }
  {
  {
#line 127
  tmp___3 = midi_write_u16((uint16_t )0);
  }
  }
#line 127
  if (tmp___3) {
#line 128
    goto out_file;
  }
  {
  {
#line 131
  tmp___4 = midi_write_u16((uint16_t )1);
  }
  }
#line 131
  if (tmp___4) {
#line 132
    goto out_file;
  }
  {
  {
#line 136
  tmp___5 = midi_write_u16((uint16_t )124);
  }
  }
#line 136
  if (tmp___5) {
#line 137
    goto out_file;
  }
  {
  {
#line 140
  tmp___6 = fwrite((void const   */* __restrict  */)"MTrk", (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)file);
  }
  }
#line 140
  if (tmp___6 != 4U) {
#line 141
    goto out_file;
  }
  {
#line 144
  track_length = 0L;
  {
#line 145
  track_length_offset = ftell(file);
  }
  }
#line 146
  if (track_length_offset == -1L) {
#line 147
    goto out_file;
  }
  {
  {
#line 149
  tmp___7 = midi_write_u32((uint32_t )0);
  }
  }
#line 149
  if (tmp___7) {
#line 150
    goto out_file;
  }
#line 152
  return (0);
  out_file: 
  {
  {
#line 155
  fclose(file);
  }
#line 156
  file = (FILE *)((void *)0);
  }
  out: 
#line 158
  return (1);
}
}
#line 161 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_close_track(void) 
{ 
  uint8_t event[3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp5 ;

  {
  {
#line 166
  event[0] = (uint8_t )255;
#line 167
  event[1] = (uint8_t )47;
#line 168
  event[2] = (uint8_t )0;
  {
#line 170
  tmp = midi_write_event(cycles_prev, (uint8_t const   *)(event), 3U);
  }
  }
#line 170
  if (tmp) {
#line 171
    goto out;
  }
  {
  {
#line 173
  tmp___0 = fseek(file, track_length_offset, 0);
  }
  }
#line 173
  if (tmp___0 == -1) {
#line 174
    goto out;
  }
  {
  {
#line 176
  tmp___1 = midi_write_u32((uint32_t )track_length);
  }
  }
#line 176
  if (tmp___1) {
#line 177
    goto out;
  }
  {
  {
#line 179
  fclose(file);
  }
#line 180
  file = (FILE *)((void *)0);
  }
#line 181
  return (0);
  out: 
#line 184
  file = (FILE *)((void *)0);
#line 185
  return (1);
}
}
#line 188 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int ( __attribute__((__regparm__(3))) midi_skip)(int subsong ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 190
  cycles_prev = 0L;
#line 192
  if (file) {
    {
    {
#line 193
    tmp = midi_close_track();
    }
    }
#line 193
    if (tmp) {
#line 194
      return (1);
    }
  }
  {
  {
#line 197
  tmp___0 = midi_open_track(subsong);
  }
  }
#line 197
  return (tmp___0);
}
}
#line 200 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int note_on(long cycles , int channel , int note___1 , int velocity ) 
{ 
  uint8_t event[3] ;
  int tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 205
  event[0] = (uint8_t )144;
#line 206
  event[1] = (uint8_t )note___1;
#line 207
  event[2] = (uint8_t )velocity;
  {
#line 209
  tmp = midi_write_event(cycles, (uint8_t const   *)(event), 3U);
  }
  }
#line 209
  if (tmp) {
#line 210
    return (1);
  }
#line 212
  return (0);
}
}
#line 215 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int note_off(long cycles , int channel , int note___1 ) 
{ 
  uint8_t event[3] ;
  int tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 220
  event[0] = (uint8_t )128;
#line 221
  event[1] = (uint8_t )note___1;
#line 222
  event[2] = (uint8_t )0;
  {
#line 224
  tmp = midi_write_event(cycles, (uint8_t const   *)(event), 3U);
  }
  }
#line 224
  if (tmp) {
#line 225
    return (1);
  }
#line 227
  return (0);
}
}
#line 232
static int ( __attribute__((__regparm__(3))) midi_io)(long cycles , uint32_t addr ,
                                                      uint8_t val ) ;
#line 232 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long div___0[4]  = {      0L,      0L,      0L,      0L};
#line 233 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long note[4]  = {      0L,      0L,      0L,      0L};
#line 234 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int volume[4]  = {      0,      0,      0,      0};
#line 230 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int ( __attribute__((__regparm__(3))) midi_io)(long cycles , uint32_t addr ,
                                                      uint8_t val ) 
{ 
  long chan ;
  int new_note ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 236
  chan = (long )((addr - 65296U) / 5U);
  {
#line 241
  if (addr == 65313U) {
#line 241
    goto case_65313;
  }
#line 241
  if (addr == 65303U) {
#line 241
    goto case_65313;
  }
#line 241
  if (addr == 65298U) {
#line 241
    goto case_65313;
  }
#line 246
  if (addr == 65309U) {
#line 246
    goto case_65309;
  }
#line 246
  if (addr == 65304U) {
#line 246
    goto case_65309;
  }
#line 246
  if (addr == 65299U) {
#line 246
    goto case_65309;
  }
#line 252
  if (addr == 65310U) {
#line 252
    goto case_65310;
  }
#line 252
  if (addr == 65305U) {
#line 252
    goto case_65310;
  }
#line 252
  if (addr == 65300U) {
#line 252
    goto case_65310;
  }
#line 278
  if (addr == 65306U) {
#line 278
    goto case_65306;
  }
#line 289
  if (addr == 65308U) {
#line 289
    goto case_65308;
  }
#line 238
  goto switch_break;
  case_65313: /* CIL Label */ 
  case_65303: /* CIL Label */ 
  case_65298: /* CIL Label */ 
#line 242
  volume[chan] = 8 * ((int )val >> 4);
#line 243
  goto switch_break;
  case_65309: /* CIL Label */ 
  case_65304: /* CIL Label */ 
  case_65299: /* CIL Label */ 
#line 247
  div___0[chan] &= 65280L;
#line 248
  div___0[chan] |= (long )val;
#line 249
  goto switch_break;
  case_65310: /* CIL Label */ 
  case_65305: /* CIL Label */ 
  case_65300: /* CIL Label */ 
  {
#line 253
  div___0[chan] &= 255L;
#line 254
  div___0[chan] |= (long )((int )val & 7) << 8;
  {
#line 256
  tmp = log((double )(262144L / (2048L - div___0[chan])));
  }
#line 256
  new_note = (int )((long )((tmp / .69314718055994530941 - 5.78135971352465960412) * (double )12 + .2) + 21L);
  }
#line 259
  if ((int )val & 128) {
#line 260
    if (note[chan]) {
      {
      {
#line 261
      tmp___0 = note_off(cycles, (int )chan, (int )note[chan]);
      }
      }
#line 261
      if (tmp___0) {
#line 262
        return (1);
      }
    }
#line 265
    if (new_note < 0) {
#line 266
      goto switch_break;
    } else
#line 265
    if (new_note >= 128) {
#line 266
      goto switch_break;
    }
    {
    {
#line 268
    tmp___1 = note_on(cycles, (int )chan, new_note, volume[chan]);
    }
    }
#line 268
    if (tmp___1) {
#line 269
      return (1);
    }
#line 270
    note[chan] = (long )new_note;
  } else {
    {
    {
#line 272
    tmp___2 = note_off(cycles, (int )chan, (int )note[chan]);
    }
    }
#line 272
    if (tmp___2) {
#line 273
      return (1);
    }
#line 274
    note[chan] = 0L;
  }
#line 277
  goto switch_break;
  case_65306: /* CIL Label */ 
#line 288
  goto switch_break;
  case_65308: /* CIL Label */ 
#line 290
  volume[2] = 32 * ((4 - ((int )val >> 5)) & 3);
#line 291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 294
  return (0);
}
}
#line 297 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static ssize_t ( __attribute__((__regparm__(3))) midi_write)(void const   *buf___3 ,
                                                             size_t count ) 
{ 


  {
#line 299
  return ((ssize_t )count);
}
}
#line 302 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static void ( __attribute__((__regparm__(3))) midi_close)(void) 
{ 


  {
#line 304
  if (file) {
    {
    {
#line 305
    midi_close_track();
    }
    }
  }
#line 306
  return;
}
}
#line 308 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
struct output_plugin  const  plugout_midi  = 
#line 308
     {(char *)"midi", (char *)"MIDI sound driver", 0L, & midi_open, & midi_skip, & midi_io,
    & midi_write, & midi_close};
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_line___0  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_char___0  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static FILE *cfg_file___0  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextchar_state___0  ;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char ( __attribute__((__regparm__(3))) nextchar___0)(void) 
{ 
  long c___3 ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 30
  if (! ((unsigned long )cfg_file___0 != (unsigned long )((void *)0))) {
    {
    {
#line 30
    __assert_fail("cfg_file != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c",
                  30U, "nextchar");
    }
    }
  }
  {
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 33
    tmp = fgetc(cfg_file___0);
    }
#line 33
    c___3 = (long )tmp;
    }
#line 33
    if (c___3 == -1L) {
#line 33
      return ((char)0);
    }
#line 35
    if (c___3 == 10L) {
#line 36
      cfg_char___0 = 0L;
#line 37
      cfg_line___0 ++;
    } else {
#line 38
      cfg_char___0 ++;
    }
    {
#line 41
    if (nextchar_state___0 == 0L) {
#line 41
      goto case_0;
    }
#line 45
    if (nextchar_state___0 == 1L) {
#line 45
      goto case_1;
    }
#line 49
    if (nextchar_state___0 == 2L) {
#line 49
      goto case_2;
    }
#line 40
    goto switch_break;
    case_0: /* CIL Label */ 
#line 42
    if (c___3 == 92L) {
#line 42
      nextchar_state___0 = 1L;
    } else
#line 43
    if (c___3 == 35L) {
#line 43
      nextchar_state___0 = 2L;
    }
#line 44
    goto switch_break;
    case_1: /* CIL Label */ 
#line 46
    nextchar_state___0 = 0L;
#line 47
    if (c___3 == 110L) {
#line 47
      c___3 = (long )'\n';
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
#line 50
    if (c___3 == 0L) {
#line 50
      nextchar_state___0 = 0L;
    } else
#line 50
    if (c___3 == 10L) {
#line 50
      nextchar_state___0 = 0L;
    }
#line 51
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 32
    if (! (nextchar_state___0 != 0L)) {
#line 32
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return ((char )c___3);
}
}
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long state___0  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextstate___0  ;
#line 60 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long c___0  ;
#line 61 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char const   *filename___0  ;
#line 63 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static void ( __attribute__((__regparm__(3))) err_expect___0)(char *s ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 65
  tmp = _("\'%s\' expected at %s line %ld char %ld.\n");
  }
  {
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, s,
          filename___0, cfg_line___0, cfg_char___0);
  }
  {
#line 67
  tmp___0 = nextchar___0();
  }
#line 67
  c___0 = (long )tmp___0;
#line 68
  state___0 = 0L;
#line 69
  nextstate___0 = 1L;
  }
#line 70
  return;
}
}
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 102 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
gbcpu_regs_u gbcpu_regs  ;
#line 103 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
long gbcpu_halted  ;
#line 104 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.h"
long gbcpu_if  ;
#line 106
void ( __attribute__((__regparm__(3))) gbcpu_addmem)(uint32_t start , uint32_t end ,
                                                     void ( __attribute__((__regparm__(3))) (*putfn))(uint32_t addr ,
                                                                                                      uint8_t val ) ,
                                                     uint32_t ( __attribute__((__regparm__(3))) (*getfn))(uint32_t addr ) ) ;
#line 107
void ( __attribute__((__regparm__(3))) gbcpu_init)(void) ;
#line 108
long ( __attribute__((__regparm__(3))) gbcpu_step)(void) ;
#line 109
void ( __attribute__((__regparm__(3))) gbcpu_intr)(long vec ) ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
long gbcpu_stopped  ;
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) none_get)(uint32_t addr ) 
{ 


  {
#line 45
  return ((uint32_t )255);
}
}
#line 48 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) none_put)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_get_fn getlookup[256]  = 
#line 52
  {      & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get, 
        & none_get,      & none_get,      & none_get,      & none_get};
#line 311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_put_fn putlookup[256]  = 
#line 311
  {      & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put, 
        & none_put,      & none_put,      & none_put,      & none_put};
#line 570 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static uint32_t ( __attribute__((__regparm__(3))) mem_get)(uint32_t addr ) 
{ 
  uint32_t ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr ) ;
  uint32_t tmp ;

  {
  {
#line 572
  fn = getlookup[addr >> 8];
  {
#line 573
  tmp = (*fn)(addr);
  }
  }
#line 573
  return (tmp);
}
}
#line 576 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static void ( __attribute__((__regparm__(3))) mem_put)(uint32_t addr , uint32_t val ) 
{ 
  void ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr , uint8_t val ) ;

  {
  {
#line 578
  fn = putlookup[addr >> 8];
  {
#line 579
  (*fn)(addr, (uint8_t )val);
  }
  }
#line 580
  return;
}
}
#line 582 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) push)(uint32_t val ) 
{ 
  uint32_t sp ;

  {
  {
#line 584
  sp = (uint32_t )((int )*((uint16_t *)(& gbcpu_regs.ri[8])) - 2);
#line 585
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )sp;
  {
#line 586
  mem_put(sp, val & 255U);
  }
  {
#line 587
  mem_put(sp + 1U, val >> 8);
  }
  }
#line 588
  return;
}
}
#line 590 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) pop)(void) 
{ 
  uint32_t res ;
  uint32_t sp ;
  uint32_t tmp ;

  {
  {
#line 593
  sp = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[8]));
  {
#line 595
  res = mem_get(sp);
  }
  {
#line 596
  tmp = mem_get(sp + 1U);
  }
#line 596
  res += tmp << 8;
#line 597
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )(sp + 2U);
  }
#line 599
  return (res);
}
}
#line 602 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm8)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;

  {
  {
#line 604
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 606
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 1U);
  {
#line 607
  res = mem_get(pc);
  }
  }
  {
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 608
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  return (res);
}
}
#line 612 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm16)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 614
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 616
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 2U);
  {
#line 617
  tmp = mem_get(pc);
  }
  {
#line 617
  tmp___0 = mem_get(pc + 1U);
  }
#line 617
  res = tmp + (tmp___0 << 8);
  }
  {
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 618
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (res);
}
}
#line 622 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static void print_reg(long i ) 
{ 


  {
#line 624
  if (i == 6L) {
    {
    {
#line 624
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 624
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 625
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 625
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 626
  return;
}
}
#line 628 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_reg)(long i ) 
{ 
  uint32_t tmp ;

  {
#line 630
  if (i == 6L) {
    {
    {
#line 631
    tmp = mem_get((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])));
    }
    }
#line 631
    return (tmp);
  }
#line 632
  return ((uint32_t )gbcpu_regs.ri[i ^ 1L]);
}
}
#line 635 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) put_reg)(long i , uint32_t val ) 
{ 


  {
#line 637
  if (i == 6L) {
    {
    {
#line 638
    mem_put((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])), val);
    }
    }
  } else {
#line 639
    gbcpu_regs.ri[i ^ 1L] = (uint8_t )val;
  }
#line 640
  return;
}
}
#line 642 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_unknown)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 644
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown opcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 645
  gbcpu_stopped = 1L;
  }
#line 646
  return;
}
}
#line 648 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_set)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 650
  reg = (long )(op & 7U);
#line 651
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 653
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 654
  print_reg(reg);
  }
  {
#line 655
  tmp = get_reg(reg);
  }
  {
#line 655
  put_reg(reg, tmp | (unsigned int )(1 << bit));
  }
  }
#line 656
  return;
}
}
#line 658 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_res)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 660
  reg = (long )(op & 7U);
#line 661
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 663
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 664
  print_reg(reg);
  }
  {
#line 665
  tmp = get_reg(reg);
  }
  {
#line 665
  put_reg(reg, tmp & (unsigned int )(~ (1 << bit)));
  }
  }
#line 666
  return;
}
}
#line 668 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_bit)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 670
  reg = (long )(op & 7U);
#line 671
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 673
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 674
  print_reg(reg);
  }
#line 675
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 676
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 160);
  {
#line 677
  tmp = get_reg(reg);
  }
#line 677
  gbcpu_regs.rn.f = (uint8_t )((unsigned int )gbcpu_regs.rn.f ^ (((tmp << 8) >> (bit + 1UL)) & 128U));
  }
#line 678
  return;
}
}
#line 680 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rl)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 682
  reg = (long )(op & 7U);
  {
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 685
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 686
  print_reg(reg);
  }
  {
#line 687
  tmp = get_reg(reg);
  }
#line 687
  val = (uint8_t )tmp;
#line 687
  res = val;
#line 688
  res = (uint8_t )((int )res << 1);
#line 689
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 690
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 691
  if ((int )res == 0) {
#line 691
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 692
  put_reg(reg, (uint32_t )res);
  }
  }
#line 693
  return;
}
}
#line 695 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rla)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 699
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 699
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  res = gbcpu_regs.rn.a;
#line 701
  res = (uint8_t )((int )res << 1);
#line 702
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 703
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 704
  if ((int )res == 0) {
#line 704
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 705
  gbcpu_regs.rn.a = res;
#line 706
  return;
}
}
#line 708 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlc)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 710
  reg = (long )(op & 7U);
  {
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 713
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 714
  print_reg(reg);
  }
  {
#line 715
  tmp = get_reg(reg);
  }
#line 715
  val = (uint8_t )tmp;
#line 715
  res = val;
#line 716
  res = (uint8_t )((int )res << 1);
#line 717
  res = (uint8_t )((int )res | ((int )val >> 7));
#line 718
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 719
  if ((int )res == 0) {
#line 719
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 720
  put_reg(reg, (uint32_t )res);
  }
  }
#line 721
  return;
}
}
#line 723 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlca)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 727
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 727
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  res = gbcpu_regs.rn.a;
#line 729
  res = (uint8_t )((int )res << 1);
#line 730
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a >> 7));
#line 731
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 732
  if ((int )res == 0) {
#line 732
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 733
  gbcpu_regs.rn.a = res;
#line 734
  return;
}
}
#line 736 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sla)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 738
  reg = (long )(op & 7U);
  {
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 741
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 742
  print_reg(reg);
  }
  {
#line 743
  tmp = get_reg(reg);
  }
#line 743
  val = (uint8_t )tmp;
#line 743
  res = val;
#line 744
  res = (uint8_t )((int )res << 1);
#line 745
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 746
  if ((int )res == 0) {
#line 746
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 747
  put_reg(reg, (uint32_t )res);
  }
  }
#line 748
  return;
}
}
#line 750 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rr)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 752
  reg = (long )(op & 7U);
  {
  {
#line 755
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 755
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 756
  print_reg(reg);
  }
  {
#line 757
  tmp = get_reg(reg);
  }
#line 757
  val = (uint8_t )tmp;
#line 757
  res = val;
#line 758
  res = (uint8_t )((int )res >> 1);
#line 759
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 760
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 761
  if ((int )res == 0) {
#line 761
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 762
  put_reg(reg, (uint32_t )res);
  }
  }
#line 763
  return;
}
}
#line 765 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rra)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 769
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 769
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  res = gbcpu_regs.rn.a;
#line 771
  res = (uint8_t )((int )res >> 1);
#line 772
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 773
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 774
  if ((int )res == 0) {
#line 774
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 775
  gbcpu_regs.rn.a = res;
#line 776
  return;
}
}
#line 778 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrc)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 780
  reg = (long )(op & 7U);
  {
  {
#line 783
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 783
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 784
  print_reg(reg);
  }
  {
#line 785
  tmp = get_reg(reg);
  }
#line 785
  val = (uint8_t )tmp;
#line 785
  res = val;
#line 786
  res = (uint8_t )((int )res >> 1);
#line 787
  res = (uint8_t )((int )res | ((int )val << 7));
#line 788
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 789
  if ((int )res == 0) {
#line 789
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 790
  put_reg(reg, (uint32_t )res);
  }
  }
#line 791
  return;
}
}
#line 793 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrca)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  res = gbcpu_regs.rn.a;
#line 799
  res = (uint8_t )((int )res >> 1);
#line 800
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a << 7));
#line 801
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 802
  if ((int )res == 0) {
#line 802
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 803
  gbcpu_regs.rn.a = res;
#line 804
  return;
}
}
#line 806 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sra)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 808
  reg = (long )(op & 7U);
  {
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 811
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 812
  print_reg(reg);
  }
  {
#line 813
  tmp = get_reg(reg);
  }
#line 813
  val = (uint8_t )tmp;
#line 813
  res = val;
#line 814
  res = (uint8_t )((int )res >> 1);
#line 815
  res = (uint8_t )((int )res | ((int )val & 128));
#line 816
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 817
  if ((int )res == 0) {
#line 817
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 818
  put_reg(reg, (uint32_t )res);
  }
  }
#line 819
  return;
}
}
#line 821 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_srl)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 823
  reg = (long )(op & 7U);
  {
  {
#line 826
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 826
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 827
  print_reg(reg);
  }
  {
#line 828
  tmp = get_reg(reg);
  }
#line 828
  val = (uint8_t )tmp;
#line 828
  res = val;
#line 829
  res = (uint8_t )((int )res >> 1);
#line 830
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 831
  if ((int )res == 0) {
#line 831
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 832
  put_reg(reg, (uint32_t )res);
  }
  }
#line 833
  return;
}
}
#line 835 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_swap)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t res ;
  uint32_t val ;

  {
#line 837
  reg = (long )(op & 7U);
  {
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 841
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 842
  print_reg(reg);
  }
  {
#line 843
  val = get_reg(reg);
  }
#line 844
  res = (val >> 4) | (val << 4);
#line 846
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 847
  if (res == 0U) {
#line 847
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 848
  put_reg(reg, res);
  }
  }
#line 849
  return;
}
}
#line 851 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  cbops[8]  = 
#line 851
  {      {& op_rlc}, 
        {& op_rrc}, 
        {& op_rl}, 
        {& op_rr}, 
        {& op_sla}, 
        {& op_sra}, 
        {& op_swap}, 
        {& op_srl}};
#line 862 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cbprefix)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t pc ;
  char *__cil_tmp4 ;

  {
  {
#line 864
  pc = *((uint16_t *)(& gbcpu_regs.ri[10]));
#line 866
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )pc + 1);
  {
#line 867
  op = mem_get((uint32_t )pc);
  }
  }
  {
#line 869
  if (op >> 6 == 0U) {
#line 869
    goto case_0;
  }
#line 871
  if (op >> 6 == 1U) {
#line 871
    goto case_1;
  }
#line 872
  if (op >> 6 == 2U) {
#line 872
    goto case_2;
  }
#line 873
  if (op >> 6 == 3U) {
#line 873
    goto case_3;
  }
#line 868
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 869
  (*(cbops[(op >> 3) & 7U].fn))(op, & cbops[(op >> 3) & 7U]);
  }
  }
#line 870
  return;
  case_1: /* CIL Label */ 
  {
  {
#line 871
  op_bit(op);
  }
  }
#line 871
  return;
  case_2: /* CIL Label */ 
  {
  {
#line 872
  op_res(op);
  }
  }
#line 872
  return;
  case_3: /* CIL Label */ 
  {
  {
#line 873
  op_set(op);
  }
  }
#line 873
  return;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 875
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown CB subopcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 876
  gbcpu_stopped = 1L;
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long src ;
  long dst ;
  uint32_t tmp ;

  {
#line 881
  src = (long )(op & 7U);
#line 882
  dst = (long )((op >> 3) & 7U);
  {
  {
#line 884
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 884
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 885
  print_reg(dst);
  }
  }
  {
  {
#line 886
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 886
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 887
  print_reg(src);
  }
  {
#line 888
  tmp = get_reg(src);
  }
  {
#line 888
  put_reg(dst, tmp);
  }
  }
#line 889
  return;
}
}
#line 891 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 893
  tmp = get_imm16();
  }
#line 893
  ofs = (long )tmp;
  }
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 896
  tmp___0 = mem_get((uint32_t )ofs);
  }
#line 896
  gbcpu_regs.rn.a = (uint8_t )tmp___0;
  }
#line 897
  return;
}
}
#line 899 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_a)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 901
  tmp = get_imm16();
  }
#line 901
  ofs = (long )tmp;
  }
  {
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 903
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 904
  mem_put((uint32_t )ofs, (uint32_t )gbcpu_regs.rn.a);
  }
  }
#line 905
  return;
}
}
#line 907 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_sp)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  long sp ;

  {
  {
  {
#line 909
  tmp = get_imm16();
  }
#line 909
  ofs = (long )tmp;
#line 910
  sp = (long )*((uint16_t *)(& gbcpu_regs.ri[8]));
  }
  {
  {
#line 912
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 912
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 913
  mem_put((uint32_t )ofs, (uint32_t )(sp & 255L));
  }
  {
#line 914
  mem_put((uint32_t )(ofs + 1L), (uint32_t )(sp >> 8));
  }
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_hlsp)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t ofs ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 919
  tmp = get_imm8();
  }
#line 919
  ofs = (int8_t )tmp;
#line 920
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 921
  new = (uint16_t )((int )old + (int )ofs);
  }
#line 923
  if ((int )ofs > 0) {
    {
    {
#line 923
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 923
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 924
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 924
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 925
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 926
  gbcpu_regs.rn.f = (uint8_t )0;
#line 927
  if ((int )old > (int )new) {
#line 927
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 928
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 928
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 929
  return;
}
}
#line 931 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_sphl)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 933
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 933
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  *((uint16_t *)(& gbcpu_regs.ri[8])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 935
  return;
}
}
#line 937 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 939
  tmp = get_imm16();
  }
#line 939
  val = (long )tmp;
#line 940
  reg = (long )((op >> 4) & 3U);
#line 942
  reg += (long )(reg > 2L);
  }
  {
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 943
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )val;
#line 945
  return;
}
}
#line 947 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_a)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t r ;
  uint32_t tmp ;

  {
#line 949
  reg = (long )((op >> 4) & 3U);
#line 952
  reg -= (long )(reg > 2L);
#line 953
  if (op & 8U) {
    {
    {
#line 954
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 954
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 955
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 955
    tmp = mem_get((uint32_t )r);
    }
#line 955
    gbcpu_regs.rn.a = (uint8_t )tmp;
    }
  } else {
    {
    {
#line 957
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 957
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 958
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 958
    mem_put((uint32_t )r, (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 961
  if (reg == 2L) {
#line 962
    r = (uint16_t )((int )r + ((((op & 16U) == 0U) << 1) - 1));
#line 963
    *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = r;
  }
#line 965
  return;
}
}
#line 967 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg8_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 969
  tmp = get_imm8();
  }
#line 969
  val = (long )tmp;
#line 970
  reg = (long )((op >> 3) & 7U);
  }
  {
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 972
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 973
  print_reg(reg);
  }
  {
#line 974
  put_reg(reg, (uint32_t )val);
  }
  }
  {
  {
#line 975
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 975
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 976
  return;
}
}
#line 978 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ldh)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 980
  if (op & 2U) {
#line 980
    tmp___0 = (uint32_t )0;
  } else {
    {
    {
#line 980
    tmp = get_imm8();
    }
#line 980
    tmp___0 = tmp;
    }
  }
#line 980
  ofs = (long )tmp___0;
#line 982
  if (op & 16U) {
    {
    {
#line 983
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 983
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 984
    if ((op & 2U) == 0U) {
      {
      {
#line 985
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 985
        goto while_break___0;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 987
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 988
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 988
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 990
    tmp___1 = mem_get((uint32_t )(65280L + ofs));
    }
#line 990
    gbcpu_regs.rn.a = (uint8_t )tmp___1;
    }
  } else {
#line 992
    if ((op & 2U) == 0U) {
      {
      {
#line 993
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 993
        goto while_break___2;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 995
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 996
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 996
        goto while_break___3;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    {
#line 998
    mem_put((uint32_t )(65280L + ofs), (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 1000
  return;
}
}
#line 1002 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1004
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1008
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1008
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1009
  print_reg(reg);
  }
  {
#line 1010
  tmp = get_reg(reg);
  }
#line 1010
  res = (uint8_t )tmp;
#line 1010
  old = res;
#line 1011
  res = (uint8_t )((int )res + 1);
  {
#line 1012
  put_reg(reg, (uint32_t )res);
  }
#line 1013
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -225);
  }
#line 1014
  if ((int )res == 0) {
#line 1014
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1015
  if (((int )old & 15) > ((int )res & 15)) {
#line 1015
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1016
  return;
}
}
#line 1018 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc16)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1020
  reg = (long )((op >> 4) & 3U);
#line 1021
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1023
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1023
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  res = (uint16_t )((int )res + 1);
#line 1025
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1026
  return;
}
}
#line 1028 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1030
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1034
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1034
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1035
  print_reg(reg);
  }
  {
#line 1036
  tmp = get_reg(reg);
  }
#line 1036
  res = (uint8_t )tmp;
#line 1036
  old = res;
#line 1037
  res = (uint8_t )((int )res - 1);
  {
#line 1038
  put_reg(reg, (uint32_t )res);
  }
#line 1039
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 64);
#line 1040
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -161);
  }
#line 1041
  if ((int )res == 0) {
#line 1041
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1042
  if (((int )old & 15) > ((int )res & 15)) {
#line 1042
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1043
  return;
}
}
#line 1045 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec16)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1047
  reg = (long )((op >> 4) & 3U);
#line 1048
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1050
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1050
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1051
  res = (uint16_t )((int )res - 1);
#line 1052
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1053
  return;
}
}
#line 1055 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_sp_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t imm ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 1057
  tmp = get_imm8();
  }
#line 1057
  imm = (int8_t )tmp;
#line 1058
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 1059
  new = old;
  }
  {
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1061
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  new = (uint16_t )((int )new + (int )imm);
#line 1063
  *((uint16_t *)(& gbcpu_regs.ri[8])) = new;
#line 1064
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1065
  if ((int )old > (int )new) {
#line 1065
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1066
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1066
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1067
  return;
}
}
#line 1069 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1071
  old = gbcpu_regs.rn.a;
  {
  {
#line 1074
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1074
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1075
  print_reg((long )(op & 7U));
  }
  {
#line 1076
  tmp = get_reg((long )(op & 7U));
  }
#line 1076
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1077
  new = gbcpu_regs.rn.a;
#line 1078
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1079
  if ((int )old > (int )new) {
#line 1079
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1080
  if (((int )old & 15) > ((int )new & 15)) {
#line 1080
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1081
  if ((int )new == 0) {
#line 1081
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1082
  return;
}
}
#line 1084 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1086
  tmp = get_imm8();
  }
#line 1086
  imm = (uint8_t )tmp;
#line 1087
  old = gbcpu_regs.rn.a;
#line 1088
  new = old;
  }
  {
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1090
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1091
  new = (uint8_t )((int )new + (int )imm);
#line 1092
  gbcpu_regs.rn.a = new;
#line 1093
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1094
  if ((int )old > (int )new) {
#line 1094
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1095
  if (((int )old & 15) > ((int )new & 15)) {
#line 1095
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1096
  if ((int )new == 0) {
#line 1096
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1097
  return;
}
}
#line 1099 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_hl)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t old ;
  uint16_t new ;

  {
#line 1101
  reg = (long )((op >> 4) & 3U);
#line 1102
  old = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1103
  new = old;
#line 1105
  reg += (long )(reg > 2L);
  {
  {
#line 1106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1106
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  new = (uint16_t )((int )new + (int )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
#line 1109
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 1111
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -113);
#line 1112
  if ((int )old > (int )new) {
#line 1112
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1113
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1113
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1114
  return;
}
}
#line 1116 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1118
  old = gbcpu_regs.rn.a;
  {
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1121
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1122
  print_reg((long )(op & 7U));
  }
  {
#line 1123
  tmp = get_reg((long )(op & 7U));
  }
#line 1123
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1124
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1125
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1126
  new = gbcpu_regs.rn.a;
  }
#line 1127
  if ((int )old > (int )new) {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1128
  if (((int )old & 15) > ((int )new & 15)) {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1129
  if ((int )new == 0) {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1130
  return;
}
}
#line 1132 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1134
  tmp = get_imm8();
  }
#line 1134
  imm = (uint8_t )tmp;
#line 1135
  old = gbcpu_regs.rn.a;
#line 1136
  new = old;
  }
  {
  {
#line 1138
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1138
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  new = (uint8_t )((int )new + (int )imm);
#line 1140
  new = (uint8_t )((int )new + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1141
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1142
  gbcpu_regs.rn.a = new;
#line 1143
  if ((int )old > (int )new) {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1144
  if (((int )old & 15) > ((int )new & 15)) {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1145
  if ((int )new == 0) {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1150
  old = gbcpu_regs.rn.a;
#line 1151
  new = old;
  {
  {
#line 1153
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1153
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1154
  print_reg((long )(op & 7U));
  }
  {
#line 1155
  tmp = get_reg((long )(op & 7U));
  }
#line 1155
  new = (uint8_t )((uint32_t )new - tmp);
#line 1156
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1157
  if ((int )old < (int )new) {
#line 1157
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1158
  if (((int )old & 15) < ((int )new & 15)) {
#line 1158
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1159
  if ((int )new == 0) {
#line 1159
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1160
  return;
}
}
#line 1162 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1164
  tmp = get_imm8();
  }
#line 1164
  imm = (uint8_t )tmp;
#line 1165
  old = gbcpu_regs.rn.a;
#line 1166
  new = old;
  }
  {
  {
#line 1168
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1168
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  new = (uint8_t )((int )new - (int )imm);
#line 1170
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1171
  if ((int )old < (int )new) {
#line 1171
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1172
  if (((int )old & 15) < ((int )new & 15)) {
#line 1172
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1173
  if ((int )new == 0) {
#line 1173
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1174
  return;
}
}
#line 1176 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1178
  old = gbcpu_regs.rn.a;
  {
  {
#line 1181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1181
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1182
  print_reg((long )(op & 7U));
  }
  {
#line 1183
  tmp = get_reg((long )(op & 7U));
  }
#line 1183
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1184
  new = gbcpu_regs.rn.a;
#line 1185
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1186
  if ((int )old < (int )new) {
#line 1186
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1187
  if (((int )old & 15) < ((int )new & 15)) {
#line 1187
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1188
  if ((int )new == 0) {
#line 1188
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1189
  return;
}
}
#line 1191 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1193
  tmp = get_imm8();
  }
#line 1193
  imm = (uint8_t )tmp;
#line 1194
  old = gbcpu_regs.rn.a;
#line 1195
  new = old;
  }
  {
  {
#line 1197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1197
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  new = (uint8_t )((int )new - (int )imm);
#line 1199
  gbcpu_regs.rn.a = new;
#line 1200
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1201
  if ((int )old < (int )new) {
#line 1201
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1202
  if (((int )old & 15) < ((int )new & 15)) {
#line 1202
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1203
  if ((int )new == 0) {
#line 1203
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1204
  return;
}
}
#line 1206 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1208
  old = gbcpu_regs.rn.a;
  {
  {
#line 1211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1211
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1212
  print_reg((long )(op & 7U));
  }
  {
#line 1213
  tmp = get_reg((long )(op & 7U));
  }
#line 1213
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1214
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1215
  new = gbcpu_regs.rn.a;
#line 1216
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1217
  if ((int )old < (int )new) {
#line 1217
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1218
  if (((int )old & 15) < ((int )new & 15)) {
#line 1218
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1219
  if ((int )new == 0) {
#line 1219
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1220
  return;
}
}
#line 1222 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1224
  tmp = get_imm8();
  }
#line 1224
  imm = (uint8_t )tmp;
#line 1225
  old = gbcpu_regs.rn.a;
#line 1226
  new = old;
  }
  {
  {
#line 1228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1228
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  new = (uint8_t )((int )new - (int )imm);
#line 1230
  new = (uint8_t )((int )new - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1231
  gbcpu_regs.rn.a = new;
#line 1232
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1233
  if ((int )old < (int )new) {
#line 1233
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1234
  if (((int )old & 15) < ((int )new & 15)) {
#line 1234
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1235
  if ((int )new == 0) {
#line 1235
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1236
  return;
}
}
#line 1238 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1240
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1241
  print_reg((long )(op & 7U));
  }
  {
#line 1242
  tmp = get_reg((long )(op & 7U));
  }
#line 1242
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a & tmp);
#line 1243
  gbcpu_regs.rn.f = (uint8_t )32;
  }
#line 1244
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1244
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1245
  return;
}
}
#line 1247 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1249
  tmp = get_imm8();
  }
#line 1249
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1251
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1252
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a & (int )imm);
#line 1253
  gbcpu_regs.rn.f = (uint8_t )32;
#line 1254
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1254
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1255
  return;
}
}
#line 1257 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1259
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1260
  print_reg((long )(op & 7U));
  }
  {
#line 1261
  tmp = get_reg((long )(op & 7U));
  }
#line 1261
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a | tmp);
#line 1262
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1263
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1263
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1264
  return;
}
}
#line 1266 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1268
  tmp = get_imm8();
  }
#line 1268
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1270
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a | (int )imm);
#line 1272
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1273
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1273
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1274
  return;
}
}
#line 1276 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1278
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1279
  print_reg((long )(op & 7U));
  }
  {
#line 1280
  tmp = get_reg((long )(op & 7U));
  }
#line 1280
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a ^ tmp);
#line 1281
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1282
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1282
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1283
  return;
}
}
#line 1285 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor_imm)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1287
  tmp = get_imm8();
  }
#line 1287
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1289
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1289
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a ^ (int )imm);
#line 1291
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1292
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1292
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1293
  return;
}
}
#line 1295 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_push)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;

  {
  {
#line 1297
  reg = (long )((op >> 4) & 3U);
  {
#line 1299
  push((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
  }
  }
  {
  {
#line 1300
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1300
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1301
  return;
}
}
#line 1303 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_pop)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t tmp ;

  {
  {
#line 1305
  reg = (long )((op >> 4) & 3U);
  {
#line 1307
  tmp = pop();
  }
#line 1307
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )tmp;
  }
  {
  {
#line 1308
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1308
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 1311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cpl)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1313
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1313
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1314
  gbcpu_regs.rn.a = (uint8_t )(~ ((int )gbcpu_regs.rn.a));
#line 1315
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 96);
#line 1316
  return;
}
}
#line 1318 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ccf)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1320
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f ^ 16);
#line 1322
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1323
  return;
}
}
#line 1325 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_scf)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1327
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1327
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1328
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
#line 1329
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1330
  return;
}
}
#line 1332 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1334
  tmp = get_imm16();
  }
#line 1334
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1336
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1337
  push((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1338
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1339
  return;
}
}
#line 1341 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call_cond)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1343
  tmp = get_imm16();
  }
#line 1343
  ofs = (uint16_t )tmp;
#line 1344
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1346
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1346
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1348
  if (cond == 0L) {
#line 1348
    goto case_0;
  }
#line 1349
  if (cond == 1L) {
#line 1349
    goto case_1;
  }
#line 1350
  if (cond == 2L) {
#line 1350
    goto case_2;
  }
#line 1351
  if (cond == 3L) {
#line 1351
    goto case_3;
  }
#line 1347
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1348
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1348
    return;
  }
#line 1348
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1349
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1349
    return;
  }
#line 1349
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1350
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1350
    return;
  }
#line 1350
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1351
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1351
    return;
  }
#line 1351
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1353
  push((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1354
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1355
  return;
}
}
#line 1357 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1359
  tmp = pop();
  }
#line 1359
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1360
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1361
  return;
}
}
#line 1363 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_reti)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1365
  tmp = pop();
  }
#line 1365
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1366
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1367
  return;
}
}
#line 1369 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret_cond)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long cond ;
  uint32_t tmp ;

  {
#line 1371
  cond = (long )((op >> 3) & 3U);
  {
  {
#line 1373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1373
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1375
  if (cond == 0L) {
#line 1375
    goto case_0;
  }
#line 1376
  if (cond == 1L) {
#line 1376
    goto case_1;
  }
#line 1377
  if (cond == 2L) {
#line 1377
    goto case_2;
  }
#line 1378
  if (cond == 3L) {
#line 1378
    goto case_3;
  }
#line 1374
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1375
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1375
    return;
  }
#line 1375
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1376
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1376
    return;
  }
#line 1376
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1377
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1377
    return;
  }
#line 1377
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1378
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1378
    return;
  }
#line 1378
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1380
  tmp = pop();
  }
#line 1380
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
#line 1381
  return;
}
}
#line 1383 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_halt)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1385
  gbcpu_halted = 1L;
  {
  {
#line 1386
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1386
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  return;
}
}
#line 1389 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_stop)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1391
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1391
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  return;
}
}
#line 1394 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_di)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1396
  gbcpu_if = 0L;
  {
  {
#line 1397
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1397
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return;
}
}
#line 1400 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ei)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1402
  gbcpu_if = 1L;
  {
  {
#line 1403
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1403
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1408
  tmp = get_imm8();
  }
#line 1408
  ofs = (int16_t )((int8_t )tmp);
  }
#line 1410
  if ((int )ofs < 0) {
    {
    {
#line 1410
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1410
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1411
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1411
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1412
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1413
  return;
}
}
#line 1415 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr_cond)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1417
  tmp = get_imm8();
  }
#line 1417
  ofs = (int16_t )((int8_t )tmp);
#line 1418
  cond = (long )((op >> 3) & 3U);
  }
#line 1420
  if ((int )ofs < 0) {
    {
    {
#line 1420
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1420
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1421
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1421
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1423
  if (cond == 0L) {
#line 1423
    goto case_0;
  }
#line 1424
  if (cond == 1L) {
#line 1424
    goto case_1;
  }
#line 1425
  if (cond == 2L) {
#line 1425
    goto case_2;
  }
#line 1426
  if (cond == 3L) {
#line 1426
    goto case_3;
  }
#line 1422
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1423
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1423
    return;
  }
#line 1423
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1424
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1424
    return;
  }
#line 1424
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1425
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1425
    return;
  }
#line 1425
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1426
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1426
    return;
  }
#line 1426
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1428
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1429
  return;
}
}
#line 1431 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1433
  tmp = get_imm16();
  }
#line 1433
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1435
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1435
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1437
  return;
}
}
#line 1439 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_hl)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1441
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1441
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  *((uint16_t *)(& gbcpu_regs.ri[10])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1443
  return;
}
}
#line 1445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_cond)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1447
  tmp = get_imm16();
  }
#line 1447
  ofs = (uint16_t )tmp;
#line 1448
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1450
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1450
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1452
  if (cond == 0L) {
#line 1452
    goto case_0;
  }
#line 1453
  if (cond == 1L) {
#line 1453
    goto case_1;
  }
#line 1454
  if (cond == 2L) {
#line 1454
    goto case_2;
  }
#line 1455
  if (cond == 3L) {
#line 1455
    goto case_3;
  }
#line 1451
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1452
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1452
    return;
  }
#line 1452
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1453
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1453
    return;
  }
#line 1453
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1454
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1454
    return;
  }
#line 1454
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1455
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1455
    return;
  }
#line 1455
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1457
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1458
  return;
}
}
#line 1460 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rst)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;

  {
#line 1462
  ofs = (int16_t )(op & 56U);
  {
  {
#line 1464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1464
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1465
  push((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1466
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )ofs;
  }
#line 1467
  return;
}
}
#line 1469 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_nop)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1471
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1471
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  return;
}
}
#line 1474 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  ops[256]  = 
#line 1474
  {      {& op_nop}, 
        {& op_ld_reg16_imm}, 
        {& op_ld_reg16_a}, 
        {& op_inc16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_rlca}, 
        {& op_ld_ind16_sp}, 
        {& op_add_hl}, 
        {& op_ld_reg16_a}, 
        {& op_dec16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_rrca}, 
        {& op_stop}, 
        {& op_ld_reg16_imm}, 
        {& op_ld_reg16_a}, 
        {& op_inc16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_rla}, 
        {& op_jr}, 
        {& op_add_hl}, 
        {& op_ld_reg16_a}, 
        {& op_dec16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_rra}, 
        {& op_jr_cond}, 
        {& op_ld_reg16_imm}, 
        {& op_ld_reg16_a}, 
        {& op_inc16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_unknown}, 
        {& op_jr_cond}, 
        {& op_add_hl}, 
        {& op_ld_reg16_a}, 
        {& op_dec16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_cpl}, 
        {& op_jr_cond}, 
        {& op_ld_reg16_imm}, 
        {& op_ld_reg16_a}, 
        {& op_inc16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_scf}, 
        {& op_jr_cond}, 
        {& op_add_hl}, 
        {& op_ld_reg16_a}, 
        {& op_dec16}, 
        {& op_inc}, 
        {& op_dec}, 
        {& op_ld_reg8_imm}, 
        {& op_ccf}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_halt}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_ld}, 
        {& op_add}, 
        {& op_add}, 
        {& op_add}, 
        {& op_add}, 
        {& op_add}, 
        {& op_add}, 
        {& op_add}, 
        {& op_add}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_adc}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sub}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_sbc}, 
        {& op_and}, 
        {& op_and}, 
        {& op_and}, 
        {& op_and}, 
        {& op_and}, 
        {& op_and}, 
        {& op_and}, 
        {& op_and}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_xor}, 
        {& op_or}, 
        {& op_or}, 
        {& op_or}, 
        {& op_or}, 
        {& op_or}, 
        {& op_or}, 
        {& op_or}, 
        {& op_or}, 
        {& op_cp}, 
        {& op_cp}, 
        {& op_cp}, 
        {& op_cp}, 
        {& op_cp}, 
        {& op_cp}, 
        {& op_cp}, 
        {& op_unknown}, 
        {& op_ret_cond}, 
        {& op_pop}, 
        {& op_jp_cond}, 
        {& op_jp}, 
        {& op_call_cond}, 
        {& op_push}, 
        {& op_add_imm}, 
        {& op_rst}, 
        {& op_ret_cond}, 
        {& op_ret}, 
        {& op_jp_cond}, 
        {& op_cbprefix}, 
        {& op_call_cond}, 
        {& op_call}, 
        {& op_adc_imm}, 
        {& op_rst}, 
        {& op_ret_cond}, 
        {& op_pop}, 
        {& op_jp_cond}, 
        {& op_unknown}, 
        {& op_call_cond}, 
        {& op_push}, 
        {& op_sub_imm}, 
        {& op_rst}, 
        {& op_ret_cond}, 
        {& op_reti}, 
        {& op_jp_cond}, 
        {& op_unknown}, 
        {& op_call_cond}, 
        {& op_unknown}, 
        {& op_sbc_imm}, 
        {& op_rst}, 
        {& op_ldh}, 
        {& op_pop}, 
        {& op_ldh}, 
        {& op_unknown}, 
        {& op_unknown}, 
        {& op_push}, 
        {& op_and_imm}, 
        {& op_rst}, 
        {& op_add_sp_imm}, 
        {& op_jp_hl}, 
        {& op_ld_ind16_a}, 
        {& op_unknown}, 
        {& op_unknown}, 
        {& op_unknown}, 
        {& op_xor_imm}, 
        {& op_rst}, 
        {& op_ldh}, 
        {& op_pop}, 
        {& op_ldh}, 
        {& op_di}, 
        {& op_unknown}, 
        {& op_push}, 
        {& op_or_imm}, 
        {& op_rst}, 
        {& op_ld_hlsp}, 
        {& op_ld_sphl}, 
        {& op_ld_imm}, 
        {& op_ei}, 
        {& op_unknown}, 
        {& op_unknown}, 
        {& op_cp_imm}, 
        {& op_rst}};
#line 1791 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
void ( __attribute__((__regparm__(3))) gbcpu_addmem)(uint32_t start , uint32_t end ,
                                                     void ( __attribute__((__regparm__(3))) (*putfn))(uint32_t addr ,
                                                                                                      uint8_t val ) ,
                                                     uint32_t ( __attribute__((__regparm__(3))) (*getfn))(uint32_t addr ) ) 
{ 
  uint32_t i ;

  {
#line 1795
  i = start;
  {
  {
#line 1795
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1795
    if (! (i <= end)) {
#line 1795
      goto while_break;
    }
#line 1796
    putlookup[i] = putfn;
#line 1797
    getlookup[i] = getfn;
#line 1795
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1799
  return;
}
}
#line 1801 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
void ( __attribute__((__regparm__(3))) gbcpu_init)(void) 
{ 


  {
  {
  {
#line 1803
  memset((void *)(& gbcpu_regs), 0, (size_t )sizeof(gbcpu_regs));
  }
#line 1804
  gbcpu_halted = 0L;
#line 1805
  gbcpu_stopped = 0L;
#line 1806
  gbcpu_if = 0L;
  }
#line 1808
  return;
}
}
#line 1810 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
void ( __attribute__((__regparm__(3))) gbcpu_intr)(long vec ) 
{ 


  {
  {
#line 1812
  gbcpu_halted = 0L;
  {
#line 1813
  push((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1814
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )vec;
  }
#line 1815
  return;
}
}
#line 1817 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
long ( __attribute__((__regparm__(3))) gbcpu_step)(void) 
{ 
  uint8_t op ;
  uint16_t tmp ;
  uint32_t tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 1821
  if (! gbcpu_halted) {
    {
#line 1822
    tmp = gbcpu_regs.rn.pc;
#line 1822
    gbcpu_regs.rn.pc = (uint16_t )((int )gbcpu_regs.rn.pc + 1);
    {
#line 1822
    tmp___0 = mem_get((uint32_t )tmp);
    }
#line 1822
    op = (uint8_t )tmp___0;
    }
    {
    {
#line 1823
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1823
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1824
    (*(ops[op].fn))((uint32_t )op, & ops[op]);
    }
    }
#line 1827
    return (1L);
  }
#line 1829
  if (gbcpu_halted == 1L) {
#line 1829
    if (gbcpu_if == 0L) {
      {
      {
#line 1830
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CPU locked up (halt with interrupts disabled).\n");
      }
#line 1831
      gbcpu_stopped = 1L;
      }
    }
  }
#line 1833
  if (gbcpu_stopped) {
#line 1833
    return (-1L);
  }
#line 1834
  return (16L);
}
}
#line 64 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 13 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.h"
short *gen_impulsetab(long w_shift , long n_shift , double cutoff ) ;
#line 14 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double sinc(double x ) 
{ 
  double a ;
  double tmp ;

  {
#line 16
  a = 3.14159265358979323846 * x;
#line 18
  if (a == 0.0) {
#line 18
    return (1.0);
  }
  {
  {
#line 20
  tmp = sin(a);
  }
  }
#line 20
  return (tmp / a);
}
}
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double blackman(double n , double m ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
  {
#line 25
  tmp = cos((((double )2 * n) * 3.14159265358979323846) / m);
  }
  {
#line 25
  tmp___0 = cos((((double )4 * n) * 3.14159265358979323846) / m);
  }
  }
#line 25
  return ((0.42 - 0.5 * tmp) + 0.08 * tmp___0);
}
}
#line 28 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
short *gen_impulsetab(long w_shift , long n_shift , double cutoff ) 
{ 
  long i ;
  double j ;
  long width ;
  long n ;
  long m ;
  long size ;
  short *pulsetab ;
  void *tmp ;
  short *ptr ;
  long sum ;
  long corr ;
  long n___0 ;
  double div___2 ;
  double dcorr ;
  double xd ;
  double tmp___0 ;
  double tmp___1 ;
  short x ;
  double tmp___2 ;
  long tmp___3 ;
  double xd___0 ;
  double tmp___4 ;
  double tmp___5 ;
  short x___0 ;
  double tmp___6 ;
  short *tmp___7 ;

  {
  {
#line 32
  width = (long )(1 << w_shift);
#line 33
  n = (long )(1 << n_shift);
#line 34
  m = width / 2L;
#line 35
  size = (long )((unsigned long )(width * n) * sizeof(short ));
  {
#line 36
  tmp = malloc((size_t )size);
  }
#line 36
  pulsetab = (short *)tmp;
#line 37
  ptr = pulsetab;
  }
#line 39
  if (! pulsetab) {
#line 40
    return ((short *)((void *)0));
  }
#line 42
  j = (double )0;
  {
  {
#line 42
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 42
    if (! (j < 1.0)) {
#line 42
      goto while_break;
    }
#line 43
    sum = 0L;
#line 45
    n___0 = 0L;
#line 46
    div___2 = 256.0;
#line 47
    dcorr = cutoff;
    {
    {
#line 49
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 50
      sum = 0L;
#line 51
      i = - m + 1L;
      {
      {
#line 51
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 51
        if (! (i <= m)) {
#line 51
          goto while_break___1;
        }
        {
        {
#line 52
        tmp___0 = sinc(((double )i - j) * cutoff);
        }
        {
#line 52
        tmp___1 = blackman(((double )i - j) + (double )(width / 2L), (double )width);
        }
#line 52
        xd = ((dcorr * 256.0) * tmp___0) * tmp___1;
        {
#line 53
        tmp___2 = rint(xd);
        }
#line 53
        x = (short )tmp___2;
#line 54
        sum += (long )x;
#line 51
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 56
      corr = (long )(256.0 - (double )sum);
#line 57
      dcorr *= 1.0 + (double )corr / div___2;
#line 58
      div___2 *= 1.3;
#line 49
      if (corr != 0L) {
#line 49
        tmp___3 = n___0;
#line 49
        n___0 ++;
#line 49
        if (! (tmp___3 < 20L)) {
#line 49
          goto while_break___0;
        }
      } else {
#line 49
        goto while_break___0;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    sum = 0L;
#line 62
    i = - m + 1L;
    {
    {
#line 62
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 62
      if (! (i <= m)) {
#line 62
        goto while_break___2;
      }
      {
      {
#line 63
      tmp___4 = sinc(((double )i - j) * cutoff);
      }
      {
#line 63
      tmp___5 = blackman(((double )i - j) + (double )(width / 2L), (double )width);
      }
#line 63
      xd___0 = ((dcorr * 256.0) * tmp___4) * tmp___5;
      {
#line 64
      tmp___6 = rint(xd___0);
      }
#line 64
      x___0 = (short )tmp___6;
#line 65
      tmp___7 = ptr;
#line 65
      ptr ++;
#line 65
      *tmp___7 = x___0;
#line 66
      sum += (long )x___0;
#line 62
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 68
    *(ptr - m) = (short )((double )*(ptr - m) + (256.0 - (double )sum));
#line 42
    j += 1.0 / (double )n;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (pulsetab);
}
}
#line 13 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static unsigned long crc_table[256]  ;
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static void ( __attribute__((__regparm__(3))) make_crc_table)(void) 
{ 
  unsigned long i ;
  unsigned long j ;
  unsigned long h ;
  unsigned long tmp ;

  {
#line 21
  h = 1UL;
#line 22
  crc_table[0] = 0UL;
#line 23
  i = 128UL;
  {
  {
#line 23
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 23
    if (! i) {
#line 23
      goto while_break;
    }
#line 24
    if (h & 1UL) {
#line 24
      tmp = 3988292384UL;
    } else {
#line 24
      tmp = 0UL;
    }
#line 24
    h = (h >> 1) ^ tmp;
#line 26
    j = 0UL;
    {
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! (j < 256UL)) {
#line 26
        goto while_break___0;
      }
#line 27
      crc_table[i + j] = crc_table[j] ^ h;
#line 26
      j += 2UL * i;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 23
    i >>= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 41 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
unsigned long ( __attribute__((__regparm__(3))) gbs_crc32)(unsigned long crc , char const   *buf___3 ,
                                                           size_t len ) 
{ 
  char const   *tmp ;
  size_t tmp___0 ;

  {
#line 42
  if (crc_table[255] == 0UL) {
    {
    {
#line 43
    make_crc_table();
    }
    }
  }
#line 44
  crc ^= 4294967295UL;
  {
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    tmp___0 = len;
#line 45
    len --;
#line 45
    if (! tmp___0) {
#line 45
      goto while_break;
    }
#line 46
    tmp = buf___3;
#line 46
    buf___3 ++;
#line 46
    crc = (crc >> 8) ^ crc_table[(crc ^ (unsigned long )((unsigned char )*tmp)) & 255UL];
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (crc ^ 4294967295UL);
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 473 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 411
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.h"
void ( __attribute__((__regparm__(3))) gbhw_init)(uint8_t *rombuf , uint32_t size ) ;
#line 60
void ( __attribute__((__regparm__(3))) gbhw_master_fade)(long speed , long dstvol ) ;
#line 61
void ( __attribute__((__regparm__(3))) gbhw_getminmax)(int16_t *lmin , int16_t *lmax ,
                                                       int16_t *rmin , int16_t *rmax ) ;
#line 62
long ( __attribute__((__regparm__(3))) gbhw_step)(long time_to_work ) ;
#line 61 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.h"
struct gbs *( __attribute__((__regparm__(3))) gbs_open)(char *name ) ;
#line 62
long ( __attribute__((__regparm__(3))) gbs_init)(struct gbs *gbs , long subsong ) ;
#line 63
long ( __attribute__((__regparm__(3))) gbs_step)(struct gbs *gbs , long time_to_work ) ;
#line 64
void ( __attribute__((__regparm__(3))) gbs_set_nextsubsong_cb)(struct gbs *gbs , long ( __attribute__((__regparm__(3))) (*cb))(struct gbs *gbs ,
                                                                                                                               void *priv ) ,
                                                               void *priv ) ;
#line 65
void ( __attribute__((__regparm__(3))) gbs_printinfo)(struct gbs *gbs , long verbose ) ;
#line 66
void ( __attribute__((__regparm__(3))) gbs_close)(struct gbs *gbs ) ;
#line 67
long ( __attribute__((__regparm__(3))) gbs_write)(struct gbs *gbs , char *name , long version___2 ) ;
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint8_t const   playercode[127]  = 
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
  {      (uint8_t const   )245,      (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )48, 
        (uint8_t const   )0,      (uint8_t const   )17,      (uint8_t const   )16,      (uint8_t const   )255, 
        (uint8_t const   )33,      (uint8_t const   )159,      (uint8_t const   )0,      (uint8_t const   )42, 
        (uint8_t const   )18,      (uint8_t const   )19,      (uint8_t const   )11,      (uint8_t const   )120, 
        (uint8_t const   )177,      (uint8_t const   )32,      (uint8_t const   )248,      (uint8_t const   )225, 
        (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )14,      (uint8_t const   )0, 
        (uint8_t const   )9,      (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )6, 
        (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )7,      (uint8_t const   )17, 
        (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )203,      (uint8_t const   )87, 
        (uint8_t const   )62,      (uint8_t const   )1,      (uint8_t const   )40,      (uint8_t const   )2, 
        (uint8_t const   )62,      (uint8_t const   )4,      (uint8_t const   )18,      (uint8_t const   )225, 
        (uint8_t const   )241,      (uint8_t const   )87,      (uint8_t const   )229,      (uint8_t const   )1, 
        (uint8_t const   )8,      (uint8_t const   )0,      (uint8_t const   )9,      (uint8_t const   )42, 
        (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122,      (uint8_t const   )1, 
        (uint8_t const   )140,      (uint8_t const   )0,      (uint8_t const   )197,      (uint8_t const   )233, 
        (uint8_t const   )251,      (uint8_t const   )118,      (uint8_t const   )225,      (uint8_t const   )229, 
        (uint8_t const   )1,      (uint8_t const   )10,      (uint8_t const   )0,      (uint8_t const   )9, 
        (uint8_t const   )42,      (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122, 
        (uint8_t const   )1,      (uint8_t const   )157,      (uint8_t const   )0,      (uint8_t const   )197, 
        (uint8_t const   )233,      (uint8_t const   )24,      (uint8_t const   )238,      (uint8_t const   )128, 
        (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191, 
        (uint8_t const   )0,      (uint8_t const   )63,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255,      (uint8_t const   )159, 
        (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )255, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )119, 
        (uint8_t const   )243,      (uint8_t const   )241,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72,      (uint8_t const   )54, 
        (uint8_t const   )2,      (uint8_t const   )207,      (uint8_t const   )22,      (uint8_t const   )44, 
        (uint8_t const   )4,      (uint8_t const   )229,      (uint8_t const   )44,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72};
#line 95 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
long ( __attribute__((__regparm__(3))) gbs_init)(struct gbs *gbs , long subsong ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 97
  gbhw_init(gbs->rom, (uint32_t )gbs->romsize);
  }
  }
#line 99
  if (subsong == -1L) {
#line 99
    subsong = gbs->defaultsong - 1L;
  }
#line 100
  if (subsong >= gbs->songs) {
    {
    {
#line 101
    tmp = _("Subsong number out of range (min=0, max=%ld).\n");
    }
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            gbs->songs - 1L);
    }
    }
#line 102
    return (0L);
  }
#line 105
  gbs->subsong = subsong;
#line 106
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )80;
#line 107
  *((uint16_t *)(& gbcpu_regs.ri[8])) = gbs->stack;
#line 108
  *((uint16_t *)(& gbcpu_regs.ri[4])) = (uint16_t )((int )gbs->load - 112);
#line 109
  gbcpu_regs.rn.a = (uint8_t )subsong;
#line 111
  gbs->ticks = 0LL;
#line 113
  return (1L);
}
}
#line 116 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
void ( __attribute__((__regparm__(3))) gbs_set_nextsubsong_cb)(struct gbs *gbs , long ( __attribute__((__regparm__(3))) (*cb))(struct gbs *gbs ,
                                                                                                                               void *priv ) ,
                                                               void *priv ) 
{ 


  {
#line 118
  gbs->nextsubsong_cb = cb;
#line 119
  gbs->nextsubsong_cb_priv = priv;
#line 120
  return;
}
}
#line 122 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static long ( __attribute__((__regparm__(3))) gbs_nextsubsong)(struct gbs *gbs ) 
{ 
  long tmp ;

  {
#line 124
  if ((unsigned long )gbs->nextsubsong_cb != (unsigned long )((void *)0)) {
    {
    {
#line 125
    tmp = (*(gbs->nextsubsong_cb))(gbs, gbs->nextsubsong_cb_priv);
    }
    }
#line 125
    return (tmp);
  } else {
#line 127
    (gbs->subsong) ++;
#line 128
    if (gbs->subsong >= gbs->songs) {
#line 129
      return (0L);
    }
    {
    {
#line 130
    gbs_init(gbs, gbs->subsong);
    }
    }
  }
#line 132
  return (1L);
}
}
#line 135 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
long ( __attribute__((__regparm__(3))) gbs_step)(struct gbs *gbs , long time_to_work ) 
{ 
  long cycles ;
  long tmp ;
  long time___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
  {
#line 137
  tmp = gbhw_step(time_to_work);
  }
#line 137
  cycles = tmp;
  }
#line 140
  if (cycles < 0L) {
#line 141
    return (0L);
  }
  {
#line 144
  gbs->ticks += (long long )cycles;
  {
#line 146
  gbhw_getminmax(& gbs->lmin, & gbs->lmax, & gbs->rmin, & gbs->rmax);
  }
  }
#line 147
  if (- ((int )gbs->lmin) > (int )gbs->lmax) {
#line 147
    gbs->lvol = (int16_t )(- ((int )gbs->lmin));
  } else {
#line 147
    gbs->lvol = gbs->lmax;
  }
#line 148
  if (- ((int )gbs->rmin) > (int )gbs->rmax) {
#line 148
    gbs->rvol = (int16_t )(- ((int )gbs->rmin));
  } else {
#line 148
    gbs->rvol = gbs->rmax;
  }
#line 150
  time___0 = (long )(gbs->ticks / 4194304LL);
#line 151
  if (gbs->silence_timeout) {
#line 152
    if ((int )gbs->lmin == (int )gbs->lmax) {
#line 152
      if ((int )gbs->rmin == (int )gbs->rmax) {
#line 153
        if (gbs->silence_start == 0LL) {
#line 154
          gbs->silence_start = gbs->ticks;
        }
      } else {
#line 155
        gbs->silence_start = 0LL;
      }
    } else {
#line 155
      gbs->silence_start = 0LL;
    }
  }
#line 158
  if (gbs->fadeout) {
#line 158
    if (gbs->subsong_timeout) {
#line 158
      if (time___0 >= (gbs->subsong_timeout - gbs->fadeout) - gbs->gap) {
        {
        {
#line 160
        gbhw_master_fade(128L / gbs->fadeout, 0L);
        }
        }
      }
    }
  }
#line 161
  if (gbs->subsong_timeout) {
#line 161
    if (time___0 >= gbs->subsong_timeout - gbs->gap) {
      {
      {
#line 163
      gbhw_master_fade(2048L, 0L);
      }
      }
    }
  }
#line 165
  if (gbs->silence_start) {
#line 165
    if ((gbs->ticks - gbs->silence_start) / 4194304LL >= (long long )gbs->silence_timeout) {
#line 167
      if ((gbs->subsong_info + gbs->subsong)->len == 0U) {
#line 168
        (gbs->subsong_info + gbs->subsong)->len = (uint32_t )((gbs->ticks * (long long )(1 << 10)) / 4194304LL);
      }
      {
      {
#line 170
      tmp___0 = gbs_nextsubsong(gbs);
      }
      }
#line 170
      return (tmp___0);
    }
  }
#line 172
  if (gbs->subsong_timeout) {
#line 172
    if (time___0 >= gbs->subsong_timeout) {
      {
      {
#line 173
      tmp___1 = gbs_nextsubsong(gbs);
      }
      }
#line 173
      return (tmp___1);
    }
  }
#line 175
  return (1L);
}
}
#line 178 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
void ( __attribute__((__regparm__(3))) gbs_printinfo)(struct gbs *gbs , long verbose ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long i ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 180
  tmp = _("GBSVersion:     %ld\nTitle:          \"%s\"\nAuthor:         \"%s\"\nCopyright:      \"%s\"\nLoad address:   0x%04x\nInit address:   0x%04x\nPlay address:   0x%04x\nStack pointer:  0x%04x\nFile size:      0x%08x\nROM size:       0x%08lx (%ld banks)\nSubsongs:       %ld\n");
  }
  {
#line 180
  printf((char const   */* __restrict  */)tmp, gbs->version, gbs->title, gbs->author,
         gbs->copyright, (int )gbs->load, (int )gbs->init, (int )gbs->play, (int )gbs->stack,
         gbs->filesize, gbs->romsize, gbs->romsize / 16384UL, gbs->songs);
  }
  }
#line 203
  if (gbs->version == 2L) {
#line 204
    if (gbs->crc == gbs->crcnow) {
      {
      {
#line 204
      tmp___0 = _("OK");
      }
#line 204
      tmp___2 = tmp___0;
      }
    } else {
      {
      {
#line 204
      tmp___1 = _("Failed");
      }
#line 204
      tmp___2 = tmp___1;
      }
    }
    {
    {
#line 204
    tmp___3 = _("CRC32:\t\t0x%08lx/0x%08lx (%s)\n");
    }
    {
#line 204
    printf((char const   */* __restrict  */)tmp___3, (unsigned long )gbs->crc, (unsigned long )gbs->crcnow,
           tmp___2);
    }
    }
  }
#line 208
  if (verbose) {
#line 208
    if (gbs->version == 2L) {
#line 210
      i = 0L;
      {
      {
#line 210
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 210
        if (! (i < gbs->songs)) {
#line 210
          goto while_break;
        }
        {
        {
#line 211
        tmp___4 = _("Subsong %03ld:\t");
        }
        {
#line 211
        printf((char const   */* __restrict  */)tmp___4, i);
        }
        }
#line 212
        if ((gbs->subsong_info + i)->title) {
          {
          {
#line 213
          printf((char const   */* __restrict  */)"\"%s\" ", (gbs->subsong_info + i)->title);
          }
          }
        } else {
          {
          {
#line 215
          tmp___5 = _("untitled");
          }
          {
#line 215
          printf((char const   */* __restrict  */)"%s ", tmp___5);
          }
          }
        }
#line 217
        if ((gbs->subsong_info + i)->len) {
          {
          {
#line 218
          tmp___6 = _("(%ld seconds)\n");
          }
          {
#line 218
          printf((char const   */* __restrict  */)tmp___6, (long )((gbs->subsong_info + i)->len >> 10));
          }
          }
        } else {
          {
          {
#line 221
          tmp___7 = _("no time limit");
          }
          {
#line 221
          printf((char const   */* __restrict  */)"%s\n", tmp___7);
          }
          }
        }
#line 210
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 225
  return;
}
}
#line 227 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
void ( __attribute__((__regparm__(3))) gbs_close)(struct gbs *gbs ) 
{ 


  {
  {
  {
#line 229
  free((void *)gbs->subsong_info);
  }
  {
#line 230
  free((void *)gbs);
  }
  }
#line 231
  return;
}
}
#line 233 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static void ( __attribute__((__regparm__(3))) writeint)(char *buf___3 , uint32_t val ,
                                                        long bytes ) 
{ 
  long shift ;
  long i ;

  {
#line 235
  shift = 0L;
#line 238
  i = 0L;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < bytes)) {
#line 238
      goto while_break;
    }
#line 239
    *(buf___3 + i) = (char )((val >> shift) & 255U);
#line 240
    shift += 8L;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint32_t ( __attribute__((__regparm__(3))) readint)(char *buf___3 , long bytes ) 
{ 
  long i ;
  long shift ;
  uint32_t res ;

  {
#line 247
  shift = 0L;
#line 248
  res = (uint32_t )0;
#line 250
  i = 0L;
  {
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < bytes)) {
#line 250
      goto while_break;
    }
#line 251
    res |= (unsigned int )((int )((unsigned char )*(buf___3 + i)) << shift);
#line 252
    shift += 8L;
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return (res);
}
}
#line 258 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
long ( __attribute__((__regparm__(3))) gbs_write)(struct gbs *gbs , char *name , long version___2 ) 
{ 
  long fd___2 ;
  long codelen ;
  char pad[16] ;
  char strings[65536] ;
  long stringofs ;
  long newlen ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long len ;
  long i ;
  long ehdrlen ;
  uint32_t hdrcrc ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 261
  codelen = (long )((gbs->codelen + 15UL) >> 4);
#line 264
  stringofs = 0L;
#line 265
  newlen = (long )gbs->filesize;
  {
#line 267
  memset((void *)(pad), 255, (size_t )sizeof(pad));
  }
  {
#line 269
  tmp___2 = open((char const   *)name, 577, 420);
  }
#line 269
  fd___2 = (long )tmp___2;
  }
#line 269
  if (fd___2 == -1L) {
    {
    {
#line 270
    tmp = __errno_location();
    }
    {
#line 270
    tmp___0 = strerror(*tmp);
    }
    {
#line 270
    tmp___1 = _("Could not open %s: %s\n");
    }
    {
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            name, tmp___0);
    }
    }
#line 271
    return (0L);
  }
#line 274
  if (version___2 == 2L) {
    {
#line 276
    ehdrlen = 32L + 8L * gbs->songs;
#line 279
    newlen = (112L + codelen * 16L) + ehdrlen;
#line 280
    *(gbs->buf + 3) = (char)1;
    {
#line 281
    tmp___3 = realloc((void *)gbs->buf, (size_t )(newlen + 65536L));
    }
#line 281
    gbs->buf = (char *)tmp___3;
#line 282
    gbs->code = gbs->buf + 112;
#line 283
    gbs->exthdr = gbs->code + codelen * 16L;
    {
#line 284
    writeint(gbs->buf + 110, (uint32_t )codelen, 2L);
    }
    {
#line 285
    memset((void *)(gbs->code + gbs->codelen), 0, (size_t )((unsigned long )(codelen * 16L) - gbs->codelen));
    }
    {
#line 286
    memset((void *)gbs->exthdr, 0, (size_t )(ehdrlen + 65536L));
    }
    {
#line 287
    strncpy((char */* __restrict  */)gbs->exthdr, (char const   */* __restrict  */)"GBSX",
            (size_t )4);
    }
#line 288
    *(gbs->exthdr + 28) = (char )gbs->songs;
    {
#line 289
    tmp___4 = strlen((char const   *)gbs->title);
    }
#line 289
    len = (long )tmp___4;
    }
#line 289
    if (len > 32L) {
      {
      {
#line 290
      memcpy((void */* __restrict  */)(strings + stringofs), (void const   */* __restrict  */)gbs->title,
             (size_t )(len + 1L));
      }
      {
#line 291
      writeint(gbs->exthdr + 20, (uint32_t )stringofs, 2L);
      }
#line 292
      stringofs += len + 1L;
      }
    } else {
      {
      {
#line 293
      writeint(gbs->exthdr + 20, (uint32_t )65535, 2L);
      }
      }
    }
    {
    {
#line 294
    tmp___5 = strlen((char const   *)gbs->author);
    }
#line 294
    len = (long )tmp___5;
    }
#line 294
    if (len > 32L) {
      {
      {
#line 295
      memcpy((void */* __restrict  */)(strings + stringofs), (void const   */* __restrict  */)gbs->author,
             (size_t )(len + 1L));
      }
      {
#line 296
      writeint(gbs->exthdr + 22, (uint32_t )stringofs, 2L);
      }
#line 297
      stringofs += len + 1L;
      }
    } else {
      {
      {
#line 298
      writeint(gbs->exthdr + 22, (uint32_t )65535, 2L);
      }
      }
    }
    {
    {
#line 299
    tmp___6 = strlen((char const   *)gbs->copyright);
    }
#line 299
    len = (long )tmp___6;
    }
#line 299
    if (len > 30L) {
      {
      {
#line 300
      memcpy((void */* __restrict  */)(strings + stringofs), (void const   */* __restrict  */)gbs->copyright,
             (size_t )(len + 1L));
      }
      {
#line 301
      writeint(gbs->exthdr + 24, (uint32_t )stringofs, 2L);
      }
#line 302
      stringofs += len + 1L;
      }
    } else {
      {
      {
#line 303
      writeint(gbs->exthdr + 24, (uint32_t )65535, 2L);
      }
      }
    }
#line 305
    i = 0L;
    {
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 305
      if (! (i < gbs->songs)) {
#line 305
        goto while_break;
      }
      {
      {
#line 306
      writeint(gbs->exthdr + (32L + 8L * i), (gbs->subsong_info + i)->len, 4L);
      }
      }
#line 308
      if ((gbs->subsong_info + i)->title) {
        {
        {
#line 308
        tmp___8 = strcmp((char const   *)(gbs->subsong_info + i)->title, "");
        }
        }
#line 308
        if (tmp___8 != 0) {
          {
          {
#line 310
          tmp___7 = strlen((char const   *)(gbs->subsong_info + i)->title);
          }
#line 310
          len = (long )(tmp___7 + 1U);
          {
#line 311
          memcpy((void */* __restrict  */)(strings + stringofs), (void const   */* __restrict  */)(gbs->subsong_info + i)->title,
                 (size_t )len);
          }
          {
#line 312
          writeint(gbs->exthdr + ((32L + 8L * i) + 4L), (uint32_t )stringofs, 2L);
          }
#line 314
          stringofs += len;
          }
        } else {
          {
          {
#line 315
          writeint(gbs->exthdr + ((32L + 8L * i) + 4L), (uint32_t )65535, 2L);
          }
          }
        }
      } else {
        {
        {
#line 315
        writeint(gbs->exthdr + ((32L + 8L * i) + 4L), (uint32_t )65535, 2L);
        }
        }
      }
#line 305
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 317
    memcpy((void */* __restrict  */)(gbs->buf + newlen), (void const   */* __restrict  */)(strings),
           (size_t )stringofs);
    }
#line 318
    newlen += stringofs;
    {
#line 320
    writeint(gbs->exthdr + 4, (uint32_t )((ehdrlen + stringofs) - 8L), 4L);
    }
    {
#line 321
    writeint(gbs->exthdr + 12, gbs->filesize, 4L);
    }
    {
#line 322
    tmp___9 = gbs_crc32(0UL, (char const   *)gbs->buf, gbs->filesize);
    }
#line 322
    gbs->crc = (uint32_t )tmp___9;
    {
#line 323
    writeint(gbs->exthdr + 16, gbs->crc, 4L);
    }
    {
#line 324
    tmp___10 = gbs_crc32(0UL, (char const   *)gbs->exthdr, (size_t )(ehdrlen + stringofs));
    }
#line 324
    hdrcrc = (uint32_t )tmp___10;
    {
#line 325
    writeint(gbs->exthdr + 8, hdrcrc, 4L);
    }
    }
  } else
#line 328
  if (gbs->version == 2L) {
#line 329
    *(gbs->buf + 3) = (char)1;
  }
  {
  {
#line 332
  write((int )fd___2, (void const   *)gbs->buf, (size_t )newlen);
  }
  {
#line 333
  close((int )fd___2);
  }
  }
#line 335
  return (1L);
}
}
#line 338 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
struct gbs *( __attribute__((__regparm__(3))) gbs_open)(char *name ) 
{ 
  long fd___2 ;
  long i ;
  struct stat st ;
  struct gbs *gbs ;
  void *tmp ;
  char *buf___3 ;
  char *buf2 ;
  long have_ehdr ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  void *tmp___12 ;
  uint32_t crc ;
  uint32_t realcrc ;
  uint32_t ehdrlen ;
  uint32_t tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  int tmp___16 ;
  unsigned long tmp___17 ;
  long gbs_titleex ;
  long gbs_authorex ;
  long gbs_copyex ;
  long entries ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  long ofs ;
  uint32_t tmp___21 ;
  char *tmp___22 ;
  void *tmp___23 ;
  long addr ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
  {
#line 342
  tmp = malloc((size_t )sizeof(struct gbs ));
  }
#line 342
  gbs = (struct gbs *)tmp;
#line 344
  buf2 = (char *)((void *)0);
#line 345
  have_ehdr = 0L;
  {
#line 347
  memset((void *)gbs, 0, (size_t )sizeof(struct gbs ));
  }
#line 348
  gbs->silence_timeout = 2L;
#line 349
  gbs->subsong_timeout = 120L;
#line 350
  gbs->gap = 2L;
#line 351
  gbs->fadeout = 3L;
  {
#line 352
  tmp___3 = open((char const   *)name, 0);
  }
#line 352
  fd___2 = (long )tmp___3;
  }
#line 352
  if (fd___2 == -1L) {
    {
    {
#line 353
    tmp___0 = __errno_location();
    }
    {
#line 353
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 353
    tmp___2 = _("Could not open %s: %s\n");
    }
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            name, tmp___1);
    }
    }
#line 354
    return ((struct gbs *)((void *)0));
  }
  {
  {
#line 356
  fstat((int )fd___2, & st);
  }
  {
#line 357
  tmp___4 = malloc((size_t )st.st_size);
  }
#line 357
  buf___3 = (char *)tmp___4;
#line 357
  gbs->buf = buf___3;
  {
#line 358
  read((int )fd___2, (void *)buf___3, (size_t )st.st_size);
  }
  {
#line 359
  tmp___6 = strncmp((char const   *)buf___3, "GBS", (size_t )3);
  }
  }
#line 359
  if (tmp___6 != 0) {
    {
    {
#line 360
    tmp___5 = _("Not a GBS-File: %s\n");
    }
    {
#line 360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
            name);
    }
    }
#line 361
    return ((struct gbs *)((void *)0));
  }
#line 363
  gbs->version = (long )*(buf___3 + 3);
#line 364
  if (gbs->version != 1L) {
    {
    {
#line 365
    tmp___7 = _("GBS Version %d unsupported.\n");
    }
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
            (int )*(buf___3 + 3));
    }
    }
#line 366
    return ((struct gbs *)((void *)0));
  }
  {
#line 369
  gbs->songs = (long )*(buf___3 + 4);
#line 370
  gbs->defaultsong = (long )*(buf___3 + 5);
  {
#line 371
  tmp___8 = readint(buf___3 + 6, 2L);
  }
#line 371
  gbs->load = (uint16_t )tmp___8;
  {
#line 372
  tmp___9 = readint(buf___3 + 8, 2L);
  }
#line 372
  gbs->init = (uint16_t )tmp___9;
  {
#line 373
  tmp___10 = readint(buf___3 + 10, 2L);
  }
#line 373
  gbs->play = (uint16_t )tmp___10;
  {
#line 374
  tmp___11 = readint(buf___3 + 12, 2L);
  }
#line 374
  gbs->stack = (uint16_t )tmp___11;
#line 375
  gbs->tma = (uint8_t )*(buf___3 + 14);
#line 376
  gbs->tmc = (uint8_t )*(buf___3 + 15);
  {
#line 378
  memcpy((void */* __restrict  */)(gbs->v1strings), (void const   */* __restrict  */)(buf___3 + 16),
         (size_t )32);
  }
  {
#line 379
  memcpy((void */* __restrict  */)(gbs->v1strings + 33), (void const   */* __restrict  */)(buf___3 + 48),
         (size_t )32);
  }
  {
#line 380
  memcpy((void */* __restrict  */)(gbs->v1strings + 66), (void const   */* __restrict  */)(buf___3 + 80),
         (size_t )30);
  }
#line 381
  gbs->title = gbs->v1strings;
#line 382
  gbs->author = gbs->v1strings + 33;
#line 383
  gbs->copyright = gbs->v1strings + 66;
#line 384
  gbs->code = buf___3 + 112;
#line 385
  gbs->filesize = (size_t )st.st_size;
  {
#line 387
  tmp___12 = malloc((size_t )((unsigned long )gbs->songs * sizeof(struct gbs_subsong_info )));
  }
#line 387
  gbs->subsong_info = (struct gbs_subsong_info *)tmp___12;
  {
#line 388
  memset((void *)gbs->subsong_info, 0, (size_t )((unsigned long )gbs->songs * sizeof(struct gbs_subsong_info )));
  }
#line 389
  gbs->codelen = (unsigned long )(((int )*(buf___3 + 110) + ((int )*(buf___3 + 111) << 8)) << 4);
  }
#line 390
  if (112UL + gbs->codelen < (unsigned long )(gbs->filesize - 8U)) {
    {
    {
#line 390
    tmp___16 = strncmp((char const   *)(buf___3 + (112UL + gbs->codelen)), "GBSX",
                       (size_t )4);
    }
    }
#line 390
    if (tmp___16 == 0) {
      {
#line 394
      gbs->exthdr = gbs->code + gbs->codelen;
      {
#line 395
      tmp___13 = readint(gbs->exthdr + 4, 4L);
      }
#line 395
      ehdrlen = tmp___13 + 8U;
      {
#line 396
      crc = readint(gbs->exthdr + 8, 4L);
      }
      {
#line 397
      writeint(gbs->exthdr + 8, (uint32_t )0, 4L);
      }
      {
#line 399
      tmp___15 = gbs_crc32(0UL, (char const   *)gbs->exthdr, ehdrlen);
      }
#line 399
      realcrc = (uint32_t )tmp___15;
      }
#line 399
      if (realcrc == crc) {
#line 400
        have_ehdr = 1L;
      } else {
        {
        {
#line 402
        tmp___14 = _("Warning: Extended header found, but CRC does not match (0x%08x != 0x%08x).\n");
        }
        {
#line 402
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___14,
                crc, realcrc);
        }
        }
      }
    }
  }
#line 406
  if (have_ehdr) {
    {
#line 407
    buf2 = gbs->exthdr;
    {
#line 408
    gbs->filesize = readint(buf2 + 12, 4L);
    }
    {
#line 409
    gbs->crc = readint(buf2 + 16, 4L);
    }
    {
#line 410
    writeint(buf2 + 16, (uint32_t )0, 4L);
    }
    }
  } else {
    {
    {
#line 412
    memcpy((void */* __restrict  */)(gbs->v1strings + 66), (void const   */* __restrict  */)(buf___3 + 80),
           (size_t )32);
    }
#line 413
    gbs->codelen = (unsigned long )(st.st_size - 112L);
    }
  }
  {
  {
#line 415
  tmp___17 = gbs_crc32(0UL, (char const   *)buf___3, gbs->filesize);
  }
#line 415
  gbs->crcnow = (uint32_t )tmp___17;
  }
#line 416
  if (have_ehdr) {
    {
#line 422
    gbs->version = 2L;
#line 423
    entries = (long )*(buf2 + 28);
#line 424
    gbs->strings = (gbs->exthdr + 32) + 8L * entries;
    {
#line 426
    tmp___18 = readint(buf2 + 20, 2L);
    }
#line 426
    gbs_titleex = (long )tmp___18;
    {
#line 427
    tmp___19 = readint(buf2 + 22, 2L);
    }
#line 427
    gbs_authorex = (long )tmp___19;
    {
#line 428
    tmp___20 = readint(buf2 + 24, 2L);
    }
#line 428
    gbs_copyex = (long )tmp___20;
    }
#line 429
    if (gbs_titleex != 65535L) {
#line 430
      gbs->title = gbs->strings + gbs_titleex;
    }
#line 431
    if (gbs_authorex != 65535L) {
#line 432
      gbs->author = gbs->strings + gbs_authorex;
    }
#line 433
    if (gbs_copyex != 65535L) {
#line 434
      gbs->copyright = gbs->strings + gbs_copyex;
    }
#line 436
    i = 0L;
    {
    {
#line 436
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 436
      if (! (i < entries)) {
#line 436
        goto while_break;
      }
      {
      {
#line 437
      tmp___21 = readint(buf2 + ((32L + 8L * i) + 4L), 2L);
      }
#line 437
      ofs = (long )tmp___21;
      {
#line 438
      (gbs->subsong_info + i)->len = readint(buf2 + (32L + 8L * i), 4L);
      }
      }
#line 439
      if (ofs == 65535L) {
#line 440
        (gbs->subsong_info + i)->title = (char *)((void *)0);
      } else {
#line 441
        (gbs->subsong_info + i)->title = gbs->strings + ofs;
      }
#line 436
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 444
    if (gbs->crc != gbs->crcnow) {
      {
      {
#line 445
      tmp___22 = _("Warning: File CRC does not match (0x%08x != 0x%08x).\n");
      }
      {
#line 445
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
              gbs->crc, gbs->crcnow);
      }
      }
    }
  }
  {
#line 450
  gbs->romsize = ((gbs->codelen + (unsigned long )gbs->load) + 16383UL) & 0xffffffffffffc000UL;
  {
#line 452
  tmp___23 = calloc((size_t )1, (size_t )gbs->romsize);
  }
#line 452
  gbs->rom = (uint8_t *)tmp___23;
  {
#line 453
  memcpy((void */* __restrict  */)(gbs->rom + ((int )gbs->load - 112)), (void const   */* __restrict  */)buf___3,
         (size_t )(112UL + gbs->codelen));
  }
  {
#line 454
  memcpy((void */* __restrict  */)(gbs->rom + 80), (void const   */* __restrict  */)(playercode),
         (size_t )sizeof(playercode));
  }
#line 456
  i = 0L;
  }
  {
  {
#line 456
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 456
    if (! (i < 8L)) {
#line 456
      goto while_break___0;
    }
#line 457
    addr = (long )gbs->load + 8L * i;
#line 458
    *(gbs->rom + 8L * i) = (uint8_t )195;
#line 459
    *(gbs->rom + (8L * i + 1L)) = (uint8_t )(addr & 255L);
#line 460
    *(gbs->rom + (8L * i + 2L)) = (uint8_t )(addr >> 8);
#line 456
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 462
  *(gbs->rom + 64) = (uint8_t )201;
#line 463
  *(gbs->rom + 72) = (uint8_t )201;
  {
#line 465
  close((int )fd___2);
  }
  }
#line 467
  return (gbs);
}
}
#line 456 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.h"
struct gbhw_channel gbhw_ch[4]  ;
#line 54
void ( __attribute__((__regparm__(3))) gbhw_setcallback)(void ( __attribute__((__regparm__(3))) (*fn))(struct gbhw_buffer *buf ,
                                                                                                       void *priv ) ,
                                                         void *priv ) ;
#line 55
void ( __attribute__((__regparm__(3))) gbhw_setiocallback)(void ( __attribute__((__regparm__(3))) (*fn))(long cycles ,
                                                                                                         uint32_t addr ,
                                                                                                         uint8_t valu ,
                                                                                                         void *priv ) ,
                                                           void *priv ) ;
#line 56
void ( __attribute__((__regparm__(3))) gbhw_setrate)(long rate___1 ) ;
#line 57
void ( __attribute__((__regparm__(3))) gbhw_setbuffer)(struct gbhw_buffer *buffer ) ;
#line 59
void ( __attribute__((__regparm__(3))) gbhw_pause)(long new_pause ) ;
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t *rom  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t intram[8192]  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t extram[8192]  ;
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t ioregs[128]  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t hiram[128]  ;
#line 25 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rombank  =    1L;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lastbank  ;
#line 28 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static char const   dutylookup[4]  = {      (char const   )1,      (char const   )2,      (char const   )4,      (char const   )6};
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lminval  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lmaxval  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rminval  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rmaxval  ;
#line 38 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_volume  ;
#line 39 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_fade  ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_dstvol  ;
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   vblanktc  =    (long const   )70256;
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long vblankctr  =    70256L;
#line 44 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timertc  =    70256L;
#line 45 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timerctr  =    70256L;
#line 47 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   msec_cycles  =    (long const   )4194;
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sum_cycles  ;
#line 51 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long pause_output  =    0L;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*callback))(struct gbhw_buffer *buf ,
                                                           void *priv )  ;
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *callbackpriv  ;
#line 55 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *soundbuf  =    (struct gbhw_buffer *)((void *)0);
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *impbuf  =    (struct gbhw_buffer *)((void *)0);
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*iocallback))(long cycles , uint32_t addr ,
                                                             uint8_t valu , void *priv )  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *iocallback_priv  ;
#line 66 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap1  =    (uint32_t )16384;
#line 67 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap2  =    (uint32_t )8192;
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t lfsr  =    4294967295U;
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long long sound_div_tc  =    0LL;
#line 73 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   main_div_tc  =    (long const   )32;
#line 74 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long main_div  ;
#line 75 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   sweep_div_tc  =    (long const   )256;
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sweep_div  ;
#line 78 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long ch3pos  ;
#line 80 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_n_shift  =    7L;
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_w_shift  =    5L;
#line 82 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static double impulse_cutoff  =    1.0;
#line 84 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static short *base_impulse  =    (short *)((void *)0);
#line 90 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rom_get)(uint32_t addr ) 
{ 


  {
#line 93
  return ((uint32_t )*(rom + (addr & 16383U)));
}
}
#line 96 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rombank_get)(uint32_t addr ) 
{ 


  {
#line 99
  return ((uint32_t )*(rom + ((long )(addr & 16383U) + 16384L * rombank)));
}
}
#line 102 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) io_get)(uint32_t addr ) 
{ 
  char *__cil_tmp2 ;

  {
#line 104
  if (addr >= 65408U) {
#line 104
    if (addr <= 65534U) {
#line 105
      return ((uint32_t )hiram[addr & 127U]);
    }
  }
#line 107
  if (addr >= 65296U) {
#line 107
    if (addr <= 65343U) {
#line 109
      return ((uint32_t )ioregs[addr & 127U]);
    }
  }
#line 111
  if (addr == 65280U) {
#line 111
    return ((uint32_t )0);
  }
#line 112
  if (addr == 65535U) {
#line 112
    return ((uint32_t )ioregs[127]);
  }
  {
  {
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ioread from 0x%04x unimplemented.\n",
          addr);
  }
  }
  {
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((uint32_t )255);
}
}
#line 118 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) intram_get)(uint32_t addr ) 
{ 


  {
#line 121
  return ((uint32_t )intram[addr & 8191U]);
}
}
#line 124 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) extram_get)(uint32_t addr ) 
{ 


  {
#line 127
  return ((uint32_t )extram[addr & 8191U]);
}
}
#line 130 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) rom_put)(uint32_t addr , uint8_t val ) 
{ 
  char *__cil_tmp3 ;

  {
#line 132
  if (addr >= 8192U) {
#line 132
    if (addr <= 16383U) {
#line 133
      val = (uint8_t )((int )val & 31);
#line 134
      rombank = (long )((int )val + ((int )val == 0));
#line 135
      if (rombank > lastbank) {
        {
        {
#line 136
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bank %ld out of range (0-%ld)!\n",
                rombank, lastbank);
        }
#line 137
        rombank = lastbank;
        }
      }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) io_put)(uint32_t addr , uint8_t val ) 
{ 
  long chn ;
  long duty_ctr ;
  long len ;
  long vol ;
  long envdir ;
  long envspd ;
  long tmp ;
  long div___2 ;
  long vol___0 ;
  long div___3 ;
  long shift ;
  long rate___1 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 144
  (*iocallback)(sum_cycles, addr, val, iocallback_priv);
  }
#line 146
  chn = (long )((addr - 65296U) / 5U);
  }
#line 147
  if (addr >= 65408U) {
#line 147
    if (addr <= 65534U) {
#line 148
      hiram[addr & 127U] = val;
#line 149
      return;
    }
  }
#line 151
  ioregs[addr & 127U] = val;
  {
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  if (addr == 65287U) {
#line 155
    goto case_65287;
  }
#line 155
  if (addr == 65286U) {
#line 155
    goto case_65287;
  }
#line 160
  if (addr == 65296U) {
#line 160
    goto case_65296;
  }
#line 168
  if (addr == 65312U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65302U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65297U) {
#line 168
    goto case_65312;
  }
#line 181
  if (addr == 65313U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65303U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65298U) {
#line 181
    goto case_65313;
  }
#line 197
  if (addr == 65310U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65309U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65305U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65304U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65300U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65299U) {
#line 197
    goto case_65310;
  }
#line 213
  if (addr == 65301U) {
#line 213
    goto case_65301;
  }
#line 215
  if (addr == 65306U) {
#line 215
    goto case_65306;
  }
#line 218
  if (addr == 65307U) {
#line 218
    goto case_65307;
  }
#line 221
  if (addr == 65308U) {
#line 221
    goto case_65308;
  }
#line 227
  if (addr == 65311U) {
#line 227
    goto case_65311;
  }
#line 230
  if (addr == 65315U) {
#line 230
    goto case_65315;
  }
#line 230
  if (addr == 65314U) {
#line 230
    goto case_65315;
  }
#line 252
  if (addr == 65317U) {
#line 252
    goto case_65317;
  }
#line 262
  if (addr == 65318U) {
#line 262
    goto case_65318;
  }
#line 292
  if (addr == 65535U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65343U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65342U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65341U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65340U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65339U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65338U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65337U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65336U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65335U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65334U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65333U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65332U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65331U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65330U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65329U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65328U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65327U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65326U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65325U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65324U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65323U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65322U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65321U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65320U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65319U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65316U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65280U) {
#line 292
    goto case_65535;
  }
#line 294
  goto switch_default;
  case_65287: /* CIL Label */ 
  case_65286: /* CIL Label */ 
#line 156
  timertc = (long )((256 - (int )ioregs[6]) * (16 << ((((int )ioregs[7] + 3) & 3) << 1)));
#line 157
  if (((int )ioregs[7] & 240) == 128) {
#line 157
    timertc /= 2L;
  }
#line 159
  goto switch_break;
  case_65296: /* CIL Label */ 
#line 161
  gbhw_ch[0].sweep_tc = (long )(((int )val >> 4) & 7);
#line 161
  gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 162
  gbhw_ch[0].sweep_dir = (long )(((int )val >> 3) & 1);
#line 163
  gbhw_ch[0].sweep_shift = (long )((int )val & 7);
#line 165
  goto switch_break;
  case_65312: /* CIL Label */ 
  case_65302: /* CIL Label */ 
  case_65297: /* CIL Label */ 
#line 170
  duty_ctr = (long )((int )val >> 6);
#line 171
  len = (long )((int )val & 63);
#line 173
  gbhw_ch[chn].duty_ctr = (long )dutylookup[duty_ctr];
#line 174
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 175
  gbhw_ch[chn].len = (64L - len) * 2L;
#line 177
  goto switch_break;
  case_65313: /* CIL Label */ 
  case_65303: /* CIL Label */ 
  case_65298: /* CIL Label */ 
#line 183
  vol = (long )((int )val >> 4);
#line 184
  envdir = (long )(((int )val >> 3) & 1);
#line 185
  envspd = (long )((int )val & 7);
#line 187
  gbhw_ch[chn].volume = vol;
#line 188
  gbhw_ch[chn].env_dir = envdir;
#line 189
  tmp = envspd * 8L;
#line 189
  gbhw_ch[chn].env_tc = tmp;
#line 189
  gbhw_ch[chn].env_ctr = tmp;
#line 191
  goto switch_break;
  case_65310: /* CIL Label */ 
  case_65309: /* CIL Label */ 
  case_65305: /* CIL Label */ 
  case_65304: /* CIL Label */ 
  case_65300: /* CIL Label */ 
  case_65299: /* CIL Label */ 
#line 199
  div___2 = (long )ioregs[19L + 5L * chn];
#line 201
  div___2 |= ((long )ioregs[20L + 5L * chn] & 7L) << 8;
#line 202
  gbhw_ch[chn].div_tc = 2048L - div___2;
#line 203
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 205
  if (addr == 65299U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65304U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65309U) {
#line 207
    goto switch_break;
  }
#line 209
  gbhw_ch[chn].len_enable = (long )(((int )ioregs[20L + 5L * chn] & 64) > 0);
#line 212
  goto switch_break;
  case_65301: /* CIL Label */ 
#line 214
  goto switch_break;
  case_65306: /* CIL Label */ 
#line 216
  gbhw_ch[2].master = (long )(((int )ioregs[26] & 128) > 0);
#line 217
  goto switch_break;
  case_65307: /* CIL Label */ 
#line 219
  gbhw_ch[2].len = (long )((256 - (int )val) * 2);
#line 220
  goto switch_break;
  case_65308: /* CIL Label */ 
#line 223
  vol___0 = (long )(((int )ioregs[28] >> 5) & 3);
#line 224
  gbhw_ch[2].volume = vol___0;
#line 225
  goto switch_break;
  case_65311: /* CIL Label */ 
#line 228
  goto switch_break;
  case_65315: /* CIL Label */ 
  case_65314: /* CIL Label */ 
#line 232
  div___3 = (long )ioregs[34];
#line 233
  shift = div___3 >> 4;
#line 234
  rate___1 = div___3 & 7L;
#line 235
  gbhw_ch[3].div_ctr = 0L;
#line 236
  gbhw_ch[3].div_tc = (long )(1 << shift);
#line 237
  if (div___3 & 8L) {
#line 238
    tap1 = (uint32_t )64;
#line 239
    tap2 = (uint32_t )32;
  } else {
#line 241
    tap1 = (uint32_t )16384;
#line 242
    tap2 = (uint32_t )8192;
  }
#line 244
  lfsr |= 1U;
#line 245
  if (rate___1) {
#line 245
    gbhw_ch[3].div_tc *= rate___1;
  } else {
#line 246
    gbhw_ch[3].div_tc /= 2L;
  }
#line 247
  if (addr == 65314U) {
#line 247
    goto switch_break;
  }
#line 250
  gbhw_ch[chn].len_enable = (long )(((int )ioregs[35] & 64) > 0);
#line 251
  goto switch_break;
  case_65317: /* CIL Label */ 
#line 253
  gbhw_ch[0].leftgate = (long )(((int )val & 16) > 0);
#line 254
  gbhw_ch[0].rightgate = (long )(((int )val & 1) > 0);
#line 255
  gbhw_ch[1].leftgate = (long )(((int )val & 32) > 0);
#line 256
  gbhw_ch[1].rightgate = (long )(((int )val & 2) > 0);
#line 257
  gbhw_ch[2].leftgate = (long )(((int )val & 64) > 0);
#line 258
  gbhw_ch[2].rightgate = (long )(((int )val & 4) > 0);
#line 259
  gbhw_ch[3].leftgate = (long )(((int )val & 128) > 0);
#line 260
  gbhw_ch[3].rightgate = (long )(((int )val & 8) > 0);
#line 261
  goto switch_break;
  case_65318: /* CIL Label */ 
#line 263
  ioregs[38] = (uint8_t )128;
#line 264
  goto switch_break;
  case_65535: /* CIL Label */ 
  case_65343: /* CIL Label */ 
  case_65342: /* CIL Label */ 
  case_65341: /* CIL Label */ 
  case_65340: /* CIL Label */ 
  case_65339: /* CIL Label */ 
  case_65338: /* CIL Label */ 
  case_65337: /* CIL Label */ 
  case_65336: /* CIL Label */ 
  case_65335: /* CIL Label */ 
  case_65334: /* CIL Label */ 
  case_65333: /* CIL Label */ 
  case_65332: /* CIL Label */ 
  case_65331: /* CIL Label */ 
  case_65330: /* CIL Label */ 
  case_65329: /* CIL Label */ 
  case_65328: /* CIL Label */ 
  case_65327: /* CIL Label */ 
  case_65326: /* CIL Label */ 
  case_65325: /* CIL Label */ 
  case_65324: /* CIL Label */ 
  case_65323: /* CIL Label */ 
  case_65322: /* CIL Label */ 
  case_65321: /* CIL Label */ 
  case_65320: /* CIL Label */ 
  case_65319: /* CIL Label */ 
  case_65316: /* CIL Label */ 
  case_65280: /* CIL Label */ 
#line 293
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iowrite to 0x%04x unimplemented (val=%02x).\n",
          addr, (int )val);
  }
  }
#line 296
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) intram_put)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 302
  intram[addr & 8191U] = val;
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) extram_put)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 307
  extram[addr & 8191U] = val;
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound_sweep)(void) 
{ 
  long i ;
  long val ;

  {
#line 314
  if (gbhw_ch[0].sweep_tc) {
#line 315
    (gbhw_ch[0].sweep_ctr) --;
#line 316
    if (gbhw_ch[0].sweep_ctr < 0L) {
#line 317
      val = gbhw_ch[0].div_tc >> gbhw_ch[0].sweep_shift;
#line 319
      gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 320
      if (gbhw_ch[0].sweep_dir) {
#line 321
        if (gbhw_ch[0].div_tc < 2048L - val) {
#line 321
          gbhw_ch[0].div_tc += val;
        }
      } else
#line 323
      if (gbhw_ch[0].div_tc > val) {
#line 323
        gbhw_ch[0].div_tc -= val;
      }
#line 325
      gbhw_ch[0].duty_tc = (gbhw_ch[0].div_tc * gbhw_ch[0].duty_ctr) / 8L;
    }
  }
#line 328
  i = 0L;
  {
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < 4L)) {
#line 328
      goto while_break;
    }
#line 329
    if (gbhw_ch[i].len > 0L) {
#line 329
      if (gbhw_ch[i].len_enable) {
#line 330
        (gbhw_ch[i].len) --;
#line 331
        if (gbhw_ch[i].len == 0L) {
#line 332
          gbhw_ch[i].volume = 0L;
#line 333
          gbhw_ch[i].env_tc = 0L;
        }
      }
    }
#line 336
    if (gbhw_ch[i].env_tc) {
#line 337
      (gbhw_ch[i].env_ctr) --;
#line 338
      if (gbhw_ch[i].env_ctr <= 0L) {
#line 339
        gbhw_ch[i].env_ctr = gbhw_ch[i].env_tc;
#line 340
        if (! gbhw_ch[i].env_dir) {
#line 341
          if (gbhw_ch[i].volume > 0L) {
#line 342
            (gbhw_ch[i].volume) --;
          }
        } else
#line 344
        if (gbhw_ch[i].volume < 15L) {
#line 345
          (gbhw_ch[i].volume) ++;
        }
      }
    }
#line 328
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (master_fade) {
#line 351
    master_volume += master_fade;
#line 352
    if (master_fade > 0L) {
#line 352
      if (master_volume >= master_dstvol) {
#line 356
        master_fade = 0L;
#line 357
        master_volume = master_dstvol;
      } else {
#line 352
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 352
    if (master_fade < 0L) {
#line 352
      if (master_volume <= master_dstvol) {
#line 356
        master_fade = 0L;
#line 357
        master_volume = master_dstvol;
      }
    }
  }
#line 361
  return;
}
}
#line 363 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_master_fade)(long speed , long dstvol ) 
{ 


  {
#line 365
  if (dstvol < 0L) {
#line 365
    dstvol = 0L;
  }
#line 366
  if (dstvol > 65536L) {
#line 366
    dstvol = 65536L;
  }
#line 367
  master_dstvol = dstvol;
#line 368
  if (dstvol > master_volume) {
#line 369
    master_fade = speed;
  } else {
#line 370
    master_fade = - speed;
  }
#line 371
  return;
}
}
#line 378 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_flush_buffer)(void) 
{ 
  long i ;
  long overlap ;
  long l_smpl ;
  long r_smpl ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 384
  if (! ((unsigned long )soundbuf != (unsigned long )((void *)0))) {
    {
    {
#line 384
    __assert_fail("soundbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  384U, "gb_flush_buffer");
    }
    }
  }
#line 385
  if (! ((unsigned long )impbuf != (unsigned long )((void *)0))) {
    {
    {
#line 385
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  385U, "gb_flush_buffer");
    }
    }
  }
#line 388
  l_smpl = soundbuf->l_lvl;
#line 389
  r_smpl = soundbuf->r_lvl;
#line 390
  i = 0L;
  {
  {
#line 390
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < soundbuf->samples)) {
#line 390
      goto while_break;
    }
#line 391
    l_smpl += (long )*(impbuf->data + i * 2L);
#line 392
    r_smpl += (long )*(impbuf->data + (i * 2L + 1L));
#line 393
    *(soundbuf->data + i * 2L) = (int16_t )((l_smpl * master_volume) / 65536L);
#line 394
    *(soundbuf->data + (i * 2L + 1L)) = (int16_t )((r_smpl * master_volume) / 65536L);
#line 395
    if (l_smpl > lmaxval) {
#line 395
      lmaxval = l_smpl;
    }
#line 396
    if (l_smpl < lminval) {
#line 396
      lminval = l_smpl;
    }
#line 397
    if (r_smpl > rmaxval) {
#line 397
      rmaxval = r_smpl;
    }
#line 398
    if (r_smpl < rminval) {
#line 398
      rminval = r_smpl;
    }
#line 390
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  soundbuf->pos = soundbuf->samples;
#line 401
  soundbuf->l_lvl = l_smpl;
#line 402
  soundbuf->r_lvl = r_smpl;
#line 404
  if ((unsigned long )callback != (unsigned long )((void *)0)) {
    {
    {
#line 404
    (*callback)(soundbuf, callbackpriv);
    }
    }
  }
  {
#line 406
  overlap = impbuf->samples - soundbuf->samples;
  {
#line 407
  memmove((void *)impbuf->data, (void const   *)(impbuf->data + 2L * soundbuf->samples),
          (size_t )(4L * overlap));
  }
  {
#line 408
  memset((void *)(impbuf->data + 2L * overlap), 0, (size_t )(impbuf->bytes - 4L * overlap));
  }
  }
#line 409
  if (! (impbuf->bytes == impbuf->samples * 4L)) {
    {
    {
#line 409
    __assert_fail("impbuf->bytes == impbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  409U, "gb_flush_buffer");
    }
    }
  }
#line 410
  if (! (soundbuf->bytes == soundbuf->samples * 4L)) {
    {
    {
#line 410
    __assert_fail("soundbuf->bytes == soundbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  410U, "gb_flush_buffer");
    }
    }
  }
  {
  {
#line 411
  memset((void *)soundbuf->data, 0, (size_t )soundbuf->bytes);
  }
#line 412
  soundbuf->pos = 0L;
#line 414
  impbuf->cycles = (long )((long long )impbuf->cycles - (sound_div_tc * (long long )soundbuf->samples) / 65536LL);
  }
#line 415
  return;
}
}
#line 417 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_change_level)(long l_ofs , long r_ofs ) 
{ 
  long pos ;
  long imp_idx ;
  long imp_l ;
  long imp_r ;
  long i ;
  short *ptr ;
  long bufi ;
  long impi ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 421
  imp_l = (long )(- (1 << impulse_w_shift) / 2);
#line 422
  imp_r = (long )((1 << impulse_w_shift) / 2);
#line 424
  ptr = base_impulse;
#line 426
  if (! ((unsigned long )impbuf != (unsigned long )((void *)0))) {
    {
    {
#line 426
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  426U, "gb_change_level");
    }
    }
  }
#line 427
  pos = (long )(((long long )impbuf->cycles * 65536LL) / sound_div_tc);
#line 428
  imp_idx = (long )(((long long )(impbuf->cycles << impulse_n_shift) * 65536LL) / sound_div_tc) & (long )((1 << impulse_n_shift) - 1);
#line 429
  if (! (pos + imp_r < impbuf->samples)) {
    {
    {
#line 429
    __assert_fail("pos + imp_r < impbuf->samples", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  429U, "gb_change_level");
    }
    }
  }
#line 430
  if (! (pos + imp_l >= 0L)) {
    {
    {
#line 430
    __assert_fail("pos + imp_l >= 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  430U, "gb_change_level");
    }
    }
  }
#line 432
  ptr += imp_idx * (long )(1 << impulse_w_shift);
#line 434
  i = imp_l;
  {
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < imp_r)) {
#line 434
      goto while_break;
    }
#line 435
    bufi = pos + i;
#line 436
    impi = i + (long )((1 << impulse_w_shift) / 2);
#line 437
    *(impbuf->data + bufi * 2L) = (int16_t )((long )*(impbuf->data + bufi * 2L) + (long )*(ptr + impi) * l_ofs);
#line 438
    *(impbuf->data + (bufi * 2L + 1L)) = (int16_t )((long )*(impbuf->data + (bufi * 2L + 1L)) + (long )*(ptr + impi) * r_ofs);
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  impbuf->l_lvl += l_ofs * 256L;
#line 442
  impbuf->r_lvl += r_ofs * 256L;
#line 443
  return;
}
}
#line 449
static void ( __attribute__((__regparm__(3))) gb_sound)(long cycles ) ;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_l  =    0L;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_r  =    0L;
#line 511 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long val___1  ;
#line 445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound)(long cycles ) 
{ 
  long i ;
  long j ;
  long l_lvl ;
  long r_lvl ;
  long pos ;
  long tmp ;
  long val ;
  long index___0 ;
  long shift ;
  long old_l___3 ;
  long old_r___3 ;
  long l_diff ;
  long r_diff ;
  long val___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 448
  l_lvl = 0L;
#line 448
  r_lvl = 0L;
#line 451
  if (! ((unsigned long )impbuf != (unsigned long )((void *)0))) {
    {
    {
#line 451
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  451U, "gb_sound");
    }
    }
  }
#line 453
  j = 0L;
  {
  {
#line 453
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 453
    if (! (j < cycles)) {
#line 453
      goto while_break;
    }
#line 454
    main_div ++;
#line 455
    (impbuf->cycles) ++;
#line 456
    if ((long long )impbuf->cycles * 65536LL >= sound_div_tc * (long long )(impbuf->samples - (long )((1 << impulse_w_shift) / 2))) {
      {
      {
#line 457
      gb_flush_buffer();
      }
      }
    }
#line 459
    if (gbhw_ch[2].master) {
#line 460
      (gbhw_ch[2].div_ctr) --;
#line 461
      if (gbhw_ch[2].div_ctr <= 0L) {
#line 462
        tmp = ch3pos;
#line 462
        ch3pos ++;
#line 462
        pos = tmp;
#line 463
        index___0 = (pos >> 1) & 15L;
#line 463
        shift = (~ pos & 1L) << 2;
#line 463
        val = (long )(((int )*(& ioregs[48] + index___0) >> shift) & 15);
#line 464
        old_l___3 = gbhw_ch[2].l_lvl;
#line 465
        old_r___3 = gbhw_ch[2].r_lvl;
#line 467
        gbhw_ch[2].div_ctr = gbhw_ch[2].div_tc * 2L;
#line 468
        if (gbhw_ch[2].volume) {
#line 469
          val >>= gbhw_ch[2].volume - 1L;
        } else {
#line 470
          val = 0L;
        }
#line 471
        val *= 2L;
#line 472
        if (gbhw_ch[2].volume) {
#line 472
          if (! gbhw_ch[2].mute) {
#line 473
            if (gbhw_ch[2].leftgate) {
#line 474
              gbhw_ch[2].l_lvl = val;
            }
#line 475
            if (gbhw_ch[2].rightgate) {
#line 476
              gbhw_ch[2].r_lvl = val;
            }
          }
        }
        {
#line 478
        l_diff = gbhw_ch[2].l_lvl - old_l___3;
#line 479
        r_diff = gbhw_ch[2].r_lvl - old_r___3;
        {
#line 480
        gb_change_level(l_diff, r_diff);
        }
        }
      }
    }
#line 484
    if (main_div > (long )main_div_tc) {
#line 485
      main_div -= (long )main_div_tc;
#line 487
      i = 0L;
      {
      {
#line 487
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 487
        if (! (i < 2L)) {
#line 487
          goto while_break___0;
        }
#line 487
        if (gbhw_ch[i].master) {
#line 488
          val___0 = gbhw_ch[i].volume;
#line 489
          if (gbhw_ch[i].div_ctr > gbhw_ch[i].duty_tc) {
#line 490
            val___0 = - val___0;
          }
#line 492
          if (! gbhw_ch[i].mute) {
#line 493
            if (gbhw_ch[i].leftgate) {
#line 494
              gbhw_ch[i].l_lvl = val___0;
            }
#line 495
            if (gbhw_ch[i].rightgate) {
#line 496
              gbhw_ch[i].r_lvl = val___0;
            }
          }
#line 498
          (gbhw_ch[i].div_ctr) --;
#line 499
          if (gbhw_ch[i].div_ctr <= 0L) {
#line 500
            gbhw_ch[i].div_ctr = gbhw_ch[i].div_tc;
          }
        }
#line 487
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 503
      i = 0L;
      {
      {
#line 503
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 503
        if (! (i < 2L)) {
#line 503
          goto while_break___1;
        }
#line 504
        l_lvl += gbhw_ch[i].l_lvl;
#line 505
        r_lvl += gbhw_ch[i].r_lvl;
#line 503
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 508
      if (gbhw_ch[3].master) {
#line 512
        if (! gbhw_ch[3].mute) {
#line 513
          if (gbhw_ch[3].leftgate) {
#line 514
            gbhw_ch[3].l_lvl = val___1;
          }
#line 515
          if (gbhw_ch[3].rightgate) {
#line 516
            gbhw_ch[3].r_lvl = val___1;
          }
        }
#line 518
        (gbhw_ch[3].div_ctr) --;
#line 519
        if (gbhw_ch[3].div_ctr <= 0L) {
#line 520
          gbhw_ch[3].div_ctr = gbhw_ch[3].div_tc;
#line 521
          lfsr = (lfsr << 1) | (unsigned int )(((lfsr & tap1) > 0U) ^ ((lfsr & tap2) > 0U));
#line 522
          val___1 = gbhw_ch[3].volume * (long )((lfsr & 2U) - 1U);
        }
      }
#line 525
      l_lvl += gbhw_ch[3].l_lvl;
#line 526
      r_lvl += gbhw_ch[3].r_lvl;
#line 528
      if (l_lvl != old_l) {
        {
        {
#line 529
        gb_change_level(l_lvl - old_l, r_lvl - old_r);
        }
#line 530
        old_l = l_lvl;
#line 531
        old_r = r_lvl;
        }
      } else
#line 528
      if (r_lvl != old_r) {
        {
        {
#line 529
        gb_change_level(l_lvl - old_l, r_lvl - old_r);
        }
#line 530
        old_l = l_lvl;
#line 531
        old_r = r_lvl;
        }
      }
#line 534
      sweep_div ++;
#line 535
      if (sweep_div >= (long )sweep_div_tc) {
        {
#line 536
        sweep_div = 0L;
        {
#line 537
        gb_sound_sweep();
        }
        }
      }
    }
#line 453
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return;
}
}
#line 543 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_setcallback)(void ( __attribute__((__regparm__(3))) (*fn))(struct gbhw_buffer *buf ,
                                                                                                       void *priv ) ,
                                                         void *priv ) 
{ 


  {
#line 545
  callback = fn;
#line 546
  callbackpriv = priv;
#line 547
  return;
}
}
#line 549 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_setiocallback)(void ( __attribute__((__regparm__(3))) (*fn))(long cycles ,
                                                                                                         uint32_t addr ,
                                                                                                         uint8_t valu ,
                                                                                                         void *priv ) ,
                                                           void *priv ) 
{ 


  {
#line 551
  iocallback = fn;
#line 552
  iocallback_priv = priv;
#line 553
  return;
}
}
#line 555 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gbhw_impbuf_reset)(struct gbhw_buffer *impbuf___3 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 557
  if (! (sound_div_tc != 0LL)) {
    {
    {
#line 557
    __assert_fail("sound_div_tc != 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  557U, "gbhw_impbuf_reset");
    }
    }
  }
  {
#line 558
  impbuf___3->cycles = (long )(((sound_div_tc * (long long )(1 << impulse_w_shift)) / 2LL) / 65536LL);
#line 559
  impbuf___3->l_lvl = 0L;
#line 560
  impbuf___3->r_lvl = 0L;
  {
#line 561
  memset((void *)impbuf___3->data, 0, (size_t )impbuf___3->bytes);
  }
  }
#line 562
  return;
}
}
#line 564 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_setbuffer)(struct gbhw_buffer *buffer ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 566
  soundbuf = buffer;
#line 567
  soundbuf->samples = soundbuf->bytes / 4L;
#line 569
  if (impbuf) {
    {
    {
#line 569
    free((void *)impbuf);
    }
    }
  }
  {
  {
#line 570
  tmp = malloc((size_t )(sizeof(*impbuf) + (unsigned long )(((soundbuf->samples + (long )(1 << impulse_w_shift)) + 1L) * 4L)));
  }
#line 570
  impbuf = (struct gbhw_buffer *)tmp;
  }
#line 571
  if ((unsigned long )impbuf == (unsigned long )((void *)0)) {
    {
    {
#line 572
    tmp___0 = _("Memory allocation failed!\n");
    }
    {
#line 572
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            tmp___0);
    }
    }
#line 573
    return;
  }
  {
  {
#line 575
  memset((void *)impbuf, 0, (size_t )sizeof(*impbuf));
  }
#line 576
  impbuf->data = (int16_t *)((void *)(impbuf + 1));
#line 577
  impbuf->samples = (soundbuf->samples + (long )(1 << impulse_w_shift)) + 1L;
#line 578
  impbuf->bytes = impbuf->samples * 4L;
  {
#line 579
  gbhw_impbuf_reset(impbuf);
  }
  }
#line 580
  return;
}
}
#line 582 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_setrate)(long rate___1 ) 
{ 


  {
#line 584
  sound_div_tc = 274877906944LL / (long long )rate___1;
#line 585
  return;
}
}
#line 587 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_getminmax)(int16_t *lmin , int16_t *lmax ,
                                                       int16_t *rmin , int16_t *rmax ) 
{ 


  {
#line 589
  if (lminval == 2147483647L) {
#line 589
    return;
  }
#line 590
  *lmin = (int16_t )lminval;
#line 591
  *lmax = (int16_t )lmaxval;
#line 592
  *rmin = (int16_t )rminval;
#line 593
  *rmax = (int16_t )rmaxval;
#line 594
  rminval = 2147483647L;
#line 594
  lminval = rminval;
#line 595
  rmaxval = (-0x7FFFFFFF-1);
#line 595
  lmaxval = rmaxval;
#line 596
  return;
}
}
#line 604 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_init)(uint8_t *rombuf , uint32_t size ) 
{ 
  long i ;
  int mute_tmp[4] ;
  void *__cil_tmp5 ;

  {
#line 609
  i = 0L;
  {
  {
#line 609
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i < 4L)) {
#line 609
      goto while_break;
    }
#line 610
    mute_tmp[i] = (int )gbhw_ch[i].mute;
#line 609
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  if (impbuf) {
    {
    {
#line 612
    gbhw_impbuf_reset(impbuf);
    }
    }
  }
#line 613
  rom = rombuf;
#line 614
  lastbank = (long )((size + 16383U) / 16384U - 1U);
#line 615
  rombank = 1L;
#line 616
  master_volume = 65536L;
#line 617
  master_fade = 0L;
#line 618
  if (soundbuf) {
#line 619
    soundbuf->pos = 0L;
#line 620
    soundbuf->l_lvl = 0L;
#line 621
    soundbuf->r_lvl = 0L;
  }
#line 623
  rminval = 2147483647L;
#line 623
  lminval = rminval;
#line 624
  rmaxval = (-0x7FFFFFFF-1);
#line 624
  lmaxval = rmaxval;
#line 625
  i = 0L;
  {
  {
#line 625
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 625
    if (! (i < 4L)) {
#line 625
      goto while_break___0;
    }
#line 626
    gbhw_ch[i].duty_ctr = 4L;
#line 627
    gbhw_ch[i].div_tc = 1L;
#line 628
    gbhw_ch[i].master = 1L;
#line 629
    gbhw_ch[i].mute = (long )mute_tmp[i];
#line 625
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 631
  memset((void *)(extram), 0, (size_t )sizeof(extram));
  }
  {
#line 632
  memset((void *)(intram), 0, (size_t )sizeof(intram));
  }
  {
#line 633
  memset((void *)(hiram), 0, (size_t )sizeof(hiram));
  }
  {
#line 634
  memset((void *)(ioregs), 0, (size_t )sizeof(ioregs));
  }
#line 636
  sum_cycles = 0L;
  {
#line 638
  gbcpu_init();
  }
  {
#line 639
  gbcpu_addmem((uint32_t )0, (uint32_t )63, & rom_put, & rom_get);
  }
  {
#line 640
  gbcpu_addmem((uint32_t )64, (uint32_t )127, & rom_put, & rombank_get);
  }
  {
#line 641
  gbcpu_addmem((uint32_t )160, (uint32_t )191, & extram_put, & extram_get);
  }
  {
#line 642
  gbcpu_addmem((uint32_t )192, (uint32_t )254, & intram_put, & intram_get);
  }
  {
#line 643
  gbcpu_addmem((uint32_t )255, (uint32_t )255, & io_put, & io_get);
  }
  }
#line 645
  if (base_impulse) {
    {
    {
#line 646
    free((void *)base_impulse);
    }
    }
  }
  {
  {
#line 647
  base_impulse = gen_impulsetab(impulse_w_shift, impulse_n_shift, impulse_cutoff);
  }
  }
#line 648
  return;
}
}
#line 654 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
long ( __attribute__((__regparm__(3))) gbhw_step)(long time_to_work ) 
{ 
  long cycles_total ;
  long maxcycles ;
  long cycles ;
  long step ;
  long tmp ;

  {
#line 656
  cycles_total = 0L;
#line 658
  if (pause_output) {
    {
    {
#line 659
    usleep((__useconds_t )(time_to_work * 1000L));
    }
    }
#line 660
    return (0L);
  }
#line 663
  time_to_work *= (long )msec_cycles;
  {
  {
#line 665
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 665
    if (! (cycles_total < time_to_work)) {
#line 665
      goto while_break;
    }
#line 666
    maxcycles = time_to_work - cycles_total;
#line 667
    cycles = 0L;
#line 669
    if (vblankctr > 0L) {
#line 669
      if (vblankctr < maxcycles) {
#line 669
        maxcycles = vblankctr;
      }
    }
#line 670
    if (timerctr > 0L) {
#line 670
      if (timerctr < maxcycles) {
#line 670
        maxcycles = timerctr;
      }
    }
    {
    {
#line 672
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 672
      if (! (cycles < maxcycles)) {
#line 672
        goto while_break___0;
      }
      {
      {
#line 673
      tmp = gbcpu_step();
      }
#line 673
      step = tmp;
      }
#line 674
      if (step < 0L) {
#line 674
        return (step);
      }
      {
#line 675
      cycles += step;
#line 676
      sum_cycles += step;
      {
#line 677
      gb_sound(step);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 680
    if (vblankctr > 0L) {
#line 680
      vblankctr -= cycles;
    }
#line 681
    if (vblankctr <= 0L) {
#line 681
      if (gbcpu_if) {
#line 681
        if ((int )ioregs[127] & 1) {
          {
#line 682
          vblankctr += (long )vblanktc;
          {
#line 683
          gbcpu_intr(64L);
          }
          }
        }
      }
    }
#line 685
    if (timerctr > 0L) {
#line 685
      timerctr -= cycles;
    }
#line 686
    if (timerctr <= 0L) {
#line 686
      if (gbcpu_if) {
#line 686
        if ((int )ioregs[127] & 4) {
          {
#line 687
          timerctr += timertc;
          {
#line 688
          gbcpu_intr(72L);
          }
          }
        }
      }
    }
#line 690
    cycles_total += cycles;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  return (cycles_total);
}
}
#line 696 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
void ( __attribute__((__regparm__(3))) gbhw_pause)(long new_pause ) 
{ 


  {
#line 698
  pause_output = (long )(new_pause != 0L);
#line 699
  return;
}
}
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) none_get___0)(uint32_t addr ) 
{ 


  {
#line 45
  return ((uint32_t )255);
}
}
#line 48 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) none_put___0)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_get_fn getlookup___0[256]  = 
#line 52
  {      & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0, 
        & none_get___0,      & none_get___0,      & none_get___0,      & none_get___0};
#line 311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_put_fn putlookup___0[256]  = 
#line 311
  {      & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0, 
        & none_put___0,      & none_put___0,      & none_put___0,      & none_put___0};
#line 570 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static uint32_t ( __attribute__((__regparm__(3))) mem_get___0)(uint32_t addr ) 
{ 
  uint32_t ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr ) ;
  uint32_t tmp ;

  {
  {
#line 572
  fn = getlookup___0[addr >> 8];
  {
#line 573
  tmp = (*fn)(addr);
  }
  }
#line 573
  return (tmp);
}
}
#line 576 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static void ( __attribute__((__regparm__(3))) mem_put___0)(uint32_t addr ,
                                                                    uint32_t val ) 
{ 
  void ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr , uint8_t val ) ;

  {
  {
#line 578
  fn = putlookup___0[addr >> 8];
  {
#line 579
  (*fn)(addr, (uint8_t )val);
  }
  }
#line 580
  return;
}
}
#line 582 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) push___0)(uint32_t val ) 
{ 
  uint32_t sp ;

  {
  {
#line 584
  sp = (uint32_t )((int )*((uint16_t *)(& gbcpu_regs.ri[8])) - 2);
#line 585
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )sp;
  {
#line 586
  mem_put___0(sp, val & 255U);
  }
  {
#line 587
  mem_put___0(sp + 1U, val >> 8);
  }
  }
#line 588
  return;
}
}
#line 590 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) pop___0)(void) 
{ 
  uint32_t res ;
  uint32_t sp ;
  uint32_t tmp ;

  {
  {
#line 593
  sp = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[8]));
  {
#line 595
  res = mem_get___0(sp);
  }
  {
#line 596
  tmp = mem_get___0(sp + 1U);
  }
#line 596
  res += tmp << 8;
#line 597
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )(sp + 2U);
  }
#line 599
  return (res);
}
}
#line 602 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm8___0)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;

  {
  {
#line 604
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 606
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 1U);
  {
#line 607
  res = mem_get___0(pc);
  }
  }
  {
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 608
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  return (res);
}
}
#line 612 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm16___0)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 614
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 616
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 2U);
  {
#line 617
  tmp = mem_get___0(pc);
  }
  {
#line 617
  tmp___0 = mem_get___0(pc + 1U);
  }
#line 617
  res = tmp + (tmp___0 << 8);
  }
  {
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 618
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (res);
}
}
#line 628 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_reg___0)(long i ) 
{ 
  uint32_t tmp ;

  {
#line 630
  if (i == 6L) {
    {
    {
#line 631
    tmp = mem_get___0((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])));
    }
    }
#line 631
    return (tmp);
  }
#line 632
  return ((uint32_t )gbcpu_regs.ri[i ^ 1L]);
}
}
#line 635 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) put_reg___0)(long i , uint32_t val ) 
{ 


  {
#line 637
  if (i == 6L) {
    {
    {
#line 638
    mem_put___0((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])), val);
    }
    }
  } else {
#line 639
    gbcpu_regs.ri[i ^ 1L] = (uint8_t )val;
  }
#line 640
  return;
}
}
#line 642 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_unknown___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 644
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown opcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 645
  gbcpu_stopped = 1L;
  }
#line 646
  return;
}
}
#line 648 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_set___0)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 650
  reg = (long )(op & 7U);
#line 651
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 653
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 654
  print_reg(reg);
  }
  {
#line 655
  tmp = get_reg___0(reg);
  }
  {
#line 655
  put_reg___0(reg, tmp | (unsigned int )(1 << bit));
  }
  }
#line 656
  return;
}
}
#line 658 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_res___0)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 660
  reg = (long )(op & 7U);
#line 661
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 663
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 664
  print_reg(reg);
  }
  {
#line 665
  tmp = get_reg___0(reg);
  }
  {
#line 665
  put_reg___0(reg, tmp & (unsigned int )(~ (1 << bit)));
  }
  }
#line 666
  return;
}
}
#line 668 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_bit___0)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 670
  reg = (long )(op & 7U);
#line 671
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 673
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 674
  print_reg(reg);
  }
#line 675
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 676
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 160);
  {
#line 677
  tmp = get_reg___0(reg);
  }
#line 677
  gbcpu_regs.rn.f = (uint8_t )((unsigned int )gbcpu_regs.rn.f ^ (((tmp << 8) >> (bit + 1UL)) & 128U));
  }
#line 678
  return;
}
}
#line 680 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rl___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 682
  reg = (long )(op & 7U);
  {
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 685
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 686
  print_reg(reg);
  }
  {
#line 687
  tmp = get_reg___0(reg);
  }
#line 687
  val = (uint8_t )tmp;
#line 687
  res = val;
#line 688
  res = (uint8_t )((int )res << 1);
#line 689
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 690
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 691
  if ((int )res == 0) {
#line 691
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 692
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 693
  return;
}
}
#line 695 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rla___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 699
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 699
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  res = gbcpu_regs.rn.a;
#line 701
  res = (uint8_t )((int )res << 1);
#line 702
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 703
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 704
  if ((int )res == 0) {
#line 704
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 705
  gbcpu_regs.rn.a = res;
#line 706
  return;
}
}
#line 708 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlc___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 710
  reg = (long )(op & 7U);
  {
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 713
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 714
  print_reg(reg);
  }
  {
#line 715
  tmp = get_reg___0(reg);
  }
#line 715
  val = (uint8_t )tmp;
#line 715
  res = val;
#line 716
  res = (uint8_t )((int )res << 1);
#line 717
  res = (uint8_t )((int )res | ((int )val >> 7));
#line 718
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 719
  if ((int )res == 0) {
#line 719
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 720
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 721
  return;
}
}
#line 723 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlca___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 727
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 727
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  res = gbcpu_regs.rn.a;
#line 729
  res = (uint8_t )((int )res << 1);
#line 730
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a >> 7));
#line 731
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 732
  if ((int )res == 0) {
#line 732
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 733
  gbcpu_regs.rn.a = res;
#line 734
  return;
}
}
#line 736 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sla___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 738
  reg = (long )(op & 7U);
  {
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 741
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 742
  print_reg(reg);
  }
  {
#line 743
  tmp = get_reg___0(reg);
  }
#line 743
  val = (uint8_t )tmp;
#line 743
  res = val;
#line 744
  res = (uint8_t )((int )res << 1);
#line 745
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 746
  if ((int )res == 0) {
#line 746
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 747
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 748
  return;
}
}
#line 750 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rr___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 752
  reg = (long )(op & 7U);
  {
  {
#line 755
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 755
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 756
  print_reg(reg);
  }
  {
#line 757
  tmp = get_reg___0(reg);
  }
#line 757
  val = (uint8_t )tmp;
#line 757
  res = val;
#line 758
  res = (uint8_t )((int )res >> 1);
#line 759
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 760
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 761
  if ((int )res == 0) {
#line 761
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 762
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 763
  return;
}
}
#line 765 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rra___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 769
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 769
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  res = gbcpu_regs.rn.a;
#line 771
  res = (uint8_t )((int )res >> 1);
#line 772
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 773
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 774
  if ((int )res == 0) {
#line 774
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 775
  gbcpu_regs.rn.a = res;
#line 776
  return;
}
}
#line 778 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrc___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 780
  reg = (long )(op & 7U);
  {
  {
#line 783
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 783
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 784
  print_reg(reg);
  }
  {
#line 785
  tmp = get_reg___0(reg);
  }
#line 785
  val = (uint8_t )tmp;
#line 785
  res = val;
#line 786
  res = (uint8_t )((int )res >> 1);
#line 787
  res = (uint8_t )((int )res | ((int )val << 7));
#line 788
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 789
  if ((int )res == 0) {
#line 789
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 790
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 791
  return;
}
}
#line 793 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrca___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  res = gbcpu_regs.rn.a;
#line 799
  res = (uint8_t )((int )res >> 1);
#line 800
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a << 7));
#line 801
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 802
  if ((int )res == 0) {
#line 802
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 803
  gbcpu_regs.rn.a = res;
#line 804
  return;
}
}
#line 806 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sra___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 808
  reg = (long )(op & 7U);
  {
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 811
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 812
  print_reg(reg);
  }
  {
#line 813
  tmp = get_reg___0(reg);
  }
#line 813
  val = (uint8_t )tmp;
#line 813
  res = val;
#line 814
  res = (uint8_t )((int )res >> 1);
#line 815
  res = (uint8_t )((int )res | ((int )val & 128));
#line 816
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 817
  if ((int )res == 0) {
#line 817
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 818
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 819
  return;
}
}
#line 821 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_srl___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 823
  reg = (long )(op & 7U);
  {
  {
#line 826
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 826
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 827
  print_reg(reg);
  }
  {
#line 828
  tmp = get_reg___0(reg);
  }
#line 828
  val = (uint8_t )tmp;
#line 828
  res = val;
#line 829
  res = (uint8_t )((int )res >> 1);
#line 830
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 831
  if ((int )res == 0) {
#line 831
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 832
  put_reg___0(reg, (uint32_t )res);
  }
  }
#line 833
  return;
}
}
#line 835 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_swap___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t res ;
  uint32_t val ;

  {
#line 837
  reg = (long )(op & 7U);
  {
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 841
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 842
  print_reg(reg);
  }
  {
#line 843
  val = get_reg___0(reg);
  }
#line 844
  res = (val >> 4) | (val << 4);
#line 846
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 847
  if (res == 0U) {
#line 847
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 848
  put_reg___0(reg, res);
  }
  }
#line 849
  return;
}
}
#line 851 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  cbops___0[8]  = 
#line 851
  {      {& op_rlc___0}, 
        {& op_rrc___0}, 
        {& op_rl___0}, 
        {& op_rr___0}, 
        {& op_sla___0}, 
        {& op_sra___0}, 
        {& op_swap___0}, 
        {& op_srl___0}};
#line 862 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cbprefix___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t pc ;
  char *__cil_tmp4 ;

  {
  {
#line 864
  pc = *((uint16_t *)(& gbcpu_regs.ri[10]));
#line 866
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )pc + 1);
  {
#line 867
  op = mem_get___0((uint32_t )pc);
  }
  }
  {
#line 869
  if (op >> 6 == 0U) {
#line 869
    goto case_0;
  }
#line 871
  if (op >> 6 == 1U) {
#line 871
    goto case_1;
  }
#line 872
  if (op >> 6 == 2U) {
#line 872
    goto case_2;
  }
#line 873
  if (op >> 6 == 3U) {
#line 873
    goto case_3;
  }
#line 868
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 869
  (*(cbops___0[(op >> 3) & 7U].fn))(op, & cbops___0[(op >> 3) & 7U]);
  }
  }
#line 870
  return;
  case_1: /* CIL Label */ 
  {
  {
#line 871
  op_bit___0(op);
  }
  }
#line 871
  return;
  case_2: /* CIL Label */ 
  {
  {
#line 872
  op_res___0(op);
  }
  }
#line 872
  return;
  case_3: /* CIL Label */ 
  {
  {
#line 873
  op_set___0(op);
  }
  }
#line 873
  return;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 875
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown CB subopcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 876
  gbcpu_stopped = 1L;
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long src ;
  long dst ;
  uint32_t tmp ;

  {
#line 881
  src = (long )(op & 7U);
#line 882
  dst = (long )((op >> 3) & 7U);
  {
  {
#line 884
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 884
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 885
  print_reg(dst);
  }
  }
  {
  {
#line 886
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 886
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 887
  print_reg(src);
  }
  {
#line 888
  tmp = get_reg___0(src);
  }
  {
#line 888
  put_reg___0(dst, tmp);
  }
  }
#line 889
  return;
}
}
#line 891 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 893
  tmp = get_imm16___0();
  }
#line 893
  ofs = (long )tmp;
  }
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 896
  tmp___0 = mem_get___0((uint32_t )ofs);
  }
#line 896
  gbcpu_regs.rn.a = (uint8_t )tmp___0;
  }
#line 897
  return;
}
}
#line 899 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_a___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 901
  tmp = get_imm16___0();
  }
#line 901
  ofs = (long )tmp;
  }
  {
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 903
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 904
  mem_put___0((uint32_t )ofs, (uint32_t )gbcpu_regs.rn.a);
  }
  }
#line 905
  return;
}
}
#line 907 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_sp___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  long sp ;

  {
  {
  {
#line 909
  tmp = get_imm16___0();
  }
#line 909
  ofs = (long )tmp;
#line 910
  sp = (long )*((uint16_t *)(& gbcpu_regs.ri[8]));
  }
  {
  {
#line 912
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 912
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 913
  mem_put___0((uint32_t )ofs, (uint32_t )(sp & 255L));
  }
  {
#line 914
  mem_put___0((uint32_t )(ofs + 1L), (uint32_t )(sp >> 8));
  }
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_hlsp___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t ofs ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 919
  tmp = get_imm8___0();
  }
#line 919
  ofs = (int8_t )tmp;
#line 920
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 921
  new = (uint16_t )((int )old + (int )ofs);
  }
#line 923
  if ((int )ofs > 0) {
    {
    {
#line 923
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 923
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 924
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 924
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 925
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 926
  gbcpu_regs.rn.f = (uint8_t )0;
#line 927
  if ((int )old > (int )new) {
#line 927
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 928
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 928
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 929
  return;
}
}
#line 931 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_sphl___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 933
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 933
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  *((uint16_t *)(& gbcpu_regs.ri[8])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 935
  return;
}
}
#line 937 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 939
  tmp = get_imm16___0();
  }
#line 939
  val = (long )tmp;
#line 940
  reg = (long )((op >> 4) & 3U);
#line 942
  reg += (long )(reg > 2L);
  }
  {
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 943
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )val;
#line 945
  return;
}
}
#line 947 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_a___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t r ;
  uint32_t tmp ;

  {
#line 949
  reg = (long )((op >> 4) & 3U);
#line 952
  reg -= (long )(reg > 2L);
#line 953
  if (op & 8U) {
    {
    {
#line 954
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 954
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 955
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 955
    tmp = mem_get___0((uint32_t )r);
    }
#line 955
    gbcpu_regs.rn.a = (uint8_t )tmp;
    }
  } else {
    {
    {
#line 957
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 957
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 958
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 958
    mem_put___0((uint32_t )r, (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 961
  if (reg == 2L) {
#line 962
    r = (uint16_t )((int )r + ((((op & 16U) == 0U) << 1) - 1));
#line 963
    *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = r;
  }
#line 965
  return;
}
}
#line 967 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg8_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 969
  tmp = get_imm8___0();
  }
#line 969
  val = (long )tmp;
#line 970
  reg = (long )((op >> 3) & 7U);
  }
  {
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 972
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 973
  print_reg(reg);
  }
  {
#line 974
  put_reg___0(reg, (uint32_t )val);
  }
  }
  {
  {
#line 975
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 975
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 976
  return;
}
}
#line 978 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ldh___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 980
  if (op & 2U) {
#line 980
    tmp___0 = (uint32_t )0;
  } else {
    {
    {
#line 980
    tmp = get_imm8___0();
    }
#line 980
    tmp___0 = tmp;
    }
  }
#line 980
  ofs = (long )tmp___0;
#line 982
  if (op & 16U) {
    {
    {
#line 983
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 983
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 984
    if ((op & 2U) == 0U) {
      {
      {
#line 985
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 985
        goto while_break___0;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 987
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 988
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 988
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 990
    tmp___1 = mem_get___0((uint32_t )(65280L + ofs));
    }
#line 990
    gbcpu_regs.rn.a = (uint8_t )tmp___1;
    }
  } else {
#line 992
    if ((op & 2U) == 0U) {
      {
      {
#line 993
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 993
        goto while_break___2;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 995
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 996
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 996
        goto while_break___3;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    {
#line 998
    mem_put___0((uint32_t )(65280L + ofs), (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 1000
  return;
}
}
#line 1002 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1004
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1008
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1008
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1009
  print_reg(reg);
  }
  {
#line 1010
  tmp = get_reg___0(reg);
  }
#line 1010
  res = (uint8_t )tmp;
#line 1010
  old = res;
#line 1011
  res = (uint8_t )((int )res + 1);
  {
#line 1012
  put_reg___0(reg, (uint32_t )res);
  }
#line 1013
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -225);
  }
#line 1014
  if ((int )res == 0) {
#line 1014
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1015
  if (((int )old & 15) > ((int )res & 15)) {
#line 1015
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1016
  return;
}
}
#line 1018 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc16___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1020
  reg = (long )((op >> 4) & 3U);
#line 1021
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1023
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1023
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  res = (uint16_t )((int )res + 1);
#line 1025
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1026
  return;
}
}
#line 1028 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1030
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1034
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1034
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1035
  print_reg(reg);
  }
  {
#line 1036
  tmp = get_reg___0(reg);
  }
#line 1036
  res = (uint8_t )tmp;
#line 1036
  old = res;
#line 1037
  res = (uint8_t )((int )res - 1);
  {
#line 1038
  put_reg___0(reg, (uint32_t )res);
  }
#line 1039
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 64);
#line 1040
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -161);
  }
#line 1041
  if ((int )res == 0) {
#line 1041
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1042
  if (((int )old & 15) > ((int )res & 15)) {
#line 1042
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1043
  return;
}
}
#line 1045 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec16___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1047
  reg = (long )((op >> 4) & 3U);
#line 1048
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1050
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1050
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1051
  res = (uint16_t )((int )res - 1);
#line 1052
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1053
  return;
}
}
#line 1055 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_sp_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t imm ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 1057
  tmp = get_imm8___0();
  }
#line 1057
  imm = (int8_t )tmp;
#line 1058
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 1059
  new = old;
  }
  {
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1061
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  new = (uint16_t )((int )new + (int )imm);
#line 1063
  *((uint16_t *)(& gbcpu_regs.ri[8])) = new;
#line 1064
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1065
  if ((int )old > (int )new) {
#line 1065
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1066
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1066
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1067
  return;
}
}
#line 1069 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1071
  old = gbcpu_regs.rn.a;
  {
  {
#line 1074
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1074
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1075
  print_reg((long )(op & 7U));
  }
  {
#line 1076
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1076
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1077
  new = gbcpu_regs.rn.a;
#line 1078
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1079
  if ((int )old > (int )new) {
#line 1079
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1080
  if (((int )old & 15) > ((int )new & 15)) {
#line 1080
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1081
  if ((int )new == 0) {
#line 1081
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1082
  return;
}
}
#line 1084 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1086
  tmp = get_imm8___0();
  }
#line 1086
  imm = (uint8_t )tmp;
#line 1087
  old = gbcpu_regs.rn.a;
#line 1088
  new = old;
  }
  {
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1090
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1091
  new = (uint8_t )((int )new + (int )imm);
#line 1092
  gbcpu_regs.rn.a = new;
#line 1093
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1094
  if ((int )old > (int )new) {
#line 1094
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1095
  if (((int )old & 15) > ((int )new & 15)) {
#line 1095
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1096
  if ((int )new == 0) {
#line 1096
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1097
  return;
}
}
#line 1099 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_hl___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t old ;
  uint16_t new ;

  {
#line 1101
  reg = (long )((op >> 4) & 3U);
#line 1102
  old = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1103
  new = old;
#line 1105
  reg += (long )(reg > 2L);
  {
  {
#line 1106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1106
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  new = (uint16_t )((int )new + (int )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
#line 1109
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 1111
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -113);
#line 1112
  if ((int )old > (int )new) {
#line 1112
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1113
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1113
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1114
  return;
}
}
#line 1116 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1118
  old = gbcpu_regs.rn.a;
  {
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1121
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1122
  print_reg((long )(op & 7U));
  }
  {
#line 1123
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1123
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1124
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1125
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1126
  new = gbcpu_regs.rn.a;
  }
#line 1127
  if ((int )old > (int )new) {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1128
  if (((int )old & 15) > ((int )new & 15)) {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1129
  if ((int )new == 0) {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1130
  return;
}
}
#line 1132 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1134
  tmp = get_imm8___0();
  }
#line 1134
  imm = (uint8_t )tmp;
#line 1135
  old = gbcpu_regs.rn.a;
#line 1136
  new = old;
  }
  {
  {
#line 1138
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1138
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  new = (uint8_t )((int )new + (int )imm);
#line 1140
  new = (uint8_t )((int )new + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1141
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1142
  gbcpu_regs.rn.a = new;
#line 1143
  if ((int )old > (int )new) {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1144
  if (((int )old & 15) > ((int )new & 15)) {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1145
  if ((int )new == 0) {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1150
  old = gbcpu_regs.rn.a;
#line 1151
  new = old;
  {
  {
#line 1153
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1153
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1154
  print_reg((long )(op & 7U));
  }
  {
#line 1155
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1155
  new = (uint8_t )((uint32_t )new - tmp);
#line 1156
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1157
  if ((int )old < (int )new) {
#line 1157
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1158
  if (((int )old & 15) < ((int )new & 15)) {
#line 1158
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1159
  if ((int )new == 0) {
#line 1159
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1160
  return;
}
}
#line 1162 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1164
  tmp = get_imm8___0();
  }
#line 1164
  imm = (uint8_t )tmp;
#line 1165
  old = gbcpu_regs.rn.a;
#line 1166
  new = old;
  }
  {
  {
#line 1168
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1168
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  new = (uint8_t )((int )new - (int )imm);
#line 1170
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1171
  if ((int )old < (int )new) {
#line 1171
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1172
  if (((int )old & 15) < ((int )new & 15)) {
#line 1172
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1173
  if ((int )new == 0) {
#line 1173
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1174
  return;
}
}
#line 1176 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1178
  old = gbcpu_regs.rn.a;
  {
  {
#line 1181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1181
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1182
  print_reg((long )(op & 7U));
  }
  {
#line 1183
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1183
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1184
  new = gbcpu_regs.rn.a;
#line 1185
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1186
  if ((int )old < (int )new) {
#line 1186
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1187
  if (((int )old & 15) < ((int )new & 15)) {
#line 1187
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1188
  if ((int )new == 0) {
#line 1188
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1189
  return;
}
}
#line 1191 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1193
  tmp = get_imm8___0();
  }
#line 1193
  imm = (uint8_t )tmp;
#line 1194
  old = gbcpu_regs.rn.a;
#line 1195
  new = old;
  }
  {
  {
#line 1197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1197
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  new = (uint8_t )((int )new - (int )imm);
#line 1199
  gbcpu_regs.rn.a = new;
#line 1200
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1201
  if ((int )old < (int )new) {
#line 1201
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1202
  if (((int )old & 15) < ((int )new & 15)) {
#line 1202
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1203
  if ((int )new == 0) {
#line 1203
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1204
  return;
}
}
#line 1206 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1208
  old = gbcpu_regs.rn.a;
  {
  {
#line 1211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1211
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1212
  print_reg((long )(op & 7U));
  }
  {
#line 1213
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1213
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1214
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1215
  new = gbcpu_regs.rn.a;
#line 1216
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1217
  if ((int )old < (int )new) {
#line 1217
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1218
  if (((int )old & 15) < ((int )new & 15)) {
#line 1218
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1219
  if ((int )new == 0) {
#line 1219
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1220
  return;
}
}
#line 1222 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1224
  tmp = get_imm8___0();
  }
#line 1224
  imm = (uint8_t )tmp;
#line 1225
  old = gbcpu_regs.rn.a;
#line 1226
  new = old;
  }
  {
  {
#line 1228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1228
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  new = (uint8_t )((int )new - (int )imm);
#line 1230
  new = (uint8_t )((int )new - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1231
  gbcpu_regs.rn.a = new;
#line 1232
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1233
  if ((int )old < (int )new) {
#line 1233
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1234
  if (((int )old & 15) < ((int )new & 15)) {
#line 1234
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1235
  if ((int )new == 0) {
#line 1235
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1236
  return;
}
}
#line 1238 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1240
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1241
  print_reg((long )(op & 7U));
  }
  {
#line 1242
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1242
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a & tmp);
#line 1243
  gbcpu_regs.rn.f = (uint8_t )32;
  }
#line 1244
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1244
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1245
  return;
}
}
#line 1247 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1249
  tmp = get_imm8___0();
  }
#line 1249
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1251
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1252
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a & (int )imm);
#line 1253
  gbcpu_regs.rn.f = (uint8_t )32;
#line 1254
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1254
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1255
  return;
}
}
#line 1257 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1259
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1260
  print_reg((long )(op & 7U));
  }
  {
#line 1261
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1261
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a | tmp);
#line 1262
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1263
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1263
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1264
  return;
}
}
#line 1266 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1268
  tmp = get_imm8___0();
  }
#line 1268
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1270
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a | (int )imm);
#line 1272
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1273
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1273
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1274
  return;
}
}
#line 1276 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1278
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1279
  print_reg((long )(op & 7U));
  }
  {
#line 1280
  tmp = get_reg___0((long )(op & 7U));
  }
#line 1280
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a ^ tmp);
#line 1281
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1282
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1282
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1283
  return;
}
}
#line 1285 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor_imm___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1287
  tmp = get_imm8___0();
  }
#line 1287
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1289
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1289
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a ^ (int )imm);
#line 1291
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1292
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1292
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1293
  return;
}
}
#line 1295 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_push___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;

  {
  {
#line 1297
  reg = (long )((op >> 4) & 3U);
  {
#line 1299
  push___0((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
  }
  }
  {
  {
#line 1300
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1300
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1301
  return;
}
}
#line 1303 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_pop___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t tmp ;

  {
  {
#line 1305
  reg = (long )((op >> 4) & 3U);
  {
#line 1307
  tmp = pop___0();
  }
#line 1307
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )tmp;
  }
  {
  {
#line 1308
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1308
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 1311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cpl___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1313
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1313
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1314
  gbcpu_regs.rn.a = (uint8_t )(~ ((int )gbcpu_regs.rn.a));
#line 1315
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 96);
#line 1316
  return;
}
}
#line 1318 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ccf___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1320
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f ^ 16);
#line 1322
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1323
  return;
}
}
#line 1325 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_scf___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1327
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1327
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1328
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
#line 1329
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1330
  return;
}
}
#line 1332 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1334
  tmp = get_imm16___0();
  }
#line 1334
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1336
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1337
  push___0((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1338
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1339
  return;
}
}
#line 1341 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call_cond___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1343
  tmp = get_imm16___0();
  }
#line 1343
  ofs = (uint16_t )tmp;
#line 1344
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1346
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1346
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1348
  if (cond == 0L) {
#line 1348
    goto case_0;
  }
#line 1349
  if (cond == 1L) {
#line 1349
    goto case_1;
  }
#line 1350
  if (cond == 2L) {
#line 1350
    goto case_2;
  }
#line 1351
  if (cond == 3L) {
#line 1351
    goto case_3;
  }
#line 1347
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1348
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1348
    return;
  }
#line 1348
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1349
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1349
    return;
  }
#line 1349
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1350
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1350
    return;
  }
#line 1350
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1351
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1351
    return;
  }
#line 1351
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1353
  push___0((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1354
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1355
  return;
}
}
#line 1357 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1359
  tmp = pop___0();
  }
#line 1359
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1360
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1361
  return;
}
}
#line 1363 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_reti___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1365
  tmp = pop___0();
  }
#line 1365
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1366
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1367
  return;
}
}
#line 1369 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret_cond___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long cond ;
  uint32_t tmp ;

  {
#line 1371
  cond = (long )((op >> 3) & 3U);
  {
  {
#line 1373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1373
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1375
  if (cond == 0L) {
#line 1375
    goto case_0;
  }
#line 1376
  if (cond == 1L) {
#line 1376
    goto case_1;
  }
#line 1377
  if (cond == 2L) {
#line 1377
    goto case_2;
  }
#line 1378
  if (cond == 3L) {
#line 1378
    goto case_3;
  }
#line 1374
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1375
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1375
    return;
  }
#line 1375
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1376
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1376
    return;
  }
#line 1376
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1377
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1377
    return;
  }
#line 1377
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1378
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1378
    return;
  }
#line 1378
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1380
  tmp = pop___0();
  }
#line 1380
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
#line 1381
  return;
}
}
#line 1383 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_halt___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1385
  gbcpu_halted = 1L;
  {
  {
#line 1386
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1386
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  return;
}
}
#line 1389 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_stop___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1391
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1391
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  return;
}
}
#line 1394 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_di___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1396
  gbcpu_if = 0L;
  {
  {
#line 1397
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1397
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return;
}
}
#line 1400 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ei___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1402
  gbcpu_if = 1L;
  {
  {
#line 1403
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1403
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1408
  tmp = get_imm8___0();
  }
#line 1408
  ofs = (int16_t )((int8_t )tmp);
  }
#line 1410
  if ((int )ofs < 0) {
    {
    {
#line 1410
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1410
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1411
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1411
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1412
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1413
  return;
}
}
#line 1415 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr_cond___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1417
  tmp = get_imm8___0();
  }
#line 1417
  ofs = (int16_t )((int8_t )tmp);
#line 1418
  cond = (long )((op >> 3) & 3U);
  }
#line 1420
  if ((int )ofs < 0) {
    {
    {
#line 1420
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1420
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1421
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1421
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1423
  if (cond == 0L) {
#line 1423
    goto case_0;
  }
#line 1424
  if (cond == 1L) {
#line 1424
    goto case_1;
  }
#line 1425
  if (cond == 2L) {
#line 1425
    goto case_2;
  }
#line 1426
  if (cond == 3L) {
#line 1426
    goto case_3;
  }
#line 1422
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1423
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1423
    return;
  }
#line 1423
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1424
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1424
    return;
  }
#line 1424
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1425
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1425
    return;
  }
#line 1425
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1426
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1426
    return;
  }
#line 1426
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1428
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1429
  return;
}
}
#line 1431 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1433
  tmp = get_imm16___0();
  }
#line 1433
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1435
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1435
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1437
  return;
}
}
#line 1439 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_hl___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1441
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1441
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  *((uint16_t *)(& gbcpu_regs.ri[10])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1443
  return;
}
}
#line 1445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_cond___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1447
  tmp = get_imm16___0();
  }
#line 1447
  ofs = (uint16_t )tmp;
#line 1448
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1450
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1450
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1452
  if (cond == 0L) {
#line 1452
    goto case_0;
  }
#line 1453
  if (cond == 1L) {
#line 1453
    goto case_1;
  }
#line 1454
  if (cond == 2L) {
#line 1454
    goto case_2;
  }
#line 1455
  if (cond == 3L) {
#line 1455
    goto case_3;
  }
#line 1451
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1452
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1452
    return;
  }
#line 1452
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1453
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1453
    return;
  }
#line 1453
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1454
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1454
    return;
  }
#line 1454
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1455
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1455
    return;
  }
#line 1455
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1457
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1458
  return;
}
}
#line 1460 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rst___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;

  {
#line 1462
  ofs = (int16_t )(op & 56U);
  {
  {
#line 1464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1464
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1465
  push___0((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1466
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )ofs;
  }
#line 1467
  return;
}
}
#line 1469 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_nop___0)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1471
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1471
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  return;
}
}
#line 1474 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  ops___0[256]  = 
#line 1474
  {      {& op_nop___0}, 
        {& op_ld_reg16_imm___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_inc16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_rlca___0}, 
        {& op_ld_ind16_sp___0}, 
        {& op_add_hl___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_dec16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_rrca___0}, 
        {& op_stop___0}, 
        {& op_ld_reg16_imm___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_inc16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_rla___0}, 
        {& op_jr___0}, 
        {& op_add_hl___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_dec16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_rra___0}, 
        {& op_jr_cond___0}, 
        {& op_ld_reg16_imm___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_inc16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_unknown___0}, 
        {& op_jr_cond___0}, 
        {& op_add_hl___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_dec16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_cpl___0}, 
        {& op_jr_cond___0}, 
        {& op_ld_reg16_imm___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_inc16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_scf___0}, 
        {& op_jr_cond___0}, 
        {& op_add_hl___0}, 
        {& op_ld_reg16_a___0}, 
        {& op_dec16___0}, 
        {& op_inc___0}, 
        {& op_dec___0}, 
        {& op_ld_reg8_imm___0}, 
        {& op_ccf___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_halt___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_ld___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_add___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_adc___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sub___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_sbc___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_and___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_xor___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_or___0}, 
        {& op_cp___0}, 
        {& op_cp___0}, 
        {& op_cp___0}, 
        {& op_cp___0}, 
        {& op_cp___0}, 
        {& op_cp___0}, 
        {& op_cp___0}, 
        {& op_unknown___0}, 
        {& op_ret_cond___0}, 
        {& op_pop___0}, 
        {& op_jp_cond___0}, 
        {& op_jp___0}, 
        {& op_call_cond___0}, 
        {& op_push___0}, 
        {& op_add_imm___0}, 
        {& op_rst___0}, 
        {& op_ret_cond___0}, 
        {& op_ret___0}, 
        {& op_jp_cond___0}, 
        {& op_cbprefix___0}, 
        {& op_call_cond___0}, 
        {& op_call___0}, 
        {& op_adc_imm___0}, 
        {& op_rst___0}, 
        {& op_ret_cond___0}, 
        {& op_pop___0}, 
        {& op_jp_cond___0}, 
        {& op_unknown___0}, 
        {& op_call_cond___0}, 
        {& op_push___0}, 
        {& op_sub_imm___0}, 
        {& op_rst___0}, 
        {& op_ret_cond___0}, 
        {& op_reti___0}, 
        {& op_jp_cond___0}, 
        {& op_unknown___0}, 
        {& op_call_cond___0}, 
        {& op_unknown___0}, 
        {& op_sbc_imm___0}, 
        {& op_rst___0}, 
        {& op_ldh___0}, 
        {& op_pop___0}, 
        {& op_ldh___0}, 
        {& op_unknown___0}, 
        {& op_unknown___0}, 
        {& op_push___0}, 
        {& op_and_imm___0}, 
        {& op_rst___0}, 
        {& op_add_sp_imm___0}, 
        {& op_jp_hl___0}, 
        {& op_ld_ind16_a___0}, 
        {& op_unknown___0}, 
        {& op_unknown___0}, 
        {& op_unknown___0}, 
        {& op_xor_imm___0}, 
        {& op_rst___0}, 
        {& op_ldh___0}, 
        {& op_pop___0}, 
        {& op_ldh___0}, 
        {& op_di___0}, 
        {& op_unknown___0}, 
        {& op_push___0}, 
        {& op_or_imm___0}, 
        {& op_rst___0}, 
        {& op_ld_hlsp___0}, 
        {& op_ld_sphl___0}, 
        {& op_ld_imm___0}, 
        {& op_ei___0}, 
        {& op_unknown___0}, 
        {& op_unknown___0}, 
        {& op_cp_imm___0}, 
        {& op_rst___0}};
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static int fd___0  ;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static long ( __attribute__((__regparm__(3))) devdsp_open)(enum plugout_endian endian___1 ,
                                                           long rate___1 ) 
{ 
  int c___3 ;
  int flags ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
  {
#line 31
  fd___0 = open("/dev/dsp", 2049);
  }
  }
#line 31
  if (fd___0 == -1) {
    {
    {
#line 32
    tmp = __errno_location();
    }
    {
#line 32
    tmp___0 = strerror(*tmp);
    }
    {
#line 32
    tmp___1 = _("Could not open /dev/dsp: %s\n");
    }
    {
#line 32
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            tmp___0);
    }
    }
#line 33
    return (-1L);
  }
  {
  {
#line 35
  flags = fcntl(fd___0, 3);
  }
  }
#line 35
  if (flags == -1) {
    {
    {
#line 36
    tmp___2 = __errno_location();
    }
    {
#line 36
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 36
    tmp___4 = _("fcntl(F_GETFL) failed: %s\n");
    }
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
            tmp___3);
    }
    }
  } else {
    {
    {
#line 37
    tmp___8 = fcntl(fd___0, 4, flags & -2049);
    }
    }
#line 37
    if (tmp___8 == -1) {
      {
      {
#line 38
      tmp___5 = __errno_location();
      }
      {
#line 38
      tmp___6 = strerror(*tmp___5);
      }
      {
#line 38
      tmp___7 = _("fcntl(F_SETFL, flags&~O_NONBLOCK) failed: %s\n");
      }
      {
#line 38
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              tmp___6);
      }
      }
    }
  }
  {
#line 42
  if ((unsigned int )endian___1 == 0U) {
#line 42
    goto case_0;
  }
#line 43
  if ((unsigned int )endian___1 == 1U) {
#line 43
    goto case_1;
  }
#line 44
  if ((unsigned int )endian___1 == 2U) {
#line 44
    goto case_2;
  }
#line 41
  goto switch_break;
  case_0: /* CIL Label */ 
#line 42
  c___3 = 32;
#line 42
  goto switch_break;
  case_1: /* CIL Label */ 
#line 43
  c___3 = 16;
#line 43
  goto switch_break;
  case_2: /* CIL Label */ 
#line 44
  c___3 = 16;
#line 44
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 46
  tmp___12 = ioctl(fd___0, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 46
  if (tmp___12 == -1) {
    {
    {
#line 47
    tmp___9 = __errno_location();
    }
    {
#line 47
    tmp___10 = strerror(*tmp___9);
    }
    {
#line 47
    tmp___11 = _("ioctl(fd, SNDCTL_DSP_SETFMT, %d) failed: %s\n");
    }
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            c___3, tmp___10);
    }
    }
#line 48
    return (-1L);
  }
  {
#line 50
  c___3 = (int )rate___1;
  {
#line 51
  tmp___16 = ioctl(fd___0, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 51
  if (tmp___16 == -1) {
    {
    {
#line 52
    tmp___13 = __errno_location();
    }
    {
#line 52
    tmp___14 = strerror(*tmp___13);
    }
    {
#line 52
    tmp___15 = _("ioctl(fd, SNDCTL_DSP_SPEED, %ld) failed: %s\n");
    }
    {
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
            rate___1, tmp___14);
    }
    }
#line 53
    return (-1L);
  }
#line 55
  if ((long )c___3 != rate___1) {
    {
    {
#line 56
    tmp___17 = _("Requested rate %ldHz, got %dHz.\n");
    }
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
            rate___1, c___3);
    }
#line 57
    rate___1 = (long )c___3;
    }
  }
  {
#line 59
  c___3 = 1;
  {
#line 60
  tmp___21 = ioctl(fd___0, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 60
  if (tmp___21 == -1) {
    {
    {
#line 61
    tmp___18 = __errno_location();
    }
    {
#line 61
    tmp___19 = strerror(*tmp___18);
    }
    {
#line 61
    tmp___20 = _("ioctl(fd, SNDCTL_DSP_STEREO, %d) failed: %s\n");
    }
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
            c___3, tmp___19);
    }
    }
#line 62
    return (-1L);
  }
  {
#line 64
  c___3 = (4 << 16) + 11;
  {
#line 65
  tmp___25 = ioctl(fd___0, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 10U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 65
  if (tmp___25 == -1) {
    {
    {
#line 66
    tmp___22 = __errno_location();
    }
    {
#line 66
    tmp___23 = strerror(*tmp___22);
    }
    {
#line 66
    tmp___24 = _("ioctl(fd, SNDCTL_DSP_SETFRAGMENT, %08x) failed: %s\n");
    }
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
            c___3, tmp___23);
    }
    }
  }
#line 68
  return (0L);
}
}
#line 71 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static ssize_t ( __attribute__((__regparm__(3))) devdsp_write)(void const   *buf___3 ,
                                                               size_t count ) 
{ 
  ssize_t tmp ;

  {
  {
  {
#line 73
  tmp = write(fd___0, buf___3, count);
  }
  }
#line 73
  return (tmp);
}
}
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static void ( __attribute__((__regparm__(3))) devdsp_close)(void) 
{ 


  {
  {
  {
#line 78
  close(fd___0);
  }
  }
#line 79
  return;
}
}
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
struct output_plugin  const  plugout_devdsp  = 
#line 81
     {(char *)"oss", (char *)"OSS sound driver", 0L, & devdsp_open, (int ( __attribute__((__regparm__(3))) (*))(int subsong ))0,
    (int ( __attribute__((__regparm__(3))) (*))(long cycles , uint32_t addr , uint8_t val ))0,
    & devdsp_write, & devdsp_close};
#line 13 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static unsigned long crc_table___0[256]  ;
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static void ( __attribute__((__regparm__(3))) make_crc_table___0)(void) 
{ 
  unsigned long i ;
  unsigned long j ;
  unsigned long h ;
  unsigned long tmp ;

  {
#line 21
  h = 1UL;
#line 22
  crc_table___0[0] = 0UL;
#line 23
  i = 128UL;
  {
  {
#line 23
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 23
    if (! i) {
#line 23
      goto while_break;
    }
#line 24
    if (h & 1UL) {
#line 24
      tmp = 3988292384UL;
    } else {
#line 24
      tmp = 0UL;
    }
#line 24
    h = (h >> 1) ^ tmp;
#line 26
    j = 0UL;
    {
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! (j < 256UL)) {
#line 26
        goto while_break___0;
      }
#line 27
      crc_table___0[i + j] = crc_table___0[j] ^ h;
#line 26
      j += 2UL * i;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 23
    i >>= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint8_t const   playercode___0[127]  = 
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
  {      (uint8_t const   )245,      (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )48, 
        (uint8_t const   )0,      (uint8_t const   )17,      (uint8_t const   )16,      (uint8_t const   )255, 
        (uint8_t const   )33,      (uint8_t const   )159,      (uint8_t const   )0,      (uint8_t const   )42, 
        (uint8_t const   )18,      (uint8_t const   )19,      (uint8_t const   )11,      (uint8_t const   )120, 
        (uint8_t const   )177,      (uint8_t const   )32,      (uint8_t const   )248,      (uint8_t const   )225, 
        (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )14,      (uint8_t const   )0, 
        (uint8_t const   )9,      (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )6, 
        (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )7,      (uint8_t const   )17, 
        (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )203,      (uint8_t const   )87, 
        (uint8_t const   )62,      (uint8_t const   )1,      (uint8_t const   )40,      (uint8_t const   )2, 
        (uint8_t const   )62,      (uint8_t const   )4,      (uint8_t const   )18,      (uint8_t const   )225, 
        (uint8_t const   )241,      (uint8_t const   )87,      (uint8_t const   )229,      (uint8_t const   )1, 
        (uint8_t const   )8,      (uint8_t const   )0,      (uint8_t const   )9,      (uint8_t const   )42, 
        (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122,      (uint8_t const   )1, 
        (uint8_t const   )140,      (uint8_t const   )0,      (uint8_t const   )197,      (uint8_t const   )233, 
        (uint8_t const   )251,      (uint8_t const   )118,      (uint8_t const   )225,      (uint8_t const   )229, 
        (uint8_t const   )1,      (uint8_t const   )10,      (uint8_t const   )0,      (uint8_t const   )9, 
        (uint8_t const   )42,      (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122, 
        (uint8_t const   )1,      (uint8_t const   )157,      (uint8_t const   )0,      (uint8_t const   )197, 
        (uint8_t const   )233,      (uint8_t const   )24,      (uint8_t const   )238,      (uint8_t const   )128, 
        (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191, 
        (uint8_t const   )0,      (uint8_t const   )63,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255,      (uint8_t const   )159, 
        (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )255, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )119, 
        (uint8_t const   )243,      (uint8_t const   )241,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72,      (uint8_t const   )54, 
        (uint8_t const   )2,      (uint8_t const   )207,      (uint8_t const   )22,      (uint8_t const   )44, 
        (uint8_t const   )4,      (uint8_t const   )229,      (uint8_t const   )44,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72};
#line 122 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static long ( __attribute__((__regparm__(3))) gbs_nextsubsong___0)(struct gbs *gbs ) 
{ 
  long tmp ;

  {
#line 124
  if ((unsigned long )gbs->nextsubsong_cb != (unsigned long )((void *)0)) {
    {
    {
#line 125
    tmp = (*(gbs->nextsubsong_cb))(gbs, gbs->nextsubsong_cb_priv);
    }
    }
#line 125
    return (tmp);
  } else {
#line 127
    (gbs->subsong) ++;
#line 128
    if (gbs->subsong >= gbs->songs) {
#line 129
      return (0L);
    }
    {
    {
#line 130
    gbs_init(gbs, gbs->subsong);
    }
    }
  }
#line 132
  return (1L);
}
}
#line 233 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static void ( __attribute__((__regparm__(3))) writeint___0)(char *buf___3 , uint32_t val ,
                                                            long bytes ) 
{ 
  long shift ;
  long i ;

  {
#line 235
  shift = 0L;
#line 238
  i = 0L;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < bytes)) {
#line 238
      goto while_break;
    }
#line 239
    *(buf___3 + i) = (char )((val >> shift) & 255U);
#line 240
    shift += 8L;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint32_t ( __attribute__((__regparm__(3))) readint___0)(char *buf___3 , long bytes ) 
{ 
  long i ;
  long shift ;
  uint32_t res ;

  {
#line 247
  shift = 0L;
#line 248
  res = (uint32_t )0;
#line 250
  i = 0L;
  {
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < bytes)) {
#line 250
      goto while_break;
    }
#line 251
    res |= (unsigned int )((int )((unsigned char )*(buf___3 + i)) << shift);
#line 252
    shift += 8L;
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return (res);
}
}
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) none_get___1)(uint32_t addr ) 
{ 


  {
#line 45
  return ((uint32_t )255);
}
}
#line 48 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) none_put___1)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_get_fn getlookup___1[256]  = 
#line 52
  {      & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1, 
        & none_get___1,      & none_get___1,      & none_get___1,      & none_get___1};
#line 311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_put_fn putlookup___1[256]  = 
#line 311
  {      & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1, 
        & none_put___1,      & none_put___1,      & none_put___1,      & none_put___1};
#line 570 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static uint32_t ( __attribute__((__regparm__(3))) mem_get___1)(uint32_t addr ) 
{ 
  uint32_t ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr ) ;
  uint32_t tmp ;

  {
  {
#line 572
  fn = getlookup___1[addr >> 8];
  {
#line 573
  tmp = (*fn)(addr);
  }
  }
#line 573
  return (tmp);
}
}
#line 576 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static void ( __attribute__((__regparm__(3))) mem_put___1)(uint32_t addr ,
                                                                    uint32_t val ) 
{ 
  void ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr , uint8_t val ) ;

  {
  {
#line 578
  fn = putlookup___1[addr >> 8];
  {
#line 579
  (*fn)(addr, (uint8_t )val);
  }
  }
#line 580
  return;
}
}
#line 582 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) push___1)(uint32_t val ) 
{ 
  uint32_t sp ;

  {
  {
#line 584
  sp = (uint32_t )((int )*((uint16_t *)(& gbcpu_regs.ri[8])) - 2);
#line 585
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )sp;
  {
#line 586
  mem_put___1(sp, val & 255U);
  }
  {
#line 587
  mem_put___1(sp + 1U, val >> 8);
  }
  }
#line 588
  return;
}
}
#line 590 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) pop___1)(void) 
{ 
  uint32_t res ;
  uint32_t sp ;
  uint32_t tmp ;

  {
  {
#line 593
  sp = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[8]));
  {
#line 595
  res = mem_get___1(sp);
  }
  {
#line 596
  tmp = mem_get___1(sp + 1U);
  }
#line 596
  res += tmp << 8;
#line 597
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )(sp + 2U);
  }
#line 599
  return (res);
}
}
#line 602 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm8___1)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;

  {
  {
#line 604
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 606
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 1U);
  {
#line 607
  res = mem_get___1(pc);
  }
  }
  {
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 608
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  return (res);
}
}
#line 612 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm16___1)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 614
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 616
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 2U);
  {
#line 617
  tmp = mem_get___1(pc);
  }
  {
#line 617
  tmp___0 = mem_get___1(pc + 1U);
  }
#line 617
  res = tmp + (tmp___0 << 8);
  }
  {
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 618
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (res);
}
}
#line 628 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_reg___1)(long i ) 
{ 
  uint32_t tmp ;

  {
#line 630
  if (i == 6L) {
    {
    {
#line 631
    tmp = mem_get___1((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])));
    }
    }
#line 631
    return (tmp);
  }
#line 632
  return ((uint32_t )gbcpu_regs.ri[i ^ 1L]);
}
}
#line 635 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) put_reg___1)(long i , uint32_t val ) 
{ 


  {
#line 637
  if (i == 6L) {
    {
    {
#line 638
    mem_put___1((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])), val);
    }
    }
  } else {
#line 639
    gbcpu_regs.ri[i ^ 1L] = (uint8_t )val;
  }
#line 640
  return;
}
}
#line 642 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_unknown___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 644
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown opcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 645
  gbcpu_stopped = 1L;
  }
#line 646
  return;
}
}
#line 648 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_set___1)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 650
  reg = (long )(op & 7U);
#line 651
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 653
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 654
  print_reg(reg);
  }
  {
#line 655
  tmp = get_reg___1(reg);
  }
  {
#line 655
  put_reg___1(reg, tmp | (unsigned int )(1 << bit));
  }
  }
#line 656
  return;
}
}
#line 658 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_res___1)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 660
  reg = (long )(op & 7U);
#line 661
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 663
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 664
  print_reg(reg);
  }
  {
#line 665
  tmp = get_reg___1(reg);
  }
  {
#line 665
  put_reg___1(reg, tmp & (unsigned int )(~ (1 << bit)));
  }
  }
#line 666
  return;
}
}
#line 668 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_bit___1)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 670
  reg = (long )(op & 7U);
#line 671
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 673
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 674
  print_reg(reg);
  }
#line 675
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 676
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 160);
  {
#line 677
  tmp = get_reg___1(reg);
  }
#line 677
  gbcpu_regs.rn.f = (uint8_t )((unsigned int )gbcpu_regs.rn.f ^ (((tmp << 8) >> (bit + 1UL)) & 128U));
  }
#line 678
  return;
}
}
#line 680 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rl___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 682
  reg = (long )(op & 7U);
  {
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 685
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 686
  print_reg(reg);
  }
  {
#line 687
  tmp = get_reg___1(reg);
  }
#line 687
  val = (uint8_t )tmp;
#line 687
  res = val;
#line 688
  res = (uint8_t )((int )res << 1);
#line 689
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 690
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 691
  if ((int )res == 0) {
#line 691
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 692
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 693
  return;
}
}
#line 695 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rla___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 699
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 699
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  res = gbcpu_regs.rn.a;
#line 701
  res = (uint8_t )((int )res << 1);
#line 702
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 703
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 704
  if ((int )res == 0) {
#line 704
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 705
  gbcpu_regs.rn.a = res;
#line 706
  return;
}
}
#line 708 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlc___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 710
  reg = (long )(op & 7U);
  {
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 713
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 714
  print_reg(reg);
  }
  {
#line 715
  tmp = get_reg___1(reg);
  }
#line 715
  val = (uint8_t )tmp;
#line 715
  res = val;
#line 716
  res = (uint8_t )((int )res << 1);
#line 717
  res = (uint8_t )((int )res | ((int )val >> 7));
#line 718
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 719
  if ((int )res == 0) {
#line 719
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 720
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 721
  return;
}
}
#line 723 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlca___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 727
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 727
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  res = gbcpu_regs.rn.a;
#line 729
  res = (uint8_t )((int )res << 1);
#line 730
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a >> 7));
#line 731
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 732
  if ((int )res == 0) {
#line 732
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 733
  gbcpu_regs.rn.a = res;
#line 734
  return;
}
}
#line 736 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sla___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 738
  reg = (long )(op & 7U);
  {
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 741
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 742
  print_reg(reg);
  }
  {
#line 743
  tmp = get_reg___1(reg);
  }
#line 743
  val = (uint8_t )tmp;
#line 743
  res = val;
#line 744
  res = (uint8_t )((int )res << 1);
#line 745
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 746
  if ((int )res == 0) {
#line 746
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 747
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 748
  return;
}
}
#line 750 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rr___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 752
  reg = (long )(op & 7U);
  {
  {
#line 755
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 755
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 756
  print_reg(reg);
  }
  {
#line 757
  tmp = get_reg___1(reg);
  }
#line 757
  val = (uint8_t )tmp;
#line 757
  res = val;
#line 758
  res = (uint8_t )((int )res >> 1);
#line 759
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 760
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 761
  if ((int )res == 0) {
#line 761
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 762
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 763
  return;
}
}
#line 765 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rra___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 769
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 769
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  res = gbcpu_regs.rn.a;
#line 771
  res = (uint8_t )((int )res >> 1);
#line 772
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 773
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 774
  if ((int )res == 0) {
#line 774
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 775
  gbcpu_regs.rn.a = res;
#line 776
  return;
}
}
#line 778 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrc___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 780
  reg = (long )(op & 7U);
  {
  {
#line 783
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 783
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 784
  print_reg(reg);
  }
  {
#line 785
  tmp = get_reg___1(reg);
  }
#line 785
  val = (uint8_t )tmp;
#line 785
  res = val;
#line 786
  res = (uint8_t )((int )res >> 1);
#line 787
  res = (uint8_t )((int )res | ((int )val << 7));
#line 788
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 789
  if ((int )res == 0) {
#line 789
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 790
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 791
  return;
}
}
#line 793 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrca___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  res = gbcpu_regs.rn.a;
#line 799
  res = (uint8_t )((int )res >> 1);
#line 800
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a << 7));
#line 801
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 802
  if ((int )res == 0) {
#line 802
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 803
  gbcpu_regs.rn.a = res;
#line 804
  return;
}
}
#line 806 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sra___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 808
  reg = (long )(op & 7U);
  {
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 811
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 812
  print_reg(reg);
  }
  {
#line 813
  tmp = get_reg___1(reg);
  }
#line 813
  val = (uint8_t )tmp;
#line 813
  res = val;
#line 814
  res = (uint8_t )((int )res >> 1);
#line 815
  res = (uint8_t )((int )res | ((int )val & 128));
#line 816
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 817
  if ((int )res == 0) {
#line 817
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 818
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 819
  return;
}
}
#line 821 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_srl___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 823
  reg = (long )(op & 7U);
  {
  {
#line 826
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 826
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 827
  print_reg(reg);
  }
  {
#line 828
  tmp = get_reg___1(reg);
  }
#line 828
  val = (uint8_t )tmp;
#line 828
  res = val;
#line 829
  res = (uint8_t )((int )res >> 1);
#line 830
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 831
  if ((int )res == 0) {
#line 831
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 832
  put_reg___1(reg, (uint32_t )res);
  }
  }
#line 833
  return;
}
}
#line 835 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_swap___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t res ;
  uint32_t val ;

  {
#line 837
  reg = (long )(op & 7U);
  {
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 841
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 842
  print_reg(reg);
  }
  {
#line 843
  val = get_reg___1(reg);
  }
#line 844
  res = (val >> 4) | (val << 4);
#line 846
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 847
  if (res == 0U) {
#line 847
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 848
  put_reg___1(reg, res);
  }
  }
#line 849
  return;
}
}
#line 851 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  cbops___1[8]  = 
#line 851
  {      {& op_rlc___1}, 
        {& op_rrc___1}, 
        {& op_rl___1}, 
        {& op_rr___1}, 
        {& op_sla___1}, 
        {& op_sra___1}, 
        {& op_swap___1}, 
        {& op_srl___1}};
#line 862 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cbprefix___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t pc ;
  char *__cil_tmp4 ;

  {
  {
#line 864
  pc = *((uint16_t *)(& gbcpu_regs.ri[10]));
#line 866
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )pc + 1);
  {
#line 867
  op = mem_get___1((uint32_t )pc);
  }
  }
  {
#line 869
  if (op >> 6 == 0U) {
#line 869
    goto case_0;
  }
#line 871
  if (op >> 6 == 1U) {
#line 871
    goto case_1;
  }
#line 872
  if (op >> 6 == 2U) {
#line 872
    goto case_2;
  }
#line 873
  if (op >> 6 == 3U) {
#line 873
    goto case_3;
  }
#line 868
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 869
  (*(cbops___1[(op >> 3) & 7U].fn))(op, & cbops___1[(op >> 3) & 7U]);
  }
  }
#line 870
  return;
  case_1: /* CIL Label */ 
  {
  {
#line 871
  op_bit___1(op);
  }
  }
#line 871
  return;
  case_2: /* CIL Label */ 
  {
  {
#line 872
  op_res___1(op);
  }
  }
#line 872
  return;
  case_3: /* CIL Label */ 
  {
  {
#line 873
  op_set___1(op);
  }
  }
#line 873
  return;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 875
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown CB subopcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 876
  gbcpu_stopped = 1L;
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long src ;
  long dst ;
  uint32_t tmp ;

  {
#line 881
  src = (long )(op & 7U);
#line 882
  dst = (long )((op >> 3) & 7U);
  {
  {
#line 884
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 884
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 885
  print_reg(dst);
  }
  }
  {
  {
#line 886
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 886
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 887
  print_reg(src);
  }
  {
#line 888
  tmp = get_reg___1(src);
  }
  {
#line 888
  put_reg___1(dst, tmp);
  }
  }
#line 889
  return;
}
}
#line 891 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 893
  tmp = get_imm16___1();
  }
#line 893
  ofs = (long )tmp;
  }
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 896
  tmp___0 = mem_get___1((uint32_t )ofs);
  }
#line 896
  gbcpu_regs.rn.a = (uint8_t )tmp___0;
  }
#line 897
  return;
}
}
#line 899 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_a___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 901
  tmp = get_imm16___1();
  }
#line 901
  ofs = (long )tmp;
  }
  {
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 903
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 904
  mem_put___1((uint32_t )ofs, (uint32_t )gbcpu_regs.rn.a);
  }
  }
#line 905
  return;
}
}
#line 907 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_sp___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  long sp ;

  {
  {
  {
#line 909
  tmp = get_imm16___1();
  }
#line 909
  ofs = (long )tmp;
#line 910
  sp = (long )*((uint16_t *)(& gbcpu_regs.ri[8]));
  }
  {
  {
#line 912
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 912
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 913
  mem_put___1((uint32_t )ofs, (uint32_t )(sp & 255L));
  }
  {
#line 914
  mem_put___1((uint32_t )(ofs + 1L), (uint32_t )(sp >> 8));
  }
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_hlsp___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t ofs ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 919
  tmp = get_imm8___1();
  }
#line 919
  ofs = (int8_t )tmp;
#line 920
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 921
  new = (uint16_t )((int )old + (int )ofs);
  }
#line 923
  if ((int )ofs > 0) {
    {
    {
#line 923
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 923
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 924
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 924
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 925
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 926
  gbcpu_regs.rn.f = (uint8_t )0;
#line 927
  if ((int )old > (int )new) {
#line 927
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 928
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 928
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 929
  return;
}
}
#line 931 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_sphl___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 933
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 933
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  *((uint16_t *)(& gbcpu_regs.ri[8])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 935
  return;
}
}
#line 937 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 939
  tmp = get_imm16___1();
  }
#line 939
  val = (long )tmp;
#line 940
  reg = (long )((op >> 4) & 3U);
#line 942
  reg += (long )(reg > 2L);
  }
  {
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 943
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )val;
#line 945
  return;
}
}
#line 947 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_a___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t r ;
  uint32_t tmp ;

  {
#line 949
  reg = (long )((op >> 4) & 3U);
#line 952
  reg -= (long )(reg > 2L);
#line 953
  if (op & 8U) {
    {
    {
#line 954
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 954
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 955
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 955
    tmp = mem_get___1((uint32_t )r);
    }
#line 955
    gbcpu_regs.rn.a = (uint8_t )tmp;
    }
  } else {
    {
    {
#line 957
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 957
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 958
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 958
    mem_put___1((uint32_t )r, (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 961
  if (reg == 2L) {
#line 962
    r = (uint16_t )((int )r + ((((op & 16U) == 0U) << 1) - 1));
#line 963
    *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = r;
  }
#line 965
  return;
}
}
#line 967 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg8_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 969
  tmp = get_imm8___1();
  }
#line 969
  val = (long )tmp;
#line 970
  reg = (long )((op >> 3) & 7U);
  }
  {
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 972
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 973
  print_reg(reg);
  }
  {
#line 974
  put_reg___1(reg, (uint32_t )val);
  }
  }
  {
  {
#line 975
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 975
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 976
  return;
}
}
#line 978 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ldh___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 980
  if (op & 2U) {
#line 980
    tmp___0 = (uint32_t )0;
  } else {
    {
    {
#line 980
    tmp = get_imm8___1();
    }
#line 980
    tmp___0 = tmp;
    }
  }
#line 980
  ofs = (long )tmp___0;
#line 982
  if (op & 16U) {
    {
    {
#line 983
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 983
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 984
    if ((op & 2U) == 0U) {
      {
      {
#line 985
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 985
        goto while_break___0;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 987
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 988
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 988
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 990
    tmp___1 = mem_get___1((uint32_t )(65280L + ofs));
    }
#line 990
    gbcpu_regs.rn.a = (uint8_t )tmp___1;
    }
  } else {
#line 992
    if ((op & 2U) == 0U) {
      {
      {
#line 993
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 993
        goto while_break___2;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 995
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 996
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 996
        goto while_break___3;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    {
#line 998
    mem_put___1((uint32_t )(65280L + ofs), (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 1000
  return;
}
}
#line 1002 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1004
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1008
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1008
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1009
  print_reg(reg);
  }
  {
#line 1010
  tmp = get_reg___1(reg);
  }
#line 1010
  res = (uint8_t )tmp;
#line 1010
  old = res;
#line 1011
  res = (uint8_t )((int )res + 1);
  {
#line 1012
  put_reg___1(reg, (uint32_t )res);
  }
#line 1013
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -225);
  }
#line 1014
  if ((int )res == 0) {
#line 1014
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1015
  if (((int )old & 15) > ((int )res & 15)) {
#line 1015
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1016
  return;
}
}
#line 1018 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc16___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1020
  reg = (long )((op >> 4) & 3U);
#line 1021
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1023
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1023
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  res = (uint16_t )((int )res + 1);
#line 1025
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1026
  return;
}
}
#line 1028 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1030
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1034
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1034
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1035
  print_reg(reg);
  }
  {
#line 1036
  tmp = get_reg___1(reg);
  }
#line 1036
  res = (uint8_t )tmp;
#line 1036
  old = res;
#line 1037
  res = (uint8_t )((int )res - 1);
  {
#line 1038
  put_reg___1(reg, (uint32_t )res);
  }
#line 1039
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 64);
#line 1040
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -161);
  }
#line 1041
  if ((int )res == 0) {
#line 1041
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1042
  if (((int )old & 15) > ((int )res & 15)) {
#line 1042
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1043
  return;
}
}
#line 1045 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec16___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1047
  reg = (long )((op >> 4) & 3U);
#line 1048
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1050
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1050
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1051
  res = (uint16_t )((int )res - 1);
#line 1052
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1053
  return;
}
}
#line 1055 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_sp_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t imm ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 1057
  tmp = get_imm8___1();
  }
#line 1057
  imm = (int8_t )tmp;
#line 1058
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 1059
  new = old;
  }
  {
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1061
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  new = (uint16_t )((int )new + (int )imm);
#line 1063
  *((uint16_t *)(& gbcpu_regs.ri[8])) = new;
#line 1064
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1065
  if ((int )old > (int )new) {
#line 1065
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1066
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1066
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1067
  return;
}
}
#line 1069 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1071
  old = gbcpu_regs.rn.a;
  {
  {
#line 1074
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1074
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1075
  print_reg((long )(op & 7U));
  }
  {
#line 1076
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1076
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1077
  new = gbcpu_regs.rn.a;
#line 1078
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1079
  if ((int )old > (int )new) {
#line 1079
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1080
  if (((int )old & 15) > ((int )new & 15)) {
#line 1080
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1081
  if ((int )new == 0) {
#line 1081
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1082
  return;
}
}
#line 1084 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1086
  tmp = get_imm8___1();
  }
#line 1086
  imm = (uint8_t )tmp;
#line 1087
  old = gbcpu_regs.rn.a;
#line 1088
  new = old;
  }
  {
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1090
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1091
  new = (uint8_t )((int )new + (int )imm);
#line 1092
  gbcpu_regs.rn.a = new;
#line 1093
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1094
  if ((int )old > (int )new) {
#line 1094
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1095
  if (((int )old & 15) > ((int )new & 15)) {
#line 1095
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1096
  if ((int )new == 0) {
#line 1096
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1097
  return;
}
}
#line 1099 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_hl___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t old ;
  uint16_t new ;

  {
#line 1101
  reg = (long )((op >> 4) & 3U);
#line 1102
  old = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1103
  new = old;
#line 1105
  reg += (long )(reg > 2L);
  {
  {
#line 1106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1106
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  new = (uint16_t )((int )new + (int )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
#line 1109
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 1111
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -113);
#line 1112
  if ((int )old > (int )new) {
#line 1112
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1113
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1113
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1114
  return;
}
}
#line 1116 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1118
  old = gbcpu_regs.rn.a;
  {
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1121
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1122
  print_reg((long )(op & 7U));
  }
  {
#line 1123
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1123
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1124
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1125
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1126
  new = gbcpu_regs.rn.a;
  }
#line 1127
  if ((int )old > (int )new) {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1128
  if (((int )old & 15) > ((int )new & 15)) {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1129
  if ((int )new == 0) {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1130
  return;
}
}
#line 1132 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1134
  tmp = get_imm8___1();
  }
#line 1134
  imm = (uint8_t )tmp;
#line 1135
  old = gbcpu_regs.rn.a;
#line 1136
  new = old;
  }
  {
  {
#line 1138
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1138
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  new = (uint8_t )((int )new + (int )imm);
#line 1140
  new = (uint8_t )((int )new + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1141
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1142
  gbcpu_regs.rn.a = new;
#line 1143
  if ((int )old > (int )new) {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1144
  if (((int )old & 15) > ((int )new & 15)) {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1145
  if ((int )new == 0) {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1150
  old = gbcpu_regs.rn.a;
#line 1151
  new = old;
  {
  {
#line 1153
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1153
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1154
  print_reg((long )(op & 7U));
  }
  {
#line 1155
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1155
  new = (uint8_t )((uint32_t )new - tmp);
#line 1156
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1157
  if ((int )old < (int )new) {
#line 1157
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1158
  if (((int )old & 15) < ((int )new & 15)) {
#line 1158
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1159
  if ((int )new == 0) {
#line 1159
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1160
  return;
}
}
#line 1162 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1164
  tmp = get_imm8___1();
  }
#line 1164
  imm = (uint8_t )tmp;
#line 1165
  old = gbcpu_regs.rn.a;
#line 1166
  new = old;
  }
  {
  {
#line 1168
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1168
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  new = (uint8_t )((int )new - (int )imm);
#line 1170
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1171
  if ((int )old < (int )new) {
#line 1171
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1172
  if (((int )old & 15) < ((int )new & 15)) {
#line 1172
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1173
  if ((int )new == 0) {
#line 1173
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1174
  return;
}
}
#line 1176 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1178
  old = gbcpu_regs.rn.a;
  {
  {
#line 1181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1181
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1182
  print_reg((long )(op & 7U));
  }
  {
#line 1183
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1183
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1184
  new = gbcpu_regs.rn.a;
#line 1185
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1186
  if ((int )old < (int )new) {
#line 1186
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1187
  if (((int )old & 15) < ((int )new & 15)) {
#line 1187
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1188
  if ((int )new == 0) {
#line 1188
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1189
  return;
}
}
#line 1191 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1193
  tmp = get_imm8___1();
  }
#line 1193
  imm = (uint8_t )tmp;
#line 1194
  old = gbcpu_regs.rn.a;
#line 1195
  new = old;
  }
  {
  {
#line 1197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1197
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  new = (uint8_t )((int )new - (int )imm);
#line 1199
  gbcpu_regs.rn.a = new;
#line 1200
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1201
  if ((int )old < (int )new) {
#line 1201
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1202
  if (((int )old & 15) < ((int )new & 15)) {
#line 1202
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1203
  if ((int )new == 0) {
#line 1203
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1204
  return;
}
}
#line 1206 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1208
  old = gbcpu_regs.rn.a;
  {
  {
#line 1211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1211
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1212
  print_reg((long )(op & 7U));
  }
  {
#line 1213
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1213
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1214
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1215
  new = gbcpu_regs.rn.a;
#line 1216
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1217
  if ((int )old < (int )new) {
#line 1217
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1218
  if (((int )old & 15) < ((int )new & 15)) {
#line 1218
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1219
  if ((int )new == 0) {
#line 1219
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1220
  return;
}
}
#line 1222 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1224
  tmp = get_imm8___1();
  }
#line 1224
  imm = (uint8_t )tmp;
#line 1225
  old = gbcpu_regs.rn.a;
#line 1226
  new = old;
  }
  {
  {
#line 1228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1228
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  new = (uint8_t )((int )new - (int )imm);
#line 1230
  new = (uint8_t )((int )new - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1231
  gbcpu_regs.rn.a = new;
#line 1232
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1233
  if ((int )old < (int )new) {
#line 1233
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1234
  if (((int )old & 15) < ((int )new & 15)) {
#line 1234
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1235
  if ((int )new == 0) {
#line 1235
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1236
  return;
}
}
#line 1238 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1240
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1241
  print_reg((long )(op & 7U));
  }
  {
#line 1242
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1242
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a & tmp);
#line 1243
  gbcpu_regs.rn.f = (uint8_t )32;
  }
#line 1244
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1244
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1245
  return;
}
}
#line 1247 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1249
  tmp = get_imm8___1();
  }
#line 1249
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1251
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1252
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a & (int )imm);
#line 1253
  gbcpu_regs.rn.f = (uint8_t )32;
#line 1254
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1254
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1255
  return;
}
}
#line 1257 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1259
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1260
  print_reg((long )(op & 7U));
  }
  {
#line 1261
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1261
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a | tmp);
#line 1262
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1263
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1263
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1264
  return;
}
}
#line 1266 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1268
  tmp = get_imm8___1();
  }
#line 1268
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1270
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a | (int )imm);
#line 1272
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1273
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1273
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1274
  return;
}
}
#line 1276 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1278
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1279
  print_reg((long )(op & 7U));
  }
  {
#line 1280
  tmp = get_reg___1((long )(op & 7U));
  }
#line 1280
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a ^ tmp);
#line 1281
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1282
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1282
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1283
  return;
}
}
#line 1285 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor_imm___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1287
  tmp = get_imm8___1();
  }
#line 1287
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1289
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1289
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a ^ (int )imm);
#line 1291
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1292
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1292
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1293
  return;
}
}
#line 1295 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_push___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;

  {
  {
#line 1297
  reg = (long )((op >> 4) & 3U);
  {
#line 1299
  push___1((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
  }
  }
  {
  {
#line 1300
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1300
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1301
  return;
}
}
#line 1303 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_pop___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t tmp ;

  {
  {
#line 1305
  reg = (long )((op >> 4) & 3U);
  {
#line 1307
  tmp = pop___1();
  }
#line 1307
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )tmp;
  }
  {
  {
#line 1308
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1308
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 1311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cpl___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1313
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1313
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1314
  gbcpu_regs.rn.a = (uint8_t )(~ ((int )gbcpu_regs.rn.a));
#line 1315
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 96);
#line 1316
  return;
}
}
#line 1318 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ccf___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1320
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f ^ 16);
#line 1322
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1323
  return;
}
}
#line 1325 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_scf___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1327
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1327
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1328
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
#line 1329
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1330
  return;
}
}
#line 1332 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1334
  tmp = get_imm16___1();
  }
#line 1334
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1336
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1337
  push___1((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1338
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1339
  return;
}
}
#line 1341 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call_cond___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1343
  tmp = get_imm16___1();
  }
#line 1343
  ofs = (uint16_t )tmp;
#line 1344
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1346
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1346
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1348
  if (cond == 0L) {
#line 1348
    goto case_0;
  }
#line 1349
  if (cond == 1L) {
#line 1349
    goto case_1;
  }
#line 1350
  if (cond == 2L) {
#line 1350
    goto case_2;
  }
#line 1351
  if (cond == 3L) {
#line 1351
    goto case_3;
  }
#line 1347
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1348
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1348
    return;
  }
#line 1348
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1349
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1349
    return;
  }
#line 1349
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1350
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1350
    return;
  }
#line 1350
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1351
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1351
    return;
  }
#line 1351
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1353
  push___1((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1354
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1355
  return;
}
}
#line 1357 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1359
  tmp = pop___1();
  }
#line 1359
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1360
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1361
  return;
}
}
#line 1363 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_reti___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1365
  tmp = pop___1();
  }
#line 1365
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1366
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1367
  return;
}
}
#line 1369 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret_cond___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long cond ;
  uint32_t tmp ;

  {
#line 1371
  cond = (long )((op >> 3) & 3U);
  {
  {
#line 1373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1373
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1375
  if (cond == 0L) {
#line 1375
    goto case_0;
  }
#line 1376
  if (cond == 1L) {
#line 1376
    goto case_1;
  }
#line 1377
  if (cond == 2L) {
#line 1377
    goto case_2;
  }
#line 1378
  if (cond == 3L) {
#line 1378
    goto case_3;
  }
#line 1374
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1375
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1375
    return;
  }
#line 1375
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1376
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1376
    return;
  }
#line 1376
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1377
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1377
    return;
  }
#line 1377
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1378
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1378
    return;
  }
#line 1378
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1380
  tmp = pop___1();
  }
#line 1380
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
#line 1381
  return;
}
}
#line 1383 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_halt___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1385
  gbcpu_halted = 1L;
  {
  {
#line 1386
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1386
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  return;
}
}
#line 1389 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_stop___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1391
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1391
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  return;
}
}
#line 1394 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_di___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1396
  gbcpu_if = 0L;
  {
  {
#line 1397
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1397
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return;
}
}
#line 1400 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ei___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1402
  gbcpu_if = 1L;
  {
  {
#line 1403
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1403
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1408
  tmp = get_imm8___1();
  }
#line 1408
  ofs = (int16_t )((int8_t )tmp);
  }
#line 1410
  if ((int )ofs < 0) {
    {
    {
#line 1410
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1410
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1411
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1411
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1412
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1413
  return;
}
}
#line 1415 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr_cond___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1417
  tmp = get_imm8___1();
  }
#line 1417
  ofs = (int16_t )((int8_t )tmp);
#line 1418
  cond = (long )((op >> 3) & 3U);
  }
#line 1420
  if ((int )ofs < 0) {
    {
    {
#line 1420
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1420
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1421
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1421
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1423
  if (cond == 0L) {
#line 1423
    goto case_0;
  }
#line 1424
  if (cond == 1L) {
#line 1424
    goto case_1;
  }
#line 1425
  if (cond == 2L) {
#line 1425
    goto case_2;
  }
#line 1426
  if (cond == 3L) {
#line 1426
    goto case_3;
  }
#line 1422
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1423
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1423
    return;
  }
#line 1423
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1424
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1424
    return;
  }
#line 1424
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1425
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1425
    return;
  }
#line 1425
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1426
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1426
    return;
  }
#line 1426
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1428
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1429
  return;
}
}
#line 1431 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1433
  tmp = get_imm16___1();
  }
#line 1433
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1435
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1435
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1437
  return;
}
}
#line 1439 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_hl___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1441
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1441
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  *((uint16_t *)(& gbcpu_regs.ri[10])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1443
  return;
}
}
#line 1445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_cond___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1447
  tmp = get_imm16___1();
  }
#line 1447
  ofs = (uint16_t )tmp;
#line 1448
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1450
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1450
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1452
  if (cond == 0L) {
#line 1452
    goto case_0;
  }
#line 1453
  if (cond == 1L) {
#line 1453
    goto case_1;
  }
#line 1454
  if (cond == 2L) {
#line 1454
    goto case_2;
  }
#line 1455
  if (cond == 3L) {
#line 1455
    goto case_3;
  }
#line 1451
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1452
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1452
    return;
  }
#line 1452
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1453
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1453
    return;
  }
#line 1453
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1454
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1454
    return;
  }
#line 1454
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1455
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1455
    return;
  }
#line 1455
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1457
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1458
  return;
}
}
#line 1460 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rst___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;

  {
#line 1462
  ofs = (int16_t )(op & 56U);
  {
  {
#line 1464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1464
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1465
  push___1((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1466
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )ofs;
  }
#line 1467
  return;
}
}
#line 1469 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_nop___1)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1471
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1471
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  return;
}
}
#line 1474 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  ops___1[256]  = 
#line 1474
  {      {& op_nop___1}, 
        {& op_ld_reg16_imm___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_inc16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_rlca___1}, 
        {& op_ld_ind16_sp___1}, 
        {& op_add_hl___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_dec16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_rrca___1}, 
        {& op_stop___1}, 
        {& op_ld_reg16_imm___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_inc16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_rla___1}, 
        {& op_jr___1}, 
        {& op_add_hl___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_dec16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_rra___1}, 
        {& op_jr_cond___1}, 
        {& op_ld_reg16_imm___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_inc16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_unknown___1}, 
        {& op_jr_cond___1}, 
        {& op_add_hl___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_dec16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_cpl___1}, 
        {& op_jr_cond___1}, 
        {& op_ld_reg16_imm___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_inc16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_scf___1}, 
        {& op_jr_cond___1}, 
        {& op_add_hl___1}, 
        {& op_ld_reg16_a___1}, 
        {& op_dec16___1}, 
        {& op_inc___1}, 
        {& op_dec___1}, 
        {& op_ld_reg8_imm___1}, 
        {& op_ccf___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_halt___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_ld___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_add___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_adc___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sub___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_sbc___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_and___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_xor___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_or___1}, 
        {& op_cp___1}, 
        {& op_cp___1}, 
        {& op_cp___1}, 
        {& op_cp___1}, 
        {& op_cp___1}, 
        {& op_cp___1}, 
        {& op_cp___1}, 
        {& op_unknown___1}, 
        {& op_ret_cond___1}, 
        {& op_pop___1}, 
        {& op_jp_cond___1}, 
        {& op_jp___1}, 
        {& op_call_cond___1}, 
        {& op_push___1}, 
        {& op_add_imm___1}, 
        {& op_rst___1}, 
        {& op_ret_cond___1}, 
        {& op_ret___1}, 
        {& op_jp_cond___1}, 
        {& op_cbprefix___1}, 
        {& op_call_cond___1}, 
        {& op_call___1}, 
        {& op_adc_imm___1}, 
        {& op_rst___1}, 
        {& op_ret_cond___1}, 
        {& op_pop___1}, 
        {& op_jp_cond___1}, 
        {& op_unknown___1}, 
        {& op_call_cond___1}, 
        {& op_push___1}, 
        {& op_sub_imm___1}, 
        {& op_rst___1}, 
        {& op_ret_cond___1}, 
        {& op_reti___1}, 
        {& op_jp_cond___1}, 
        {& op_unknown___1}, 
        {& op_call_cond___1}, 
        {& op_unknown___1}, 
        {& op_sbc_imm___1}, 
        {& op_rst___1}, 
        {& op_ldh___1}, 
        {& op_pop___1}, 
        {& op_ldh___1}, 
        {& op_unknown___1}, 
        {& op_unknown___1}, 
        {& op_push___1}, 
        {& op_and_imm___1}, 
        {& op_rst___1}, 
        {& op_add_sp_imm___1}, 
        {& op_jp_hl___1}, 
        {& op_ld_ind16_a___1}, 
        {& op_unknown___1}, 
        {& op_unknown___1}, 
        {& op_unknown___1}, 
        {& op_xor_imm___1}, 
        {& op_rst___1}, 
        {& op_ldh___1}, 
        {& op_pop___1}, 
        {& op_ldh___1}, 
        {& op_di___1}, 
        {& op_unknown___1}, 
        {& op_push___1}, 
        {& op_or_imm___1}, 
        {& op_rst___1}, 
        {& op_ld_hlsp___1}, 
        {& op_ld_sphl___1}, 
        {& op_ld_imm___1}, 
        {& op_ei___1}, 
        {& op_unknown___1}, 
        {& op_unknown___1}, 
        {& op_cp_imm___1}, 
        {& op_rst___1}};
#line 526 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 16 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
int fd  ;
#line 18 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
static long ( __attribute__((__regparm__(3))) stdout_open)(enum plugout_endian endian___1 ,
                                                           long rate___1 ) 
{ 


  {
  {
  {
#line 25
  fd = dup(1);
  }
  }
#line 26
  if (fd == -1) {
#line 26
    return (-1L);
  }
  {
  {
#line 27
  close(1);
  }
  }
#line 29
  return (0L);
}
}
#line 32 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
static ssize_t ( __attribute__((__regparm__(3))) stdout_write)(void const   *buf___3 ,
                                                               size_t count ) 
{ 
  ssize_t tmp ;

  {
  {
  {
#line 34
  tmp = write(fd, buf___3, count);
  }
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
static void ( __attribute__((__regparm__(3))) stdout_close)(void) 
{ 


  {
  {
  {
#line 39
  close(fd);
  }
  }
#line 40
  return;
}
}
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
struct output_plugin  const  plugout_stdout  = 
#line 42
     {(char *)"stdout", (char *)"STDOUT file writer", 1L, & stdout_open, (int ( __attribute__((__regparm__(3))) (*))(int subsong ))0,
    (int ( __attribute__((__regparm__(3))) (*))(long cycles , uint32_t addr , uint8_t val ))0,
    & stdout_write, & stdout_close};
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t *rom___0  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t intram___0[8192]  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t extram___0[8192]  ;
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t ioregs___0[128]  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t hiram___0[128]  ;
#line 25 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rombank___0  =    1L;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lastbank___0  ;
#line 28 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static char const   dutylookup___0[4]  = {      (char const   )1,      (char const   )2,      (char const   )4,      (char const   )6};
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lminval___0  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lmaxval___0  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rminval___0  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rmaxval___0  ;
#line 38 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_volume___0  ;
#line 39 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_fade___0  ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_dstvol___0  ;
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   vblanktc___0  =    (long const   )70256;
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long vblankctr___0  =    70256L;
#line 44 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timertc___0  =    70256L;
#line 45 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timerctr___0  =    70256L;
#line 47 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   msec_cycles___0  =    (long const   )4194;
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sum_cycles___0  ;
#line 51 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long pause_output___0  =    0L;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*callback___0))(struct gbhw_buffer *buf ,
                                                               void *priv )  ;
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *callbackpriv___0  ;
#line 55 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *soundbuf___0  =    (struct gbhw_buffer *)((void *)0);
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *impbuf___0  =    (struct gbhw_buffer *)((void *)0);
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*iocallback___0))(long cycles , uint32_t addr ,
                                                                 uint8_t valu , void *priv )  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *iocallback_priv___0  ;
#line 66 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap1___0  =    (uint32_t )16384;
#line 67 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap2___0  =    (uint32_t )8192;
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t lfsr___0  =    4294967295U;
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long long sound_div_tc___0  =    0LL;
#line 73 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   main_div_tc___0  =    (long const   )32;
#line 74 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long main_div___0  ;
#line 75 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   sweep_div_tc___0  =    (long const   )256;
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sweep_div___0  ;
#line 78 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long ch3pos___0  ;
#line 80 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_n_shift___0  =    7L;
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_w_shift___0  =    5L;
#line 82 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static double impulse_cutoff___0  =    1.0;
#line 84 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static short *base_impulse___0  =    (short *)((void *)0);
#line 90 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rom_get___0)(uint32_t addr ) 
{ 


  {
#line 93
  return ((uint32_t )*(rom___0 + (addr & 16383U)));
}
}
#line 96 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rombank_get___0)(uint32_t addr ) 
{ 


  {
#line 99
  return ((uint32_t )*(rom___0 + ((long )(addr & 16383U) + 16384L * rombank___0)));
}
}
#line 102 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) io_get___0)(uint32_t addr ) 
{ 
  char *__cil_tmp2 ;

  {
#line 104
  if (addr >= 65408U) {
#line 104
    if (addr <= 65534U) {
#line 105
      return ((uint32_t )hiram___0[addr & 127U]);
    }
  }
#line 107
  if (addr >= 65296U) {
#line 107
    if (addr <= 65343U) {
#line 109
      return ((uint32_t )ioregs___0[addr & 127U]);
    }
  }
#line 111
  if (addr == 65280U) {
#line 111
    return ((uint32_t )0);
  }
#line 112
  if (addr == 65535U) {
#line 112
    return ((uint32_t )ioregs___0[127]);
  }
  {
  {
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ioread from 0x%04x unimplemented.\n",
          addr);
  }
  }
  {
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((uint32_t )255);
}
}
#line 118 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) intram_get___0)(uint32_t addr ) 
{ 


  {
#line 121
  return ((uint32_t )intram___0[addr & 8191U]);
}
}
#line 124 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) extram_get___0)(uint32_t addr ) 
{ 


  {
#line 127
  return ((uint32_t )extram___0[addr & 8191U]);
}
}
#line 130 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) rom_put___0)(uint32_t addr , uint8_t val ) 
{ 
  char *__cil_tmp3 ;

  {
#line 132
  if (addr >= 8192U) {
#line 132
    if (addr <= 16383U) {
#line 133
      val = (uint8_t )((int )val & 31);
#line 134
      rombank___0 = (long )((int )val + ((int )val == 0));
#line 135
      if (rombank___0 > lastbank___0) {
        {
        {
#line 136
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bank %ld out of range (0-%ld)!\n",
                rombank___0, lastbank___0);
        }
#line 137
        rombank___0 = lastbank___0;
        }
      }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) io_put___0)(uint32_t addr , uint8_t val ) 
{ 
  long chn ;
  long duty_ctr ;
  long len ;
  long vol ;
  long envdir ;
  long envspd ;
  long tmp ;
  long div___2 ;
  long vol___0 ;
  long div___3 ;
  long shift ;
  long rate___1 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 144
  (*iocallback___0)(sum_cycles___0, addr, val, iocallback_priv___0);
  }
#line 146
  chn = (long )((addr - 65296U) / 5U);
  }
#line 147
  if (addr >= 65408U) {
#line 147
    if (addr <= 65534U) {
#line 148
      hiram___0[addr & 127U] = val;
#line 149
      return;
    }
  }
#line 151
  ioregs___0[addr & 127U] = val;
  {
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  if (addr == 65287U) {
#line 155
    goto case_65287;
  }
#line 155
  if (addr == 65286U) {
#line 155
    goto case_65287;
  }
#line 160
  if (addr == 65296U) {
#line 160
    goto case_65296;
  }
#line 168
  if (addr == 65312U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65302U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65297U) {
#line 168
    goto case_65312;
  }
#line 181
  if (addr == 65313U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65303U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65298U) {
#line 181
    goto case_65313;
  }
#line 197
  if (addr == 65310U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65309U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65305U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65304U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65300U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65299U) {
#line 197
    goto case_65310;
  }
#line 213
  if (addr == 65301U) {
#line 213
    goto case_65301;
  }
#line 215
  if (addr == 65306U) {
#line 215
    goto case_65306;
  }
#line 218
  if (addr == 65307U) {
#line 218
    goto case_65307;
  }
#line 221
  if (addr == 65308U) {
#line 221
    goto case_65308;
  }
#line 227
  if (addr == 65311U) {
#line 227
    goto case_65311;
  }
#line 230
  if (addr == 65315U) {
#line 230
    goto case_65315;
  }
#line 230
  if (addr == 65314U) {
#line 230
    goto case_65315;
  }
#line 252
  if (addr == 65317U) {
#line 252
    goto case_65317;
  }
#line 262
  if (addr == 65318U) {
#line 262
    goto case_65318;
  }
#line 292
  if (addr == 65535U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65343U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65342U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65341U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65340U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65339U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65338U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65337U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65336U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65335U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65334U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65333U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65332U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65331U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65330U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65329U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65328U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65327U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65326U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65325U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65324U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65323U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65322U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65321U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65320U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65319U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65316U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65280U) {
#line 292
    goto case_65535;
  }
#line 294
  goto switch_default;
  case_65287: /* CIL Label */ 
  case_65286: /* CIL Label */ 
#line 156
  timertc___0 = (long )((256 - (int )ioregs___0[6]) * (16 << ((((int )ioregs___0[7] + 3) & 3) << 1)));
#line 157
  if (((int )ioregs___0[7] & 240) == 128) {
#line 157
    timertc___0 /= 2L;
  }
#line 159
  goto switch_break;
  case_65296: /* CIL Label */ 
#line 161
  gbhw_ch[0].sweep_tc = (long )(((int )val >> 4) & 7);
#line 161
  gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 162
  gbhw_ch[0].sweep_dir = (long )(((int )val >> 3) & 1);
#line 163
  gbhw_ch[0].sweep_shift = (long )((int )val & 7);
#line 165
  goto switch_break;
  case_65312: /* CIL Label */ 
  case_65302: /* CIL Label */ 
  case_65297: /* CIL Label */ 
#line 170
  duty_ctr = (long )((int )val >> 6);
#line 171
  len = (long )((int )val & 63);
#line 173
  gbhw_ch[chn].duty_ctr = (long )dutylookup___0[duty_ctr];
#line 174
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 175
  gbhw_ch[chn].len = (64L - len) * 2L;
#line 177
  goto switch_break;
  case_65313: /* CIL Label */ 
  case_65303: /* CIL Label */ 
  case_65298: /* CIL Label */ 
#line 183
  vol = (long )((int )val >> 4);
#line 184
  envdir = (long )(((int )val >> 3) & 1);
#line 185
  envspd = (long )((int )val & 7);
#line 187
  gbhw_ch[chn].volume = vol;
#line 188
  gbhw_ch[chn].env_dir = envdir;
#line 189
  tmp = envspd * 8L;
#line 189
  gbhw_ch[chn].env_tc = tmp;
#line 189
  gbhw_ch[chn].env_ctr = tmp;
#line 191
  goto switch_break;
  case_65310: /* CIL Label */ 
  case_65309: /* CIL Label */ 
  case_65305: /* CIL Label */ 
  case_65304: /* CIL Label */ 
  case_65300: /* CIL Label */ 
  case_65299: /* CIL Label */ 
#line 199
  div___2 = (long )ioregs___0[19L + 5L * chn];
#line 201
  div___2 |= ((long )ioregs___0[20L + 5L * chn] & 7L) << 8;
#line 202
  gbhw_ch[chn].div_tc = 2048L - div___2;
#line 203
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 205
  if (addr == 65299U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65304U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65309U) {
#line 207
    goto switch_break;
  }
#line 209
  gbhw_ch[chn].len_enable = (long )(((int )ioregs___0[20L + 5L * chn] & 64) > 0);
#line 212
  goto switch_break;
  case_65301: /* CIL Label */ 
#line 214
  goto switch_break;
  case_65306: /* CIL Label */ 
#line 216
  gbhw_ch[2].master = (long )(((int )ioregs___0[26] & 128) > 0);
#line 217
  goto switch_break;
  case_65307: /* CIL Label */ 
#line 219
  gbhw_ch[2].len = (long )((256 - (int )val) * 2);
#line 220
  goto switch_break;
  case_65308: /* CIL Label */ 
#line 223
  vol___0 = (long )(((int )ioregs___0[28] >> 5) & 3);
#line 224
  gbhw_ch[2].volume = vol___0;
#line 225
  goto switch_break;
  case_65311: /* CIL Label */ 
#line 228
  goto switch_break;
  case_65315: /* CIL Label */ 
  case_65314: /* CIL Label */ 
#line 232
  div___3 = (long )ioregs___0[34];
#line 233
  shift = div___3 >> 4;
#line 234
  rate___1 = div___3 & 7L;
#line 235
  gbhw_ch[3].div_ctr = 0L;
#line 236
  gbhw_ch[3].div_tc = (long )(1 << shift);
#line 237
  if (div___3 & 8L) {
#line 238
    tap1___0 = (uint32_t )64;
#line 239
    tap2___0 = (uint32_t )32;
  } else {
#line 241
    tap1___0 = (uint32_t )16384;
#line 242
    tap2___0 = (uint32_t )8192;
  }
#line 244
  lfsr___0 |= 1U;
#line 245
  if (rate___1) {
#line 245
    gbhw_ch[3].div_tc *= rate___1;
  } else {
#line 246
    gbhw_ch[3].div_tc /= 2L;
  }
#line 247
  if (addr == 65314U) {
#line 247
    goto switch_break;
  }
#line 250
  gbhw_ch[chn].len_enable = (long )(((int )ioregs___0[35] & 64) > 0);
#line 251
  goto switch_break;
  case_65317: /* CIL Label */ 
#line 253
  gbhw_ch[0].leftgate = (long )(((int )val & 16) > 0);
#line 254
  gbhw_ch[0].rightgate = (long )(((int )val & 1) > 0);
#line 255
  gbhw_ch[1].leftgate = (long )(((int )val & 32) > 0);
#line 256
  gbhw_ch[1].rightgate = (long )(((int )val & 2) > 0);
#line 257
  gbhw_ch[2].leftgate = (long )(((int )val & 64) > 0);
#line 258
  gbhw_ch[2].rightgate = (long )(((int )val & 4) > 0);
#line 259
  gbhw_ch[3].leftgate = (long )(((int )val & 128) > 0);
#line 260
  gbhw_ch[3].rightgate = (long )(((int )val & 8) > 0);
#line 261
  goto switch_break;
  case_65318: /* CIL Label */ 
#line 263
  ioregs___0[38] = (uint8_t )128;
#line 264
  goto switch_break;
  case_65535: /* CIL Label */ 
  case_65343: /* CIL Label */ 
  case_65342: /* CIL Label */ 
  case_65341: /* CIL Label */ 
  case_65340: /* CIL Label */ 
  case_65339: /* CIL Label */ 
  case_65338: /* CIL Label */ 
  case_65337: /* CIL Label */ 
  case_65336: /* CIL Label */ 
  case_65335: /* CIL Label */ 
  case_65334: /* CIL Label */ 
  case_65333: /* CIL Label */ 
  case_65332: /* CIL Label */ 
  case_65331: /* CIL Label */ 
  case_65330: /* CIL Label */ 
  case_65329: /* CIL Label */ 
  case_65328: /* CIL Label */ 
  case_65327: /* CIL Label */ 
  case_65326: /* CIL Label */ 
  case_65325: /* CIL Label */ 
  case_65324: /* CIL Label */ 
  case_65323: /* CIL Label */ 
  case_65322: /* CIL Label */ 
  case_65321: /* CIL Label */ 
  case_65320: /* CIL Label */ 
  case_65319: /* CIL Label */ 
  case_65316: /* CIL Label */ 
  case_65280: /* CIL Label */ 
#line 293
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iowrite to 0x%04x unimplemented (val=%02x).\n",
          addr, (int )val);
  }
  }
#line 296
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) intram_put___0)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 302
  intram___0[addr & 8191U] = val;
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) extram_put___0)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 307
  extram___0[addr & 8191U] = val;
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound_sweep___0)(void) 
{ 
  long i ;
  long val ;

  {
#line 314
  if (gbhw_ch[0].sweep_tc) {
#line 315
    (gbhw_ch[0].sweep_ctr) --;
#line 316
    if (gbhw_ch[0].sweep_ctr < 0L) {
#line 317
      val = gbhw_ch[0].div_tc >> gbhw_ch[0].sweep_shift;
#line 319
      gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 320
      if (gbhw_ch[0].sweep_dir) {
#line 321
        if (gbhw_ch[0].div_tc < 2048L - val) {
#line 321
          gbhw_ch[0].div_tc += val;
        }
      } else
#line 323
      if (gbhw_ch[0].div_tc > val) {
#line 323
        gbhw_ch[0].div_tc -= val;
      }
#line 325
      gbhw_ch[0].duty_tc = (gbhw_ch[0].div_tc * gbhw_ch[0].duty_ctr) / 8L;
    }
  }
#line 328
  i = 0L;
  {
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < 4L)) {
#line 328
      goto while_break;
    }
#line 329
    if (gbhw_ch[i].len > 0L) {
#line 329
      if (gbhw_ch[i].len_enable) {
#line 330
        (gbhw_ch[i].len) --;
#line 331
        if (gbhw_ch[i].len == 0L) {
#line 332
          gbhw_ch[i].volume = 0L;
#line 333
          gbhw_ch[i].env_tc = 0L;
        }
      }
    }
#line 336
    if (gbhw_ch[i].env_tc) {
#line 337
      (gbhw_ch[i].env_ctr) --;
#line 338
      if (gbhw_ch[i].env_ctr <= 0L) {
#line 339
        gbhw_ch[i].env_ctr = gbhw_ch[i].env_tc;
#line 340
        if (! gbhw_ch[i].env_dir) {
#line 341
          if (gbhw_ch[i].volume > 0L) {
#line 342
            (gbhw_ch[i].volume) --;
          }
        } else
#line 344
        if (gbhw_ch[i].volume < 15L) {
#line 345
          (gbhw_ch[i].volume) ++;
        }
      }
    }
#line 328
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (master_fade___0) {
#line 351
    master_volume___0 += master_fade___0;
#line 352
    if (master_fade___0 > 0L) {
#line 352
      if (master_volume___0 >= master_dstvol___0) {
#line 356
        master_fade___0 = 0L;
#line 357
        master_volume___0 = master_dstvol___0;
      } else {
#line 352
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 352
    if (master_fade___0 < 0L) {
#line 352
      if (master_volume___0 <= master_dstvol___0) {
#line 356
        master_fade___0 = 0L;
#line 357
        master_volume___0 = master_dstvol___0;
      }
    }
  }
#line 361
  return;
}
}
#line 378 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_flush_buffer___0)(void) 
{ 
  long i ;
  long overlap ;
  long l_smpl ;
  long r_smpl ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 384
  if (! ((unsigned long )soundbuf___0 != (unsigned long )((void *)0))) {
    {
    {
#line 384
    __assert_fail("soundbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  384U, "gb_flush_buffer");
    }
    }
  }
#line 385
  if (! ((unsigned long )impbuf___0 != (unsigned long )((void *)0))) {
    {
    {
#line 385
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  385U, "gb_flush_buffer");
    }
    }
  }
#line 388
  l_smpl = soundbuf___0->l_lvl;
#line 389
  r_smpl = soundbuf___0->r_lvl;
#line 390
  i = 0L;
  {
  {
#line 390
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < soundbuf___0->samples)) {
#line 390
      goto while_break;
    }
#line 391
    l_smpl += (long )*(impbuf___0->data + i * 2L);
#line 392
    r_smpl += (long )*(impbuf___0->data + (i * 2L + 1L));
#line 393
    *(soundbuf___0->data + i * 2L) = (int16_t )((l_smpl * master_volume___0) / 65536L);
#line 394
    *(soundbuf___0->data + (i * 2L + 1L)) = (int16_t )((r_smpl * master_volume___0) / 65536L);
#line 395
    if (l_smpl > lmaxval___0) {
#line 395
      lmaxval___0 = l_smpl;
    }
#line 396
    if (l_smpl < lminval___0) {
#line 396
      lminval___0 = l_smpl;
    }
#line 397
    if (r_smpl > rmaxval___0) {
#line 397
      rmaxval___0 = r_smpl;
    }
#line 398
    if (r_smpl < rminval___0) {
#line 398
      rminval___0 = r_smpl;
    }
#line 390
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  soundbuf___0->pos = soundbuf___0->samples;
#line 401
  soundbuf___0->l_lvl = l_smpl;
#line 402
  soundbuf___0->r_lvl = r_smpl;
#line 404
  if ((unsigned long )callback___0 != (unsigned long )((void *)0)) {
    {
    {
#line 404
    (*callback___0)(soundbuf___0, callbackpriv___0);
    }
    }
  }
  {
#line 406
  overlap = impbuf___0->samples - soundbuf___0->samples;
  {
#line 407
  memmove((void *)impbuf___0->data, (void const   *)(impbuf___0->data + 2L * soundbuf___0->samples),
          (size_t )(4L * overlap));
  }
  {
#line 408
  memset((void *)(impbuf___0->data + 2L * overlap), 0, (size_t )(impbuf___0->bytes - 4L * overlap));
  }
  }
#line 409
  if (! (impbuf___0->bytes == impbuf___0->samples * 4L)) {
    {
    {
#line 409
    __assert_fail("impbuf->bytes == impbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  409U, "gb_flush_buffer");
    }
    }
  }
#line 410
  if (! (soundbuf___0->bytes == soundbuf___0->samples * 4L)) {
    {
    {
#line 410
    __assert_fail("soundbuf->bytes == soundbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  410U, "gb_flush_buffer");
    }
    }
  }
  {
  {
#line 411
  memset((void *)soundbuf___0->data, 0, (size_t )soundbuf___0->bytes);
  }
#line 412
  soundbuf___0->pos = 0L;
#line 414
  impbuf___0->cycles = (long )((long long )impbuf___0->cycles - (sound_div_tc___0 * (long long )soundbuf___0->samples) / 65536LL);
  }
#line 415
  return;
}
}
#line 417 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_change_level___0)(long l_ofs , long r_ofs ) 
{ 
  long pos ;
  long imp_idx ;
  long imp_l ;
  long imp_r ;
  long i ;
  short *ptr ;
  long bufi ;
  long impi ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 421
  imp_l = (long )(- (1 << impulse_w_shift___0) / 2);
#line 422
  imp_r = (long )((1 << impulse_w_shift___0) / 2);
#line 424
  ptr = base_impulse___0;
#line 426
  if (! ((unsigned long )impbuf___0 != (unsigned long )((void *)0))) {
    {
    {
#line 426
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  426U, "gb_change_level");
    }
    }
  }
#line 427
  pos = (long )(((long long )impbuf___0->cycles * 65536LL) / sound_div_tc___0);
#line 428
  imp_idx = (long )(((long long )(impbuf___0->cycles << impulse_n_shift___0) * 65536LL) / sound_div_tc___0) & (long )((1 << impulse_n_shift___0) - 1);
#line 429
  if (! (pos + imp_r < impbuf___0->samples)) {
    {
    {
#line 429
    __assert_fail("pos + imp_r < impbuf->samples", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  429U, "gb_change_level");
    }
    }
  }
#line 430
  if (! (pos + imp_l >= 0L)) {
    {
    {
#line 430
    __assert_fail("pos + imp_l >= 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  430U, "gb_change_level");
    }
    }
  }
#line 432
  ptr += imp_idx * (long )(1 << impulse_w_shift___0);
#line 434
  i = imp_l;
  {
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < imp_r)) {
#line 434
      goto while_break;
    }
#line 435
    bufi = pos + i;
#line 436
    impi = i + (long )((1 << impulse_w_shift___0) / 2);
#line 437
    *(impbuf___0->data + bufi * 2L) = (int16_t )((long )*(impbuf___0->data + bufi * 2L) + (long )*(ptr + impi) * l_ofs);
#line 438
    *(impbuf___0->data + (bufi * 2L + 1L)) = (int16_t )((long )*(impbuf___0->data + (bufi * 2L + 1L)) + (long )*(ptr + impi) * r_ofs);
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  impbuf___0->l_lvl += l_ofs * 256L;
#line 442
  impbuf___0->r_lvl += r_ofs * 256L;
#line 443
  return;
}
}
#line 449
static void ( __attribute__((__regparm__(3))) gb_sound___0)(long cycles ) ;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_l___0  =    0L;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_r___0  =    0L;
#line 511 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long val___2  ;
#line 445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound___0)(long cycles ) 
{ 
  long i ;
  long j ;
  long l_lvl ;
  long r_lvl ;
  long pos ;
  long tmp ;
  long val ;
  long index___0 ;
  long shift ;
  long old_l___3 ;
  long old_r___3 ;
  long l_diff ;
  long r_diff ;
  long val___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 448
  l_lvl = 0L;
#line 448
  r_lvl = 0L;
#line 451
  if (! ((unsigned long )impbuf___0 != (unsigned long )((void *)0))) {
    {
    {
#line 451
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  451U, "gb_sound");
    }
    }
  }
#line 453
  j = 0L;
  {
  {
#line 453
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 453
    if (! (j < cycles)) {
#line 453
      goto while_break;
    }
#line 454
    main_div___0 ++;
#line 455
    (impbuf___0->cycles) ++;
#line 456
    if ((long long )impbuf___0->cycles * 65536LL >= sound_div_tc___0 * (long long )(impbuf___0->samples - (long )((1 << impulse_w_shift___0) / 2))) {
      {
      {
#line 457
      gb_flush_buffer___0();
      }
      }
    }
#line 459
    if (gbhw_ch[2].master) {
#line 460
      (gbhw_ch[2].div_ctr) --;
#line 461
      if (gbhw_ch[2].div_ctr <= 0L) {
#line 462
        tmp = ch3pos___0;
#line 462
        ch3pos___0 ++;
#line 462
        pos = tmp;
#line 463
        index___0 = (pos >> 1) & 15L;
#line 463
        shift = (~ pos & 1L) << 2;
#line 463
        val = (long )(((int )*(& ioregs___0[48] + index___0) >> shift) & 15);
#line 464
        old_l___3 = gbhw_ch[2].l_lvl;
#line 465
        old_r___3 = gbhw_ch[2].r_lvl;
#line 467
        gbhw_ch[2].div_ctr = gbhw_ch[2].div_tc * 2L;
#line 468
        if (gbhw_ch[2].volume) {
#line 469
          val >>= gbhw_ch[2].volume - 1L;
        } else {
#line 470
          val = 0L;
        }
#line 471
        val *= 2L;
#line 472
        if (gbhw_ch[2].volume) {
#line 472
          if (! gbhw_ch[2].mute) {
#line 473
            if (gbhw_ch[2].leftgate) {
#line 474
              gbhw_ch[2].l_lvl = val;
            }
#line 475
            if (gbhw_ch[2].rightgate) {
#line 476
              gbhw_ch[2].r_lvl = val;
            }
          }
        }
        {
#line 478
        l_diff = gbhw_ch[2].l_lvl - old_l___3;
#line 479
        r_diff = gbhw_ch[2].r_lvl - old_r___3;
        {
#line 480
        gb_change_level___0(l_diff, r_diff);
        }
        }
      }
    }
#line 484
    if (main_div___0 > (long )main_div_tc___0) {
#line 485
      main_div___0 -= (long )main_div_tc___0;
#line 487
      i = 0L;
      {
      {
#line 487
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 487
        if (! (i < 2L)) {
#line 487
          goto while_break___0;
        }
#line 487
        if (gbhw_ch[i].master) {
#line 488
          val___0 = gbhw_ch[i].volume;
#line 489
          if (gbhw_ch[i].div_ctr > gbhw_ch[i].duty_tc) {
#line 490
            val___0 = - val___0;
          }
#line 492
          if (! gbhw_ch[i].mute) {
#line 493
            if (gbhw_ch[i].leftgate) {
#line 494
              gbhw_ch[i].l_lvl = val___0;
            }
#line 495
            if (gbhw_ch[i].rightgate) {
#line 496
              gbhw_ch[i].r_lvl = val___0;
            }
          }
#line 498
          (gbhw_ch[i].div_ctr) --;
#line 499
          if (gbhw_ch[i].div_ctr <= 0L) {
#line 500
            gbhw_ch[i].div_ctr = gbhw_ch[i].div_tc;
          }
        }
#line 487
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 503
      i = 0L;
      {
      {
#line 503
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 503
        if (! (i < 2L)) {
#line 503
          goto while_break___1;
        }
#line 504
        l_lvl += gbhw_ch[i].l_lvl;
#line 505
        r_lvl += gbhw_ch[i].r_lvl;
#line 503
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 508
      if (gbhw_ch[3].master) {
#line 512
        if (! gbhw_ch[3].mute) {
#line 513
          if (gbhw_ch[3].leftgate) {
#line 514
            gbhw_ch[3].l_lvl = val___2;
          }
#line 515
          if (gbhw_ch[3].rightgate) {
#line 516
            gbhw_ch[3].r_lvl = val___2;
          }
        }
#line 518
        (gbhw_ch[3].div_ctr) --;
#line 519
        if (gbhw_ch[3].div_ctr <= 0L) {
#line 520
          gbhw_ch[3].div_ctr = gbhw_ch[3].div_tc;
#line 521
          lfsr___0 = (lfsr___0 << 1) | (unsigned int )(((lfsr___0 & tap1___0) > 0U) ^ ((lfsr___0 & tap2___0) > 0U));
#line 522
          val___2 = gbhw_ch[3].volume * (long )((lfsr___0 & 2U) - 1U);
        }
      }
#line 525
      l_lvl += gbhw_ch[3].l_lvl;
#line 526
      r_lvl += gbhw_ch[3].r_lvl;
#line 528
      if (l_lvl != old_l___0) {
        {
        {
#line 529
        gb_change_level___0(l_lvl - old_l___0, r_lvl - old_r___0);
        }
#line 530
        old_l___0 = l_lvl;
#line 531
        old_r___0 = r_lvl;
        }
      } else
#line 528
      if (r_lvl != old_r___0) {
        {
        {
#line 529
        gb_change_level___0(l_lvl - old_l___0, r_lvl - old_r___0);
        }
#line 530
        old_l___0 = l_lvl;
#line 531
        old_r___0 = r_lvl;
        }
      }
#line 534
      sweep_div___0 ++;
#line 535
      if (sweep_div___0 >= (long )sweep_div_tc___0) {
        {
#line 536
        sweep_div___0 = 0L;
        {
#line 537
        gb_sound_sweep___0();
        }
        }
      }
    }
#line 453
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return;
}
}
#line 555 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gbhw_impbuf_reset___0)(struct gbhw_buffer *impbuf___3 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 557
  if (! (sound_div_tc___0 != 0LL)) {
    {
    {
#line 557
    __assert_fail("sound_div_tc != 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  557U, "gbhw_impbuf_reset");
    }
    }
  }
  {
#line 558
  impbuf___3->cycles = (long )(((sound_div_tc___0 * (long long )(1 << impulse_w_shift___0)) / 2LL) / 65536LL);
#line 559
  impbuf___3->l_lvl = 0L;
#line 560
  impbuf___3->r_lvl = 0L;
  {
#line 561
  memset((void *)impbuf___3->data, 0, (size_t )impbuf___3->bytes);
  }
  }
#line 562
  return;
}
}
#line 380 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 13 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/util.c"
__inline long rand_long(long max ) 
{ 
  int tmp ;

  {
  {
  {
#line 16
  tmp = rand();
  }
  }
#line 16
  return ((long )(((double )max * (double )tmp) / ((double )2147483647 + 1.0)));
}
}
#line 19 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/util.c"
void shuffle_long(long *array , long elements ) 
{ 
  long i ;
  long j ;
  long temp ;

  {
#line 24
  i = elements - 1L;
  {
  {
#line 24
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i > 0L)) {
#line 24
      goto while_break;
    }
    {
    {
#line 25
    j = rand_long(i);
    }
#line 26
    temp = *(array + i);
#line 27
    *(array + i) = *(array + j);
#line 28
    *(array + j) = temp;
#line 24
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 668
extern int puts(char const   *__s ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/common.h"
__inline static void i18n_init(void) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 60
  tmp = setlocale(6, "");
  }
  }
#line 60
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"setlocale() failed\n");
    }
    }
  }
  {
  {
#line 63
  tmp___2 = bindtextdomain("gbsplay", "/usr/local/share/locale");
  }
  }
#line 63
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
    {
#line 64
    tmp___0 = __errno_location();
    }
    {
#line 64
    tmp___1 = strerror(*tmp___0);
    }
    {
#line 64
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bindtextdomain() failed: %s\n",
            tmp___1);
    }
    }
  }
  {
  {
#line 66
  tmp___5 = textdomain("gbsplay");
  }
  }
#line 66
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
    {
#line 67
    tmp___3 = __errno_location();
    }
    {
#line 67
    tmp___4 = strerror(*tmp___3);
    }
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"textdomain() failed: %s\n",
            tmp___4);
    }
    }
  }
#line 69
  return;
}
}
#line 113 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/common.h"
__inline static long is_le_machine(void) 
{ 


  {
#line 114
  return (1L);
}
}
#line 117 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/common.h"
__inline static long is_be_machine(void) 
{ 


  {
#line 118
  return (0L);
}
}
#line 382 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 623 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 67 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 71
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
#line 266 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 31 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.h"
void ( __attribute__((__regparm__(3))) plugout_list_plugins)(void) ;
#line 32
struct output_plugin  const  *( __attribute__((__regparm__(3))) plugout_select_by_name)(char const   *name ) ;
#line 44 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char notelookup[432]  ;
#line 45 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char vollookup[80]  ;
#line 46 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char const   vols[5]  = {      (char const   )' ',      (char const   )'-',      (char const   )'=',      (char const   )'#', 
        (char const   )'%'};
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *myname___0  ;
#line 50 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long quit  =    0L;
#line 51 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static struct termios ots  ;
#line 52 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long *subsong_playlist  ;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_playlist_idx  =    0L;
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long pause_mode  =    0L;
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
unsigned long random_seed  ;
#line 60 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long refresh_delay  =    33L;
#line 63 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long playmode  =    1L;
#line 64 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long loopmode  =    0L;
#line 65 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static enum plugout_endian endian  =    (enum plugout_endian )2;
#line 66 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long verbosity  =    3L;
#line 67 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long rate  =    44100L;
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long silence_timeout  =    2L;
#line 69 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long fadeout  =    3L;
#line 70 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_gap  =    2L;
#line 71 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_start  =    -1L;
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_stop  =    -1L;
#line 73 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_timeout  =    120L;
#line 74 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long redraw  =    0L;
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char const   cfgfile[11]  = 
#line 76
  {      (char const   )'.',      (char const   )'g',      (char const   )'b',      (char const   )'s', 
        (char const   )'p',      (char const   )'l',      (char const   )'a',      (char const   )'y', 
        (char const   )'r',      (char const   )'c',      (char const   )'\000'};
#line 78 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *sound_name  =    (char *)"oss";
#line 79 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *sound_description  ;
#line 80 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) (*sound_open))(enum plugout_endian endian ,
                                                             long rate )  ;
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int ( __attribute__((__regparm__(3))) (*sound_skip))(int subsong )  ;
#line 82 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int ( __attribute__((__regparm__(3))) (*sound_io))(long cycles , uint32_t addr ,
                                                          uint8_t val )  ;
#line 83 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static ssize_t ( __attribute__((__regparm__(3))) (*sound_write))(void const   *buf ,
                                                                 size_t count )  ;
#line 84 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) (*sound_close))(void)  ;
#line 86 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int16_t samples[4096]  ;
#line 87 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static struct gbhw_buffer buf  =    {samples, 0L, 0L, 0L, (long )sizeof(samples), 0L, 0L};
#line 94 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static struct cfg_option  const  options[11]  = 
#line 94
  {      {(char *)"rate", (void *)(& rate), & cfg_long}, 
        {(char *)"refresh_delay", (void *)(& refresh_delay), & cfg_long}, 
        {(char *)"verbosity", (void *)(& verbosity), & cfg_long}, 
        {(char *)"endian", (void *)(& endian), & cfg_endian}, 
        {(char *)"subsong_timeout", (void *)(& subsong_timeout), & cfg_long}, 
        {(char *)"subsong_gap", (void *)(& subsong_gap), & cfg_long}, 
        {(char *)"fadeout", (void *)(& fadeout), & cfg_long}, 
        {(char *)"silence_timeout", (void *)(& silence_timeout), & cfg_long}, 
        {(char *)"output_plugin", (void *)(& sound_name), & cfg_string}, 
        {(char *)"loop", (void *)(& loopmode), & cfg_long}, 
        {(char *)((void *)0), (void *)0, (void ( __attribute__((__regparm__(3))) (*))(void *ptr ))((void *)0)}};
#line 109 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) getnote)(long div___2 ) 
{ 
  long n ;
  double tmp ;

  {
#line 111
  n = 0L;
#line 113
  if (div___2 > 0L) {
    {
    {
#line 114
    tmp = log((double )(262144L / div___2));
    }
#line 114
    n = (long )((tmp / .69314718055994530941 - 5.78135971352465960412) * (double )12 + .2);
    }
  }
#line 117
  if (n < 0L) {
#line 118
    n = 0L;
  } else
#line 119
  if (n >= 108L) {
#line 120
    n = 8L;
  }
#line 123
  return (n);
}
}
#line 126 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) precalc_notes)(void) 
{ 
  long i ;
  char *s ;
  long n ;

  {
#line 129
  i = 0L;
  {
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < 108L)) {
#line 129
      goto while_break;
    }
#line 130
    s = notelookup + 4L * i;
#line 131
    n = i % 12L;
#line 133
    *(s + 2) = (char )(48L + i / 12L);
#line 134
    n += (long )((n > 2L) + (n > 7L));
#line 135
    *(s + 0) = (char )(65L + (n >> 1));
#line 136
    if (n & 1L) {
#line 137
      *(s + 1) = (char )'#';
    } else {
#line 139
      *(s + 1) = (char )'-';
    }
#line 129
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 146 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char buf___0[5]  ;
#line 144 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *( __attribute__((__regparm__(3))) reverse_vol)(char *s ) 
{ 
  long i ;

  {
#line 149
  i = 0L;
  {
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < 4L)) {
#line 149
      goto while_break;
    }
#line 150
    buf___0[i] = *(s + (3L - i));
#line 149
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  buf___0[4] = (char)0;
#line 154
  return (buf___0);
}
}
#line 157 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) precalc_vols)(void) 
{ 
  long i ;
  long k ;
  long j ;
  char *s ;

  {
#line 160
  k = 0L;
  {
  {
#line 160
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < 16L)) {
#line 160
      goto while_break;
    }
#line 162
    s = vollookup + 5L * k;
#line 163
    i = k;
#line 164
    j = 0L;
    {
    {
#line 164
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 164
      if (! (j < 4L)) {
#line 164
        goto while_break___0;
      }
#line 165
      if (i >= 4L) {
#line 166
        *(s + j) = (char )vols[4];
#line 167
        i -= 4L;
      } else {
#line 169
        *(s + j) = (char )vols[i];
#line 170
        i = 0L;
      }
#line 164
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 160
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) swap_endian)(struct gbhw_buffer *buf___3 ) 
{ 
  long i ;
  short x ;

  {
#line 180
  i = 0L;
  {
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )i < (unsigned long )buf___3->bytes / sizeof(short ))) {
#line 180
      goto while_break;
    }
#line 181
    x = *(buf___3->data + i);
#line 182
    *(buf___3->data + i) = (int16_t )((((int )x & 255) << 8) | ((int )x >> 8));
#line 180
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 186 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) iocallback___1)(long cycles , uint32_t addr ,
                                                              uint8_t val , void *priv ) 
{ 


  {
#line 188
  if (sound_io) {
    {
    {
#line 189
    (*sound_io)(cycles, addr, val);
    }
    }
  }
#line 190
  return;
}
}
#line 192 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) callback___1)(struct gbhw_buffer *buf___3 ,
                                                            void *priv ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
  {
#line 194
  tmp = is_le_machine();
  }
  }
#line 194
  if (tmp) {
#line 194
    if ((unsigned int )endian == 0U) {
      {
      {
#line 196
      swap_endian(buf___3);
      }
      }
    } else {
#line 194
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 194
    tmp___0 = is_be_machine();
    }
    }
#line 194
    if (tmp___0) {
#line 194
      if ((unsigned int )endian == 1U) {
        {
        {
#line 196
        swap_endian(buf___3);
        }
        }
      }
    }
  }
  {
  {
#line 198
  (*sound_write)((void const   *)buf___3->data, (size_t )((unsigned long )(buf___3->pos * 2L) * sizeof(int16_t )));
  }
#line 199
  buf___3->pos = 0L;
  }
#line 200
  return;
}
}
#line 202 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long *( __attribute__((__regparm__(3))) setup_playlist)(long songs ) 
{ 
  long i ;
  long *playlist ;
  void *tmp ;

  {
  {
  {
#line 208
  tmp = calloc((size_t )songs, (size_t )sizeof(long ));
  }
#line 208
  playlist = (long *)tmp;
#line 209
  i = 0L;
  }
  {
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i < songs)) {
#line 209
      goto while_break;
    }
#line 210
    *(playlist + i) = i;
#line 209
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 214
  srand((unsigned int )random_seed);
  }
  {
#line 215
  shuffle_long(playlist, songs);
  }
  }
#line 217
  return (playlist);
}
}
#line 220 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) get_next_subsong)(struct gbs *gbs ) 
{ 
  long next ;

  {
#line 223
  next = -1L;
  {
#line 226
  if (playmode == 2L) {
#line 226
    goto case_2;
  }
#line 230
  if (playmode == 3L) {
#line 230
    goto case_3;
  }
#line 241
  if (playmode == 1L) {
#line 241
    goto case_1;
  }
#line 224
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 227
  next = rand_long(gbs->songs);
  }
  }
#line 228
  goto switch_break;
  case_3: /* CIL Label */ 
#line 231
  subsong_playlist_idx ++;
#line 232
  if (subsong_playlist_idx == gbs->songs) {
    {
    {
#line 233
    free((void *)subsong_playlist);
    }
#line 234
    random_seed ++;
    {
#line 235
    subsong_playlist = setup_playlist(gbs->songs);
    }
#line 236
    subsong_playlist_idx = 0L;
    }
  }
#line 238
  next = *(subsong_playlist + subsong_playlist_idx);
#line 239
  goto switch_break;
  case_1: /* CIL Label */ 
#line 242
  next = gbs->subsong + 1L;
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 245
  return (next);
}
}
#line 248 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int ( __attribute__((__regparm__(3))) get_prev_subsong)(struct gbs *gbs ) 
{ 
  int prev ;
  long tmp ;

  {
#line 251
  prev = -1;
  {
#line 254
  if (playmode == 2L) {
#line 254
    goto case_2;
  }
#line 258
  if (playmode == 3L) {
#line 258
    goto case_3;
  }
#line 269
  if (playmode == 1L) {
#line 269
    goto case_1;
  }
#line 252
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 255
  tmp = rand_long(gbs->songs);
  }
#line 255
  prev = (int )tmp;
  }
#line 256
  goto switch_break;
  case_3: /* CIL Label */ 
#line 259
  subsong_playlist_idx --;
#line 260
  if (subsong_playlist_idx == -1L) {
    {
    {
#line 261
    free((void *)subsong_playlist);
    }
#line 262
    random_seed --;
    {
#line 263
    subsong_playlist = setup_playlist(gbs->songs);
    }
#line 264
    subsong_playlist_idx = gbs->songs - 1L;
    }
  }
#line 266
  prev = (int )*(subsong_playlist + subsong_playlist_idx);
#line 267
  goto switch_break;
  case_1: /* CIL Label */ 
#line 270
  prev = (int )(gbs->subsong - 1L);
#line 271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 273
  return (prev);
}
}
#line 276 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) setup_playmode)(struct gbs *gbs ) 
{ 


  {
  {
#line 281
  if (playmode == 2L) {
#line 281
    goto case_2;
  }
#line 286
  if (playmode == 3L) {
#line 286
    goto case_3;
  }
#line 301
  if (playmode == 1L) {
#line 301
    goto case_1;
  }
#line 279
  goto switch_break;
  case_2: /* CIL Label */ 
#line 282
  if (gbs->subsong == -1L) {
    {
    {
#line 283
    gbs->subsong = get_next_subsong(gbs);
    }
    }
  }
  case_3: /* CIL Label */ 
  {
  {
#line 287
  subsong_playlist = setup_playlist(gbs->songs);
  }
#line 288
  subsong_playlist_idx = 0L;
  }
#line 289
  if (gbs->subsong == -1L) {
#line 290
    gbs->subsong = *(subsong_playlist + 0);
  } else {
    {
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 295
      if (! (*(subsong_playlist + 0) != gbs->subsong)) {
#line 295
        goto while_break;
      }
      {
#line 296
      random_seed ++;
      {
#line 297
      subsong_playlist = setup_playlist(gbs->songs);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  case_1: /* CIL Label */ 
#line 302
  if (gbs->subsong == -1L) {
#line 303
    gbs->subsong = gbs->defaultsong - 1L;
  }
#line 305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 309 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) nextsubsong_cb)(struct gbs *gbs , void *priv ) 
{ 
  long subsong ;
  long tmp ;

  {
  {
  {
#line 311
  tmp = get_next_subsong(gbs);
  }
#line 311
  subsong = tmp;
  }
#line 313
  if (gbs->subsong == subsong_stop) {
#line 313
    goto _L;
  } else
#line 313
  if (subsong >= gbs->songs) {
    _L: /* CIL Label */ 
#line 315
    if (loopmode) {
      {
#line 316
      subsong = subsong_start;
      {
#line 317
      setup_playmode(gbs);
      }
      }
    } else {
#line 319
      return (0L);
    }
  }
  {
  {
#line 323
  gbs_init(gbs, subsong);
  }
  }
#line 324
  if (sound_skip) {
    {
    {
#line 325
    (*sound_skip)((int )subsong);
    }
    }
  }
#line 326
  return (1L);
}
}
#line 329 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
char *endian_str(long endian___1 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 332
  if (endian___1 == 0L) {
#line 332
    goto case_0;
  }
#line 333
  if (endian___1 == 1L) {
#line 333
    goto case_1;
  }
#line 334
  if (endian___1 == 2L) {
#line 334
    goto case_2;
  }
#line 335
  goto switch_default;
  case_0: /* CIL Label */ 
#line 332
  return ((char *)"big");
  case_1: /* CIL Label */ 
#line 333
  return ((char *)"little");
  case_2: /* CIL Label */ 
#line 334
  return ((char *)"native");
  switch_default: /* CIL Label */ 
#line 335
  return ((char *)"invalid");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 339 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) usage___0)(long exitcode ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 341
  if (exitcode) {
#line 341
    tmp = stderr;
  } else {
#line 341
    tmp = stdout;
  }
  {
#line 341
  out = tmp;
  {
#line 342
  tmp___0 = endian_str((long )endian);
  }
  {
#line 342
  tmp___1 = _("Usage: %s [option(s)] <gbs-file> [start_at_subsong [stop_at_subsong] ]\n\nAvailable options are:\n  -E        endian, b == big, l == little, n == native (%s)\n  -f        set fadeout (%ld seconds)\n  -g        set subsong gap (%ld seconds)\n  -h        display this help and exit\n  -l        loop mode\n  -o        select output plugin (%s)\n            \'list\' shows available plugins\n  -q        reduce verbosity\n  -r        set samplerate (%ldHz)\n  -R        set refresh delay (%ld milliseconds)\n  -t        set subsong timeout (%ld seconds)\n  -T        set silence timeout (%ld seconds)\n  -v        increase verbosity\n  -V        print version and exit\n  -z        play subsongs in shuffle mode\n  -Z        play subsongs in random mode (repetitions possible)\n  -1 to -4  mute a channel on startup\n");
  }
  {
#line 342
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
          myname___0, tmp___0, fadeout, subsong_gap, sound_name, rate, refresh_delay,
          subsong_timeout, silence_timeout);
  }
  {
#line 372
  exit((int )exitcode);
  }
  }
}
}
#line 375 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) version___0)(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 377
  puts("gbsplay 0.0.91");
  }
  {
#line 378
  exit(0);
  }
  }
}
}
#line 381 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) parseopts___0)(int *argc , char ***argv ) 
{ 
  long res ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 384
  myname___0 = *(*(argv + 0));
  {
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 385
    tmp___3 = getopt(*argc, (char * const  *)*argv, "1234E:f:g:hlo:qr:R:t:T:vVzZ");
    }
#line 385
    res = (long )tmp___3;
    }
#line 385
    if (! (res != -1L)) {
#line 385
      goto while_break;
    }
    {
#line 393
    if (res == 52L) {
#line 393
      goto case_52;
    }
#line 393
    if (res == 51L) {
#line 393
      goto case_52;
    }
#line 393
    if (res == 50L) {
#line 393
      goto case_52;
    }
#line 393
    if (res == 49L) {
#line 393
      goto case_52;
    }
#line 396
    if (res == 69L) {
#line 396
      goto case_69;
    }
#line 408
    if (res == 102L) {
#line 408
      goto case_102;
    }
#line 411
    if (res == 103L) {
#line 411
      goto case_103;
    }
#line 414
    if (res == 104L) {
#line 414
      goto case_104;
    }
#line 417
    if (res == 108L) {
#line 417
      goto case_108;
    }
#line 420
    if (res == 111L) {
#line 420
      goto case_111;
    }
#line 423
    if (res == 113L) {
#line 423
      goto case_113;
    }
#line 426
    if (res == 114L) {
#line 426
      goto case_114;
    }
#line 429
    if (res == 82L) {
#line 429
      goto case_82;
    }
#line 432
    if (res == 116L) {
#line 432
      goto case_116;
    }
#line 435
    if (res == 84L) {
#line 435
      goto case_84;
    }
#line 438
    if (res == 118L) {
#line 438
      goto case_118;
    }
#line 441
    if (res == 86L) {
#line 441
      goto case_86;
    }
#line 444
    if (res == 122L) {
#line 444
      goto case_122;
    }
#line 447
    if (res == 90L) {
#line 447
      goto case_90;
    }
#line 387
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
    {
#line 388
    usage___0(1L);
    }
    }
#line 389
    goto switch_break;
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 394
    gbhw_ch[res - 49L].mute ^= 1L;
#line 395
    goto switch_break;
    case_69: /* CIL Label */ 
    {
    {
#line 397
    tmp___2 = strcasecmp((char const   *)optarg, "b");
    }
    }
#line 397
    if (tmp___2 == 0) {
#line 398
      endian = (enum plugout_endian )0;
    } else {
      {
      {
#line 399
      tmp___1 = strcasecmp((char const   *)optarg, "l");
      }
      }
#line 399
      if (tmp___1 == 0) {
#line 400
        endian = (enum plugout_endian )1;
      } else {
        {
        {
#line 401
        tmp___0 = strcasecmp((char const   *)optarg, "n");
        }
        }
#line 401
        if (tmp___0 == 0) {
#line 402
          endian = (enum plugout_endian )2;
        } else {
          {
          {
#line 404
          tmp = _("\"%s\" is not a valid endian.\n\n");
          }
          {
#line 404
          printf((char const   */* __restrict  */)tmp, optarg);
          }
          {
#line 405
          usage___0(1L);
          }
          }
        }
      }
    }
#line 407
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 409
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & fadeout);
    }
    }
#line 410
    goto switch_break;
    case_103: /* CIL Label */ 
    {
    {
#line 412
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & subsong_gap);
    }
    }
#line 413
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 415
    usage___0(0L);
    }
    }
#line 416
    goto switch_break;
    case_108: /* CIL Label */ 
#line 418
    loopmode = 1L;
#line 419
    goto switch_break;
    case_111: /* CIL Label */ 
#line 421
    sound_name = optarg;
#line 422
    goto switch_break;
    case_113: /* CIL Label */ 
#line 424
    verbosity --;
#line 425
    goto switch_break;
    case_114: /* CIL Label */ 
    {
    {
#line 427
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & rate);
    }
    }
#line 428
    goto switch_break;
    case_82: /* CIL Label */ 
    {
    {
#line 430
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & refresh_delay);
    }
    }
#line 431
    goto switch_break;
    case_116: /* CIL Label */ 
    {
    {
#line 433
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & subsong_timeout);
    }
    }
#line 434
    goto switch_break;
    case_84: /* CIL Label */ 
    {
    {
#line 436
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & silence_timeout);
    }
    }
#line 437
    goto switch_break;
    case_118: /* CIL Label */ 
#line 439
    verbosity ++;
#line 440
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 442
    version___0();
    }
    }
#line 443
    goto switch_break;
    case_122: /* CIL Label */ 
#line 445
    playmode = 3L;
#line 446
    goto switch_break;
    case_90: /* CIL Label */ 
#line 448
    playmode = 2L;
#line 449
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  *argc -= optind;
#line 453
  *argv += optind;
#line 454
  return;
}
}
#line 456 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) handleuserinput)(struct gbs *gbs ) 
{ 
  char c___3 ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
  {
#line 460
  tmp___0 = read(0, (void *)(& c___3), (size_t )1);
  }
  }
#line 460
  if (tmp___0 != -1) {
    {
#line 462
    if ((int )c___3 == 112) {
#line 462
      goto case_112;
    }
#line 471
    if ((int )c___3 == 110) {
#line 471
      goto case_110;
    }
#line 479
    if ((int )c___3 == 27) {
#line 479
      goto case_27;
    }
#line 479
    if ((int )c___3 == 113) {
#line 479
      goto case_27;
    }
#line 482
    if ((int )c___3 == 32) {
#line 482
      goto case_32;
    }
#line 489
    if ((int )c___3 == 52) {
#line 489
      goto case_52;
    }
#line 489
    if ((int )c___3 == 51) {
#line 489
      goto case_52;
    }
#line 489
    if ((int )c___3 == 50) {
#line 489
      goto case_52;
    }
#line 489
    if ((int )c___3 == 49) {
#line 489
      goto case_52;
    }
#line 461
    goto switch_break;
    case_112: /* CIL Label */ 
    {
    {
#line 463
    tmp = get_prev_subsong(gbs);
    }
#line 463
    gbs->subsong = (long )tmp;
    }
    {
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 464
      if (! (gbs->subsong < 0L)) {
#line 464
        goto while_break;
      }
#line 465
      gbs->subsong += gbs->songs;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 467
    gbs_init(gbs, gbs->subsong);
    }
    }
#line 468
    if (sound_skip) {
      {
      {
#line 469
      (*sound_skip)((int )gbs->subsong);
      }
      }
    }
#line 470
    goto switch_break;
    case_110: /* CIL Label */ 
    {
    {
#line 472
    gbs->subsong = get_next_subsong(gbs);
    }
#line 473
    gbs->subsong %= gbs->songs;
    {
#line 474
    gbs_init(gbs, gbs->subsong);
    }
    }
#line 475
    if (sound_skip) {
      {
      {
#line 476
      (*sound_skip)((int )gbs->subsong);
      }
      }
    }
#line 477
    goto switch_break;
    case_27: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 480
    quit = 1L;
#line 481
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 483
    pause_mode = (long )(! pause_mode);
    {
#line 484
    gbhw_pause(pause_mode);
    }
    }
#line 485
    goto switch_break;
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 490
    gbhw_ch[(int )c___3 - 49].mute ^= 1L;
#line 491
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 494
  return;
}
}
#line 496 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *( __attribute__((__regparm__(3))) notestring)(long ch ) 
{ 
  long n ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 500
  if (gbhw_ch[ch].mute) {
#line 500
    return ((char *)"-M-");
  }
#line 502
  if (gbhw_ch[ch].volume == 0L) {
#line 503
    return ((char *)"---");
  } else
#line 502
  if (gbhw_ch[ch].master == 0L) {
#line 503
    return ((char *)"---");
  }
  {
  {
#line 505
  n = getnote(gbhw_ch[ch].div_tc);
  }
  }
#line 506
  if (ch != 3L) {
#line 506
    return (& notelookup[4L * n]);
  } else {
#line 507
    return ((char *)"nse");
  }
}
}
#line 510 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) chvol)(long ch ) 
{ 
  long v ;

  {
#line 514
  if (gbhw_ch[ch].mute) {
#line 515
    return (0L);
  } else
#line 514
  if (gbhw_ch[ch].master == 0L) {
#line 515
    return (0L);
  }
#line 517
  if (ch == 2L) {
#line 518
    v = (3L - ((gbhw_ch[2].volume + 3L) & 3L)) << 2;
  } else {
#line 519
    v = gbhw_ch[ch].volume;
  }
#line 521
  return (v);
}
}
#line 524 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *( __attribute__((__regparm__(3))) volstring)(long v ) 
{ 


  {
#line 526
  if (v < 0L) {
#line 526
    v = 0L;
  }
#line 527
  if (v > 15L) {
#line 527
    v = 15L;
  }
#line 529
  return (& vollookup[5L * v]);
}
}
#line 532 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) printstatus)(struct gbs *gbs ) 
{ 
  long time___0 ;
  long timem ;
  long times ;
  char *songtitle ;
  long len ;
  long lenm ;
  long lens ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  long tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 534
  time___0 = (long )(gbs->ticks / 4194304LL);
#line 535
  timem = time___0 / 60L;
#line 536
  times = time___0 % 60L;
#line 538
  len = (long )((gbs->subsong_info + gbs->subsong)->len / 1024U);
#line 541
  if (len == 0L) {
#line 542
    len = subsong_timeout;
  }
#line 544
  lenm = len / 60L;
#line 545
  lens = len % 60L;
#line 547
  songtitle = (gbs->subsong_info + gbs->subsong)->title;
#line 548
  if (! songtitle) {
    {
    {
#line 549
    songtitle = _("Untitled");
    }
    }
  }
  {
  {
#line 551
  printf((char const   */* __restrict  */)"\r\033[A\033[ASong %3ld/%3ld (%s)\033[K\n%02ld:%02ld/%02ld:%02ld",
         gbs->subsong + 1L, gbs->songs, songtitle, timem, times, lenm, lens);
  }
  }
#line 556
  if (verbosity > 2L) {
    {
    {
#line 557
    tmp = volstring((long )((int )gbs->rvol / 1024));
    }
    {
#line 557
    tmp___0 = volstring((long )((int )gbs->lvol / 1024));
    }
    {
#line 557
    tmp___1 = reverse_vol(tmp___0);
    }
    {
#line 557
    tmp___2 = chvol(3L);
    }
    {
#line 557
    tmp___3 = volstring(tmp___2);
    }
    {
#line 557
    tmp___4 = notestring(3L);
    }
    {
#line 557
    tmp___5 = chvol(2L);
    }
    {
#line 557
    tmp___6 = volstring(tmp___5);
    }
    {
#line 557
    tmp___7 = notestring(2L);
    }
    {
#line 557
    tmp___8 = chvol(1L);
    }
    {
#line 557
    tmp___9 = volstring(tmp___8);
    }
    {
#line 557
    tmp___10 = notestring(1L);
    }
    {
#line 557
    tmp___11 = chvol(0L);
    }
    {
#line 557
    tmp___12 = volstring(tmp___11);
    }
    {
#line 557
    tmp___13 = notestring(0L);
    }
    {
#line 557
    printf((char const   */* __restrict  */)"  %s %s  %s %s  %s %s  %s %s  [%s|%s]\n",
           tmp___13, tmp___12, tmp___10, tmp___9, tmp___7, tmp___6, tmp___4, tmp___3,
           tmp___1, tmp);
    }
    }
  } else {
    {
    {
#line 565
    puts("");
    }
    }
  }
  {
  {
#line 567
  fflush(stdout);
  }
  }
#line 568
  return;
}
}
#line 574 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
void exit_handler(int signum ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 576
  tmp = _("\nCaught signal %d, exiting...\n");
  }
  {
#line 576
  printf((char const   */* __restrict  */)tmp, signum);
  }
  {
#line 577
  tcsetattr(0, 2, (struct termios  const  *)(& ots));
  }
  {
#line 578
  exit(1);
  }
  }
}
}
#line 581 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
void stop_handler(int signum ) 
{ 


  {
  {
  {
#line 583
  tcsetattr(0, 2, (struct termios  const  *)(& ots));
  }
  }
#line 584
  return;
}
}
#line 586 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
void cont_handler(int signum ) 
{ 
  struct termios ts ;

  {
  {
  {
#line 590
  tcgetattr(0, & ts);
  }
#line 591
  ots = ts;
#line 592
  ts.c_lflag &= 4294967221U;
  {
#line 593
  tcsetattr(0, 2, (struct termios  const  *)(& ts));
  }
  {
#line 594
  fcntl(0, 4, 2048);
  }
#line 596
  redraw = 1L;
  }
#line 597
  return;
}
}
#line 599 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) printinfo)(struct gbs *gbs ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 601
  if (verbosity > 0L) {
    {
    {
#line 602
    gbs_printinfo(gbs, 0L);
    }
    {
#line 603
    tmp = _("\ncommands:  [p]revious subsong   [n]ext subsong   [q]uit player\n           [ ] pause/resume   [1-4] mute channel");
    }
    {
#line 603
    puts((char const   *)tmp);
    }
    }
  }
#line 606
  if (verbosity > 1L) {
    {
    {
#line 607
    puts("\n\n");
    }
    }
  }
#line 609
  redraw = 0L;
#line 610
  return;
}
}
#line 612 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) select_plugin)(void) 
{ 
  struct output_plugin  const  *plugout ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 616
  tmp = strcmp((char const   *)sound_name, "list");
  }
  }
#line 616
  if (tmp == 0) {
    {
    {
#line 617
    plugout_list_plugins();
    }
    {
#line 618
    exit(0);
    }
    }
  }
  {
  {
#line 621
  plugout = plugout_select_by_name((char const   *)sound_name);
  }
  }
#line 622
  if ((unsigned long )plugout == (unsigned long )((void *)0)) {
    {
    {
#line 623
    tmp___0 = _("\"%s\" is not a known output plugin.\n\n");
    }
    {
#line 623
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            sound_name);
    }
    {
#line 625
    exit(1);
    }
    }
  }
#line 628
  sound_open = (long ( __attribute__((__regparm__(3))) (*))(enum plugout_endian endian ,
                                                            long rate ))plugout->open;
#line 629
  sound_skip = (int ( __attribute__((__regparm__(3))) (*))(int subsong ))plugout->skip;
#line 630
  sound_io = (int ( __attribute__((__regparm__(3))) (*))(long cycles , uint32_t addr ,
                                                         uint8_t val ))plugout->io;
#line 631
  sound_write = (ssize_t ( __attribute__((__regparm__(3))) (*))(void const   *buf ,
                                                                size_t count ))plugout->write;
#line 632
  sound_close = (void ( __attribute__((__regparm__(3))) (*))(void))plugout->close;
#line 633
  sound_description = (char *)plugout->description;
#line 635
  if (plugout->flags & 1L) {
#line 636
    verbosity = 0L;
  }
#line 638
  return;
}
}
#line 640 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
int main(int argc , char **argv ) 
{ 
  struct gbs *gbs ;
  char *usercfg ;
  struct termios ts ;
  struct sigaction sa ;
  time_t tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 647
  i18n_init();
  }
  {
#line 650
  tmp = time((time_t *)0);
  }
  {
#line 650
  tmp___0 = getpid();
  }
#line 650
  random_seed = (unsigned long )(tmp + (time_t )tmp___0);
  {
#line 651
  srand((unsigned int )random_seed);
  }
  {
#line 653
  usercfg = get_userconfig(cfgfile);
  }
  {
#line 654
  cfg_parse("/etc/gbsplayrc", options);
  }
  {
#line 655
  cfg_parse((char const   *)usercfg, options);
  }
  {
#line 656
  free((void *)usercfg);
  }
  {
#line 657
  parseopts___0(& argc, & argv);
  }
  {
#line 658
  select_plugin();
  }
  }
#line 660
  if (argc < 1) {
    {
    {
#line 661
    usage___0(1L);
    }
    }
  }
  {
  {
#line 664
  precalc_notes();
  }
  {
#line 665
  precalc_vols();
  }
  {
#line 667
  tmp___2 = (*sound_open)(endian, rate);
  }
  }
#line 667
  if (tmp___2 != 0L) {
    {
    {
#line 668
    tmp___1 = _("Could not open output plugin \"%s\"\n");
    }
    {
#line 668
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            sound_name);
    }
    {
#line 670
    exit(1);
    }
    }
  }
  {
  {
#line 673
  gbhw_setiocallback(& iocallback___1, (void *)0);
  }
  {
#line 674
  gbhw_setcallback(& callback___1, (void *)0);
  }
  {
#line 675
  gbhw_setrate(rate);
  }
  }
#line 677
  if (argc >= 2) {
    {
    {
#line 678
    sscanf((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"%ld",
           & subsong_start);
    }
#line 679
    subsong_start --;
    }
  }
#line 682
  if (argc >= 3) {
    {
    {
#line 683
    sscanf((char const   */* __restrict  */)*(argv + 2), (char const   */* __restrict  */)"%ld",
           & subsong_stop);
    }
#line 684
    subsong_stop --;
    }
  }
  {
  {
#line 687
  gbs = gbs_open(*(argv + 0));
  }
  }
#line 688
  if ((unsigned long )gbs == (unsigned long )((void *)0)) {
    {
    {
#line 689
    exit(1);
    }
    }
  }
#line 693
  if (subsong_start < -1L) {
#line 694
    subsong_start = 0L;
  } else
#line 695
  if (subsong_start >= gbs->songs) {
#line 696
    subsong_start = gbs->songs - 1L;
  }
#line 698
  if (subsong_stop < 0L) {
#line 699
    subsong_stop = -1L;
  } else
#line 700
  if (subsong_stop >= gbs->songs) {
#line 701
    subsong_stop = -1L;
  }
  {
#line 704
  gbs->subsong = subsong_start;
#line 705
  gbs->subsong_timeout = subsong_timeout;
#line 706
  gbs->silence_timeout = silence_timeout;
#line 707
  gbs->gap = subsong_gap;
#line 708
  gbs->fadeout = fadeout;
  {
#line 709
  setup_playmode(gbs);
  }
  {
#line 710
  gbhw_setbuffer(& buf);
  }
  {
#line 711
  gbs_set_nextsubsong_cb(gbs, & nextsubsong_cb, (void *)0);
  }
  {
#line 712
  gbs_init(gbs, gbs->subsong);
  }
  }
#line 713
  if (sound_skip) {
    {
    {
#line 714
    (*sound_skip)((int )gbs->subsong);
    }
    }
  }
  {
  {
#line 715
  printinfo(gbs);
  }
  {
#line 716
  tcgetattr(0, & ts);
  }
#line 717
  ots = ts;
#line 718
  ts.c_lflag &= 4294967221U;
  {
#line 719
  tcsetattr(0, 2, (struct termios  const  *)(& ts));
  }
  {
#line 721
  memset((void *)(& sa), 0, (size_t )sizeof(sa));
  }
#line 722
  sa.__sigaction_handler.sa_handler = & exit_handler;
  {
#line 723
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 724
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 725
  sigaction(11, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 726
  sa.__sigaction_handler.sa_handler = & stop_handler;
  {
#line 727
  sigaction(19, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 728
  sa.__sigaction_handler.sa_handler = & cont_handler;
  {
#line 729
  sigaction(18, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 731
  fcntl(0, 4, 2048);
  }
  }
  {
  {
#line 732
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 732
    if (! (! quit)) {
#line 732
      goto while_break;
    }
    {
    {
#line 733
    tmp___3 = gbs_step(gbs, refresh_delay);
    }
    }
#line 733
    if (! tmp___3) {
#line 734
      quit = 1L;
#line 735
      goto while_break;
    }
#line 738
    if (redraw) {
      {
      {
#line 738
      printinfo(gbs);
      }
      }
    }
#line 739
    if (verbosity > 1L) {
      {
      {
#line 739
      printstatus(gbs);
      }
      }
    }
    {
    {
#line 740
    handleuserinput(gbs);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 742
  tcsetattr(0, 2, (struct termios  const  *)(& ots));
  }
  {
#line 744
  (*sound_close)();
  }
  }
#line 746
  return (0);
}
}
#line 14 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double sinc___0(double x ) 
{ 
  double a ;
  double tmp ;

  {
#line 16
  a = 3.14159265358979323846 * x;
#line 18
  if (a == 0.0) {
#line 18
    return (1.0);
  }
  {
  {
#line 20
  tmp = sin(a);
  }
  }
#line 20
  return (tmp / a);
}
}
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double blackman___0(double n , double m ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
  {
#line 25
  tmp = cos((((double )2 * n) * 3.14159265358979323846) / m);
  }
  {
#line 25
  tmp___0 = cos((((double )4 * n) * 3.14159265358979323846) / m);
  }
  }
#line 25
  return ((0.42 - 0.5 * tmp) + 0.08 * tmp___0);
}
}
#line 30 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long ( __attribute__((__regparm__(3))) midi_open___0)(enum plugout_endian endian___1 ,
                                                             long rate___1 ) 
{ 


  {
#line 32
  return (0L);
}
}
#line 35 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static FILE *file___0  =    (FILE *)((void *)0);
#line 37 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long track_length___0  ;
#line 38 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long track_length_offset___0  ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long cycles_prev___0  =    0L;
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_u32___0(uint32_t x ) 
{ 
  uint8_t s[4] ;
  size_t tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 46
  s[0] = (uint8_t )(x >> 24);
#line 47
  s[1] = (uint8_t )(x >> 16);
#line 48
  s[2] = (uint8_t )(x >> 8);
#line 49
  s[3] = (uint8_t )x;
  {
#line 51
  tmp = fwrite((void const   */* __restrict  */)(s), (size_t )1, (size_t )4, (FILE */* __restrict  */)file___0);
  }
  }
#line 51
  if (tmp != 4U) {
#line 52
    return (1);
  }
#line 53
  return (0);
}
}
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_u16___0(uint16_t x ) 
{ 
  uint8_t s[2] ;
  size_t tmp ;
  void *__cil_tmp4 ;

  {
  {
#line 60
  s[0] = (uint8_t )((int )x >> 8);
#line 61
  s[1] = (uint8_t )x;
  {
#line 63
  tmp = fwrite((void const   */* __restrict  */)(s), (size_t )1, (size_t )2, (FILE */* __restrict  */)file___0);
  }
  }
#line 63
  if (tmp != 2U) {
#line 64
    return (1);
  }
#line 65
  return (0);
}
}
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_varlen___0(unsigned long x ) 
{ 
  uint8_t s ;
  size_t tmp ;

  {
  {
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 73
    s = (uint8_t )(x & 127UL);
#line 74
    x >>= 7;
#line 75
    if (x) {
#line 76
      s = (uint8_t )((int )s | 128);
    }
    {
    {
#line 78
    tmp = fwrite((void const   */* __restrict  */)(& s), (size_t )1, (size_t )1, (FILE */* __restrict  */)file___0);
    }
    }
#line 78
    if (tmp != 1U) {
#line 79
      return (1);
    }
#line 81
    track_length___0 ++;
#line 70
    if (! x) {
#line 70
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (0);
}
}
#line 87 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_write_event___0(long cycles , uint8_t const   *s , unsigned int n ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
  {
#line 89
  tmp = midi_write_varlen___0((unsigned long )((cycles - cycles_prev___0) >> 14));
  }
  }
#line 89
  if (tmp) {
#line 90
    return (1);
  }
  {
  {
#line 92
  tmp___0 = fwrite((void const   */* __restrict  */)s, (size_t )1, n, (FILE */* __restrict  */)file___0);
  }
  }
#line 92
  if (tmp___0 != n) {
#line 93
    return (1);
  }
#line 95
  track_length___0 += (long )n;
#line 97
  cycles_prev___0 = cycles;
#line 98
  return (0);
}
}
#line 101 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_open_track___0(int subsong ) 
{ 
  char *filename___3 ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 104
  tmp = malloc((size_t )32);
  }
#line 104
  filename___3 = (char *)tmp;
  }
#line 104
  if ((unsigned long )filename___3 == (unsigned long )((void *)0)) {
#line 105
    goto out;
  }
  {
  {
#line 107
  tmp___0 = snprintf((char */* __restrict  */)filename___3, (size_t )32, (char const   */* __restrict  */)"gbsplay-%d.mid",
                     subsong + 1);
  }
  }
#line 107
  if (tmp___0 >= 32) {
#line 108
    goto out;
  }
  {
  {
#line 110
  file___0 = fopen((char const   */* __restrict  */)filename___3, (char const   */* __restrict  */)"wb");
  }
  }
#line 111
  if (! file___0) {
    {
    {
#line 112
    free((void *)filename___3);
    }
    }
#line 113
    goto out;
  }
  {
  {
#line 116
  free((void *)filename___3);
  }
  {
#line 119
  tmp___1 = fwrite((void const   */* __restrict  */)"MThd", (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)file___0);
  }
  }
#line 119
  if (tmp___1 != 4U) {
#line 120
    goto out_file;
  }
  {
  {
#line 123
  tmp___2 = midi_write_u32___0((uint32_t )6);
  }
  }
#line 123
  if (tmp___2) {
#line 124
    goto out_file;
  }
  {
  {
#line 127
  tmp___3 = midi_write_u16___0((uint16_t )0);
  }
  }
#line 127
  if (tmp___3) {
#line 128
    goto out_file;
  }
  {
  {
#line 131
  tmp___4 = midi_write_u16___0((uint16_t )1);
  }
  }
#line 131
  if (tmp___4) {
#line 132
    goto out_file;
  }
  {
  {
#line 136
  tmp___5 = midi_write_u16___0((uint16_t )124);
  }
  }
#line 136
  if (tmp___5) {
#line 137
    goto out_file;
  }
  {
  {
#line 140
  tmp___6 = fwrite((void const   */* __restrict  */)"MTrk", (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)file___0);
  }
  }
#line 140
  if (tmp___6 != 4U) {
#line 141
    goto out_file;
  }
  {
#line 144
  track_length___0 = 0L;
  {
#line 145
  track_length_offset___0 = ftell(file___0);
  }
  }
#line 146
  if (track_length_offset___0 == -1L) {
#line 147
    goto out_file;
  }
  {
  {
#line 149
  tmp___7 = midi_write_u32___0((uint32_t )0);
  }
  }
#line 149
  if (tmp___7) {
#line 150
    goto out_file;
  }
#line 152
  return (0);
  out_file: 
  {
  {
#line 155
  fclose(file___0);
  }
#line 156
  file___0 = (FILE *)((void *)0);
  }
  out: 
#line 158
  return (1);
}
}
#line 161 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int midi_close_track___0(void) 
{ 
  uint8_t event[3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp5 ;

  {
  {
#line 166
  event[0] = (uint8_t )255;
#line 167
  event[1] = (uint8_t )47;
#line 168
  event[2] = (uint8_t )0;
  {
#line 170
  tmp = midi_write_event___0(cycles_prev___0, (uint8_t const   *)(event), 3U);
  }
  }
#line 170
  if (tmp) {
#line 171
    goto out;
  }
  {
  {
#line 173
  tmp___0 = fseek(file___0, track_length_offset___0, 0);
  }
  }
#line 173
  if (tmp___0 == -1) {
#line 174
    goto out;
  }
  {
  {
#line 176
  tmp___1 = midi_write_u32___0((uint32_t )track_length___0);
  }
  }
#line 176
  if (tmp___1) {
#line 177
    goto out;
  }
  {
  {
#line 179
  fclose(file___0);
  }
#line 180
  file___0 = (FILE *)((void *)0);
  }
#line 181
  return (0);
  out: 
#line 184
  file___0 = (FILE *)((void *)0);
#line 185
  return (1);
}
}
#line 188 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int ( __attribute__((__regparm__(3))) midi_skip___0)(int subsong ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 190
  cycles_prev___0 = 0L;
#line 192
  if (file___0) {
    {
    {
#line 193
    tmp = midi_close_track___0();
    }
    }
#line 193
    if (tmp) {
#line 194
      return (1);
    }
  }
  {
  {
#line 197
  tmp___0 = midi_open_track___0(subsong);
  }
  }
#line 197
  return (tmp___0);
}
}
#line 200 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int note_on___0(long cycles , int channel , int note___1 , int velocity ) 
{ 
  uint8_t event[3] ;
  int tmp ;
  void *__cil_tmp7 ;

  {
  {
#line 205
  event[0] = (uint8_t )144;
#line 206
  event[1] = (uint8_t )note___1;
#line 207
  event[2] = (uint8_t )velocity;
  {
#line 209
  tmp = midi_write_event___0(cycles, (uint8_t const   *)(event), 3U);
  }
  }
#line 209
  if (tmp) {
#line 210
    return (1);
  }
#line 212
  return (0);
}
}
#line 215 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int note_off___0(long cycles , int channel , int note___1 ) 
{ 
  uint8_t event[3] ;
  int tmp ;
  void *__cil_tmp6 ;

  {
  {
#line 220
  event[0] = (uint8_t )128;
#line 221
  event[1] = (uint8_t )note___1;
#line 222
  event[2] = (uint8_t )0;
  {
#line 224
  tmp = midi_write_event___0(cycles, (uint8_t const   *)(event), 3U);
  }
  }
#line 224
  if (tmp) {
#line 225
    return (1);
  }
#line 227
  return (0);
}
}
#line 232
static int ( __attribute__((__regparm__(3))) midi_io___0)(long cycles , uint32_t addr ,
                                                          uint8_t val ) ;
#line 232 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long div___1[4]  = {      0L,      0L,      0L,      0L};
#line 233 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static long note___0[4]  = {      0L,      0L,      0L,      0L};
#line 234 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int volume___0[4]  = {      0,      0,      0,      0};
#line 230 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static int ( __attribute__((__regparm__(3))) midi_io___0)(long cycles , uint32_t addr ,
                                                          uint8_t val ) 
{ 
  long chan ;
  int new_note ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 236
  chan = (long )((addr - 65296U) / 5U);
  {
#line 241
  if (addr == 65313U) {
#line 241
    goto case_65313;
  }
#line 241
  if (addr == 65303U) {
#line 241
    goto case_65313;
  }
#line 241
  if (addr == 65298U) {
#line 241
    goto case_65313;
  }
#line 246
  if (addr == 65309U) {
#line 246
    goto case_65309;
  }
#line 246
  if (addr == 65304U) {
#line 246
    goto case_65309;
  }
#line 246
  if (addr == 65299U) {
#line 246
    goto case_65309;
  }
#line 252
  if (addr == 65310U) {
#line 252
    goto case_65310;
  }
#line 252
  if (addr == 65305U) {
#line 252
    goto case_65310;
  }
#line 252
  if (addr == 65300U) {
#line 252
    goto case_65310;
  }
#line 278
  if (addr == 65306U) {
#line 278
    goto case_65306;
  }
#line 289
  if (addr == 65308U) {
#line 289
    goto case_65308;
  }
#line 238
  goto switch_break;
  case_65313: /* CIL Label */ 
  case_65303: /* CIL Label */ 
  case_65298: /* CIL Label */ 
#line 242
  volume___0[chan] = 8 * ((int )val >> 4);
#line 243
  goto switch_break;
  case_65309: /* CIL Label */ 
  case_65304: /* CIL Label */ 
  case_65299: /* CIL Label */ 
#line 247
  div___1[chan] &= 65280L;
#line 248
  div___1[chan] |= (long )val;
#line 249
  goto switch_break;
  case_65310: /* CIL Label */ 
  case_65305: /* CIL Label */ 
  case_65300: /* CIL Label */ 
  {
#line 253
  div___1[chan] &= 255L;
#line 254
  div___1[chan] |= (long )((int )val & 7) << 8;
  {
#line 256
  tmp = log((double )(262144L / (2048L - div___1[chan])));
  }
#line 256
  new_note = (int )((long )((tmp / .69314718055994530941 - 5.78135971352465960412) * (double )12 + .2) + 21L);
  }
#line 259
  if ((int )val & 128) {
#line 260
    if (note___0[chan]) {
      {
      {
#line 261
      tmp___0 = note_off___0(cycles, (int )chan, (int )note___0[chan]);
      }
      }
#line 261
      if (tmp___0) {
#line 262
        return (1);
      }
    }
#line 265
    if (new_note < 0) {
#line 266
      goto switch_break;
    } else
#line 265
    if (new_note >= 128) {
#line 266
      goto switch_break;
    }
    {
    {
#line 268
    tmp___1 = note_on___0(cycles, (int )chan, new_note, volume___0[chan]);
    }
    }
#line 268
    if (tmp___1) {
#line 269
      return (1);
    }
#line 270
    note___0[chan] = (long )new_note;
  } else {
    {
    {
#line 272
    tmp___2 = note_off___0(cycles, (int )chan, (int )note___0[chan]);
    }
    }
#line 272
    if (tmp___2) {
#line 273
      return (1);
    }
#line 274
    note___0[chan] = 0L;
  }
#line 277
  goto switch_break;
  case_65306: /* CIL Label */ 
#line 288
  goto switch_break;
  case_65308: /* CIL Label */ 
#line 290
  volume___0[2] = 32 * ((4 - ((int )val >> 5)) & 3);
#line 291
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 294
  return (0);
}
}
#line 297 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static ssize_t ( __attribute__((__regparm__(3))) midi_write___0)(void const   *buf___3 ,
                                                                 size_t count ) 
{ 


  {
#line 299
  return ((ssize_t )count);
}
}
#line 302 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_midi.c"
static void ( __attribute__((__regparm__(3))) midi_close___0)(void) 
{ 


  {
#line 304
  if (file___0) {
    {
    {
#line 305
    midi_close_track___0();
    }
    }
  }
#line 306
  return;
}
}
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_line___1  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_char___1  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static FILE *cfg_file___1  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextchar_state___1  ;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char ( __attribute__((__regparm__(3))) nextchar___1)(void) 
{ 
  long c___3 ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 30
  if (! ((unsigned long )cfg_file___1 != (unsigned long )((void *)0))) {
    {
    {
#line 30
    __assert_fail("cfg_file != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c",
                  30U, "nextchar");
    }
    }
  }
  {
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 33
    tmp = fgetc(cfg_file___1);
    }
#line 33
    c___3 = (long )tmp;
    }
#line 33
    if (c___3 == -1L) {
#line 33
      return ((char)0);
    }
#line 35
    if (c___3 == 10L) {
#line 36
      cfg_char___1 = 0L;
#line 37
      cfg_line___1 ++;
    } else {
#line 38
      cfg_char___1 ++;
    }
    {
#line 41
    if (nextchar_state___1 == 0L) {
#line 41
      goto case_0;
    }
#line 45
    if (nextchar_state___1 == 1L) {
#line 45
      goto case_1;
    }
#line 49
    if (nextchar_state___1 == 2L) {
#line 49
      goto case_2;
    }
#line 40
    goto switch_break;
    case_0: /* CIL Label */ 
#line 42
    if (c___3 == 92L) {
#line 42
      nextchar_state___1 = 1L;
    } else
#line 43
    if (c___3 == 35L) {
#line 43
      nextchar_state___1 = 2L;
    }
#line 44
    goto switch_break;
    case_1: /* CIL Label */ 
#line 46
    nextchar_state___1 = 0L;
#line 47
    if (c___3 == 110L) {
#line 47
      c___3 = (long )'\n';
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
#line 50
    if (c___3 == 0L) {
#line 50
      nextchar_state___1 = 0L;
    } else
#line 50
    if (c___3 == 10L) {
#line 50
      nextchar_state___1 = 0L;
    }
#line 51
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 32
    if (! (nextchar_state___1 != 0L)) {
#line 32
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return ((char )c___3);
}
}
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long state___1  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextstate___1  ;
#line 60 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long c___1  ;
#line 61 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char const   *filename___1  ;
#line 63 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static void ( __attribute__((__regparm__(3))) err_expect___1)(char *s ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 65
  tmp = _("\'%s\' expected at %s line %ld char %ld.\n");
  }
  {
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, s,
          filename___1, cfg_line___1, cfg_char___1);
  }
  {
#line 67
  tmp___0 = nextchar___1();
  }
#line 67
  c___1 = (long )tmp___0;
#line 68
  state___1 = 0L;
#line 69
  nextstate___1 = 1L;
  }
#line 70
  return;
}
}
#line 35 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.c"
static output_plugin_const_t plugouts[4]  = {      & plugout_devdsp,      & plugout_stdout,      & plugout_midi,      (output_plugin_const_t )((void *)0)};
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.c"
void ( __attribute__((__regparm__(3))) plugout_list_plugins)(void) 
{ 
  long idx ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 58
  tmp = _("Available output plugins:\n\n");
  }
  {
#line 58
  printf((char const   */* __restrict  */)tmp);
  }
  }
#line 60
  if ((unsigned long )plugouts[0] == (unsigned long )((void *)0)) {
    {
    {
#line 61
    tmp___0 = _("No output plugins available.\n\n");
    }
    {
#line 61
    printf((char const   */* __restrict  */)tmp___0);
    }
    }
#line 62
    return;
  }
#line 65
  idx = 0L;
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )plugouts[idx] != (unsigned long )((void *)0))) {
#line 65
      goto while_break;
    }
    {
    {
#line 66
    printf((char const   */* __restrict  */)"%s\t- %s\n", (plugouts[idx])->name, (plugouts[idx])->description);
    }
#line 65
    idx ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 68
  puts("");
  }
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.c"
struct output_plugin  const  *( __attribute__((__regparm__(3))) plugout_select_by_name)(char const   *name ) 
{ 
  long idx ;
  int tmp ;

  {
#line 75
  idx = 0L;
  {
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 75
    if ((unsigned long )plugouts[idx] != (unsigned long )((void *)0)) {
      {
      {
#line 75
      tmp = strcmp((char const   *)(plugouts[idx])->name, name);
      }
      }
#line 75
      if (! (tmp != 0)) {
#line 75
        goto while_break;
      }
    } else {
#line 75
      goto while_break;
    }
#line 75
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (plugouts[idx]);
}
}
#line 35 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout.c"
static output_plugin_const_t plugouts___0[4]  = {      & plugout_devdsp,      & plugout_stdout,      & plugout_midi,      (output_plugin_const_t )((void *)0)};
#line 14 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double sinc___1(double x ) 
{ 
  double a ;
  double tmp ;

  {
#line 16
  a = 3.14159265358979323846 * x;
#line 18
  if (a == 0.0) {
#line 18
    return (1.0);
  }
  {
  {
#line 20
  tmp = sin(a);
  }
  }
#line 20
  return (tmp / a);
}
}
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double blackman___1(double n , double m ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
  {
#line 25
  tmp = cos((((double )2 * n) * 3.14159265358979323846) / m);
  }
  {
#line 25
  tmp___0 = cos((((double )4 * n) * 3.14159265358979323846) / m);
  }
  }
#line 25
  return ((0.42 - 0.5 * tmp) + 0.08 * tmp___0);
}
}
#line 13 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static unsigned long crc_table___1[256]  ;
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static void ( __attribute__((__regparm__(3))) make_crc_table___1)(void) 
{ 
  unsigned long i ;
  unsigned long j ;
  unsigned long h ;
  unsigned long tmp ;

  {
#line 21
  h = 1UL;
#line 22
  crc_table___1[0] = 0UL;
#line 23
  i = 128UL;
  {
  {
#line 23
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 23
    if (! i) {
#line 23
      goto while_break;
    }
#line 24
    if (h & 1UL) {
#line 24
      tmp = 3988292384UL;
    } else {
#line 24
      tmp = 0UL;
    }
#line 24
    h = (h >> 1) ^ tmp;
#line 26
    j = 0UL;
    {
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! (j < 256UL)) {
#line 26
        goto while_break___0;
      }
#line 27
      crc_table___1[i + j] = crc_table___1[j] ^ h;
#line 26
      j += 2UL * i;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 23
    i >>= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint8_t const   playercode___1[127]  = 
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
  {      (uint8_t const   )245,      (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )48, 
        (uint8_t const   )0,      (uint8_t const   )17,      (uint8_t const   )16,      (uint8_t const   )255, 
        (uint8_t const   )33,      (uint8_t const   )159,      (uint8_t const   )0,      (uint8_t const   )42, 
        (uint8_t const   )18,      (uint8_t const   )19,      (uint8_t const   )11,      (uint8_t const   )120, 
        (uint8_t const   )177,      (uint8_t const   )32,      (uint8_t const   )248,      (uint8_t const   )225, 
        (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )14,      (uint8_t const   )0, 
        (uint8_t const   )9,      (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )6, 
        (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )7,      (uint8_t const   )17, 
        (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )203,      (uint8_t const   )87, 
        (uint8_t const   )62,      (uint8_t const   )1,      (uint8_t const   )40,      (uint8_t const   )2, 
        (uint8_t const   )62,      (uint8_t const   )4,      (uint8_t const   )18,      (uint8_t const   )225, 
        (uint8_t const   )241,      (uint8_t const   )87,      (uint8_t const   )229,      (uint8_t const   )1, 
        (uint8_t const   )8,      (uint8_t const   )0,      (uint8_t const   )9,      (uint8_t const   )42, 
        (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122,      (uint8_t const   )1, 
        (uint8_t const   )140,      (uint8_t const   )0,      (uint8_t const   )197,      (uint8_t const   )233, 
        (uint8_t const   )251,      (uint8_t const   )118,      (uint8_t const   )225,      (uint8_t const   )229, 
        (uint8_t const   )1,      (uint8_t const   )10,      (uint8_t const   )0,      (uint8_t const   )9, 
        (uint8_t const   )42,      (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122, 
        (uint8_t const   )1,      (uint8_t const   )157,      (uint8_t const   )0,      (uint8_t const   )197, 
        (uint8_t const   )233,      (uint8_t const   )24,      (uint8_t const   )238,      (uint8_t const   )128, 
        (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191, 
        (uint8_t const   )0,      (uint8_t const   )63,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255,      (uint8_t const   )159, 
        (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )255, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )119, 
        (uint8_t const   )243,      (uint8_t const   )241,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72,      (uint8_t const   )54, 
        (uint8_t const   )2,      (uint8_t const   )207,      (uint8_t const   )22,      (uint8_t const   )44, 
        (uint8_t const   )4,      (uint8_t const   )229,      (uint8_t const   )44,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72};
#line 122 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static long ( __attribute__((__regparm__(3))) gbs_nextsubsong___1)(struct gbs *gbs ) 
{ 
  long tmp ;

  {
#line 124
  if ((unsigned long )gbs->nextsubsong_cb != (unsigned long )((void *)0)) {
    {
    {
#line 125
    tmp = (*(gbs->nextsubsong_cb))(gbs, gbs->nextsubsong_cb_priv);
    }
    }
#line 125
    return (tmp);
  } else {
#line 127
    (gbs->subsong) ++;
#line 128
    if (gbs->subsong >= gbs->songs) {
#line 129
      return (0L);
    }
    {
    {
#line 130
    gbs_init(gbs, gbs->subsong);
    }
    }
  }
#line 132
  return (1L);
}
}
#line 233 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static void ( __attribute__((__regparm__(3))) writeint___1)(char *buf___3 , uint32_t val ,
                                                            long bytes ) 
{ 
  long shift ;
  long i ;

  {
#line 235
  shift = 0L;
#line 238
  i = 0L;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < bytes)) {
#line 238
      goto while_break;
    }
#line 239
    *(buf___3 + i) = (char )((val >> shift) & 255U);
#line 240
    shift += 8L;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint32_t ( __attribute__((__regparm__(3))) readint___1)(char *buf___3 , long bytes ) 
{ 
  long i ;
  long shift ;
  uint32_t res ;

  {
#line 247
  shift = 0L;
#line 248
  res = (uint32_t )0;
#line 250
  i = 0L;
  {
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < bytes)) {
#line 250
      goto while_break;
    }
#line 251
    res |= (unsigned int )((int )((unsigned char )*(buf___3 + i)) << shift);
#line 252
    shift += 8L;
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return (res);
}
}
#line 19 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsinfo.c"
char *myname  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsinfo.c"
void usage(long exitcode ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 23
  if (exitcode) {
#line 23
    tmp = stderr;
  } else {
#line 23
    tmp = stdout;
  }
  {
#line 23
  out = tmp;
  {
#line 24
  tmp___0 = _("Usage: %s [option] <gbs-file>\n\nAvailable options are:\n  -h  display this help and exit\n  -V  print version and exit\n");
  }
  {
#line 24
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
          myname);
  }
  {
#line 31
  exit((int )exitcode);
  }
  }
}
}
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsinfo.c"
void version(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 36
  puts("gbsplay 0.0.91");
  }
  {
#line 37
  exit(0);
  }
  }
}
}
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsinfo.c"
void parseopts(int *argc , char ***argv ) 
{ 
  long res ;
  int tmp ;
  char *__cil_tmp5 ;

  {
#line 43
  myname = *(*(argv + 0));
  {
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 44
    tmp = getopt(*argc, (char * const  *)*argv, "hV");
    }
#line 44
    res = (long )tmp;
    }
#line 44
    if (! (res != -1L)) {
#line 44
      goto while_break;
    }
    {
#line 49
    if (res == 104L) {
#line 49
      goto case_104;
    }
#line 52
    if (res == 86L) {
#line 52
      goto case_86;
    }
#line 46
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
    {
#line 47
    usage(1L);
    }
    }
#line 48
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 50
    usage(0L);
    }
    }
#line 51
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 53
    version();
    }
    }
#line 54
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  *argc -= optind;
#line 58
  *argv += optind;
#line 59
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static int fd___1  ;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static long ( __attribute__((__regparm__(3))) devdsp_open___0)(enum plugout_endian endian___1 ,
                                                               long rate___1 ) 
{ 
  int c___3 ;
  int flags ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
  {
#line 31
  fd___1 = open("/dev/dsp", 2049);
  }
  }
#line 31
  if (fd___1 == -1) {
    {
    {
#line 32
    tmp = __errno_location();
    }
    {
#line 32
    tmp___0 = strerror(*tmp);
    }
    {
#line 32
    tmp___1 = _("Could not open /dev/dsp: %s\n");
    }
    {
#line 32
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            tmp___0);
    }
    }
#line 33
    return (-1L);
  }
  {
  {
#line 35
  flags = fcntl(fd___1, 3);
  }
  }
#line 35
  if (flags == -1) {
    {
    {
#line 36
    tmp___2 = __errno_location();
    }
    {
#line 36
    tmp___3 = strerror(*tmp___2);
    }
    {
#line 36
    tmp___4 = _("fcntl(F_GETFL) failed: %s\n");
    }
    {
#line 36
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
            tmp___3);
    }
    }
  } else {
    {
    {
#line 37
    tmp___8 = fcntl(fd___1, 4, flags & -2049);
    }
    }
#line 37
    if (tmp___8 == -1) {
      {
      {
#line 38
      tmp___5 = __errno_location();
      }
      {
#line 38
      tmp___6 = strerror(*tmp___5);
      }
      {
#line 38
      tmp___7 = _("fcntl(F_SETFL, flags&~O_NONBLOCK) failed: %s\n");
      }
      {
#line 38
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
              tmp___6);
      }
      }
    }
  }
  {
#line 42
  if ((unsigned int )endian___1 == 0U) {
#line 42
    goto case_0;
  }
#line 43
  if ((unsigned int )endian___1 == 1U) {
#line 43
    goto case_1;
  }
#line 44
  if ((unsigned int )endian___1 == 2U) {
#line 44
    goto case_2;
  }
#line 41
  goto switch_break;
  case_0: /* CIL Label */ 
#line 42
  c___3 = 32;
#line 42
  goto switch_break;
  case_1: /* CIL Label */ 
#line 43
  c___3 = 16;
#line 43
  goto switch_break;
  case_2: /* CIL Label */ 
#line 44
  c___3 = 16;
#line 44
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 46
  tmp___12 = ioctl(fd___1, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 5U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 46
  if (tmp___12 == -1) {
    {
    {
#line 47
    tmp___9 = __errno_location();
    }
    {
#line 47
    tmp___10 = strerror(*tmp___9);
    }
    {
#line 47
    tmp___11 = _("ioctl(fd, SNDCTL_DSP_SETFMT, %d) failed: %s\n");
    }
    {
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11,
            c___3, tmp___10);
    }
    }
#line 48
    return (-1L);
  }
  {
#line 50
  c___3 = (int )rate___1;
  {
#line 51
  tmp___16 = ioctl(fd___1, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 2U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 51
  if (tmp___16 == -1) {
    {
    {
#line 52
    tmp___13 = __errno_location();
    }
    {
#line 52
    tmp___14 = strerror(*tmp___13);
    }
    {
#line 52
    tmp___15 = _("ioctl(fd, SNDCTL_DSP_SPEED, %ld) failed: %s\n");
    }
    {
#line 52
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___15,
            rate___1, tmp___14);
    }
    }
#line 53
    return (-1L);
  }
#line 55
  if ((long )c___3 != rate___1) {
    {
    {
#line 56
    tmp___17 = _("Requested rate %ldHz, got %dHz.\n");
    }
    {
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
            rate___1, c___3);
    }
#line 57
    rate___1 = (long )c___3;
    }
  }
  {
#line 59
  c___3 = 1;
  {
#line 60
  tmp___21 = ioctl(fd___1, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 3U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 60
  if (tmp___21 == -1) {
    {
    {
#line 61
    tmp___18 = __errno_location();
    }
    {
#line 61
    tmp___19 = strerror(*tmp___18);
    }
    {
#line 61
    tmp___20 = _("ioctl(fd, SNDCTL_DSP_STEREO, %d) failed: %s\n");
    }
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
            c___3, tmp___19);
    }
    }
#line 62
    return (-1L);
  }
  {
#line 64
  c___3 = (4 << 16) + 11;
  {
#line 65
  tmp___25 = ioctl(fd___1, (unsigned long )(((3U << 30) | (unsigned int )(80 << 8)) | 10U) | (sizeof(int ) << 16),
                   & c___3);
  }
  }
#line 65
  if (tmp___25 == -1) {
    {
    {
#line 66
    tmp___22 = __errno_location();
    }
    {
#line 66
    tmp___23 = strerror(*tmp___22);
    }
    {
#line 66
    tmp___24 = _("ioctl(fd, SNDCTL_DSP_SETFRAGMENT, %08x) failed: %s\n");
    }
    {
#line 66
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
            c___3, tmp___23);
    }
    }
  }
#line 68
  return (0L);
}
}
#line 71 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static ssize_t ( __attribute__((__regparm__(3))) devdsp_write___0)(void const   *buf___3 ,
                                                                   size_t count ) 
{ 
  ssize_t tmp ;

  {
  {
  {
#line 73
  tmp = write(fd___1, buf___3, count);
  }
  }
#line 73
  return (tmp);
}
}
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_devdsp.c"
static void ( __attribute__((__regparm__(3))) devdsp_close___0)(void) 
{ 


  {
  {
  {
#line 78
  close(fd___1);
  }
  }
#line 79
  return;
}
}
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t *rom___1  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t intram___1[8192]  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t extram___1[8192]  ;
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t ioregs___1[128]  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t hiram___1[128]  ;
#line 25 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rombank___1  =    1L;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lastbank___1  ;
#line 28 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static char const   dutylookup___1[4]  = {      (char const   )1,      (char const   )2,      (char const   )4,      (char const   )6};
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lminval___1  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lmaxval___1  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rminval___1  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rmaxval___1  ;
#line 38 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_volume___1  ;
#line 39 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_fade___1  ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_dstvol___1  ;
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   vblanktc___1  =    (long const   )70256;
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long vblankctr___1  =    70256L;
#line 44 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timertc___1  =    70256L;
#line 45 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timerctr___1  =    70256L;
#line 47 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   msec_cycles___1  =    (long const   )4194;
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sum_cycles___1  ;
#line 51 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long pause_output___1  =    0L;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*callback___2))(struct gbhw_buffer *buf ,
                                                               void *priv )  ;
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *callbackpriv___1  ;
#line 55 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *soundbuf___1  =    (struct gbhw_buffer *)((void *)0);
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *impbuf___1  =    (struct gbhw_buffer *)((void *)0);
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*iocallback___2))(long cycles , uint32_t addr ,
                                                                 uint8_t valu , void *priv )  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *iocallback_priv___1  ;
#line 66 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap1___1  =    (uint32_t )16384;
#line 67 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap2___1  =    (uint32_t )8192;
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t lfsr___1  =    4294967295U;
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long long sound_div_tc___1  =    0LL;
#line 73 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   main_div_tc___1  =    (long const   )32;
#line 74 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long main_div___1  ;
#line 75 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   sweep_div_tc___1  =    (long const   )256;
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sweep_div___1  ;
#line 78 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long ch3pos___1  ;
#line 80 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_n_shift___1  =    7L;
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_w_shift___1  =    5L;
#line 82 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static double impulse_cutoff___1  =    1.0;
#line 84 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static short *base_impulse___1  =    (short *)((void *)0);
#line 90 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rom_get___1)(uint32_t addr ) 
{ 


  {
#line 93
  return ((uint32_t )*(rom___1 + (addr & 16383U)));
}
}
#line 96 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rombank_get___1)(uint32_t addr ) 
{ 


  {
#line 99
  return ((uint32_t )*(rom___1 + ((long )(addr & 16383U) + 16384L * rombank___1)));
}
}
#line 102 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) io_get___1)(uint32_t addr ) 
{ 
  char *__cil_tmp2 ;

  {
#line 104
  if (addr >= 65408U) {
#line 104
    if (addr <= 65534U) {
#line 105
      return ((uint32_t )hiram___1[addr & 127U]);
    }
  }
#line 107
  if (addr >= 65296U) {
#line 107
    if (addr <= 65343U) {
#line 109
      return ((uint32_t )ioregs___1[addr & 127U]);
    }
  }
#line 111
  if (addr == 65280U) {
#line 111
    return ((uint32_t )0);
  }
#line 112
  if (addr == 65535U) {
#line 112
    return ((uint32_t )ioregs___1[127]);
  }
  {
  {
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ioread from 0x%04x unimplemented.\n",
          addr);
  }
  }
  {
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((uint32_t )255);
}
}
#line 118 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) intram_get___1)(uint32_t addr ) 
{ 


  {
#line 121
  return ((uint32_t )intram___1[addr & 8191U]);
}
}
#line 124 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) extram_get___1)(uint32_t addr ) 
{ 


  {
#line 127
  return ((uint32_t )extram___1[addr & 8191U]);
}
}
#line 130 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) rom_put___1)(uint32_t addr , uint8_t val ) 
{ 
  char *__cil_tmp3 ;

  {
#line 132
  if (addr >= 8192U) {
#line 132
    if (addr <= 16383U) {
#line 133
      val = (uint8_t )((int )val & 31);
#line 134
      rombank___1 = (long )((int )val + ((int )val == 0));
#line 135
      if (rombank___1 > lastbank___1) {
        {
        {
#line 136
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bank %ld out of range (0-%ld)!\n",
                rombank___1, lastbank___1);
        }
#line 137
        rombank___1 = lastbank___1;
        }
      }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) io_put___1)(uint32_t addr , uint8_t val ) 
{ 
  long chn ;
  long duty_ctr ;
  long len ;
  long vol ;
  long envdir ;
  long envspd ;
  long tmp ;
  long div___2 ;
  long vol___0 ;
  long div___3 ;
  long shift ;
  long rate___1 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 144
  (*iocallback___2)(sum_cycles___1, addr, val, iocallback_priv___1);
  }
#line 146
  chn = (long )((addr - 65296U) / 5U);
  }
#line 147
  if (addr >= 65408U) {
#line 147
    if (addr <= 65534U) {
#line 148
      hiram___1[addr & 127U] = val;
#line 149
      return;
    }
  }
#line 151
  ioregs___1[addr & 127U] = val;
  {
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  if (addr == 65287U) {
#line 155
    goto case_65287;
  }
#line 155
  if (addr == 65286U) {
#line 155
    goto case_65287;
  }
#line 160
  if (addr == 65296U) {
#line 160
    goto case_65296;
  }
#line 168
  if (addr == 65312U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65302U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65297U) {
#line 168
    goto case_65312;
  }
#line 181
  if (addr == 65313U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65303U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65298U) {
#line 181
    goto case_65313;
  }
#line 197
  if (addr == 65310U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65309U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65305U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65304U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65300U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65299U) {
#line 197
    goto case_65310;
  }
#line 213
  if (addr == 65301U) {
#line 213
    goto case_65301;
  }
#line 215
  if (addr == 65306U) {
#line 215
    goto case_65306;
  }
#line 218
  if (addr == 65307U) {
#line 218
    goto case_65307;
  }
#line 221
  if (addr == 65308U) {
#line 221
    goto case_65308;
  }
#line 227
  if (addr == 65311U) {
#line 227
    goto case_65311;
  }
#line 230
  if (addr == 65315U) {
#line 230
    goto case_65315;
  }
#line 230
  if (addr == 65314U) {
#line 230
    goto case_65315;
  }
#line 252
  if (addr == 65317U) {
#line 252
    goto case_65317;
  }
#line 262
  if (addr == 65318U) {
#line 262
    goto case_65318;
  }
#line 292
  if (addr == 65535U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65343U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65342U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65341U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65340U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65339U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65338U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65337U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65336U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65335U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65334U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65333U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65332U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65331U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65330U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65329U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65328U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65327U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65326U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65325U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65324U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65323U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65322U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65321U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65320U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65319U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65316U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65280U) {
#line 292
    goto case_65535;
  }
#line 294
  goto switch_default;
  case_65287: /* CIL Label */ 
  case_65286: /* CIL Label */ 
#line 156
  timertc___1 = (long )((256 - (int )ioregs___1[6]) * (16 << ((((int )ioregs___1[7] + 3) & 3) << 1)));
#line 157
  if (((int )ioregs___1[7] & 240) == 128) {
#line 157
    timertc___1 /= 2L;
  }
#line 159
  goto switch_break;
  case_65296: /* CIL Label */ 
#line 161
  gbhw_ch[0].sweep_tc = (long )(((int )val >> 4) & 7);
#line 161
  gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 162
  gbhw_ch[0].sweep_dir = (long )(((int )val >> 3) & 1);
#line 163
  gbhw_ch[0].sweep_shift = (long )((int )val & 7);
#line 165
  goto switch_break;
  case_65312: /* CIL Label */ 
  case_65302: /* CIL Label */ 
  case_65297: /* CIL Label */ 
#line 170
  duty_ctr = (long )((int )val >> 6);
#line 171
  len = (long )((int )val & 63);
#line 173
  gbhw_ch[chn].duty_ctr = (long )dutylookup___1[duty_ctr];
#line 174
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 175
  gbhw_ch[chn].len = (64L - len) * 2L;
#line 177
  goto switch_break;
  case_65313: /* CIL Label */ 
  case_65303: /* CIL Label */ 
  case_65298: /* CIL Label */ 
#line 183
  vol = (long )((int )val >> 4);
#line 184
  envdir = (long )(((int )val >> 3) & 1);
#line 185
  envspd = (long )((int )val & 7);
#line 187
  gbhw_ch[chn].volume = vol;
#line 188
  gbhw_ch[chn].env_dir = envdir;
#line 189
  tmp = envspd * 8L;
#line 189
  gbhw_ch[chn].env_tc = tmp;
#line 189
  gbhw_ch[chn].env_ctr = tmp;
#line 191
  goto switch_break;
  case_65310: /* CIL Label */ 
  case_65309: /* CIL Label */ 
  case_65305: /* CIL Label */ 
  case_65304: /* CIL Label */ 
  case_65300: /* CIL Label */ 
  case_65299: /* CIL Label */ 
#line 199
  div___2 = (long )ioregs___1[19L + 5L * chn];
#line 201
  div___2 |= ((long )ioregs___1[20L + 5L * chn] & 7L) << 8;
#line 202
  gbhw_ch[chn].div_tc = 2048L - div___2;
#line 203
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 205
  if (addr == 65299U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65304U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65309U) {
#line 207
    goto switch_break;
  }
#line 209
  gbhw_ch[chn].len_enable = (long )(((int )ioregs___1[20L + 5L * chn] & 64) > 0);
#line 212
  goto switch_break;
  case_65301: /* CIL Label */ 
#line 214
  goto switch_break;
  case_65306: /* CIL Label */ 
#line 216
  gbhw_ch[2].master = (long )(((int )ioregs___1[26] & 128) > 0);
#line 217
  goto switch_break;
  case_65307: /* CIL Label */ 
#line 219
  gbhw_ch[2].len = (long )((256 - (int )val) * 2);
#line 220
  goto switch_break;
  case_65308: /* CIL Label */ 
#line 223
  vol___0 = (long )(((int )ioregs___1[28] >> 5) & 3);
#line 224
  gbhw_ch[2].volume = vol___0;
#line 225
  goto switch_break;
  case_65311: /* CIL Label */ 
#line 228
  goto switch_break;
  case_65315: /* CIL Label */ 
  case_65314: /* CIL Label */ 
#line 232
  div___3 = (long )ioregs___1[34];
#line 233
  shift = div___3 >> 4;
#line 234
  rate___1 = div___3 & 7L;
#line 235
  gbhw_ch[3].div_ctr = 0L;
#line 236
  gbhw_ch[3].div_tc = (long )(1 << shift);
#line 237
  if (div___3 & 8L) {
#line 238
    tap1___1 = (uint32_t )64;
#line 239
    tap2___1 = (uint32_t )32;
  } else {
#line 241
    tap1___1 = (uint32_t )16384;
#line 242
    tap2___1 = (uint32_t )8192;
  }
#line 244
  lfsr___1 |= 1U;
#line 245
  if (rate___1) {
#line 245
    gbhw_ch[3].div_tc *= rate___1;
  } else {
#line 246
    gbhw_ch[3].div_tc /= 2L;
  }
#line 247
  if (addr == 65314U) {
#line 247
    goto switch_break;
  }
#line 250
  gbhw_ch[chn].len_enable = (long )(((int )ioregs___1[35] & 64) > 0);
#line 251
  goto switch_break;
  case_65317: /* CIL Label */ 
#line 253
  gbhw_ch[0].leftgate = (long )(((int )val & 16) > 0);
#line 254
  gbhw_ch[0].rightgate = (long )(((int )val & 1) > 0);
#line 255
  gbhw_ch[1].leftgate = (long )(((int )val & 32) > 0);
#line 256
  gbhw_ch[1].rightgate = (long )(((int )val & 2) > 0);
#line 257
  gbhw_ch[2].leftgate = (long )(((int )val & 64) > 0);
#line 258
  gbhw_ch[2].rightgate = (long )(((int )val & 4) > 0);
#line 259
  gbhw_ch[3].leftgate = (long )(((int )val & 128) > 0);
#line 260
  gbhw_ch[3].rightgate = (long )(((int )val & 8) > 0);
#line 261
  goto switch_break;
  case_65318: /* CIL Label */ 
#line 263
  ioregs___1[38] = (uint8_t )128;
#line 264
  goto switch_break;
  case_65535: /* CIL Label */ 
  case_65343: /* CIL Label */ 
  case_65342: /* CIL Label */ 
  case_65341: /* CIL Label */ 
  case_65340: /* CIL Label */ 
  case_65339: /* CIL Label */ 
  case_65338: /* CIL Label */ 
  case_65337: /* CIL Label */ 
  case_65336: /* CIL Label */ 
  case_65335: /* CIL Label */ 
  case_65334: /* CIL Label */ 
  case_65333: /* CIL Label */ 
  case_65332: /* CIL Label */ 
  case_65331: /* CIL Label */ 
  case_65330: /* CIL Label */ 
  case_65329: /* CIL Label */ 
  case_65328: /* CIL Label */ 
  case_65327: /* CIL Label */ 
  case_65326: /* CIL Label */ 
  case_65325: /* CIL Label */ 
  case_65324: /* CIL Label */ 
  case_65323: /* CIL Label */ 
  case_65322: /* CIL Label */ 
  case_65321: /* CIL Label */ 
  case_65320: /* CIL Label */ 
  case_65319: /* CIL Label */ 
  case_65316: /* CIL Label */ 
  case_65280: /* CIL Label */ 
#line 293
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iowrite to 0x%04x unimplemented (val=%02x).\n",
          addr, (int )val);
  }
  }
#line 296
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) intram_put___1)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 302
  intram___1[addr & 8191U] = val;
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) extram_put___1)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 307
  extram___1[addr & 8191U] = val;
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound_sweep___1)(void) 
{ 
  long i ;
  long val ;

  {
#line 314
  if (gbhw_ch[0].sweep_tc) {
#line 315
    (gbhw_ch[0].sweep_ctr) --;
#line 316
    if (gbhw_ch[0].sweep_ctr < 0L) {
#line 317
      val = gbhw_ch[0].div_tc >> gbhw_ch[0].sweep_shift;
#line 319
      gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 320
      if (gbhw_ch[0].sweep_dir) {
#line 321
        if (gbhw_ch[0].div_tc < 2048L - val) {
#line 321
          gbhw_ch[0].div_tc += val;
        }
      } else
#line 323
      if (gbhw_ch[0].div_tc > val) {
#line 323
        gbhw_ch[0].div_tc -= val;
      }
#line 325
      gbhw_ch[0].duty_tc = (gbhw_ch[0].div_tc * gbhw_ch[0].duty_ctr) / 8L;
    }
  }
#line 328
  i = 0L;
  {
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < 4L)) {
#line 328
      goto while_break;
    }
#line 329
    if (gbhw_ch[i].len > 0L) {
#line 329
      if (gbhw_ch[i].len_enable) {
#line 330
        (gbhw_ch[i].len) --;
#line 331
        if (gbhw_ch[i].len == 0L) {
#line 332
          gbhw_ch[i].volume = 0L;
#line 333
          gbhw_ch[i].env_tc = 0L;
        }
      }
    }
#line 336
    if (gbhw_ch[i].env_tc) {
#line 337
      (gbhw_ch[i].env_ctr) --;
#line 338
      if (gbhw_ch[i].env_ctr <= 0L) {
#line 339
        gbhw_ch[i].env_ctr = gbhw_ch[i].env_tc;
#line 340
        if (! gbhw_ch[i].env_dir) {
#line 341
          if (gbhw_ch[i].volume > 0L) {
#line 342
            (gbhw_ch[i].volume) --;
          }
        } else
#line 344
        if (gbhw_ch[i].volume < 15L) {
#line 345
          (gbhw_ch[i].volume) ++;
        }
      }
    }
#line 328
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (master_fade___1) {
#line 351
    master_volume___1 += master_fade___1;
#line 352
    if (master_fade___1 > 0L) {
#line 352
      if (master_volume___1 >= master_dstvol___1) {
#line 356
        master_fade___1 = 0L;
#line 357
        master_volume___1 = master_dstvol___1;
      } else {
#line 352
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 352
    if (master_fade___1 < 0L) {
#line 352
      if (master_volume___1 <= master_dstvol___1) {
#line 356
        master_fade___1 = 0L;
#line 357
        master_volume___1 = master_dstvol___1;
      }
    }
  }
#line 361
  return;
}
}
#line 378 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_flush_buffer___1)(void) 
{ 
  long i ;
  long overlap ;
  long l_smpl ;
  long r_smpl ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 384
  if (! ((unsigned long )soundbuf___1 != (unsigned long )((void *)0))) {
    {
    {
#line 384
    __assert_fail("soundbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  384U, "gb_flush_buffer");
    }
    }
  }
#line 385
  if (! ((unsigned long )impbuf___1 != (unsigned long )((void *)0))) {
    {
    {
#line 385
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  385U, "gb_flush_buffer");
    }
    }
  }
#line 388
  l_smpl = soundbuf___1->l_lvl;
#line 389
  r_smpl = soundbuf___1->r_lvl;
#line 390
  i = 0L;
  {
  {
#line 390
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < soundbuf___1->samples)) {
#line 390
      goto while_break;
    }
#line 391
    l_smpl += (long )*(impbuf___1->data + i * 2L);
#line 392
    r_smpl += (long )*(impbuf___1->data + (i * 2L + 1L));
#line 393
    *(soundbuf___1->data + i * 2L) = (int16_t )((l_smpl * master_volume___1) / 65536L);
#line 394
    *(soundbuf___1->data + (i * 2L + 1L)) = (int16_t )((r_smpl * master_volume___1) / 65536L);
#line 395
    if (l_smpl > lmaxval___1) {
#line 395
      lmaxval___1 = l_smpl;
    }
#line 396
    if (l_smpl < lminval___1) {
#line 396
      lminval___1 = l_smpl;
    }
#line 397
    if (r_smpl > rmaxval___1) {
#line 397
      rmaxval___1 = r_smpl;
    }
#line 398
    if (r_smpl < rminval___1) {
#line 398
      rminval___1 = r_smpl;
    }
#line 390
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  soundbuf___1->pos = soundbuf___1->samples;
#line 401
  soundbuf___1->l_lvl = l_smpl;
#line 402
  soundbuf___1->r_lvl = r_smpl;
#line 404
  if ((unsigned long )callback___2 != (unsigned long )((void *)0)) {
    {
    {
#line 404
    (*callback___2)(soundbuf___1, callbackpriv___1);
    }
    }
  }
  {
#line 406
  overlap = impbuf___1->samples - soundbuf___1->samples;
  {
#line 407
  memmove((void *)impbuf___1->data, (void const   *)(impbuf___1->data + 2L * soundbuf___1->samples),
          (size_t )(4L * overlap));
  }
  {
#line 408
  memset((void *)(impbuf___1->data + 2L * overlap), 0, (size_t )(impbuf___1->bytes - 4L * overlap));
  }
  }
#line 409
  if (! (impbuf___1->bytes == impbuf___1->samples * 4L)) {
    {
    {
#line 409
    __assert_fail("impbuf->bytes == impbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  409U, "gb_flush_buffer");
    }
    }
  }
#line 410
  if (! (soundbuf___1->bytes == soundbuf___1->samples * 4L)) {
    {
    {
#line 410
    __assert_fail("soundbuf->bytes == soundbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  410U, "gb_flush_buffer");
    }
    }
  }
  {
  {
#line 411
  memset((void *)soundbuf___1->data, 0, (size_t )soundbuf___1->bytes);
  }
#line 412
  soundbuf___1->pos = 0L;
#line 414
  impbuf___1->cycles = (long )((long long )impbuf___1->cycles - (sound_div_tc___1 * (long long )soundbuf___1->samples) / 65536LL);
  }
#line 415
  return;
}
}
#line 417 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_change_level___1)(long l_ofs , long r_ofs ) 
{ 
  long pos ;
  long imp_idx ;
  long imp_l ;
  long imp_r ;
  long i ;
  short *ptr ;
  long bufi ;
  long impi ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 421
  imp_l = (long )(- (1 << impulse_w_shift___1) / 2);
#line 422
  imp_r = (long )((1 << impulse_w_shift___1) / 2);
#line 424
  ptr = base_impulse___1;
#line 426
  if (! ((unsigned long )impbuf___1 != (unsigned long )((void *)0))) {
    {
    {
#line 426
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  426U, "gb_change_level");
    }
    }
  }
#line 427
  pos = (long )(((long long )impbuf___1->cycles * 65536LL) / sound_div_tc___1);
#line 428
  imp_idx = (long )(((long long )(impbuf___1->cycles << impulse_n_shift___1) * 65536LL) / sound_div_tc___1) & (long )((1 << impulse_n_shift___1) - 1);
#line 429
  if (! (pos + imp_r < impbuf___1->samples)) {
    {
    {
#line 429
    __assert_fail("pos + imp_r < impbuf->samples", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  429U, "gb_change_level");
    }
    }
  }
#line 430
  if (! (pos + imp_l >= 0L)) {
    {
    {
#line 430
    __assert_fail("pos + imp_l >= 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  430U, "gb_change_level");
    }
    }
  }
#line 432
  ptr += imp_idx * (long )(1 << impulse_w_shift___1);
#line 434
  i = imp_l;
  {
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < imp_r)) {
#line 434
      goto while_break;
    }
#line 435
    bufi = pos + i;
#line 436
    impi = i + (long )((1 << impulse_w_shift___1) / 2);
#line 437
    *(impbuf___1->data + bufi * 2L) = (int16_t )((long )*(impbuf___1->data + bufi * 2L) + (long )*(ptr + impi) * l_ofs);
#line 438
    *(impbuf___1->data + (bufi * 2L + 1L)) = (int16_t )((long )*(impbuf___1->data + (bufi * 2L + 1L)) + (long )*(ptr + impi) * r_ofs);
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  impbuf___1->l_lvl += l_ofs * 256L;
#line 442
  impbuf___1->r_lvl += r_ofs * 256L;
#line 443
  return;
}
}
#line 449
static void ( __attribute__((__regparm__(3))) gb_sound___1)(long cycles ) ;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_l___1  =    0L;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_r___1  =    0L;
#line 511 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long val___3  ;
#line 445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound___1)(long cycles ) 
{ 
  long i ;
  long j ;
  long l_lvl ;
  long r_lvl ;
  long pos ;
  long tmp ;
  long val ;
  long index___0 ;
  long shift ;
  long old_l___3 ;
  long old_r___3 ;
  long l_diff ;
  long r_diff ;
  long val___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 448
  l_lvl = 0L;
#line 448
  r_lvl = 0L;
#line 451
  if (! ((unsigned long )impbuf___1 != (unsigned long )((void *)0))) {
    {
    {
#line 451
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  451U, "gb_sound");
    }
    }
  }
#line 453
  j = 0L;
  {
  {
#line 453
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 453
    if (! (j < cycles)) {
#line 453
      goto while_break;
    }
#line 454
    main_div___1 ++;
#line 455
    (impbuf___1->cycles) ++;
#line 456
    if ((long long )impbuf___1->cycles * 65536LL >= sound_div_tc___1 * (long long )(impbuf___1->samples - (long )((1 << impulse_w_shift___1) / 2))) {
      {
      {
#line 457
      gb_flush_buffer___1();
      }
      }
    }
#line 459
    if (gbhw_ch[2].master) {
#line 460
      (gbhw_ch[2].div_ctr) --;
#line 461
      if (gbhw_ch[2].div_ctr <= 0L) {
#line 462
        tmp = ch3pos___1;
#line 462
        ch3pos___1 ++;
#line 462
        pos = tmp;
#line 463
        index___0 = (pos >> 1) & 15L;
#line 463
        shift = (~ pos & 1L) << 2;
#line 463
        val = (long )(((int )*(& ioregs___1[48] + index___0) >> shift) & 15);
#line 464
        old_l___3 = gbhw_ch[2].l_lvl;
#line 465
        old_r___3 = gbhw_ch[2].r_lvl;
#line 467
        gbhw_ch[2].div_ctr = gbhw_ch[2].div_tc * 2L;
#line 468
        if (gbhw_ch[2].volume) {
#line 469
          val >>= gbhw_ch[2].volume - 1L;
        } else {
#line 470
          val = 0L;
        }
#line 471
        val *= 2L;
#line 472
        if (gbhw_ch[2].volume) {
#line 472
          if (! gbhw_ch[2].mute) {
#line 473
            if (gbhw_ch[2].leftgate) {
#line 474
              gbhw_ch[2].l_lvl = val;
            }
#line 475
            if (gbhw_ch[2].rightgate) {
#line 476
              gbhw_ch[2].r_lvl = val;
            }
          }
        }
        {
#line 478
        l_diff = gbhw_ch[2].l_lvl - old_l___3;
#line 479
        r_diff = gbhw_ch[2].r_lvl - old_r___3;
        {
#line 480
        gb_change_level___1(l_diff, r_diff);
        }
        }
      }
    }
#line 484
    if (main_div___1 > (long )main_div_tc___1) {
#line 485
      main_div___1 -= (long )main_div_tc___1;
#line 487
      i = 0L;
      {
      {
#line 487
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 487
        if (! (i < 2L)) {
#line 487
          goto while_break___0;
        }
#line 487
        if (gbhw_ch[i].master) {
#line 488
          val___0 = gbhw_ch[i].volume;
#line 489
          if (gbhw_ch[i].div_ctr > gbhw_ch[i].duty_tc) {
#line 490
            val___0 = - val___0;
          }
#line 492
          if (! gbhw_ch[i].mute) {
#line 493
            if (gbhw_ch[i].leftgate) {
#line 494
              gbhw_ch[i].l_lvl = val___0;
            }
#line 495
            if (gbhw_ch[i].rightgate) {
#line 496
              gbhw_ch[i].r_lvl = val___0;
            }
          }
#line 498
          (gbhw_ch[i].div_ctr) --;
#line 499
          if (gbhw_ch[i].div_ctr <= 0L) {
#line 500
            gbhw_ch[i].div_ctr = gbhw_ch[i].div_tc;
          }
        }
#line 487
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 503
      i = 0L;
      {
      {
#line 503
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 503
        if (! (i < 2L)) {
#line 503
          goto while_break___1;
        }
#line 504
        l_lvl += gbhw_ch[i].l_lvl;
#line 505
        r_lvl += gbhw_ch[i].r_lvl;
#line 503
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 508
      if (gbhw_ch[3].master) {
#line 512
        if (! gbhw_ch[3].mute) {
#line 513
          if (gbhw_ch[3].leftgate) {
#line 514
            gbhw_ch[3].l_lvl = val___3;
          }
#line 515
          if (gbhw_ch[3].rightgate) {
#line 516
            gbhw_ch[3].r_lvl = val___3;
          }
        }
#line 518
        (gbhw_ch[3].div_ctr) --;
#line 519
        if (gbhw_ch[3].div_ctr <= 0L) {
#line 520
          gbhw_ch[3].div_ctr = gbhw_ch[3].div_tc;
#line 521
          lfsr___1 = (lfsr___1 << 1) | (unsigned int )(((lfsr___1 & tap1___1) > 0U) ^ ((lfsr___1 & tap2___1) > 0U));
#line 522
          val___3 = gbhw_ch[3].volume * (long )((lfsr___1 & 2U) - 1U);
        }
      }
#line 525
      l_lvl += gbhw_ch[3].l_lvl;
#line 526
      r_lvl += gbhw_ch[3].r_lvl;
#line 528
      if (l_lvl != old_l___1) {
        {
        {
#line 529
        gb_change_level___1(l_lvl - old_l___1, r_lvl - old_r___1);
        }
#line 530
        old_l___1 = l_lvl;
#line 531
        old_r___1 = r_lvl;
        }
      } else
#line 528
      if (r_lvl != old_r___1) {
        {
        {
#line 529
        gb_change_level___1(l_lvl - old_l___1, r_lvl - old_r___1);
        }
#line 530
        old_l___1 = l_lvl;
#line 531
        old_r___1 = r_lvl;
        }
      }
#line 534
      sweep_div___1 ++;
#line 535
      if (sweep_div___1 >= (long )sweep_div_tc___1) {
        {
#line 536
        sweep_div___1 = 0L;
        {
#line 537
        gb_sound_sweep___1();
        }
        }
      }
    }
#line 453
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return;
}
}
#line 555 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gbhw_impbuf_reset___1)(struct gbhw_buffer *impbuf___3 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 557
  if (! (sound_div_tc___1 != 0LL)) {
    {
    {
#line 557
    __assert_fail("sound_div_tc != 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  557U, "gbhw_impbuf_reset");
    }
    }
  }
  {
#line 558
  impbuf___3->cycles = (long )(((sound_div_tc___1 * (long long )(1 << impulse_w_shift___1)) / 2LL) / 65536LL);
#line 559
  impbuf___3->l_lvl = 0L;
#line 560
  impbuf___3->r_lvl = 0L;
  {
#line 561
  memset((void *)impbuf___3->data, 0, (size_t )impbuf___3->bytes);
  }
  }
#line 562
  return;
}
}
#line 14 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double sinc___2(double x ) 
{ 
  double a ;
  double tmp ;

  {
#line 16
  a = 3.14159265358979323846 * x;
#line 18
  if (a == 0.0) {
#line 18
    return (1.0);
  }
  {
  {
#line 20
  tmp = sin(a);
  }
  }
#line 20
  return (tmp / a);
}
}
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/impulsegen.c"
static double blackman___2(double n , double m ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
  {
#line 25
  tmp = cos((((double )2 * n) * 3.14159265358979323846) / m);
  }
  {
#line 25
  tmp___0 = cos((((double )4 * n) * 3.14159265358979323846) / m);
  }
  }
#line 25
  return ((0.42 - 0.5 * tmp) + 0.08 * tmp___0);
}
}
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_line___2  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long cfg_char___2  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static FILE *cfg_file___2  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextchar_state___2  ;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char ( __attribute__((__regparm__(3))) nextchar___2)(void) 
{ 
  long c___3 ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 30
  if (! ((unsigned long )cfg_file___2 != (unsigned long )((void *)0))) {
    {
    {
#line 30
    __assert_fail("cfg_file != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c",
                  30U, "nextchar");
    }
    }
  }
  {
  {
#line 32
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 33
    tmp = fgetc(cfg_file___2);
    }
#line 33
    c___3 = (long )tmp;
    }
#line 33
    if (c___3 == -1L) {
#line 33
      return ((char)0);
    }
#line 35
    if (c___3 == 10L) {
#line 36
      cfg_char___2 = 0L;
#line 37
      cfg_line___2 ++;
    } else {
#line 38
      cfg_char___2 ++;
    }
    {
#line 41
    if (nextchar_state___2 == 0L) {
#line 41
      goto case_0;
    }
#line 45
    if (nextchar_state___2 == 1L) {
#line 45
      goto case_1;
    }
#line 49
    if (nextchar_state___2 == 2L) {
#line 49
      goto case_2;
    }
#line 40
    goto switch_break;
    case_0: /* CIL Label */ 
#line 42
    if (c___3 == 92L) {
#line 42
      nextchar_state___2 = 1L;
    } else
#line 43
    if (c___3 == 35L) {
#line 43
      nextchar_state___2 = 2L;
    }
#line 44
    goto switch_break;
    case_1: /* CIL Label */ 
#line 46
    nextchar_state___2 = 0L;
#line 47
    if (c___3 == 110L) {
#line 47
      c___3 = (long )'\n';
    }
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
#line 50
    if (c___3 == 0L) {
#line 50
      nextchar_state___2 = 0L;
    } else
#line 50
    if (c___3 == 10L) {
#line 50
      nextchar_state___2 = 0L;
    }
#line 51
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 32
    if (! (nextchar_state___2 != 0L)) {
#line 32
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return ((char )c___3);
}
}
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long state___2  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long nextstate___2  ;
#line 60 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static long c___2  ;
#line 61 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static char const   *filename___2  ;
#line 63 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/cfgparser.c"
static void ( __attribute__((__regparm__(3))) err_expect___2)(char *s ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 65
  tmp = _("\'%s\' expected at %s line %ld char %ld.\n");
  }
  {
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, s,
          filename___2, cfg_line___2, cfg_char___2);
  }
  {
#line 67
  tmp___0 = nextchar___2();
  }
#line 67
  c___2 = (long )tmp___0;
#line 68
  state___2 = 0L;
#line 69
  nextstate___2 = 1L;
  }
#line 70
  return;
}
}
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) none_get___2)(uint32_t addr ) 
{ 


  {
#line 45
  return ((uint32_t )255);
}
}
#line 48 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) none_put___2)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_get_fn getlookup___2[256]  = 
#line 52
  {      & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2, 
        & none_get___2,      & none_get___2,      & none_get___2,      & none_get___2};
#line 311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static gbcpu_put_fn putlookup___2[256]  = 
#line 311
  {      & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2, 
        & none_put___2,      & none_put___2,      & none_put___2,      & none_put___2};
#line 570 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static uint32_t ( __attribute__((__regparm__(3))) mem_get___2)(uint32_t addr ) 
{ 
  uint32_t ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr ) ;
  uint32_t tmp ;

  {
  {
#line 572
  fn = getlookup___2[addr >> 8];
  {
#line 573
  tmp = (*fn)(addr);
  }
  }
#line 573
  return (tmp);
}
}
#line 576 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
__inline static void ( __attribute__((__regparm__(3))) mem_put___2)(uint32_t addr ,
                                                                    uint32_t val ) 
{ 
  void ( __attribute__((__regparm__(3))) (*fn))(uint32_t addr , uint8_t val ) ;

  {
  {
#line 578
  fn = putlookup___2[addr >> 8];
  {
#line 579
  (*fn)(addr, (uint8_t )val);
  }
  }
#line 580
  return;
}
}
#line 582 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) push___2)(uint32_t val ) 
{ 
  uint32_t sp ;

  {
  {
#line 584
  sp = (uint32_t )((int )*((uint16_t *)(& gbcpu_regs.ri[8])) - 2);
#line 585
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )sp;
  {
#line 586
  mem_put___2(sp, val & 255U);
  }
  {
#line 587
  mem_put___2(sp + 1U, val >> 8);
  }
  }
#line 588
  return;
}
}
#line 590 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) pop___2)(void) 
{ 
  uint32_t res ;
  uint32_t sp ;
  uint32_t tmp ;

  {
  {
#line 593
  sp = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[8]));
  {
#line 595
  res = mem_get___2(sp);
  }
  {
#line 596
  tmp = mem_get___2(sp + 1U);
  }
#line 596
  res += tmp << 8;
#line 597
  *((uint16_t *)(& gbcpu_regs.ri[8])) = (uint16_t )(sp + 2U);
  }
#line 599
  return (res);
}
}
#line 602 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm8___2)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;

  {
  {
#line 604
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 606
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 1U);
  {
#line 607
  res = mem_get___2(pc);
  }
  }
  {
  {
#line 608
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 608
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 609
  return (res);
}
}
#line 612 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_imm16___2)(void) 
{ 
  uint32_t pc ;
  uint32_t res ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 614
  pc = (uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10]));
#line 616
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )(pc + 2U);
  {
#line 617
  tmp = mem_get___2(pc);
  }
  {
#line 617
  tmp___0 = mem_get___2(pc + 1U);
  }
#line 617
  res = tmp + (tmp___0 << 8);
  }
  {
  {
#line 618
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 618
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (res);
}
}
#line 628 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static uint32_t ( __attribute__((__regparm__(3))) get_reg___2)(long i ) 
{ 
  uint32_t tmp ;

  {
#line 630
  if (i == 6L) {
    {
    {
#line 631
    tmp = mem_get___2((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])));
    }
    }
#line 631
    return (tmp);
  }
#line 632
  return ((uint32_t )gbcpu_regs.ri[i ^ 1L]);
}
}
#line 635 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) put_reg___2)(long i , uint32_t val ) 
{ 


  {
#line 637
  if (i == 6L) {
    {
    {
#line 638
    mem_put___2((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[4])), val);
    }
    }
  } else {
#line 639
    gbcpu_regs.ri[i ^ 1L] = (uint8_t )val;
  }
#line 640
  return;
}
}
#line 642 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_unknown___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 644
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown opcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 645
  gbcpu_stopped = 1L;
  }
#line 646
  return;
}
}
#line 648 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_set___2)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 650
  reg = (long )(op & 7U);
#line 651
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 653
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 653
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 654
  print_reg(reg);
  }
  {
#line 655
  tmp = get_reg___2(reg);
  }
  {
#line 655
  put_reg___2(reg, tmp | (unsigned int )(1 << bit));
  }
  }
#line 656
  return;
}
}
#line 658 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_res___2)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 660
  reg = (long )(op & 7U);
#line 661
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 663
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 664
  print_reg(reg);
  }
  {
#line 665
  tmp = get_reg___2(reg);
  }
  {
#line 665
  put_reg___2(reg, tmp & (unsigned int )(~ (1 << bit)));
  }
  }
#line 666
  return;
}
}
#line 668 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_bit___2)(uint32_t op ) 
{ 
  long reg ;
  unsigned long bit ;
  uint32_t tmp ;

  {
#line 670
  reg = (long )(op & 7U);
#line 671
  bit = (unsigned long )((op >> 3) & 7U);
  {
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 673
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 674
  print_reg(reg);
  }
#line 675
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 676
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 160);
  {
#line 677
  tmp = get_reg___2(reg);
  }
#line 677
  gbcpu_regs.rn.f = (uint8_t )((unsigned int )gbcpu_regs.rn.f ^ (((tmp << 8) >> (bit + 1UL)) & 128U));
  }
#line 678
  return;
}
}
#line 680 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rl___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 682
  reg = (long )(op & 7U);
  {
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 685
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 686
  print_reg(reg);
  }
  {
#line 687
  tmp = get_reg___2(reg);
  }
#line 687
  val = (uint8_t )tmp;
#line 687
  res = val;
#line 688
  res = (uint8_t )((int )res << 1);
#line 689
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 690
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 691
  if ((int )res == 0) {
#line 691
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 692
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 693
  return;
}
}
#line 695 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rla___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 699
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 699
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  res = gbcpu_regs.rn.a;
#line 701
  res = (uint8_t )((int )res << 1);
#line 702
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) >> 4));
#line 703
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 704
  if ((int )res == 0) {
#line 704
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 705
  gbcpu_regs.rn.a = res;
#line 706
  return;
}
}
#line 708 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlc___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 710
  reg = (long )(op & 7U);
  {
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 713
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 714
  print_reg(reg);
  }
  {
#line 715
  tmp = get_reg___2(reg);
  }
#line 715
  val = (uint8_t )tmp;
#line 715
  res = val;
#line 716
  res = (uint8_t )((int )res << 1);
#line 717
  res = (uint8_t )((int )res | ((int )val >> 7));
#line 718
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 719
  if ((int )res == 0) {
#line 719
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 720
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 721
  return;
}
}
#line 723 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rlca___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 727
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 727
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  res = gbcpu_regs.rn.a;
#line 729
  res = (uint8_t )((int )res << 1);
#line 730
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a >> 7));
#line 731
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a >> 7) << 4);
#line 732
  if ((int )res == 0) {
#line 732
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 733
  gbcpu_regs.rn.a = res;
#line 734
  return;
}
}
#line 736 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sla___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 738
  reg = (long )(op & 7U);
  {
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 741
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 742
  print_reg(reg);
  }
  {
#line 743
  tmp = get_reg___2(reg);
  }
#line 743
  val = (uint8_t )tmp;
#line 743
  res = val;
#line 744
  res = (uint8_t )((int )res << 1);
#line 745
  gbcpu_regs.rn.f = (uint8_t )(((int )val >> 7) << 4);
  }
#line 746
  if ((int )res == 0) {
#line 746
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 747
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 748
  return;
}
}
#line 750 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rr___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 752
  reg = (long )(op & 7U);
  {
  {
#line 755
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 755
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 756
  print_reg(reg);
  }
  {
#line 757
  tmp = get_reg___2(reg);
  }
#line 757
  val = (uint8_t )tmp;
#line 757
  res = val;
#line 758
  res = (uint8_t )((int )res >> 1);
#line 759
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 760
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 761
  if ((int )res == 0) {
#line 761
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 762
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 763
  return;
}
}
#line 765 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rra___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 769
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 769
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  res = gbcpu_regs.rn.a;
#line 771
  res = (uint8_t )((int )res >> 1);
#line 772
  res = (uint8_t )((int )res | (((int )gbcpu_regs.rn.f & 16) << 3));
#line 773
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 774
  if ((int )res == 0) {
#line 774
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 775
  gbcpu_regs.rn.a = res;
#line 776
  return;
}
}
#line 778 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrc___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 780
  reg = (long )(op & 7U);
  {
  {
#line 783
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 783
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 784
  print_reg(reg);
  }
  {
#line 785
  tmp = get_reg___2(reg);
  }
#line 785
  val = (uint8_t )tmp;
#line 785
  res = val;
#line 786
  res = (uint8_t )((int )res >> 1);
#line 787
  res = (uint8_t )((int )res | ((int )val << 7));
#line 788
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 789
  if ((int )res == 0) {
#line 789
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 790
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 791
  return;
}
}
#line 793 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rrca___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t res ;

  {
  {
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 797
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  res = gbcpu_regs.rn.a;
#line 799
  res = (uint8_t )((int )res >> 1);
#line 800
  res = (uint8_t )((int )res | ((int )gbcpu_regs.rn.a << 7));
#line 801
  gbcpu_regs.rn.f = (uint8_t )(((int )gbcpu_regs.rn.a & 1) << 4);
#line 802
  if ((int )res == 0) {
#line 802
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 803
  gbcpu_regs.rn.a = res;
#line 804
  return;
}
}
#line 806 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sra___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 808
  reg = (long )(op & 7U);
  {
  {
#line 811
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 811
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 812
  print_reg(reg);
  }
  {
#line 813
  tmp = get_reg___2(reg);
  }
#line 813
  val = (uint8_t )tmp;
#line 813
  res = val;
#line 814
  res = (uint8_t )((int )res >> 1);
#line 815
  res = (uint8_t )((int )res | ((int )val & 128));
#line 816
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 817
  if ((int )res == 0) {
#line 817
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 818
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 819
  return;
}
}
#line 821 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_srl___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t val ;
  uint32_t tmp ;

  {
#line 823
  reg = (long )(op & 7U);
  {
  {
#line 826
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 826
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 827
  print_reg(reg);
  }
  {
#line 828
  tmp = get_reg___2(reg);
  }
#line 828
  val = (uint8_t )tmp;
#line 828
  res = val;
#line 829
  res = (uint8_t )((int )res >> 1);
#line 830
  gbcpu_regs.rn.f = (uint8_t )(((int )val & 1) << 4);
  }
#line 831
  if ((int )res == 0) {
#line 831
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 832
  put_reg___2(reg, (uint32_t )res);
  }
  }
#line 833
  return;
}
}
#line 835 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_swap___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t res ;
  uint32_t val ;

  {
#line 837
  reg = (long )(op & 7U);
  {
  {
#line 841
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 841
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 842
  print_reg(reg);
  }
  {
#line 843
  val = get_reg___2(reg);
  }
#line 844
  res = (val >> 4) | (val << 4);
#line 846
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 847
  if (res == 0U) {
#line 847
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
  {
  {
#line 848
  put_reg___2(reg, res);
  }
  }
#line 849
  return;
}
}
#line 851 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  cbops___2[8]  = 
#line 851
  {      {& op_rlc___2}, 
        {& op_rrc___2}, 
        {& op_rl___2}, 
        {& op_rr___2}, 
        {& op_sla___2}, 
        {& op_sra___2}, 
        {& op_swap___2}, 
        {& op_srl___2}};
#line 862 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cbprefix___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t pc ;
  char *__cil_tmp4 ;

  {
  {
#line 864
  pc = *((uint16_t *)(& gbcpu_regs.ri[10]));
#line 866
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )pc + 1);
  {
#line 867
  op = mem_get___2((uint32_t )pc);
  }
  }
  {
#line 869
  if (op >> 6 == 0U) {
#line 869
    goto case_0;
  }
#line 871
  if (op >> 6 == 1U) {
#line 871
    goto case_1;
  }
#line 872
  if (op >> 6 == 2U) {
#line 872
    goto case_2;
  }
#line 873
  if (op >> 6 == 3U) {
#line 873
    goto case_3;
  }
#line 868
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 869
  (*(cbops___2[(op >> 3) & 7U].fn))(op, & cbops___2[(op >> 3) & 7U]);
  }
  }
#line 870
  return;
  case_1: /* CIL Label */ 
  {
  {
#line 871
  op_bit___2(op);
  }
  }
#line 871
  return;
  case_2: /* CIL Label */ 
  {
  {
#line 872
  op_res___2(op);
  }
  }
#line 872
  return;
  case_3: /* CIL Label */ 
  {
  {
#line 873
  op_set___2(op);
  }
  }
#line 873
  return;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 875
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nUnknown CB subopcode %02x.\n",
          (int )((unsigned char )op));
  }
#line 876
  gbcpu_stopped = 1L;
  }
#line 877
  return;
}
}
#line 879 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long src ;
  long dst ;
  uint32_t tmp ;

  {
#line 881
  src = (long )(op & 7U);
#line 882
  dst = (long )((op >> 3) & 7U);
  {
  {
#line 884
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 884
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 885
  print_reg(dst);
  }
  }
  {
  {
#line 886
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 886
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 887
  print_reg(src);
  }
  {
#line 888
  tmp = get_reg___2(src);
  }
  {
#line 888
  put_reg___2(dst, tmp);
  }
  }
#line 889
  return;
}
}
#line 891 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
  {
#line 893
  tmp = get_imm16___2();
  }
#line 893
  ofs = (long )tmp;
  }
  {
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 895
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 896
  tmp___0 = mem_get___2((uint32_t )ofs);
  }
#line 896
  gbcpu_regs.rn.a = (uint8_t )tmp___0;
  }
#line 897
  return;
}
}
#line 899 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_a___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 901
  tmp = get_imm16___2();
  }
#line 901
  ofs = (long )tmp;
  }
  {
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 903
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 904
  mem_put___2((uint32_t )ofs, (uint32_t )gbcpu_regs.rn.a);
  }
  }
#line 905
  return;
}
}
#line 907 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_ind16_sp___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  long sp ;

  {
  {
  {
#line 909
  tmp = get_imm16___2();
  }
#line 909
  ofs = (long )tmp;
#line 910
  sp = (long )*((uint16_t *)(& gbcpu_regs.ri[8]));
  }
  {
  {
#line 912
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 912
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 913
  mem_put___2((uint32_t )ofs, (uint32_t )(sp & 255L));
  }
  {
#line 914
  mem_put___2((uint32_t )(ofs + 1L), (uint32_t )(sp >> 8));
  }
  }
#line 915
  return;
}
}
#line 917 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_hlsp___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t ofs ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 919
  tmp = get_imm8___2();
  }
#line 919
  ofs = (int8_t )tmp;
#line 920
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 921
  new = (uint16_t )((int )old + (int )ofs);
  }
#line 923
  if ((int )ofs > 0) {
    {
    {
#line 923
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 923
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 924
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 924
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 925
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 926
  gbcpu_regs.rn.f = (uint8_t )0;
#line 927
  if ((int )old > (int )new) {
#line 927
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 928
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 928
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 929
  return;
}
}
#line 931 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_sphl___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 933
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 933
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  *((uint16_t *)(& gbcpu_regs.ri[8])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 935
  return;
}
}
#line 937 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 939
  tmp = get_imm16___2();
  }
#line 939
  val = (long )tmp;
#line 940
  reg = (long )((op >> 4) & 3U);
#line 942
  reg += (long )(reg > 2L);
  }
  {
  {
#line 943
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 943
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 944
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )val;
#line 945
  return;
}
}
#line 947 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg16_a___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t r ;
  uint32_t tmp ;

  {
#line 949
  reg = (long )((op >> 4) & 3U);
#line 952
  reg -= (long )(reg > 2L);
#line 953
  if (op & 8U) {
    {
    {
#line 954
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 954
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 955
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 955
    tmp = mem_get___2((uint32_t )r);
    }
#line 955
    gbcpu_regs.rn.a = (uint8_t )tmp;
    }
  } else {
    {
    {
#line 957
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 957
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 958
    r = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
    {
#line 958
    mem_put___2((uint32_t )r, (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 961
  if (reg == 2L) {
#line 962
    r = (uint16_t )((int )r + ((((op & 16U) == 0U) << 1) - 1));
#line 963
    *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = r;
  }
#line 965
  return;
}
}
#line 967 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ld_reg8_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long val ;
  uint32_t tmp ;
  long reg ;

  {
  {
  {
#line 969
  tmp = get_imm8___2();
  }
#line 969
  val = (long )tmp;
#line 970
  reg = (long )((op >> 3) & 7U);
  }
  {
  {
#line 972
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 972
    goto while_break;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 973
  print_reg(reg);
  }
  {
#line 974
  put_reg___2(reg, (uint32_t )val);
  }
  }
  {
  {
#line 975
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 975
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 976
  return;
}
}
#line 978 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ldh___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long ofs ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 980
  if (op & 2U) {
#line 980
    tmp___0 = (uint32_t )0;
  } else {
    {
    {
#line 980
    tmp = get_imm8___2();
    }
#line 980
    tmp___0 = tmp;
    }
  }
#line 980
  ofs = (long )tmp___0;
#line 982
  if (op & 16U) {
    {
    {
#line 983
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 983
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 984
    if ((op & 2U) == 0U) {
      {
      {
#line 985
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 985
        goto while_break___0;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 987
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 988
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 988
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 990
    tmp___1 = mem_get___2((uint32_t )(65280L + ofs));
    }
#line 990
    gbcpu_regs.rn.a = (uint8_t )tmp___1;
    }
  } else {
#line 992
    if ((op & 2U) == 0U) {
      {
      {
#line 993
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 993
        goto while_break___2;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 995
      ofs = (long )gbcpu_regs.rn.c;
      {
      {
#line 996
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 996
        goto while_break___3;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
    {
#line 998
    mem_put___2((uint32_t )(65280L + ofs), (uint32_t )gbcpu_regs.rn.a);
    }
    }
  }
#line 1000
  return;
}
}
#line 1002 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1004
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1008
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1008
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1009
  print_reg(reg);
  }
  {
#line 1010
  tmp = get_reg___2(reg);
  }
#line 1010
  res = (uint8_t )tmp;
#line 1010
  old = res;
#line 1011
  res = (uint8_t )((int )res + 1);
  {
#line 1012
  put_reg___2(reg, (uint32_t )res);
  }
#line 1013
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -225);
  }
#line 1014
  if ((int )res == 0) {
#line 1014
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1015
  if (((int )old & 15) > ((int )res & 15)) {
#line 1015
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1016
  return;
}
}
#line 1018 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_inc16___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1020
  reg = (long )((op >> 4) & 3U);
#line 1021
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1023
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1023
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  res = (uint16_t )((int )res + 1);
#line 1025
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1026
  return;
}
}
#line 1028 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint8_t res ;
  uint8_t old ;
  uint32_t tmp ;

  {
#line 1030
  reg = (long )((op >> 3) & 7U);
  {
  {
#line 1034
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1034
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1035
  print_reg(reg);
  }
  {
#line 1036
  tmp = get_reg___2(reg);
  }
#line 1036
  res = (uint8_t )tmp;
#line 1036
  old = res;
#line 1037
  res = (uint8_t )((int )res - 1);
  {
#line 1038
  put_reg___2(reg, (uint32_t )res);
  }
#line 1039
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 64);
#line 1040
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -161);
  }
#line 1041
  if ((int )res == 0) {
#line 1041
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1042
  if (((int )old & 15) > ((int )res & 15)) {
#line 1042
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1043
  return;
}
}
#line 1045 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_dec16___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t res ;

  {
#line 1047
  reg = (long )((op >> 4) & 3U);
#line 1048
  res = *((uint16_t *)(& gbcpu_regs.ri[reg * 2L]));
  {
  {
#line 1050
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1050
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1051
  res = (uint16_t )((int )res - 1);
#line 1052
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = res;
#line 1053
  return;
}
}
#line 1055 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_sp_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int8_t imm ;
  uint32_t tmp ;
  uint16_t old ;
  uint16_t new ;

  {
  {
  {
#line 1057
  tmp = get_imm8___2();
  }
#line 1057
  imm = (int8_t )tmp;
#line 1058
  old = *((uint16_t *)(& gbcpu_regs.ri[8]));
#line 1059
  new = old;
  }
  {
  {
#line 1061
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1061
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  new = (uint16_t )((int )new + (int )imm);
#line 1063
  *((uint16_t *)(& gbcpu_regs.ri[8])) = new;
#line 1064
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1065
  if ((int )old > (int )new) {
#line 1065
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1066
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1066
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1067
  return;
}
}
#line 1069 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1071
  old = gbcpu_regs.rn.a;
  {
  {
#line 1074
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1074
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1075
  print_reg((long )(op & 7U));
  }
  {
#line 1076
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1076
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1077
  new = gbcpu_regs.rn.a;
#line 1078
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1079
  if ((int )old > (int )new) {
#line 1079
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1080
  if (((int )old & 15) > ((int )new & 15)) {
#line 1080
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1081
  if ((int )new == 0) {
#line 1081
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1082
  return;
}
}
#line 1084 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1086
  tmp = get_imm8___2();
  }
#line 1086
  imm = (uint8_t )tmp;
#line 1087
  old = gbcpu_regs.rn.a;
#line 1088
  new = old;
  }
  {
  {
#line 1090
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1090
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1091
  new = (uint8_t )((int )new + (int )imm);
#line 1092
  gbcpu_regs.rn.a = new;
#line 1093
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1094
  if ((int )old > (int )new) {
#line 1094
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1095
  if (((int )old & 15) > ((int )new & 15)) {
#line 1095
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1096
  if ((int )new == 0) {
#line 1096
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1097
  return;
}
}
#line 1099 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_add_hl___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint16_t old ;
  uint16_t new ;

  {
#line 1101
  reg = (long )((op >> 4) & 3U);
#line 1102
  old = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1103
  new = old;
#line 1105
  reg += (long )(reg > 2L);
  {
  {
#line 1106
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1106
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  new = (uint16_t )((int )new + (int )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
#line 1109
  *((uint16_t *)(& gbcpu_regs.ri[4])) = new;
#line 1111
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -113);
#line 1112
  if ((int )old > (int )new) {
#line 1112
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1113
  if (((int )old & 4095) > ((int )new & 4095)) {
#line 1113
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1114
  return;
}
}
#line 1116 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1118
  old = gbcpu_regs.rn.a;
  {
  {
#line 1121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1121
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1122
  print_reg((long )(op & 7U));
  }
  {
#line 1123
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1123
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a + tmp);
#line 1124
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1125
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1126
  new = gbcpu_regs.rn.a;
  }
#line 1127
  if ((int )old > (int )new) {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1127
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1128
  if (((int )old & 15) > ((int )new & 15)) {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1128
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1129
  if ((int )new == 0) {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1129
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1130
  return;
}
}
#line 1132 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_adc_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1134
  tmp = get_imm8___2();
  }
#line 1134
  imm = (uint8_t )tmp;
#line 1135
  old = gbcpu_regs.rn.a;
#line 1136
  new = old;
  }
  {
  {
#line 1138
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1138
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  new = (uint8_t )((int )new + (int )imm);
#line 1140
  new = (uint8_t )((int )new + (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1141
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -65);
#line 1142
  gbcpu_regs.rn.a = new;
#line 1143
  if ((int )old > (int )new) {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  } else {
#line 1143
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -17);
  }
#line 1144
  if (((int )old & 15) > ((int )new & 15)) {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  } else {
#line 1144
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -33);
  }
#line 1145
  if ((int )new == 0) {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  } else {
#line 1145
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -129);
  }
#line 1146
  return;
}
}
#line 1148 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1150
  old = gbcpu_regs.rn.a;
#line 1151
  new = old;
  {
  {
#line 1153
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1153
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1154
  print_reg((long )(op & 7U));
  }
  {
#line 1155
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1155
  new = (uint8_t )((uint32_t )new - tmp);
#line 1156
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1157
  if ((int )old < (int )new) {
#line 1157
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1158
  if (((int )old & 15) < ((int )new & 15)) {
#line 1158
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1159
  if ((int )new == 0) {
#line 1159
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1160
  return;
}
}
#line 1162 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cp_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1164
  tmp = get_imm8___2();
  }
#line 1164
  imm = (uint8_t )tmp;
#line 1165
  old = gbcpu_regs.rn.a;
#line 1166
  new = old;
  }
  {
  {
#line 1168
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1168
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1169
  new = (uint8_t )((int )new - (int )imm);
#line 1170
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1171
  if ((int )old < (int )new) {
#line 1171
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1172
  if (((int )old & 15) < ((int )new & 15)) {
#line 1172
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1173
  if ((int )new == 0) {
#line 1173
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1174
  return;
}
}
#line 1176 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1178
  old = gbcpu_regs.rn.a;
  {
  {
#line 1181
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1181
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1182
  print_reg((long )(op & 7U));
  }
  {
#line 1183
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1183
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1184
  new = gbcpu_regs.rn.a;
#line 1185
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1186
  if ((int )old < (int )new) {
#line 1186
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1187
  if (((int )old & 15) < ((int )new & 15)) {
#line 1187
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1188
  if ((int )new == 0) {
#line 1188
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1189
  return;
}
}
#line 1191 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sub_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1193
  tmp = get_imm8___2();
  }
#line 1193
  imm = (uint8_t )tmp;
#line 1194
  old = gbcpu_regs.rn.a;
#line 1195
  new = old;
  }
  {
  {
#line 1197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1197
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  new = (uint8_t )((int )new - (int )imm);
#line 1199
  gbcpu_regs.rn.a = new;
#line 1200
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1201
  if ((int )old < (int )new) {
#line 1201
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1202
  if (((int )old & 15) < ((int )new & 15)) {
#line 1202
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1203
  if ((int )new == 0) {
#line 1203
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1204
  return;
}
}
#line 1206 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t old ;
  uint8_t new ;
  uint32_t tmp ;

  {
#line 1208
  old = gbcpu_regs.rn.a;
  {
  {
#line 1211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1211
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1212
  print_reg((long )(op & 7U));
  }
  {
#line 1213
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1213
  gbcpu_regs.rn.a = (uint8_t )((uint32_t )gbcpu_regs.rn.a - tmp);
#line 1214
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1215
  new = gbcpu_regs.rn.a;
#line 1216
  gbcpu_regs.rn.f = (uint8_t )64;
  }
#line 1217
  if ((int )old < (int )new) {
#line 1217
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1218
  if (((int )old & 15) < ((int )new & 15)) {
#line 1218
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1219
  if ((int )new == 0) {
#line 1219
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1220
  return;
}
}
#line 1222 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_sbc_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;
  uint8_t old ;
  uint8_t new ;

  {
  {
  {
#line 1224
  tmp = get_imm8___2();
  }
#line 1224
  imm = (uint8_t )tmp;
#line 1225
  old = gbcpu_regs.rn.a;
#line 1226
  new = old;
  }
  {
  {
#line 1228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1228
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  new = (uint8_t )((int )new - (int )imm);
#line 1230
  new = (uint8_t )((int )new - (((int )gbcpu_regs.rn.f & 16) > 0));
#line 1231
  gbcpu_regs.rn.a = new;
#line 1232
  gbcpu_regs.rn.f = (uint8_t )64;
#line 1233
  if ((int )old < (int )new) {
#line 1233
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
  }
#line 1234
  if (((int )old & 15) < ((int )new & 15)) {
#line 1234
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 32);
  }
#line 1235
  if ((int )new == 0) {
#line 1235
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1236
  return;
}
}
#line 1238 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1240
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1241
  print_reg((long )(op & 7U));
  }
  {
#line 1242
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1242
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a & tmp);
#line 1243
  gbcpu_regs.rn.f = (uint8_t )32;
  }
#line 1244
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1244
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1245
  return;
}
}
#line 1247 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_and_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1249
  tmp = get_imm8___2();
  }
#line 1249
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1251
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1251
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1252
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a & (int )imm);
#line 1253
  gbcpu_regs.rn.f = (uint8_t )32;
#line 1254
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1254
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1255
  return;
}
}
#line 1257 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1259
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1260
  print_reg((long )(op & 7U));
  }
  {
#line 1261
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1261
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a | tmp);
#line 1262
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1263
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1263
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1264
  return;
}
}
#line 1266 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_or_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1268
  tmp = get_imm8___2();
  }
#line 1268
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1270
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a | (int )imm);
#line 1272
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1273
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1273
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1274
  return;
}
}
#line 1276 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1278
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1279
  print_reg((long )(op & 7U));
  }
  {
#line 1280
  tmp = get_reg___2((long )(op & 7U));
  }
#line 1280
  gbcpu_regs.rn.a = (uint8_t )((unsigned int )gbcpu_regs.rn.a ^ tmp);
#line 1281
  gbcpu_regs.rn.f = (uint8_t )0;
  }
#line 1282
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1282
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1283
  return;
}
}
#line 1285 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_xor_imm___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint8_t imm ;
  uint32_t tmp ;

  {
  {
  {
#line 1287
  tmp = get_imm8___2();
  }
#line 1287
  imm = (uint8_t )tmp;
  }
  {
  {
#line 1289
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1289
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1290
  gbcpu_regs.rn.a = (uint8_t )((int )gbcpu_regs.rn.a ^ (int )imm);
#line 1291
  gbcpu_regs.rn.f = (uint8_t )0;
#line 1292
  if ((int )gbcpu_regs.rn.a == 0) {
#line 1292
    gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 128);
  }
#line 1293
  return;
}
}
#line 1295 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_push___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;

  {
  {
#line 1297
  reg = (long )((op >> 4) & 3U);
  {
#line 1299
  push___2((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[reg * 2L])));
  }
  }
  {
  {
#line 1300
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1300
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1301
  return;
}
}
#line 1303 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_pop___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long reg ;
  uint32_t tmp ;

  {
  {
#line 1305
  reg = (long )((op >> 4) & 3U);
  {
#line 1307
  tmp = pop___2();
  }
#line 1307
  *((uint16_t *)(& gbcpu_regs.ri[reg * 2L])) = (uint16_t )tmp;
  }
  {
  {
#line 1308
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1308
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return;
}
}
#line 1311 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_cpl___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1313
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1313
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1314
  gbcpu_regs.rn.a = (uint8_t )(~ ((int )gbcpu_regs.rn.a));
#line 1315
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 96);
#line 1316
  return;
}
}
#line 1318 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ccf___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1320
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f ^ 16);
#line 1322
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1323
  return;
}
}
#line 1325 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_scf___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1327
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1327
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1328
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f | 16);
#line 1329
  gbcpu_regs.rn.f = (uint8_t )((int )gbcpu_regs.rn.f & -97);
#line 1330
  return;
}
}
#line 1332 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1334
  tmp = get_imm16___2();
  }
#line 1334
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1336
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1336
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1337
  push___2((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1338
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1339
  return;
}
}
#line 1341 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_call_cond___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1343
  tmp = get_imm16___2();
  }
#line 1343
  ofs = (uint16_t )tmp;
#line 1344
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1346
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1346
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1348
  if (cond == 0L) {
#line 1348
    goto case_0;
  }
#line 1349
  if (cond == 1L) {
#line 1349
    goto case_1;
  }
#line 1350
  if (cond == 2L) {
#line 1350
    goto case_2;
  }
#line 1351
  if (cond == 3L) {
#line 1351
    goto case_3;
  }
#line 1347
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1348
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1348
    return;
  }
#line 1348
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1349
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1349
    return;
  }
#line 1349
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1350
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1350
    return;
  }
#line 1350
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1351
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1351
    return;
  }
#line 1351
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1353
  push___2((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1354
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
  }
#line 1355
  return;
}
}
#line 1357 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1359
  tmp = pop___2();
  }
#line 1359
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1360
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1361
  return;
}
}
#line 1363 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_reti___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint32_t tmp ;

  {
  {
  {
#line 1365
  tmp = pop___2();
  }
#line 1365
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
  {
  {
#line 1366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1366
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1367
  return;
}
}
#line 1369 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ret_cond___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  long cond ;
  uint32_t tmp ;

  {
#line 1371
  cond = (long )((op >> 3) & 3U);
  {
  {
#line 1373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1373
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1375
  if (cond == 0L) {
#line 1375
    goto case_0;
  }
#line 1376
  if (cond == 1L) {
#line 1376
    goto case_1;
  }
#line 1377
  if (cond == 2L) {
#line 1377
    goto case_2;
  }
#line 1378
  if (cond == 3L) {
#line 1378
    goto case_3;
  }
#line 1374
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1375
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1375
    return;
  }
#line 1375
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1376
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1376
    return;
  }
#line 1376
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1377
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1377
    return;
  }
#line 1377
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1378
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1378
    return;
  }
#line 1378
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1380
  tmp = pop___2();
  }
#line 1380
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )tmp;
  }
#line 1381
  return;
}
}
#line 1383 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_halt___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1385
  gbcpu_halted = 1L;
  {
  {
#line 1386
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1386
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  return;
}
}
#line 1389 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_stop___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1391
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1391
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  return;
}
}
#line 1394 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_di___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1396
  gbcpu_if = 0L;
  {
  {
#line 1397
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1397
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1398
  return;
}
}
#line 1400 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_ei___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
#line 1402
  gbcpu_if = 1L;
  {
  {
#line 1403
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1403
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1406 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1408
  tmp = get_imm8___2();
  }
#line 1408
  ofs = (int16_t )((int8_t )tmp);
  }
#line 1410
  if ((int )ofs < 0) {
    {
    {
#line 1410
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1410
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1411
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1411
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1412
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1413
  return;
}
}
#line 1415 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jr_cond___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1417
  tmp = get_imm8___2();
  }
#line 1417
  ofs = (int16_t )((int8_t )tmp);
#line 1418
  cond = (long )((op >> 3) & 3U);
  }
#line 1420
  if ((int )ofs < 0) {
    {
    {
#line 1420
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1420
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1421
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1421
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1423
  if (cond == 0L) {
#line 1423
    goto case_0;
  }
#line 1424
  if (cond == 1L) {
#line 1424
    goto case_1;
  }
#line 1425
  if (cond == 2L) {
#line 1425
    goto case_2;
  }
#line 1426
  if (cond == 3L) {
#line 1426
    goto case_3;
  }
#line 1422
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1423
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1423
    return;
  }
#line 1423
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1424
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1424
    return;
  }
#line 1424
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1425
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1425
    return;
  }
#line 1425
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1426
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1426
    return;
  }
#line 1426
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1428
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )((int )*((uint16_t *)(& gbcpu_regs.ri[10])) + (int )ofs);
#line 1429
  return;
}
}
#line 1431 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;

  {
  {
  {
#line 1433
  tmp = get_imm16___2();
  }
#line 1433
  ofs = (uint16_t )tmp;
  }
  {
  {
#line 1435
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1435
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1436
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1437
  return;
}
}
#line 1439 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_hl___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1441
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1441
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1442
  *((uint16_t *)(& gbcpu_regs.ri[10])) = *((uint16_t *)(& gbcpu_regs.ri[4]));
#line 1443
  return;
}
}
#line 1445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_jp_cond___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  uint16_t ofs ;
  uint32_t tmp ;
  long cond ;

  {
  {
  {
#line 1447
  tmp = get_imm16___2();
  }
#line 1447
  ofs = (uint16_t )tmp;
#line 1448
  cond = (long )((op >> 3) & 3U);
  }
  {
  {
#line 1450
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1450
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1452
  if (cond == 0L) {
#line 1452
    goto case_0;
  }
#line 1453
  if (cond == 1L) {
#line 1453
    goto case_1;
  }
#line 1454
  if (cond == 2L) {
#line 1454
    goto case_2;
  }
#line 1455
  if (cond == 3L) {
#line 1455
    goto case_3;
  }
#line 1451
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1452
  if (((int )gbcpu_regs.rn.f & 128) != 0) {
#line 1452
    return;
  }
#line 1452
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1453
  if (((int )gbcpu_regs.rn.f & 128) == 0) {
#line 1453
    return;
  }
#line 1453
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1454
  if (((int )gbcpu_regs.rn.f & 16) != 0) {
#line 1454
    return;
  }
#line 1454
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1455
  if (((int )gbcpu_regs.rn.f & 16) == 0) {
#line 1455
    return;
  }
#line 1455
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1457
  *((uint16_t *)(& gbcpu_regs.ri[10])) = ofs;
#line 1458
  return;
}
}
#line 1460 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_rst___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 
  int16_t ofs ;

  {
#line 1462
  ofs = (int16_t )(op & 56U);
  {
  {
#line 1464
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1464
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1465
  push___2((uint32_t )*((uint16_t *)(& gbcpu_regs.ri[10])));
  }
#line 1466
  *((uint16_t *)(& gbcpu_regs.ri[10])) = (uint16_t )ofs;
  }
#line 1467
  return;
}
}
#line 1469 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static void ( __attribute__((__regparm__(3))) op_nop___2)(uint32_t op , struct opinfo  const  *oi ) 
{ 


  {
  {
  {
#line 1471
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1471
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  return;
}
}
#line 1474 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbcpu.c"
static struct opinfo  const  ops___2[256]  = 
#line 1474
  {      {& op_nop___2}, 
        {& op_ld_reg16_imm___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_inc16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_rlca___2}, 
        {& op_ld_ind16_sp___2}, 
        {& op_add_hl___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_dec16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_rrca___2}, 
        {& op_stop___2}, 
        {& op_ld_reg16_imm___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_inc16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_rla___2}, 
        {& op_jr___2}, 
        {& op_add_hl___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_dec16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_rra___2}, 
        {& op_jr_cond___2}, 
        {& op_ld_reg16_imm___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_inc16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_unknown___2}, 
        {& op_jr_cond___2}, 
        {& op_add_hl___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_dec16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_cpl___2}, 
        {& op_jr_cond___2}, 
        {& op_ld_reg16_imm___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_inc16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_scf___2}, 
        {& op_jr_cond___2}, 
        {& op_add_hl___2}, 
        {& op_ld_reg16_a___2}, 
        {& op_dec16___2}, 
        {& op_inc___2}, 
        {& op_dec___2}, 
        {& op_ld_reg8_imm___2}, 
        {& op_ccf___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_halt___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_ld___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_add___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_adc___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sub___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_sbc___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_and___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_xor___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_or___2}, 
        {& op_cp___2}, 
        {& op_cp___2}, 
        {& op_cp___2}, 
        {& op_cp___2}, 
        {& op_cp___2}, 
        {& op_cp___2}, 
        {& op_cp___2}, 
        {& op_unknown___2}, 
        {& op_ret_cond___2}, 
        {& op_pop___2}, 
        {& op_jp_cond___2}, 
        {& op_jp___2}, 
        {& op_call_cond___2}, 
        {& op_push___2}, 
        {& op_add_imm___2}, 
        {& op_rst___2}, 
        {& op_ret_cond___2}, 
        {& op_ret___2}, 
        {& op_jp_cond___2}, 
        {& op_cbprefix___2}, 
        {& op_call_cond___2}, 
        {& op_call___2}, 
        {& op_adc_imm___2}, 
        {& op_rst___2}, 
        {& op_ret_cond___2}, 
        {& op_pop___2}, 
        {& op_jp_cond___2}, 
        {& op_unknown___2}, 
        {& op_call_cond___2}, 
        {& op_push___2}, 
        {& op_sub_imm___2}, 
        {& op_rst___2}, 
        {& op_ret_cond___2}, 
        {& op_reti___2}, 
        {& op_jp_cond___2}, 
        {& op_unknown___2}, 
        {& op_call_cond___2}, 
        {& op_unknown___2}, 
        {& op_sbc_imm___2}, 
        {& op_rst___2}, 
        {& op_ldh___2}, 
        {& op_pop___2}, 
        {& op_ldh___2}, 
        {& op_unknown___2}, 
        {& op_unknown___2}, 
        {& op_push___2}, 
        {& op_and_imm___2}, 
        {& op_rst___2}, 
        {& op_add_sp_imm___2}, 
        {& op_jp_hl___2}, 
        {& op_ld_ind16_a___2}, 
        {& op_unknown___2}, 
        {& op_unknown___2}, 
        {& op_unknown___2}, 
        {& op_xor_imm___2}, 
        {& op_rst___2}, 
        {& op_ldh___2}, 
        {& op_pop___2}, 
        {& op_ldh___2}, 
        {& op_di___2}, 
        {& op_unknown___2}, 
        {& op_push___2}, 
        {& op_or_imm___2}, 
        {& op_rst___2}, 
        {& op_ld_hlsp___2}, 
        {& op_ld_sphl___2}, 
        {& op_ld_imm___2}, 
        {& op_ei___2}, 
        {& op_unknown___2}, 
        {& op_unknown___2}, 
        {& op_cp_imm___2}, 
        {& op_rst___2}};
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t *rom___2  ;
#line 21 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t intram___2[8192]  ;
#line 22 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t extram___2[8192]  ;
#line 23 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t ioregs___2[128]  ;
#line 24 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint8_t hiram___2[128]  ;
#line 25 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rombank___2  =    1L;
#line 26 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lastbank___2  ;
#line 28 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static char const   dutylookup___2[4]  = {      (char const   )1,      (char const   )2,      (char const   )4,      (char const   )6};
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lminval___2  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long lmaxval___2  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rminval___2  ;
#line 34 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long rmaxval___2  ;
#line 38 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_volume___2  ;
#line 39 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_fade___2  ;
#line 40 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long master_dstvol___2  ;
#line 42 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   vblanktc___2  =    (long const   )70256;
#line 43 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long vblankctr___2  =    70256L;
#line 44 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timertc___2  =    70256L;
#line 45 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long timerctr___2  =    70256L;
#line 47 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   msec_cycles___2  =    (long const   )4194;
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sum_cycles___2  ;
#line 51 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long pause_output___2  =    0L;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*callback___3))(struct gbhw_buffer *buf ,
                                                               void *priv )  ;
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *callbackpriv___2  ;
#line 55 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *soundbuf___2  =    (struct gbhw_buffer *)((void *)0);
#line 56 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static struct gbhw_buffer *impbuf___2  =    (struct gbhw_buffer *)((void *)0);
#line 58 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) (*iocallback___3))(long cycles , uint32_t addr ,
                                                                 uint8_t valu , void *priv )  ;
#line 59 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void *iocallback_priv___2  ;
#line 66 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap1___2  =    (uint32_t )16384;
#line 67 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t tap2___2  =    (uint32_t )8192;
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t lfsr___2  =    4294967295U;
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long long sound_div_tc___2  =    0LL;
#line 73 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   main_div_tc___2  =    (long const   )32;
#line 74 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long main_div___2  ;
#line 75 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long const   sweep_div_tc___2  =    (long const   )256;
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long sweep_div___2  ;
#line 78 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long ch3pos___2  ;
#line 80 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_n_shift___2  =    7L;
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long impulse_w_shift___2  =    5L;
#line 82 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static double impulse_cutoff___2  =    1.0;
#line 84 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static short *base_impulse___2  =    (short *)((void *)0);
#line 90 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rom_get___2)(uint32_t addr ) 
{ 


  {
#line 93
  return ((uint32_t )*(rom___2 + (addr & 16383U)));
}
}
#line 96 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) rombank_get___2)(uint32_t addr ) 
{ 


  {
#line 99
  return ((uint32_t )*(rom___2 + ((long )(addr & 16383U) + 16384L * rombank___2)));
}
}
#line 102 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) io_get___2)(uint32_t addr ) 
{ 
  char *__cil_tmp2 ;

  {
#line 104
  if (addr >= 65408U) {
#line 104
    if (addr <= 65534U) {
#line 105
      return ((uint32_t )hiram___2[addr & 127U]);
    }
  }
#line 107
  if (addr >= 65296U) {
#line 107
    if (addr <= 65343U) {
#line 109
      return ((uint32_t )ioregs___2[addr & 127U]);
    }
  }
#line 111
  if (addr == 65280U) {
#line 111
    return ((uint32_t )0);
  }
#line 112
  if (addr == 65535U) {
#line 112
    return ((uint32_t )ioregs___2[127]);
  }
  {
  {
#line 113
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ioread from 0x%04x unimplemented.\n",
          addr);
  }
  }
  {
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((uint32_t )255);
}
}
#line 118 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) intram_get___2)(uint32_t addr ) 
{ 


  {
#line 121
  return ((uint32_t )intram___2[addr & 8191U]);
}
}
#line 124 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static uint32_t ( __attribute__((__regparm__(3))) extram_get___2)(uint32_t addr ) 
{ 


  {
#line 127
  return ((uint32_t )extram___2[addr & 8191U]);
}
}
#line 130 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) rom_put___2)(uint32_t addr , uint8_t val ) 
{ 
  char *__cil_tmp3 ;

  {
#line 132
  if (addr >= 8192U) {
#line 132
    if (addr <= 16383U) {
#line 133
      val = (uint8_t )((int )val & 31);
#line 134
      rombank___2 = (long )((int )val + ((int )val == 0));
#line 135
      if (rombank___2 > lastbank___2) {
        {
        {
#line 136
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bank %ld out of range (0-%ld)!\n",
                rombank___2, lastbank___2);
        }
#line 137
        rombank___2 = lastbank___2;
        }
      }
    }
  }
#line 140
  return;
}
}
#line 142 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) io_put___2)(uint32_t addr , uint8_t val ) 
{ 
  long chn ;
  long duty_ctr ;
  long len ;
  long vol ;
  long envdir ;
  long envspd ;
  long tmp ;
  long div___2 ;
  long vol___0 ;
  long div___3 ;
  long shift ;
  long rate___1 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 144
  (*iocallback___3)(sum_cycles___2, addr, val, iocallback_priv___2);
  }
#line 146
  chn = (long )((addr - 65296U) / 5U);
  }
#line 147
  if (addr >= 65408U) {
#line 147
    if (addr <= 65534U) {
#line 148
      hiram___2[addr & 127U] = val;
#line 149
      return;
    }
  }
#line 151
  ioregs___2[addr & 127U] = val;
  {
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 152
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  if (addr == 65287U) {
#line 155
    goto case_65287;
  }
#line 155
  if (addr == 65286U) {
#line 155
    goto case_65287;
  }
#line 160
  if (addr == 65296U) {
#line 160
    goto case_65296;
  }
#line 168
  if (addr == 65312U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65302U) {
#line 168
    goto case_65312;
  }
#line 168
  if (addr == 65297U) {
#line 168
    goto case_65312;
  }
#line 181
  if (addr == 65313U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65303U) {
#line 181
    goto case_65313;
  }
#line 181
  if (addr == 65298U) {
#line 181
    goto case_65313;
  }
#line 197
  if (addr == 65310U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65309U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65305U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65304U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65300U) {
#line 197
    goto case_65310;
  }
#line 197
  if (addr == 65299U) {
#line 197
    goto case_65310;
  }
#line 213
  if (addr == 65301U) {
#line 213
    goto case_65301;
  }
#line 215
  if (addr == 65306U) {
#line 215
    goto case_65306;
  }
#line 218
  if (addr == 65307U) {
#line 218
    goto case_65307;
  }
#line 221
  if (addr == 65308U) {
#line 221
    goto case_65308;
  }
#line 227
  if (addr == 65311U) {
#line 227
    goto case_65311;
  }
#line 230
  if (addr == 65315U) {
#line 230
    goto case_65315;
  }
#line 230
  if (addr == 65314U) {
#line 230
    goto case_65315;
  }
#line 252
  if (addr == 65317U) {
#line 252
    goto case_65317;
  }
#line 262
  if (addr == 65318U) {
#line 262
    goto case_65318;
  }
#line 292
  if (addr == 65535U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65343U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65342U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65341U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65340U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65339U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65338U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65337U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65336U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65335U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65334U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65333U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65332U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65331U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65330U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65329U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65328U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65327U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65326U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65325U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65324U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65323U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65322U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65321U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65320U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65319U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65316U) {
#line 292
    goto case_65535;
  }
#line 292
  if (addr == 65280U) {
#line 292
    goto case_65535;
  }
#line 294
  goto switch_default;
  case_65287: /* CIL Label */ 
  case_65286: /* CIL Label */ 
#line 156
  timertc___2 = (long )((256 - (int )ioregs___2[6]) * (16 << ((((int )ioregs___2[7] + 3) & 3) << 1)));
#line 157
  if (((int )ioregs___2[7] & 240) == 128) {
#line 157
    timertc___2 /= 2L;
  }
#line 159
  goto switch_break;
  case_65296: /* CIL Label */ 
#line 161
  gbhw_ch[0].sweep_tc = (long )(((int )val >> 4) & 7);
#line 161
  gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 162
  gbhw_ch[0].sweep_dir = (long )(((int )val >> 3) & 1);
#line 163
  gbhw_ch[0].sweep_shift = (long )((int )val & 7);
#line 165
  goto switch_break;
  case_65312: /* CIL Label */ 
  case_65302: /* CIL Label */ 
  case_65297: /* CIL Label */ 
#line 170
  duty_ctr = (long )((int )val >> 6);
#line 171
  len = (long )((int )val & 63);
#line 173
  gbhw_ch[chn].duty_ctr = (long )dutylookup___2[duty_ctr];
#line 174
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 175
  gbhw_ch[chn].len = (64L - len) * 2L;
#line 177
  goto switch_break;
  case_65313: /* CIL Label */ 
  case_65303: /* CIL Label */ 
  case_65298: /* CIL Label */ 
#line 183
  vol = (long )((int )val >> 4);
#line 184
  envdir = (long )(((int )val >> 3) & 1);
#line 185
  envspd = (long )((int )val & 7);
#line 187
  gbhw_ch[chn].volume = vol;
#line 188
  gbhw_ch[chn].env_dir = envdir;
#line 189
  tmp = envspd * 8L;
#line 189
  gbhw_ch[chn].env_tc = tmp;
#line 189
  gbhw_ch[chn].env_ctr = tmp;
#line 191
  goto switch_break;
  case_65310: /* CIL Label */ 
  case_65309: /* CIL Label */ 
  case_65305: /* CIL Label */ 
  case_65304: /* CIL Label */ 
  case_65300: /* CIL Label */ 
  case_65299: /* CIL Label */ 
#line 199
  div___2 = (long )ioregs___2[19L + 5L * chn];
#line 201
  div___2 |= ((long )ioregs___2[20L + 5L * chn] & 7L) << 8;
#line 202
  gbhw_ch[chn].div_tc = 2048L - div___2;
#line 203
  gbhw_ch[chn].duty_tc = (gbhw_ch[chn].div_tc * gbhw_ch[chn].duty_ctr) / 8L;
#line 205
  if (addr == 65299U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65304U) {
#line 207
    goto switch_break;
  } else
#line 205
  if (addr == 65309U) {
#line 207
    goto switch_break;
  }
#line 209
  gbhw_ch[chn].len_enable = (long )(((int )ioregs___2[20L + 5L * chn] & 64) > 0);
#line 212
  goto switch_break;
  case_65301: /* CIL Label */ 
#line 214
  goto switch_break;
  case_65306: /* CIL Label */ 
#line 216
  gbhw_ch[2].master = (long )(((int )ioregs___2[26] & 128) > 0);
#line 217
  goto switch_break;
  case_65307: /* CIL Label */ 
#line 219
  gbhw_ch[2].len = (long )((256 - (int )val) * 2);
#line 220
  goto switch_break;
  case_65308: /* CIL Label */ 
#line 223
  vol___0 = (long )(((int )ioregs___2[28] >> 5) & 3);
#line 224
  gbhw_ch[2].volume = vol___0;
#line 225
  goto switch_break;
  case_65311: /* CIL Label */ 
#line 228
  goto switch_break;
  case_65315: /* CIL Label */ 
  case_65314: /* CIL Label */ 
#line 232
  div___3 = (long )ioregs___2[34];
#line 233
  shift = div___3 >> 4;
#line 234
  rate___1 = div___3 & 7L;
#line 235
  gbhw_ch[3].div_ctr = 0L;
#line 236
  gbhw_ch[3].div_tc = (long )(1 << shift);
#line 237
  if (div___3 & 8L) {
#line 238
    tap1___2 = (uint32_t )64;
#line 239
    tap2___2 = (uint32_t )32;
  } else {
#line 241
    tap1___2 = (uint32_t )16384;
#line 242
    tap2___2 = (uint32_t )8192;
  }
#line 244
  lfsr___2 |= 1U;
#line 245
  if (rate___1) {
#line 245
    gbhw_ch[3].div_tc *= rate___1;
  } else {
#line 246
    gbhw_ch[3].div_tc /= 2L;
  }
#line 247
  if (addr == 65314U) {
#line 247
    goto switch_break;
  }
#line 250
  gbhw_ch[chn].len_enable = (long )(((int )ioregs___2[35] & 64) > 0);
#line 251
  goto switch_break;
  case_65317: /* CIL Label */ 
#line 253
  gbhw_ch[0].leftgate = (long )(((int )val & 16) > 0);
#line 254
  gbhw_ch[0].rightgate = (long )(((int )val & 1) > 0);
#line 255
  gbhw_ch[1].leftgate = (long )(((int )val & 32) > 0);
#line 256
  gbhw_ch[1].rightgate = (long )(((int )val & 2) > 0);
#line 257
  gbhw_ch[2].leftgate = (long )(((int )val & 64) > 0);
#line 258
  gbhw_ch[2].rightgate = (long )(((int )val & 4) > 0);
#line 259
  gbhw_ch[3].leftgate = (long )(((int )val & 128) > 0);
#line 260
  gbhw_ch[3].rightgate = (long )(((int )val & 8) > 0);
#line 261
  goto switch_break;
  case_65318: /* CIL Label */ 
#line 263
  ioregs___2[38] = (uint8_t )128;
#line 264
  goto switch_break;
  case_65535: /* CIL Label */ 
  case_65343: /* CIL Label */ 
  case_65342: /* CIL Label */ 
  case_65341: /* CIL Label */ 
  case_65340: /* CIL Label */ 
  case_65339: /* CIL Label */ 
  case_65338: /* CIL Label */ 
  case_65337: /* CIL Label */ 
  case_65336: /* CIL Label */ 
  case_65335: /* CIL Label */ 
  case_65334: /* CIL Label */ 
  case_65333: /* CIL Label */ 
  case_65332: /* CIL Label */ 
  case_65331: /* CIL Label */ 
  case_65330: /* CIL Label */ 
  case_65329: /* CIL Label */ 
  case_65328: /* CIL Label */ 
  case_65327: /* CIL Label */ 
  case_65326: /* CIL Label */ 
  case_65325: /* CIL Label */ 
  case_65324: /* CIL Label */ 
  case_65323: /* CIL Label */ 
  case_65322: /* CIL Label */ 
  case_65321: /* CIL Label */ 
  case_65320: /* CIL Label */ 
  case_65319: /* CIL Label */ 
  case_65316: /* CIL Label */ 
  case_65280: /* CIL Label */ 
#line 293
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 295
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iowrite to 0x%04x unimplemented (val=%02x).\n",
          addr, (int )val);
  }
  }
#line 296
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) intram_put___2)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 302
  intram___2[addr & 8191U] = val;
#line 303
  return;
}
}
#line 305 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) extram_put___2)(uint32_t addr , uint8_t val ) 
{ 


  {
#line 307
  extram___2[addr & 8191U] = val;
#line 308
  return;
}
}
#line 310 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound_sweep___2)(void) 
{ 
  long i ;
  long val ;

  {
#line 314
  if (gbhw_ch[0].sweep_tc) {
#line 315
    (gbhw_ch[0].sweep_ctr) --;
#line 316
    if (gbhw_ch[0].sweep_ctr < 0L) {
#line 317
      val = gbhw_ch[0].div_tc >> gbhw_ch[0].sweep_shift;
#line 319
      gbhw_ch[0].sweep_ctr = gbhw_ch[0].sweep_tc;
#line 320
      if (gbhw_ch[0].sweep_dir) {
#line 321
        if (gbhw_ch[0].div_tc < 2048L - val) {
#line 321
          gbhw_ch[0].div_tc += val;
        }
      } else
#line 323
      if (gbhw_ch[0].div_tc > val) {
#line 323
        gbhw_ch[0].div_tc -= val;
      }
#line 325
      gbhw_ch[0].duty_tc = (gbhw_ch[0].div_tc * gbhw_ch[0].duty_ctr) / 8L;
    }
  }
#line 328
  i = 0L;
  {
  {
#line 328
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < 4L)) {
#line 328
      goto while_break;
    }
#line 329
    if (gbhw_ch[i].len > 0L) {
#line 329
      if (gbhw_ch[i].len_enable) {
#line 330
        (gbhw_ch[i].len) --;
#line 331
        if (gbhw_ch[i].len == 0L) {
#line 332
          gbhw_ch[i].volume = 0L;
#line 333
          gbhw_ch[i].env_tc = 0L;
        }
      }
    }
#line 336
    if (gbhw_ch[i].env_tc) {
#line 337
      (gbhw_ch[i].env_ctr) --;
#line 338
      if (gbhw_ch[i].env_ctr <= 0L) {
#line 339
        gbhw_ch[i].env_ctr = gbhw_ch[i].env_tc;
#line 340
        if (! gbhw_ch[i].env_dir) {
#line 341
          if (gbhw_ch[i].volume > 0L) {
#line 342
            (gbhw_ch[i].volume) --;
          }
        } else
#line 344
        if (gbhw_ch[i].volume < 15L) {
#line 345
          (gbhw_ch[i].volume) ++;
        }
      }
    }
#line 328
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (master_fade___2) {
#line 351
    master_volume___2 += master_fade___2;
#line 352
    if (master_fade___2 > 0L) {
#line 352
      if (master_volume___2 >= master_dstvol___2) {
#line 356
        master_fade___2 = 0L;
#line 357
        master_volume___2 = master_dstvol___2;
      } else {
#line 352
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 352
    if (master_fade___2 < 0L) {
#line 352
      if (master_volume___2 <= master_dstvol___2) {
#line 356
        master_fade___2 = 0L;
#line 357
        master_volume___2 = master_dstvol___2;
      }
    }
  }
#line 361
  return;
}
}
#line 378 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_flush_buffer___2)(void) 
{ 
  long i ;
  long overlap ;
  long l_smpl ;
  long r_smpl ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 384
  if (! ((unsigned long )soundbuf___2 != (unsigned long )((void *)0))) {
    {
    {
#line 384
    __assert_fail("soundbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  384U, "gb_flush_buffer");
    }
    }
  }
#line 385
  if (! ((unsigned long )impbuf___2 != (unsigned long )((void *)0))) {
    {
    {
#line 385
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  385U, "gb_flush_buffer");
    }
    }
  }
#line 388
  l_smpl = soundbuf___2->l_lvl;
#line 389
  r_smpl = soundbuf___2->r_lvl;
#line 390
  i = 0L;
  {
  {
#line 390
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < soundbuf___2->samples)) {
#line 390
      goto while_break;
    }
#line 391
    l_smpl += (long )*(impbuf___2->data + i * 2L);
#line 392
    r_smpl += (long )*(impbuf___2->data + (i * 2L + 1L));
#line 393
    *(soundbuf___2->data + i * 2L) = (int16_t )((l_smpl * master_volume___2) / 65536L);
#line 394
    *(soundbuf___2->data + (i * 2L + 1L)) = (int16_t )((r_smpl * master_volume___2) / 65536L);
#line 395
    if (l_smpl > lmaxval___2) {
#line 395
      lmaxval___2 = l_smpl;
    }
#line 396
    if (l_smpl < lminval___2) {
#line 396
      lminval___2 = l_smpl;
    }
#line 397
    if (r_smpl > rmaxval___2) {
#line 397
      rmaxval___2 = r_smpl;
    }
#line 398
    if (r_smpl < rminval___2) {
#line 398
      rminval___2 = r_smpl;
    }
#line 390
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  soundbuf___2->pos = soundbuf___2->samples;
#line 401
  soundbuf___2->l_lvl = l_smpl;
#line 402
  soundbuf___2->r_lvl = r_smpl;
#line 404
  if ((unsigned long )callback___3 != (unsigned long )((void *)0)) {
    {
    {
#line 404
    (*callback___3)(soundbuf___2, callbackpriv___2);
    }
    }
  }
  {
#line 406
  overlap = impbuf___2->samples - soundbuf___2->samples;
  {
#line 407
  memmove((void *)impbuf___2->data, (void const   *)(impbuf___2->data + 2L * soundbuf___2->samples),
          (size_t )(4L * overlap));
  }
  {
#line 408
  memset((void *)(impbuf___2->data + 2L * overlap), 0, (size_t )(impbuf___2->bytes - 4L * overlap));
  }
  }
#line 409
  if (! (impbuf___2->bytes == impbuf___2->samples * 4L)) {
    {
    {
#line 409
    __assert_fail("impbuf->bytes == impbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  409U, "gb_flush_buffer");
    }
    }
  }
#line 410
  if (! (soundbuf___2->bytes == soundbuf___2->samples * 4L)) {
    {
    {
#line 410
    __assert_fail("soundbuf->bytes == soundbuf->samples*4", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  410U, "gb_flush_buffer");
    }
    }
  }
  {
  {
#line 411
  memset((void *)soundbuf___2->data, 0, (size_t )soundbuf___2->bytes);
  }
#line 412
  soundbuf___2->pos = 0L;
#line 414
  impbuf___2->cycles = (long )((long long )impbuf___2->cycles - (sound_div_tc___2 * (long long )soundbuf___2->samples) / 65536LL);
  }
#line 415
  return;
}
}
#line 417 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_change_level___2)(long l_ofs , long r_ofs ) 
{ 
  long pos ;
  long imp_idx ;
  long imp_l ;
  long imp_r ;
  long i ;
  short *ptr ;
  long bufi ;
  long impi ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 421
  imp_l = (long )(- (1 << impulse_w_shift___2) / 2);
#line 422
  imp_r = (long )((1 << impulse_w_shift___2) / 2);
#line 424
  ptr = base_impulse___2;
#line 426
  if (! ((unsigned long )impbuf___2 != (unsigned long )((void *)0))) {
    {
    {
#line 426
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  426U, "gb_change_level");
    }
    }
  }
#line 427
  pos = (long )(((long long )impbuf___2->cycles * 65536LL) / sound_div_tc___2);
#line 428
  imp_idx = (long )(((long long )(impbuf___2->cycles << impulse_n_shift___2) * 65536LL) / sound_div_tc___2) & (long )((1 << impulse_n_shift___2) - 1);
#line 429
  if (! (pos + imp_r < impbuf___2->samples)) {
    {
    {
#line 429
    __assert_fail("pos + imp_r < impbuf->samples", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  429U, "gb_change_level");
    }
    }
  }
#line 430
  if (! (pos + imp_l >= 0L)) {
    {
    {
#line 430
    __assert_fail("pos + imp_l >= 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  430U, "gb_change_level");
    }
    }
  }
#line 432
  ptr += imp_idx * (long )(1 << impulse_w_shift___2);
#line 434
  i = imp_l;
  {
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 434
    if (! (i < imp_r)) {
#line 434
      goto while_break;
    }
#line 435
    bufi = pos + i;
#line 436
    impi = i + (long )((1 << impulse_w_shift___2) / 2);
#line 437
    *(impbuf___2->data + bufi * 2L) = (int16_t )((long )*(impbuf___2->data + bufi * 2L) + (long )*(ptr + impi) * l_ofs);
#line 438
    *(impbuf___2->data + (bufi * 2L + 1L)) = (int16_t )((long )*(impbuf___2->data + (bufi * 2L + 1L)) + (long )*(ptr + impi) * r_ofs);
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  impbuf___2->l_lvl += l_ofs * 256L;
#line 442
  impbuf___2->r_lvl += r_ofs * 256L;
#line 443
  return;
}
}
#line 449
static void ( __attribute__((__regparm__(3))) gb_sound___2)(long cycles ) ;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_l___2  =    0L;
#line 449 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long old_r___2  =    0L;
#line 511 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static long val___4  ;
#line 445 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gb_sound___2)(long cycles ) 
{ 
  long i ;
  long j ;
  long l_lvl ;
  long r_lvl ;
  long pos ;
  long tmp ;
  long val ;
  long index___0 ;
  long shift ;
  long old_l___3 ;
  long old_r___3 ;
  long l_diff ;
  long r_diff ;
  long val___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 448
  l_lvl = 0L;
#line 448
  r_lvl = 0L;
#line 451
  if (! ((unsigned long )impbuf___2 != (unsigned long )((void *)0))) {
    {
    {
#line 451
    __assert_fail("impbuf != ((void *)0)", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  451U, "gb_sound");
    }
    }
  }
#line 453
  j = 0L;
  {
  {
#line 453
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 453
    if (! (j < cycles)) {
#line 453
      goto while_break;
    }
#line 454
    main_div___2 ++;
#line 455
    (impbuf___2->cycles) ++;
#line 456
    if ((long long )impbuf___2->cycles * 65536LL >= sound_div_tc___2 * (long long )(impbuf___2->samples - (long )((1 << impulse_w_shift___2) / 2))) {
      {
      {
#line 457
      gb_flush_buffer___2();
      }
      }
    }
#line 459
    if (gbhw_ch[2].master) {
#line 460
      (gbhw_ch[2].div_ctr) --;
#line 461
      if (gbhw_ch[2].div_ctr <= 0L) {
#line 462
        tmp = ch3pos___2;
#line 462
        ch3pos___2 ++;
#line 462
        pos = tmp;
#line 463
        index___0 = (pos >> 1) & 15L;
#line 463
        shift = (~ pos & 1L) << 2;
#line 463
        val = (long )(((int )*(& ioregs___2[48] + index___0) >> shift) & 15);
#line 464
        old_l___3 = gbhw_ch[2].l_lvl;
#line 465
        old_r___3 = gbhw_ch[2].r_lvl;
#line 467
        gbhw_ch[2].div_ctr = gbhw_ch[2].div_tc * 2L;
#line 468
        if (gbhw_ch[2].volume) {
#line 469
          val >>= gbhw_ch[2].volume - 1L;
        } else {
#line 470
          val = 0L;
        }
#line 471
        val *= 2L;
#line 472
        if (gbhw_ch[2].volume) {
#line 472
          if (! gbhw_ch[2].mute) {
#line 473
            if (gbhw_ch[2].leftgate) {
#line 474
              gbhw_ch[2].l_lvl = val;
            }
#line 475
            if (gbhw_ch[2].rightgate) {
#line 476
              gbhw_ch[2].r_lvl = val;
            }
          }
        }
        {
#line 478
        l_diff = gbhw_ch[2].l_lvl - old_l___3;
#line 479
        r_diff = gbhw_ch[2].r_lvl - old_r___3;
        {
#line 480
        gb_change_level___2(l_diff, r_diff);
        }
        }
      }
    }
#line 484
    if (main_div___2 > (long )main_div_tc___2) {
#line 485
      main_div___2 -= (long )main_div_tc___2;
#line 487
      i = 0L;
      {
      {
#line 487
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 487
        if (! (i < 2L)) {
#line 487
          goto while_break___0;
        }
#line 487
        if (gbhw_ch[i].master) {
#line 488
          val___0 = gbhw_ch[i].volume;
#line 489
          if (gbhw_ch[i].div_ctr > gbhw_ch[i].duty_tc) {
#line 490
            val___0 = - val___0;
          }
#line 492
          if (! gbhw_ch[i].mute) {
#line 493
            if (gbhw_ch[i].leftgate) {
#line 494
              gbhw_ch[i].l_lvl = val___0;
            }
#line 495
            if (gbhw_ch[i].rightgate) {
#line 496
              gbhw_ch[i].r_lvl = val___0;
            }
          }
#line 498
          (gbhw_ch[i].div_ctr) --;
#line 499
          if (gbhw_ch[i].div_ctr <= 0L) {
#line 500
            gbhw_ch[i].div_ctr = gbhw_ch[i].div_tc;
          }
        }
#line 487
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 503
      i = 0L;
      {
      {
#line 503
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 503
        if (! (i < 2L)) {
#line 503
          goto while_break___1;
        }
#line 504
        l_lvl += gbhw_ch[i].l_lvl;
#line 505
        r_lvl += gbhw_ch[i].r_lvl;
#line 503
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 508
      if (gbhw_ch[3].master) {
#line 512
        if (! gbhw_ch[3].mute) {
#line 513
          if (gbhw_ch[3].leftgate) {
#line 514
            gbhw_ch[3].l_lvl = val___4;
          }
#line 515
          if (gbhw_ch[3].rightgate) {
#line 516
            gbhw_ch[3].r_lvl = val___4;
          }
        }
#line 518
        (gbhw_ch[3].div_ctr) --;
#line 519
        if (gbhw_ch[3].div_ctr <= 0L) {
#line 520
          gbhw_ch[3].div_ctr = gbhw_ch[3].div_tc;
#line 521
          lfsr___2 = (lfsr___2 << 1) | (unsigned int )(((lfsr___2 & tap1___2) > 0U) ^ ((lfsr___2 & tap2___2) > 0U));
#line 522
          val___4 = gbhw_ch[3].volume * (long )((lfsr___2 & 2U) - 1U);
        }
      }
#line 525
      l_lvl += gbhw_ch[3].l_lvl;
#line 526
      r_lvl += gbhw_ch[3].r_lvl;
#line 528
      if (l_lvl != old_l___2) {
        {
        {
#line 529
        gb_change_level___2(l_lvl - old_l___2, r_lvl - old_r___2);
        }
#line 530
        old_l___2 = l_lvl;
#line 531
        old_r___2 = r_lvl;
        }
      } else
#line 528
      if (r_lvl != old_r___2) {
        {
        {
#line 529
        gb_change_level___2(l_lvl - old_l___2, r_lvl - old_r___2);
        }
#line 530
        old_l___2 = l_lvl;
#line 531
        old_r___2 = r_lvl;
        }
      }
#line 534
      sweep_div___2 ++;
#line 535
      if (sweep_div___2 >= (long )sweep_div_tc___2) {
        {
#line 536
        sweep_div___2 = 0L;
        {
#line 537
        gb_sound_sweep___2();
        }
        }
      }
    }
#line 453
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return;
}
}
#line 555 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c"
static void ( __attribute__((__regparm__(3))) gbhw_impbuf_reset___2)(struct gbhw_buffer *impbuf___3 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 557
  if (! (sound_div_tc___2 != 0LL)) {
    {
    {
#line 557
    __assert_fail("sound_div_tc != 0", "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbhw.c",
                  557U, "gbhw_impbuf_reset");
    }
    }
  }
  {
#line 558
  impbuf___3->cycles = (long )(((sound_div_tc___2 * (long long )(1 << impulse_w_shift___2)) / 2LL) / 65536LL);
#line 559
  impbuf___3->l_lvl = 0L;
#line 560
  impbuf___3->r_lvl = 0L;
  {
#line 561
  memset((void *)impbuf___3->data, 0, (size_t )impbuf___3->bytes);
  }
  }
#line 562
  return;
}
}
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint8_t const   playercode___2[127]  = 
#line 27 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
  {      (uint8_t const   )245,      (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )48, 
        (uint8_t const   )0,      (uint8_t const   )17,      (uint8_t const   )16,      (uint8_t const   )255, 
        (uint8_t const   )33,      (uint8_t const   )159,      (uint8_t const   )0,      (uint8_t const   )42, 
        (uint8_t const   )18,      (uint8_t const   )19,      (uint8_t const   )11,      (uint8_t const   )120, 
        (uint8_t const   )177,      (uint8_t const   )32,      (uint8_t const   )248,      (uint8_t const   )225, 
        (uint8_t const   )229,      (uint8_t const   )1,      (uint8_t const   )14,      (uint8_t const   )0, 
        (uint8_t const   )9,      (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )6, 
        (uint8_t const   )42,      (uint8_t const   )224,      (uint8_t const   )7,      (uint8_t const   )17, 
        (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )203,      (uint8_t const   )87, 
        (uint8_t const   )62,      (uint8_t const   )1,      (uint8_t const   )40,      (uint8_t const   )2, 
        (uint8_t const   )62,      (uint8_t const   )4,      (uint8_t const   )18,      (uint8_t const   )225, 
        (uint8_t const   )241,      (uint8_t const   )87,      (uint8_t const   )229,      (uint8_t const   )1, 
        (uint8_t const   )8,      (uint8_t const   )0,      (uint8_t const   )9,      (uint8_t const   )42, 
        (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122,      (uint8_t const   )1, 
        (uint8_t const   )140,      (uint8_t const   )0,      (uint8_t const   )197,      (uint8_t const   )233, 
        (uint8_t const   )251,      (uint8_t const   )118,      (uint8_t const   )225,      (uint8_t const   )229, 
        (uint8_t const   )1,      (uint8_t const   )10,      (uint8_t const   )0,      (uint8_t const   )9, 
        (uint8_t const   )42,      (uint8_t const   )102,      (uint8_t const   )111,      (uint8_t const   )122, 
        (uint8_t const   )1,      (uint8_t const   )157,      (uint8_t const   )0,      (uint8_t const   )197, 
        (uint8_t const   )233,      (uint8_t const   )24,      (uint8_t const   )238,      (uint8_t const   )128, 
        (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191, 
        (uint8_t const   )0,      (uint8_t const   )63,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )191,      (uint8_t const   )127,      (uint8_t const   )255,      (uint8_t const   )159, 
        (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )0,      (uint8_t const   )255, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )191,      (uint8_t const   )119, 
        (uint8_t const   )243,      (uint8_t const   )241,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72,      (uint8_t const   )54, 
        (uint8_t const   )2,      (uint8_t const   )207,      (uint8_t const   )22,      (uint8_t const   )44, 
        (uint8_t const   )4,      (uint8_t const   )229,      (uint8_t const   )44,      (uint8_t const   )172, 
        (uint8_t const   )221,      (uint8_t const   )218,      (uint8_t const   )72};
#line 122 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static long ( __attribute__((__regparm__(3))) gbs_nextsubsong___2)(struct gbs *gbs ) 
{ 
  long tmp ;

  {
#line 124
  if ((unsigned long )gbs->nextsubsong_cb != (unsigned long )((void *)0)) {
    {
    {
#line 125
    tmp = (*(gbs->nextsubsong_cb))(gbs, gbs->nextsubsong_cb_priv);
    }
    }
#line 125
    return (tmp);
  } else {
#line 127
    (gbs->subsong) ++;
#line 128
    if (gbs->subsong >= gbs->songs) {
#line 129
      return (0L);
    }
    {
    {
#line 130
    gbs_init(gbs, gbs->subsong);
    }
    }
  }
#line 132
  return (1L);
}
}
#line 233 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static void ( __attribute__((__regparm__(3))) writeint___2)(char *buf___3 , uint32_t val ,
                                                            long bytes ) 
{ 
  long shift ;
  long i ;

  {
#line 235
  shift = 0L;
#line 238
  i = 0L;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < bytes)) {
#line 238
      goto while_break;
    }
#line 239
    *(buf___3 + i) = (char )((val >> shift) & 255U);
#line 240
    shift += 8L;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbs.c"
static uint32_t ( __attribute__((__regparm__(3))) readint___2)(char *buf___3 , long bytes ) 
{ 
  long i ;
  long shift ;
  uint32_t res ;

  {
#line 247
  shift = 0L;
#line 248
  res = (uint32_t )0;
#line 250
  i = 0L;
  {
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < bytes)) {
#line 250
      goto while_break;
    }
#line 251
    res |= (unsigned int )((int )((unsigned char )*(buf___3 + i)) << shift);
#line 252
    shift += 8L;
#line 250
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return (res);
}
}
#line 13 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static unsigned long crc_table___2[256]  ;
#line 20 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/crc32.c"
static void ( __attribute__((__regparm__(3))) make_crc_table___2)(void) 
{ 
  unsigned long i ;
  unsigned long j ;
  unsigned long h ;
  unsigned long tmp ;

  {
#line 21
  h = 1UL;
#line 22
  crc_table___2[0] = 0UL;
#line 23
  i = 128UL;
  {
  {
#line 23
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 23
    if (! i) {
#line 23
      goto while_break;
    }
#line 24
    if (h & 1UL) {
#line 24
      tmp = 3988292384UL;
    } else {
#line 24
      tmp = 0UL;
    }
#line 24
    h = (h >> 1) ^ tmp;
#line 26
    j = 0UL;
    {
    {
#line 26
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! (j < 256UL)) {
#line 26
        goto while_break___0;
      }
#line 27
      crc_table___2[i + j] = crc_table___2[j] ^ h;
#line 26
      j += 2UL * i;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 23
    i >>= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 44 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char notelookup___0[432]  ;
#line 45 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char vollookup___0[80]  ;
#line 46 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char const   vols___0[5]  = {      (char const   )' ',      (char const   )'-',      (char const   )'=',      (char const   )'#', 
        (char const   )'%'};
#line 49 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *myname___1  ;
#line 50 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long quit___0  =    0L;
#line 51 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static struct termios ots___0  ;
#line 52 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long *subsong_playlist___0  ;
#line 53 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_playlist_idx___0  =    0L;
#line 54 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long pause_mode___0  =    0L;
#line 60 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long refresh_delay___0  =    33L;
#line 63 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long playmode___0  =    1L;
#line 64 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long loopmode___0  =    0L;
#line 65 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static enum plugout_endian endian___0  =    (enum plugout_endian )2;
#line 66 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long verbosity___0  =    3L;
#line 67 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long rate___0  =    44100L;
#line 68 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long silence_timeout___0  =    2L;
#line 69 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long fadeout___0  =    3L;
#line 70 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_gap___0  =    2L;
#line 71 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_start___0  =    -1L;
#line 72 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_stop___0  =    -1L;
#line 73 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long subsong_timeout___0  =    120L;
#line 74 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long redraw___0  =    0L;
#line 76 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char const   cfgfile___0[11]  = 
#line 76
  {      (char const   )'.',      (char const   )'g',      (char const   )'b',      (char const   )'s', 
        (char const   )'p',      (char const   )'l',      (char const   )'a',      (char const   )'y', 
        (char const   )'r',      (char const   )'c',      (char const   )'\000'};
#line 78 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *sound_name___0  =    (char *)"oss";
#line 79 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *sound_description___0  ;
#line 80 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) (*sound_open___0))(enum plugout_endian endian ,
                                                                 long rate )  ;
#line 81 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int ( __attribute__((__regparm__(3))) (*sound_skip___0))(int subsong )  ;
#line 82 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int ( __attribute__((__regparm__(3))) (*sound_io___0))(long cycles , uint32_t addr ,
                                                              uint8_t val )  ;
#line 83 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static ssize_t ( __attribute__((__regparm__(3))) (*sound_write___0))(void const   *buf ,
                                                                     size_t count )  ;
#line 84 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) (*sound_close___0))(void)  ;
#line 86 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int16_t samples___0[4096]  ;
#line 87 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static struct gbhw_buffer buf___1  =    {samples___0, 0L, 0L, 0L, (long )sizeof(samples___0), 0L, 0L};
#line 94 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static struct cfg_option  const  options___0[11]  = 
#line 94
  {      {(char *)"rate", (void *)(& rate___0), & cfg_long}, 
        {(char *)"refresh_delay", (void *)(& refresh_delay___0), & cfg_long}, 
        {(char *)"verbosity", (void *)(& verbosity___0), & cfg_long}, 
        {(char *)"endian", (void *)(& endian___0), & cfg_endian}, 
        {(char *)"subsong_timeout", (void *)(& subsong_timeout___0), & cfg_long}, 
        {(char *)"subsong_gap", (void *)(& subsong_gap___0), & cfg_long}, 
        {(char *)"fadeout", (void *)(& fadeout___0), & cfg_long}, 
        {(char *)"silence_timeout", (void *)(& silence_timeout___0), & cfg_long}, 
        {(char *)"output_plugin", (void *)(& sound_name___0), & cfg_string}, 
        {(char *)"loop", (void *)(& loopmode___0), & cfg_long}, 
        {(char *)((void *)0), (void *)0, (void ( __attribute__((__regparm__(3))) (*))(void *ptr ))((void *)0)}};
#line 109 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) getnote___0)(long div___2 ) 
{ 
  long n ;
  double tmp ;

  {
#line 111
  n = 0L;
#line 113
  if (div___2 > 0L) {
    {
    {
#line 114
    tmp = log((double )(262144L / div___2));
    }
#line 114
    n = (long )((tmp / .69314718055994530941 - 5.78135971352465960412) * (double )12 + .2);
    }
  }
#line 117
  if (n < 0L) {
#line 118
    n = 0L;
  } else
#line 119
  if (n >= 108L) {
#line 120
    n = 8L;
  }
#line 123
  return (n);
}
}
#line 126 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) precalc_notes___0)(void) 
{ 
  long i ;
  char *s ;
  long n ;

  {
#line 129
  i = 0L;
  {
  {
#line 129
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < 108L)) {
#line 129
      goto while_break;
    }
#line 130
    s = notelookup___0 + 4L * i;
#line 131
    n = i % 12L;
#line 133
    *(s + 2) = (char )(48L + i / 12L);
#line 134
    n += (long )((n > 2L) + (n > 7L));
#line 135
    *(s + 0) = (char )(65L + (n >> 1));
#line 136
    if (n & 1L) {
#line 137
      *(s + 1) = (char )'#';
    } else {
#line 139
      *(s + 1) = (char )'-';
    }
#line 129
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 146 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char buf___2[5]  ;
#line 144 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *( __attribute__((__regparm__(3))) reverse_vol___0)(char *s ) 
{ 
  long i ;

  {
#line 149
  i = 0L;
  {
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < 4L)) {
#line 149
      goto while_break;
    }
#line 150
    buf___2[i] = *(s + (3L - i));
#line 149
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  buf___2[4] = (char)0;
#line 154
  return (buf___2);
}
}
#line 157 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) precalc_vols___0)(void) 
{ 
  long i ;
  long k ;
  long j ;
  char *s ;

  {
#line 160
  k = 0L;
  {
  {
#line 160
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 160
    if (! (k < 16L)) {
#line 160
      goto while_break;
    }
#line 162
    s = vollookup___0 + 5L * k;
#line 163
    i = k;
#line 164
    j = 0L;
    {
    {
#line 164
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 164
      if (! (j < 4L)) {
#line 164
        goto while_break___0;
      }
#line 165
      if (i >= 4L) {
#line 166
        *(s + j) = (char )vols___0[4];
#line 167
        i -= 4L;
      } else {
#line 169
        *(s + j) = (char )vols___0[i];
#line 170
        i = 0L;
      }
#line 164
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 160
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) swap_endian___0)(struct gbhw_buffer *buf___3 ) 
{ 
  long i ;
  short x ;

  {
#line 180
  i = 0L;
  {
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )i < (unsigned long )buf___3->bytes / sizeof(short ))) {
#line 180
      goto while_break;
    }
#line 181
    x = *(buf___3->data + i);
#line 182
    *(buf___3->data + i) = (int16_t )((((int )x & 255) << 8) | ((int )x >> 8));
#line 180
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 186 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) iocallback___4)(long cycles , uint32_t addr ,
                                                              uint8_t val , void *priv ) 
{ 


  {
#line 188
  if (sound_io___0) {
    {
    {
#line 189
    (*sound_io___0)(cycles, addr, val);
    }
    }
  }
#line 190
  return;
}
}
#line 192 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) callback___4)(struct gbhw_buffer *buf___3 ,
                                                            void *priv ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
  {
#line 194
  tmp = is_le_machine();
  }
  }
#line 194
  if (tmp) {
#line 194
    if ((unsigned int )endian___0 == 0U) {
      {
      {
#line 196
      swap_endian___0(buf___3);
      }
      }
    } else {
#line 194
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 194
    tmp___0 = is_be_machine();
    }
    }
#line 194
    if (tmp___0) {
#line 194
      if ((unsigned int )endian___0 == 1U) {
        {
        {
#line 196
        swap_endian___0(buf___3);
        }
        }
      }
    }
  }
  {
  {
#line 198
  (*sound_write___0)((void const   *)buf___3->data, (size_t )((unsigned long )(buf___3->pos * 2L) * sizeof(int16_t )));
  }
#line 199
  buf___3->pos = 0L;
  }
#line 200
  return;
}
}
#line 202 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long *( __attribute__((__regparm__(3))) setup_playlist___0)(long songs ) 
{ 
  long i ;
  long *playlist ;
  void *tmp ;

  {
  {
  {
#line 208
  tmp = calloc((size_t )songs, (size_t )sizeof(long ));
  }
#line 208
  playlist = (long *)tmp;
#line 209
  i = 0L;
  }
  {
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i < songs)) {
#line 209
      goto while_break;
    }
#line 210
    *(playlist + i) = i;
#line 209
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 214
  srand((unsigned int )random_seed);
  }
  {
#line 215
  shuffle_long(playlist, songs);
  }
  }
#line 217
  return (playlist);
}
}
#line 220 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) get_next_subsong___0)(struct gbs *gbs ) 
{ 
  long next ;

  {
#line 223
  next = -1L;
  {
#line 226
  if (playmode___0 == 2L) {
#line 226
    goto case_2;
  }
#line 230
  if (playmode___0 == 3L) {
#line 230
    goto case_3;
  }
#line 241
  if (playmode___0 == 1L) {
#line 241
    goto case_1;
  }
#line 224
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 227
  next = rand_long(gbs->songs);
  }
  }
#line 228
  goto switch_break;
  case_3: /* CIL Label */ 
#line 231
  subsong_playlist_idx___0 ++;
#line 232
  if (subsong_playlist_idx___0 == gbs->songs) {
    {
    {
#line 233
    free((void *)subsong_playlist___0);
    }
#line 234
    random_seed ++;
    {
#line 235
    subsong_playlist___0 = setup_playlist___0(gbs->songs);
    }
#line 236
    subsong_playlist_idx___0 = 0L;
    }
  }
#line 238
  next = *(subsong_playlist___0 + subsong_playlist_idx___0);
#line 239
  goto switch_break;
  case_1: /* CIL Label */ 
#line 242
  next = gbs->subsong + 1L;
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 245
  return (next);
}
}
#line 248 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static int ( __attribute__((__regparm__(3))) get_prev_subsong___0)(struct gbs *gbs ) 
{ 
  int prev ;
  long tmp ;

  {
#line 251
  prev = -1;
  {
#line 254
  if (playmode___0 == 2L) {
#line 254
    goto case_2;
  }
#line 258
  if (playmode___0 == 3L) {
#line 258
    goto case_3;
  }
#line 269
  if (playmode___0 == 1L) {
#line 269
    goto case_1;
  }
#line 252
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 255
  tmp = rand_long(gbs->songs);
  }
#line 255
  prev = (int )tmp;
  }
#line 256
  goto switch_break;
  case_3: /* CIL Label */ 
#line 259
  subsong_playlist_idx___0 --;
#line 260
  if (subsong_playlist_idx___0 == -1L) {
    {
    {
#line 261
    free((void *)subsong_playlist___0);
    }
#line 262
    random_seed --;
    {
#line 263
    subsong_playlist___0 = setup_playlist___0(gbs->songs);
    }
#line 264
    subsong_playlist_idx___0 = gbs->songs - 1L;
    }
  }
#line 266
  prev = (int )*(subsong_playlist___0 + subsong_playlist_idx___0);
#line 267
  goto switch_break;
  case_1: /* CIL Label */ 
#line 270
  prev = (int )(gbs->subsong - 1L);
#line 271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 273
  return (prev);
}
}
#line 276 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) setup_playmode___0)(struct gbs *gbs ) 
{ 


  {
  {
#line 281
  if (playmode___0 == 2L) {
#line 281
    goto case_2;
  }
#line 286
  if (playmode___0 == 3L) {
#line 286
    goto case_3;
  }
#line 301
  if (playmode___0 == 1L) {
#line 301
    goto case_1;
  }
#line 279
  goto switch_break;
  case_2: /* CIL Label */ 
#line 282
  if (gbs->subsong == -1L) {
    {
    {
#line 283
    gbs->subsong = get_next_subsong___0(gbs);
    }
    }
  }
  case_3: /* CIL Label */ 
  {
  {
#line 287
  subsong_playlist___0 = setup_playlist___0(gbs->songs);
  }
#line 288
  subsong_playlist_idx___0 = 0L;
  }
#line 289
  if (gbs->subsong == -1L) {
#line 290
    gbs->subsong = *(subsong_playlist___0 + 0);
  } else {
    {
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 295
      if (! (*(subsong_playlist___0 + 0) != gbs->subsong)) {
#line 295
        goto while_break;
      }
      {
#line 296
      random_seed ++;
      {
#line 297
      subsong_playlist___0 = setup_playlist___0(gbs->songs);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  case_1: /* CIL Label */ 
#line 302
  if (gbs->subsong == -1L) {
#line 303
    gbs->subsong = gbs->defaultsong - 1L;
  }
#line 305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 309 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) nextsubsong_cb___0)(struct gbs *gbs ,
                                                                  void *priv ) 
{ 
  long subsong ;
  long tmp ;

  {
  {
  {
#line 311
  tmp = get_next_subsong___0(gbs);
  }
#line 311
  subsong = tmp;
  }
#line 313
  if (gbs->subsong == subsong_stop___0) {
#line 313
    goto _L;
  } else
#line 313
  if (subsong >= gbs->songs) {
    _L: /* CIL Label */ 
#line 315
    if (loopmode___0) {
      {
#line 316
      subsong = subsong_start___0;
      {
#line 317
      setup_playmode___0(gbs);
      }
      }
    } else {
#line 319
      return (0L);
    }
  }
  {
  {
#line 323
  gbs_init(gbs, subsong);
  }
  }
#line 324
  if (sound_skip___0) {
    {
    {
#line 325
    (*sound_skip___0)((int )subsong);
    }
    }
  }
#line 326
  return (1L);
}
}
#line 339 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) usage___1)(long exitcode ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 341
  if (exitcode) {
#line 341
    tmp = stderr;
  } else {
#line 341
    tmp = stdout;
  }
  {
#line 341
  out = tmp;
  {
#line 342
  tmp___0 = endian_str((long )endian___0);
  }
  {
#line 342
  tmp___1 = _("Usage: %s [option(s)] <gbs-file> [start_at_subsong [stop_at_subsong] ]\n\nAvailable options are:\n  -E        endian, b == big, l == little, n == native (%s)\n  -f        set fadeout (%ld seconds)\n  -g        set subsong gap (%ld seconds)\n  -h        display this help and exit\n  -l        loop mode\n  -o        select output plugin (%s)\n            \'list\' shows available plugins\n  -q        reduce verbosity\n  -r        set samplerate (%ldHz)\n  -R        set refresh delay (%ld milliseconds)\n  -t        set subsong timeout (%ld seconds)\n  -T        set silence timeout (%ld seconds)\n  -v        increase verbosity\n  -V        print version and exit\n  -z        play subsongs in shuffle mode\n  -Z        play subsongs in random mode (repetitions possible)\n  -1 to -4  mute a channel on startup\n");
  }
  {
#line 342
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
          myname___1, tmp___0, fadeout___0, subsong_gap___0, sound_name___0, rate___0,
          refresh_delay___0, subsong_timeout___0, silence_timeout___0);
  }
  {
#line 372
  exit((int )exitcode);
  }
  }
}
}
#line 375 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) version___1)(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 377
  puts("gbsplay 0.0.91");
  }
  {
#line 378
  exit(0);
  }
  }
}
}
#line 381 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) parseopts___1)(int *argc , char ***argv ) 
{ 
  long res ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 384
  myname___1 = *(*(argv + 0));
  {
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 385
    tmp___3 = getopt(*argc, (char * const  *)*argv, "1234E:f:g:hlo:qr:R:t:T:vVzZ");
    }
#line 385
    res = (long )tmp___3;
    }
#line 385
    if (! (res != -1L)) {
#line 385
      goto while_break;
    }
    {
#line 393
    if (res == 52L) {
#line 393
      goto case_52;
    }
#line 393
    if (res == 51L) {
#line 393
      goto case_52;
    }
#line 393
    if (res == 50L) {
#line 393
      goto case_52;
    }
#line 393
    if (res == 49L) {
#line 393
      goto case_52;
    }
#line 396
    if (res == 69L) {
#line 396
      goto case_69;
    }
#line 408
    if (res == 102L) {
#line 408
      goto case_102;
    }
#line 411
    if (res == 103L) {
#line 411
      goto case_103;
    }
#line 414
    if (res == 104L) {
#line 414
      goto case_104;
    }
#line 417
    if (res == 108L) {
#line 417
      goto case_108;
    }
#line 420
    if (res == 111L) {
#line 420
      goto case_111;
    }
#line 423
    if (res == 113L) {
#line 423
      goto case_113;
    }
#line 426
    if (res == 114L) {
#line 426
      goto case_114;
    }
#line 429
    if (res == 82L) {
#line 429
      goto case_82;
    }
#line 432
    if (res == 116L) {
#line 432
      goto case_116;
    }
#line 435
    if (res == 84L) {
#line 435
      goto case_84;
    }
#line 438
    if (res == 118L) {
#line 438
      goto case_118;
    }
#line 441
    if (res == 86L) {
#line 441
      goto case_86;
    }
#line 444
    if (res == 122L) {
#line 444
      goto case_122;
    }
#line 447
    if (res == 90L) {
#line 447
      goto case_90;
    }
#line 387
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
    {
#line 388
    usage___1(1L);
    }
    }
#line 389
    goto switch_break;
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 394
    gbhw_ch[res - 49L].mute ^= 1L;
#line 395
    goto switch_break;
    case_69: /* CIL Label */ 
    {
    {
#line 397
    tmp___2 = strcasecmp((char const   *)optarg, "b");
    }
    }
#line 397
    if (tmp___2 == 0) {
#line 398
      endian___0 = (enum plugout_endian )0;
    } else {
      {
      {
#line 399
      tmp___1 = strcasecmp((char const   *)optarg, "l");
      }
      }
#line 399
      if (tmp___1 == 0) {
#line 400
        endian___0 = (enum plugout_endian )1;
      } else {
        {
        {
#line 401
        tmp___0 = strcasecmp((char const   *)optarg, "n");
        }
        }
#line 401
        if (tmp___0 == 0) {
#line 402
          endian___0 = (enum plugout_endian )2;
        } else {
          {
          {
#line 404
          tmp = _("\"%s\" is not a valid endian.\n\n");
          }
          {
#line 404
          printf((char const   */* __restrict  */)tmp, optarg);
          }
          {
#line 405
          usage___1(1L);
          }
          }
        }
      }
    }
#line 407
    goto switch_break;
    case_102: /* CIL Label */ 
    {
    {
#line 409
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & fadeout___0);
    }
    }
#line 410
    goto switch_break;
    case_103: /* CIL Label */ 
    {
    {
#line 412
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & subsong_gap___0);
    }
    }
#line 413
    goto switch_break;
    case_104: /* CIL Label */ 
    {
    {
#line 415
    usage___1(0L);
    }
    }
#line 416
    goto switch_break;
    case_108: /* CIL Label */ 
#line 418
    loopmode___0 = 1L;
#line 419
    goto switch_break;
    case_111: /* CIL Label */ 
#line 421
    sound_name___0 = optarg;
#line 422
    goto switch_break;
    case_113: /* CIL Label */ 
#line 424
    verbosity___0 --;
#line 425
    goto switch_break;
    case_114: /* CIL Label */ 
    {
    {
#line 427
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & rate___0);
    }
    }
#line 428
    goto switch_break;
    case_82: /* CIL Label */ 
    {
    {
#line 430
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & refresh_delay___0);
    }
    }
#line 431
    goto switch_break;
    case_116: /* CIL Label */ 
    {
    {
#line 433
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & subsong_timeout___0);
    }
    }
#line 434
    goto switch_break;
    case_84: /* CIL Label */ 
    {
    {
#line 436
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%ld",
           & silence_timeout___0);
    }
    }
#line 437
    goto switch_break;
    case_118: /* CIL Label */ 
#line 439
    verbosity___0 ++;
#line 440
    goto switch_break;
    case_86: /* CIL Label */ 
    {
    {
#line 442
    version___1();
    }
    }
#line 443
    goto switch_break;
    case_122: /* CIL Label */ 
#line 445
    playmode___0 = 3L;
#line 446
    goto switch_break;
    case_90: /* CIL Label */ 
#line 448
    playmode___0 = 2L;
#line 449
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  *argc -= optind;
#line 453
  *argv += optind;
#line 454
  return;
}
}
#line 456 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) handleuserinput___0)(struct gbs *gbs ) 
{ 
  char c___3 ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
  {
#line 460
  tmp___0 = read(0, (void *)(& c___3), (size_t )1);
  }
  }
#line 460
  if (tmp___0 != -1) {
    {
#line 462
    if ((int )c___3 == 112) {
#line 462
      goto case_112;
    }
#line 471
    if ((int )c___3 == 110) {
#line 471
      goto case_110;
    }
#line 479
    if ((int )c___3 == 27) {
#line 479
      goto case_27;
    }
#line 479
    if ((int )c___3 == 113) {
#line 479
      goto case_27;
    }
#line 482
    if ((int )c___3 == 32) {
#line 482
      goto case_32;
    }
#line 489
    if ((int )c___3 == 52) {
#line 489
      goto case_52;
    }
#line 489
    if ((int )c___3 == 51) {
#line 489
      goto case_52;
    }
#line 489
    if ((int )c___3 == 50) {
#line 489
      goto case_52;
    }
#line 489
    if ((int )c___3 == 49) {
#line 489
      goto case_52;
    }
#line 461
    goto switch_break;
    case_112: /* CIL Label */ 
    {
    {
#line 463
    tmp = get_prev_subsong___0(gbs);
    }
#line 463
    gbs->subsong = (long )tmp;
    }
    {
    {
#line 464
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 464
      if (! (gbs->subsong < 0L)) {
#line 464
        goto while_break;
      }
#line 465
      gbs->subsong += gbs->songs;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 467
    gbs_init(gbs, gbs->subsong);
    }
    }
#line 468
    if (sound_skip___0) {
      {
      {
#line 469
      (*sound_skip___0)((int )gbs->subsong);
      }
      }
    }
#line 470
    goto switch_break;
    case_110: /* CIL Label */ 
    {
    {
#line 472
    gbs->subsong = get_next_subsong___0(gbs);
    }
#line 473
    gbs->subsong %= gbs->songs;
    {
#line 474
    gbs_init(gbs, gbs->subsong);
    }
    }
#line 475
    if (sound_skip___0) {
      {
      {
#line 476
      (*sound_skip___0)((int )gbs->subsong);
      }
      }
    }
#line 477
    goto switch_break;
    case_27: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 480
    quit___0 = 1L;
#line 481
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 483
    pause_mode___0 = (long )(! pause_mode___0);
    {
#line 484
    gbhw_pause(pause_mode___0);
    }
    }
#line 485
    goto switch_break;
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 490
    gbhw_ch[(int )c___3 - 49].mute ^= 1L;
#line 491
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 494
  return;
}
}
#line 496 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *( __attribute__((__regparm__(3))) notestring___0)(long ch ) 
{ 
  long n ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 500
  if (gbhw_ch[ch].mute) {
#line 500
    return ((char *)"-M-");
  }
#line 502
  if (gbhw_ch[ch].volume == 0L) {
#line 503
    return ((char *)"---");
  } else
#line 502
  if (gbhw_ch[ch].master == 0L) {
#line 503
    return ((char *)"---");
  }
  {
  {
#line 505
  n = getnote___0(gbhw_ch[ch].div_tc);
  }
  }
#line 506
  if (ch != 3L) {
#line 506
    return (& notelookup___0[4L * n]);
  } else {
#line 507
    return ((char *)"nse");
  }
}
}
#line 510 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static long ( __attribute__((__regparm__(3))) chvol___0)(long ch ) 
{ 
  long v ;

  {
#line 514
  if (gbhw_ch[ch].mute) {
#line 515
    return (0L);
  } else
#line 514
  if (gbhw_ch[ch].master == 0L) {
#line 515
    return (0L);
  }
#line 517
  if (ch == 2L) {
#line 518
    v = (3L - ((gbhw_ch[2].volume + 3L) & 3L)) << 2;
  } else {
#line 519
    v = gbhw_ch[ch].volume;
  }
#line 521
  return (v);
}
}
#line 524 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static char *( __attribute__((__regparm__(3))) volstring___0)(long v ) 
{ 


  {
#line 526
  if (v < 0L) {
#line 526
    v = 0L;
  }
#line 527
  if (v > 15L) {
#line 527
    v = 15L;
  }
#line 529
  return (& vollookup___0[5L * v]);
}
}
#line 532 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) printstatus___0)(struct gbs *gbs ) 
{ 
  long time___0 ;
  long timem ;
  long times ;
  char *songtitle ;
  long len ;
  long lenm ;
  long lens ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  long tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 534
  time___0 = (long )(gbs->ticks / 4194304LL);
#line 535
  timem = time___0 / 60L;
#line 536
  times = time___0 % 60L;
#line 538
  len = (long )((gbs->subsong_info + gbs->subsong)->len / 1024U);
#line 541
  if (len == 0L) {
#line 542
    len = subsong_timeout___0;
  }
#line 544
  lenm = len / 60L;
#line 545
  lens = len % 60L;
#line 547
  songtitle = (gbs->subsong_info + gbs->subsong)->title;
#line 548
  if (! songtitle) {
    {
    {
#line 549
    songtitle = _("Untitled");
    }
    }
  }
  {
  {
#line 551
  printf((char const   */* __restrict  */)"\r\033[A\033[ASong %3ld/%3ld (%s)\033[K\n%02ld:%02ld/%02ld:%02ld",
         gbs->subsong + 1L, gbs->songs, songtitle, timem, times, lenm, lens);
  }
  }
#line 556
  if (verbosity___0 > 2L) {
    {
    {
#line 557
    tmp = volstring___0((long )((int )gbs->rvol / 1024));
    }
    {
#line 557
    tmp___0 = volstring___0((long )((int )gbs->lvol / 1024));
    }
    {
#line 557
    tmp___1 = reverse_vol___0(tmp___0);
    }
    {
#line 557
    tmp___2 = chvol___0(3L);
    }
    {
#line 557
    tmp___3 = volstring___0(tmp___2);
    }
    {
#line 557
    tmp___4 = notestring___0(3L);
    }
    {
#line 557
    tmp___5 = chvol___0(2L);
    }
    {
#line 557
    tmp___6 = volstring___0(tmp___5);
    }
    {
#line 557
    tmp___7 = notestring___0(2L);
    }
    {
#line 557
    tmp___8 = chvol___0(1L);
    }
    {
#line 557
    tmp___9 = volstring___0(tmp___8);
    }
    {
#line 557
    tmp___10 = notestring___0(1L);
    }
    {
#line 557
    tmp___11 = chvol___0(0L);
    }
    {
#line 557
    tmp___12 = volstring___0(tmp___11);
    }
    {
#line 557
    tmp___13 = notestring___0(0L);
    }
    {
#line 557
    printf((char const   */* __restrict  */)"  %s %s  %s %s  %s %s  %s %s  [%s|%s]\n",
           tmp___13, tmp___12, tmp___10, tmp___9, tmp___7, tmp___6, tmp___4, tmp___3,
           tmp___1, tmp);
    }
    }
  } else {
    {
    {
#line 565
    puts("");
    }
    }
  }
  {
  {
#line 567
  fflush(stdout);
  }
  }
#line 568
  return;
}
}
#line 599 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) printinfo___0)(struct gbs *gbs ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 601
  if (verbosity___0 > 0L) {
    {
    {
#line 602
    gbs_printinfo(gbs, 0L);
    }
    {
#line 603
    tmp = _("\ncommands:  [p]revious subsong   [n]ext subsong   [q]uit player\n           [ ] pause/resume   [1-4] mute channel");
    }
    {
#line 603
    puts((char const   *)tmp);
    }
    }
  }
#line 606
  if (verbosity___0 > 1L) {
    {
    {
#line 607
    puts("\n\n");
    }
    }
  }
#line 609
  redraw___0 = 0L;
#line 610
  return;
}
}
#line 612 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/gbsplay.c"
static void ( __attribute__((__regparm__(3))) select_plugin___0)(void) 
{ 
  struct output_plugin  const  *plugout ;
  int tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 616
  tmp = strcmp((char const   *)sound_name___0, "list");
  }
  }
#line 616
  if (tmp == 0) {
    {
    {
#line 617
    plugout_list_plugins();
    }
    {
#line 618
    exit(0);
    }
    }
  }
  {
  {
#line 621
  plugout = plugout_select_by_name((char const   *)sound_name___0);
  }
  }
#line 622
  if ((unsigned long )plugout == (unsigned long )((void *)0)) {
    {
    {
#line 623
    tmp___0 = _("\"%s\" is not a known output plugin.\n\n");
    }
    {
#line 623
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            sound_name___0);
    }
    {
#line 625
    exit(1);
    }
    }
  }
#line 628
  sound_open___0 = (long ( __attribute__((__regparm__(3))) (*))(enum plugout_endian endian ,
                                                                long rate ))plugout->open;
#line 629
  sound_skip___0 = (int ( __attribute__((__regparm__(3))) (*))(int subsong ))plugout->skip;
#line 630
  sound_io___0 = (int ( __attribute__((__regparm__(3))) (*))(long cycles , uint32_t addr ,
                                                             uint8_t val ))plugout->io;
#line 631
  sound_write___0 = (ssize_t ( __attribute__((__regparm__(3))) (*))(void const   *buf ,
                                                                    size_t count ))plugout->write;
#line 632
  sound_close___0 = (void ( __attribute__((__regparm__(3))) (*))(void))plugout->close;
#line 633
  sound_description___0 = (char *)plugout->description;
#line 635
  if (plugout->flags & 1L) {
#line 636
    verbosity___0 = 0L;
  }
#line 638
  return;
}
}
#line 18 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
static long ( __attribute__((__regparm__(3))) stdout_open___0)(enum plugout_endian endian___1 ,
                                                               long rate___1 ) 
{ 


  {
  {
  {
#line 25
  fd = dup(1);
  }
  }
#line 26
  if (fd == -1) {
#line 26
    return (-1L);
  }
  {
  {
#line 27
  close(1);
  }
  }
#line 29
  return (0L);
}
}
#line 32 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
static ssize_t ( __attribute__((__regparm__(3))) stdout_write___0)(void const   *buf___3 ,
                                                                   size_t count ) 
{ 
  ssize_t tmp ;

  {
  {
  {
#line 34
  tmp = write(fd, buf___3, count);
  }
  }
#line 34
  return (tmp);
}
}
#line 37 "/home/wslee/benchmarks/sound/gbsplay-0.0.91/plugout_stdout.c"
static void ( __attribute__((__regparm__(3))) stdout_close___0)(void) 
{ 


  {
  {
  {
#line 39
  close(fd);
  }
  }
#line 40
  return;
}
}
