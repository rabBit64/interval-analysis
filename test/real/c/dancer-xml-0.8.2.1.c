/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 35 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
struct dxml_attribute {
   char *attribute_name ;
   char *attribute_data ;
   struct dxml_attribute *next ;
};
#line 35 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
typedef struct dxml_attribute dxml_attribute;
#line 53
enum element_type {
    element_type_element = 0,
    element_type_pcdata = 1
} ;
#line 53 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
struct dxml_element {
   char *element_name ;
   enum element_type element_type ;
   dxml_attribute *element_attribute ;
   struct dxml_element *child ;
   struct dxml_element *next ;
};
#line 53 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
typedef struct dxml_element dxml_element;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 668
extern int puts(char const   *__s ) ;
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 181
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 152 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 77 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
dxml_element *dxml_read_xml(FILE *f ) ;
#line 83
dxml_element *dxml_get_element_byname(dxml_element *e , char const   *name ) ;
#line 86
dxml_element *dxml_get_element_bysimplepath(dxml_element *e , char const   *path ) ;
#line 89
void dxml_dump_element(dxml_element *e ) ;
#line 92
char *dxml_get_PCDATA_bysimplepath(dxml_element *e , char const   *path ) ;
#line 30 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int replace_external_entity(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 33
  tmp___1 = strcmp(s, "gt");
  }
  }
#line 33
  if (tmp___1) {
    {
    {
#line 35
    tmp___0 = strcmp(s, "lt");
    }
    }
#line 35
    if (tmp___0) {
      {
      {
#line 37
      tmp = strcmp(s, "amp");
      }
      }
#line 37
      if (tmp) {
        {
        {
#line 41
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown entity %s\n",
                s);
        }
        {
#line 42
        exit(1);
        }
        }
      } else {
        {
        {
#line 38
        printf((char const   */* __restrict  */)"\\&{}");
        }
        }
      }
    } else {
      {
      {
#line 36
      printf((char const   */* __restrict  */)"$<$");
      }
      }
    }
  } else {
    {
    {
#line 34
    printf((char const   */* __restrict  */)"$>$");
    }
    }
  }
#line 44
  return (0);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int convert_print(char const   *s , int verbatim ) 
{ 
  char const   *endptr ;
  unsigned short const   **tmp ;
  char *tmps ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 55
  endptr = (char const   *)((void *)0);
#line 57
  if (! s) {
#line 59
    return (1);
  }
  {
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 62
    if (*s) {
      {
      {
#line 62
      tmp = __ctype_b_loc();
      }
      }
#line 62
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 64
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! *s) {
#line 66
      goto while_break___0;
    }
    {
#line 70
    if ((int const   )*s == 36) {
#line 70
      goto case_36;
    }
#line 73
    if ((int const   )*s == 95) {
#line 73
      goto case_95;
    }
#line 76
    if ((int const   )*s == 92) {
#line 76
      goto case_92;
    }
#line 79
    if ((int const   )*s == 94) {
#line 79
      goto case_94;
    }
#line 82
    if ((int const   )*s == 126) {
#line 82
      goto case_126;
    }
#line 85
    if ((int const   )*s == 10) {
#line 85
      goto case_10;
    }
#line 89
    if ((int const   )*s == 35) {
#line 89
      goto case_35;
    }
#line 92
    if ((int const   )*s == 91) {
#line 92
      goto case_91;
    }
#line 95
    if ((int const   )*s == 93) {
#line 95
      goto case_93;
    }
#line 99
    if ((int const   )*s == 38) {
#line 99
      goto case_38;
    }
#line 114
    goto switch_default;
    case_36: /* CIL Label */ 
    {
    {
#line 71
    printf((char const   */* __restrict  */)"\\${}");
    }
    }
#line 72
    goto switch_break;
    case_95: /* CIL Label */ 
    {
    {
#line 74
    printf((char const   */* __restrict  */)"\\underline{ }");
    }
    }
#line 75
    goto switch_break;
    case_92: /* CIL Label */ 
    {
    {
#line 77
    printf((char const   */* __restrict  */)"\\verb\'\\\'");
    }
    }
#line 78
    goto switch_break;
    case_94: /* CIL Label */ 
    {
    {
#line 80
    printf((char const   */* __restrict  */)"\\verb!^!");
    }
    }
#line 81
    goto switch_break;
    case_126: /* CIL Label */ 
    {
    {
#line 83
    printf((char const   */* __restrict  */)"\\~\\ ");
    }
    }
#line 84
    goto switch_break;
    case_10: /* CIL Label */ 
#line 86
    if (verbatim) {
      {
      {
#line 86
      printf((char const   */* __restrict  */)"\\\\%%");
      }
      }
    }
    {
    {
#line 87
    printf((char const   */* __restrict  */)"\n");
    }
    }
#line 88
    goto switch_break;
    case_35: /* CIL Label */ 
    {
    {
#line 90
    printf((char const   */* __restrict  */)"$\\sharp$");
    }
    }
#line 91
    goto switch_break;
    case_91: /* CIL Label */ 
    {
    {
#line 93
    printf((char const   */* __restrict  */)"{}[{}");
    }
    }
#line 94
    goto switch_break;
    case_93: /* CIL Label */ 
    {
    {
#line 96
    printf((char const   */* __restrict  */)"{}]{}");
    }
    }
#line 97
    goto switch_break;
    case_38: /* CIL Label */ 
    {
    {
#line 100
    tmp___0 = strchr(s, ';');
    }
#line 100
    endptr = (char const   *)tmp___0;
    }
#line 100
    if ((unsigned long )((void *)0) != (unsigned long )endptr) {
      {
      {
#line 103
      tmps = strndup(s + 1, (size_t )((endptr - s) - 1L));
      }
      {
#line 104
      replace_external_entity((char const   *)tmps);
      }
      {
#line 105
      free((void *)tmps);
      }
#line 106
      s = endptr;
      }
    } else {
      {
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated & \n");
      }
      {
#line 111
      exit(1);
      }
      }
    }
#line 113
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 115
    _IO_putc((int )*s, stdout);
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 118
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return (0);
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static char const   *getatrstring(dxml_element *e , char const   *attr ) 
{ 
  dxml_attribute *a ;
  int tmp ;

  {
#line 127
  a = e->element_attribute;
  {
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 128
    if (! a) {
#line 128
      goto while_break;
    }
    {
    {
#line 130
    tmp = strcmp((char const   *)a->attribute_name, attr);
    }
    }
#line 130
    if (! tmp) {
#line 131
      return ((char const   *)a->attribute_data);
    }
#line 132
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return ((char const   *)((void *)0));
}
}
#line 137
static int get_paratype(dxml_element *b , int verbatim ) ;
#line 138
static int get_bookchapter(dxml_element *b , int paraenter ) ;
#line 140 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int maybe_label(dxml_element *b ) 
{ 
  char const   *s ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 144
  s = getatrstring(b, "id");
  }
  }
#line 144
  if (s) {
    {
    {
#line 145
    printf((char const   */* __restrict  */)"\\label{%s}\n", s);
    }
    }
  }
#line 146
  return (0);
}
}
#line 149 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_table(dxml_element *b_parent ) 
{ 
  int i ;
  int width ;
  dxml_element *row ;
  dxml_element *entry ;
  dxml_element *b ;
  int columns ;
  dxml_element *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 154
  b = b_parent->child;
  {
#line 155
  tmp = dxml_get_element_byname(b, "tgroup");
  }
  {
#line 155
  tmp___0 = getatrstring(tmp, "cols");
  }
  {
#line 155
  tmp___1 = atoi(tmp___0);
  }
#line 155
  columns = tmp___1;
  {
#line 156
  tmp___2 = dxml_get_PCDATA_bysimplepath(b, "title");
  }
  {
#line 156
  printf((char const   */* __restrict  */)"\\begin{table}\n\\caption{%s}\n", tmp___2);
  }
  {
#line 159
  maybe_label(b_parent);
  }
#line 161
  width = 12 / columns;
  {
#line 162
  printf((char const   */* __restrict  */)"\\begin{tabular}{p{%icm}", width);
  }
#line 163
  i = 0;
  }
  {
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < columns - 1)) {
#line 163
      goto while_break;
    }
    {
    {
#line 164
    printf((char const   */* __restrict  */)"|p{%icm}", width);
    }
#line 163
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 165
  printf((char const   */* __restrict  */)"}\n\\hline\n\\hline\n");
  }
  {
#line 166
  row = dxml_get_element_bysimplepath(b, "tgroup/tbody/row");
  }
  }
  {
  {
#line 166
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! row) {
#line 166
      goto while_break___0;
    }
#line 168
    entry = row->child;
    {
    {
#line 168
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 168
      if (! entry) {
#line 168
        goto while_break___1;
      }
      {
      {
#line 170
      get_paratype(entry->child, 0);
      }
      }
#line 171
      if (entry->next) {
        {
        {
#line 172
        printf((char const   */* __restrict  */)" & ");
        }
        }
      }
#line 168
      entry = entry->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 176
    printf((char const   */* __restrict  */)"\\\\\n");
    }
#line 166
    row = row->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 178
  printf((char const   */* __restrict  */)"\\hline\n\\hline\n\\end{tabular}\n\\end{table}\n");
  }
  }
#line 183
  return (0);
}
}
#line 186 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_itemizedlist(dxml_element *b ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 188
  printf((char const   */* __restrict  */)"\\begin{itemize}\n");
  }
  }
  {
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 189
    if (! b) {
#line 189
      goto while_break;
    }
    {
    {
#line 192
    tmp = strcasecmp("listitem", (char const   *)b->element_name);
    }
    }
#line 192
    if (tmp) {
      {
      {
#line 199
      dxml_dump_element(b);
      }
      }
    } else {
      {
      {
#line 194
      printf((char const   */* __restrict  */)"\\item ");
      }
      {
#line 195
      get_bookchapter(b->child, 0);
      }
      {
#line 196
      printf((char const   */* __restrict  */)"\n");
      }
      }
    }
#line 201
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 203
  printf((char const   */* __restrict  */)"\\end{itemize}\n");
  }
  }
#line 204
  return (0);
}
}
#line 213 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_bothtypes(dxml_element *b , int inlinetype ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 215
  tmp = strcasecmp("screen", (char const   *)b->element_name);
  }
  }
#line 215
  if (tmp) {
#line 226
    return (0);
  } else {
#line 217
    if (! inlinetype) {
      {
      {
#line 218
      puts("\n\n\n\n");
      }
      }
    }
    {
    {
#line 219
    puts("{\\tt %\n");
    }
    {
#line 220
    get_paratype(b->child, 1);
    }
    {
#line 221
    puts("}");
    }
    }
#line 222
    if (! inlinetype) {
      {
      {
#line 223
      puts("\n\n\n\n");
      }
      }
    }
  }
#line 227
  return (1);
}
}
#line 234 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_paratype(dxml_element *b , int verbatim ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;

  {
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! b) {
#line 238
      goto while_break;
    }
#line 240
    if ((unsigned int )b->element_type == 1U) {
      {
      {
#line 242
      convert_print((char const   *)b->element_name, verbatim);
      }
      }
    } else {
      {
      {
#line 244
      tmp___23 = get_bothtypes(b, 1);
      }
      }
#line 244
      if (! tmp___23) {
        {
        {
#line 247
        tmp___13 = strcasecmp("command", (char const   *)b->element_name);
        }
        }
#line 247
        if (tmp___13) {
          {
          {
#line 247
          tmp___14 = strcasecmp("filename", (char const   *)b->element_name);
          }
          }
#line 247
          if (tmp___14) {
            {
            {
#line 247
            tmp___15 = strcasecmp("keysym", (char const   *)b->element_name);
            }
            }
#line 247
            if (tmp___15) {
              {
              {
#line 247
              tmp___16 = strcasecmp("keycombo", (char const   *)b->element_name);
              }
              }
#line 247
              if (tmp___16) {
                {
                {
#line 247
                tmp___17 = strcasecmp("otheraddr", (char const   *)b->element_name);
                }
                }
#line 247
                if (tmp___17) {
                  {
                  {
#line 247
                  tmp___18 = strcasecmp("function", (char const   *)b->element_name);
                  }
                  }
#line 247
                  if (tmp___18) {
                    {
                    {
#line 247
                    tmp___19 = strcasecmp("prompt", (char const   *)b->element_name);
                    }
                    }
#line 247
                    if (tmp___19) {
                      {
                      {
#line 247
                      tmp___20 = strcasecmp("type", (char const   *)b->element_name);
                      }
                      }
#line 247
                      if (tmp___20) {
                        {
                        {
#line 247
                        tmp___21 = strcasecmp("productname", (char const   *)b->element_name);
                        }
                        }
#line 247
                        if (tmp___21) {
                          {
                          {
#line 247
                          tmp___22 = strcasecmp("address", (char const   *)b->element_name);
                          }
                          }
#line 247
                          if (tmp___22) {
                            {
                            {
#line 262
                            tmp___10 = strcasecmp("option", (char const   *)b->element_name);
                            }
                            }
#line 262
                            if (tmp___10) {
                              {
                              {
#line 262
                              tmp___11 = strcasecmp("parameter", (char const   *)b->element_name);
                              }
                              }
#line 262
                              if (tmp___11) {
                                {
                                {
#line 262
                                tmp___12 = strcasecmp("replaceable", (char const   *)b->element_name);
                                }
                                }
#line 262
                                if (tmp___12) {
                                  {
                                  {
#line 270
                                  tmp___9 = strcasecmp("emphasis", (char const   *)b->element_name);
                                  }
                                  }
#line 270
                                  if (tmp___9) {
                                    {
                                    {
#line 277
                                    tmp___8 = strcasecmp("quote", (char const   *)b->element_name);
                                    }
                                    }
#line 277
                                    if (tmp___8) {
                                      {
                                      {
#line 283
                                      tmp___7 = strcasecmp("footnote", (char const   *)b->element_name);
                                      }
                                      }
#line 283
                                      if (tmp___7) {
                                        {
                                        {
#line 289
                                        tmp___6 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                                        }
                                        }
#line 289
                                        if (tmp___6) {
                                          {
                                          {
#line 293
                                          tmp___4 = strcasecmp("xref", (char const   *)b->element_name);
                                          }
                                          }
#line 293
                                          if (tmp___4) {
                                            {
                                            {
#line 293
                                            tmp___5 = strcasecmp("link", (char const   *)b->element_name);
                                            }
                                            }
#line 293
                                            if (tmp___5) {
                                              {
                                              {
#line 300
                                              tmp___2 = strcasecmp("ulink", (char const   *)b->element_name);
                                              }
                                              }
#line 300
                                              if (tmp___2) {
                                                {
                                                {
#line 300
                                                tmp___3 = strcasecmp("email", (char const   *)b->element_name);
                                                }
                                                }
#line 300
                                                if (tmp___3) {
                                                  {
                                                  {
#line 308
                                                  tmp___1 = strcasecmp("table", (char const   *)b->element_name);
                                                  }
                                                  }
#line 308
                                                  if (tmp___1) {
                                                    {
                                                    {
#line 314
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"Unknown tag: %s\n",
                                                            b->element_name);
                                                    }
                                                    {
#line 315
                                                    dxml_dump_element(b);
                                                    }
                                                    }
                                                  } else {
                                                    {
                                                    {
#line 310
                                                    get_table(b);
                                                    }
                                                    }
                                                  }
                                                } else {
                                                  {
                                                  {
#line 303
                                                  get_paratype(b->child, verbatim);
                                                  }
                                                  {
#line 304
                                                  printf((char const   */* __restrict  */)"({\\tt ");
                                                  }
                                                  {
#line 305
                                                  tmp___0 = getatrstring(b, "url");
                                                  }
                                                  {
#line 305
                                                  convert_print(tmp___0, verbatim);
                                                  }
                                                  {
#line 306
                                                  printf((char const   */* __restrict  */)"})");
                                                  }
                                                  }
                                                }
                                              } else {
                                                {
                                                {
#line 303
                                                get_paratype(b->child, verbatim);
                                                }
                                                {
#line 304
                                                printf((char const   */* __restrict  */)"({\\tt ");
                                                }
                                                {
#line 305
                                                tmp___0 = getatrstring(b, "url");
                                                }
                                                {
#line 305
                                                convert_print(tmp___0, verbatim);
                                                }
                                                {
#line 306
                                                printf((char const   */* __restrict  */)"})");
                                                }
                                                }
                                              }
                                            } else {
                                              {
                                              {
#line 296
                                              tmp = getatrstring(b, "linkend");
                                              }
                                              {
#line 296
                                              printf((char const   */* __restrict  */)"\\ref{%s}",
                                                     tmp);
                                              }
                                              {
#line 298
                                              get_paratype(b->child, verbatim);
                                              }
                                              }
                                            }
                                          } else {
                                            {
                                            {
#line 296
                                            tmp = getatrstring(b, "linkend");
                                            }
                                            {
#line 296
                                            printf((char const   */* __restrict  */)"\\ref{%s}",
                                                   tmp);
                                            }
                                            {
#line 298
                                            get_paratype(b->child, verbatim);
                                            }
                                            }
                                          }
                                        } else {
                                          {
                                          {
#line 291
                                          get_itemizedlist(b->child);
                                          }
                                          }
                                        }
                                      } else {
                                        {
                                        {
#line 285
                                        printf((char const   */* __restrict  */)"\\footnote{");
                                        }
                                        {
#line 286
                                        get_bookchapter(b->child, 0);
                                        }
                                        {
#line 287
                                        printf((char const   */* __restrict  */)"} ");
                                        }
                                        }
                                      }
                                    } else {
                                      {
                                      {
#line 279
                                      printf((char const   */* __restrict  */)" ``");
                                      }
                                      {
#line 280
                                      get_paratype(b->child, verbatim);
                                      }
                                      {
#line 281
                                      printf((char const   */* __restrict  */)"\'\' ");
                                      }
                                      }
                                    }
                                  } else {
                                    {
                                    {
#line 273
                                    printf((char const   */* __restrict  */)"{\\b ");
                                    }
                                    {
#line 274
                                    get_paratype(b->child, verbatim);
                                    }
                                    {
#line 275
                                    printf((char const   */* __restrict  */)"} ");
                                    }
                                    }
                                  }
                                } else {
                                  {
                                  {
#line 266
                                  printf((char const   */* __restrict  */)"{\\it ");
                                  }
                                  {
#line 267
                                  get_paratype(b->child, verbatim);
                                  }
                                  {
#line 268
                                  printf((char const   */* __restrict  */)"} ");
                                  }
                                  }
                                }
                              } else {
                                {
                                {
#line 266
                                printf((char const   */* __restrict  */)"{\\it ");
                                }
                                {
#line 267
                                get_paratype(b->child, verbatim);
                                }
                                {
#line 268
                                printf((char const   */* __restrict  */)"} ");
                                }
                                }
                              }
                            } else {
                              {
                              {
#line 266
                              printf((char const   */* __restrict  */)"{\\it ");
                              }
                              {
#line 267
                              get_paratype(b->child, verbatim);
                              }
                              {
#line 268
                              printf((char const   */* __restrict  */)"} ");
                              }
                              }
                            }
                          } else {
                            {
                            {
#line 258
                            printf((char const   */* __restrict  */)"{\\tt ");
                            }
                            {
#line 259
                            get_paratype(b->child, verbatim);
                            }
                            {
#line 260
                            printf((char const   */* __restrict  */)"} ");
                            }
                            }
                          }
                        } else {
                          {
                          {
#line 258
                          printf((char const   */* __restrict  */)"{\\tt ");
                          }
                          {
#line 259
                          get_paratype(b->child, verbatim);
                          }
                          {
#line 260
                          printf((char const   */* __restrict  */)"} ");
                          }
                          }
                        }
                      } else {
                        {
                        {
#line 258
                        printf((char const   */* __restrict  */)"{\\tt ");
                        }
                        {
#line 259
                        get_paratype(b->child, verbatim);
                        }
                        {
#line 260
                        printf((char const   */* __restrict  */)"} ");
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 258
                      printf((char const   */* __restrict  */)"{\\tt ");
                      }
                      {
#line 259
                      get_paratype(b->child, verbatim);
                      }
                      {
#line 260
                      printf((char const   */* __restrict  */)"} ");
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 258
                    printf((char const   */* __restrict  */)"{\\tt ");
                    }
                    {
#line 259
                    get_paratype(b->child, verbatim);
                    }
                    {
#line 260
                    printf((char const   */* __restrict  */)"} ");
                    }
                    }
                  }
                } else {
                  {
                  {
#line 258
                  printf((char const   */* __restrict  */)"{\\tt ");
                  }
                  {
#line 259
                  get_paratype(b->child, verbatim);
                  }
                  {
#line 260
                  printf((char const   */* __restrict  */)"} ");
                  }
                  }
                }
              } else {
                {
                {
#line 258
                printf((char const   */* __restrict  */)"{\\tt ");
                }
                {
#line 259
                get_paratype(b->child, verbatim);
                }
                {
#line 260
                printf((char const   */* __restrict  */)"} ");
                }
                }
              }
            } else {
              {
              {
#line 258
              printf((char const   */* __restrict  */)"{\\tt ");
              }
              {
#line 259
              get_paratype(b->child, verbatim);
              }
              {
#line 260
              printf((char const   */* __restrict  */)"} ");
              }
              }
            }
          } else {
            {
            {
#line 258
            printf((char const   */* __restrict  */)"{\\tt ");
            }
            {
#line 259
            get_paratype(b->child, verbatim);
            }
            {
#line 260
            printf((char const   */* __restrict  */)"} ");
            }
            }
          }
        } else {
          {
          {
#line 258
          printf((char const   */* __restrict  */)"{\\tt ");
          }
          {
#line 259
          get_paratype(b->child, verbatim);
          }
          {
#line 260
          printf((char const   */* __restrict  */)"} ");
          }
          }
        }
      }
    }
#line 319
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return (0);
}
}
#line 327 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_bookchapter(dxml_element *b , int paraenter ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 329
    if (! b) {
#line 329
      goto while_break;
    }
#line 331
    if ((unsigned int )b->element_type != 0U) {
      {
      {
#line 333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"element type for b was wrong\n");
      }
      {
#line 334
      exit(1);
      }
      }
    } else {
      {
      {
#line 336
      tmp___9 = strcasecmp("sect1", (char const   *)b->element_name);
      }
      }
#line 336
      if (tmp___9) {
        {
        {
#line 336
        tmp___10 = strcasecmp("section", (char const   *)b->element_name);
        }
        }
#line 336
        if (tmp___10) {
          {
          {
#line 345
          tmp___8 = strcasecmp("sect2", (char const   *)b->element_name);
          }
          }
#line 345
          if (tmp___8) {
            {
            {
#line 353
            tmp___7 = strcasecmp("sect3", (char const   *)b->element_name);
            }
            }
#line 353
            if (tmp___7) {
              {
              {
#line 361
              tmp___6 = strcasecmp("title", (char const   *)b->element_name);
              }
              }
#line 361
              if (tmp___6) {
                {
                {
#line 364
                tmp___5 = get_bothtypes(b, 0);
                }
                }
#line 364
                if (! tmp___5) {
                  {
                  {
#line 367
                  tmp___4 = strcasecmp("para", (char const   *)b->element_name);
                  }
                  }
#line 367
                  if (tmp___4) {
                    {
                    {
#line 373
                    tmp___3 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                    }
                    }
#line 373
                    if (tmp___3) {
                      {
                      {
#line 377
                      tmp___2 = strcasecmp("table", (char const   *)b->element_name);
                      }
                      }
#line 377
                      if (tmp___2) {
                        {
                        {
#line 383
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                                b->element_name);
                        }
                        {
#line 384
                        dxml_dump_element(b->child);
                        }
                        }
                      } else {
                        {
                        {
#line 379
                        get_table(b);
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 375
                      get_itemizedlist(b->child);
                      }
                      }
                    }
                  } else {
#line 369
                    if (paraenter) {
                      {
                      {
#line 369
                      puts("\n\n");
                      }
                      }
                    }
                    {
                    {
#line 370
                    get_paratype(b->child, 0);
                    }
                    }
#line 371
                    if (paraenter) {
                      {
                      {
#line 371
                      puts("\n\n");
                      }
                      }
                    }
                  }
                }
              }
            } else {
              {
              {
#line 355
              printf((char const   */* __restrict  */)"\n\\subsubsection{");
              }
              {
#line 356
              tmp___1 = dxml_get_PCDATA_bysimplepath(b->child, "title");
              }
              {
#line 356
              convert_print((char const   *)tmp___1, 0);
              }
              {
#line 357
              printf((char const   */* __restrict  */)"}\n\n");
              }
              {
#line 358
              maybe_label(b);
              }
              {
#line 359
              get_bookchapter(b->child, 1);
              }
              }
            }
          } else {
            {
            {
#line 347
            printf((char const   */* __restrict  */)"\n\\subsection{");
            }
            {
#line 348
            tmp___0 = dxml_get_PCDATA_bysimplepath(b->child, "title");
            }
            {
#line 348
            convert_print((char const   *)tmp___0, 0);
            }
            {
#line 349
            printf((char const   */* __restrict  */)"}\n\n");
            }
            {
#line 350
            maybe_label(b);
            }
            {
#line 351
            get_bookchapter(b->child, 1);
            }
            }
          }
        } else {
          _L: /* CIL Label */ 
          {
          {
#line 339
          printf((char const   */* __restrict  */)"\n\\section{");
          }
          {
#line 340
          tmp = dxml_get_PCDATA_bysimplepath(b->child, "title");
          }
          {
#line 340
          convert_print((char const   *)tmp, 0);
          }
          {
#line 341
          printf((char const   */* __restrict  */)"}\n\n");
          }
          {
#line 342
          maybe_label(b);
          }
          {
#line 343
          get_bookchapter(b->child, 1);
          }
          }
        }
      } else {
#line 336
        goto _L;
      }
    }
#line 387
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (0);
}
}
#line 392 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int recursebook(dxml_element *b ) 
{ 
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 395
  tmp = dxml_get_element_byname(b, "chapter");
  }
  }
  {
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 395
    if (! tmp) {
#line 395
      goto while_break;
    }
    {
    {
#line 397
    printf((char const   */* __restrict  */)"\n\\chapter{");
    }
    {
#line 398
    tmp___0 = dxml_get_PCDATA_bysimplepath(tmp->child, "title");
    }
    {
#line 398
    convert_print((char const   *)tmp___0, 0);
    }
    {
#line 399
    printf((char const   */* __restrict  */)"}\n\n");
    }
    {
#line 400
    maybe_label(tmp);
    }
    {
#line 401
    get_bookchapter(tmp->child, 1);
    }
#line 395
    tmp = tmp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 407 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
int main(int argc , char **argv ) 
{ 
  dxml_element *tmp ;
  int c ;
  char const   *papersize ;
  char const   *articletype ;
  char *title ;
  dxml_element *authorlink ;
  int notfirst ;
  char *tmp___0 ;
  char *tmp___1 ;
  dxml_element *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 412
  papersize = "letter";
#line 413
  articletype = "report";
  {
  {
#line 415
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 415
    c = getopt(argc, (char * const  *)argv, "p");
    }
    }
#line 415
    if (! (c != -1)) {
#line 415
      goto while_break;
    }
    {
#line 419
    if (c == 112) {
#line 419
      goto case_112;
    }
#line 423
    if (c == 63) {
#line 423
      goto case_63;
    }
#line 425
    goto switch_default;
    case_112: /* CIL Label */ 
#line 420
    articletype = "jreport";
#line 421
    papersize = "a4j";
#line 422
    goto switch_break;
    case_63: /* CIL Label */ 
#line 424
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option -%c used\n",
            c);
    }
    }
#line 427
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 431
  printf((char const   */* __restrict  */)"%s%s\n", "%%Generated by dxml-db2latex",
         "0.8.2.1");
  }
  {
#line 436
  tmp = dxml_read_xml(stdin);
  }
  }
#line 437
  if (tmp) {
    {
#line 439
    title = (char *)((void *)0);
    {
#line 443
    printf((char const   */* __restrict  */)"\\documentclass[%s]{%s}\n\\usepackage{moreverb}\n\\date{}\n\\author{",
           papersize, articletype);
    }
#line 451
    notfirst = 0;
    {
#line 452
    authorlink = dxml_get_element_bysimplepath(tmp, "book/bookinfo/authorgroup/author");
    }
    }
    {
    {
#line 452
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 452
      if (! authorlink) {
#line 452
        goto while_break___0;
      }
#line 456
      if (notfirst) {
        {
        {
#line 457
        printf((char const   */* __restrict  */)", ");
        }
        }
      } else {
#line 459
        notfirst = 1;
      }
      {
      {
#line 461
      tmp___0 = dxml_get_PCDATA_bysimplepath(authorlink, "author/firstname");
      }
      {
#line 461
      convert_print((char const   *)tmp___0, 0);
      }
      {
#line 462
      printf((char const   */* __restrict  */)" ");
      }
      {
#line 464
      tmp___1 = dxml_get_PCDATA_bysimplepath(authorlink, "author/surname");
      }
      {
#line 464
      convert_print((char const   *)tmp___1, 0);
      }
      {
#line 452
      authorlink = dxml_get_element_byname(authorlink->next, "author");
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 468
    printf((char const   */* __restrict  */)"}\n");
    }
    {
#line 471
    printf((char const   */* __restrict  */)"\\title{");
    }
    {
#line 473
    title = dxml_get_PCDATA_bysimplepath(tmp, "book/title");
    }
    }
#line 474
    if (! title) {
      {
      {
#line 475
      title = dxml_get_PCDATA_bysimplepath(tmp, "book/bookinfo/title");
      }
      }
    }
#line 476
    if (title) {
      {
      {
#line 477
      convert_print((char const   *)title, 0);
      }
      }
    }
    {
    {
#line 479
    printf((char const   */* __restrict  */)"}\n\\begin{document}\n\\maketitle\n\\tableofcontents\n");
    }
    {
#line 486
    tmp___2 = dxml_get_element_byname(tmp, "book");
    }
    {
#line 486
    recursebook(tmp___2->child);
    }
    {
#line 487
    printf((char const   */* __restrict  */)"\\end{document}\n");
    }
    }
  } else {
    {
    {
#line 492
    printf((char const   */* __restrict  */)"Something wicked happened!\n");
    }
    }
#line 493
    return (1);
  }
#line 496
  return (0);
}
}
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 80 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
dxml_element *dxml_next_notPCDATA(dxml_element *e ) ;
#line 36 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
dxml_element *dxml_next_notPCDATA(dxml_element *e ) 
{ 
  dxml_element *tmp ;

  {
#line 39
  if (! e) {
#line 39
    return ((dxml_element *)((void *)0));
  }
#line 40
  if ((unsigned int )e->element_type == 1U) {
    {
    {
#line 41
    tmp = dxml_next_notPCDATA(e->next);
    }
    }
#line 41
    return (tmp);
  }
#line 42
  return (e);
}
}
#line 45 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
dxml_element *dxml_get_element_byname(dxml_element *e , char const   *name ) 
{ 
  int tmp ;

  {
  {
  {
#line 48
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 48
    if (! e) {
#line 48
      goto while_break;
    }
#line 50
    if ((unsigned int )e->element_type == 0U) {
      {
      {
#line 50
      tmp = strcmp((char const   *)e->element_name, name);
      }
      }
#line 50
      if (! tmp) {
#line 52
        return (e);
      }
    }
#line 53
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return ((dxml_element *)((void *)0));
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal(dxml_element *e , char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 85 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
dxml_element *dxml_get_element_bysimplepath(dxml_element *e , char const   *path ) 
{ 
  char *buf ;
  char *tmp ;
  dxml_element *e2 ;

  {
  {
  {
#line 88
  tmp = strdup(path);
  }
#line 88
  buf = tmp;
  }
#line 91
  if (! buf) {
#line 91
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 92
  e2 = dxml_get_element_bysimplepath_internal(e, buf);
  }
  {
#line 93
  free((void *)buf);
  }
  }
#line 94
  return (e2);
}
}
#line 97 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
char *dxml_get_PCDATA_bysimplepath(dxml_element *e , char const   *path ) 
{ 
  dxml_element *e2 ;
  char *buf ;
  char *tmp ;

  {
  {
  {
#line 104
  tmp = strdup(path);
  }
#line 104
  buf = tmp;
  }
#line 105
  if (! buf) {
#line 105
    return ((char *)((void *)0));
  }
  {
  {
#line 106
  e2 = dxml_get_element_bysimplepath_internal(e, buf);
  }
  {
#line 107
  free((void *)buf);
  }
  }
#line 108
  if (! e2) {
#line 108
    return ((char *)((void *)0));
  }
#line 109
  e2 = e2->child;
#line 109
  if (! e2) {
#line 109
    return ((char *)((void *)0));
  }
  {
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 110
    if ((unsigned int )e2->element_type != 1U) {
#line 110
      if (! e2) {
#line 110
        goto while_break;
      }
    } else {
#line 110
      goto while_break;
    }
#line 112
    e2 = e2->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if (! e2) {
#line 114
    return ((char *)((void *)0));
  }
#line 115
  return (e2->element_name);
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 155 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
void dxml_dump_element(dxml_element *e ) 
{ 


  {
  {
  {
#line 158
  recurse_element(e, 0);
  }
  }
#line 159
  return;
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 675 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 95 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/dancer-xml.h"
void dxml_free_xml(dxml_element *e ) ;
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars(f);
  }
  {
#line 500
  tmp___6 = checkchar('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 520 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
dxml_element *dxml_read_xml(FILE *f ) 
{ 
  dxml_element *e ;
  int c ;
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 526
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 526
    c = _IO_getc(f);
    }
    }
#line 526
    if (! (c != 60)) {
#line 526
      goto while_break;
    }
#line 528
    if (c == -1) {
#line 530
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Garbage is loaded in read_xml prologue\n");
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 538
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 538
    e = read_element(f);
    }
    }
#line 538
    if (! ((unsigned long )((void *)0) == (unsigned long )e)) {
#line 538
      goto while_break___0;
    }
    {
    {
#line 540
    skipwhitechars(f);
    }
    {
#line 541
    tmp = checkchar('<', f);
    }
    }
#line 541
    if (tmp) {
#line 544
      return ((dxml_element *)((void *)0));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 547
  return (e);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 571 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
void dxml_free_xml(dxml_element *e ) 
{ 
  char *__cil_tmp2 ;

  {
#line 574
  if (! e) {
    {
    {
#line 576
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: e is NULL\n");
    }
    }
#line 577
    return;
  }
#line 580
  if (e->element_name) {
    {
    {
#line 581
    free((void *)e->element_name);
    }
    }
  }
#line 582
  if (e->element_attribute) {
    {
    {
#line 583
    dxml_free_attrib(e->element_attribute);
    }
    }
  }
#line 584
  if (e->child) {
    {
    {
#line 585
    dxml_free_xml(e->child);
    }
    }
  }
#line 586
  if (e->next) {
    {
    {
#line 587
    dxml_free_xml(e->next);
    }
    }
  }
  {
  {
#line 588
  free((void *)e);
  }
  }
#line 589
  return;
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 493 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 31 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
char const   *get_PCDATA_bysimplepath_i(dxml_element *e , char const   *loc ) 
{ 
  char const   *s ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 33
  tmp = dxml_get_PCDATA_bysimplepath(e, loc);
  }
#line 33
  s = (char const   *)tmp;
  }
#line 34
  if (s) {
#line 35
    return (s);
  } else {
#line 37
    return ("");
  }
}
}
#line 41 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
static void dump_one_info(dxml_element *e ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 44
  tmp = get_PCDATA_bysimplepath_i(e, "status");
  }
  {
#line 44
  tmp___0 = get_PCDATA_bysimplepath_i(e, "uid");
  }
  {
#line 44
  tmp___1 = get_PCDATA_bysimplepath_i(e, "name");
  }
  {
#line 44
  printf((char const   */* __restrict  */)"<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><tr> \n",
         tmp___1, tmp___0, "hidden", tmp);
  }
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
static void process_file(char const   *filename ) 
{ 
  FILE *f ;
  FILE *tmp ;
  dxml_element *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 57
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 57
  f = tmp;
  {
#line 59
  tmp___0 = dxml_read_xml(f);
  }
  {
#line 61
  tmp___0 = dxml_get_element_byname(tmp___0, "data");
  }
  }
  {
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 61
    if (! tmp___0) {
#line 61
      goto while_break;
    }
    {
    {
#line 63
    dump_one_info(tmp___0->child);
    }
#line 61
    tmp___0 = tmp___0->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (tmp___0) {
    {
    {
#line 66
    dxml_free_xml(tmp___0);
    }
    }
  }
  {
  {
#line 68
  fclose(f);
  }
  }
#line 69
  return;
}
}
#line 72 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
static void dirlist(void) 
{ 
  DIR *dp ;
  struct dirent *ep ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 78
  dp = opendir("./");
  }
  }
#line 79
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
    {
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 81
      ep = readdir(dp);
      }
      }
#line 81
      if (! ep) {
#line 81
        goto while_break;
      }
      {
      {
#line 83
      tmp = strstr((char const   *)(ep->d_name), ".xml");
      }
      }
#line 83
      if (tmp) {
        {
        {
#line 84
        process_file((char const   *)(ep->d_name));
        }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 87
    closedir(dp);
    }
    }
  } else {
    {
    {
#line 90
    perror("Couldn\'t open the directory");
    }
    }
  }
#line 91
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___0(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___0(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___0(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___0(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___0(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___0(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___0(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___0(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___0(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___0(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___0(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___1(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___1(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___1(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___1(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___1(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___1(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___1(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___1(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___1(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___1(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___1(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___0(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___0(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___0(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___0(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___0(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___0((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___0(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___0(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___0(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___0();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___0(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___0(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___0((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___0(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___0(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___0(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___0(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___0(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___0('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___0(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___0(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___0(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___0(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___0(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___0(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___0(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___0(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___0(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___0(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___0(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___0(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___0(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___0(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___0(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___0(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___0();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___0(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___0(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___0(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___0('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___0(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___0(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___0(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___0(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___0(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___0(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___0(f);
  }
  {
#line 500
  tmp___6 = checkchar___0('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___0(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___0(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___0(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___2(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___2(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___2(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___2(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___2(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___2(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___2(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___2(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___2(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___2(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___2(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___1(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___1(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___1(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___1(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___1(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___1((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___1(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___1(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___1(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___1();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___1(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___1(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___1((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___1(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___1(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___1(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___1(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___1(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___1('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___1(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___1(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___1(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___1(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___1(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___1(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___1(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___1(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___1(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___1(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___1(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___1(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___1(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___1(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___1(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___1(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___1();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___1(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___1(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___1(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___1('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___1(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___1(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___1(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___1(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___1(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___1(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___1(f);
  }
  {
#line 500
  tmp___6 = checkchar___1('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___1(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___1(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___1(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___3(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___3(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___3(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___3(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___3(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___3(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___3(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___3(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___3(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___3(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___3(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___2(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___2(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___2(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___2(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___2(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___2((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___2(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___2(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___2(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___2();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___2(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___2(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___2((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___2(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___2(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___2(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___2(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___2(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___2('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___2(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___2(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___2(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___2(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___2(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___2(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___2(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___2(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___2(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___2(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___2(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___2(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___2(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___2(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___2(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___2(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___2();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___2(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___2(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___2(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___2('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___2(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___2(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___2(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___2(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___2(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___2(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___2(f);
  }
  {
#line 500
  tmp___6 = checkchar___2('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___2(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___2(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___2(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 33 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int counter_chapter[5]  = {      0,      0,      0,      0, 
        0};
#line 34 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_chapter  =    (int const   )0;
#line 35 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_sect1  =    (int const   )1;
#line 36 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_sect2  =    (int const   )2;
#line 37 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
int const   c_sect3  =    (int const   )3;
#line 43 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static void clear_counter(int min ) 
{ 
  int i ;

  {
#line 47
  i = min;
  {
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 5)) {
#line 47
      goto while_break;
    }
#line 48
    counter_chapter[i] = 0;
#line 47
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 52 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int replace_external_entity___0(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 55
  tmp___1 = strcmp(s, "gt");
  }
  }
#line 55
  if (tmp___1) {
    {
    {
#line 57
    tmp___0 = strcmp(s, "lt");
    }
    }
#line 57
    if (tmp___0) {
      {
      {
#line 59
      tmp = strcmp(s, "amp");
      }
      }
#line 59
      if (tmp) {
        {
        {
#line 63
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown entity %s\n",
                s);
        }
        {
#line 64
        exit(1);
        }
        }
      } else {
        {
        {
#line 60
        printf((char const   */* __restrict  */)"&amp;");
        }
        }
      }
    } else {
      {
      {
#line 58
      printf((char const   */* __restrict  */)"&lt;");
      }
      }
    }
  } else {
    {
    {
#line 56
    printf((char const   */* __restrict  */)"&gt;");
    }
    }
  }
#line 66
  return (0);
}
}
#line 73 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int convert_print___0(char const   *s , int verbatim ) 
{ 
  char const   *endptr ;
  unsigned short const   **tmp ;
  char *tmps ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 77
  endptr = (char const   *)((void *)0);
#line 79
  if (! s) {
#line 81
    return (1);
  }
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (*s) {
      {
      {
#line 84
      tmp = __ctype_b_loc();
      }
      }
#line 84
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 84
        goto while_break;
      }
    } else {
#line 84
      goto while_break;
    }
#line 86
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 89
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! *s) {
#line 89
      goto while_break___0;
    }
    {
#line 93
    if ((int const   )*s == 10) {
#line 93
      goto case_10;
    }
#line 97
    if ((int const   )*s == 38) {
#line 97
      goto case_38;
    }
#line 112
    goto switch_default;
    case_10: /* CIL Label */ 
#line 94
    if (verbatim) {
      {
      {
#line 94
      printf((char const   */* __restrict  */)"<br>");
      }
      }
    }
    {
    {
#line 95
    printf((char const   */* __restrict  */)"\n");
    }
    }
#line 96
    goto switch_break;
    case_38: /* CIL Label */ 
    {
    {
#line 98
    tmp___0 = strchr(s, ';');
    }
#line 98
    endptr = (char const   *)tmp___0;
    }
#line 98
    if ((unsigned long )((void *)0) != (unsigned long )endptr) {
      {
      {
#line 101
      tmps = strndup(s + 1, (size_t )((endptr - s) - 1L));
      }
      {
#line 102
      replace_external_entity___0((char const   *)tmps);
      }
      {
#line 103
      free((void *)tmps);
      }
#line 104
      s = endptr;
      }
    } else {
      {
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated \'&\' \n");
      }
      {
#line 109
      exit(1);
      }
      }
    }
#line 111
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 113
    _IO_putc((int )*s, stdout);
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 116
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 120
  return (0);
}
}
#line 123 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static char const   *getatrstring___0(dxml_element *e , char const   *attr ) 
{ 
  dxml_attribute *a ;
  int tmp ;

  {
#line 125
  a = e->element_attribute;
  {
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 126
    if (! a) {
#line 126
      goto while_break;
    }
    {
    {
#line 128
    tmp = strcmp((char const   *)a->attribute_name, attr);
    }
    }
#line 128
    if (! tmp) {
#line 129
      return ((char const   *)a->attribute_data);
    }
#line 130
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return ((char const   *)((void *)0));
}
}
#line 135
static int get_paratype___0(dxml_element *b , int verbatim ) ;
#line 136
static int get_bookchapter___0(dxml_element *b , int paraenter ) ;
#line 147 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int maybe_label_start(dxml_element *b ) 
{ 
  char const   *s ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 151
  s = getatrstring___0(b, "id");
  }
  }
#line 151
  if (s) {
    {
    {
#line 153
    printf((char const   */* __restrict  */)"<a href=\"#%s\" name=\"%s\"><!-- label -->\n",
           s, s);
    }
    }
#line 154
    return (1);
  }
#line 156
  return (0);
}
}
#line 162 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static void maybe_label_end(int labelt ) 
{ 
  char *__cil_tmp2 ;

  {
#line 165
  if (labelt) {
    {
    {
#line 166
    printf((char const   */* __restrict  */)"</a>\n");
    }
    }
  }
#line 167
  return;
}
}
#line 173 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_table___0(dxml_element *b_parent ) 
{ 
  dxml_element *row ;
  dxml_element *entry ;
  dxml_element *b ;
  int labelt ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 176
  b = b_parent->child;
  {
#line 180
  labelt = maybe_label_start(b_parent);
  }
  {
#line 181
  tmp = dxml_get_PCDATA_bysimplepath(b, "title");
  }
  {
#line 181
  printf((char const   */* __restrict  */)"<p class=\"tablecaption\">%s</p>\n<table>\n<tbody>\n",
         tmp);
  }
  {
#line 183
  maybe_label_end(labelt);
  }
  {
#line 185
  row = dxml_get_element_bysimplepath(b, "tgroup/tbody/row");
  }
  }
  {
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 185
    if (! row) {
#line 185
      goto while_break;
    }
    {
    {
#line 187
    printf((char const   */* __restrict  */)"<tr>\n");
    }
#line 188
    entry = row->child;
    }
    {
    {
#line 188
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! entry) {
#line 188
        goto while_break___0;
      }
      {
      {
#line 190
      printf((char const   */* __restrict  */)"<td>\n");
      }
      {
#line 191
      get_paratype___0(entry->child, 0);
      }
      {
#line 192
      printf((char const   */* __restrict  */)"</td>\n");
      }
#line 188
      entry = entry->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 194
    printf((char const   */* __restrict  */)"</tr>\n");
    }
#line 185
    row = row->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 196
  printf((char const   */* __restrict  */)"</tbody>\n</table>\n");
  }
  }
#line 199
  return (0);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_itemizedlist___0(dxml_element *b ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 207
  printf((char const   */* __restrict  */)"<ul>\n");
  }
  }
  {
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 208
    if (! b) {
#line 208
      goto while_break;
    }
    {
    {
#line 210
    tmp = strcasecmp("listitem", (char const   *)b->element_name);
    }
    }
#line 210
    if (tmp) {
      {
      {
#line 217
      dxml_dump_element(b);
      }
      }
    } else {
      {
      {
#line 212
      printf((char const   */* __restrict  */)"<li>");
      }
      {
#line 213
      get_bookchapter___0(b->child, 0);
      }
      {
#line 214
      printf((char const   */* __restrict  */)"</li>\n");
      }
      }
    }
#line 219
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 221
  printf((char const   */* __restrict  */)"</ul>\n");
  }
  }
#line 222
  return (0);
}
}
#line 232 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_bothtypes___0(dxml_element *b , int inlinetype ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 234
  tmp = strcasecmp("screen", (char const   *)b->element_name);
  }
  }
#line 234
  if (tmp) {
#line 245
    return (0);
  } else {
#line 236
    if (! inlinetype) {
      {
      {
#line 237
      puts("<pre>");
      }
      }
    }
    {
    {
#line 238
    puts("<span class=\"screen\">");
    }
    {
#line 239
    get_paratype___0(b->child, 1);
    }
    {
#line 240
    puts("</span>");
    }
    }
#line 241
    if (! inlinetype) {
      {
      {
#line 242
      puts("</pre>");
      }
      }
    }
  }
#line 246
  return (1);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_paratype___0(dxml_element *b , int verbatim ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 259
    if (! b) {
#line 259
      goto while_break;
    }
#line 261
    if ((unsigned int )b->element_type == 1U) {
      {
      {
#line 263
      convert_print___0((char const   *)b->element_name, verbatim);
      }
      }
    } else {
      {
      {
#line 265
      tmp___15 = get_bothtypes___0(b, 1);
      }
      }
#line 265
      if (! tmp___15) {
        {
        {
#line 268
        tmp___6 = strcasecmp("command", (char const   *)b->element_name);
        }
        }
#line 268
        if (tmp___6) {
          {
          {
#line 268
          tmp___7 = strcasecmp("filename", (char const   *)b->element_name);
          }
          }
#line 268
          if (tmp___7) {
            {
            {
#line 268
            tmp___8 = strcasecmp("keysym", (char const   *)b->element_name);
            }
            }
#line 268
            if (tmp___8) {
              {
              {
#line 268
              tmp___9 = strcasecmp("keycombo", (char const   *)b->element_name);
              }
              }
#line 268
              if (tmp___9) {
                {
                {
#line 268
                tmp___10 = strcasecmp("otheraddr", (char const   *)b->element_name);
                }
                }
#line 268
                if (tmp___10) {
                  {
                  {
#line 268
                  tmp___11 = strcasecmp("prompt", (char const   *)b->element_name);
                  }
                  }
#line 268
                  if (tmp___11) {
                    {
                    {
#line 268
                    tmp___12 = strcasecmp("address", (char const   *)b->element_name);
                    }
                    }
#line 268
                    if (tmp___12) {
                      {
                      {
#line 268
                      tmp___13 = strcasecmp("option", (char const   *)b->element_name);
                      }
                      }
#line 268
                      if (tmp___13) {
                        {
                        {
#line 268
                        tmp___14 = strcasecmp("parameter", (char const   *)b->element_name);
                        }
                        }
#line 268
                        if (tmp___14) {
                          {
                          {
#line 282
                          tmp___5 = strcasecmp("footnote", (char const   *)b->element_name);
                          }
                          }
#line 282
                          if (tmp___5) {
                            {
                            {
#line 288
                            tmp___4 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                            }
                            }
#line 288
                            if (tmp___4) {
                              {
                              {
#line 292
                              tmp___2 = strcasecmp("xref", (char const   *)b->element_name);
                              }
                              }
#line 292
                              if (tmp___2) {
                                {
                                {
#line 292
                                tmp___3 = strcasecmp("link", (char const   *)b->element_name);
                                }
                                }
#line 292
                                if (tmp___3) {
                                  {
                                  {
#line 300
                                  tmp___1 = strcasecmp("ulink", (char const   *)b->element_name);
                                  }
                                  }
#line 300
                                  if (tmp___1) {
                                    {
                                    {
#line 309
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                                            b->element_name);
                                    }
                                    {
#line 310
                                    dxml_dump_element(b);
                                    }
                                    }
                                  } else {
                                    {
                                    {
#line 302
                                    tmp___0 = getatrstring___0(b, "url");
                                    }
                                    {
#line 302
                                    printf((char const   */* __restrict  */)"<a href=\"%s\">",
                                           tmp___0);
                                    }
                                    {
#line 304
                                    get_paratype___0(b->child, verbatim);
                                    }
                                    {
#line 305
                                    printf((char const   */* __restrict  */)"</a>\n");
                                    }
                                    }
                                  }
                                } else {
                                  {
                                  {
#line 295
                                  tmp = getatrstring___0(b, "linkend");
                                  }
                                  {
#line 295
                                  printf((char const   */* __restrict  */)"<a href=\"#%s\">",
                                         tmp);
                                  }
                                  {
#line 297
                                  get_paratype___0(b->child, verbatim);
                                  }
                                  {
#line 298
                                  printf((char const   */* __restrict  */)"</a>\n");
                                  }
                                  }
                                }
                              } else {
                                {
                                {
#line 295
                                tmp = getatrstring___0(b, "linkend");
                                }
                                {
#line 295
                                printf((char const   */* __restrict  */)"<a href=\"#%s\">",
                                       tmp);
                                }
                                {
#line 297
                                get_paratype___0(b->child, verbatim);
                                }
                                {
#line 298
                                printf((char const   */* __restrict  */)"</a>\n");
                                }
                                }
                              }
                            } else {
                              {
                              {
#line 290
                              get_itemizedlist___0(b->child);
                              }
                              }
                            }
                          } else {
                            {
                            {
#line 284
                            printf((char const   */* __restrict  */)"<span class=\"footnote\">");
                            }
                            {
#line 285
                            get_bookchapter___0(b->child, 0);
                            }
                            {
#line 286
                            printf((char const   */* __restrict  */)"</span>\n");
                            }
                            }
                          }
                        } else {
                          {
                          {
#line 278
                          printf((char const   */* __restrict  */)"<span class=\"%s\">",
                                 b->element_name);
                          }
                          {
#line 279
                          get_paratype___0(b->child, verbatim);
                          }
                          {
#line 280
                          printf((char const   */* __restrict  */)"</span>\n");
                          }
                          }
                        }
                      } else {
                        {
                        {
#line 278
                        printf((char const   */* __restrict  */)"<span class=\"%s\">",
                               b->element_name);
                        }
                        {
#line 279
                        get_paratype___0(b->child, verbatim);
                        }
                        {
#line 280
                        printf((char const   */* __restrict  */)"</span>\n");
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 278
                      printf((char const   */* __restrict  */)"<span class=\"%s\">",
                             b->element_name);
                      }
                      {
#line 279
                      get_paratype___0(b->child, verbatim);
                      }
                      {
#line 280
                      printf((char const   */* __restrict  */)"</span>\n");
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 278
                    printf((char const   */* __restrict  */)"<span class=\"%s\">",
                           b->element_name);
                    }
                    {
#line 279
                    get_paratype___0(b->child, verbatim);
                    }
                    {
#line 280
                    printf((char const   */* __restrict  */)"</span>\n");
                    }
                    }
                  }
                } else {
                  {
                  {
#line 278
                  printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
                  }
                  {
#line 279
                  get_paratype___0(b->child, verbatim);
                  }
                  {
#line 280
                  printf((char const   */* __restrict  */)"</span>\n");
                  }
                  }
                }
              } else {
                {
                {
#line 278
                printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
                }
                {
#line 279
                get_paratype___0(b->child, verbatim);
                }
                {
#line 280
                printf((char const   */* __restrict  */)"</span>\n");
                }
                }
              }
            } else {
              {
              {
#line 278
              printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
              }
              {
#line 279
              get_paratype___0(b->child, verbatim);
              }
              {
#line 280
              printf((char const   */* __restrict  */)"</span>\n");
              }
              }
            }
          } else {
            {
            {
#line 278
            printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
            }
            {
#line 279
            get_paratype___0(b->child, verbatim);
            }
            {
#line 280
            printf((char const   */* __restrict  */)"</span>\n");
            }
            }
          }
        } else {
          {
          {
#line 278
          printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
          }
          {
#line 279
          get_paratype___0(b->child, verbatim);
          }
          {
#line 280
          printf((char const   */* __restrict  */)"</span>\n");
          }
          }
        }
      }
    }
#line 314
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return (0);
}
}
#line 326 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_bookchapter___0(dxml_element *b , int paraenter ) 
{ 
  int labelt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 331
    if (! b) {
#line 331
      goto while_break;
    }
#line 333
    if ((unsigned int )b->element_type != 0U) {
      {
      {
#line 335
      exit(1);
      }
      }
    } else {
      {
      {
#line 337
      tmp___9 = strcasecmp("sect1", (char const   *)b->element_name);
      }
      }
#line 337
      if (tmp___9) {
        {
        {
#line 349
        tmp___8 = strcasecmp("sect2", (char const   *)b->element_name);
        }
        }
#line 349
        if (tmp___8) {
          {
          {
#line 362
          tmp___7 = strcasecmp("sect3", (char const   *)b->element_name);
          }
          }
#line 362
          if (tmp___7) {
            {
            {
#line 376
            tmp___6 = strcasecmp("title", (char const   *)b->element_name);
            }
            }
#line 376
            if (tmp___6) {
              {
              {
#line 379
              tmp___5 = get_bothtypes___0(b, 0);
              }
              }
#line 379
              if (! tmp___5) {
                {
                {
#line 382
                tmp___4 = strcasecmp("para", (char const   *)b->element_name);
                }
                }
#line 382
                if (tmp___4) {
                  {
                  {
#line 388
                  tmp___3 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                  }
                  }
#line 388
                  if (tmp___3) {
                    {
                    {
#line 392
                    tmp___2 = strcasecmp("table", (char const   *)b->element_name);
                    }
                    }
#line 392
                    if (tmp___2) {
                      {
                      {
#line 398
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                              b->element_name);
                      }
                      {
#line 399
                      dxml_dump_element(b->child);
                      }
                      }
                    } else {
                      {
                      {
#line 394
                      get_table___0(b);
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 390
                    get_itemizedlist___0(b->child);
                    }
                    }
                  }
                } else {
#line 384
                  if (paraenter) {
                    {
                    {
#line 384
                    puts("<p>\n");
                    }
                    }
                  }
                  {
                  {
#line 385
                  get_paratype___0(b->child, 0);
                  }
                  }
#line 386
                  if (paraenter) {
                    {
                    {
#line 386
                    puts("</p>\n");
                    }
                    }
                  }
                }
              }
            }
          } else {
            {
            {
#line 364
            labelt = maybe_label_start(b);
            }
#line 365
            (counter_chapter[c_sect3]) ++;
            {
#line 365
            printf((char const   */* __restrict  */)"\n<h3 class=\"sect3\">%i.%i.%i.%i. ",
                   counter_chapter[c_chapter], counter_chapter[c_sect1], counter_chapter[c_sect2],
                   counter_chapter[c_sect3]);
            }
            {
#line 370
            clear_counter((int )(c_sect3 + 1));
            }
            {
#line 371
            tmp___1 = dxml_get_PCDATA_bysimplepath(b->child, "title");
            }
            {
#line 371
            convert_print___0((char const   *)tmp___1, 0);
            }
            {
#line 372
            printf((char const   */* __restrict  */)"</h3>\n\n");
            }
            {
#line 373
            maybe_label_end(labelt);
            }
            {
#line 374
            get_bookchapter___0(b->child, 1);
            }
            }
          }
        } else {
          {
          {
#line 351
          labelt = maybe_label_start(b);
          }
#line 352
          (counter_chapter[c_sect2]) ++;
          {
#line 352
          printf((char const   */* __restrict  */)"\n<h3 class=\"sect2\">%i.%i.%i. ",
                 counter_chapter[c_chapter], counter_chapter[c_sect1], counter_chapter[c_sect2]);
          }
          {
#line 356
          clear_counter((int )(c_sect2 + 1));
          }
          {
#line 357
          tmp___0 = dxml_get_PCDATA_bysimplepath(b->child, "title");
          }
          {
#line 357
          convert_print___0((char const   *)tmp___0, 0);
          }
          {
#line 358
          printf((char const   */* __restrict  */)"</h3>\n\n");
          }
          {
#line 359
          maybe_label_end(labelt);
          }
          {
#line 360
          get_bookchapter___0(b->child, 1);
          }
          }
        }
      } else {
        {
        {
#line 339
        labelt = maybe_label_start(b);
        }
#line 340
        (counter_chapter[c_sect1]) ++;
        {
#line 340
        printf((char const   */* __restrict  */)"\n<h3 class=\"sect1\">%i.%i. ", counter_chapter[c_chapter],
               counter_chapter[c_sect1]);
        }
        {
#line 343
        clear_counter((int )(c_sect1 + 1));
        }
        {
#line 344
        tmp = dxml_get_PCDATA_bysimplepath(b->child, "title");
        }
        {
#line 344
        convert_print___0((char const   *)tmp, 0);
        }
        {
#line 345
        printf((char const   */* __restrict  */)"</h3>\n\n");
        }
        {
#line 346
        maybe_label_end(labelt);
        }
        {
#line 347
        get_bookchapter___0(b->child, 1);
        }
        }
      }
    }
#line 402
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return (0);
}
}
#line 410 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int recursebook___0(dxml_element *b ) 
{ 
  dxml_element *tmp ;
  int labelt ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 414
  labelt = 0;
  {
#line 416
  tmp = dxml_get_element_byname(b, "chapter");
  }
  }
  {
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 416
    if (! tmp) {
#line 416
      goto while_break;
    }
    {
    {
#line 418
    labelt = maybe_label_start(tmp);
    }
#line 419
    (counter_chapter[c_chapter]) ++;
    {
#line 419
    printf((char const   */* __restrict  */)"\n<h2>%i. ", counter_chapter[c_chapter]);
    }
    {
#line 420
    clear_counter((int )(c_chapter + 1));
    }
    {
#line 421
    tmp___0 = dxml_get_PCDATA_bysimplepath(tmp->child, "title");
    }
    {
#line 421
    convert_print___0((char const   *)tmp___0, 0);
    }
    {
#line 422
    printf((char const   */* __restrict  */)"</h2>\n\n");
    }
    {
#line 423
    maybe_label_end(labelt);
    }
    {
#line 424
    get_bookchapter___0(tmp->child, 1);
    }
#line 416
    tmp = tmp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___3(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___3(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___3(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___3(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___3(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___3((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___3(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___3(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___3(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___3();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___3(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___3(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___3((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___3(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___3(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___3(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___3(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___3(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___3('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___3(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___3(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___3(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___3(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___3(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___3(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___3(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___3(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___3(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___3(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___3(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___3(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___3(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___3(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___3(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___3(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___3();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___3(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___3(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___3(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___3('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___3(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___3(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___3(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___3(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___3(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___3(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___3(f);
  }
  {
#line 500
  tmp___6 = checkchar___3('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___3(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___3(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___3(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___4(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___4(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___4(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___4(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___4(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___4(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___4(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___4(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___4(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___4(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___4(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___4(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___4(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___4(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___4(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___4(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___4((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___4(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___4(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___4(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___4();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___4(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___4(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___4((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___4(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___4(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___4(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___4(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___4(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___4('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___4(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___4(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___4(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___4(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___4(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___4(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___4(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___4(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___4(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___4(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___4(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___4(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___4(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___4(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___4(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___4(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___4();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___4(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___4(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___4(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___4('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___4(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___4(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___4(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___4(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___4(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___4(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___4(f);
  }
  {
#line 500
  tmp___6 = checkchar___4('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___4(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___4(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___4(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 36 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.machines-list.parser.c"
static void print_kanrisha_info(dxml_element *e ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 39
  printf((char const   */* __restrict  */)"{");
  }
  {
#line 41
  e = dxml_get_element_bysimplepath(e, "\347\256\241\347\220\206\350\200\205\343\203\252\343\202\271\343\203\210/\347\256\241\347\220\206\350\200\205");
  }
  }
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 41
    if (! e) {
#line 41
      goto while_break;
    }
    {
    {
#line 43
    tmp = get_PCDATA_bysimplepath_i(e->child, "\343\203\241\343\203\274\343\203\253");
    }
    {
#line 43
    tmp___0 = get_PCDATA_bysimplepath_i(e->child, "\347\256\241\347\220\206\350\200\205\345\220\215");
    }
    {
#line 43
    printf((char const   */* __restrict  */)"%s $<$%s$>$ \\\\ ", tmp___0, tmp);
    }
#line 41
    e = e->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 49
  printf((char const   */* __restrict  */)"}");
  }
  }
#line 51
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.machines-list.parser.c"
static void dump_one_info___0(dxml_element *e ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 57
  tmp = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\347\224\250\351\200\224");
  }
  {
#line 57
  tmp___0 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/\343\203\216\343\203\274\343\203\211\346\225\260");
  }
  {
#line 57
  tmp___1 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/\345\275\242\346\205\213");
  }
  {
#line 57
  tmp___2 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/OS");
  }
  {
#line 57
  tmp___3 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/CPU");
  }
  {
#line 57
  tmp___4 = get_PCDATA_bysimplepath_i(e, "\345\220\215\347\247\260");
  }
  {
#line 57
  printf((char const   */* __restrict  */)"\\machineinfo{%s}{%s}{%s}{%s}{%s}{%s}",
         tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
  }
  {
#line 65
  print_kanrisha_info(e);
  }
  {
#line 67
  tmp___5 = get_PCDATA_bysimplepath_i(e, "\351\205\215\345\202\231\345\240\264\346\211\200");
  }
  {
#line 67
  printf((char const   */* __restrict  */)"{%s}\n", tmp___5);
  }
  }
#line 71
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___5(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___5(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___5(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___5(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___5(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___5((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___5(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___5(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___5(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___5();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___5(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___5(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___5((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___5(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___5(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___5(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___5(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___5(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___5('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___5(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___5(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___5(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___5(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___5(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___5(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___5(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___5(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___5(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___5(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___5(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___5(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___5(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___5(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___5(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___5(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___5();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___5(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___5(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___5(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___5('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___5(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___5(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___5(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___5(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___5(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___5(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___5(f);
  }
  {
#line 500
  tmp___6 = checkchar___5('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___5(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___5(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___5(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___5(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___5(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___5(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___5(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___5(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___5(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___5(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___5(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___5(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___5(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___5(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___6(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___6(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___6(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___6(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___6(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___6(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___6(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___6(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___6(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___6(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___6(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___6(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___6(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___6(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___6(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___6(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___6((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___6(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___6(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___6(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___6();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___6(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___6(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___6((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___6(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___6(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___6(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___6(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___6(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___6('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___6(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___6(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___6(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___6(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___6(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___6(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___6(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___6(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___6(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___6(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___6(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___6(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___6(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___6(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___6(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___6(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___6();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___6(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___6(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___6(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___6('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___6(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___6(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___6(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___6(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___6(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___6(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___6(f);
  }
  {
#line 500
  tmp___6 = checkchar___6('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___6(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___6(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___6(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 26 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/testmemleak.c"
static dxml_element *read_open(char const   *filename ) 
{ 
  FILE *f ;
  FILE *tmp ;
  dxml_element *e ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 29
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 29
  f = tmp;
  }
#line 32
  if (f) {
    {
    {
#line 34
    e = dxml_read_xml(f);
    }
    {
#line 35
    fclose(f);
    }
    }
#line 36
    return (e);
  } else {
#line 39
    return ((dxml_element *)((void *)0));
  }
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___7(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___7(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___7(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___7(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___7(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___7(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___7(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___7(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___7(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___7(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___7(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___7(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___7(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___7(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___7(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___7(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___7((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___7(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___7(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___7(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___7();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___7(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___7(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___7((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___7(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___7(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___7(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___7(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___7(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___7('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___7(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___7(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___7(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___7(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___7(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___7(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___7(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___7(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___7(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___7(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___7(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___7(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___7(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___7(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___7(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___7(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___7();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___7(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___7(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___7(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___7('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___7(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___7(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___7(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___7(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___7(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___7(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___7(f);
  }
  {
#line 500
  tmp___6 = checkchar___7('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___7(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___7(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___7(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 30 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int replace_external_entity___1(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 33
  tmp___1 = strcmp(s, "gt");
  }
  }
#line 33
  if (tmp___1) {
    {
    {
#line 35
    tmp___0 = strcmp(s, "lt");
    }
    }
#line 35
    if (tmp___0) {
      {
      {
#line 37
      tmp = strcmp(s, "amp");
      }
      }
#line 37
      if (tmp) {
        {
        {
#line 41
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown entity %s\n",
                s);
        }
        {
#line 42
        exit(1);
        }
        }
      } else {
        {
        {
#line 38
        printf((char const   */* __restrict  */)"\\&{}");
        }
        }
      }
    } else {
      {
      {
#line 36
      printf((char const   */* __restrict  */)"$<$");
      }
      }
    }
  } else {
    {
    {
#line 34
    printf((char const   */* __restrict  */)"$>$");
    }
    }
  }
#line 44
  return (0);
}
}
#line 51 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int convert_print___1(char const   *s , int verbatim ) 
{ 
  char const   *endptr ;
  unsigned short const   **tmp ;
  char *tmps ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 55
  endptr = (char const   *)((void *)0);
#line 57
  if (! s) {
#line 59
    return (1);
  }
  {
  {
#line 62
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 62
    if (*s) {
      {
      {
#line 62
      tmp = __ctype_b_loc();
      }
      }
#line 62
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 64
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! *s) {
#line 66
      goto while_break___0;
    }
    {
#line 70
    if ((int const   )*s == 36) {
#line 70
      goto case_36;
    }
#line 73
    if ((int const   )*s == 95) {
#line 73
      goto case_95;
    }
#line 76
    if ((int const   )*s == 92) {
#line 76
      goto case_92;
    }
#line 79
    if ((int const   )*s == 94) {
#line 79
      goto case_94;
    }
#line 82
    if ((int const   )*s == 126) {
#line 82
      goto case_126;
    }
#line 85
    if ((int const   )*s == 10) {
#line 85
      goto case_10;
    }
#line 89
    if ((int const   )*s == 35) {
#line 89
      goto case_35;
    }
#line 92
    if ((int const   )*s == 91) {
#line 92
      goto case_91;
    }
#line 95
    if ((int const   )*s == 93) {
#line 95
      goto case_93;
    }
#line 99
    if ((int const   )*s == 38) {
#line 99
      goto case_38;
    }
#line 114
    goto switch_default;
    case_36: /* CIL Label */ 
    {
    {
#line 71
    printf((char const   */* __restrict  */)"\\${}");
    }
    }
#line 72
    goto switch_break;
    case_95: /* CIL Label */ 
    {
    {
#line 74
    printf((char const   */* __restrict  */)"\\underline{ }");
    }
    }
#line 75
    goto switch_break;
    case_92: /* CIL Label */ 
    {
    {
#line 77
    printf((char const   */* __restrict  */)"\\verb\'\\\'");
    }
    }
#line 78
    goto switch_break;
    case_94: /* CIL Label */ 
    {
    {
#line 80
    printf((char const   */* __restrict  */)"\\verb!^!");
    }
    }
#line 81
    goto switch_break;
    case_126: /* CIL Label */ 
    {
    {
#line 83
    printf((char const   */* __restrict  */)"\\~\\ ");
    }
    }
#line 84
    goto switch_break;
    case_10: /* CIL Label */ 
#line 86
    if (verbatim) {
      {
      {
#line 86
      printf((char const   */* __restrict  */)"\\\\%%");
      }
      }
    }
    {
    {
#line 87
    printf((char const   */* __restrict  */)"\n");
    }
    }
#line 88
    goto switch_break;
    case_35: /* CIL Label */ 
    {
    {
#line 90
    printf((char const   */* __restrict  */)"$\\sharp$");
    }
    }
#line 91
    goto switch_break;
    case_91: /* CIL Label */ 
    {
    {
#line 93
    printf((char const   */* __restrict  */)"{}[{}");
    }
    }
#line 94
    goto switch_break;
    case_93: /* CIL Label */ 
    {
    {
#line 96
    printf((char const   */* __restrict  */)"{}]{}");
    }
    }
#line 97
    goto switch_break;
    case_38: /* CIL Label */ 
    {
    {
#line 100
    tmp___0 = strchr(s, ';');
    }
#line 100
    endptr = (char const   *)tmp___0;
    }
#line 100
    if ((unsigned long )((void *)0) != (unsigned long )endptr) {
      {
      {
#line 103
      tmps = strndup(s + 1, (size_t )((endptr - s) - 1L));
      }
      {
#line 104
      replace_external_entity___1((char const   *)tmps);
      }
      {
#line 105
      free((void *)tmps);
      }
#line 106
      s = endptr;
      }
    } else {
      {
      {
#line 110
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated & \n");
      }
      {
#line 111
      exit(1);
      }
      }
    }
#line 113
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 115
    _IO_putc((int )*s, stdout);
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 118
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 122
  return (0);
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static char const   *getatrstring___1(dxml_element *e , char const   *attr ) 
{ 
  dxml_attribute *a ;
  int tmp ;

  {
#line 127
  a = e->element_attribute;
  {
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 128
    if (! a) {
#line 128
      goto while_break;
    }
    {
    {
#line 130
    tmp = strcmp((char const   *)a->attribute_name, attr);
    }
    }
#line 130
    if (! tmp) {
#line 131
      return ((char const   *)a->attribute_data);
    }
#line 132
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return ((char const   *)((void *)0));
}
}
#line 137
static int get_paratype___1(dxml_element *b , int verbatim ) ;
#line 138
static int get_bookchapter___1(dxml_element *b , int paraenter ) ;
#line 140 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int maybe_label___0(dxml_element *b ) 
{ 
  char const   *s ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 144
  s = getatrstring___1(b, "id");
  }
  }
#line 144
  if (s) {
    {
    {
#line 145
    printf((char const   */* __restrict  */)"\\label{%s}\n", s);
    }
    }
  }
#line 146
  return (0);
}
}
#line 149 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_table___1(dxml_element *b_parent ) 
{ 
  int i ;
  int width ;
  dxml_element *row ;
  dxml_element *entry ;
  dxml_element *b ;
  int columns ;
  dxml_element *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 154
  b = b_parent->child;
  {
#line 155
  tmp = dxml_get_element_byname(b, "tgroup");
  }
  {
#line 155
  tmp___0 = getatrstring___1(tmp, "cols");
  }
  {
#line 155
  tmp___1 = atoi(tmp___0);
  }
#line 155
  columns = tmp___1;
  {
#line 156
  tmp___2 = dxml_get_PCDATA_bysimplepath(b, "title");
  }
  {
#line 156
  printf((char const   */* __restrict  */)"\\begin{table}\n\\caption{%s}\n", tmp___2);
  }
  {
#line 159
  maybe_label___0(b_parent);
  }
#line 161
  width = 12 / columns;
  {
#line 162
  printf((char const   */* __restrict  */)"\\begin{tabular}{p{%icm}", width);
  }
#line 163
  i = 0;
  }
  {
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < columns - 1)) {
#line 163
      goto while_break;
    }
    {
    {
#line 164
    printf((char const   */* __restrict  */)"|p{%icm}", width);
    }
#line 163
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 165
  printf((char const   */* __restrict  */)"}\n\\hline\n\\hline\n");
  }
  {
#line 166
  row = dxml_get_element_bysimplepath(b, "tgroup/tbody/row");
  }
  }
  {
  {
#line 166
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! row) {
#line 166
      goto while_break___0;
    }
#line 168
    entry = row->child;
    {
    {
#line 168
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 168
      if (! entry) {
#line 168
        goto while_break___1;
      }
      {
      {
#line 170
      get_paratype___1(entry->child, 0);
      }
      }
#line 171
      if (entry->next) {
        {
        {
#line 172
        printf((char const   */* __restrict  */)" & ");
        }
        }
      }
#line 168
      entry = entry->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 176
    printf((char const   */* __restrict  */)"\\\\\n");
    }
#line 166
    row = row->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 178
  printf((char const   */* __restrict  */)"\\hline\n\\hline\n\\end{tabular}\n\\end{table}\n");
  }
  }
#line 183
  return (0);
}
}
#line 186 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_itemizedlist___1(dxml_element *b ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 188
  printf((char const   */* __restrict  */)"\\begin{itemize}\n");
  }
  }
  {
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 189
    if (! b) {
#line 189
      goto while_break;
    }
    {
    {
#line 192
    tmp = strcasecmp("listitem", (char const   *)b->element_name);
    }
    }
#line 192
    if (tmp) {
      {
      {
#line 199
      dxml_dump_element(b);
      }
      }
    } else {
      {
      {
#line 194
      printf((char const   */* __restrict  */)"\\item ");
      }
      {
#line 195
      get_bookchapter___1(b->child, 0);
      }
      {
#line 196
      printf((char const   */* __restrict  */)"\n");
      }
      }
    }
#line 201
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 203
  printf((char const   */* __restrict  */)"\\end{itemize}\n");
  }
  }
#line 204
  return (0);
}
}
#line 213 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_bothtypes___1(dxml_element *b , int inlinetype ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 215
  tmp = strcasecmp("screen", (char const   *)b->element_name);
  }
  }
#line 215
  if (tmp) {
#line 226
    return (0);
  } else {
#line 217
    if (! inlinetype) {
      {
      {
#line 218
      puts("\n\n\n\n");
      }
      }
    }
    {
    {
#line 219
    puts("{\\tt %\n");
    }
    {
#line 220
    get_paratype___1(b->child, 1);
    }
    {
#line 221
    puts("}");
    }
    }
#line 222
    if (! inlinetype) {
      {
      {
#line 223
      puts("\n\n\n\n");
      }
      }
    }
  }
#line 227
  return (1);
}
}
#line 234 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_paratype___1(dxml_element *b , int verbatim ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;

  {
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! b) {
#line 238
      goto while_break;
    }
#line 240
    if ((unsigned int )b->element_type == 1U) {
      {
      {
#line 242
      convert_print___1((char const   *)b->element_name, verbatim);
      }
      }
    } else {
      {
      {
#line 244
      tmp___23 = get_bothtypes___1(b, 1);
      }
      }
#line 244
      if (! tmp___23) {
        {
        {
#line 247
        tmp___13 = strcasecmp("command", (char const   *)b->element_name);
        }
        }
#line 247
        if (tmp___13) {
          {
          {
#line 247
          tmp___14 = strcasecmp("filename", (char const   *)b->element_name);
          }
          }
#line 247
          if (tmp___14) {
            {
            {
#line 247
            tmp___15 = strcasecmp("keysym", (char const   *)b->element_name);
            }
            }
#line 247
            if (tmp___15) {
              {
              {
#line 247
              tmp___16 = strcasecmp("keycombo", (char const   *)b->element_name);
              }
              }
#line 247
              if (tmp___16) {
                {
                {
#line 247
                tmp___17 = strcasecmp("otheraddr", (char const   *)b->element_name);
                }
                }
#line 247
                if (tmp___17) {
                  {
                  {
#line 247
                  tmp___18 = strcasecmp("function", (char const   *)b->element_name);
                  }
                  }
#line 247
                  if (tmp___18) {
                    {
                    {
#line 247
                    tmp___19 = strcasecmp("prompt", (char const   *)b->element_name);
                    }
                    }
#line 247
                    if (tmp___19) {
                      {
                      {
#line 247
                      tmp___20 = strcasecmp("type", (char const   *)b->element_name);
                      }
                      }
#line 247
                      if (tmp___20) {
                        {
                        {
#line 247
                        tmp___21 = strcasecmp("productname", (char const   *)b->element_name);
                        }
                        }
#line 247
                        if (tmp___21) {
                          {
                          {
#line 247
                          tmp___22 = strcasecmp("address", (char const   *)b->element_name);
                          }
                          }
#line 247
                          if (tmp___22) {
                            {
                            {
#line 262
                            tmp___10 = strcasecmp("option", (char const   *)b->element_name);
                            }
                            }
#line 262
                            if (tmp___10) {
                              {
                              {
#line 262
                              tmp___11 = strcasecmp("parameter", (char const   *)b->element_name);
                              }
                              }
#line 262
                              if (tmp___11) {
                                {
                                {
#line 262
                                tmp___12 = strcasecmp("replaceable", (char const   *)b->element_name);
                                }
                                }
#line 262
                                if (tmp___12) {
                                  {
                                  {
#line 270
                                  tmp___9 = strcasecmp("emphasis", (char const   *)b->element_name);
                                  }
                                  }
#line 270
                                  if (tmp___9) {
                                    {
                                    {
#line 277
                                    tmp___8 = strcasecmp("quote", (char const   *)b->element_name);
                                    }
                                    }
#line 277
                                    if (tmp___8) {
                                      {
                                      {
#line 283
                                      tmp___7 = strcasecmp("footnote", (char const   *)b->element_name);
                                      }
                                      }
#line 283
                                      if (tmp___7) {
                                        {
                                        {
#line 289
                                        tmp___6 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                                        }
                                        }
#line 289
                                        if (tmp___6) {
                                          {
                                          {
#line 293
                                          tmp___4 = strcasecmp("xref", (char const   *)b->element_name);
                                          }
                                          }
#line 293
                                          if (tmp___4) {
                                            {
                                            {
#line 293
                                            tmp___5 = strcasecmp("link", (char const   *)b->element_name);
                                            }
                                            }
#line 293
                                            if (tmp___5) {
                                              {
                                              {
#line 300
                                              tmp___2 = strcasecmp("ulink", (char const   *)b->element_name);
                                              }
                                              }
#line 300
                                              if (tmp___2) {
                                                {
                                                {
#line 300
                                                tmp___3 = strcasecmp("email", (char const   *)b->element_name);
                                                }
                                                }
#line 300
                                                if (tmp___3) {
                                                  {
                                                  {
#line 308
                                                  tmp___1 = strcasecmp("table", (char const   *)b->element_name);
                                                  }
                                                  }
#line 308
                                                  if (tmp___1) {
                                                    {
                                                    {
#line 314
                                                    fprintf((FILE */* __restrict  */)stderr,
                                                            (char const   */* __restrict  */)"Unknown tag: %s\n",
                                                            b->element_name);
                                                    }
                                                    {
#line 315
                                                    dxml_dump_element(b);
                                                    }
                                                    }
                                                  } else {
                                                    {
                                                    {
#line 310
                                                    get_table___1(b);
                                                    }
                                                    }
                                                  }
                                                } else {
                                                  {
                                                  {
#line 303
                                                  get_paratype___1(b->child, verbatim);
                                                  }
                                                  {
#line 304
                                                  printf((char const   */* __restrict  */)"({\\tt ");
                                                  }
                                                  {
#line 305
                                                  tmp___0 = getatrstring___1(b, "url");
                                                  }
                                                  {
#line 305
                                                  convert_print___1(tmp___0, verbatim);
                                                  }
                                                  {
#line 306
                                                  printf((char const   */* __restrict  */)"})");
                                                  }
                                                  }
                                                }
                                              } else {
                                                {
                                                {
#line 303
                                                get_paratype___1(b->child, verbatim);
                                                }
                                                {
#line 304
                                                printf((char const   */* __restrict  */)"({\\tt ");
                                                }
                                                {
#line 305
                                                tmp___0 = getatrstring___1(b, "url");
                                                }
                                                {
#line 305
                                                convert_print___1(tmp___0, verbatim);
                                                }
                                                {
#line 306
                                                printf((char const   */* __restrict  */)"})");
                                                }
                                                }
                                              }
                                            } else {
                                              {
                                              {
#line 296
                                              tmp = getatrstring___1(b, "linkend");
                                              }
                                              {
#line 296
                                              printf((char const   */* __restrict  */)"\\ref{%s}",
                                                     tmp);
                                              }
                                              {
#line 298
                                              get_paratype___1(b->child, verbatim);
                                              }
                                              }
                                            }
                                          } else {
                                            {
                                            {
#line 296
                                            tmp = getatrstring___1(b, "linkend");
                                            }
                                            {
#line 296
                                            printf((char const   */* __restrict  */)"\\ref{%s}",
                                                   tmp);
                                            }
                                            {
#line 298
                                            get_paratype___1(b->child, verbatim);
                                            }
                                            }
                                          }
                                        } else {
                                          {
                                          {
#line 291
                                          get_itemizedlist___1(b->child);
                                          }
                                          }
                                        }
                                      } else {
                                        {
                                        {
#line 285
                                        printf((char const   */* __restrict  */)"\\footnote{");
                                        }
                                        {
#line 286
                                        get_bookchapter___1(b->child, 0);
                                        }
                                        {
#line 287
                                        printf((char const   */* __restrict  */)"} ");
                                        }
                                        }
                                      }
                                    } else {
                                      {
                                      {
#line 279
                                      printf((char const   */* __restrict  */)" ``");
                                      }
                                      {
#line 280
                                      get_paratype___1(b->child, verbatim);
                                      }
                                      {
#line 281
                                      printf((char const   */* __restrict  */)"\'\' ");
                                      }
                                      }
                                    }
                                  } else {
                                    {
                                    {
#line 273
                                    printf((char const   */* __restrict  */)"{\\b ");
                                    }
                                    {
#line 274
                                    get_paratype___1(b->child, verbatim);
                                    }
                                    {
#line 275
                                    printf((char const   */* __restrict  */)"} ");
                                    }
                                    }
                                  }
                                } else {
                                  {
                                  {
#line 266
                                  printf((char const   */* __restrict  */)"{\\it ");
                                  }
                                  {
#line 267
                                  get_paratype___1(b->child, verbatim);
                                  }
                                  {
#line 268
                                  printf((char const   */* __restrict  */)"} ");
                                  }
                                  }
                                }
                              } else {
                                {
                                {
#line 266
                                printf((char const   */* __restrict  */)"{\\it ");
                                }
                                {
#line 267
                                get_paratype___1(b->child, verbatim);
                                }
                                {
#line 268
                                printf((char const   */* __restrict  */)"} ");
                                }
                                }
                              }
                            } else {
                              {
                              {
#line 266
                              printf((char const   */* __restrict  */)"{\\it ");
                              }
                              {
#line 267
                              get_paratype___1(b->child, verbatim);
                              }
                              {
#line 268
                              printf((char const   */* __restrict  */)"} ");
                              }
                              }
                            }
                          } else {
                            {
                            {
#line 258
                            printf((char const   */* __restrict  */)"{\\tt ");
                            }
                            {
#line 259
                            get_paratype___1(b->child, verbatim);
                            }
                            {
#line 260
                            printf((char const   */* __restrict  */)"} ");
                            }
                            }
                          }
                        } else {
                          {
                          {
#line 258
                          printf((char const   */* __restrict  */)"{\\tt ");
                          }
                          {
#line 259
                          get_paratype___1(b->child, verbatim);
                          }
                          {
#line 260
                          printf((char const   */* __restrict  */)"} ");
                          }
                          }
                        }
                      } else {
                        {
                        {
#line 258
                        printf((char const   */* __restrict  */)"{\\tt ");
                        }
                        {
#line 259
                        get_paratype___1(b->child, verbatim);
                        }
                        {
#line 260
                        printf((char const   */* __restrict  */)"} ");
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 258
                      printf((char const   */* __restrict  */)"{\\tt ");
                      }
                      {
#line 259
                      get_paratype___1(b->child, verbatim);
                      }
                      {
#line 260
                      printf((char const   */* __restrict  */)"} ");
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 258
                    printf((char const   */* __restrict  */)"{\\tt ");
                    }
                    {
#line 259
                    get_paratype___1(b->child, verbatim);
                    }
                    {
#line 260
                    printf((char const   */* __restrict  */)"} ");
                    }
                    }
                  }
                } else {
                  {
                  {
#line 258
                  printf((char const   */* __restrict  */)"{\\tt ");
                  }
                  {
#line 259
                  get_paratype___1(b->child, verbatim);
                  }
                  {
#line 260
                  printf((char const   */* __restrict  */)"} ");
                  }
                  }
                }
              } else {
                {
                {
#line 258
                printf((char const   */* __restrict  */)"{\\tt ");
                }
                {
#line 259
                get_paratype___1(b->child, verbatim);
                }
                {
#line 260
                printf((char const   */* __restrict  */)"} ");
                }
                }
              }
            } else {
              {
              {
#line 258
              printf((char const   */* __restrict  */)"{\\tt ");
              }
              {
#line 259
              get_paratype___1(b->child, verbatim);
              }
              {
#line 260
              printf((char const   */* __restrict  */)"} ");
              }
              }
            }
          } else {
            {
            {
#line 258
            printf((char const   */* __restrict  */)"{\\tt ");
            }
            {
#line 259
            get_paratype___1(b->child, verbatim);
            }
            {
#line 260
            printf((char const   */* __restrict  */)"} ");
            }
            }
          }
        } else {
          {
          {
#line 258
          printf((char const   */* __restrict  */)"{\\tt ");
          }
          {
#line 259
          get_paratype___1(b->child, verbatim);
          }
          {
#line 260
          printf((char const   */* __restrict  */)"} ");
          }
          }
        }
      }
    }
#line 319
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return (0);
}
}
#line 327 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int get_bookchapter___1(dxml_element *b , int paraenter ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 329
    if (! b) {
#line 329
      goto while_break;
    }
#line 331
    if ((unsigned int )b->element_type != 0U) {
      {
      {
#line 333
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"element type for b was wrong\n");
      }
      {
#line 334
      exit(1);
      }
      }
    } else {
      {
      {
#line 336
      tmp___9 = strcasecmp("sect1", (char const   *)b->element_name);
      }
      }
#line 336
      if (tmp___9) {
        {
        {
#line 336
        tmp___10 = strcasecmp("section", (char const   *)b->element_name);
        }
        }
#line 336
        if (tmp___10) {
          {
          {
#line 345
          tmp___8 = strcasecmp("sect2", (char const   *)b->element_name);
          }
          }
#line 345
          if (tmp___8) {
            {
            {
#line 353
            tmp___7 = strcasecmp("sect3", (char const   *)b->element_name);
            }
            }
#line 353
            if (tmp___7) {
              {
              {
#line 361
              tmp___6 = strcasecmp("title", (char const   *)b->element_name);
              }
              }
#line 361
              if (tmp___6) {
                {
                {
#line 364
                tmp___5 = get_bothtypes___1(b, 0);
                }
                }
#line 364
                if (! tmp___5) {
                  {
                  {
#line 367
                  tmp___4 = strcasecmp("para", (char const   *)b->element_name);
                  }
                  }
#line 367
                  if (tmp___4) {
                    {
                    {
#line 373
                    tmp___3 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                    }
                    }
#line 373
                    if (tmp___3) {
                      {
                      {
#line 377
                      tmp___2 = strcasecmp("table", (char const   *)b->element_name);
                      }
                      }
#line 377
                      if (tmp___2) {
                        {
                        {
#line 383
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                                b->element_name);
                        }
                        {
#line 384
                        dxml_dump_element(b->child);
                        }
                        }
                      } else {
                        {
                        {
#line 379
                        get_table___1(b);
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 375
                      get_itemizedlist___1(b->child);
                      }
                      }
                    }
                  } else {
#line 369
                    if (paraenter) {
                      {
                      {
#line 369
                      puts("\n\n");
                      }
                      }
                    }
                    {
                    {
#line 370
                    get_paratype___1(b->child, 0);
                    }
                    }
#line 371
                    if (paraenter) {
                      {
                      {
#line 371
                      puts("\n\n");
                      }
                      }
                    }
                  }
                }
              }
            } else {
              {
              {
#line 355
              printf((char const   */* __restrict  */)"\n\\subsubsection{");
              }
              {
#line 356
              tmp___1 = dxml_get_PCDATA_bysimplepath(b->child, "title");
              }
              {
#line 356
              convert_print___1((char const   *)tmp___1, 0);
              }
              {
#line 357
              printf((char const   */* __restrict  */)"}\n\n");
              }
              {
#line 358
              maybe_label___0(b);
              }
              {
#line 359
              get_bookchapter___1(b->child, 1);
              }
              }
            }
          } else {
            {
            {
#line 347
            printf((char const   */* __restrict  */)"\n\\subsection{");
            }
            {
#line 348
            tmp___0 = dxml_get_PCDATA_bysimplepath(b->child, "title");
            }
            {
#line 348
            convert_print___1((char const   *)tmp___0, 0);
            }
            {
#line 349
            printf((char const   */* __restrict  */)"}\n\n");
            }
            {
#line 350
            maybe_label___0(b);
            }
            {
#line 351
            get_bookchapter___1(b->child, 1);
            }
            }
          }
        } else {
          _L: /* CIL Label */ 
          {
          {
#line 339
          printf((char const   */* __restrict  */)"\n\\section{");
          }
          {
#line 340
          tmp = dxml_get_PCDATA_bysimplepath(b->child, "title");
          }
          {
#line 340
          convert_print___1((char const   *)tmp, 0);
          }
          {
#line 341
          printf((char const   */* __restrict  */)"}\n\n");
          }
          {
#line 342
          maybe_label___0(b);
          }
          {
#line 343
          get_bookchapter___1(b->child, 1);
          }
          }
        }
      } else {
#line 336
        goto _L;
      }
    }
#line 387
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (0);
}
}
#line 392 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2latex.c"
static int recursebook___1(dxml_element *b ) 
{ 
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 395
  tmp = dxml_get_element_byname(b, "chapter");
  }
  }
  {
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 395
    if (! tmp) {
#line 395
      goto while_break;
    }
    {
    {
#line 397
    printf((char const   */* __restrict  */)"\n\\chapter{");
    }
    {
#line 398
    tmp___0 = dxml_get_PCDATA_bysimplepath(tmp->child, "title");
    }
    {
#line 398
    convert_print___1((char const   *)tmp___0, 0);
    }
    {
#line 399
    printf((char const   */* __restrict  */)"}\n\n");
    }
    {
#line 400
    maybe_label___0(tmp);
    }
    {
#line 401
    get_bookchapter___1(tmp->child, 1);
    }
#line 395
    tmp = tmp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (0);
}
}
#line 58 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static dxml_element *dxml_get_element_bysimplepath_internal___8(dxml_element *e ,
                                                                char *path ) 
{ 
  char *slash ;
  char *tmp ;
  dxml_element *tmp___0 ;
  dxml_element *tmp___1 ;
  dxml_element *tmp___2 ;

  {
  {
  {
#line 65
  tmp = strchr((char const   *)path, '/');
  }
#line 65
  slash = tmp;
  }
#line 67
  if ((unsigned long )slash == (unsigned long )path) {
    {
    {
#line 69
    tmp___0 = dxml_get_element_bysimplepath(e, (char const   *)(path + 1));
    }
    }
#line 69
    return (tmp___0);
  } else
#line 71
  if (slash) {
    {
#line 73
    *slash = (char)0;
    {
#line 74
    e = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 74
    if (! e) {
#line 75
      return ((dxml_element *)((void *)0));
    }
#line 76
    e = e->child;
#line 76
    if (! e) {
#line 77
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 79
    tmp___1 = dxml_get_element_bysimplepath(e, (char const   *)(slash + 1));
    }
    }
#line 79
    return (tmp___1);
  } else {
    {
    {
#line 82
    tmp___2 = dxml_get_element_byname(e, (char const   *)path);
    }
    }
#line 82
    return (tmp___2);
  }
}
}
#line 118 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void space___8(int i ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 121
    tmp = i;
#line 121
    i --;
#line 121
    if (! tmp) {
#line 121
      goto while_break;
    }
    {
    {
#line 122
    printf((char const   */* __restrict  */)" ");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 125 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_attribute___8(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 128
  printf((char const   */* __restrict  */)" %s=\"%s\"", a->attribute_name, a->attribute_data);
  }
  }
#line 129
  if (a->next) {
    {
    {
#line 130
    recurse_attribute___8(a->next);
    }
    }
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxmlhelper.c"
static void recurse_element___8(dxml_element *e , int level ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 136
  if ((unsigned int )e->element_type == 0U) {
    {
    {
#line 138
    space___8(level);
    }
    {
#line 139
    printf((char const   */* __restrict  */)"<%s", e->element_name);
    }
    }
#line 140
    if (e->element_attribute) {
      {
      {
#line 141
      recurse_attribute___8(e->element_attribute);
      }
      }
    }
    {
    {
#line 142
    printf((char const   */* __restrict  */)">\n");
    }
    }
#line 143
    if (e->child) {
      {
      {
#line 144
      recurse_element___8(e->child, level + 1);
      }
      }
    }
    {
    {
#line 145
    space___8(level);
    }
    {
#line 145
    printf((char const   */* __restrict  */)"</%s>\n", e->element_name);
    }
    }
  } else {
    {
    {
#line 149
    space___8(level);
    }
    {
#line 150
    printf((char const   */* __restrict  */)"%s\n", e->element_name);
    }
    }
  }
#line 152
  if (e->next) {
    {
    {
#line 152
    recurse_element___8(e->next, level);
    }
    }
  }
#line 153
  return;
}
}
#line 36 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.machines-list.parser.c"
static void print_kanrisha_info___0(dxml_element *e ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 39
  printf((char const   */* __restrict  */)"{");
  }
  {
#line 41
  e = dxml_get_element_bysimplepath(e, "\347\256\241\347\220\206\350\200\205\343\203\252\343\202\271\343\203\210/\347\256\241\347\220\206\350\200\205");
  }
  }
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 41
    if (! e) {
#line 41
      goto while_break;
    }
    {
    {
#line 43
    tmp = get_PCDATA_bysimplepath_i(e->child, "\343\203\241\343\203\274\343\203\253");
    }
    {
#line 43
    tmp___0 = get_PCDATA_bysimplepath_i(e->child, "\347\256\241\347\220\206\350\200\205\345\220\215");
    }
    {
#line 43
    printf((char const   */* __restrict  */)"%s $<$%s$>$ \\\\ ", tmp___0, tmp);
    }
#line 41
    e = e->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 49
  printf((char const   */* __restrict  */)"}");
  }
  }
#line 51
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.machines-list.parser.c"
static void dump_one_info___1(dxml_element *e ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 57
  tmp = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\347\224\250\351\200\224");
  }
  {
#line 57
  tmp___0 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/\343\203\216\343\203\274\343\203\211\346\225\260");
  }
  {
#line 57
  tmp___1 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/\345\275\242\346\205\213");
  }
  {
#line 57
  tmp___2 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/OS");
  }
  {
#line 57
  tmp___3 = get_PCDATA_bysimplepath_i(e, "\343\202\267\343\202\271\343\203\206\343\203\240\346\247\213\346\210\220/CPU");
  }
  {
#line 57
  tmp___4 = get_PCDATA_bysimplepath_i(e, "\345\220\215\347\247\260");
  }
  {
#line 57
  printf((char const   */* __restrict  */)"\\machineinfo{%s}{%s}{%s}{%s}{%s}{%s}",
         tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
  }
  {
#line 65
  print_kanrisha_info___0(e);
  }
  {
#line 67
  tmp___5 = get_PCDATA_bysimplepath_i(e, "\351\205\215\345\202\231\345\240\264\346\211\200");
  }
  {
#line 67
  printf((char const   */* __restrict  */)"{%s}\n", tmp___5);
  }
  }
#line 71
  return;
}
}
#line 43 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static void clear_counter___0(int min ) 
{ 
  int i ;

  {
#line 47
  i = min;
  {
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 5)) {
#line 47
      goto while_break;
    }
#line 48
    counter_chapter[i] = 0;
#line 47
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 52 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int replace_external_entity___2(char const   *s ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 55
  tmp___1 = strcmp(s, "gt");
  }
  }
#line 55
  if (tmp___1) {
    {
    {
#line 57
    tmp___0 = strcmp(s, "lt");
    }
    }
#line 57
    if (tmp___0) {
      {
      {
#line 59
      tmp = strcmp(s, "amp");
      }
      }
#line 59
      if (tmp) {
        {
        {
#line 63
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown entity %s\n",
                s);
        }
        {
#line 64
        exit(1);
        }
        }
      } else {
        {
        {
#line 60
        printf((char const   */* __restrict  */)"&amp;");
        }
        }
      }
    } else {
      {
      {
#line 58
      printf((char const   */* __restrict  */)"&lt;");
      }
      }
    }
  } else {
    {
    {
#line 56
    printf((char const   */* __restrict  */)"&gt;");
    }
    }
  }
#line 66
  return (0);
}
}
#line 73 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int convert_print___2(char const   *s , int verbatim ) 
{ 
  char const   *endptr ;
  unsigned short const   **tmp ;
  char *tmps ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 77
  endptr = (char const   *)((void *)0);
#line 79
  if (! s) {
#line 81
    return (1);
  }
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (*s) {
      {
      {
#line 84
      tmp = __ctype_b_loc();
      }
      }
#line 84
      if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 84
        goto while_break;
      }
    } else {
#line 84
      goto while_break;
    }
#line 86
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 89
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! *s) {
#line 89
      goto while_break___0;
    }
    {
#line 93
    if ((int const   )*s == 10) {
#line 93
      goto case_10;
    }
#line 97
    if ((int const   )*s == 38) {
#line 97
      goto case_38;
    }
#line 112
    goto switch_default;
    case_10: /* CIL Label */ 
#line 94
    if (verbatim) {
      {
      {
#line 94
      printf((char const   */* __restrict  */)"<br>");
      }
      }
    }
    {
    {
#line 95
    printf((char const   */* __restrict  */)"\n");
    }
    }
#line 96
    goto switch_break;
    case_38: /* CIL Label */ 
    {
    {
#line 98
    tmp___0 = strchr(s, ';');
    }
#line 98
    endptr = (char const   *)tmp___0;
    }
#line 98
    if ((unsigned long )((void *)0) != (unsigned long )endptr) {
      {
      {
#line 101
      tmps = strndup(s + 1, (size_t )((endptr - s) - 1L));
      }
      {
#line 102
      replace_external_entity___2((char const   *)tmps);
      }
      {
#line 103
      free((void *)tmps);
      }
#line 104
      s = endptr;
      }
    } else {
      {
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unterminated \'&\' \n");
      }
      {
#line 109
      exit(1);
      }
      }
    }
#line 111
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 113
    _IO_putc((int )*s, stdout);
    }
    }
    switch_break: /* CIL Label */ ;
    }
#line 116
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 120
  return (0);
}
}
#line 123 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static char const   *getatrstring___2(dxml_element *e , char const   *attr ) 
{ 
  dxml_attribute *a ;
  int tmp ;

  {
#line 125
  a = e->element_attribute;
  {
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 126
    if (! a) {
#line 126
      goto while_break;
    }
    {
    {
#line 128
    tmp = strcmp((char const   *)a->attribute_name, attr);
    }
    }
#line 128
    if (! tmp) {
#line 129
      return ((char const   *)a->attribute_data);
    }
#line 130
    a = a->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return ((char const   *)((void *)0));
}
}
#line 135
static int get_paratype___2(dxml_element *b , int verbatim ) ;
#line 136
static int get_bookchapter___2(dxml_element *b , int paraenter ) ;
#line 147 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int maybe_label_start___0(dxml_element *b ) 
{ 
  char const   *s ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 151
  s = getatrstring___2(b, "id");
  }
  }
#line 151
  if (s) {
    {
    {
#line 153
    printf((char const   */* __restrict  */)"<a href=\"#%s\" name=\"%s\"><!-- label -->\n",
           s, s);
    }
    }
#line 154
    return (1);
  }
#line 156
  return (0);
}
}
#line 162 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static void maybe_label_end___0(int labelt ) 
{ 
  char *__cil_tmp2 ;

  {
#line 165
  if (labelt) {
    {
    {
#line 166
    printf((char const   */* __restrict  */)"</a>\n");
    }
    }
  }
#line 167
  return;
}
}
#line 173 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_table___2(dxml_element *b_parent ) 
{ 
  dxml_element *row ;
  dxml_element *entry ;
  dxml_element *b ;
  int labelt ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 176
  b = b_parent->child;
  {
#line 180
  labelt = maybe_label_start___0(b_parent);
  }
  {
#line 181
  tmp = dxml_get_PCDATA_bysimplepath(b, "title");
  }
  {
#line 181
  printf((char const   */* __restrict  */)"<p class=\"tablecaption\">%s</p>\n<table>\n<tbody>\n",
         tmp);
  }
  {
#line 183
  maybe_label_end___0(labelt);
  }
  {
#line 185
  row = dxml_get_element_bysimplepath(b, "tgroup/tbody/row");
  }
  }
  {
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 185
    if (! row) {
#line 185
      goto while_break;
    }
    {
    {
#line 187
    printf((char const   */* __restrict  */)"<tr>\n");
    }
#line 188
    entry = row->child;
    }
    {
    {
#line 188
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! entry) {
#line 188
        goto while_break___0;
      }
      {
      {
#line 190
      printf((char const   */* __restrict  */)"<td>\n");
      }
      {
#line 191
      get_paratype___2(entry->child, 0);
      }
      {
#line 192
      printf((char const   */* __restrict  */)"</td>\n");
      }
#line 188
      entry = entry->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 194
    printf((char const   */* __restrict  */)"</tr>\n");
    }
#line 185
    row = row->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 196
  printf((char const   */* __restrict  */)"</tbody>\n</table>\n");
  }
  }
#line 199
  return (0);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_itemizedlist___2(dxml_element *b ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 207
  printf((char const   */* __restrict  */)"<ul>\n");
  }
  }
  {
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 208
    if (! b) {
#line 208
      goto while_break;
    }
    {
    {
#line 210
    tmp = strcasecmp("listitem", (char const   *)b->element_name);
    }
    }
#line 210
    if (tmp) {
      {
      {
#line 217
      dxml_dump_element(b);
      }
      }
    } else {
      {
      {
#line 212
      printf((char const   */* __restrict  */)"<li>");
      }
      {
#line 213
      get_bookchapter___2(b->child, 0);
      }
      {
#line 214
      printf((char const   */* __restrict  */)"</li>\n");
      }
      }
    }
#line 219
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 221
  printf((char const   */* __restrict  */)"</ul>\n");
  }
  }
#line 222
  return (0);
}
}
#line 232 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_bothtypes___2(dxml_element *b , int inlinetype ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 234
  tmp = strcasecmp("screen", (char const   *)b->element_name);
  }
  }
#line 234
  if (tmp) {
#line 245
    return (0);
  } else {
#line 236
    if (! inlinetype) {
      {
      {
#line 237
      puts("<pre>");
      }
      }
    }
    {
    {
#line 238
    puts("<span class=\"screen\">");
    }
    {
#line 239
    get_paratype___2(b->child, 1);
    }
    {
#line 240
    puts("</span>");
    }
    }
#line 241
    if (! inlinetype) {
      {
      {
#line 242
      puts("</pre>");
      }
      }
    }
  }
#line 246
  return (1);
}
}
#line 255 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_paratype___2(dxml_element *b , int verbatim ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 259
    if (! b) {
#line 259
      goto while_break;
    }
#line 261
    if ((unsigned int )b->element_type == 1U) {
      {
      {
#line 263
      convert_print___2((char const   *)b->element_name, verbatim);
      }
      }
    } else {
      {
      {
#line 265
      tmp___15 = get_bothtypes___2(b, 1);
      }
      }
#line 265
      if (! tmp___15) {
        {
        {
#line 268
        tmp___6 = strcasecmp("command", (char const   *)b->element_name);
        }
        }
#line 268
        if (tmp___6) {
          {
          {
#line 268
          tmp___7 = strcasecmp("filename", (char const   *)b->element_name);
          }
          }
#line 268
          if (tmp___7) {
            {
            {
#line 268
            tmp___8 = strcasecmp("keysym", (char const   *)b->element_name);
            }
            }
#line 268
            if (tmp___8) {
              {
              {
#line 268
              tmp___9 = strcasecmp("keycombo", (char const   *)b->element_name);
              }
              }
#line 268
              if (tmp___9) {
                {
                {
#line 268
                tmp___10 = strcasecmp("otheraddr", (char const   *)b->element_name);
                }
                }
#line 268
                if (tmp___10) {
                  {
                  {
#line 268
                  tmp___11 = strcasecmp("prompt", (char const   *)b->element_name);
                  }
                  }
#line 268
                  if (tmp___11) {
                    {
                    {
#line 268
                    tmp___12 = strcasecmp("address", (char const   *)b->element_name);
                    }
                    }
#line 268
                    if (tmp___12) {
                      {
                      {
#line 268
                      tmp___13 = strcasecmp("option", (char const   *)b->element_name);
                      }
                      }
#line 268
                      if (tmp___13) {
                        {
                        {
#line 268
                        tmp___14 = strcasecmp("parameter", (char const   *)b->element_name);
                        }
                        }
#line 268
                        if (tmp___14) {
                          {
                          {
#line 282
                          tmp___5 = strcasecmp("footnote", (char const   *)b->element_name);
                          }
                          }
#line 282
                          if (tmp___5) {
                            {
                            {
#line 288
                            tmp___4 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                            }
                            }
#line 288
                            if (tmp___4) {
                              {
                              {
#line 292
                              tmp___2 = strcasecmp("xref", (char const   *)b->element_name);
                              }
                              }
#line 292
                              if (tmp___2) {
                                {
                                {
#line 292
                                tmp___3 = strcasecmp("link", (char const   *)b->element_name);
                                }
                                }
#line 292
                                if (tmp___3) {
                                  {
                                  {
#line 300
                                  tmp___1 = strcasecmp("ulink", (char const   *)b->element_name);
                                  }
                                  }
#line 300
                                  if (tmp___1) {
                                    {
                                    {
#line 309
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                                            b->element_name);
                                    }
                                    {
#line 310
                                    dxml_dump_element(b);
                                    }
                                    }
                                  } else {
                                    {
                                    {
#line 302
                                    tmp___0 = getatrstring___2(b, "url");
                                    }
                                    {
#line 302
                                    printf((char const   */* __restrict  */)"<a href=\"%s\">",
                                           tmp___0);
                                    }
                                    {
#line 304
                                    get_paratype___2(b->child, verbatim);
                                    }
                                    {
#line 305
                                    printf((char const   */* __restrict  */)"</a>\n");
                                    }
                                    }
                                  }
                                } else {
                                  {
                                  {
#line 295
                                  tmp = getatrstring___2(b, "linkend");
                                  }
                                  {
#line 295
                                  printf((char const   */* __restrict  */)"<a href=\"#%s\">",
                                         tmp);
                                  }
                                  {
#line 297
                                  get_paratype___2(b->child, verbatim);
                                  }
                                  {
#line 298
                                  printf((char const   */* __restrict  */)"</a>\n");
                                  }
                                  }
                                }
                              } else {
                                {
                                {
#line 295
                                tmp = getatrstring___2(b, "linkend");
                                }
                                {
#line 295
                                printf((char const   */* __restrict  */)"<a href=\"#%s\">",
                                       tmp);
                                }
                                {
#line 297
                                get_paratype___2(b->child, verbatim);
                                }
                                {
#line 298
                                printf((char const   */* __restrict  */)"</a>\n");
                                }
                                }
                              }
                            } else {
                              {
                              {
#line 290
                              get_itemizedlist___2(b->child);
                              }
                              }
                            }
                          } else {
                            {
                            {
#line 284
                            printf((char const   */* __restrict  */)"<span class=\"footnote\">");
                            }
                            {
#line 285
                            get_bookchapter___2(b->child, 0);
                            }
                            {
#line 286
                            printf((char const   */* __restrict  */)"</span>\n");
                            }
                            }
                          }
                        } else {
                          {
                          {
#line 278
                          printf((char const   */* __restrict  */)"<span class=\"%s\">",
                                 b->element_name);
                          }
                          {
#line 279
                          get_paratype___2(b->child, verbatim);
                          }
                          {
#line 280
                          printf((char const   */* __restrict  */)"</span>\n");
                          }
                          }
                        }
                      } else {
                        {
                        {
#line 278
                        printf((char const   */* __restrict  */)"<span class=\"%s\">",
                               b->element_name);
                        }
                        {
#line 279
                        get_paratype___2(b->child, verbatim);
                        }
                        {
#line 280
                        printf((char const   */* __restrict  */)"</span>\n");
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 278
                      printf((char const   */* __restrict  */)"<span class=\"%s\">",
                             b->element_name);
                      }
                      {
#line 279
                      get_paratype___2(b->child, verbatim);
                      }
                      {
#line 280
                      printf((char const   */* __restrict  */)"</span>\n");
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 278
                    printf((char const   */* __restrict  */)"<span class=\"%s\">",
                           b->element_name);
                    }
                    {
#line 279
                    get_paratype___2(b->child, verbatim);
                    }
                    {
#line 280
                    printf((char const   */* __restrict  */)"</span>\n");
                    }
                    }
                  }
                } else {
                  {
                  {
#line 278
                  printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
                  }
                  {
#line 279
                  get_paratype___2(b->child, verbatim);
                  }
                  {
#line 280
                  printf((char const   */* __restrict  */)"</span>\n");
                  }
                  }
                }
              } else {
                {
                {
#line 278
                printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
                }
                {
#line 279
                get_paratype___2(b->child, verbatim);
                }
                {
#line 280
                printf((char const   */* __restrict  */)"</span>\n");
                }
                }
              }
            } else {
              {
              {
#line 278
              printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
              }
              {
#line 279
              get_paratype___2(b->child, verbatim);
              }
              {
#line 280
              printf((char const   */* __restrict  */)"</span>\n");
              }
              }
            }
          } else {
            {
            {
#line 278
            printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
            }
            {
#line 279
            get_paratype___2(b->child, verbatim);
            }
            {
#line 280
            printf((char const   */* __restrict  */)"</span>\n");
            }
            }
          }
        } else {
          {
          {
#line 278
          printf((char const   */* __restrict  */)"<span class=\"%s\">", b->element_name);
          }
          {
#line 279
          get_paratype___2(b->child, verbatim);
          }
          {
#line 280
          printf((char const   */* __restrict  */)"</span>\n");
          }
          }
        }
      }
    }
#line 314
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return (0);
}
}
#line 326 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int get_bookchapter___2(dxml_element *b , int paraenter ) 
{ 
  int labelt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 331
    if (! b) {
#line 331
      goto while_break;
    }
#line 333
    if ((unsigned int )b->element_type != 0U) {
      {
      {
#line 335
      exit(1);
      }
      }
    } else {
      {
      {
#line 337
      tmp___9 = strcasecmp("sect1", (char const   *)b->element_name);
      }
      }
#line 337
      if (tmp___9) {
        {
        {
#line 349
        tmp___8 = strcasecmp("sect2", (char const   *)b->element_name);
        }
        }
#line 349
        if (tmp___8) {
          {
          {
#line 362
          tmp___7 = strcasecmp("sect3", (char const   *)b->element_name);
          }
          }
#line 362
          if (tmp___7) {
            {
            {
#line 376
            tmp___6 = strcasecmp("title", (char const   *)b->element_name);
            }
            }
#line 376
            if (tmp___6) {
              {
              {
#line 379
              tmp___5 = get_bothtypes___2(b, 0);
              }
              }
#line 379
              if (! tmp___5) {
                {
                {
#line 382
                tmp___4 = strcasecmp("para", (char const   *)b->element_name);
                }
                }
#line 382
                if (tmp___4) {
                  {
                  {
#line 388
                  tmp___3 = strcasecmp("itemizedlist", (char const   *)b->element_name);
                  }
                  }
#line 388
                  if (tmp___3) {
                    {
                    {
#line 392
                    tmp___2 = strcasecmp("table", (char const   *)b->element_name);
                    }
                    }
#line 392
                    if (tmp___2) {
                      {
                      {
#line 398
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown tag: %s\n",
                              b->element_name);
                      }
                      {
#line 399
                      dxml_dump_element(b->child);
                      }
                      }
                    } else {
                      {
                      {
#line 394
                      get_table___2(b);
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 390
                    get_itemizedlist___2(b->child);
                    }
                    }
                  }
                } else {
#line 384
                  if (paraenter) {
                    {
                    {
#line 384
                    puts("<p>\n");
                    }
                    }
                  }
                  {
                  {
#line 385
                  get_paratype___2(b->child, 0);
                  }
                  }
#line 386
                  if (paraenter) {
                    {
                    {
#line 386
                    puts("</p>\n");
                    }
                    }
                  }
                }
              }
            }
          } else {
            {
            {
#line 364
            labelt = maybe_label_start___0(b);
            }
#line 365
            (counter_chapter[c_sect3]) ++;
            {
#line 365
            printf((char const   */* __restrict  */)"\n<h3 class=\"sect3\">%i.%i.%i.%i. ",
                   counter_chapter[c_chapter], counter_chapter[c_sect1], counter_chapter[c_sect2],
                   counter_chapter[c_sect3]);
            }
            {
#line 370
            clear_counter___0((int )(c_sect3 + 1));
            }
            {
#line 371
            tmp___1 = dxml_get_PCDATA_bysimplepath(b->child, "title");
            }
            {
#line 371
            convert_print___2((char const   *)tmp___1, 0);
            }
            {
#line 372
            printf((char const   */* __restrict  */)"</h3>\n\n");
            }
            {
#line 373
            maybe_label_end___0(labelt);
            }
            {
#line 374
            get_bookchapter___2(b->child, 1);
            }
            }
          }
        } else {
          {
          {
#line 351
          labelt = maybe_label_start___0(b);
          }
#line 352
          (counter_chapter[c_sect2]) ++;
          {
#line 352
          printf((char const   */* __restrict  */)"\n<h3 class=\"sect2\">%i.%i.%i. ",
                 counter_chapter[c_chapter], counter_chapter[c_sect1], counter_chapter[c_sect2]);
          }
          {
#line 356
          clear_counter___0((int )(c_sect2 + 1));
          }
          {
#line 357
          tmp___0 = dxml_get_PCDATA_bysimplepath(b->child, "title");
          }
          {
#line 357
          convert_print___2((char const   *)tmp___0, 0);
          }
          {
#line 358
          printf((char const   */* __restrict  */)"</h3>\n\n");
          }
          {
#line 359
          maybe_label_end___0(labelt);
          }
          {
#line 360
          get_bookchapter___2(b->child, 1);
          }
          }
        }
      } else {
        {
        {
#line 339
        labelt = maybe_label_start___0(b);
        }
#line 340
        (counter_chapter[c_sect1]) ++;
        {
#line 340
        printf((char const   */* __restrict  */)"\n<h3 class=\"sect1\">%i.%i. ", counter_chapter[c_chapter],
               counter_chapter[c_sect1]);
        }
        {
#line 343
        clear_counter___0((int )(c_sect1 + 1));
        }
        {
#line 344
        tmp = dxml_get_PCDATA_bysimplepath(b->child, "title");
        }
        {
#line 344
        convert_print___2((char const   *)tmp, 0);
        }
        {
#line 345
        printf((char const   */* __restrict  */)"</h3>\n\n");
        }
        {
#line 346
        maybe_label_end___0(labelt);
        }
        {
#line 347
        get_bookchapter___2(b->child, 1);
        }
        }
      }
    }
#line 402
    b = b->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return (0);
}
}
#line 410 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/db2html.c"
static int recursebook___2(dxml_element *b ) 
{ 
  dxml_element *tmp ;
  int labelt ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 414
  labelt = 0;
  {
#line 416
  tmp = dxml_get_element_byname(b, "chapter");
  }
  }
  {
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 416
    if (! tmp) {
#line 416
      goto while_break;
    }
    {
    {
#line 418
    labelt = maybe_label_start___0(tmp);
    }
#line 419
    (counter_chapter[c_chapter]) ++;
    {
#line 419
    printf((char const   */* __restrict  */)"\n<h2>%i. ", counter_chapter[c_chapter]);
    }
    {
#line 420
    clear_counter___0((int )(c_chapter + 1));
    }
    {
#line 421
    tmp___0 = dxml_get_PCDATA_bysimplepath(tmp->child, "title");
    }
    {
#line 421
    convert_print___2((char const   *)tmp___0, 0);
    }
    {
#line 422
    printf((char const   */* __restrict  */)"</h2>\n\n");
    }
    {
#line 423
    maybe_label_end___0(labelt);
    }
    {
#line 424
    get_bookchapter___2(tmp->child, 1);
    }
#line 416
    tmp = tmp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___8(dxml_attribute *a ) ;
#line 68 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void *mallocwm___8(int l ) 
{ 
  char *t ;
  void *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  tmp = malloc((size_t )l);
  }
#line 71
  t = (char *)tmp;
  }
#line 72
  if (! t) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory in initialize_element\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 77
  return ((void *)t);
}
}
#line 86 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skipwhitechars___8(FILE *f ) 
{ 
  int c ;

  {
  {
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    c = _IO_getc(f);
    }
    }
    {
#line 95
    if (c == 10) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 13) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 9) {
#line 95
      goto case_10;
    }
#line 95
    if (c == 32) {
#line 95
      goto case_10;
    }
#line 97
    if (c == -1) {
#line 97
      goto case_neg_1;
    }
#line 99
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 96
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 98
    return (1);
    switch_default: /* CIL Label */ 
    {
    {
#line 100
    ungetc(c, f);
    }
    }
#line 101
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int checkchar___8(int expect , FILE *f ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 113
  tmp = _IO_getc(f);
  }
#line 113
  c = tmp;
  }
#line 114
  if (c != expect) {
#line 116
    if (c == -1) {
      {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected end-of-file\n");
      }
      }
    } else {
      {
      {
#line 119
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Expected token \'%c\', but got \'%c\' instead \n",
              expect, c);
      }
      }
    }
#line 120
    return (1);
  }
#line 122
  return (0);
}
}
#line 130 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *initialize_element___8(void) 
{ 
  dxml_element *new_element ;
  void *tmp ;
  struct dxml_element *tmp___0 ;

  {
  {
  {
#line 133
  tmp = mallocwm___8((int )sizeof(dxml_element ));
  }
#line 133
  new_element = (dxml_element *)tmp;
#line 135
  new_element->element_name = (char *)((void *)0);
#line 136
  new_element->element_attribute = (dxml_attribute *)((void *)0);
#line 137
  tmp___0 = (struct dxml_element *)((void *)0);
#line 137
  new_element->next = tmp___0;
#line 137
  new_element->child = tmp___0;
#line 138
  new_element->element_type = (enum element_type )0;
  }
#line 140
  return (new_element);
}
}
#line 148 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static char *read_character_stream___8(FILE *f , char const   *stop_chars ) 
{ 
  int SINGLEBUFSIZ ;
  int currentbufsiz ;
  char *buf ;
  void *tmp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 151
  SINGLEBUFSIZ = 512;
#line 152
  currentbufsiz = SINGLEBUFSIZ;
  {
#line 153
  tmp = mallocwm___8(SINGLEBUFSIZ);
  }
#line 153
  buf = (char *)tmp;
#line 154
  i = 0;
#line 155
  c = 0;
  }
  {
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 157
    c = _IO_getc(f);
    }
    }
#line 157
    if (! (c != -1)) {
#line 157
      goto while_break;
    }
    {
    {
#line 159
    tmp___0 = strchr(stop_chars, c);
    }
    }
#line 159
    if (tmp___0) {
      {
      {
#line 161
      ungetc(c, f);
      }
      }
#line 162
      goto while_break;
    }
#line 164
    tmp___1 = i;
#line 164
    i ++;
#line 164
    *(buf + tmp___1) = (char )c;
#line 165
    if (i > currentbufsiz - 2) {
      {
#line 167
      currentbufsiz += SINGLEBUFSIZ;
      {
#line 167
      tmp___2 = realloc((void *)buf, (size_t )currentbufsiz);
      }
#line 167
      buf = (char *)tmp___2;
      }
#line 168
      if (! buf) {
        {
        {
#line 170
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory for realloc in %s %i\n",
                "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c",
                170);
        }
        }
#line 171
        return ((char *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  *(buf + i) = (char)0;
#line 176
  return (buf);
}
}
#line 184 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_PCDATA___8(FILE *f ) 
{ 
  dxml_element *new_element ;
  dxml_element *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 187
  tmp = initialize_element___8();
  }
#line 187
  new_element = tmp;
#line 188
  new_element->element_type = (enum element_type )1;
  {
#line 189
  tmp___0 = read_character_stream___8(f, "<>");
  }
#line 189
  new_element->element_name = tmp___0;
  }
#line 189
  if (! tmp___0) {
    {
    {
#line 191
    dxml_free_xml(new_element);
    }
    }
#line 192
    return ((dxml_element *)((void *)0));
  }
#line 194
  return (new_element);
}
}
#line 205 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_attribute *read_attribute___8(FILE *f ) 
{ 
  dxml_attribute *new_attribute ;
  void *tmp ;
  int c ;
  int startquote ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 208
  tmp = mallocwm___8((int )sizeof(dxml_attribute ));
  }
#line 208
  new_attribute = (dxml_attribute *)tmp;
#line 211
  tmp___0 = (char *)((void *)0);
#line 211
  new_attribute->attribute_data = tmp___0;
#line 211
  new_attribute->attribute_name = tmp___0;
#line 213
  new_attribute->next = (struct dxml_attribute *)((void *)0);
  {
#line 215
  tmp___1 = skipwhitechars___8(f);
  }
  }
#line 215
  if (tmp___1) {
#line 215
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 217
  c = _IO_getc(f);
  }
  {
#line 218
  ungetc(c, f);
  }
  }
#line 220
  if (c == 62) {
    {
    {
#line 223
    dxml_free_attrib___8(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  } else
#line 220
  if (c == 47) {
    {
    {
#line 223
    dxml_free_attrib___8(new_attribute);
    }
    }
#line 224
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 228
  tmp___2 = read_character_stream___8(f, "> /\t=");
  }
#line 228
  new_attribute->attribute_name = tmp___2;
  }
#line 228
  if (! tmp___2) {
    {
    {
#line 230
    dxml_free_attrib___8(new_attribute);
    }
    }
#line 231
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 235
  tmp___3 = checkchar___8('=', f);
  }
  }
#line 235
  if (tmp___3) {
    {
    {
#line 237
    dxml_free_attrib___8(new_attribute);
    }
    }
#line 238
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 242
  startquote = _IO_getc(f);
  }
  }
  {
#line 245
  if (startquote == 34) {
#line 245
    goto case_34;
  }
#line 248
  if (startquote == 39) {
#line 248
    goto case_39;
  }
#line 251
  goto switch_default;
  case_34: /* CIL Label */ 
  {
  {
#line 246
  new_attribute->attribute_data = read_character_stream___8(f, "\"");
  }
  }
#line 247
  goto switch_break;
  case_39: /* CIL Label */ 
  {
  {
#line 249
  new_attribute->attribute_data = read_character_stream___8(f, "\'");
  }
  }
#line 250
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error with startquote, needs to be \" or \'\n");
  }
  {
#line 253
  exit(1);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  tmp___4 = checkchar___8(startquote, f);
  }
  }
#line 255
  if (tmp___4) {
    {
    {
#line 257
    dxml_free_attrib___8(new_attribute);
    }
    }
#line 258
    return ((dxml_attribute *)((void *)0));
  }
  {
  {
#line 262
  new_attribute->next = read_attribute___8(f);
  }
  }
#line 265
  return (new_attribute);
}
}
#line 273 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_PI___8(FILE *f , int strict ) 
{ 
  int c ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 278
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    c = _IO_getc(f);
    }
    }
#line 278
    if (! (c != 62)) {
#line 278
      goto while_break;
    }
    {
#line 282
    if (c == -1) {
#line 282
      goto case_neg_1;
    }
#line 285
    if (c == 91) {
#line 285
      goto case_91;
    }
#line 291
    if (c == 60) {
#line 291
      goto case_60;
    }
#line 280
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
    {
#line 283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature EOF found reading PI\n");
    }
    }
#line 284
    return (1);
    case_91: /* CIL Label */ 
    {
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 287
      c = _IO_getc(f);
      }
      }
#line 287
      if (! (c != 93)) {
#line 287
        goto while_break___0;
      }
#line 288
      if (c == -1) {
#line 288
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 290
    goto switch_break;
    case_60: /* CIL Label */ 
#line 294
    if (strict) {
      {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"While reading PI, an extra < was encountered\n");
      }
      }
#line 297
      return (1);
    }
#line 300
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 305
  tmp = skipwhitechars___8(f);
  }
  }
#line 305
  if (tmp) {
#line 306
    return (1);
  }
#line 308
  return (0);
}
}
#line 316 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int skip_read_comment___8(FILE *f ) 
{ 
  int c ;
  int prev ;
  int prevprev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 320
  prev = 0;
#line 320
  prevprev = 0;
  {
#line 323
  c = _IO_getc(f);
  }
  }
#line 323
  if (c != 45) {
    {
    {
#line 325
    ungetc(c, f);
    }
    {
#line 326
    tmp = skip_read_PI___8(f, 0);
    }
    }
#line 326
    return (tmp);
  }
  {
  {
#line 328
  c = _IO_getc(f);
  }
  }
#line 328
  if (c != 45) {
    {
    {
#line 330
    ungetc(c, f);
    }
    {
#line 331
    tmp___0 = skip_read_PI___8(f, 0);
    }
    }
#line 331
    return (tmp___0);
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    c = _IO_getc(f);
    }
    }
#line 334
    if (! (c != -1)) {
#line 334
      goto while_break;
    }
#line 336
    if (prev == 45) {
#line 336
      if (prevprev == 45) {
#line 336
        if (c == 62) {
#line 337
          goto while_break;
        }
      }
    }
#line 338
    prevprev = prev;
#line 339
    prev = c;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 342
  tmp___1 = skipwhitechars___8(f);
  }
  }
#line 342
  if (tmp___1) {
#line 343
    return (1);
  }
#line 346
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static int read_element_start___8(FILE *f ) 
{ 
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
  {
#line 359
  c = _IO_getc(f);
  }
  }
#line 361
  if (c == 63) {
    {
    {
#line 363
    tmp___1 = skip_read_PI___8(f, 1);
    }
    }
#line 363
    if (tmp___1) {
#line 363
      tmp___0 = 2;
    } else {
#line 363
      tmp___0 = 0;
    }
#line 363
    return (tmp___0);
  }
#line 367
  if (c == 33) {
    {
    {
#line 369
    tmp___4 = skip_read_comment___8(f);
    }
    }
#line 369
    if (tmp___4) {
#line 369
      tmp___3 = 2;
    } else {
#line 369
      tmp___3 = 0;
    }
#line 369
    return (tmp___3);
  }
  {
  {
#line 373
  ungetc(c, f);
  }
  }
#line 374
  return (1);
}
}
#line 387 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static dxml_element *read_element___8(FILE *f ) 
{ 
  int c ;
  char *buf ;
  dxml_element *new_element ;
  dxml_element *tmp ;
  dxml_element *tmp_element ;
  dxml_element *current_element_bottom ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct dxml_element *tmp___3 ;
  struct dxml_element *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 393
  tmp = initialize_element___8();
  }
#line 393
  new_element = tmp;
#line 394
  current_element_bottom = (dxml_element *)((void *)0);
  {
#line 396
  tmp___0 = read_element_start___8(f);
  }
  }
  {
#line 398
  if (tmp___0 == 0) {
#line 398
    goto case_0;
  }
#line 401
  if (tmp___0 == 1) {
#line 401
    goto case_1;
  }
#line 403
  if (tmp___0 == 2) {
#line 403
    goto case_2;
  }
#line 396
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 399
  free((void *)new_element);
  }
  }
#line 400
  return ((dxml_element *)((void *)0));
  case_1: /* CIL Label */ 
#line 402
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading element failed due to possibly unclosed braces.\n");
  }
  }
#line 405
  return ((dxml_element *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 410
  tmp___1 = read_character_stream___8(f, "> /\t");
  }
#line 410
  new_element->element_name = tmp___1;
  }
#line 410
  if (! tmp___1) {
#line 412
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 414
  new_element->element_attribute = read_attribute___8(f);
  }
  {
#line 417
  c = _IO_getc(f);
  }
  }
#line 418
  if (c == -1) {
    {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected EOF found while parsing <%s\n",
            new_element->element_name);
    }
    }
#line 422
    return ((dxml_element *)((void *)0));
  }
#line 425
  if (c == 47) {
    {
    {
#line 427
    tmp___2 = checkchar___8('>', f);
    }
    }
#line 427
    if (tmp___2) {
      {
      {
#line 429
      free((void *)new_element->element_name);
      }
      {
#line 430
      dxml_free_attrib___8(new_element->element_attribute);
      }
      {
#line 431
      free((void *)new_element);
      }
      }
#line 432
      return ((dxml_element *)((void *)0));
    }
    {
    {
#line 436
    skipwhitechars___8(f);
    }
    }
#line 438
    return (new_element);
  }
  {
  {
#line 442
  skipwhitechars___8(f);
  }
  }
  {
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 445
    c = _IO_getc(f);
    }
    }
#line 446
    if (c == -1) {
      {
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected EOF\n");
      }
      }
#line 449
      return ((dxml_element *)((void *)0));
    } else
#line 451
    if (c == 60) {
      {
      {
#line 453
      c = _IO_getc(f);
      }
      }
#line 454
      if (c == 47) {
#line 455
        goto while_break;
      }
      {
      {
#line 456
      ungetc(c, f);
      }
      {
#line 457
      tmp_element = read_element___8(f);
      }
      }
    } else
#line 459
    if (c == 62) {
      {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unexpected > in document\n");
      }
      {
#line 463
      exit(1);
      }
      }
    } else {
      {
      {
#line 467
      ungetc(c, f);
      }
      {
#line 468
      tmp_element = read_PCDATA___8(f);
      }
      }
    }
#line 472
    if (tmp_element) {
#line 474
      if (new_element->child) {
#line 476
        tmp___3 = tmp_element;
#line 476
        current_element_bottom->next = tmp___3;
#line 476
        current_element_bottom = tmp___3;
      } else {
#line 481
        tmp___4 = tmp_element;
#line 481
        new_element->child = tmp___4;
#line 481
        current_element_bottom = tmp___4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 490
  buf = read_character_stream___8(f, "> \t\n\r");
  }
  {
#line 491
  tmp___5 = strcmp((char const   *)new_element->element_name, (char const   *)buf);
  }
  }
#line 491
  if (tmp___5) {
    {
    {
#line 493
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad element name, tag opened with %s and closed with %s\n",
            new_element->element_name, buf);
    }
    }
#line 496
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 498
  free((void *)buf);
  }
  {
#line 499
  skipwhitechars___8(f);
  }
  {
#line 500
  tmp___6 = checkchar___8('>', f);
  }
  }
#line 500
  if (tmp___6) {
    {
    {
#line 502
    dxml_free_xml(new_element);
    }
    }
#line 503
    return ((dxml_element *)((void *)0));
  }
  {
  {
#line 507
  skipwhitechars___8(f);
  }
  }
#line 511
  return (new_element);
}
}
#line 553 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/loadxml.c"
static void dxml_free_attrib___8(dxml_attribute *a ) 
{ 
  char *__cil_tmp2 ;

  {
#line 556
  if (! a) {
    {
    {
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"loadxml, internal error: a is NULL\n");
    }
    }
#line 559
    return;
  }
#line 562
  if (a->attribute_name) {
    {
    {
#line 563
    free((void *)a->attribute_name);
    }
    }
  }
#line 564
  if (a->attribute_data) {
    {
    {
#line 565
    free((void *)a->attribute_data);
    }
    }
  }
#line 566
  if (a->next) {
    {
    {
#line 567
    dxml_free_attrib___8(a->next);
    }
    }
  }
  {
  {
#line 568
  free((void *)a);
  }
  }
#line 569
  return;
}
}
#line 41 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
static void dump_one_info___2(dxml_element *e ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 44
  tmp = get_PCDATA_bysimplepath_i(e, "status");
  }
  {
#line 44
  tmp___0 = get_PCDATA_bysimplepath_i(e, "uid");
  }
  {
#line 44
  tmp___1 = get_PCDATA_bysimplepath_i(e, "name");
  }
  {
#line 44
  printf((char const   */* __restrict  */)"<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><tr> \n",
         tmp___1, tmp___0, "hidden", tmp);
  }
  }
#line 52
  return;
}
}
#line 54 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
static void process_file___0(char const   *filename ) 
{ 
  FILE *f ;
  FILE *tmp ;
  dxml_element *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 57
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 57
  f = tmp;
  {
#line 59
  tmp___0 = dxml_read_xml(f);
  }
  {
#line 61
  tmp___0 = dxml_get_element_byname(tmp___0, "data");
  }
  }
  {
  {
#line 61
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 61
    if (! tmp___0) {
#line 61
      goto while_break;
    }
    {
    {
#line 63
    dump_one_info___2(tmp___0->child);
    }
#line 61
    tmp___0 = tmp___0->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (tmp___0) {
    {
    {
#line 66
    dxml_free_xml(tmp___0);
    }
    }
  }
  {
  {
#line 68
  fclose(f);
  }
  }
#line 69
  return;
}
}
#line 72 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/mikilab.useraccount-parser.c"
static void dirlist___0(void) 
{ 
  DIR *dp ;
  struct dirent *ep ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 78
  dp = opendir("./");
  }
  }
#line 79
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
    {
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 81
      ep = readdir(dp);
      }
      }
#line 81
      if (! ep) {
#line 81
        goto while_break;
      }
      {
      {
#line 83
      tmp = strstr((char const   *)(ep->d_name), ".xml");
      }
      }
#line 83
      if (tmp) {
        {
        {
#line 84
        process_file___0((char const   *)(ep->d_name));
        }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 87
    closedir(dp);
    }
    }
  } else {
    {
    {
#line 90
    perror("Couldn\'t open the directory");
    }
    }
  }
#line 91
  return;
}
}
#line 26 "/home/wslee/benchmarks/textformat/dancer-xml-0.8.2.1/testmemleak.c"
static dxml_element *read_open___0(char const   *filename ) 
{ 
  FILE *f ;
  FILE *tmp ;
  dxml_element *e ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 29
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 29
  f = tmp;
  }
#line 32
  if (f) {
    {
    {
#line 34
    e = dxml_read_xml(f);
    }
    {
#line 35
    fclose(f);
    }
    }
#line 36
    return (e);
  } else {
#line 39
    return ((dxml_element *)((void *)0));
  }
}
}
