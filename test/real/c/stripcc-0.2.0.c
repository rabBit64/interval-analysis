/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/x86_64-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned long size_t;
#line 25 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.h"
struct ringbuf_t {
   char *buf ;
   int cap ;
   int idx ;
   int writed ;
};
#line 25 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.h"
struct list_t {
   struct list_t *next ;
   void *data ;
};
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_48 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_49 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_48 __wait_terminated ;
   struct __anonstruct___wait_stopped_49 __wait_stopped ;
};
#line 285 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
enum __anonenum_cur_section_51 {
    none = 0,
    strip_exts = 1,
    strip_dirs = 2,
    strip_files = 3,
    dont_strip_dirs = 4,
    dont_strip_files = 5
} ;
#line 407 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
struct logiline_t {
   char *linebuf ;
   size_t linebuf_size ;
   size_t linebuf_idx ;
   size_t phyline_count ;
   size_t phyline_idx[1024] ;
};
#line 1250 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
struct cc_used_t {
   int flags ;
   struct list_t *used_branch ;
};
#line 1422 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
union __anonunion_52 {
   int __in ;
   int __i ;
};
#line 1422 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 2063 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 2063 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 32 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.h"
struct ringbuf_t *ringbuf_new(int capacity ) ;
#line 33
void ringbuf_clear(struct ringbuf_t *rbuf ) ;
#line 34
void ringbuf_write(struct ringbuf_t *rbuf , void const   *data , int len ) ;
#line 35
int ringbuf_read_last(struct ringbuf_t *rbuf , void *buf , int len ) ;
#line 36
void ringbuf_free(struct ringbuf_t *rbuf ) ;
#line 29 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.c"
struct ringbuf_t *ringbuf_new(int capacity ) 
{ 
  struct ringbuf_t *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 34
  tmp = malloc(sizeof(struct ringbuf_t ));
  }
#line 34
  ret = (struct ringbuf_t *)tmp;
  }
#line 35
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 36
    return ((struct ringbuf_t *)((void *)0));
  }
  {
  {
#line 37
  tmp___0 = malloc((size_t )capacity);
  }
#line 37
  ret->buf = (char *)tmp___0;
  }
#line 38
  if ((unsigned long )ret->buf == (unsigned long )((void *)0)) {
    {
    {
#line 39
    free((void *)ret);
    }
    }
#line 40
    return ((struct ringbuf_t *)((void *)0));
  }
#line 42
  ret->cap = capacity;
#line 43
  ret->idx = 0;
#line 44
  ret->writed = 0;
#line 46
  return (ret);
}
}
#line 49 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.c"
void ringbuf_clear(struct ringbuf_t *rbuf ) 
{ 


  {
#line 52
  rbuf->idx = 0;
#line 53
  rbuf->writed = 0;
#line 54
  return;
}
}
#line 56 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.c"
void ringbuf_write(struct ringbuf_t *rbuf , void const   *data , int len ) 
{ 
  int rest ;
  size_t tmp ;

  {
#line 61
  if (len == -1) {
    {
    {
#line 63
    tmp = strlen((char const   *)((char *)data));
    }
#line 63
    len = (int )tmp;
    }
  }
#line 65
  if (len > rbuf->cap) {
#line 67
    data = (data + len) - rbuf->cap;
#line 68
    len = rbuf->cap;
  }
#line 70
  rest = rbuf->cap - rbuf->idx;
#line 71
  if (len >= rest) {
    {
    {
#line 73
    memcpy((void */* __restrict  */)(rbuf->buf + rbuf->idx), (void const   */* __restrict  */)data,
           (size_t )rest);
    }
#line 74
    rbuf->idx = 0;
#line 75
    rbuf->writed += rest;
#line 77
    data += rest;
#line 78
    len -= rest;
    }
  }
#line 80
  if (len > 0) {
    {
    {
#line 81
    memcpy((void */* __restrict  */)(rbuf->buf + rbuf->idx), (void const   */* __restrict  */)data,
           (size_t )len);
    }
#line 82
    rbuf->idx += len;
#line 83
    rbuf->writed += len;
    }
  }
#line 85
  return;
}
}
#line 87 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.c"
int ringbuf_read_last(struct ringbuf_t *rbuf , void *buf , int len ) 
{ 
  int ret_len ;
  int part1_len ;

  {
#line 92
  if (rbuf->writed > rbuf->cap) {
#line 93
    ret_len = rbuf->cap;
  } else {
#line 95
    ret_len = rbuf->writed;
  }
#line 96
  if (ret_len > len) {
#line 97
    ret_len = len;
  }
#line 99
  part1_len = ret_len - rbuf->idx;
#line 100
  if (part1_len > 0) {
    {
    {
#line 101
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)((rbuf->buf + rbuf->cap) - part1_len),
           (size_t )part1_len);
    }
#line 102
    buf += part1_len;
    {
#line 103
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)rbuf->buf,
           (size_t )rbuf->idx);
    }
    }
  } else {
    {
    {
#line 105
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)((rbuf->buf + rbuf->idx) - ret_len),
           (size_t )ret_len);
    }
    }
  }
#line 107
  return (ret_len);
}
}
#line 110 "/home/wslee/tests/SOURCES/stripcc-0.2.0/ringbuf.c"
void ringbuf_free(struct ringbuf_t *rbuf ) 
{ 


  {
  {
  {
#line 113
  free((void *)rbuf->buf);
  }
  {
#line 114
  free((void *)rbuf);
  }
  }
#line 115
  return;
}
}
#line 33 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.h"
void list_free(struct list_t *list , void (*nfree)(struct list_t * ) ) ;
#line 34
struct list_t *sorted_list_insert_item(struct list_t *list , struct list_t *item ,
                                       int (*dcmp)(void const   *list_data , void const   *data ) ) ;
#line 36
struct list_t *sorted_list_remove_and_free_item_by_data(struct list_t *list , void const   *data ,
                                                        int (*dcmp)(void const   *list_data ,
                                                                    void const   *data ) ,
                                                        void (*nfree)(struct list_t * ) ) ;
#line 40
struct list_t *list_prepend_item_by_data(struct list_t *list , void const   *data ) ;
#line 41
struct list_t *list_search_item_by_data(struct list_t *list , void const   *data ) ;
#line 29 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.c"
void list_free(struct list_t *list , void (*nfree)(struct list_t * ) ) 
{ 
  struct list_t *tmp ;

  {
#line 34
  tmp = list;
  {
  {
#line 35
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 35
      goto while_break;
    }
    {
#line 36
    list = list->next;
    {
#line 38
    (*nfree)(tmp);
    }
#line 40
    tmp = list;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return;
}
}
#line 44 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.c"
struct list_t *sorted_list_insert_item(struct list_t *list , struct list_t *item ,
                                       int (*dcmp)(void const   *list_data , void const   *data ) ) 
{ 
  struct list_t *tmp ;
  struct list_t *prev ;
  int ret ;

  {
#line 50
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 51
    item->next = (struct list_t *)((void *)0);
#line 52
    return (item);
  }
#line 55
  tmp = list;
#line 56
  prev = (struct list_t *)((void *)0);
  {
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 57
      goto while_break;
    }
    {
    {
#line 58
    ret = (*dcmp)((void const   *)tmp->data, (void const   *)item->data);
    }
    }
#line 59
    if (ret > 0) {
#line 61
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 63
        item->next = list;
#line 64
        return (item);
      } else {
#line 66
        item->next = tmp;
#line 67
        prev->next = item;
#line 68
        return (list);
      }
    } else
#line 70
    if (ret == 0) {
#line 72
      return ((struct list_t *)((void *)0));
    }
#line 75
    prev = tmp;
#line 76
    tmp = tmp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  item->next = (struct list_t *)((void *)0);
#line 80
  prev->next = item;
#line 81
  return (list);
}
}
#line 84 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.c"
struct list_t *sorted_list_remove_and_free_item_by_data(struct list_t *list , void const   *data ,
                                                        int (*dcmp)(void const   *list_data ,
                                                                    void const   *data ) ,
                                                        void (*nfree)(struct list_t * ) ) 
{ 
  struct list_t *tmp ;
  struct list_t *prev ;
  int ret ;

  {
#line 92
  tmp = list;
#line 93
  prev = (struct list_t *)((void *)0);
  {
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 94
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 94
      goto while_break;
    }
    {
    {
#line 95
    ret = (*dcmp)((void const   *)tmp->data, data);
    }
    }
#line 96
    if (ret == 0) {
#line 98
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
        {
#line 99
        list = tmp->next;
        {
#line 100
        (*nfree)(tmp);
        }
        }
#line 101
        return (list);
      } else {
        {
#line 103
        prev->next = tmp->next;
        {
#line 104
        (*nfree)(tmp);
        }
        }
#line 105
        return (list);
      }
    }
#line 109
    prev = tmp;
#line 110
    tmp = tmp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (list);
}
}
#line 116 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.c"
struct list_t *list_prepend_item_by_data(struct list_t *list , void const   *data ) 
{ 
  struct list_t *rets ;
  void *tmp ;

  {
  {
  {
#line 121
  tmp = malloc(sizeof(struct list_t ));
  }
#line 121
  rets = (struct list_t *)tmp;
  }
#line 122
  if ((unsigned long )rets == (unsigned long )((void *)0)) {
#line 123
    return ((struct list_t *)((void *)0));
  }
#line 124
  rets->next = list;
#line 125
  rets->data = (void *)data;
#line 126
  return (rets);
}
}
#line 129 "/home/wslee/tests/SOURCES/stripcc-0.2.0/list.c"
struct list_t *list_search_item_by_data(struct list_t *list , void const   *data ) 
{ 


  {
  {
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 132
    if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 132
      goto while_break;
    }
#line 133
    if ((unsigned long )list->data == (unsigned long )data) {
#line 134
      return (list);
    }
#line 136
    list = list->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return ((struct list_t *)((void *)0));
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 157
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 283
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 173
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 286
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 312
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 441
extern unsigned int sleep(unsigned int __seconds ) ;
#line 493
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 507
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 568
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execl)(char const   *__path ,
                                                                                  char const   *__arg 
                                                                                  , ...) ;
#line 598
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 806
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 73
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 263 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 139
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 78 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void show_help(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 81
  printf((char const   */* __restrict  */)"Usage: stripcc <option(s)>\nRemove CCs(Conditional Compilation Branchs) which won\'t be compiled from c/c++ source files under current directory.\n The options are:\n  -c <str> Commands for build target program, \"make\" is default\n  -m <str> Directory to run build commands, current directory is default\n  -f       Working in fast mode (Experimental, NOT RECOMMENDED!)\n  -n       Don\'t verify after strip\n  -v       Display this program\'s version number\n  -h       Display this output\n");
  }
  }
#line 90
  return;
}
}
#line 92 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void show_ver(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 95
  printf((char const   */* __restrict  */)"stripcc 0.2.0 20081212\nCopyright 2007-2008 Du XiaoGang <dugang@188.com>\nModified By harite <harite.k@gmail.com>\nThis program is free software; you may redistribute it under the terms of\nthe GNU General Public License.  This program has absolutely no warranty.\n");
  }
  }
#line 100
  return;
}
}
#line 102 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void item_free(struct list_t *item ) 
{ 


  {
  {
  {
#line 105
  free(item->data);
  }
  {
#line 106
  free((void *)item);
  }
  }
#line 107
  return;
}
}
#line 109 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static struct list_t *_list_need_strip_files(struct list_t *exts , struct list_t *dirs ,
                                             struct list_t *files , struct list_t *exc_dirs ,
                                             struct list_t *exc_files ) 
{ 
  DIR *dir ;
  struct dirent *entry ;
  char path[4096] ;
  char *p ;
  int ret ;
  int len ;
  int ever_found ;
  struct stat st ;
  struct list_t *item ;
  struct list_t *ext ;
  struct list_t *rets_tmp ;
  struct list_t *prev ;
  struct list_t *rets ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 120
  rets = (struct list_t *)((void *)0);
  {
  {
#line 123
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 123
    if (! ((unsigned long )dirs != (unsigned long )((void *)0))) {
#line 123
      goto while_break;
    }
    {
    {
#line 125
    dir = opendir((char const   *)dirs->data);
    }
    }
#line 126
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
      {
      {
#line 127
      tmp = __errno_location();
      }
      {
#line 127
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mFailed to open directory(%s), errno = %d.\n",
              (char *)dirs->data, *tmp);
      }
      {
#line 129
      exit(1);
      }
      }
    }
    {
    {
#line 132
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 132
      entry = readdir(dir);
      }
      }
#line 132
      if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 132
        goto while_break___0;
      }
      {
      {
#line 133
      tmp___0 = strcmp((char const   *)(entry->d_name), ".");
      }
      }
#line 133
      if (tmp___0 == 0) {
#line 135
        goto while_continue___0;
      } else {
        {
        {
#line 133
        tmp___1 = strcmp((char const   *)(entry->d_name), "..");
        }
        }
#line 133
        if (tmp___1 == 0) {
#line 135
          goto while_continue___0;
        }
      }
      {
#line 138
      p = (char *)dirs->data;
      {
#line 139
      tmp___2 = strlen((char const   *)p);
      }
      }
#line 139
      if ((int )*(p + (tmp___2 - 1UL)) == 47) {
        {
        {
#line 140
        ret = snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s%s",
                       (char *)dirs->data, entry->d_name);
        }
        }
      } else {
        {
        {
#line 143
        ret = snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s",
                       (char *)dirs->data, entry->d_name);
        }
        }
      }
#line 146
      if ((unsigned long )ret >= sizeof(path)) {
        {
        {
#line 147
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mPath or file name is too long.\n");
        }
        {
#line 148
        exit(1);
        }
        }
      }
      {
      {
#line 150
      tmp___4 = lstat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& st));
      }
      }
#line 150
      if (tmp___4 == -1) {
        {
        {
#line 151
        while (1) {
          while_continue___15: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
          {
          {
#line 151
          tmp___3 = __errno_location();
          }
          {
#line 151
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 151, *tmp___3);
          }
          {
#line 151
          exit(1);
          }
          }
#line 151
          goto while_break___1;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 153
      if ((st.st_mode & 61440U) == 16384U) {
        {
        {
#line 155
        tmp___5 = malloc(sizeof(struct list_t ));
        }
#line 155
        item = (struct list_t *)tmp___5;
        }
#line 156
        if ((unsigned long )item == (unsigned long )((void *)0)) {
          {
          {
#line 157
          while (1) {
            while_continue___16: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
            {
            {
#line 157
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
            }
            {
#line 157
            exit(1);
            }
            }
#line 157
            goto while_break___2;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
        {
#line 158
        tmp___6 = strdup((char const   *)(path));
        }
#line 158
        item->data = (void *)tmp___6;
        }
#line 159
        if ((unsigned long )item->data == (unsigned long )((void *)0)) {
          {
          {
#line 160
          while (1) {
            while_continue___17: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
            {
            {
#line 160
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
            }
            {
#line 160
            exit(1);
            }
            }
#line 160
            goto while_break___3;
          }
          while_break___17: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 162
        item->next = dirs->next;
#line 163
        dirs->next = item;
      } else
#line 164
      if ((st.st_mode & 61440U) == 32768U) {
        {
        {
#line 166
        p = strrchr((char const   *)(path), '.');
        }
        }
#line 167
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 168
          goto while_continue___0;
        }
#line 169
        ext = exts;
        {
        {
#line 170
        while (1) {
          while_continue___18: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 170
          if (! ((unsigned long )ext != (unsigned long )((void *)0))) {
#line 170
            goto while_break___4;
          }
          {
          {
#line 171
          tmp___7 = strcmp((char const   *)p, (char const   *)((char *)ext->data));
          }
          }
#line 171
          if (tmp___7 == 0) {
#line 172
            goto while_break___4;
          }
#line 174
          ext = ext->next;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 176
        if ((unsigned long )ext == (unsigned long )((void *)0)) {
#line 177
          goto while_continue___0;
        }
        {
        {
#line 179
        tmp___8 = malloc(sizeof(struct list_t ));
        }
#line 179
        item = (struct list_t *)tmp___8;
        }
#line 180
        if ((unsigned long )item == (unsigned long )((void *)0)) {
          {
          {
#line 181
          while (1) {
            while_continue___19: /* CIL Label */ ;
            while_continue___5: /* CIL Label */ ;
            {
            {
#line 181
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
            }
            {
#line 181
            exit(1);
            }
            }
#line 181
            goto while_break___5;
          }
          while_break___19: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
        {
        {
#line 182
        tmp___9 = strdup((char const   *)(path));
        }
#line 182
        item->data = (void *)tmp___9;
        }
#line 183
        if ((unsigned long )item->data == (unsigned long )((void *)0)) {
          {
          {
#line 184
          while (1) {
            while_continue___20: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
            {
            {
#line 184
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
            }
            {
#line 184
            exit(1);
            }
            }
#line 184
            goto while_break___6;
          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
        {
        {
#line 186
        rets_tmp = sorted_list_insert_item(rets, item, (int (*)(void const   *list_data ,
                                                                void const   *data ))(& strcmp));
        }
        }
#line 187
        if ((unsigned long )rets_tmp == (unsigned long )((void *)0)) {
          {
          {
#line 189
          free(item->data);
          }
          {
#line 190
          free((void *)item);
          }
          }
        } else {
#line 192
          rets = rets_tmp;
        }
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 196
    closedir(dir);
    }
#line 198
    dirs = dirs->next;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 202
  while (1) {
    while_continue___21: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 202
    if (! ((unsigned long )exc_dirs != (unsigned long )((void *)0))) {
#line 202
      goto while_break___7;
    }
    {
    {
#line 203
    tmp___10 = strlen((char const   *)((char *)exc_dirs->data));
    }
#line 203
    len = (int )tmp___10;
#line 205
    item = rets;
#line 206
    prev = (struct list_t *)((void *)0);
#line 207
    ever_found = 0;
    }
    {
    {
#line 208
    while (1) {
      while_continue___22: /* CIL Label */ ;
      while_continue___8: /* CIL Label */ ;
#line 208
      if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 208
        goto while_break___8;
      }
      {
      {
#line 209
      ret = strncmp((char const   *)((char *)item->data), (char const   *)((char *)exc_dirs->data),
                    (size_t )len);
      }
      }
#line 210
      if (ret == 0) {
#line 210
        if ((int )*((char *)item->data + len) == 47) {
#line 211
          ever_found = 1;
#line 213
          if ((unsigned long )prev == (unsigned long )((void *)0)) {
            {
#line 214
            rets = item->next;
            {
#line 215
            item_free(item);
            }
#line 217
            item = rets;
            }
#line 218
            goto while_continue___8;
          } else {
            {
#line 220
            prev->next = item->next;
            {
#line 221
            item_free(item);
            }
#line 223
            item = prev->next;
            }
#line 224
            goto while_continue___8;
          }
        } else {
#line 210
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 227
      if (ever_found) {
#line 229
        goto while_break___8;
      }
#line 233
      prev = item;
#line 234
      item = item->next;
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 237
    exc_dirs = exc_dirs->next;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
  {
#line 241
  while (1) {
    while_continue___23: /* CIL Label */ ;
    while_continue___9: /* CIL Label */ ;
#line 241
    if (! ((unsigned long )files != (unsigned long )((void *)0))) {
#line 241
      goto while_break___9;
    }
    {
    {
#line 243
    tmp___11 = malloc(sizeof(struct list_t ));
    }
#line 243
    item = (struct list_t *)tmp___11;
    }
#line 244
    if ((unsigned long )item == (unsigned long )((void *)0)) {
      {
      {
#line 245
      while (1) {
        while_continue___24: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
        {
        {
#line 245
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
        }
        {
#line 245
        exit(1);
        }
        }
#line 245
        goto while_break___10;
      }
      while_break___24: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    {
    {
#line 246
    tmp___12 = strdup((char const   *)((char *)files->data));
    }
#line 246
    item->data = (void *)tmp___12;
    }
#line 247
    if ((unsigned long )item->data == (unsigned long )((void *)0)) {
      {
      {
#line 248
      while (1) {
        while_continue___25: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
        {
        {
#line 248
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
        }
        {
#line 248
        exit(1);
        }
        }
#line 248
        goto while_break___11;
      }
      while_break___25: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    {
    {
#line 250
    rets_tmp = sorted_list_insert_item(rets, item, (int (*)(void const   *list_data ,
                                                            void const   *data ))(& strcmp));
    }
    }
#line 251
    if ((unsigned long )rets_tmp == (unsigned long )((void *)0)) {
      {
      {
#line 253
      free(item->data);
      }
      {
#line 254
      free((void *)item);
      }
      }
    } else {
#line 256
      rets = rets_tmp;
    }
#line 259
    files = files->next;
  }
  while_break___23: /* CIL Label */ ;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
  {
#line 263
  while (1) {
    while_continue___26: /* CIL Label */ ;
    while_continue___12: /* CIL Label */ ;
#line 263
    if (! ((unsigned long )exc_files != (unsigned long )((void *)0))) {
#line 263
      goto while_break___12;
    }
    {
    {
#line 265
    rets = sorted_list_remove_and_free_item_by_data(rets, (void const   *)exc_files->data,
                                                    (int (*)(void const   *list_data ,
                                                             void const   *data ))(& strcmp),
                                                    & item_free);
    }
#line 270
    exc_files = exc_files->next;
    }
  }
  while_break___26: /* CIL Label */ ;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 273
  return (rets);
}
}
#line 276 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static struct list_t *list_need_strip_files(void) 
{ 
  FILE *fp ;
  int lineno ;
  char linebuf[4096] ;
  char *p ;
  char *q ;
  struct list_t *item ;
  struct list_t *rets ;
  struct list_t exts_c ;
  struct list_t exts_h ;
  struct list_t dir_cwd ;
  enum __anonenum_cur_section_51 cur_section ;
  struct list_t *exts ;
  struct list_t *dirs ;
  struct list_t *files ;
  struct list_t *exc_dirs ;
  struct list_t *exc_files ;
  struct list_t *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
  {
#line 284
  exts_c.next = (struct list_t *)((void *)0);
#line 284
  exts_c.data = (void *)".c";
#line 284
  exts_h.next = & exts_c;
#line 284
  exts_h.data = (void *)".h";
#line 284
  dir_cwd.next = (struct list_t *)((void *)0);
#line 284
  dir_cwd.data = (void *)".";
#line 285
  cur_section = (enum __anonenum_cur_section_51 )0;
#line 293
  exts = (struct list_t *)((void *)0);
#line 293
  dirs = (struct list_t *)((void *)0);
#line 293
  files = (struct list_t *)((void *)0);
#line 293
  exc_dirs = (struct list_t *)((void *)0);
#line 293
  exc_files = (struct list_t *)((void *)0);
  {
#line 296
  fp = fopen((char const   */* __restrict  */)"./stripcc.conf", (char const   */* __restrict  */)"r");
  }
  }
#line 297
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 298
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mFailed to open config file(%s), use the default values.\n",
            "./stripcc.conf");
    }
    {
#line 300
    tmp = _list_need_strip_files(& exts_h, & dir_cwd, (struct list_t *)((void *)0),
                                 (struct list_t *)((void *)0), (struct list_t *)((void *)0));
    }
    }
#line 300
    return (tmp);
  }
#line 304
  lineno = 0;
  {
  {
#line 305
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 305
    tmp___10 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
    }
    }
#line 305
    if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 305
      goto while_break;
    }
    {
#line 306
    lineno ++;
    {
#line 308
    tmp___0 = strlen((char const   *)(linebuf));
    }
    }
#line 308
    if (tmp___0 == sizeof(linebuf) - 1UL) {
#line 308
      if ((int )linebuf[sizeof(linebuf) - 2UL] != 10) {
        {
        {
#line 311
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mThe config line(%s: %d) is too long to parse.\n",
                "./stripcc.conf", lineno);
        }
        {
#line 313
        exit(1);
        }
        }
      }
    }
    {
#line 316
    p = linebuf;
    {
#line 317
    tmp___1 = strspn((char const   *)p, " \t");
    }
#line 317
    p += tmp___1;
    }
#line 318
    if ((int )*p == 13) {
#line 319
      goto while_continue;
    } else
#line 318
    if ((int )*p == 10) {
#line 319
      goto while_continue;
    } else
#line 318
    if ((int )*p == 0) {
#line 319
      goto while_continue;
    }
#line 321
    if ((int )*p == 35) {
#line 322
      goto while_continue;
    }
#line 324
    if ((int )*p == 91) {
      {
      {
#line 326
      q = strpbrk((char const   *)p, " \t\r\n");
      }
      }
#line 327
      if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 328
        *q = (char )'\000';
      }
      {
      {
#line 329
      tmp___6 = strcmp((char const   *)p, "[strip_exts]");
      }
      }
#line 329
      if (tmp___6 == 0) {
#line 330
        cur_section = (enum __anonenum_cur_section_51 )1;
      } else {
        {
        {
#line 331
        tmp___5 = strcmp((char const   *)p, "[strip_dirs]");
        }
        }
#line 331
        if (tmp___5 == 0) {
#line 332
          cur_section = (enum __anonenum_cur_section_51 )2;
        } else {
          {
          {
#line 333
          tmp___4 = strcmp((char const   *)p, "[strip_files]");
          }
          }
#line 333
          if (tmp___4 == 0) {
#line 334
            cur_section = (enum __anonenum_cur_section_51 )3;
          } else {
            {
            {
#line 335
            tmp___3 = strcmp((char const   *)p, "[dont_strip_dirs]");
            }
            }
#line 335
            if (tmp___3 == 0) {
#line 336
              cur_section = (enum __anonenum_cur_section_51 )4;
            } else {
              {
              {
#line 337
              tmp___2 = strcmp((char const   *)p, "[dont_strip_files]");
              }
              }
#line 337
              if (tmp___2 == 0) {
#line 338
                cur_section = (enum __anonenum_cur_section_51 )5;
              }
            }
          }
        }
      }
    } else {
      {
      {
#line 343
      tmp___7 = strlen((char const   *)p);
      }
#line 343
      q = p + tmp___7;
      }
      {
      {
#line 344
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 345
        q --;
#line 344
        if (! ((int )*q == 32)) {
#line 344
          if (! ((int )*q == 9)) {
#line 344
            if (! ((int )*q == 13)) {
#line 344
              if (! ((int )*q == 10)) {
#line 344
                goto while_break___0;
              }
            }
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 347
      q ++;
#line 347
      *q = (char )'\000';
      {
#line 349
      tmp___8 = malloc(sizeof(struct list_t ));
      }
#line 349
      item = (struct list_t *)tmp___8;
      }
#line 350
      if ((unsigned long )item == (unsigned long )((void *)0)) {
        {
        {
#line 351
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
          {
          {
#line 351
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
          }
          {
#line 351
          exit(1);
          }
          }
#line 351
          goto while_break___1;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
      {
#line 352
      tmp___9 = strdup((char const   *)p);
      }
#line 352
      item->data = (void *)tmp___9;
      }
#line 353
      if ((unsigned long )item->data == (unsigned long )((void *)0)) {
        {
        {
#line 354
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
          {
          {
#line 354
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
          }
          {
#line 354
          exit(1);
          }
          }
#line 354
          goto while_break___2;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 356
      if ((unsigned int )cur_section == 1U) {
#line 357
        item->next = exts;
#line 358
        exts = item;
      } else
#line 359
      if ((unsigned int )cur_section == 2U) {
#line 360
        item->next = dirs;
#line 361
        dirs = item;
      } else
#line 362
      if ((unsigned int )cur_section == 3U) {
#line 363
        item->next = files;
#line 364
        files = item;
      } else
#line 365
      if ((unsigned int )cur_section == 4U) {
#line 366
        item->next = exc_dirs;
#line 367
        exc_dirs = item;
      } else
#line 368
      if ((unsigned int )cur_section == 5U) {
#line 369
        item->next = exc_files;
#line 370
        exc_files = item;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 374
  fclose(fp);
  }
  {
#line 376
  rets = _list_need_strip_files(exts, dirs, files, exc_dirs, exc_files);
  }
  {
#line 377
  list_free(exts, & item_free);
  }
  {
#line 378
  list_free(dirs, & item_free);
  }
  {
#line 379
  list_free(files, & item_free);
  }
  {
#line 380
  list_free(exc_dirs, & item_free);
  }
  {
#line 381
  list_free(exc_files, & item_free);
  }
  }
#line 382
  return (rets);
}
}
#line 385 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void backup_files(struct list_t *file_list ) 
{ 
  int ret ;
  char path[4096] ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 392
    if (! ((unsigned long )file_list != (unsigned long )((void *)0))) {
#line 392
      goto while_break;
    }
    {
    {
#line 394
    ret = snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s.%s",
                   (char *)file_list->data, "eecbfb859094a362907dfb2f2cd3a8c8");
    }
    }
#line 395
    if ((unsigned long )ret >= sizeof(path)) {
      {
      {
#line 396
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mPath or file name is too long.\n");
      }
      {
#line 397
      exit(1);
      }
      }
    }
    {
    {
#line 399
    unlink((char const   *)(path));
    }
    {
#line 400
    tmp___0 = link((char const   *)((char *)file_list->data), (char const   *)(path));
    }
    }
#line 400
    if (tmp___0 == -1) {
      {
      {
#line 401
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 401
        tmp = __errno_location();
        }
        {
#line 401
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 401, *tmp);
        }
        {
#line 401
        exit(1);
        }
        }
#line 401
        goto while_break___0;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 403
    file_list = file_list->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return;
}
}
#line 415 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int is_unterminate_line(char const   *line ) 
{ 
  int i ;
  int len ;
  size_t tmp ;

  {
  {
  {
#line 421
  tmp = strlen(line);
  }
#line 421
  len = (int )tmp;
  }
#line 422
  if ((int const   )*(line + (len - 1)) != 10) {
#line 423
    return (0);
  }
#line 424
  i = len - 2;
  {
  {
#line 424
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 424
    if (! (i >= 0)) {
#line 424
      goto while_break;
    }
#line 425
    if ((int const   )*(line + i) == 92) {
#line 426
      return (1);
    } else
#line 427
    if (! ((int const   )*(line + i) == 32)) {
#line 427
      if ((int const   )*(line + i) == 9) {
#line 429
        goto __Cont;
      } else
#line 427
      if (! ((int const   )*(line + i) == 13)) {
#line 431
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 424
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  return (0);
}
}
#line 438 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static struct logiline_t *build_logiline(struct logiline_t *logiline , char const   *phyline ) 
{ 
  int len ;
  int add ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 443
  if ((unsigned long )logiline == (unsigned long )((void *)0)) {
    {
    {
#line 445
    tmp = malloc(sizeof(struct logiline_t ));
    }
#line 445
    logiline = (struct logiline_t *)tmp;
    }
#line 446
    if ((unsigned long )logiline == (unsigned long )((void *)0)) {
      {
      {
#line 447
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 447
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
        }
        {
#line 447
        exit(1);
        }
        }
#line 447
        goto while_break;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 449
    logiline->linebuf_size = (size_t )16384;
    {
#line 450
    tmp___0 = strlen(phyline);
    }
#line 450
    len = (int )tmp___0;
    }
    {
    {
#line 451
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! (logiline->linebuf_size <= (size_t )len)) {
#line 451
        goto while_break___0;
      }
#line 452
      logiline->linebuf_size += 16384UL;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 453
    tmp___1 = malloc(logiline->linebuf_size);
    }
#line 453
    logiline->linebuf = (char *)tmp___1;
    }
#line 454
    if ((unsigned long )logiline->linebuf == (unsigned long )((void *)0)) {
      {
      {
#line 455
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 455
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
        }
        {
#line 455
        exit(1);
        }
        }
#line 455
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 456
    strcpy((char */* __restrict  */)logiline->linebuf, (char const   */* __restrict  */)phyline);
    }
#line 457
    logiline->linebuf_idx = (size_t )len;
#line 458
    logiline->phyline_count = (size_t )1;
#line 459
    logiline->phyline_idx[0] = (size_t )0;
    }
  } else {
    {
    {
#line 462
    tmp___2 = strlen(phyline);
    }
#line 462
    len = (int )tmp___2;
#line 463
    add = 0;
    }
    {
    {
#line 465
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 465
      if (! ((logiline->linebuf_size + (size_t )add) - logiline->linebuf_idx <= (size_t )len)) {
#line 465
        goto while_break___2;
      }
#line 466
      add += 16384;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 467
    if (add > 0) {
      {
      {
#line 468
      tmp___3 = realloc((void *)logiline->linebuf, logiline->linebuf_size + (size_t )add);
      }
#line 468
      logiline->linebuf = (char *)tmp___3;
      }
#line 470
      if ((unsigned long )logiline->linebuf == (unsigned long )((void *)0)) {
        {
        {
#line 471
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
          {
          {
#line 471
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
          }
          {
#line 471
          exit(1);
          }
          }
#line 471
          goto while_break___3;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 472
      logiline->linebuf_size += (size_t )add;
    }
    {
    {
#line 475
    strcat((char */* __restrict  */)logiline->linebuf, (char const   */* __restrict  */)phyline);
    }
#line 476
    (logiline->phyline_count) ++;
    }
#line 477
    if (logiline->phyline_count == 1024UL) {
      {
      {
#line 478
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mToo many physical line in a logical line.\n");
      }
      {
#line 479
      exit(1);
      }
      }
    }
#line 481
    logiline->phyline_idx[logiline->phyline_count - 1UL] = logiline->linebuf_idx;
#line 482
    logiline->linebuf_idx += (size_t )len;
  }
#line 484
  return (logiline);
}
}
#line 487 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int is_in_quote(char *line , char *pos ) 
{ 
  char c ;
  char *p ;
  char *q ;
  char *r ;
  int quotes_num ;

  {
#line 491
  quotes_num = 0;
#line 494
  c = *pos;
#line 495
  *pos = (char )'\000';
#line 497
  p = line;
  {
  {
#line 498
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 499
    q = strchr((char const   *)p, '\"');
    }
    }
#line 500
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 501
      goto while_break;
    }
#line 502
    if ((unsigned long )q == (unsigned long )p) {
#line 503
      quotes_num ++;
#line 505
      p = q + 1;
    } else
#line 508
    if ((int )*(q + -1) == 92) {
#line 510
      r = q + -1;
      {
      {
#line 511
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 511
        if ((unsigned long )r >= (unsigned long )p) {
#line 511
          if (! ((int )*r == 92)) {
#line 511
            goto while_break___0;
          }
        } else {
#line 511
          goto while_break___0;
        }
#line 512
        r --;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 513
      if (((q - 1) - r) % 2L == 0L) {
#line 514
        quotes_num ++;
      }
#line 515
      p = q + 1;
    } else
#line 516
    if ((int )*(q + -1) == 39) {
#line 516
      if ((int )*(q + 1) == 39) {
#line 518
        p = q + 2;
      } else {
#line 520
        quotes_num ++;
#line 522
        p = q + 1;
      }
    } else {
#line 520
      quotes_num ++;
#line 522
      p = q + 1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  *pos = c;
#line 528
  if (quotes_num % 2 == 0) {
#line 529
    return (0);
  } else {
#line 531
    return (1);
  }
}
}
#line 535 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static char *find_first_quote(char const   *str ) 
{ 
  char *p ;
  char *q ;
  char *r ;

  {
#line 540
  p = (char *)str;
  {
  {
#line 541
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 542
    q = strchr((char const   *)p, '\"');
    }
    }
#line 543
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 544
      return ((char *)((void *)0));
    }
#line 545
    if ((unsigned long )q == (unsigned long )p) {
#line 546
      return (q);
    } else
#line 549
    if ((int )*(q + -1) == 92) {
#line 551
      r = q + -1;
      {
      {
#line 552
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 552
        if ((unsigned long )r >= (unsigned long )p) {
#line 552
          if (! ((int )*r == 92)) {
#line 552
            goto while_break___0;
          }
        } else {
#line 552
          goto while_break___0;
        }
#line 553
        r --;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 554
      if (((q - 1) - r) % 2L == 0L) {
#line 555
        return (q);
      }
#line 556
      p = q + 1;
    } else
#line 557
    if ((int )*(q + -1) == 39) {
#line 557
      if ((int )*(q + 1) == 39) {
#line 558
        p = q + 2;
      } else {
#line 560
        return (q);
      }
    } else {
#line 560
      return (q);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return ((char *)((void *)0));
}
}
#line 576 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int get_line_type(char const   *line ) 
{ 
  char const   *p ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  size_t tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 582
  p = line;
  {
#line 583
  tmp = strspn(p, " \t");
  }
#line 583
  p += tmp;
  }
#line 584
  if ((int const   )*p == 35) {
    {
#line 585
    p ++;
    {
#line 586
    tmp___0 = strspn(p, " \t");
    }
#line 586
    p += tmp___0;
    {
#line 587
    tmp___4 = strncmp(p, "if", (size_t )2);
    }
    }
#line 587
    if (tmp___4 == 0) {
#line 589
      return (2);
    } else {
      {
      {
#line 590
      tmp___3 = strncmp(p, "elif", (size_t )4);
      }
      }
#line 590
      if (tmp___3 == 0) {
#line 592
        return (3);
      } else {
        {
        {
#line 593
        tmp___2 = strncmp(p, "else", (size_t )4);
        }
        }
#line 593
        if (tmp___2 == 0) {
#line 595
          return (4);
        } else {
          {
          {
#line 596
          tmp___1 = strncmp(p, "endif", (size_t )5);
          }
          }
#line 596
          if (tmp___1 == 0) {
#line 598
            return (5);
          } else {
#line 600
            return (6);
          }
        }
      }
    }
  }
  {
  {
#line 604
  tmp___5 = strstr(line, "main");
  }
#line 604
  p = (char const   *)tmp___5;
  }
#line 605
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 606
    return (0);
  }
#line 607
  if ((unsigned long )p > (unsigned long )line) {
    {
    {
#line 607
    tmp___6 = __ctype_b_loc();
    }
    }
#line 607
    if (! ((int const   )*(*tmp___6 + (int )*(p + -1)) & 8192)) {
#line 608
      return (0);
    }
  }
  {
#line 609
  p += 4;
  {
#line 610
  tmp___7 = strspn(p, " \t\r\n");
  }
#line 610
  p += tmp___7;
  }
#line 611
  if ((int const   )*p != 40) {
#line 611
    if ((int const   )*p != 0) {
#line 612
      return (0);
    }
  }
#line 613
  return (1);
}
}
#line 616 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void fputs2(char const   *s , FILE *stream ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 619
  tmp___0 = fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stream);
  }
  }
#line 619
  if (tmp___0 == -1) {
    {
    {
#line 620
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 620
      tmp = __errno_location();
      }
      {
#line 620
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 620, *tmp);
      }
      {
#line 620
      exit(1);
      }
      }
#line 620
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 621
  return;
}
}
#line 623 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void logiline_free(struct logiline_t *logiline ) 
{ 


  {
  {
  {
#line 626
  free((void *)logiline->linebuf);
  }
  {
#line 627
  free((void *)logiline);
  }
  }
#line 628
  return;
}
}
#line 630 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void discovered_main(struct list_t **main_list , char const   *path ) 
{ 
  struct list_t *item ;
  struct list_t *tmp_list ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 635
  tmp = malloc(sizeof(struct list_t ));
  }
#line 635
  item = (struct list_t *)tmp;
  }
#line 636
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
    {
#line 637
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 637
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
      }
      {
#line 637
      exit(1);
      }
      }
#line 637
      goto while_break;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 638
  tmp___0 = strdup(path);
  }
#line 638
  item->data = (void *)tmp___0;
  }
#line 639
  if ((unsigned long )item->data == (unsigned long )((void *)0)) {
    {
    {
#line 640
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 640
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
      }
      {
#line 640
      exit(1);
      }
      }
#line 640
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
  {
#line 642
  tmp_list = sorted_list_insert_item(*main_list, item, (int (*)(void const   *list_data ,
                                                                void const   *data ))(& strcmp));
  }
  }
#line 643
  if ((unsigned long )tmp_list == (unsigned long )((void *)0)) {
    {
    {
#line 645
    free(item->data);
    }
    {
#line 646
    free((void *)item);
    }
    }
  } else {
#line 648
    *main_list = tmp_list;
  }
#line 650
  return;
}
}
#line 652 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int add_warning_cc_to_files(struct list_t *file_list , int fast_mode , struct list_t **invalid_file_list ,
                                   struct list_t **main_list ) 
{ 
  FILE *sfp ;
  FILE *tfp ;
  struct logiline_t *logiline ;
  char *p ;
  char *q ;
  char *r ;
  char *s ;
  char *comment_begin ;
  char linebuf[4096] ;
  char *srcfile ;
  int cc_type ;
  int dont_output ;
  int comment_begin_in_this_line ;
  int whole_file_cc_id ;
  int cc_id[64] ;
  int cc_branch[64] ;
  int have_else[64] ;
  int cur_nest ;
  int lineno ;
  int is_in_comment ;
  int invalid_file ;
  int warning_cc_id ;
  struct list_t *item ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  int tmp___30 ;
  int *tmp___31 ;
  int tmp___32 ;
  int *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  int tmp___36 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  void *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;

  {
#line 659
  warning_cc_id = 0;
  {
  {
#line 664
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 664
    if (! ((unsigned long )file_list != (unsigned long )((void *)0))) {
#line 664
      goto while_break;
    }
    {
#line 666
    comment_begin = (char *)((void *)0);
#line 667
    cur_nest = 0;
#line 668
    lineno = 0;
#line 669
    is_in_comment = 0;
#line 670
    invalid_file = 0;
#line 673
    srcfile = (char *)file_list->data;
    {
#line 674
    sfp = fopen((char const   */* __restrict  */)srcfile, (char const   */* __restrict  */)"r");
    }
    }
#line 675
    if ((unsigned long )sfp == (unsigned long )((void *)0)) {
      {
      {
#line 676
      tmp = __errno_location();
      }
      {
#line 676
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mFailed to open the source file(%s), errno = %d.\n",
              srcfile, *tmp);
      }
      {
#line 678
      exit(1);
      }
      }
    }
    {
    {
#line 680
    tfp = fopen((char const   */* __restrict  */)"eecbfb859094a362907dfb2f2cd3a8c8.tmp",
                (char const   */* __restrict  */)"w");
    }
    }
#line 681
    if ((unsigned long )tfp == (unsigned long )((void *)0)) {
      {
      {
#line 682
      tmp___0 = __errno_location();
      }
      {
#line 682
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mFailed to open the temprary file(%s), errno = %d.\n",
              "eecbfb859094a362907dfb2f2cd3a8c8.tmp", *tmp___0);
      }
      {
#line 684
      exit(1);
      }
      }
    }
    {
#line 688
    tmp___1 = warning_cc_id;
#line 688
    warning_cc_id ++;
#line 688
    cc_id[cur_nest] = tmp___1;
#line 689
    whole_file_cc_id = cc_id[cur_nest];
#line 690
    cc_branch[cur_nest] = 0;
#line 691
    have_else[cur_nest] = 0;
    {
#line 692
    tmp___3 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"#if 1\n");
    }
    }
#line 692
    if (tmp___3 < 0) {
      {
      {
#line 693
      while (1) {
        while_continue___19: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 693
        tmp___2 = __errno_location();
        }
        {
#line 693
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 693, *tmp___2);
        }
        {
#line 693
        exit(1);
        }
        }
#line 693
        goto while_break___0;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 694
    tmp___5 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"#warning %s_%d_%d\n",
                      "eecbfb859094a362907dfb2f2cd3a8c8", cc_id[cur_nest], cc_branch[cur_nest]);
    }
    }
#line 694
    if (tmp___5 < 0) {
      {
      {
#line 697
      while (1) {
        while_continue___20: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 697
        tmp___4 = __errno_location();
        }
        {
#line 697
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 697, *tmp___4);
        }
        {
#line 697
        exit(1);
        }
        }
#line 697
        goto while_break___1;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 701
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 701
      tmp___24 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                       (FILE */* __restrict  */)sfp);
      }
      }
#line 701
      if (! ((unsigned long )tmp___24 != (unsigned long )((void *)0))) {
#line 701
        goto while_break___2;
      }
      {
#line 702
      logiline = (struct logiline_t *)((void *)0);
#line 703
      lineno ++;
#line 704
      cc_type = 0;
      {
#line 706
      tmp___6 = strlen((char const   *)(linebuf));
      }
      }
#line 706
      if (tmp___6 == sizeof(linebuf) - 1UL) {
#line 706
        if ((int )linebuf[sizeof(linebuf) - 2UL] != 10) {
          {
          {
#line 709
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mThe source line(%s: %d) is too long to parse.\n",
                  srcfile, lineno);
          }
#line 711
          invalid_file = 1;
          }
#line 712
          goto invalid_file;
        }
      }
      {
      {
#line 715
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 715
        tmp___9 = is_unterminate_line((char const   *)(linebuf));
        }
        }
#line 715
        if (! tmp___9) {
#line 715
          goto while_break___3;
        }
        {
        {
#line 717
        p = strrchr((char const   *)(linebuf), '\\');
        }
#line 718
        *p = (char )'\000';
        {
#line 719
        logiline = build_logiline(logiline, (char const   *)(linebuf));
        }
        {
#line 720
        tmp___7 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                        (FILE */* __restrict  */)sfp);
        }
        }
#line 720
        if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
          {
          {
#line 721
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnterminated line(%s: %d).\n",
                  srcfile, lineno);
          }
#line 722
          invalid_file = 1;
          }
#line 723
          goto invalid_file;
        }
        {
#line 725
        lineno ++;
        {
#line 727
        tmp___8 = strlen((char const   *)(linebuf));
        }
        }
#line 727
        if (tmp___8 == sizeof(linebuf) - 1UL) {
#line 727
          if ((int )linebuf[sizeof(linebuf) - 2UL] != 10) {
            {
            {
#line 730
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mThe source line(%s: %d) is too long to parse.\n",
                    srcfile, lineno);
            }
#line 732
            invalid_file = 1;
            }
#line 733
            goto invalid_file;
          }
        }
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 737
      if ((unsigned long )logiline != (unsigned long )((void *)0)) {
        {
        {
#line 739
        logiline = build_logiline(logiline, (char const   *)(linebuf));
        }
#line 740
        p = logiline->linebuf;
        }
      } else {
#line 742
        p = linebuf;
      }
#line 745
      if (is_in_comment) {
#line 746
        comment_begin_in_this_line = 0;
      } else {
#line 748
        comment_begin_in_this_line = 1;
      }
#line 749
      dont_output = 0;
      {
      {
#line 750
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 752
        if (is_in_comment) {
          {
          {
#line 754
          q = strstr((char const   *)p, "*/");
          }
          }
#line 755
          if ((unsigned long )q != (unsigned long )((void *)0)) {
            {
            {
#line 757
            tmp___10 = strlen((char const   *)(q + 2));
            }
            {
#line 757
            memmove((void *)p, (void const   *)(q + 2), tmp___10 + 1UL);
            }
#line 758
            is_in_comment = 0;
            }
#line 759
            goto while_continue___4;
          } else {
#line 762
            if (comment_begin_in_this_line) {
#line 765
              *(comment_begin + 0) = (char )' ';
#line 766
              *(comment_begin + 1) = (char )'\000';
#line 768
              if ((unsigned long )logiline != (unsigned long )((void *)0)) {
                {
                {
#line 769
                cc_type = get_line_type((char const   *)logiline->linebuf);
                }
                }
              } else {
                {
                {
#line 771
                cc_type = get_line_type((char const   *)(linebuf));
                }
                }
              }
#line 774
              if (cc_type == 1) {
                {
                {
#line 775
                discovered_main(main_list, (char const   *)srcfile);
                }
                }
              }
            } else {
#line 778
              dont_output = 1;
            }
#line 780
            goto while_break___4;
          }
        } else {
#line 784
          q = p;
          {
          {
#line 785
          while (1) {
            while_continue___24: /* CIL Label */ ;
            while_continue___5: /* CIL Label */ ;
            {
            {
#line 786
            r = strstr((char const   *)q, "//");
            }
            }
#line 787
            if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 788
              goto while_break___5;
            }
            {
            {
#line 789
            tmp___11 = is_in_quote(q, r);
            }
            }
#line 789
            if (tmp___11) {
              {
              {
#line 791
              q = find_first_quote((char const   *)(r + 2));
              }
              }
#line 792
              if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 794
                invalid_file = 1;
#line 795
                goto invalid_file;
              } else {
#line 797
                q ++;
              }
            } else {
#line 800
              goto while_break___5;
            }
          }
          while_break___24: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 804
          q = p;
          {
          {
#line 805
          while (1) {
            while_continue___25: /* CIL Label */ ;
            while_continue___6: /* CIL Label */ ;
            {
            {
#line 806
            s = strstr((char const   *)q, "/*");
            }
            }
#line 807
            if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 808
              goto while_break___6;
            }
            {
            {
#line 809
            tmp___12 = is_in_quote(q, s);
            }
            }
#line 809
            if (tmp___12) {
              {
              {
#line 811
              q = find_first_quote((char const   *)(s + 2));
              }
              }
#line 812
              if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 814
                invalid_file = 1;
#line 815
                goto invalid_file;
              } else {
#line 817
                q ++;
              }
            } else {
#line 820
              goto while_break___6;
            }
          }
          while_break___25: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 824
          if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 824
            if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 825
              if ((unsigned long )r < (unsigned long )s) {
#line 826
                s = (char *)((void *)0);
              } else {
#line 828
                r = (char *)((void *)0);
              }
            }
          }
#line 830
          if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 832
            *(r + 0) = (char )' ';
#line 833
            *(r + 1) = (char )'\n';
#line 834
            *(r + 2) = (char )'\000';
#line 836
            if ((unsigned long )logiline != (unsigned long )((void *)0)) {
              {
              {
#line 837
              cc_type = get_line_type((char const   *)logiline->linebuf);
              }
              }
            } else {
              {
              {
#line 839
              cc_type = get_line_type((char const   *)(linebuf));
              }
              }
            }
#line 842
            if (cc_type == 1) {
              {
              {
#line 843
              discovered_main(main_list, (char const   *)srcfile);
              }
              }
            }
          } else
#line 844
          if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 846
            *(s + 0) = (char )' ';
#line 847
            *(s + 1) = (char )' ';
#line 848
            p = s + 2;
#line 849
            comment_begin_in_this_line = 1;
#line 850
            comment_begin = s + 0;
#line 851
            is_in_comment = 1;
#line 852
            goto while_continue___4;
          } else {
#line 855
            if ((unsigned long )logiline != (unsigned long )((void *)0)) {
              {
              {
#line 856
              cc_type = get_line_type((char const   *)logiline->linebuf);
              }
              }
            } else {
              {
              {
#line 858
              cc_type = get_line_type((char const   *)(linebuf));
              }
              }
            }
#line 861
            if (cc_type == 1) {
              {
              {
#line 862
              discovered_main(main_list, (char const   *)srcfile);
              }
              }
            }
          }
#line 864
          goto while_break___4;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 868
      if (cc_type != 5) {
#line 870
        if ((unsigned long )logiline != (unsigned long )((void *)0)) {
#line 871
          if (! dont_output) {
#line 872
            if (! fast_mode) {
              {
              {
#line 874
              fputs2((char const   *)logiline->linebuf, tfp);
              }
              }
            } else
#line 872
            if (cc_type != 0) {
#line 872
              if (cc_type != 1) {
                {
                {
#line 874
                fputs2((char const   *)logiline->linebuf, tfp);
                }
                }
              }
            }
          }
          {
          {
#line 877
          logiline_free(logiline);
          }
          }
        } else
#line 879
        if (! dont_output) {
#line 880
          if (! fast_mode) {
            {
            {
#line 882
            fputs2((char const   *)(linebuf), tfp);
            }
            }
          } else
#line 880
          if (cc_type != 0) {
#line 880
            if (cc_type != 1) {
              {
              {
#line 882
              fputs2((char const   *)(linebuf), tfp);
              }
              }
            }
          }
        }
      }
#line 888
      if (cc_type == 2) {
#line 890
        cur_nest ++;
#line 891
        if (cur_nest >= 64) {
          {
          {
#line 892
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mThe source file(%s) contains too many nesting CC.\n",
                  srcfile);
          }
#line 894
          invalid_file = 1;
          }
#line 895
          goto invalid_file;
        }
        {
#line 897
        tmp___13 = warning_cc_id;
#line 897
        warning_cc_id ++;
#line 897
        cc_id[cur_nest] = tmp___13;
#line 898
        cc_branch[cur_nest] = 0;
#line 899
        have_else[cur_nest] = 0;
        {
#line 900
        tmp___15 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"\n#warning %s_%d_%d\n",
                           "eecbfb859094a362907dfb2f2cd3a8c8", cc_id[cur_nest], cc_branch[cur_nest]);
        }
        }
#line 900
        if (tmp___15 < 0) {
          {
          {
#line 903
          while (1) {
            while_continue___26: /* CIL Label */ ;
            while_continue___7: /* CIL Label */ ;
            {
            {
#line 903
            tmp___14 = __errno_location();
            }
            {
#line 903
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 903, *tmp___14);
            }
            {
#line 903
            exit(1);
            }
            }
#line 903
            goto while_break___7;
          }
          while_break___26: /* CIL Label */ ;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      } else
#line 905
      if (cc_type == 3) {
        {
#line 907
        (cc_branch[cur_nest]) ++;
        {
#line 908
        tmp___17 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"\n#warning %s_%d_%d\n",
                           "eecbfb859094a362907dfb2f2cd3a8c8", cc_id[cur_nest], cc_branch[cur_nest]);
        }
        }
#line 908
        if (tmp___17 < 0) {
          {
          {
#line 911
          while (1) {
            while_continue___27: /* CIL Label */ ;
            while_continue___8: /* CIL Label */ ;
            {
            {
#line 911
            tmp___16 = __errno_location();
            }
            {
#line 911
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 911, *tmp___16);
            }
            {
#line 911
            exit(1);
            }
            }
#line 911
            goto while_break___8;
          }
          while_break___27: /* CIL Label */ ;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
      } else
#line 913
      if (cc_type == 4) {
        {
#line 915
        (cc_branch[cur_nest]) ++;
#line 916
        have_else[cur_nest] = 1;
        {
#line 917
        tmp___19 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"\n#warning %s_%d_%d\n",
                           "eecbfb859094a362907dfb2f2cd3a8c8", cc_id[cur_nest], cc_branch[cur_nest]);
        }
        }
#line 917
        if (tmp___19 < 0) {
          {
          {
#line 920
          while (1) {
            while_continue___28: /* CIL Label */ ;
            while_continue___9: /* CIL Label */ ;
            {
            {
#line 920
            tmp___18 = __errno_location();
            }
            {
#line 920
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 920, *tmp___18);
            }
            {
#line 920
            exit(1);
            }
            }
#line 920
            goto while_break___9;
          }
          while_break___28: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      } else
#line 922
      if (cc_type == 5) {
#line 924
        if (! have_else[cur_nest]) {
          {
#line 926
          (cc_branch[cur_nest]) ++;
          {
#line 927
          tmp___21 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"\n#else\n");
          }
          }
#line 927
          if (tmp___21 < 0) {
            {
            {
#line 928
            while (1) {
              while_continue___29: /* CIL Label */ ;
              while_continue___10: /* CIL Label */ ;
              {
              {
#line 928
              tmp___20 = __errno_location();
              }
              {
#line 928
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                      "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 928, *tmp___20);
              }
              {
#line 928
              exit(1);
              }
              }
#line 928
              goto while_break___10;
            }
            while_break___29: /* CIL Label */ ;
            }
            while_break___10: /* CIL Label */ ;
            }
          }
          {
          {
#line 929
          tmp___23 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"\n#warning %s_%d_%d\n",
                             "eecbfb859094a362907dfb2f2cd3a8c8", cc_id[cur_nest],
                             cc_branch[cur_nest]);
          }
          }
#line 929
          if (tmp___23 < 0) {
            {
            {
#line 932
            while (1) {
              while_continue___30: /* CIL Label */ ;
              while_continue___11: /* CIL Label */ ;
              {
              {
#line 932
              tmp___22 = __errno_location();
              }
              {
#line 932
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                      "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 932, *tmp___22);
              }
              {
#line 932
              exit(1);
              }
              }
#line 932
              goto while_break___11;
            }
            while_break___30: /* CIL Label */ ;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
        }
#line 935
        cur_nest --;
#line 936
        if (cur_nest < 0) {
          {
          {
#line 937
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInvalid source line(%s: %d).\n",
                  srcfile, lineno);
          }
#line 938
          invalid_file = 1;
          }
#line 939
          goto invalid_file;
        }
#line 942
        if ((unsigned long )logiline != (unsigned long )((void *)0)) {
#line 943
          if (! dont_output) {
#line 944
            if (! fast_mode) {
              {
              {
#line 946
              fputs2((char const   *)logiline->linebuf, tfp);
              }
              }
            } else
#line 944
            if (cc_type != 0) {
#line 944
              if (cc_type != 1) {
                {
                {
#line 946
                fputs2((char const   *)logiline->linebuf, tfp);
                }
                }
              }
            }
          }
          {
          {
#line 949
          logiline_free(logiline);
          }
          }
        } else
#line 951
        if (! dont_output) {
#line 952
          if (! fast_mode) {
            {
            {
#line 954
            fputs2((char const   *)(linebuf), tfp);
            }
            }
          } else
#line 952
          if (cc_type != 0) {
#line 952
            if (cc_type != 1) {
              {
              {
#line 954
              fputs2((char const   *)(linebuf), tfp);
              }
              }
            }
          }
        }
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    invalid_file: 
#line 962
    if (invalid_file) {
      {
      {
#line 964
      tmp___25 = malloc(sizeof(struct list_t ));
      }
#line 964
      item = (struct list_t *)tmp___25;
      }
#line 965
      if ((unsigned long )item == (unsigned long )((void *)0)) {
        {
        {
#line 966
        while (1) {
          while_continue___31: /* CIL Label */ ;
          while_continue___12: /* CIL Label */ ;
          {
          {
#line 966
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
          }
          {
#line 966
          exit(1);
          }
          }
#line 966
          goto while_break___12;
        }
        while_break___31: /* CIL Label */ ;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
      {
      {
#line 967
      tmp___26 = strdup((char const   *)srcfile);
      }
#line 967
      item->data = (void *)tmp___26;
      }
#line 968
      if ((unsigned long )item->data == (unsigned long )((void *)0)) {
        {
        {
#line 969
        while (1) {
          while_continue___32: /* CIL Label */ ;
          while_continue___13: /* CIL Label */ ;
          {
          {
#line 969
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
          }
          {
#line 969
          exit(1);
          }
          }
#line 969
          goto while_break___13;
        }
        while_break___32: /* CIL Label */ ;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      {
#line 971
      item->next = *invalid_file_list;
#line 972
      *invalid_file_list = item;
      {
#line 974
      fclose(tfp);
      }
#line 975
      cur_nest = 0;
      {
#line 977
      tfp = fopen((char const   */* __restrict  */)"eecbfb859094a362907dfb2f2cd3a8c8.tmp",
                  (char const   */* __restrict  */)"w");
      }
      }
#line 978
      if ((unsigned long )tfp == (unsigned long )((void *)0)) {
        {
        {
#line 979
        tmp___27 = __errno_location();
        }
        {
#line 979
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mFailed to open the temprary file(%s), errno = %d.\n",
                "eecbfb859094a362907dfb2f2cd3a8c8.tmp", *tmp___27);
        }
        {
#line 981
        exit(1);
        }
        }
      }
      {
#line 984
      warning_cc_id = whole_file_cc_id;
#line 985
      tmp___28 = warning_cc_id;
#line 985
      warning_cc_id ++;
#line 985
      cc_id[cur_nest] = tmp___28;
#line 986
      cc_branch[cur_nest] = 0;
#line 987
      have_else[cur_nest] = 0;
      {
#line 988
      tmp___30 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"#if 1\n");
      }
      }
#line 988
      if (tmp___30 < 0) {
        {
        {
#line 989
        while (1) {
          while_continue___33: /* CIL Label */ ;
          while_continue___14: /* CIL Label */ ;
          {
          {
#line 989
          tmp___29 = __errno_location();
          }
          {
#line 989
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 989, *tmp___29);
          }
          {
#line 989
          exit(1);
          }
          }
#line 989
          goto while_break___14;
        }
        while_break___33: /* CIL Label */ ;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      {
      {
#line 990
      tmp___32 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"#warning %s_%d_%d\n",
                         "eecbfb859094a362907dfb2f2cd3a8c8", cc_id[cur_nest], cc_branch[cur_nest]);
      }
      }
#line 990
      if (tmp___32 < 0) {
        {
        {
#line 993
        while (1) {
          while_continue___34: /* CIL Label */ ;
          while_continue___15: /* CIL Label */ ;
          {
          {
#line 993
          tmp___31 = __errno_location();
          }
          {
#line 993
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 993, *tmp___31);
          }
          {
#line 993
          exit(1);
          }
          }
#line 993
          goto while_break___15;
        }
        while_break___34: /* CIL Label */ ;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
    }
    {
    {
#line 1000
    tmp___34 = fprintf((FILE */* __restrict  */)tfp, (char const   */* __restrict  */)"\n#endif\n");
    }
    }
#line 1000
    if (tmp___34 < 0) {
      {
      {
#line 1001
      while (1) {
        while_continue___35: /* CIL Label */ ;
        while_continue___16: /* CIL Label */ ;
        {
        {
#line 1001
        tmp___33 = __errno_location();
        }
        {
#line 1001
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1001, *tmp___33);
        }
        {
#line 1001
        exit(1);
        }
        }
#line 1001
        goto while_break___16;
      }
      while_break___35: /* CIL Label */ ;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
    {
    {
#line 1004
    fclose(sfp);
    }
    {
#line 1005
    fclose(tfp);
    }
    {
#line 1007
    tmp___36 = rename("eecbfb859094a362907dfb2f2cd3a8c8.tmp", (char const   *)srcfile);
    }
    }
#line 1007
    if (tmp___36 == -1) {
      {
      {
#line 1008
      while (1) {
        while_continue___36: /* CIL Label */ ;
        while_continue___17: /* CIL Label */ ;
        {
        {
#line 1008
        tmp___35 = __errno_location();
        }
        {
#line 1008
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1008, *tmp___35);
        }
        {
#line 1008
        exit(1);
        }
        }
#line 1008
        goto while_break___17;
      }
      while_break___36: /* CIL Label */ ;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 1011
    file_list = file_list->next;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  return (warning_cc_id);
}
}
#line 1016 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int set_nonblocking(int fd ) 
{ 
  int flag ;
  int tmp ;

  {
  {
  {
#line 1021
  flag = fcntl(fd, 3);
  }
  }
#line 1022
  if (flag == -1) {
#line 1023
    return (-1);
  }
  {
  {
#line 1024
  tmp = fcntl(fd, 4, flag | 2048);
  }
  }
#line 1024
  if (tmp == -1) {
#line 1025
    return (-1);
  }
#line 1026
  return (0);
}
}
#line 1029 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int is_lack_main(struct ringbuf_t *stderr_rbuf ) 
{ 
  char buf[4096] ;
  char *p ;
  int len ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1036
  len = ringbuf_read_last(stderr_rbuf, (void *)(buf), (int )(sizeof(buf) - 1UL));
  }
#line 1037
  buf[len] = (char )'\000';
  }
  {
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1040
    p = strrchr((char const   *)(buf), '\n');
    }
    }
#line 1041
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1043
      goto while_break;
    }
    {
    {
#line 1045
    tmp = strstr((char const   *)(p + 1), "undefined reference to `main\'");
    }
    }
#line 1045
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1046
      return (1);
    } else {
#line 1049
      *p = (char )'\000';
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1052
  tmp___0 = strstr((char const   *)(buf), "undefined reference to `main\'");
  }
  }
#line 1052
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1053
    return (1);
  }
#line 1054
  return (0);
}
}
#line 1057 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static struct list_t *in_main_list(char const   *obj_file , char const   *cwd , int cwd_len ,
                                   char const   *leave_dir , int leave_dir_len , struct list_t *main_list ) 
{ 
  char rel_path[4096] ;
  int len ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 1064
  strcpy((char */* __restrict  */)(rel_path), (char const   */* __restrict  */)"./");
  }
  }
#line 1065
  if ((int const   )*leave_dir != 0) {
    {
    {
#line 1066
    tmp = strncmp(leave_dir, cwd, (size_t )cwd_len);
    }
    }
#line 1066
    if (tmp != 0) {
#line 1067
      return ((struct list_t *)((void *)0));
    }
#line 1068
    if (leave_dir_len > cwd_len) {
      {
      {
#line 1068
      tmp___0 = strlen((char const   *)(rel_path));
      }
      }
#line 1068
      if ((unsigned long )(leave_dir_len - cwd_len) < sizeof(rel_path) - tmp___0) {
        {
        {
#line 1071
        strcat((char */* __restrict  */)(rel_path), (char const   */* __restrict  */)((leave_dir + cwd_len) + 1));
        }
        {
#line 1072
        strcat((char */* __restrict  */)(rel_path), (char const   */* __restrict  */)"/");
        }
        }
      } else {
#line 1068
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1073
    if (leave_dir_len < cwd_len) {
#line 1074
      return ((struct list_t *)((void *)0));
    }
  }
  {
  {
#line 1078
  tmp___1 = strlen(obj_file);
  }
#line 1078
  len = (int )tmp___1;
  {
#line 1079
  tmp___2 = strlen((char const   *)(rel_path));
  }
  }
#line 1079
  if ((unsigned long )len < sizeof(rel_path) - tmp___2) {
    {
    {
#line 1080
    strcat((char */* __restrict  */)(rel_path), (char const   */* __restrict  */)obj_file);
    }
    }
  } else {
#line 1082
    return ((struct list_t *)((void *)0));
  }
  {
  {
#line 1085
  tmp___3 = strlen((char const   *)(rel_path));
  }
#line 1085
  rel_path[tmp___3 - 1UL] = (char )'c';
  }
  {
  {
#line 1087
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1087
    if (! ((unsigned long )main_list != (unsigned long )((void *)0))) {
#line 1087
      goto while_break;
    }
    {
    {
#line 1088
    tmp___4 = strcmp((char const   *)((char *)main_list->data), (char const   *)(rel_path));
    }
    }
#line 1088
    if (tmp___4 == 0) {
#line 1089
      return (main_list);
    }
#line 1091
    main_list = main_list->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1093
  return ((struct list_t *)((void *)0));
}
}
#line 1096 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static struct list_t *guess_main_file(struct ringbuf_t *stdout_rbuf , struct list_t *main_list ) 
{ 
  char *p ;
  char *q ;
  char *r ;
  char cwd[4096] ;
  char buf[16384] ;
  char leave_dir[4096] ;
  char *begin ;
  int len ;
  int cwd_len ;
  int leave_dir_len ;
  int found_o ;
  struct list_t *rets ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 1100
  found_o = 0;
  {
#line 1104
  tmp___0 = getcwd(cwd, sizeof(cwd) - 1UL);
  }
  }
#line 1104
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 1105
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1105
      tmp = __errno_location();
      }
      {
#line 1105
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1105, *tmp);
      }
      {
#line 1105
      exit(1);
      }
      }
#line 1105
      goto while_break;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1106
  cwd[sizeof(cwd) - 1UL] = (char )'\000';
  {
#line 1107
  tmp___1 = strlen((char const   *)(cwd));
  }
#line 1107
  cwd_len = (int )tmp___1;
  {
#line 1110
  len = ringbuf_read_last(stdout_rbuf, (void *)(buf), (int )(sizeof(buf) - 1UL));
  }
#line 1111
  buf[len] = (char )'\000';
#line 1114
  leave_dir[0] = (char )'\000';
#line 1115
  leave_dir_len = 0;
  }
  {
  {
#line 1116
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1117
    p = strrchr((char const   *)(buf), '\n');
    }
    }
#line 1118
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1120
      goto while_break___0;
    }
    {
    {
#line 1123
    q = strstr((char const   *)(p + 1), "Leaving directory `");
    }
    }
#line 1124
    if ((unsigned long )q != (unsigned long )((void *)0)) {
      {
#line 1125
      q += 19;
      {
#line 1126
      r = strrchr((char const   *)q, '\'');
      }
      }
#line 1127
      if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 1127
        if ((unsigned long )(r - q) < sizeof(leave_dir)) {
          {
          {
#line 1128
          memcpy((void */* __restrict  */)(leave_dir), (void const   */* __restrict  */)q,
                 (size_t )(r - q));
          }
#line 1129
          leave_dir[r - q] = (char )'\000';
#line 1130
          leave_dir_len = (int )(r - q);
          }
        }
      }
#line 1133
      *p = (char )'\000';
#line 1134
      goto while_continue___0;
    }
    {
    {
#line 1137
    q = strstr((char const   *)(p + 1), ".o");
    }
    }
#line 1138
    if ((unsigned long )q != (unsigned long )((void *)0)) {
      {
      {
#line 1139
      tmp___2 = __ctype_b_loc();
      }
      }
#line 1139
      if ((int const   )*(*tmp___2 + (int )*(q + 2)) & 8192) {
#line 1140
        found_o = 1;
#line 1141
        begin = p + 1;
#line 1142
        goto while_break___0;
      } else
#line 1139
      if ((int )*(q + 2) == 0) {
#line 1140
        found_o = 1;
#line 1141
        begin = p + 1;
#line 1142
        goto while_break___0;
      }
    } else {
#line 1146
      *p = (char )'\000';
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1150
  if (! found_o) {
    {
    {
#line 1152
    q = strstr((char const   *)(buf), ".o");
    }
    }
#line 1153
    if ((unsigned long )q != (unsigned long )((void *)0)) {
      {
      {
#line 1154
      tmp___3 = __ctype_b_loc();
      }
      }
#line 1154
      if ((int const   )*(*tmp___3 + (int )*(q + 2)) & 8192) {
#line 1155
        found_o = 1;
#line 1156
        begin = buf;
      } else
#line 1154
      if ((int )*(q + 2) == 0) {
#line 1155
        found_o = 1;
#line 1156
        begin = buf;
      }
    }
#line 1159
    if (! found_o) {
#line 1161
      return ((struct list_t *)((void *)0));
    }
  }
#line 1166
  p = begin;
  {
  {
#line 1167
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 1168
    tmp___4 = strspn((char const   *)p, " \t\r");
    }
#line 1168
    p += tmp___4;
    {
#line 1169
    q = strpbrk((char const   *)p, " \t\r");
    }
    }
#line 1170
    if ((unsigned long )q == (unsigned long )((void *)0)) {
      {
      {
#line 1171
      tmp___5 = strlen((char const   *)p);
      }
#line 1171
      len = (int )tmp___5;
      }
#line 1172
      if (len >= 3) {
#line 1172
        if ((int )*(p + (len - 2)) == 46) {
#line 1172
          if ((int )*(p + (len - 1)) == 111) {
            {
            {
#line 1173
            rets = in_main_list((char const   *)p, (char const   *)(cwd), cwd_len,
                                (char const   *)(leave_dir), leave_dir_len, main_list);
            }
            }
#line 1174
            if ((unsigned long )rets != (unsigned long )((void *)0)) {
#line 1175
              return (rets);
            }
          }
        }
      }
#line 1177
      goto while_break___1;
    } else
#line 1179
    if (q - p >= 3L) {
#line 1179
      if ((int )*(q + -2) == 46) {
#line 1179
        if ((int )*(q + -1) == 111) {
          {
#line 1180
          *q = (char )'\000';
          {
#line 1181
          rets = in_main_list((char const   *)p, (char const   *)(cwd), cwd_len, (char const   *)(leave_dir),
                              leave_dir_len, main_list);
          }
          }
#line 1182
          if ((unsigned long )rets != (unsigned long )((void *)0)) {
#line 1183
            return (rets);
          }
        }
      }
    }
#line 1187
    p = q + 1;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1190
  return ((struct list_t *)((void *)0));
}
}
#line 1193 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int add_main_function(char const   *file ) 
{ 
  FILE *fp ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1198
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"a");
  }
  }
#line 1199
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1200
    return (-1);
  }
  {
  {
#line 1201
  tmp = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
                "int main(int argc, char *argv[]) {return 0;}");
  }
  }
#line 1201
  if (tmp < 0) {
    {
    {
#line 1202
    fclose(fp);
    }
    }
#line 1203
    return (-1);
  }
  {
  {
#line 1205
  fclose(fp);
  }
  }
#line 1206
  return (0);
}
}
#line 1209 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void rm_object_file(char *file ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
  {
#line 1214
  tmp = strlen((char const   *)file);
  }
#line 1214
  len = (int )tmp;
#line 1215
  *(file + (len - 1)) = (char )'o';
  {
#line 1216
  unlink((char const   *)file);
  }
#line 1217
  *(file + (len - 1)) = (char )'c';
  }
#line 1218
  return;
}
}
#line 1220 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void dump_error_info(char const   *file , struct ringbuf_t *stdout_rbuf , struct ringbuf_t *stderr_rbuf ) 
{ 
  FILE *fp ;
  char buf[4096] ;
  int len ;
  int *tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 1228
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 1229
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 1230
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1230
      tmp = __errno_location();
      }
      {
#line 1230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1230, *tmp);
      }
      {
#line 1230
      exit(1);
      }
      }
#line 1230
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 1231
  fputs2("stdout:\n\n", fp);
  }
  {
#line 1232
  len = ringbuf_read_last(stdout_rbuf, (void *)(buf), (int )(sizeof(buf) - 1UL));
  }
  }
#line 1233
  if (len > 0) {
    {
#line 1234
    buf[len] = (char )'\000';
    {
#line 1235
    fputs2((char const   *)(buf), fp);
    }
    }
  }
  {
  {
#line 1237
  fputs2("\nstderr:\n\n", fp);
  }
  {
#line 1238
  len = ringbuf_read_last(stderr_rbuf, (void *)(buf), (int )(sizeof(buf) - 1UL));
  }
  }
#line 1239
  if (len > 0) {
    {
#line 1240
    buf[len] = (char )'\000';
    {
#line 1241
    fputs2((char const   *)(buf), fp);
    }
    }
  }
  {
  {
#line 1243
  fclose(fp);
  }
  }
#line 1244
  return;
}
}
#line 1255 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static struct cc_used_t *try_build_and_parse(int fast_mode , char const   *comp_cmd ,
                                             char const   *comp_dir , int ncc , struct list_t **main_list ) 
{ 
  struct cc_used_t *rets ;
  struct ringbuf_t *stdout_rbuf ;
  struct ringbuf_t *stderr_rbuf ;
  int ret ;
  int i ;
  int stdout_pfd[2] ;
  int stderr_pfd[2] ;
  int null_fd ;
  int len ;
  int status ;
  int cc_id ;
  int cc_branch ;
  int count ;
  pid_t pid ;
  FILE *fp ;
  char linebuf[4096] ;
  char *p ;
  char buf[4096] ;
  struct list_t *tmp_list ;
  struct list_t *tmp_list2 ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  size_t tmp___15 ;
  int *tmp___16 ;
  ssize_t tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  size_t tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  struct list_t *tmp___23 ;
  char *tmp___24 ;
  ssize_t tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  __pid_t tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  union __anonunion_52 __constr_expr_0 ;
  union __anonunion_53 __constr_expr_1 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *__cil_tmp64 ;
  void *__cil_tmp65 ;
  void *__cil_tmp66 ;
  int __cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;

  {
  {
#line 1261
  count = 0;
  {
#line 1268
  tmp = malloc((unsigned long )ncc * sizeof(struct cc_used_t ));
  }
#line 1268
  rets = (struct cc_used_t *)tmp;
  }
#line 1269
  if ((unsigned long )rets == (unsigned long )((void *)0)) {
    {
    {
#line 1270
    while (1) {
      while_continue___32: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1270
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
      }
      {
#line 1270
      exit(1);
      }
      }
#line 1270
      goto while_break;
    }
    while_break___32: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1271
  i = 0;
  {
  {
#line 1271
  while (1) {
    while_continue___33: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1271
    if (! (i < ncc)) {
#line 1271
      goto while_break___0;
    }
#line 1272
    (rets + i)->flags = 0;
#line 1273
    (rets + i)->used_branch = (struct list_t *)((void *)0);
#line 1271
    i ++;
  }
  while_break___33: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1276
  stdout_rbuf = ringbuf_new(16384);
  }
  }
#line 1277
  if ((unsigned long )stdout_rbuf == (unsigned long )((void *)0)) {
    {
    {
#line 1278
    while (1) {
      while_continue___34: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 1278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
      }
      {
#line 1278
      exit(1);
      }
      }
#line 1278
      goto while_break___1;
    }
    while_break___34: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  {
#line 1279
  stderr_rbuf = ringbuf_new(16384);
  }
  }
#line 1280
  if ((unsigned long )stderr_rbuf == (unsigned long )((void *)0)) {
    {
    {
#line 1281
    while (1) {
      while_continue___35: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 1281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
      }
      {
#line 1281
      exit(1);
      }
      }
#line 1281
      goto while_break___2;
    }
    while_break___35: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
  {
#line 1283
  while (1) {
    while_continue___36: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 1285
    ringbuf_clear(stdout_rbuf);
    }
    {
#line 1286
    ringbuf_clear(stderr_rbuf);
    }
    {
#line 1288
    tmp___1 = pipe((int *)(stdout_pfd));
    }
    }
#line 1288
    if (tmp___1 == -1) {
      {
      {
#line 1289
      while (1) {
        while_continue___37: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
        {
        {
#line 1289
        tmp___0 = __errno_location();
        }
        {
#line 1289
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1289, *tmp___0);
        }
        {
#line 1289
        exit(1);
        }
        }
#line 1289
        goto while_break___4;
      }
      while_break___37: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
    {
#line 1291
    tmp___3 = pipe((int *)(stderr_pfd));
    }
    }
#line 1291
    if (tmp___3 == -1) {
      {
      {
#line 1292
      while (1) {
        while_continue___38: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
        {
        {
#line 1292
        tmp___2 = __errno_location();
        }
        {
#line 1292
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1292, *tmp___2);
        }
        {
#line 1292
        exit(1);
        }
        }
#line 1292
        goto while_break___5;
      }
      while_break___38: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
    {
#line 1294
    pid = fork();
    }
    }
#line 1295
    if (pid == -1) {
      {
      {
#line 1297
      while (1) {
        while_continue___39: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
        {
        {
#line 1297
        tmp___4 = __errno_location();
        }
        {
#line 1297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1297, *tmp___4);
        }
        {
#line 1297
        exit(1);
        }
        }
#line 1297
        goto while_break___6;
      }
      while_break___39: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 1298
    if (pid == 0) {
      {
      {
#line 1300
      close(stdout_pfd[0]);
      }
      {
#line 1301
      close(stderr_pfd[0]);
      }
      }
#line 1303
      if ((unsigned long )comp_dir != (unsigned long )((void *)0)) {
        {
        {
#line 1304
        tmp___6 = chdir(comp_dir);
        }
        }
#line 1304
        if (tmp___6 == -1) {
          {
          {
#line 1305
          while (1) {
            while_continue___40: /* CIL Label */ ;
            while_continue___7: /* CIL Label */ ;
            {
            {
#line 1305
            tmp___5 = __errno_location();
            }
            {
#line 1305
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1305, *tmp___5);
            }
            {
#line 1305
            _exit(1);
            }
            }
#line 1305
            goto while_break___7;
          }
          while_break___40: /* CIL Label */ ;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
      {
      {
#line 1308
      null_fd = open("/dev/null", 0);
      }
      }
#line 1309
      if (null_fd == -1) {
        {
        {
#line 1310
        while (1) {
          while_continue___41: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
          {
          {
#line 1310
          tmp___7 = __errno_location();
          }
          {
#line 1310
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1310, *tmp___7);
          }
          {
#line 1310
          _exit(1);
          }
          }
#line 1310
          goto while_break___8;
        }
        while_break___41: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      {
      {
#line 1311
      dup2(null_fd, 0);
      }
      {
#line 1312
      close(null_fd);
      }
      {
#line 1314
      tmp___9 = dup2(stdout_pfd[1], 1);
      }
      }
#line 1314
      if (tmp___9 == -1) {
        {
        {
#line 1315
        while (1) {
          while_continue___42: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
          {
          {
#line 1315
          tmp___8 = __errno_location();
          }
          {
#line 1315
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1315, *tmp___8);
          }
          {
#line 1315
          _exit(1);
          }
          }
#line 1315
          goto while_break___9;
        }
        while_break___42: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
      {
      {
#line 1316
      close(stdout_pfd[1]);
      }
      {
#line 1318
      tmp___11 = dup2(stderr_pfd[1], 2);
      }
      }
#line 1318
      if (tmp___11 == -1) {
        {
        {
#line 1319
        while (1) {
          while_continue___43: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
          {
          {
#line 1319
          tmp___10 = __errno_location();
          }
          {
#line 1319
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1319, *tmp___10);
          }
          {
#line 1319
          _exit(1);
          }
          }
#line 1319
          goto while_break___10;
        }
        while_break___43: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      {
      {
#line 1320
      close(stderr_pfd[1]);
      }
      {
#line 1322
      execl("/bin/sh", "sh", "-c", comp_cmd, (void *)0);
      }
      {
#line 1323
      _exit(1);
      }
      }
    }
    {
    {
#line 1326
    close(stdout_pfd[1]);
    }
    {
#line 1327
    close(stderr_pfd[1]);
    }
    {
#line 1329
    tmp___13 = set_nonblocking(stdout_pfd[0]);
    }
    }
#line 1329
    if (tmp___13 == -1) {
      {
      {
#line 1330
      while (1) {
        while_continue___44: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
        {
        {
#line 1330
        tmp___12 = __errno_location();
        }
        {
#line 1330
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1330, *tmp___12);
        }
        {
#line 1330
        exit(1);
        }
        }
#line 1330
        goto while_break___11;
      }
      while_break___44: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    {
    {
#line 1332
    fp = fdopen(stderr_pfd[0], "r");
    }
    }
#line 1333
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
      {
#line 1334
      while (1) {
        while_continue___45: /* CIL Label */ ;
        while_continue___12: /* CIL Label */ ;
        {
        {
#line 1334
        tmp___14 = __errno_location();
        }
        {
#line 1334
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1334, *tmp___14);
        }
        {
#line 1334
        exit(1);
        }
        }
#line 1334
        goto while_break___12;
      }
      while_break___45: /* CIL Label */ ;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
    {
    {
#line 1335
    while (1) {
      while_continue___46: /* CIL Label */ ;
      while_continue___13: /* CIL Label */ ;
      {
      {
#line 1335
      tmp___24 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                       (FILE */* __restrict  */)fp);
      }
      }
#line 1335
      if (! ((unsigned long )tmp___24 != (unsigned long )((void *)0))) {
#line 1335
        goto while_break___13;
      }
#line 1337
      count ++;
#line 1338
      if (count % 1200 == 0) {
        {
        {
#line 1339
        printf((char const   */* __restrict  */)"\b\b\b   \b\b\b");
        }
        {
#line 1340
        fflush(stdout);
        }
        }
      } else
#line 1341
      if (count % 300 == 0) {
        {
        {
#line 1342
        printf((char const   */* __restrict  */)".");
        }
        {
#line 1343
        fflush(stdout);
        }
        }
      }
      {
      {
#line 1346
      tmp___15 = strlen((char const   *)(linebuf));
      }
#line 1346
      len = (int )tmp___15;
      }
#line 1347
      if ((unsigned long )len == sizeof(linebuf) - 1UL) {
#line 1347
        if ((int )linebuf[sizeof(linebuf) - 2UL] != 10) {
          {
          {
#line 1348
          while (1) {
            while_continue___47: /* CIL Label */ ;
            while_continue___14: /* CIL Label */ ;
            {
            {
#line 1348
            tmp___16 = __errno_location();
            }
            {
#line 1348
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1348, *tmp___16);
            }
            {
#line 1348
            exit(1);
            }
            }
#line 1348
            goto while_break___14;
          }
          while_break___47: /* CIL Label */ ;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
      }
      {
      {
#line 1350
      ringbuf_write(stderr_rbuf, (void const   *)(linebuf), len);
      }
      }
      {
      {
#line 1352
      while (1) {
        while_continue___48: /* CIL Label */ ;
        while_continue___15: /* CIL Label */ ;
        {
        {
#line 1353
        tmp___17 = read(stdout_pfd[0], (void *)(buf), sizeof(buf));
        }
#line 1353
        ret = (int )tmp___17;
        }
#line 1354
        if (ret == -1) {
          {
          {
#line 1355
          tmp___19 = __errno_location();
          }
          }
#line 1355
          if (*tmp___19 == 11) {
#line 1356
            goto while_break___15;
          } else {
            {
            {
#line 1358
            while (1) {
              while_continue___49: /* CIL Label */ ;
              while_continue___16: /* CIL Label */ ;
              {
              {
#line 1358
              tmp___18 = __errno_location();
              }
              {
#line 1358
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                      "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1358, *tmp___18);
              }
              {
#line 1358
              exit(1);
              }
              }
#line 1358
              goto while_break___16;
            }
            while_break___49: /* CIL Label */ ;
            }
            while_break___16: /* CIL Label */ ;
            }
          }
        } else
#line 1359
        if (ret == 0) {
#line 1360
          goto while_break___15;
        }
        {
        {
#line 1363
        ringbuf_write(stdout_rbuf, (void const   *)(buf), ret);
        }
        }
      }
      while_break___48: /* CIL Label */ ;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
      {
#line 1366
      p = strstr((char const   *)(linebuf), "eecbfb859094a362907dfb2f2cd3a8c8");
      }
      }
#line 1367
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
        {
#line 1368
        tmp___20 = strlen("eecbfb859094a362907dfb2f2cd3a8c8");
        }
#line 1368
        p += tmp___20 + 1UL;
        {
#line 1369
        cc_id = atoi((char const   *)p);
        }
        }
#line 1370
        if (cc_id >= ncc) {
          {
          {
#line 1371
          while (1) {
            while_continue___50: /* CIL Label */ ;
            while_continue___17: /* CIL Label */ ;
            {
            {
#line 1371
            tmp___21 = __errno_location();
            }
            {
#line 1371
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1371, *tmp___21);
            }
            {
#line 1371
            exit(1);
            }
            }
#line 1371
            goto while_break___17;
          }
          while_break___50: /* CIL Label */ ;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
        {
        {
#line 1372
        p = strchr((char const   *)p, '_');
        }
        }
#line 1373
        if ((unsigned long )p == (unsigned long )((void *)0)) {
          {
          {
#line 1374
          while (1) {
            while_continue___51: /* CIL Label */ ;
            while_continue___18: /* CIL Label */ ;
            {
            {
#line 1374
            tmp___22 = __errno_location();
            }
            {
#line 1374
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1374, *tmp___22);
            }
            {
#line 1374
            exit(1);
            }
            }
#line 1374
            goto while_break___18;
          }
          while_break___51: /* CIL Label */ ;
          }
          while_break___18: /* CIL Label */ ;
          }
        }
        {
#line 1375
        p ++;
        {
#line 1376
        cc_branch = atoi((char const   *)p);
        }
        }
#line 1378
        if ((rets + cc_id)->flags == 0) {
          {
#line 1380
          (rets + cc_id)->flags = 1;
          {
#line 1381
          tmp_list = list_prepend_item_by_data((struct list_t *)((void *)0), (void const   *)((void *)((long )cc_branch)));
          }
          }
#line 1382
          if ((unsigned long )tmp_list == (unsigned long )((void *)0)) {
            {
            {
#line 1383
            while (1) {
              while_continue___52: /* CIL Label */ ;
              while_continue___19: /* CIL Label */ ;
              {
              {
#line 1383
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
              }
              {
#line 1383
              exit(1);
              }
              }
#line 1383
              goto while_break___19;
            }
            while_break___52: /* CIL Label */ ;
            }
            while_break___19: /* CIL Label */ ;
            }
          }
#line 1384
          (rets + cc_id)->used_branch = tmp_list;
        } else {
          {
          {
#line 1387
          tmp___23 = list_search_item_by_data((rets + cc_id)->used_branch, (void const   *)((void *)((long )cc_branch)));
          }
          }
#line 1387
          if ((unsigned long )tmp___23 == (unsigned long )((void *)0)) {
            {
#line 1391
            (rets + cc_id)->flags |= 1 << 1;
            {
#line 1393
            tmp_list = list_prepend_item_by_data((rets + cc_id)->used_branch, (void const   *)((void *)((long )cc_branch)));
            }
            }
#line 1395
            if ((unsigned long )tmp_list == (unsigned long )((void *)0)) {
              {
              {
#line 1396
              while (1) {
                while_continue___53: /* CIL Label */ ;
                while_continue___20: /* CIL Label */ ;
                {
                {
#line 1396
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
                }
                {
#line 1396
                exit(1);
                }
                }
#line 1396
                goto while_break___20;
              }
              while_break___53: /* CIL Label */ ;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
#line 1397
            (rets + cc_id)->used_branch = tmp_list;
          }
        }
      }
    }
    while_break___46: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
    {
#line 1403
    while (1) {
      while_continue___54: /* CIL Label */ ;
      while_continue___21: /* CIL Label */ ;
      {
      {
#line 1404
      tmp___25 = read(stdout_pfd[0], (void *)(buf), sizeof(buf));
      }
#line 1404
      ret = (int )tmp___25;
      }
#line 1405
      if (ret == -1) {
        {
        {
#line 1406
        tmp___27 = __errno_location();
        }
        }
#line 1406
        if (*tmp___27 == 11) {
#line 1407
          goto while_break___21;
        } else {
          {
          {
#line 1409
          while (1) {
            while_continue___55: /* CIL Label */ ;
            while_continue___22: /* CIL Label */ ;
            {
            {
#line 1409
            tmp___26 = __errno_location();
            }
            {
#line 1409
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1409, *tmp___26);
            }
            {
#line 1409
            exit(1);
            }
            }
#line 1409
            goto while_break___22;
          }
          while_break___55: /* CIL Label */ ;
          }
          while_break___22: /* CIL Label */ ;
          }
        }
      } else
#line 1410
      if (ret == 0) {
#line 1411
        goto while_break___21;
      }
      {
      {
#line 1414
      ringbuf_write(stdout_rbuf, (void const   *)(buf), ret);
      }
      }
    }
    while_break___54: /* CIL Label */ ;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
    {
#line 1417
    close(stdout_pfd[0]);
    }
    {
#line 1418
    fclose(fp);
    }
    {
#line 1420
    tmp___29 = wait((union wait *)(& status));
    }
    }
#line 1420
    if (tmp___29 == -1) {
      {
      {
#line 1421
      while (1) {
        while_continue___56: /* CIL Label */ ;
        while_continue___23: /* CIL Label */ ;
        {
        {
#line 1421
        tmp___28 = __errno_location();
        }
        {
#line 1421
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1421, *tmp___28);
        }
        {
#line 1421
        exit(1);
        }
        }
#line 1421
        goto while_break___23;
      }
      while_break___56: /* CIL Label */ ;
      }
      while_break___23: /* CIL Label */ ;
      }
    }
#line 1422
    __constr_expr_0.__in = status;
#line 1422
    if ((__constr_expr_0.__i & 127) == 0) {
#line 1422
      __constr_expr_1.__in = status;
#line 1422
      if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
        {
        {
#line 1424
        ringbuf_free(stdout_rbuf);
        }
        {
#line 1425
        ringbuf_free(stderr_rbuf);
        }
        }
#line 1426
        return (rets);
      } else {
#line 1422
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1428
      if (! fast_mode) {
        {
        {
#line 1430
        dump_error_info("./stripcc.err", stdout_rbuf, stderr_rbuf);
        }
        {
#line 1432
        ringbuf_free(stdout_rbuf);
        }
        {
#line 1433
        ringbuf_free(stderr_rbuf);
        }
#line 1435
        i = 0;
        }
        {
        {
#line 1435
        while (1) {
          while_continue___57: /* CIL Label */ ;
          while_continue___24: /* CIL Label */ ;
#line 1435
          if (! (i < ncc)) {
#line 1435
            goto while_break___24;
          }
          {
          {
#line 1436
          while (1) {
            while_continue___58: /* CIL Label */ ;
            while_continue___25: /* CIL Label */ ;
#line 1436
            if (! ((unsigned long )(rets + i)->used_branch != (unsigned long )((void *)0))) {
#line 1436
              goto while_break___25;
            }
            {
#line 1437
            tmp_list = (rets + i)->used_branch;
#line 1438
            (rets + i)->used_branch = ((rets + i)->used_branch)->next;
            {
#line 1440
            free((void *)tmp_list);
            }
            }
          }
          while_break___58: /* CIL Label */ ;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 1435
          i ++;
        }
        while_break___57: /* CIL Label */ ;
        }
        while_break___24: /* CIL Label */ ;
        }
        {
        {
#line 1443
        free((void *)rets);
        }
        }
#line 1444
        return ((struct cc_used_t *)((void *)0));
      }
      {
      {
#line 1448
      tmp___32 = is_lack_main(stderr_rbuf);
      }
      }
#line 1448
      if (tmp___32) {
        {
        {
#line 1466
        tmp_list = guess_main_file(stdout_rbuf, *main_list);
        }
        }
#line 1467
        if ((unsigned long )tmp_list == (unsigned long )((void *)0)) {
          {
          {
#line 1469
          dump_error_info("./stripcc.err", stdout_rbuf, stderr_rbuf);
          }
          {
#line 1471
          ringbuf_free(stdout_rbuf);
          }
          {
#line 1472
          ringbuf_free(stderr_rbuf);
          }
#line 1474
          i = 0;
          }
          {
          {
#line 1474
          while (1) {
            while_continue___59: /* CIL Label */ ;
            while_continue___26: /* CIL Label */ ;
#line 1474
            if (! (i < ncc)) {
#line 1474
              goto while_break___26;
            }
            {
            {
#line 1475
            while (1) {
              while_continue___60: /* CIL Label */ ;
              while_continue___27: /* CIL Label */ ;
#line 1475
              if (! ((unsigned long )(rets + i)->used_branch != (unsigned long )((void *)0))) {
#line 1475
                goto while_break___27;
              }
              {
#line 1476
              tmp_list = (rets + i)->used_branch;
#line 1477
              (rets + i)->used_branch = ((rets + i)->used_branch)->next;
              {
#line 1479
              free((void *)tmp_list);
              }
              }
            }
            while_break___60: /* CIL Label */ ;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 1474
            i ++;
          }
          while_break___59: /* CIL Label */ ;
          }
          while_break___26: /* CIL Label */ ;
          }
          {
          {
#line 1482
          free((void *)rets);
          }
          }
#line 1483
          return ((struct cc_used_t *)((void *)0));
        }
        {
        {
#line 1485
        tmp___31 = add_main_function((char const   *)((char *)tmp_list->data));
        }
        }
#line 1485
        if (tmp___31 == -1) {
          {
          {
#line 1486
          while (1) {
            while_continue___61: /* CIL Label */ ;
            while_continue___28: /* CIL Label */ ;
            {
            {
#line 1486
            tmp___30 = __errno_location();
            }
            {
#line 1486
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1486, *tmp___30);
            }
            {
#line 1486
            exit(1);
            }
            }
#line 1486
            goto while_break___28;
          }
          while_break___61: /* CIL Label */ ;
          }
          while_break___28: /* CIL Label */ ;
          }
        }
        {
        {
#line 1487
        rm_object_file((char *)tmp_list->data);
        }
        }
#line 1489
        if ((unsigned long )tmp_list == (unsigned long )*main_list) {
          {
#line 1490
          *main_list = tmp_list->next;
          {
#line 1491
          free(tmp_list->data);
          }
          {
#line 1492
          free((void *)tmp_list);
          }
          }
        } else {
#line 1494
          tmp_list2 = *main_list;
          {
          {
#line 1495
          while (1) {
            while_continue___62: /* CIL Label */ ;
            while_continue___29: /* CIL Label */ ;
#line 1495
            if (! ((unsigned long )tmp_list2->next != (unsigned long )tmp_list)) {
#line 1495
              goto while_break___29;
            }
#line 1496
            tmp_list2 = tmp_list2->next;
          }
          while_break___62: /* CIL Label */ ;
          }
          while_break___29: /* CIL Label */ ;
          }
          {
#line 1497
          tmp_list2->next = tmp_list->next;
          {
#line 1498
          free(tmp_list->data);
          }
          {
#line 1499
          free((void *)tmp_list);
          }
          }
        }
      } else {
        {
        {
#line 1450
        dump_error_info("./stripcc.err", stdout_rbuf, stderr_rbuf);
        }
        {
#line 1452
        ringbuf_free(stdout_rbuf);
        }
        {
#line 1453
        ringbuf_free(stderr_rbuf);
        }
#line 1455
        i = 0;
        }
        {
        {
#line 1455
        while (1) {
          while_continue___63: /* CIL Label */ ;
          while_continue___30: /* CIL Label */ ;
#line 1455
          if (! (i < ncc)) {
#line 1455
            goto while_break___30;
          }
          {
          {
#line 1456
          while (1) {
            while_continue___64: /* CIL Label */ ;
            while_continue___31: /* CIL Label */ ;
#line 1456
            if (! ((unsigned long )(rets + i)->used_branch != (unsigned long )((void *)0))) {
#line 1456
              goto while_break___31;
            }
            {
#line 1457
            tmp_list = (rets + i)->used_branch;
#line 1458
            (rets + i)->used_branch = ((rets + i)->used_branch)->next;
            {
#line 1460
            free((void *)tmp_list);
            }
            }
          }
          while_break___64: /* CIL Label */ ;
          }
          while_break___31: /* CIL Label */ ;
          }
#line 1455
          i ++;
        }
        while_break___63: /* CIL Label */ ;
        }
        while_break___30: /* CIL Label */ ;
        }
        {
        {
#line 1463
        free((void *)rets);
        }
        }
#line 1464
        return ((struct cc_used_t *)((void *)0));
      }
    }
  }
  while_break___36: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
}
}
#line 1506 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void restore_files(struct list_t *file_list , int rm_backup ) 
{ 
  int ret ;
  char path[4096] ;
  int *tmp ;
  int *tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 1513
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1513
    if (! ((unsigned long )file_list != (unsigned long )((void *)0))) {
#line 1513
      goto while_break;
    }
    {
    {
#line 1515
    ret = snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s.%s",
                   (char *)file_list->data, "eecbfb859094a362907dfb2f2cd3a8c8");
    }
    }
#line 1516
    if (ret >= 4096) {
      {
      {
#line 1517
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 1517
        tmp = __errno_location();
        }
        {
#line 1517
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1517, *tmp);
        }
        {
#line 1517
        exit(1);
        }
        }
#line 1517
        goto while_break___0;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
    {
#line 1518
    unlink((char const   *)((char *)file_list->data));
    }
    {
#line 1519
    ret = link((char const   *)(path), (char const   *)((char *)file_list->data));
    }
    }
#line 1520
    if (ret == -1) {
      {
      {
#line 1521
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 1521
        tmp___0 = __errno_location();
        }
        {
#line 1521
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1521, *tmp___0);
        }
        {
#line 1521
        exit(1);
        }
        }
#line 1521
        goto while_break___1;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1522
    if (rm_backup) {
      {
      {
#line 1523
      unlink((char const   *)(path));
      }
      }
    }
#line 1525
    file_list = file_list->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1527
  return;
}
}
#line 1529 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void fputs_phyline(struct logiline_t *logiline , FILE *stream , char *start ,
                          char *end ) 
{ 
  char c ;
  int i ;
  int output ;
  int *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1535
  if ((unsigned long )start != (unsigned long )((void *)0)) {
#line 1535
    if ((unsigned long )end != (unsigned long )((void *)0)) {
      {
      {
#line 1537
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 1537
        tmp = __errno_location();
        }
        {
#line 1537
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1537, *tmp);
        }
        {
#line 1537
        exit(1);
        }
        }
#line 1537
        goto while_break;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1535
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1538
  if ((unsigned long )start != (unsigned long )((void *)0)) {
#line 1540
    output = 0;
#line 1541
    i = 0;
    {
    {
#line 1541
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1541
      if (! ((size_t )i < logiline->phyline_count)) {
#line 1541
        goto while_break___0;
      }
#line 1542
      if (output == 1) {
#line 1543
        if ((size_t )i < logiline->phyline_count - 1UL) {
          {
#line 1544
          c = *(logiline->linebuf + logiline->phyline_idx[i + 1]);
#line 1545
          *(logiline->linebuf + logiline->phyline_idx[i + 1]) = (char )'\000';
          {
#line 1546
          fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
          }
          {
#line 1547
          fputs2("\\\n", stream);
          }
#line 1548
          *(logiline->linebuf + logiline->phyline_idx[i + 1]) = c;
          }
        } else {
          {
          {
#line 1551
          fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
          }
          }
        }
      } else
#line 1554
      if ((size_t )i < logiline->phyline_count - 1UL) {
#line 1555
        if ((unsigned long )start < (unsigned long )(logiline->linebuf + logiline->phyline_idx[i + 1])) {
          {
#line 1556
          output = 1;
#line 1557
          c = *(logiline->linebuf + logiline->phyline_idx[i + 1]);
#line 1558
          *(logiline->linebuf + logiline->phyline_idx[i + 1]) = (char )'\000';
          {
#line 1559
          fputs2((char const   *)start, stream);
          }
          {
#line 1560
          fputs2("\\\n", stream);
          }
#line 1561
          *(logiline->linebuf + logiline->phyline_idx[i + 1]) = c;
          }
        }
      } else {
        {
        {
#line 1565
        fputs2((char const   *)start, stream);
        }
        }
      }
#line 1541
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 1569
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 1571
    i = 0;
    {
    {
#line 1571
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1571
      if (! ((size_t )i < logiline->phyline_count)) {
#line 1571
        goto while_break___1;
      }
#line 1572
      if ((size_t )i < logiline->phyline_count - 1UL) {
#line 1573
        if ((unsigned long )end > (unsigned long )(logiline->linebuf + logiline->phyline_idx[i + 1])) {
          {
#line 1574
          c = *(logiline->linebuf + logiline->phyline_idx[i + 1]);
#line 1575
          *(logiline->linebuf + logiline->phyline_idx[i + 1]) = (char )'\000';
          {
#line 1576
          fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
          }
          {
#line 1577
          fputs2("\\\n", stream);
          }
#line 1578
          *(logiline->linebuf + logiline->phyline_idx[i + 1]) = c;
          }
        } else {
          {
#line 1580
          c = *end;
#line 1581
          *end = (char )'\000';
          {
#line 1582
          fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
          }
          {
#line 1583
          fputs2("\n", stream);
          }
#line 1584
          *end = c;
          }
        }
      } else {
        {
#line 1588
        c = *end;
#line 1589
        *end = (char )'\000';
        {
#line 1590
        fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
        }
        {
#line 1591
        fputs2("\n", stream);
        }
#line 1592
        *end = c;
        }
      }
#line 1571
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1597
    i = 0;
    {
    {
#line 1597
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1597
      if (! ((size_t )i < logiline->phyline_count)) {
#line 1597
        goto while_break___2;
      }
#line 1598
      if ((size_t )i < logiline->phyline_count - 1UL) {
        {
#line 1599
        c = *(logiline->linebuf + logiline->phyline_idx[i + 1]);
#line 1600
        *(logiline->linebuf + logiline->phyline_idx[i + 1]) = (char )'\000';
        {
#line 1601
        fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
        }
        {
#line 1602
        fputs2("\\\n", stream);
        }
#line 1603
        *(logiline->linebuf + logiline->phyline_idx[i + 1]) = c;
        }
      } else {
        {
        {
#line 1606
        fputs2((char const   *)(logiline->linebuf + logiline->phyline_idx[i]), stream);
        }
        }
      }
#line 1597
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1610
  return;
}
}
#line 1612 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static char *get_left_comment_end(char const   *line ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 1615
  tmp = strstr(line, "*/");
  }
  }
#line 1615
  return (tmp);
}
}
#line 1618 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static char *get_right_comment_begin(char const   *line ) 
{ 
  char *p ;
  char *q ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1621
  p = (char *)line;
  {
  {
#line 1624
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1625
    q = strstr((char const   *)p, "*/");
    }
    }
#line 1626
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 1627
      p = q + 2;
    } else {
#line 1629
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1632
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1633
    q = strstr((char const   *)p, "/*");
    }
    }
#line 1634
    if ((unsigned long )q == (unsigned long )((void *)0)) {
      {
      {
#line 1635
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 1635
        tmp = __errno_location();
        }
        {
#line 1635
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1635, *tmp);
        }
        {
#line 1635
        exit(1);
        }
        }
#line 1635
        goto while_break___1;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 1636
    tmp___0 = is_in_quote(p, q);
    }
    }
#line 1636
    if (tmp___0 == 1) {
      {
      {
#line 1638
      p = find_first_quote((char const   *)(q + 2));
      }
      }
#line 1639
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
        {
#line 1640
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error: Invalid source line.\n");
        }
        {
#line 1641
        exit(1);
        }
        }
      } else {
#line 1643
        p ++;
      }
    } else {
#line 1647
      return (q);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1652 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void _stripcc(char const   *src_file , struct list_t *invalid_file_list , struct cc_used_t *comp_results ,
                     int *warning_cc_id ) 
{ 
  struct list_t *tmp_list ;
  FILE *sfp ;
  FILE *tfp ;
  struct logiline_t *logiline ;
  char c ;
  char *p ;
  char *q ;
  char *r ;
  char *s ;
  char *pbak ;
  char *comment_begin ;
  char linebuf[4096] ;
  int cc_type ;
  int comment_begin_in_this_line ;
  int all_line_is_comment ;
  int left_is_comment ;
  int right_is_comment ;
  int defined[64] ;
  int cur_branch[64] ;
  int cur_nest ;
  int is_in_comment ;
  struct cc_used_t *cur_cc[64] ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  struct list_t *tmp___17 ;
  int *tmp___18 ;
  size_t tmp___19 ;
  struct list_t *tmp___20 ;
  struct list_t *tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;

  {
#line 1659
  comment_begin = (char *)((void *)0);
#line 1660
  cur_nest = 0;
#line 1660
  is_in_comment = 0;
#line 1666
  tmp_list = invalid_file_list;
  {
  {
#line 1667
  while (1) {
    while_continue___18: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1667
    if (! ((unsigned long )tmp_list != (unsigned long )((void *)0))) {
#line 1667
      goto while_break;
    }
    {
    {
#line 1668
    tmp = strcmp((char const   *)((char *)tmp_list->data), src_file);
    }
    }
#line 1668
    if (tmp == 0) {
#line 1669
      goto while_break;
    }
#line 1671
    tmp_list = tmp_list->next;
  }
  while_break___18: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1673
  if ((unsigned long )tmp_list != (unsigned long )((void *)0)) {
#line 1675
    if ((comp_results + *warning_cc_id)->flags == 0) {
      {
      {
#line 1677
      sfp = fopen((char const   */* __restrict  */)src_file, (char const   */* __restrict  */)"w");
      }
      }
#line 1678
      if ((unsigned long )sfp == (unsigned long )((void *)0)) {
        {
        {
#line 1679
        while (1) {
          while_continue___19: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
          {
#line 1679
          tmp___0 = __errno_location();
          }
          {
#line 1679
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1679, *tmp___0);
          }
          {
#line 1679
          exit(1);
          }
          }
#line 1679
          goto while_break___0;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
      {
#line 1680
      fclose(sfp);
      }
      }
    } else {
      {
      {
#line 1683
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInvalid source file: %s, ignore it\n",
              src_file);
      }
      }
    }
#line 1685
    (*warning_cc_id) ++;
#line 1686
    return;
  }
  {
  {
#line 1689
  sfp = fopen((char const   */* __restrict  */)src_file, (char const   */* __restrict  */)"r");
  }
  }
#line 1690
  if ((unsigned long )sfp == (unsigned long )((void *)0)) {
    {
    {
#line 1691
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 1691
      tmp___1 = __errno_location();
      }
      {
#line 1691
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1691, *tmp___1);
      }
      {
#line 1691
      exit(1);
      }
      }
#line 1691
      goto while_break___1;
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
  {
#line 1692
  tfp = fopen((char const   */* __restrict  */)"eecbfb859094a362907dfb2f2cd3a8c8.tmp",
              (char const   */* __restrict  */)"w");
  }
  }
#line 1693
  if ((unsigned long )tfp == (unsigned long )((void *)0)) {
    {
    {
#line 1694
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 1694
      tmp___2 = __errno_location();
      }
      {
#line 1694
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1694, *tmp___2);
      }
      {
#line 1694
      exit(1);
      }
      }
#line 1694
      goto while_break___2;
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1697
  cur_cc[cur_nest] = comp_results + *warning_cc_id;
#line 1698
  (*warning_cc_id) ++;
#line 1699
  if ((cur_cc[cur_nest])->flags == 0) {
#line 1701
    defined[cur_nest] = 0;
  } else {
#line 1704
    defined[cur_nest] = 1;
  }
#line 1706
  cur_branch[cur_nest] = 0;
  {
  {
#line 1709
  while (1) {
    while_continue___22: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
    {
    {
#line 1709
    tmp___25 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)sfp);
    }
    }
#line 1709
    if (! ((unsigned long )tmp___25 != (unsigned long )((void *)0))) {
#line 1709
      goto while_break___3;
    }
    {
#line 1710
    logiline = (struct logiline_t *)((void *)0);
#line 1711
    cc_type = 0;
    {
#line 1713
    tmp___4 = strlen((char const   *)(linebuf));
    }
    }
#line 1713
    if (tmp___4 == sizeof(linebuf) - 1UL) {
#line 1713
      if ((int )linebuf[sizeof(linebuf) - 2UL] != 10) {
        {
        {
#line 1716
        while (1) {
          while_continue___23: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
          {
          {
#line 1716
          tmp___3 = __errno_location();
          }
          {
#line 1716
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1716, *tmp___3);
          }
          {
#line 1716
          exit(1);
          }
          }
#line 1716
          goto while_break___4;
        }
        while_break___23: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    {
    {
#line 1719
    while (1) {
      while_continue___24: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
      {
      {
#line 1719
      tmp___9 = is_unterminate_line((char const   *)(linebuf));
      }
      }
#line 1719
      if (! tmp___9) {
#line 1719
        goto while_break___5;
      }
      {
      {
#line 1721
      p = strrchr((char const   *)(linebuf), '\\');
      }
#line 1722
      *p = (char )'\000';
      {
#line 1723
      logiline = build_logiline(logiline, (char const   *)(linebuf));
      }
      {
#line 1724
      tmp___6 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)sfp);
      }
      }
#line 1724
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
        {
        {
#line 1725
        while (1) {
          while_continue___25: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
          {
          {
#line 1725
          tmp___5 = __errno_location();
          }
          {
#line 1725
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1725, *tmp___5);
          }
          {
#line 1725
          exit(1);
          }
          }
#line 1725
          goto while_break___6;
        }
        while_break___25: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
      {
#line 1727
      tmp___8 = strlen((char const   *)(linebuf));
      }
      }
#line 1727
      if (tmp___8 == sizeof(linebuf) - 1UL) {
#line 1727
        if ((int )linebuf[sizeof(linebuf) - 2UL] != 10) {
          {
          {
#line 1730
          while (1) {
            while_continue___26: /* CIL Label */ ;
            while_continue___7: /* CIL Label */ ;
            {
            {
#line 1730
            tmp___7 = __errno_location();
            }
            {
#line 1730
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1730, *tmp___7);
            }
            {
#line 1730
            exit(1);
            }
            }
#line 1730
            goto while_break___7;
          }
          while_break___26: /* CIL Label */ ;
          }
          while_break___7: /* CIL Label */ ;
          }
        }
      }
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1734
    if ((unsigned long )logiline != (unsigned long )((void *)0)) {
      {
      {
#line 1736
      logiline = build_logiline(logiline, (char const   *)(linebuf));
      }
      {
#line 1737
      p = strdup((char const   *)logiline->linebuf);
      }
      }
    } else {
      {
      {
#line 1739
      p = strdup((char const   *)(linebuf));
      }
      }
    }
#line 1741
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
      {
#line 1742
      while (1) {
        while_continue___27: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
        {
        {
#line 1742
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mInsufficient memory.\n");
        }
        {
#line 1742
        exit(1);
        }
        }
#line 1742
        goto while_break___8;
      }
      while_break___27: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 1743
    pbak = p;
#line 1745
    all_line_is_comment = 0;
#line 1746
    right_is_comment = 0;
#line 1747
    if (is_in_comment) {
#line 1748
      comment_begin_in_this_line = 0;
#line 1749
      left_is_comment = 1;
    } else {
#line 1751
      comment_begin_in_this_line = 1;
#line 1752
      left_is_comment = 0;
    }
    {
    {
#line 1754
    while (1) {
      while_continue___28: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 1756
      if (is_in_comment) {
        {
        {
#line 1758
        q = strstr((char const   *)p, "*/");
        }
        }
#line 1759
        if ((unsigned long )q != (unsigned long )((void *)0)) {
          {
          {
#line 1761
          tmp___10 = strlen((char const   *)(q + 2));
          }
          {
#line 1761
          memmove((void *)p, (void const   *)(q + 2), tmp___10 + 1UL);
          }
#line 1762
          is_in_comment = 0;
          }
#line 1763
          goto while_continue___9;
        } else {
#line 1766
          if (comment_begin_in_this_line) {
            {
#line 1769
            *(comment_begin + 0) = (char )' ';
#line 1770
            *(comment_begin + 1) = (char )'\000';
#line 1772
            right_is_comment = 1;
            {
#line 1774
            cc_type = get_line_type((char const   *)pbak);
            }
            }
          } else {
#line 1777
            all_line_is_comment = 1;
          }
#line 1779
          goto while_break___9;
        }
      } else {
#line 1783
        q = p;
        {
        {
#line 1784
        while (1) {
          while_continue___29: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
          {
          {
#line 1785
          r = strstr((char const   *)q, "//");
          }
          }
#line 1786
          if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1787
            goto while_break___10;
          }
          {
          {
#line 1788
          tmp___12 = is_in_quote(q, r);
          }
          }
#line 1788
          if (tmp___12) {
            {
            {
#line 1790
            q = find_first_quote((char const   *)(r + 2));
            }
            }
#line 1791
            if ((unsigned long )q == (unsigned long )((void *)0)) {
              {
              {
#line 1792
              while (1) {
                while_continue___30: /* CIL Label */ ;
                while_continue___11: /* CIL Label */ ;
                {
                {
#line 1792
                tmp___11 = __errno_location();
                }
                {
#line 1792
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                        "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1792,
                        *tmp___11);
                }
                {
#line 1792
                exit(1);
                }
                }
#line 1792
                goto while_break___11;
              }
              while_break___30: /* CIL Label */ ;
              }
              while_break___11: /* CIL Label */ ;
              }
            } else {
#line 1794
              q ++;
            }
          } else {
#line 1797
            goto while_break___10;
          }
        }
        while_break___29: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 1801
        q = p;
        {
        {
#line 1802
        while (1) {
          while_continue___31: /* CIL Label */ ;
          while_continue___12: /* CIL Label */ ;
          {
          {
#line 1803
          s = strstr((char const   *)q, "/*");
          }
          }
#line 1804
          if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1805
            goto while_break___12;
          }
          {
          {
#line 1806
          tmp___14 = is_in_quote(q, s);
          }
          }
#line 1806
          if (tmp___14) {
            {
            {
#line 1808
            q = find_first_quote((char const   *)(s + 2));
            }
            }
#line 1809
            if ((unsigned long )q == (unsigned long )((void *)0)) {
              {
              {
#line 1810
              while (1) {
                while_continue___32: /* CIL Label */ ;
                while_continue___13: /* CIL Label */ ;
                {
                {
#line 1810
                tmp___13 = __errno_location();
                }
                {
#line 1810
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                        "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1810,
                        *tmp___13);
                }
                {
#line 1810
                exit(1);
                }
                }
#line 1810
                goto while_break___13;
              }
              while_break___32: /* CIL Label */ ;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
#line 1812
              q ++;
            }
          } else {
#line 1815
            goto while_break___12;
          }
        }
        while_break___31: /* CIL Label */ ;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1819
        if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 1819
          if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 1820
            if ((unsigned long )r < (unsigned long )s) {
#line 1821
              s = (char *)((void *)0);
            } else {
#line 1823
              r = (char *)((void *)0);
            }
          }
        }
#line 1825
        if ((unsigned long )r != (unsigned long )((void *)0)) {
          {
#line 1827
          *(r + 0) = (char )' ';
#line 1828
          *(r + 1) = (char )'\n';
#line 1829
          *(r + 2) = (char )'\000';
          {
#line 1831
          cc_type = get_line_type((char const   *)pbak);
          }
          }
        } else
#line 1832
        if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 1834
          *(s + 0) = (char )' ';
#line 1835
          *(s + 1) = (char )' ';
#line 1836
          p = s + 2;
#line 1837
          comment_begin_in_this_line = 1;
#line 1838
          comment_begin = s + 0;
#line 1839
          is_in_comment = 1;
#line 1840
          goto while_continue___9;
        } else {
          {
          {
#line 1843
          cc_type = get_line_type((char const   *)pbak);
          }
          }
        }
#line 1845
        goto while_break___9;
      }
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1849
    if (all_line_is_comment) {
#line 1849
      goto _L;
    } else
#line 1849
    if (cc_type == 0) {
#line 1849
      goto _L;
    } else
#line 1849
    if (cc_type == 1) {
#line 1849
      goto _L;
    } else
#line 1849
    if (cc_type == 6) {
      _L: /* CIL Label */ 
#line 1853
      if (defined[cur_nest]) {
#line 1855
        if ((unsigned long )logiline != (unsigned long )((void *)0)) {
          {
          {
#line 1856
          fputs_phyline(logiline, tfp, (char *)((void *)0), (char *)((void *)0));
          }
          }
        } else {
          {
          {
#line 1858
          fputs2((char const   *)(linebuf), tfp);
          }
          }
        }
      }
    } else {
#line 1863
      if (left_is_comment) {
#line 1864
        if (defined[cur_nest]) {
#line 1866
          if ((unsigned long )logiline != (unsigned long )((void *)0)) {
            {
            {
#line 1867
            tmp___15 = get_left_comment_end((char const   *)logiline->linebuf);
            }
            {
#line 1867
            fputs_phyline(logiline, tfp, (char *)((void *)0), tmp___15 + 2);
            }
            }
          } else {
            {
            {
#line 1870
            q = get_left_comment_end((char const   *)(linebuf));
            }
#line 1871
            c = *(q + 2);
#line 1872
            *(q + 2) = (char )'\000';
            {
#line 1873
            fputs2((char const   *)(linebuf), tfp);
            }
#line 1874
            *(q + 2) = c;
            {
#line 1875
            fputs2("\n", tfp);
            }
            }
          }
        }
      }
#line 1880
      if (cc_type == 2) {
#line 1881
        cur_nest ++;
#line 1882
        if (cur_nest >= 64) {
          {
          {
#line 1883
          while (1) {
            while_continue___33: /* CIL Label */ ;
            while_continue___14: /* CIL Label */ ;
            {
            {
#line 1883
            tmp___16 = __errno_location();
            }
            {
#line 1883
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1883, *tmp___16);
            }
            {
#line 1883
            exit(1);
            }
            }
#line 1883
            goto while_break___14;
          }
          while_break___33: /* CIL Label */ ;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
#line 1884
        cur_cc[cur_nest] = comp_results + *warning_cc_id;
#line 1885
        (*warning_cc_id) ++;
#line 1886
        cur_branch[cur_nest] = 0;
#line 1888
        if ((cur_cc[cur_nest])->flags == 0) {
#line 1890
          defined[cur_nest] = 0;
        } else {
          {
          {
#line 1893
          tmp___17 = list_search_item_by_data((cur_cc[cur_nest])->used_branch, (void const   *)((void *)((long )cur_branch[cur_nest])));
          }
          }
#line 1893
          if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 1897
            defined[cur_nest] = 1;
#line 1898
            if ((cur_cc[cur_nest])->flags & (1 << 1)) {
              {
#line 1900
              (cur_cc[cur_nest])->flags |= 1 << 2;
              {
#line 1902
              fputs2((char const   *)pbak, tfp);
              }
              }
            }
          } else {
#line 1906
            defined[cur_nest] = 0;
          }
        }
      } else
#line 1909
      if (cc_type == 3) {
#line 1910
        (cur_branch[cur_nest]) ++;
#line 1912
        if ((cur_cc[cur_nest])->flags != 0) {
          {
          {
#line 1914
          tmp___20 = list_search_item_by_data((cur_cc[cur_nest])->used_branch, (void const   *)((void *)((long )cur_branch[cur_nest])));
          }
          }
#line 1914
          if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
#line 1918
            defined[cur_nest] = 1;
#line 1919
            if ((cur_cc[cur_nest])->flags & (1 << 1)) {
#line 1921
              if ((cur_cc[cur_nest])->flags & (1 << 2)) {
                {
                {
#line 1923
                fputs2((char const   *)pbak, tfp);
                }
                }
              } else {
                {
#line 1926
                (cur_cc[cur_nest])->flags |= 1 << 2;
                {
#line 1927
                p = strstr((char const   *)pbak, "elif");
                }
                }
#line 1928
                if ((unsigned long )p == (unsigned long )((void *)0)) {
                  {
                  {
#line 1929
                  while (1) {
                    while_continue___34: /* CIL Label */ ;
                    while_continue___15: /* CIL Label */ ;
                    {
                    {
#line 1929
                    tmp___18 = __errno_location();
                    }
                    {
#line 1929
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                            "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1929,
                            *tmp___18);
                    }
                    {
#line 1929
                    exit(1);
                    }
                    }
#line 1929
                    goto while_break___15;
                  }
                  while_break___34: /* CIL Label */ ;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                }
                {
                {
#line 1930
                tmp___19 = strlen((char const   *)(p + 2));
                }
                {
#line 1930
                memmove((void *)p, (void const   *)(p + 2), tmp___19 + 1UL);
                }
                {
#line 1931
                fputs2((char const   *)pbak, tfp);
                }
                }
              }
            }
          } else {
#line 1936
            defined[cur_nest] = 0;
          }
        }
      } else
#line 1939
      if (cc_type == 4) {
#line 1940
        (cur_branch[cur_nest]) ++;
#line 1942
        if ((cur_cc[cur_nest])->flags != 0) {
          {
          {
#line 1944
          tmp___21 = list_search_item_by_data((cur_cc[cur_nest])->used_branch, (void const   *)((void *)((long )cur_branch[cur_nest])));
          }
          }
#line 1944
          if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
#line 1948
            defined[cur_nest] = 1;
#line 1949
            if ((cur_cc[cur_nest])->flags & (1 << 1)) {
              {
              {
#line 1951
              fputs2((char const   *)pbak, tfp);
              }
              }
            }
          } else {
#line 1955
            defined[cur_nest] = 0;
          }
        }
      } else
#line 1958
      if (cc_type == 5) {
#line 1959
        if ((cur_cc[cur_nest])->flags != 0) {
#line 1961
          if ((cur_cc[cur_nest])->flags & (1 << 1)) {
            {
            {
#line 1963
            fputs2((char const   *)pbak, tfp);
            }
            }
          }
        }
#line 1966
        cur_nest --;
#line 1967
        if (cur_nest < 0) {
          {
          {
#line 1968
          while (1) {
            while_continue___35: /* CIL Label */ ;
            while_continue___16: /* CIL Label */ ;
            {
            {
#line 1968
            tmp___22 = __errno_location();
            }
            {
#line 1968
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                    "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1968, *tmp___22);
            }
            {
#line 1968
            exit(1);
            }
            }
#line 1968
            goto while_break___16;
          }
          while_break___35: /* CIL Label */ ;
          }
          while_break___16: /* CIL Label */ ;
          }
        }
      }
#line 1971
      if (right_is_comment) {
#line 1972
        if (defined[cur_nest]) {
#line 1974
          if ((unsigned long )logiline != (unsigned long )((void *)0)) {
            {
            {
#line 1975
            tmp___23 = get_right_comment_begin((char const   *)logiline->linebuf);
            }
            {
#line 1975
            fputs_phyline(logiline, tfp, tmp___23, (char *)((void *)0));
            }
            }
          } else {
            {
            {
#line 1978
            tmp___24 = get_right_comment_begin((char const   *)(linebuf));
            }
            {
#line 1978
            fputs2((char const   *)tmp___24, tfp);
            }
            }
          }
        }
      }
    }
    {
    {
#line 1984
    free((void *)pbak);
    }
    }
#line 1985
    if ((unsigned long )logiline != (unsigned long )((void *)0)) {
      {
      {
#line 1986
      logiline_free(logiline);
      }
      }
    }
  }
  while_break___22: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
  {
#line 1990
  fclose(sfp);
  }
  {
#line 1991
  fclose(tfp);
  }
  {
#line 1993
  tmp___27 = rename("eecbfb859094a362907dfb2f2cd3a8c8.tmp", src_file);
  }
  }
#line 1993
  if (tmp___27 == -1) {
    {
    {
#line 1994
    while (1) {
      while_continue___36: /* CIL Label */ ;
      while_continue___17: /* CIL Label */ ;
      {
      {
#line 1994
      tmp___26 = __errno_location();
      }
      {
#line 1994
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 1994, *tmp___26);
      }
      {
#line 1994
      exit(1);
      }
      }
#line 1994
      goto while_break___17;
    }
    while_break___36: /* CIL Label */ ;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
#line 1995
  return;
}
}
#line 1997 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static void stripcc(struct list_t *file_list , struct list_t *invalid_file_list ,
                    struct cc_used_t *comp_results ) 
{ 
  struct list_t *item ;
  int warning_cc_id ;

  {
#line 2002
  warning_cc_id = 0;
#line 2004
  item = file_list;
  {
  {
#line 2005
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 2005
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 2005
      goto while_break;
    }
    {
    {
#line 2006
    _stripcc((char const   *)((char *)item->data), invalid_file_list, comp_results,
             & warning_cc_id);
    }
#line 2008
    item = item->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  return;
}
}
#line 2012 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
static int build(char const   *comp_cmd , char const   *comp_dir ) 
{ 
  pid_t pid ;
  int ret ;
  int null_fd ;
  int status ;
  int count ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  union __anonunion_54 __constr_expr_2 ;
  union __anonunion_55 __constr_expr_3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 2016
  count = 0;
  {
#line 2019
  pid = fork();
  }
  }
#line 2020
  if (pid == -1) {
    {
    {
#line 2022
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 2022
      tmp = __errno_location();
      }
      {
#line 2022
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
              "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 2022, *tmp);
      }
      {
#line 2022
      exit(1);
      }
      }
#line 2022
      goto while_break;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 2023
  if (pid == 0) {
#line 2026
    if ((unsigned long )comp_dir != (unsigned long )((void *)0)) {
      {
      {
#line 2027
      tmp___1 = chdir(comp_dir);
      }
      }
#line 2027
      if (tmp___1 == -1) {
        {
        {
#line 2028
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
          {
          {
#line 2028
          tmp___0 = __errno_location();
          }
          {
#line 2028
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                  "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 2028, *tmp___0);
          }
          {
#line 2028
          _exit(1);
          }
          }
#line 2028
          goto while_break___0;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
    {
#line 2031
    null_fd = open("/dev/null", 2);
    }
    }
#line 2032
    if (null_fd == -1) {
      {
      {
#line 2033
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 2033
        tmp___2 = __errno_location();
        }
        {
#line 2033
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 2033, *tmp___2);
        }
        {
#line 2033
        _exit(1);
        }
        }
#line 2033
        goto while_break___1;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 2034
    dup2(null_fd, 0);
    }
    {
#line 2035
    dup2(null_fd, 1);
    }
    {
#line 2036
    dup2(null_fd, 2);
    }
    {
#line 2037
    close(null_fd);
    }
    {
#line 2039
    execl("/bin/sh", "sh", "-c", comp_cmd, (void *)0);
    }
    {
#line 2040
    _exit(1);
    }
    }
  }
  {
  {
#line 2044
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
    {
    {
#line 2045
    ret = waitpid(pid, & status, 1);
    }
    }
#line 2046
    if (ret == -1) {
      {
      {
#line 2047
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 2047
        tmp___3 = __errno_location();
        }
        {
#line 2047
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\033[31m  o \033[0mUnexpected error(%s: %d), errno = %d\n",
                "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c", 2047, *tmp___3);
        }
        {
#line 2047
        exit(1);
        }
        }
#line 2047
        goto while_break___3;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 2048
    if (ret == 0) {
#line 2050
      count ++;
#line 2051
      if (count % 4 == 0) {
        {
        {
#line 2052
        printf((char const   */* __restrict  */)"\b\b\b   \b\b\b");
        }
        {
#line 2053
        fflush(stdout);
        }
        }
      } else {
        {
        {
#line 2055
        printf((char const   */* __restrict  */)".");
        }
        {
#line 2056
        fflush(stdout);
        }
        }
      }
      {
      {
#line 2058
      sleep(1U);
      }
      }
    } else {
#line 2060
      goto while_break___2;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2063
  __constr_expr_2.__in = status;
#line 2063
  if ((__constr_expr_2.__i & 127) == 0) {
#line 2063
    __constr_expr_3.__in = status;
#line 2063
    if ((__constr_expr_3.__i & 65280) >> 8 == 0) {
#line 2065
      return (0);
    } else {
#line 2067
      return (-1);
    }
  } else {
#line 2067
    return (-1);
  }
}
}
#line 2071 "/home/wslee/tests/SOURCES/stripcc-0.2.0/stripcc.c"
int main(int argc , char **argv ) 
{ 
  int ret ;
  int ncc ;
  int fast_mode ;
  int do_verify ;
  char *comp_cmd ;
  char *comp_dir ;
  struct list_t *file_list ;
  struct list_t *tmp_list ;
  struct list_t *invalid_file_list ;
  struct list_t *main_list ;
  struct cc_used_t *comp_results ;
  time_t t ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 2074
  fast_mode = 0;
#line 2074
  do_verify = 1;
#line 2075
  comp_cmd = (char *)"make";
#line 2075
  comp_dir = (char *)((void *)0);
#line 2076
  invalid_file_list = (struct list_t *)((void *)0);
#line 2076
  main_list = (struct list_t *)((void *)0);
  {
  {
#line 2082
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 2083
    ret = getopt(argc, (char * const  *)argv, "c:m:fnvh");
    }
    }
#line 2084
    if (ret == -1) {
#line 2085
      if ((unsigned long )*(argv + optind) != (unsigned long )((void *)0)) {
        {
        {
#line 2086
        show_help();
        }
        {
#line 2087
        exit(1);
        }
        }
      }
#line 2089
      goto while_break;
    }
    {
#line 2092
    if (ret == 99) {
#line 2092
      goto case_99;
    }
#line 2095
    if (ret == 109) {
#line 2095
      goto case_109;
    }
#line 2098
    if (ret == 110) {
#line 2098
      goto case_110;
    }
#line 2101
    if (ret == 102) {
#line 2101
      goto case_102;
    }
#line 2104
    if (ret == 118) {
#line 2104
      goto case_118;
    }
#line 2107
    if (ret == 104) {
#line 2107
      goto case_104;
    }
#line 2110
    goto switch_default;
    case_99: /* CIL Label */ 
#line 2093
    comp_cmd = optarg;
#line 2094
    goto switch_break;
    case_109: /* CIL Label */ 
#line 2096
    comp_dir = optarg;
#line 2097
    goto switch_break;
    case_110: /* CIL Label */ 
#line 2099
    do_verify = 0;
#line 2100
    goto switch_break;
    case_102: /* CIL Label */ 
#line 2102
    fast_mode = 1;
#line 2103
    goto switch_break;
    case_118: /* CIL Label */ 
    {
    {
#line 2105
    show_ver();
    }
    }
#line 2106
    return (0);
    case_104: /* CIL Label */ 
    {
    {
#line 2108
    show_help();
    }
    }
#line 2109
    return (0);
    switch_default: /* CIL Label */ 
    {
    {
#line 2111
    show_help();
    }
    {
#line 2112
    exit(1);
    }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2116
  printf((char const   */* __restrict  */)"\033[32mo \033[0mGetting a list of files which will be stripped...\n");
  }
  {
#line 2117
  file_list = list_need_strip_files();
  }
  }
#line 2118
  if ((unsigned long )file_list == (unsigned long )((void *)0)) {
    {
    {
#line 2119
    printf((char const   */* __restrict  */)"\033[31m  o \033[0mCouldn\'t get any file.\n");
    }
    }
#line 2120
    return (0);
  }
  {
  {
#line 2133
  printf((char const   */* __restrict  */)"\033[32mo \033[0mBacking up files...\n");
  }
  {
#line 2134
  backup_files(file_list);
  }
  }
  add_warning_cc: 
  {
  {
#line 2137
  printf((char const   */* __restrict  */)"\033[32mo \033[0mAdding \"#warning\"...\n");
  }
  {
#line 2138
  ncc = add_warning_cc_to_files(file_list, fast_mode, & invalid_file_list, & main_list);
  }
  {
#line 2161
  printf((char const   */* __restrict  */)"\033[32mo \033[0mTry to build target, this operation may takes a few minutes");
  }
  {
#line 2162
  fflush(stdout);
  }
  {
#line 2163
  comp_results = try_build_and_parse(fast_mode, (char const   *)comp_cmd, (char const   *)comp_dir,
                                     ncc, & main_list);
  }
  }
#line 2164
  if ((unsigned long )comp_results == (unsigned long )((void *)0)) {
#line 2165
    if (fast_mode) {
      {
      {
#line 2166
      printf((char const   */* __restrict  */)"\n\033[31m  o \033[0mFailed to build target in fast mode, then we\'ll try it in normal mode.\n");
      }
#line 2167
      fast_mode = 0;
      {
#line 2168
      restore_files(file_list, 0);
      }
      }
#line 2169
      if (invalid_file_list) {
        {
        {
#line 2170
        list_free(invalid_file_list, & item_free);
        }
#line 2171
        invalid_file_list = (struct list_t *)((void *)0);
        }
      }
#line 2173
      if (main_list) {
        {
        {
#line 2174
        list_free(main_list, & item_free);
        }
#line 2175
        main_list = (struct list_t *)((void *)0);
        }
      }
      {
      {
#line 2177
      sleep(1U);
      }
      }
#line 2178
      goto add_warning_cc;
    } else {
      {
      {
#line 2180
      printf((char const   */* __restrict  */)"\n\033[31m  o Failed to build target.\033[0m\n");
      }
      {
#line 2181
      exit(1);
      }
      }
    }
  }
  {
  {
#line 2185
  printf((char const   */* __restrict  */)"\n\033[32mo \033[0mRestore files...\n");
  }
  {
#line 2186
  restore_files(file_list, 1);
  }
  {
#line 2188
  printf((char const   */* __restrict  */)"\033[32mo \033[0mStripping files...\n");
  }
  {
#line 2189
  stripcc(file_list, invalid_file_list, comp_results);
  }
  }
#line 2191
  if (do_verify) {
    {
    {
#line 2192
    printf((char const   */* __restrict  */)"\033[32mo \033[0mStart to verify");
    }
    {
#line 2193
    fflush(stdout);
    }
    {
#line 2194
    t = time((time_t *)((void *)0));
    }
    {
#line 2195
    sleep(1U);
    }
    {
#line 2196
    tmp___0 = build((char const   *)comp_cmd, (char const   *)comp_dir);
    }
    }
#line 2196
    if (tmp___0 == -1) {
      {
      {
#line 2197
      printf((char const   */* __restrict  */)"\n");
      }
      {
#line 2198
      printf((char const   */* __restrict  */)"\033[31m  o Failed to verify.\033[0m\n");
      }
      {
#line 2200
      printf((char const   */* __restrict  */)"\033[31m  o The following files were changed during compilation.\033[0m\n");
      }
#line 2202
      tmp_list = file_list;
      }
      {
      {
#line 2203
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 2203
        if (! ((unsigned long )tmp_list != (unsigned long )((void *)0))) {
#line 2203
          goto while_break___0;
        }
        {
        {
#line 2205
        tmp = lstat((char const   */* __restrict  */)((char *)tmp_list->data), (struct stat */* __restrict  */)(& st));
        }
        }
#line 2205
        if (tmp == -1) {
          {
          {
#line 2206
          printf((char const   */* __restrict  */)"\033[31m    %s\033[0m\n", (char *)tmp_list->data);
          }
          }
        } else
#line 2208
        if (st.st_mtim.tv_sec > t) {
          {
          {
#line 2209
          printf((char const   */* __restrict  */)"\033[31m    %s\033[0m\n", (char *)tmp_list->data);
          }
          }
        }
#line 2211
        tmp_list = tmp_list->next;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 2213
      exit(1);
      }
      }
    }
    {
    {
#line 2215
    printf((char const   */* __restrict  */)"\n");
    }
    }
  }
  {
  {
#line 2218
  printf((char const   */* __restrict  */)"\033[32mo Done!\033[0m\n");
  }
  }
#line 2219
  return (0);
}
}
