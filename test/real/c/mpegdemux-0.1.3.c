/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 40 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
struct __anonstruct_mpeg_stream_info_t_8 {
   unsigned long packet_cnt ;
   unsigned long long size ;
};
#line 40 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_stream_info_t_8 mpeg_stream_info_t;
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
struct __anonstruct_mpeg_shdr_t_9 {
   unsigned int size ;
   int fixed ;
   int csps ;
};
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_shdr_t_9 mpeg_shdr_t;
#line 51 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
struct __anonstruct_mpeg_packet_t_10 {
   unsigned int type ;
   unsigned int sid ;
   unsigned int ssid ;
   unsigned int size ;
   unsigned int offset ;
   char have_pts ;
   unsigned long long pts ;
   char have_dts ;
   unsigned long long dts ;
};
#line 51 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_packet_t_10 mpeg_packet_t;
#line 65 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
struct __anonstruct_mpeg_pack_t_11 {
   unsigned int size ;
   unsigned int type ;
   unsigned long long scr ;
   unsigned long mux_rate ;
   unsigned int stuff ;
};
#line 65 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
typedef struct __anonstruct_mpeg_pack_t_11 mpeg_pack_t;
#line 73 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
struct mpeg_demux_t {
   int close ;
   int free ;
   FILE *fp ;
   unsigned long long ofs ;
   unsigned int buf_i ;
   unsigned int buf_n ;
   unsigned char buf[4096] ;
   mpeg_shdr_t shdr ;
   mpeg_packet_t packet ;
   mpeg_pack_t pack ;
   unsigned long shdr_cnt ;
   unsigned long pack_cnt ;
   unsigned long packet_cnt ;
   unsigned long end_cnt ;
   unsigned long skip_cnt ;
   mpeg_stream_info_t streams[256] ;
   mpeg_stream_info_t substreams[256] ;
   void *ext ;
   int (*mpeg_skip)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_pack)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_system_header)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_packet)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_packet_check)(struct mpeg_demux_t *mpeg ) ;
   int (*mpeg_end)(struct mpeg_demux_t *mpeg ) ;
};
#line 73 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
typedef struct mpeg_demux_t mpeg_demux_t;
#line 31 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.h"
struct __anonstruct_mpeg_buffer_t_12 {
   unsigned char *buf ;
   unsigned int cnt ;
   unsigned int max ;
};
#line 31 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.h"
typedef struct __anonstruct_mpeg_buffer_t_12 mpeg_buffer_t;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 108 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
mpeg_demux_t *mpegd_open_fp(mpeg_demux_t *mpeg , FILE *fp___1 , int close ) ;
#line 110
void mpegd_close(mpeg_demux_t *mpeg ) ;
#line 121
int mpegd_set_offset(mpeg_demux_t *mpeg , unsigned long long ofs ) ;
#line 122
int mpegd_parse(mpeg_demux_t *mpeg ) ;
#line 30 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.h"
int mpeg_scan(FILE *inp , FILE *out ) ;
#line 47 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
int par_no_end ;
#line 53
int par_first_pts ;
#line 60
int mpeg_stream_excl(unsigned char sid , unsigned char ssid ) ;
#line 61
int mpeg_packet_check(mpeg_demux_t *mpeg ) ;
#line 62
void mpeg_print_stats(mpeg_demux_t *mpeg , FILE *fp___1 ) ;
#line 35 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static unsigned long long pts1[256]  ;
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static unsigned long long pts2[256]  ;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_system_header(mpeg_demux_t *mpeg ) 
{ 


  {
#line 42
  return (0);
}
}
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_packet(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  int skip ;
  unsigned int sid ;
  unsigned int ssid ;
  unsigned long long ofs ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 53
  sid = mpeg->packet.sid;
#line 54
  ssid = mpeg->packet.ssid;
  {
#line 56
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 56
  if (tmp) {
#line 57
    return (0);
  }
  {
#line 60
  fp___1 = (FILE *)mpeg->ext;
#line 62
  ofs = mpeg->ofs;
  {
#line 64
  tmp___0 = mpegd_set_offset(mpeg, ofs + (unsigned long long )mpeg->packet.size);
  }
  }
#line 64
  if (tmp___0) {
    {
    {
#line 65
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: sid=%02x ssid=%02x incomplete packet\n",
            ofs, sid, ssid);
    }
    }
  }
#line 70
  skip = 0;
#line 72
  if (sid == 189U) {
#line 73
    if (mpeg->substreams[ssid].packet_cnt > 1UL) {
#line 74
      if (! par_first_pts) {
#line 75
        return (0);
      }
#line 78
      if (! mpeg->packet.have_pts) {
#line 79
        return (0);
      }
#line 82
      if (mpeg->packet.pts >= pts2[ssid]) {
#line 83
        return (0);
      }
    }
#line 87
    if (mpeg->packet.pts < pts2[ssid]) {
#line 88
      pts2[ssid] = mpeg->packet.pts;
    }
  } else {
#line 92
    if (mpeg->streams[sid].packet_cnt > 1UL) {
#line 93
      if (! par_first_pts) {
#line 94
        return (0);
      }
#line 97
      if (! mpeg->packet.have_pts) {
#line 98
        return (0);
      }
#line 101
      if (mpeg->packet.pts >= pts1[sid]) {
#line 102
        return (0);
      }
    }
#line 106
    if (mpeg->packet.pts < pts1[sid]) {
#line 107
      pts1[sid] = mpeg->packet.pts;
    }
  }
  {
  {
#line 111
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: sid=%02x",
          ofs, sid);
  }
  }
#line 113
  if (sid == 189U) {
    {
    {
#line 114
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[%02x]",
            ssid);
    }
    }
  } else {
    {
    {
#line 117
    fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)fp___1);
    }
    }
  }
#line 120
  if (mpeg->packet.type == 1U) {
    {
    {
#line 121
    fputs((char const   */* __restrict  */)" MPEG1", (FILE */* __restrict  */)fp___1);
    }
    }
  } else
#line 123
  if (mpeg->packet.type == 2U) {
    {
    {
#line 124
    fputs((char const   */* __restrict  */)" MPEG2", (FILE */* __restrict  */)fp___1);
    }
    }
  } else {
    {
    {
#line 127
    fputs((char const   */* __restrict  */)" UNKWN", (FILE */* __restrict  */)fp___1);
    }
    }
  }
#line 130
  if (mpeg->packet.have_pts) {
    {
    {
#line 131
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" pts=%llu[%.4f]",
            mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0);
    }
    }
  }
  {
  {
#line 136
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp___1);
  }
  {
#line 138
  fflush(fp___1);
  }
  }
#line 140
  return (0);
}
}
#line 143 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_pack(mpeg_demux_t *mpeg ) 
{ 


  {
#line 146
  return (0);
}
}
#line 149 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_end(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 154
  fp___1 = (FILE *)mpeg->ext;
#line 156
  if (! par_no_end) {
    {
    {
#line 157
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: end code\n",
            mpeg->ofs);
    }
    }
  }
#line 160
  return (0);
}
}
#line 163 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
int mpeg_scan(FILE *inp , FILE *out ) 
{ 
  int r ;
  unsigned int i ;
  mpeg_demux_t *mpeg ;

  {
#line 169
  i = 0U;
  {
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 169
    if (! (i < 256U)) {
#line 169
      goto while_break;
    }
#line 170
    pts1[i] = ~ 0ULL;
#line 171
    pts2[i] = ~ 0ULL;
#line 169
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 174
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
  }
#line 175
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 176
    return (1);
  }
  {
#line 179
  mpeg->ext = (void *)out;
#line 181
  mpeg->mpeg_system_header = & mpeg_scan_system_header;
#line 182
  mpeg->mpeg_pack = & mpeg_scan_pack;
#line 183
  mpeg->mpeg_packet = & mpeg_scan_packet;
#line 184
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 185
  mpeg->mpeg_end = & mpeg_scan_end;
  {
#line 187
  r = mpegd_parse(mpeg);
  }
  {
#line 189
  mpeg_print_stats(mpeg, out);
  }
  {
#line 191
  mpegd_close(mpeg);
  }
  }
#line 193
  return (r);
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 260
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.h"
void prt_err(char const   *msg  , ...) ;
#line 42
void prt_msg(char const   *msg  , ...) ;
#line 113 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
int mpegd_skip(mpeg_demux_t *mpeg , unsigned int n ) ;
#line 119
unsigned int mpegd_read(mpeg_demux_t *mpeg , void *buf , unsigned int n ) ;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.h"
void mpeg_buf_clear(mpeg_buffer_t *buf ) ;
#line 44
int mpeg_buf_read(mpeg_buffer_t *buf , mpeg_demux_t *mpeg , unsigned int cnt ) ;
#line 46
int mpeg_buf_write_clear(mpeg_buffer_t *buf , FILE *fp___1 ) ;
#line 30 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.h"
int mpeg_demux(FILE *inp , FILE *out ) ;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
unsigned char par_stream[256] ;
#line 40
unsigned char par_substream[256] ;
#line 51
int par_drop ;
#line 54
int par_dvdac3 ;
#line 55
int par_dvdsub ;
#line 56
char *par_demux_name ;
#line 59
char *mpeg_get_name(char const   *base , unsigned int sid ) ;
#line 63
int mpeg_copy(mpeg_demux_t *mpeg , FILE *fp___1 , unsigned int n ) ;
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static FILE *fp[512]  ;
#line 38 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static mpeg_buffer_t packet  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 44
static int mpeg_demux_copy_spu(mpeg_demux_t *mpeg , FILE *fp___1 , unsigned int cnt ) ;
#line 44 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static unsigned int spucnt  =    0U;
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int half  =    0;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_copy_spu(mpeg_demux_t *mpeg , FILE *fp___1 , unsigned int cnt ) 
{ 
  unsigned int i ;
  unsigned int n ;
  unsigned char buf[8] ;
  unsigned long long pts ;
  void *__cil_tmp8 ;

  {
#line 50
  if (half) {
    {
    {
#line 51
    mpegd_read(mpeg, (void *)(buf), 1U);
    }
    {
#line 52
    fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp___1);
    }
#line 53
    spucnt = (spucnt << 8) + (unsigned int )buf[0];
#line 54
    half = 0;
#line 56
    spucnt -= 2U;
#line 57
    cnt --;
    }
  }
  {
  {
#line 60
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 60
    if (! (cnt > 0U)) {
#line 60
      goto while_break;
    }
#line 61
    if (spucnt == 0U) {
#line 62
      pts = mpeg->packet.pts;
#line 63
      i = 0U;
      {
      {
#line 63
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 63
        if (! (i < 8U)) {
#line 63
          goto while_break___0;
        }
#line 64
        buf[7U - i] = (unsigned char )(pts & 255ULL);
#line 65
        pts >>= 8;
#line 63
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 67
      fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )8, (FILE */* __restrict  */)fp___1);
      }
      }
#line 69
      if (cnt == 1U) {
        {
        {
#line 70
        mpegd_read(mpeg, (void *)(buf), 1U);
        }
        {
#line 71
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp___1);
        }
#line 72
        spucnt = (unsigned int )buf[0];
#line 73
        half = 1;
        }
#line 74
        return (0);
      }
      {
      {
#line 77
      mpegd_read(mpeg, (void *)(buf), 2U);
      }
      {
#line 78
      fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )2, (FILE */* __restrict  */)fp___1);
      }
#line 80
      spucnt = (unsigned int )(((int )buf[0] << 8) + (int )buf[1]);
      }
#line 81
      if (spucnt < 2U) {
#line 82
        return (1);
      }
#line 85
      spucnt -= 2U;
#line 86
      cnt -= 2U;
    }
#line 89
    if (cnt < spucnt) {
#line 89
      n = cnt;
    } else {
#line 89
      n = spucnt;
    }
    {
    {
#line 91
    mpeg_copy(mpeg, fp___1, n);
    }
#line 92
    cnt -= n;
#line 93
    spucnt -= n;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (0);
}
}
#line 99 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static FILE *mpeg_demux_open(mpeg_demux_t *mpeg , unsigned int sid , unsigned int ssid ) 
{ 
  FILE *fp___1 ;
  char *name ;
  unsigned int seq ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 106
  if ((unsigned long )par_demux_name == (unsigned long )((void *)0)) {
#line 107
    fp___1 = (FILE *)mpeg->ext;
  } else {
#line 110
    if (sid == 189U) {
#line 110
      seq = (sid << 8) + ssid;
    } else {
#line 110
      seq = sid;
    }
    {
    {
#line 112
    name = mpeg_get_name((char const   *)par_demux_name, seq);
    }
    {
#line 114
    fp___1 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"wb");
    }
    }
#line 115
    if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
      {
      {
#line 116
      prt_err("can\'t open stream file (%s)\n", name);
      }
      }
#line 118
      if (sid == 189U) {
#line 119
        par_substream[ssid] = (unsigned char )((int )par_substream[ssid] & -2);
      } else {
#line 122
        par_stream[sid] = (unsigned char )((int )par_stream[sid] & -2);
      }
      {
      {
#line 125
      free((void *)name);
      }
      }
#line 127
      return ((FILE *)((void *)0));
    }
    {
    {
#line 130
    free((void *)name);
    }
    }
  }
#line 133
  if (sid == 189U) {
#line 133
    if (par_dvdsub) {
      {
      {
#line 134
      fwrite((void const   */* __restrict  */)"SPU ", (size_t )1, (size_t )4, (FILE */* __restrict  */)fp___1);
      }
      }
    }
  }
#line 137
  return (fp___1);
}
}
#line 140 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_system_header(mpeg_demux_t *mpeg ) 
{ 


  {
#line 143
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_packet(mpeg_demux_t *mpeg ) 
{ 
  unsigned int sid ;
  unsigned int ssid ;
  unsigned int fpi ;
  unsigned int cnt ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 154
  sid = mpeg->packet.sid;
#line 155
  ssid = mpeg->packet.ssid;
  {
#line 157
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 161
  cnt = mpeg->packet.offset;
#line 163
  fpi = sid;
#line 166
  if (sid == 189U) {
#line 167
    fpi = 256U + ssid;
#line 168
    cnt ++;
#line 170
    if (par_dvdac3) {
#line 171
      cnt += 3U;
    }
  }
#line 175
  if (cnt > mpeg->packet.size) {
    {
    {
#line 176
    prt_msg("demux: AC3 packet too small (sid=%02x size=%u)\n", sid, mpeg->packet.size);
    }
    }
#line 180
    return (1);
  }
#line 183
  if ((unsigned long )fp[fpi] == (unsigned long )((void *)0)) {
    {
    {
#line 184
    fp[fpi] = mpeg_demux_open(mpeg, sid, ssid);
    }
    }
#line 185
    if ((unsigned long )fp[fpi] == (unsigned long )((void *)0)) {
#line 186
      return (1);
    }
  }
#line 190
  if (cnt > 0U) {
    {
    {
#line 191
    mpegd_skip(mpeg, cnt);
    }
    }
  }
#line 194
  cnt = mpeg->packet.size - cnt;
#line 196
  if (sid == 189U) {
#line 196
    if (par_dvdsub) {
      {
      {
#line 197
      tmp___0 = mpeg_demux_copy_spu(mpeg, fp[fpi], cnt);
      }
      }
#line 197
      return (tmp___0);
    }
  }
  {
#line 200
  r = 0;
  {
#line 202
  tmp___1 = mpeg_buf_read(& packet, mpeg, cnt);
  }
  }
#line 202
  if (tmp___1) {
    {
    {
#line 203
    prt_msg("demux: incomplete packet (sid=%02x size=%u/%u)\n", sid, packet.cnt, cnt);
    }
    }
#line 207
    if (par_drop) {
      {
      {
#line 208
      mpeg_buf_clear(& packet);
      }
      }
#line 209
      return (1);
    }
#line 212
    r = 1;
  }
  {
  {
#line 215
  tmp___2 = mpeg_buf_write_clear(& packet, fp[fpi]);
  }
  }
#line 215
  if (tmp___2) {
#line 216
    r = 1;
  }
#line 219
  return (r);
}
}
#line 222 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_pack(mpeg_demux_t *mpeg ) 
{ 


  {
#line 225
  return (0);
}
}
#line 228 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_end(mpeg_demux_t *mpeg ) 
{ 


  {
#line 231
  return (0);
}
}
#line 234 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
int mpeg_demux(FILE *inp , FILE *out ) 
{ 
  unsigned int i ;
  int r ;
  mpeg_demux_t *mpeg ;

  {
#line 240
  i = 0U;
  {
  {
#line 240
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i < 512U)) {
#line 240
      goto while_break;
    }
#line 241
    fp[i] = (FILE *)((void *)0);
#line 240
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 244
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
  }
#line 245
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 246
    return (1);
  }
  {
#line 249
  mpeg->mpeg_system_header = & mpeg_demux_system_header;
#line 250
  mpeg->mpeg_pack = & mpeg_demux_pack;
#line 251
  mpeg->mpeg_packet = & mpeg_demux_packet;
#line 252
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 253
  mpeg->mpeg_end = & mpeg_demux_end;
#line 255
  mpeg->ext = (void *)out;
  {
#line 257
  r = mpegd_parse(mpeg);
  }
  {
#line 259
  mpegd_close(mpeg);
  }
#line 261
  i = 0U;
  }
  {
  {
#line 261
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 261
    if (! (i < 512U)) {
#line 261
      goto while_break___0;
    }
#line 262
    if ((unsigned long )fp[i] != (unsigned long )((void *)0)) {
#line 262
      if ((unsigned long )fp[i] != (unsigned long )out) {
        {
        {
#line 263
        fclose(fp[i]);
        }
        }
      }
    }
#line 261
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 267
  return (r);
}
}
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static FILE *fp___0[512]  ;
#line 38 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static mpeg_buffer_t packet___0  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 44
static int mpeg_demux_copy_spu___0(mpeg_demux_t *mpeg , FILE *fp___1 , unsigned int cnt ) ;
#line 44 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static unsigned int spucnt___0  =    0U;
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int half___0  =    0;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_copy_spu___0(mpeg_demux_t *mpeg , FILE *fp___1 , unsigned int cnt ) 
{ 
  unsigned int i ;
  unsigned int n ;
  unsigned char buf[8] ;
  unsigned long long pts ;
  void *__cil_tmp8 ;

  {
#line 50
  if (half___0) {
    {
    {
#line 51
    mpegd_read(mpeg, (void *)(buf), 1U);
    }
    {
#line 52
    fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp___1);
    }
#line 53
    spucnt___0 = (spucnt___0 << 8) + (unsigned int )buf[0];
#line 54
    half___0 = 0;
#line 56
    spucnt___0 -= 2U;
#line 57
    cnt --;
    }
  }
  {
  {
#line 60
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 60
    if (! (cnt > 0U)) {
#line 60
      goto while_break;
    }
#line 61
    if (spucnt___0 == 0U) {
#line 62
      pts = mpeg->packet.pts;
#line 63
      i = 0U;
      {
      {
#line 63
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 63
        if (! (i < 8U)) {
#line 63
          goto while_break___0;
        }
#line 64
        buf[7U - i] = (unsigned char )(pts & 255ULL);
#line 65
        pts >>= 8;
#line 63
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 67
      fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )8, (FILE */* __restrict  */)fp___1);
      }
      }
#line 69
      if (cnt == 1U) {
        {
        {
#line 70
        mpegd_read(mpeg, (void *)(buf), 1U);
        }
        {
#line 71
        fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp___1);
        }
#line 72
        spucnt___0 = (unsigned int )buf[0];
#line 73
        half___0 = 1;
        }
#line 74
        return (0);
      }
      {
      {
#line 77
      mpegd_read(mpeg, (void *)(buf), 2U);
      }
      {
#line 78
      fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )2, (FILE */* __restrict  */)fp___1);
      }
#line 80
      spucnt___0 = (unsigned int )(((int )buf[0] << 8) + (int )buf[1]);
      }
#line 81
      if (spucnt___0 < 2U) {
#line 82
        return (1);
      }
#line 85
      spucnt___0 -= 2U;
#line 86
      cnt -= 2U;
    }
#line 89
    if (cnt < spucnt___0) {
#line 89
      n = cnt;
    } else {
#line 89
      n = spucnt___0;
    }
    {
    {
#line 91
    mpeg_copy(mpeg, fp___1, n);
    }
#line 92
    cnt -= n;
#line 93
    spucnt___0 -= n;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (0);
}
}
#line 99 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static FILE *mpeg_demux_open___0(mpeg_demux_t *mpeg , unsigned int sid , unsigned int ssid ) 
{ 
  FILE *fp___1 ;
  char *name ;
  unsigned int seq ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 106
  if ((unsigned long )par_demux_name == (unsigned long )((void *)0)) {
#line 107
    fp___1 = (FILE *)mpeg->ext;
  } else {
#line 110
    if (sid == 189U) {
#line 110
      seq = (sid << 8) + ssid;
    } else {
#line 110
      seq = sid;
    }
    {
    {
#line 112
    name = mpeg_get_name((char const   *)par_demux_name, seq);
    }
    {
#line 114
    fp___1 = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"wb");
    }
    }
#line 115
    if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
      {
      {
#line 116
      prt_err("can\'t open stream file (%s)\n", name);
      }
      }
#line 118
      if (sid == 189U) {
#line 119
        par_substream[ssid] = (unsigned char )((int )par_substream[ssid] & -2);
      } else {
#line 122
        par_stream[sid] = (unsigned char )((int )par_stream[sid] & -2);
      }
      {
      {
#line 125
      free((void *)name);
      }
      }
#line 127
      return ((FILE *)((void *)0));
    }
    {
    {
#line 130
    free((void *)name);
    }
    }
  }
#line 133
  if (sid == 189U) {
#line 133
    if (par_dvdsub) {
      {
      {
#line 134
      fwrite((void const   */* __restrict  */)"SPU ", (size_t )1, (size_t )4, (FILE */* __restrict  */)fp___1);
      }
      }
    }
  }
#line 137
  return (fp___1);
}
}
#line 140 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_system_header___0(mpeg_demux_t *mpeg ) 
{ 


  {
#line 143
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_packet___0(mpeg_demux_t *mpeg ) 
{ 
  unsigned int sid ;
  unsigned int ssid ;
  unsigned int fpi ;
  unsigned int cnt ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 154
  sid = mpeg->packet.sid;
#line 155
  ssid = mpeg->packet.ssid;
  {
#line 157
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 157
  if (tmp) {
#line 158
    return (0);
  }
#line 161
  cnt = mpeg->packet.offset;
#line 163
  fpi = sid;
#line 166
  if (sid == 189U) {
#line 167
    fpi = 256U + ssid;
#line 168
    cnt ++;
#line 170
    if (par_dvdac3) {
#line 171
      cnt += 3U;
    }
  }
#line 175
  if (cnt > mpeg->packet.size) {
    {
    {
#line 176
    prt_msg("demux: AC3 packet too small (sid=%02x size=%u)\n", sid, mpeg->packet.size);
    }
    }
#line 180
    return (1);
  }
#line 183
  if ((unsigned long )fp___0[fpi] == (unsigned long )((void *)0)) {
    {
    {
#line 184
    fp___0[fpi] = mpeg_demux_open___0(mpeg, sid, ssid);
    }
    }
#line 185
    if ((unsigned long )fp___0[fpi] == (unsigned long )((void *)0)) {
#line 186
      return (1);
    }
  }
#line 190
  if (cnt > 0U) {
    {
    {
#line 191
    mpegd_skip(mpeg, cnt);
    }
    }
  }
#line 194
  cnt = mpeg->packet.size - cnt;
#line 196
  if (sid == 189U) {
#line 196
    if (par_dvdsub) {
      {
      {
#line 197
      tmp___0 = mpeg_demux_copy_spu___0(mpeg, fp___0[fpi], cnt);
      }
      }
#line 197
      return (tmp___0);
    }
  }
  {
#line 200
  r = 0;
  {
#line 202
  tmp___1 = mpeg_buf_read(& packet___0, mpeg, cnt);
  }
  }
#line 202
  if (tmp___1) {
    {
    {
#line 203
    prt_msg("demux: incomplete packet (sid=%02x size=%u/%u)\n", sid, packet___0.cnt,
            cnt);
    }
    }
#line 207
    if (par_drop) {
      {
      {
#line 208
      mpeg_buf_clear(& packet___0);
      }
      }
#line 209
      return (1);
    }
#line 212
    r = 1;
  }
  {
  {
#line 215
  tmp___2 = mpeg_buf_write_clear(& packet___0, fp___0[fpi]);
  }
  }
#line 215
  if (tmp___2) {
#line 216
    r = 1;
  }
#line 219
  return (r);
}
}
#line 222 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_pack___0(mpeg_demux_t *mpeg ) 
{ 


  {
#line 225
  return (0);
}
}
#line 228 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_demux.c"
static int mpeg_demux_end___0(mpeg_demux_t *mpeg ) 
{ 


  {
#line 231
  return (0);
}
}
#line 30 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.h"
int mpeg_list(FILE *inp , FILE *out ) ;
#line 44 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
int par_no_shdr ;
#line 45
int par_no_pack ;
#line 46
int par_no_packet ;
#line 35 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static unsigned long long skip_ofs  =    0ULL;
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static unsigned long skip_cnt  =    0UL;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static void mpeg_list_print_skip(FILE *fp___1 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 42
  if (skip_cnt > 0UL) {
    {
    {
#line 43
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: skip %lu\n",
            skip_ofs, skip_cnt);
    }
#line 45
    skip_cnt = 0UL;
    }
  }
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_skip(mpeg_demux_t *mpeg ) 
{ 


  {
#line 52
  if (skip_cnt == 0UL) {
#line 53
    skip_ofs = mpeg->ofs;
  }
#line 56
  skip_cnt ++;
#line 58
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_system_header(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 66
  if (par_no_shdr) {
#line 67
    return (0);
  }
  {
#line 70
  fp___1 = (FILE *)mpeg->ext;
  {
#line 72
  mpeg_list_print_skip(fp___1);
  }
  {
#line 74
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: system header[%lu]: size=%u fixed=%d csps=%d\n",
          mpeg->ofs, mpeg->shdr_cnt - 1UL, mpeg->shdr.size, mpeg->shdr.fixed, mpeg->shdr.csps);
  }
  }
#line 79
  return (0);
}
}
#line 82 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_packet(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  unsigned int sid ;
  unsigned int ssid ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 88
  if (par_no_packet) {
#line 89
    return (0);
  }
  {
#line 92
  sid = mpeg->packet.sid;
#line 93
  ssid = mpeg->packet.ssid;
  {
#line 95
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 95
  if (tmp) {
#line 96
    return (0);
  }
  {
#line 99
  fp___1 = (FILE *)mpeg->ext;
  {
#line 101
  mpeg_list_print_skip(fp___1);
  }
  {
#line 103
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: packet[%lu]: sid=%02x",
          mpeg->ofs, mpeg->streams[sid].packet_cnt - 1UL, sid);
  }
  }
#line 110
  if (sid == 189U) {
    {
    {
#line 111
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[%02x]",
            ssid);
    }
    }
  } else {
    {
    {
#line 114
    fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)fp___1);
    }
    }
  }
#line 117
  if (mpeg->packet.type == 1U) {
    {
    {
#line 118
    fputs((char const   */* __restrict  */)" MPEG1", (FILE */* __restrict  */)fp___1);
    }
    }
  } else
#line 120
  if (mpeg->packet.type == 2U) {
    {
    {
#line 121
    fputs((char const   */* __restrict  */)" MPEG2", (FILE */* __restrict  */)fp___1);
    }
    }
  } else {
    {
    {
#line 124
    fputs((char const   */* __restrict  */)" UNKWN", (FILE */* __restrict  */)fp___1);
    }
    }
  }
  {
  {
#line 127
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" size=%u",
          mpeg->packet.size);
  }
  }
#line 129
  if (mpeg->packet.have_pts) {
    {
    {
#line 130
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" pts=%llu[%.4f] dts=%llu[%.4f]",
            mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0, mpeg->packet.dts,
            (double )mpeg->packet.dts / 90000.0);
    }
    }
  } else
#line 129
  if (mpeg->packet.have_dts) {
    {
    {
#line 130
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" pts=%llu[%.4f] dts=%llu[%.4f]",
            mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0, mpeg->packet.dts,
            (double )mpeg->packet.dts / 90000.0);
    }
    }
  }
  {
  {
#line 137
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp___1);
  }
  }
#line 139
  return (0);
}
}
#line 142 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_pack(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 147
  if (par_no_pack) {
#line 148
    return (0);
  }
  {
#line 151
  fp___1 = (FILE *)mpeg->ext;
  {
#line 153
  mpeg_list_print_skip(fp___1);
  }
  {
#line 155
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: pack[%lu]: type=%u scr=%llu[%.4f] mux=%lu[%.2f] stuff=%u\n",
          mpeg->ofs, mpeg->pack_cnt - 1UL, mpeg->pack.type, mpeg->pack.scr, (double )mpeg->pack.scr / 90000.0,
          mpeg->pack.mux_rate, 50.0 * (double )mpeg->pack.mux_rate, mpeg->pack.stuff);
  }
  {
#line 163
  fflush(fp___1);
  }
  }
#line 165
  return (0);
}
}
#line 168 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_end(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 173
  if (par_no_end) {
#line 174
    return (0);
  }
  {
#line 177
  fp___1 = (FILE *)mpeg->ext;
  {
#line 179
  mpeg_list_print_skip(fp___1);
  }
  {
#line 181
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: end\n",
          mpeg->ofs);
  }
  }
#line 183
  return (0);
}
}
#line 186 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
int mpeg_list(FILE *inp , FILE *out ) 
{ 
  int r ;
  mpeg_demux_t *mpeg ;

  {
  {
  {
#line 191
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
  }
#line 192
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 193
    return (1);
  }
  {
#line 196
  skip_cnt = 0UL;
#line 197
  skip_ofs = 0ULL;
#line 199
  mpeg->ext = (void *)out;
#line 201
  mpeg->mpeg_skip = & mpeg_list_skip;
#line 202
  mpeg->mpeg_system_header = & mpeg_list_system_header;
#line 203
  mpeg->mpeg_pack = & mpeg_list_pack;
#line 204
  mpeg->mpeg_packet = & mpeg_list_packet;
#line 205
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 206
  mpeg->mpeg_end = & mpeg_list_end;
  {
#line 208
  r = mpegd_parse(mpeg);
  }
  {
#line 210
  mpeg_list_print_skip(out);
  }
  {
#line 212
  mpeg_print_stats(mpeg, out);
  }
  {
#line 214
  mpegd_close(mpeg);
  }
  }
#line 216
  return (r);
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.h"
void mpeg_buf_init(mpeg_buffer_t *buf ) ;
#line 40
void mpeg_buf_free(mpeg_buffer_t *buf ) ;
#line 42
int mpeg_buf_set_max(mpeg_buffer_t *buf , unsigned int max ) ;
#line 43
int mpeg_buf_set_cnt(mpeg_buffer_t *buf , unsigned int cnt ) ;
#line 45
int mpeg_buf_write(mpeg_buffer_t *buf , FILE *fp___1 ) ;
#line 30 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
void mpeg_buf_init(mpeg_buffer_t *buf ) 
{ 


  {
#line 32
  buf->buf = (unsigned char *)((void *)0);
#line 33
  buf->max = 0U;
#line 34
  buf->cnt = 0U;
#line 35
  return;
}
}
#line 37 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
void mpeg_buf_free(mpeg_buffer_t *buf ) 
{ 


  {
  {
  {
#line 39
  free((void *)buf->buf);
  }
#line 41
  buf->buf = (unsigned char *)((void *)0);
#line 42
  buf->cnt = 0U;
#line 43
  buf->max = 0U;
  }
#line 44
  return;
}
}
#line 46 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
void mpeg_buf_clear(mpeg_buffer_t *buf ) 
{ 


  {
#line 48
  buf->cnt = 0U;
#line 49
  return;
}
}
#line 51 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
int mpeg_buf_set_max(mpeg_buffer_t *buf , unsigned int max ) 
{ 
  void *tmp ;

  {
#line 53
  if (buf->max == max) {
#line 54
    return (0);
  }
#line 57
  if (max == 0U) {
    {
    {
#line 58
    free((void *)buf->buf);
    }
#line 59
    buf->max = 0U;
#line 60
    buf->cnt = 0U;
    }
#line 61
    return (0);
  }
  {
  {
#line 64
  tmp = realloc((void *)buf->buf, max);
  }
#line 64
  buf->buf = (unsigned char *)tmp;
  }
#line 65
  if ((unsigned long )buf->buf == (unsigned long )((void *)0)) {
#line 66
    buf->max = 0U;
#line 67
    buf->cnt = 0U;
#line 68
    return (1);
  }
#line 71
  buf->max = max;
#line 73
  if (buf->cnt > max) {
#line 74
    buf->cnt = max;
  }
#line 77
  return (0);
}
}
#line 80 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
int mpeg_buf_set_cnt(mpeg_buffer_t *buf , unsigned int cnt ) 
{ 
  int tmp ;

  {
#line 82
  if (cnt > buf->max) {
    {
    {
#line 83
    tmp = mpeg_buf_set_max(buf, cnt);
    }
    }
#line 83
    if (tmp) {
#line 84
      return (1);
    }
  }
#line 88
  buf->cnt = cnt;
#line 90
  return (0);
}
}
#line 93 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
int mpeg_buf_read(mpeg_buffer_t *buf , mpeg_demux_t *mpeg , unsigned int cnt ) 
{ 
  int tmp ;

  {
  {
  {
#line 95
  tmp = mpeg_buf_set_cnt(buf, cnt);
  }
  }
#line 95
  if (tmp) {
#line 96
    return (1);
  }
  {
  {
#line 99
  buf->cnt = mpegd_read(mpeg, (void *)buf->buf, cnt);
  }
  }
#line 101
  if (buf->cnt != cnt) {
#line 102
    return (1);
  }
#line 105
  return (0);
}
}
#line 108 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
int mpeg_buf_write(mpeg_buffer_t *buf , FILE *fp___1 ) 
{ 
  size_t tmp ;

  {
#line 110
  if (buf->cnt > 0U) {
    {
    {
#line 111
    tmp = fwrite((void const   */* __restrict  */)buf->buf, (size_t )1, buf->cnt,
                 (FILE */* __restrict  */)fp___1);
    }
    }
#line 111
    if (tmp != buf->cnt) {
#line 112
      return (1);
    }
  }
#line 116
  return (0);
}
}
#line 119 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/buffer.c"
int mpeg_buf_write_clear(mpeg_buffer_t *buf , FILE *fp___1 ) 
{ 
  size_t tmp ;

  {
#line 121
  if (buf->cnt > 0U) {
    {
    {
#line 122
    tmp = fwrite((void const   */* __restrict  */)buf->buf, (size_t )1, buf->cnt,
                 (FILE */* __restrict  */)fp___1);
    }
    }
#line 122
    if (tmp != buf->cnt) {
#line 123
      buf->cnt = 0U;
#line 124
      return (1);
    }
  }
#line 128
  buf->cnt = 0U;
#line 130
  return (0);
}
}
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 682 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 109 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.h"
mpeg_demux_t *mpegd_open(mpeg_demux_t *mpeg , char const   *fname ) ;
#line 111
void mpegd_reset_stats(mpeg_demux_t *mpeg ) ;
#line 112
unsigned long mpegd_get_bits(mpeg_demux_t *mpeg , unsigned int i , unsigned int n ) ;
#line 32 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
mpeg_demux_t *mpegd_open_fp(mpeg_demux_t *mpeg , FILE *fp___1 , int close ) 
{ 
  void *tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 34
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
    {
    {
#line 35
    tmp = malloc((size_t )sizeof(mpeg_demux_t ));
    }
#line 35
    mpeg = (mpeg_demux_t *)tmp;
    }
#line 36
    if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 37
      return ((mpeg_demux_t *)((void *)0));
    }
#line 39
    mpeg->free = 1;
  } else {
#line 42
    mpeg->free = 0;
  }
  {
#line 45
  mpeg->fp = fp___1;
#line 46
  mpeg->close = close;
#line 48
  mpeg->ofs = 0ULL;
#line 50
  mpeg->buf_i = 0U;
#line 51
  mpeg->buf_n = 0U;
#line 53
  mpeg->ext = (void *)0;
#line 55
  mpeg->mpeg_skip = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 56
  mpeg->mpeg_system_header = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 57
  mpeg->mpeg_packet = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 58
  mpeg->mpeg_packet_check = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 59
  mpeg->mpeg_pack = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
#line 60
  mpeg->mpeg_end = (int (*)(struct mpeg_demux_t *mpeg ))((void *)0);
  {
#line 62
  mpegd_reset_stats(mpeg);
  }
  }
#line 64
  return (mpeg);
}
}
#line 67 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
mpeg_demux_t *mpegd_open(mpeg_demux_t *mpeg , char const   *fname ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 71
  fp___1 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"rb");
  }
  }
#line 72
  if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
#line 73
    return ((mpeg_demux_t *)((void *)0));
  }
  {
  {
#line 76
  mpeg = mpegd_open_fp(mpeg, fp___1, 1);
  }
  }
#line 78
  return (mpeg);
}
}
#line 81 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
void mpegd_close(mpeg_demux_t *mpeg ) 
{ 


  {
#line 83
  if (mpeg->close) {
    {
    {
#line 84
    fclose(mpeg->fp);
    }
    }
  }
#line 87
  if (mpeg->free) {
    {
    {
#line 88
    free((void *)mpeg);
    }
    }
  }
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
void mpegd_reset_stats(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;

  {
#line 96
  mpeg->shdr_cnt = 0UL;
#line 97
  mpeg->pack_cnt = 0UL;
#line 98
  mpeg->packet_cnt = 0UL;
#line 99
  mpeg->end_cnt = 0UL;
#line 100
  mpeg->skip_cnt = 0UL;
#line 102
  i = 0U;
  {
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < 256U)) {
#line 102
      goto while_break;
    }
#line 103
    mpeg->streams[i].packet_cnt = 0UL;
#line 104
    mpeg->streams[i].size = 0ULL;
#line 105
    mpeg->substreams[i].packet_cnt = 0UL;
#line 106
    mpeg->substreams[i].size = 0ULL;
#line 102
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_buffer_fill(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;
  unsigned int n ;
  size_t r ;

  {
#line 116
  if (mpeg->buf_i > 0U) {
#line 116
    if (mpeg->buf_n > 0U) {
#line 117
      i = 0U;
      {
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 117
        if (! (i < mpeg->buf_n)) {
#line 117
          goto while_break;
        }
#line 118
        mpeg->buf[i] = mpeg->buf[mpeg->buf_i + i];
#line 117
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 122
  mpeg->buf_i = 0U;
#line 124
  n = 4096U - mpeg->buf_n;
#line 126
  if (n > 0U) {
    {
    {
#line 127
    r = fread((void */* __restrict  */)(mpeg->buf + mpeg->buf_n), (size_t )1, n, (FILE */* __restrict  */)mpeg->fp);
    }
    }
#line 128
    if (r < 0U) {
#line 129
      return (1);
    }
#line 132
    mpeg->buf_n += r;
  }
#line 135
  return (0);
}
}
#line 138 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_need_bits(mpeg_demux_t *mpeg , unsigned int n ) 
{ 


  {
#line 141
  n = (n + 7U) / 8U;
#line 143
  if (n > mpeg->buf_n) {
    {
    {
#line 144
    mpegd_buffer_fill(mpeg);
    }
    }
  }
#line 147
  if (n > mpeg->buf_n) {
#line 148
    return (1);
  }
#line 151
  return (0);
}
}
#line 154 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
unsigned long mpegd_get_bits(mpeg_demux_t *mpeg , unsigned int i , unsigned int n ) 
{ 
  unsigned long r ;
  unsigned long v ;
  unsigned long m ;
  unsigned int b_i ;
  unsigned int b_n ;
  unsigned char *buf ;
  int tmp ;

  {
  {
  {
#line 161
  tmp = mpegd_need_bits(mpeg, i + n);
  }
  }
#line 161
  if (tmp) {
#line 162
    return (0UL);
  }
#line 165
  buf = mpeg->buf + mpeg->buf_i;
#line 167
  r = 0UL;
#line 170
  if (((i | n) & 7U) == 0U) {
#line 171
    i /= 8U;
#line 172
    n /= 8U;
    {
    {
#line 173
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 173
      if (! (n > 0U)) {
#line 173
        goto while_break;
      }
#line 174
      r = (r << 8) | (unsigned long )*(buf + i);
#line 175
      i ++;
#line 176
      n --;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 178
    return (r);
  }
  {
  {
#line 182
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (n > 0U)) {
#line 182
      goto while_break___0;
    }
#line 183
    b_n = 8U - (i & 7U);
#line 184
    if (b_n > n) {
#line 185
      b_n = n;
    }
#line 188
    b_i = (8U - (i & 7U)) - b_n;
#line 190
    m = (unsigned long )((1 << b_n) - 1);
#line 191
    v = (unsigned long )((int )*(buf + (i >> 3)) >> b_i) & m;
#line 193
    r = (r << b_n) | v;
#line 195
    i += b_n;
#line 196
    n -= b_n;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  return (r);
}
}
#line 202 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
int mpegd_skip(mpeg_demux_t *mpeg , unsigned int n ) 
{ 
  size_t r ;

  {
#line 206
  mpeg->ofs += (unsigned long long )n;
#line 208
  if (n <= mpeg->buf_n) {
#line 209
    mpeg->buf_i += n;
#line 210
    mpeg->buf_n -= n;
#line 211
    return (0);
  }
#line 214
  n -= mpeg->buf_n;
#line 215
  mpeg->buf_i = 0U;
#line 216
  mpeg->buf_n = 0U;
  {
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 218
    if (! (n > 0U)) {
#line 218
      goto while_break;
    }
#line 219
    if (n <= 4096U) {
      {
      {
#line 220
      r = fread((void */* __restrict  */)(mpeg->buf), (size_t )1, n, (FILE */* __restrict  */)mpeg->fp);
      }
      }
    } else {
      {
      {
#line 223
      r = fread((void */* __restrict  */)(mpeg->buf), (size_t )1, (size_t )4096, (FILE */* __restrict  */)mpeg->fp);
      }
      }
    }
#line 226
    if (r <= 0U) {
#line 227
      return (1);
    }
#line 230
    n -= r;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 236 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
unsigned int mpegd_read(mpeg_demux_t *mpeg , void *buf , unsigned int n ) 
{ 
  unsigned int ret ;
  unsigned int i ;
  unsigned char *tmp ;
  size_t tmp___0 ;

  {
#line 242
  tmp = (unsigned char *)buf;
#line 244
  if (n < mpeg->buf_n) {
#line 244
    i = n;
  } else {
#line 244
    i = mpeg->buf_n;
  }
#line 246
  ret = i;
#line 248
  if (i > 0U) {
    {
    {
#line 249
    memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)(& mpeg->buf[mpeg->buf_i]),
           i);
    }
#line 251
    tmp += i;
#line 252
    mpeg->buf_i += i;
#line 253
    mpeg->buf_n -= i;
#line 254
    n -= i;
    }
  }
#line 257
  if (n > 0U) {
    {
    {
#line 258
    tmp___0 = fread((void */* __restrict  */)tmp, (size_t )1, n, (FILE */* __restrict  */)mpeg->fp);
    }
#line 258
    ret += tmp___0;
    }
  }
#line 261
  mpeg->ofs += (unsigned long long )ret;
#line 263
  return (ret);
}
}
#line 266 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
int mpegd_set_offset(mpeg_demux_t *mpeg , unsigned long long ofs ) 
{ 
  int tmp ;

  {
#line 268
  if (ofs == mpeg->ofs) {
#line 269
    return (0);
  }
#line 272
  if (ofs > mpeg->ofs) {
    {
    {
#line 273
    tmp = mpegd_skip(mpeg, (unsigned int )((unsigned long )(ofs - mpeg->ofs)));
    }
    }
#line 273
    return (tmp);
  }
#line 276
  return (1);
}
}
#line 279 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_seek_header(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 284
    tmp___1 = mpegd_get_bits(mpeg, 0U, 24U);
    }
    }
#line 284
    if (! (tmp___1 != 1UL)) {
#line 284
      goto while_break;
    }
#line 285
    ofs = mpeg->ofs + 1ULL;
#line 287
    if ((unsigned long )mpeg->mpeg_skip != (unsigned long )((void *)0)) {
      {
      {
#line 288
      tmp = (*(mpeg->mpeg_skip))(mpeg);
      }
      }
#line 288
      if (tmp) {
#line 289
        return (1);
      }
    }
    {
    {
#line 293
    tmp___0 = mpegd_set_offset(mpeg, ofs);
    }
    }
#line 293
    if (tmp___0) {
#line 294
      return (1);
    }
#line 297
    (mpeg->skip_cnt) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return (0);
}
}
#line 303 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_system_header(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 308
  tmp = mpegd_get_bits(mpeg, 32U, 16U);
  }
#line 308
  mpeg->shdr.size = (unsigned int )(tmp + 6UL);
  {
#line 310
  tmp___0 = mpegd_get_bits(mpeg, 78U, 1U);
  }
#line 310
  mpeg->shdr.fixed = (int )tmp___0;
  {
#line 311
  tmp___1 = mpegd_get_bits(mpeg, 79U, 1U);
  }
#line 311
  mpeg->shdr.csps = (int )tmp___1;
#line 313
  (mpeg->shdr_cnt) ++;
#line 315
  ofs = mpeg->ofs + (unsigned long long )mpeg->shdr.size;
  }
#line 317
  if ((unsigned long )mpeg->mpeg_system_header != (unsigned long )((void *)0)) {
    {
    {
#line 318
    tmp___2 = (*(mpeg->mpeg_system_header))(mpeg);
    }
    }
#line 318
    if (tmp___2) {
#line 319
      return (1);
    }
  }
  {
  {
#line 323
  mpegd_set_offset(mpeg, ofs);
  }
  }
#line 325
  return (0);
}
}
#line 328 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_packet1(mpeg_demux_t *mpeg , unsigned int i ) 
{ 
  unsigned int val ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  {
#line 334
  mpeg->packet.type = 1U;
  {
#line 336
  tmp___0 = mpegd_get_bits(mpeg, i, 2U);
  }
  }
#line 336
  if (tmp___0 == 1UL) {
#line 337
    i += 16U;
  }
  {
  {
#line 340
  tmp___1 = mpegd_get_bits(mpeg, i, 8U);
  }
#line 340
  val = (unsigned int )tmp___1;
  }
#line 342
  if ((val & 240U) == 32U) {
    {
    {
#line 343
    tmp___2 = mpegd_get_bits(mpeg, i + 4U, 3U);
    }
#line 343
    tmp = (unsigned long long )tmp___2;
    {
#line 344
    tmp___3 = mpegd_get_bits(mpeg, i + 8U, 15U);
    }
#line 344
    tmp = (tmp << 15) | (unsigned long long )tmp___3;
    {
#line 345
    tmp___4 = mpegd_get_bits(mpeg, i + 24U, 15U);
    }
#line 345
    tmp = (tmp << 15) | (unsigned long long )tmp___4;
#line 347
    mpeg->packet.have_pts = (char)1;
#line 348
    mpeg->packet.pts = tmp;
#line 350
    i += 40U;
    }
  } else
#line 352
  if ((val & 240U) == 48U) {
    {
    {
#line 353
    tmp___5 = mpegd_get_bits(mpeg, i + 4U, 3U);
    }
#line 353
    tmp = (unsigned long long )tmp___5;
    {
#line 354
    tmp___6 = mpegd_get_bits(mpeg, i + 8U, 15U);
    }
#line 354
    tmp = (tmp << 15) | (unsigned long long )tmp___6;
    {
#line 355
    tmp___7 = mpegd_get_bits(mpeg, i + 24U, 15U);
    }
#line 355
    tmp = (tmp << 15) | (unsigned long long )tmp___7;
#line 357
    mpeg->packet.have_pts = (char)1;
#line 358
    mpeg->packet.pts = tmp;
    {
#line 360
    tmp___8 = mpegd_get_bits(mpeg, i + 44U, 3U);
    }
#line 360
    tmp = (unsigned long long )tmp___8;
    {
#line 361
    tmp___9 = mpegd_get_bits(mpeg, i + 48U, 15U);
    }
#line 361
    tmp = (tmp << 15) | (unsigned long long )tmp___9;
    {
#line 362
    tmp___10 = mpegd_get_bits(mpeg, i + 64U, 15U);
    }
#line 362
    tmp = (tmp << 15) | (unsigned long long )tmp___10;
#line 364
    mpeg->packet.have_dts = (char)1;
#line 365
    mpeg->packet.dts = tmp;
#line 367
    i += 80U;
    }
  } else
#line 369
  if (val == 15U) {
#line 370
    i += 8U;
  }
#line 373
  mpeg->packet.offset = i / 8U;
#line 375
  return (0);
}
}
#line 378 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_packet2(mpeg_demux_t *mpeg , unsigned int i ) 
{ 
  unsigned int pts_dts_flag ;
  unsigned int cnt ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;

  {
  {
#line 385
  mpeg->packet.type = 2U;
  {
#line 387
  tmp___0 = mpegd_get_bits(mpeg, i + 8U, 2U);
  }
#line 387
  pts_dts_flag = (unsigned int )tmp___0;
  {
#line 388
  tmp___1 = mpegd_get_bits(mpeg, i + 16U, 8U);
  }
#line 388
  cnt = (unsigned int )tmp___1;
  }
#line 390
  if (pts_dts_flag == 2U) {
    {
    {
#line 391
    tmp___5 = mpegd_get_bits(mpeg, i + 24U, 4U);
    }
    }
#line 391
    if (tmp___5 == 2UL) {
      {
      {
#line 392
      tmp___2 = mpegd_get_bits(mpeg, i + 28U, 3U);
      }
#line 392
      tmp = (unsigned long long )tmp___2;
      {
#line 393
      tmp___3 = mpegd_get_bits(mpeg, i + 32U, 15U);
      }
#line 393
      tmp = (tmp << 15) | (unsigned long long )tmp___3;
      {
#line 394
      tmp___4 = mpegd_get_bits(mpeg, i + 48U, 15U);
      }
#line 394
      tmp = (tmp << 15) | (unsigned long long )tmp___4;
#line 396
      mpeg->packet.have_pts = (char)1;
#line 397
      mpeg->packet.pts = tmp;
      }
    }
  } else
#line 400
  if ((pts_dts_flag & 3U) == 3U) {
    {
    {
#line 401
    tmp___9 = mpegd_get_bits(mpeg, i + 24U, 4U);
    }
    }
#line 401
    if (tmp___9 == 3UL) {
      {
      {
#line 402
      tmp___6 = mpegd_get_bits(mpeg, i + 28U, 3U);
      }
#line 402
      tmp = (unsigned long long )tmp___6;
      {
#line 403
      tmp___7 = mpegd_get_bits(mpeg, i + 32U, 15U);
      }
#line 403
      tmp = (tmp << 15) | (unsigned long long )tmp___7;
      {
#line 404
      tmp___8 = mpegd_get_bits(mpeg, i + 48U, 15U);
      }
#line 404
      tmp = (tmp << 15) | (unsigned long long )tmp___8;
#line 406
      mpeg->packet.have_pts = (char)1;
#line 407
      mpeg->packet.pts = tmp;
      }
    }
    {
    {
#line 410
    tmp___13 = mpegd_get_bits(mpeg, i + 64U, 4U);
    }
    }
#line 410
    if (tmp___13 == 1UL) {
      {
      {
#line 411
      tmp___10 = mpegd_get_bits(mpeg, i + 68U, 3U);
      }
#line 411
      tmp = (unsigned long long )tmp___10;
      {
#line 412
      tmp___11 = mpegd_get_bits(mpeg, i + 72U, 15U);
      }
#line 412
      tmp = (tmp << 15) | (unsigned long long )tmp___11;
      {
#line 413
      tmp___12 = mpegd_get_bits(mpeg, i + 88U, 15U);
      }
#line 413
      tmp = (tmp << 15) | (unsigned long long )tmp___12;
#line 415
      mpeg->packet.have_dts = (char)1;
#line 416
      mpeg->packet.dts = tmp;
      }
    }
  }
#line 420
  i += 8U * (cnt + 3U);
#line 422
  mpeg->packet.offset = i / 8U;
#line 424
  return (0);
}
}
#line 427 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_packet(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;
  unsigned int sid ;
  unsigned int ssid ;
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 434
  mpeg->packet.type = 0U;
  {
#line 436
  tmp = mpegd_get_bits(mpeg, 24U, 8U);
  }
#line 436
  sid = (unsigned int )tmp;
#line 437
  ssid = 0U;
#line 439
  mpeg->packet.sid = sid;
#line 440
  mpeg->packet.ssid = ssid;
  {
#line 442
  tmp___0 = mpegd_get_bits(mpeg, 32U, 16U);
  }
#line 442
  mpeg->packet.size = (unsigned int )(tmp___0 + 6UL);
#line 443
  mpeg->packet.offset = 6U;
#line 445
  mpeg->packet.have_pts = (char)0;
#line 446
  mpeg->packet.pts = 0ULL;
#line 448
  mpeg->packet.have_dts = (char)0;
#line 449
  mpeg->packet.dts = 0ULL;
#line 451
  i = 48U;
  }
#line 453
  if (sid >= 192U) {
#line 453
    if (sid < 240U) {
#line 453
      goto _L;
    } else {
#line 453
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 453
  if (sid == 189U) {
    _L: /* CIL Label */ 
    {
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 454
      tmp___1 = mpegd_get_bits(mpeg, i, 8U);
      }
      }
#line 454
      if (! (tmp___1 == 255UL)) {
#line 454
        goto while_break;
      }
#line 455
      if (i > 176U) {
#line 456
        goto while_break;
      }
#line 458
      i += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 461
    tmp___4 = mpegd_get_bits(mpeg, i, 2U);
    }
    }
#line 461
    if (tmp___4 == 2UL) {
      {
      {
#line 462
      tmp___2 = mpegd_parse_packet2(mpeg, i);
      }
      }
#line 462
      if (tmp___2) {
#line 463
        return (1);
      }
    } else {
      {
      {
#line 467
      tmp___3 = mpegd_parse_packet1(mpeg, i);
      }
      }
#line 467
      if (tmp___3) {
#line 468
        return (1);
      }
    }
  } else
#line 472
  if (sid == 190U) {
#line 473
    mpeg->packet.type = 1U;
  }
#line 476
  if (sid == 189U) {
    {
    {
#line 477
    tmp___5 = mpegd_get_bits(mpeg, 8U * mpeg->packet.offset, 8U);
    }
#line 477
    ssid = (unsigned int )tmp___5;
#line 478
    mpeg->packet.ssid = ssid;
    }
  }
#line 481
  if ((unsigned long )mpeg->mpeg_packet_check != (unsigned long )((void *)0)) {
    {
    {
#line 481
    tmp___8 = (*(mpeg->mpeg_packet_check))(mpeg);
    }
    }
#line 481
    if (tmp___8) {
      {
      {
#line 482
      tmp___6 = mpegd_skip(mpeg, 1U);
      }
      }
#line 482
      if (tmp___6) {
#line 483
        return (1);
      }
    } else {
#line 481
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 487
    (mpeg->packet_cnt) ++;
#line 488
    (mpeg->streams[sid].packet_cnt) ++;
#line 489
    mpeg->streams[sid].size += (unsigned long long )(mpeg->packet.size - mpeg->packet.offset);
#line 491
    if (sid == 189U) {
#line 492
      (mpeg->substreams[ssid].packet_cnt) ++;
#line 493
      mpeg->substreams[ssid].size += (unsigned long long )(mpeg->packet.size - mpeg->packet.offset);
    }
#line 496
    ofs = mpeg->ofs + (unsigned long long )mpeg->packet.size;
#line 498
    if ((unsigned long )mpeg->mpeg_packet != (unsigned long )((void *)0)) {
      {
      {
#line 499
      tmp___7 = (*(mpeg->mpeg_packet))(mpeg);
      }
      }
#line 499
      if (tmp___7) {
#line 500
        return (1);
      }
    }
    {
    {
#line 504
    mpegd_set_offset(mpeg, ofs);
    }
    }
  }
#line 507
  return (0);
}
}
#line 510 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_pack(mpeg_demux_t *mpeg ) 
{ 
  unsigned int sid ;
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;

  {
  {
  {
#line 516
  tmp___7 = mpegd_get_bits(mpeg, 32U, 4U);
  }
  }
#line 516
  if (tmp___7 == 2UL) {
    {
#line 517
    mpeg->pack.type = 1U;
    {
#line 518
    tmp = mpegd_get_bits(mpeg, 36U, 3U);
    }
#line 518
    mpeg->pack.scr = (unsigned long long )tmp;
    {
#line 519
    tmp___0 = mpegd_get_bits(mpeg, 40U, 15U);
    }
#line 519
    mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___0;
    {
#line 520
    tmp___1 = mpegd_get_bits(mpeg, 56U, 15U);
    }
#line 520
    mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___1;
    {
#line 521
    mpeg->pack.mux_rate = mpegd_get_bits(mpeg, 73U, 22U);
    }
#line 522
    mpeg->pack.stuff = 0U;
#line 523
    mpeg->pack.size = 12U;
    }
  } else {
    {
    {
#line 525
    tmp___6 = mpegd_get_bits(mpeg, 32U, 2U);
    }
    }
#line 525
    if (tmp___6 == 1UL) {
      {
#line 526
      mpeg->pack.type = 2U;
      {
#line 527
      tmp___2 = mpegd_get_bits(mpeg, 34U, 3U);
      }
#line 527
      mpeg->pack.scr = (unsigned long long )tmp___2;
      {
#line 528
      tmp___3 = mpegd_get_bits(mpeg, 38U, 15U);
      }
#line 528
      mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___3;
      {
#line 529
      tmp___4 = mpegd_get_bits(mpeg, 54U, 15U);
      }
#line 529
      mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___4;
      {
#line 530
      mpeg->pack.mux_rate = mpegd_get_bits(mpeg, 80U, 22U);
      }
      {
#line 531
      tmp___5 = mpegd_get_bits(mpeg, 109U, 3U);
      }
#line 531
      mpeg->pack.stuff = (unsigned int )tmp___5;
#line 532
      mpeg->pack.size = 14U + mpeg->pack.stuff;
      }
    } else {
#line 535
      mpeg->pack.type = 0U;
#line 536
      mpeg->pack.scr = 0ULL;
#line 537
      mpeg->pack.mux_rate = 0UL;
#line 538
      mpeg->pack.size = 4U;
    }
  }
#line 541
  ofs = mpeg->ofs + (unsigned long long )mpeg->pack.size;
#line 543
  (mpeg->pack_cnt) ++;
#line 545
  if ((unsigned long )mpeg->mpeg_pack != (unsigned long )((void *)0)) {
    {
    {
#line 546
    tmp___8 = (*(mpeg->mpeg_pack))(mpeg);
    }
    }
#line 546
    if (tmp___8) {
#line 547
      return (1);
    }
  }
  {
  {
#line 551
  mpegd_set_offset(mpeg, ofs);
  }
  {
#line 553
  mpegd_seek_header(mpeg);
  }
  {
#line 555
  tmp___10 = mpegd_get_bits(mpeg, 0U, 32U);
  }
  }
#line 555
  if (tmp___10 == 443UL) {
    {
    {
#line 556
    tmp___9 = mpegd_parse_system_header(mpeg);
    }
    }
#line 556
    if (tmp___9) {
#line 557
      return (1);
    }
    {
    {
#line 560
    mpegd_seek_header(mpeg);
    }
    }
  }
  {
  {
#line 563
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 563
    tmp___12 = mpegd_get_bits(mpeg, 0U, 24U);
    }
    }
#line 563
    if (! (tmp___12 == 1UL)) {
#line 563
      goto while_break;
    }
    {
    {
#line 564
    tmp___11 = mpegd_get_bits(mpeg, 24U, 8U);
    }
#line 564
    sid = (unsigned int )tmp___11;
    }
#line 566
    if (sid == 186U) {
#line 567
      goto while_break;
    } else
#line 566
    if (sid == 185U) {
#line 567
      goto while_break;
    } else
#line 566
    if (sid == 187U) {
#line 567
      goto while_break;
    } else {
      {
      {
#line 570
      mpegd_parse_packet(mpeg);
      }
      }
    }
    {
    {
#line 573
    mpegd_seek_header(mpeg);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return (0);
}
}
#line 579 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
int mpegd_parse(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  int tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 583
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 584
    tmp = mpegd_seek_header(mpeg);
    }
    }
#line 584
    if (tmp) {
#line 585
      return (0);
    }
    {
    {
#line 588
    tmp___0 = mpegd_get_bits(mpeg, 0U, 32U);
    }
    }
    {
#line 589
    if (tmp___0 == 442UL) {
#line 589
      goto case_442;
    }
#line 595
    if (tmp___0 == 441UL) {
#line 595
      goto case_441;
    }
#line 611
    goto switch_default;
    case_442: /* CIL Label */ 
    {
    {
#line 590
    tmp___1 = mpegd_parse_pack(mpeg);
    }
    }
#line 590
    if (tmp___1) {
#line 591
      return (1);
    }
#line 593
    goto switch_break;
    case_441: /* CIL Label */ 
#line 596
    (mpeg->end_cnt) ++;
#line 598
    ofs = mpeg->ofs + 4ULL;
#line 600
    if ((unsigned long )mpeg->mpeg_end != (unsigned long )((void *)0)) {
      {
      {
#line 601
      tmp___2 = (*(mpeg->mpeg_end))(mpeg);
      }
      }
#line 601
      if (tmp___2) {
#line 602
        return (1);
      }
    }
    {
    {
#line 606
    tmp___3 = mpegd_set_offset(mpeg, ofs);
    }
    }
#line 606
    if (tmp___3) {
#line 607
      return (1);
    }
#line 609
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 612
    ofs = mpeg->ofs + 1ULL;
#line 614
    if ((unsigned long )mpeg->mpeg_skip != (unsigned long )((void *)0)) {
      {
      {
#line 615
      tmp___4 = (*(mpeg->mpeg_skip))(mpeg);
      }
      }
#line 615
      if (tmp___4) {
#line 616
        return (1);
      }
    }
    {
    {
#line 620
    tmp___5 = mpegd_set_offset(mpeg, ofs);
    }
    }
#line 620
    if (tmp___5) {
#line 621
      return (0);
    }
#line 624
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return (0);
}
}
#line 35 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static unsigned long long pts1___0[256]  ;
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static unsigned long long pts2___0[256]  ;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_system_header___0(mpeg_demux_t *mpeg ) 
{ 


  {
#line 42
  return (0);
}
}
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_packet___0(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  int skip ;
  unsigned int sid ;
  unsigned int ssid ;
  unsigned long long ofs ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 53
  sid = mpeg->packet.sid;
#line 54
  ssid = mpeg->packet.ssid;
  {
#line 56
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 56
  if (tmp) {
#line 57
    return (0);
  }
  {
#line 60
  fp___1 = (FILE *)mpeg->ext;
#line 62
  ofs = mpeg->ofs;
  {
#line 64
  tmp___0 = mpegd_set_offset(mpeg, ofs + (unsigned long long )mpeg->packet.size);
  }
  }
#line 64
  if (tmp___0) {
    {
    {
#line 65
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: sid=%02x ssid=%02x incomplete packet\n",
            ofs, sid, ssid);
    }
    }
  }
#line 70
  skip = 0;
#line 72
  if (sid == 189U) {
#line 73
    if (mpeg->substreams[ssid].packet_cnt > 1UL) {
#line 74
      if (! par_first_pts) {
#line 75
        return (0);
      }
#line 78
      if (! mpeg->packet.have_pts) {
#line 79
        return (0);
      }
#line 82
      if (mpeg->packet.pts >= pts2___0[ssid]) {
#line 83
        return (0);
      }
    }
#line 87
    if (mpeg->packet.pts < pts2___0[ssid]) {
#line 88
      pts2___0[ssid] = mpeg->packet.pts;
    }
  } else {
#line 92
    if (mpeg->streams[sid].packet_cnt > 1UL) {
#line 93
      if (! par_first_pts) {
#line 94
        return (0);
      }
#line 97
      if (! mpeg->packet.have_pts) {
#line 98
        return (0);
      }
#line 101
      if (mpeg->packet.pts >= pts1___0[sid]) {
#line 102
        return (0);
      }
    }
#line 106
    if (mpeg->packet.pts < pts1___0[sid]) {
#line 107
      pts1___0[sid] = mpeg->packet.pts;
    }
  }
  {
  {
#line 111
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: sid=%02x",
          ofs, sid);
  }
  }
#line 113
  if (sid == 189U) {
    {
    {
#line 114
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[%02x]",
            ssid);
    }
    }
  } else {
    {
    {
#line 117
    fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)fp___1);
    }
    }
  }
#line 120
  if (mpeg->packet.type == 1U) {
    {
    {
#line 121
    fputs((char const   */* __restrict  */)" MPEG1", (FILE */* __restrict  */)fp___1);
    }
    }
  } else
#line 123
  if (mpeg->packet.type == 2U) {
    {
    {
#line 124
    fputs((char const   */* __restrict  */)" MPEG2", (FILE */* __restrict  */)fp___1);
    }
    }
  } else {
    {
    {
#line 127
    fputs((char const   */* __restrict  */)" UNKWN", (FILE */* __restrict  */)fp___1);
    }
    }
  }
#line 130
  if (mpeg->packet.have_pts) {
    {
    {
#line 131
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" pts=%llu[%.4f]",
            mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0);
    }
    }
  }
  {
  {
#line 136
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp___1);
  }
  {
#line 138
  fflush(fp___1);
  }
  }
#line 140
  return (0);
}
}
#line 143 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_pack___0(mpeg_demux_t *mpeg ) 
{ 


  {
#line 146
  return (0);
}
}
#line 149 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_scan.c"
static int mpeg_scan_end___0(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 154
  fp___1 = (FILE *)mpeg->ext;
#line 156
  if (! par_no_end) {
    {
    {
#line 157
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: end code\n",
            mpeg->ofs);
    }
    }
  }
#line 160
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.h"
void msg_set_level(unsigned int level ) ;
#line 37
unsigned int msg_get_level(void) ;
#line 39
void prt_message(unsigned int level , char const   *msg  , ...) ;
#line 43
void prt_deb(char const   *msg  , ...) ;
#line 32 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
static unsigned int msg_level  =    3U;
#line 35 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
void msg_set_level(unsigned int level ) 
{ 


  {
#line 37
  msg_level = level;
#line 38
  return;
}
}
#line 40 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
unsigned int msg_get_level(void) 
{ 


  {
#line 42
  return (msg_level);
}
}
#line 45 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
void prt_msg_va(unsigned int level , char const   *msg , va_list va ) 
{ 


  {
#line 47
  if (level <= msg_level) {
    {
    {
#line 48
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
             va);
    }
    {
#line 49
    fflush(stderr);
    }
    }
  }
#line 51
  return;
}
}
#line 53 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
void prt_message(unsigned int level , char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 57
  if (level <= msg_level) {
    {
    {
#line 58
    __builtin_va_start(va, msg);
    }
    {
#line 59
    prt_msg_va(level, msg, va);
    }
    {
#line 60
    __builtin_va_end(va);
    }
    }
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
void prt_err(char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 68
  if (0U <= msg_level) {
    {
    {
#line 69
    __builtin_va_start(va, msg);
    }
    {
#line 70
    prt_msg_va(0U, msg, va);
    }
    {
#line 71
    __builtin_va_end(va);
    }
    }
  }
#line 73
  return;
}
}
#line 75 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
void prt_msg(char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 79
  if (1U <= msg_level) {
    {
    {
#line 80
    __builtin_va_start(va, msg);
    }
    {
#line 81
    prt_msg_va(1U, msg, va);
    }
    {
#line 82
    __builtin_va_end(va);
    }
    }
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
void prt_deb(char const   *msg  , ...) 
{ 
  va_list va ;

  {
#line 90
  if (3U <= msg_level) {
    {
    {
#line 91
    __builtin_va_start(va, msg);
    }
    {
#line 92
    prt_msg_va(3U, msg, va);
    }
    {
#line 93
    __builtin_va_end(va);
    }
    }
  }
#line 95
  return;
}
}
#line 30 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.h"
int mpeg_remux(FILE *inp , FILE *out ) ;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
unsigned char par_stream_map[256] ;
#line 42
unsigned char par_substream_map[256] ;
#line 48
int par_empty_pack ;
#line 49
int par_remux_skipped ;
#line 50
int par_split ;
#line 40 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static mpeg_buffer_t shdr  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static mpeg_buffer_t pack  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 42 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static mpeg_buffer_t packet___1  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 44 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static unsigned int sequence  =    0U;
#line 47 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_next_fp(mpeg_demux_t *mpeg ) 
{ 
  char *fname ;
  FILE *fp___1 ;
  char *__cil_tmp4 ;

  {
#line 53
  fp___1 = (FILE *)mpeg->ext;
#line 54
  if ((unsigned long )fp___1 != (unsigned long )((void *)0)) {
    {
    {
#line 55
    fclose(fp___1);
    }
#line 56
    mpeg->ext = (void *)0;
    }
  }
  {
  {
#line 59
  fname = mpeg_get_name((char const   *)par_demux_name, sequence);
  }
  }
#line 60
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 61
    return (1);
  }
  {
#line 64
  sequence ++;
  {
#line 66
  fp___1 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"wb");
  }
  {
#line 68
  free((void *)fname);
  }
  }
#line 70
  if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
#line 71
    return (1);
  }
#line 74
  mpeg->ext = (void *)fp___1;
#line 76
  return (0);
}
}
#line 79 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_skip(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;

  {
#line 82
  if (par_remux_skipped == 0) {
#line 83
    return (0);
  }
  {
  {
#line 86
  tmp = mpeg_copy(mpeg, (FILE *)mpeg->ext, 1U);
  }
  }
#line 86
  if (tmp) {
#line 87
    return (1);
  }
#line 90
  return (0);
}
}
#line 93 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_system_header(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  if (par_no_shdr) {
#line 96
    if (mpeg->shdr_cnt > 1UL) {
#line 97
      return (0);
    }
  }
  {
  {
#line 100
  tmp = mpeg_buf_write_clear(& pack, (FILE *)mpeg->ext);
  }
  }
#line 100
  if (tmp) {
#line 101
    return (1);
  }
  {
  {
#line 104
  tmp___0 = mpeg_buf_read(& shdr, mpeg, mpeg->shdr.size);
  }
  }
#line 104
  if (tmp___0) {
#line 105
    return (1);
  }
  {
  {
#line 108
  tmp___1 = mpeg_buf_write_clear(& shdr, (FILE *)mpeg->ext);
  }
  }
#line 108
  if (tmp___1) {
#line 109
    return (1);
  }
#line 112
  return (0);
}
}
#line 115 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_packet(mpeg_demux_t *mpeg ) 
{ 
  int r ;
  unsigned int sid ;
  unsigned int ssid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 121
  sid = mpeg->packet.sid;
#line 122
  ssid = mpeg->packet.ssid;
  {
#line 124
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 124
  if (tmp) {
#line 125
    return (0);
  }
  {
#line 128
  r = 0;
  {
#line 130
  tmp___0 = mpeg_buf_read(& packet___1, mpeg, mpeg->packet.size);
  }
  }
#line 130
  if (tmp___0) {
    {
    {
#line 131
    prt_msg("remux: incomplete packet (sid=%02x size=%u/%u)\n", sid, packet___1.cnt,
            mpeg->packet.size);
    }
    }
#line 135
    if (par_drop) {
      {
      {
#line 136
      mpeg_buf_clear(& packet___1);
      }
      }
#line 137
      return (1);
    }
#line 140
    r = 1;
  }
#line 143
  if (packet___1.cnt >= 4U) {
#line 144
    *(packet___1.buf + 3) = par_stream_map[sid];
#line 146
    if (sid == 189U) {
#line 146
      if (packet___1.cnt > mpeg->packet.offset) {
#line 147
        *(packet___1.buf + mpeg->packet.offset) = par_substream_map[ssid];
      }
    }
  }
  {
  {
#line 151
  tmp___1 = mpeg_buf_write_clear(& pack, (FILE *)mpeg->ext);
  }
  }
#line 151
  if (tmp___1) {
#line 152
    return (1);
  }
  {
  {
#line 155
  tmp___2 = mpeg_buf_write_clear(& packet___1, (FILE *)mpeg->ext);
  }
  }
#line 155
  if (tmp___2) {
#line 156
    return (1);
  }
#line 159
  return (r);
}
}
#line 162 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_pack(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 165
  tmp = mpeg_buf_read(& pack, mpeg, mpeg->pack.size);
  }
  }
#line 165
  if (tmp) {
#line 166
    return (1);
  }
#line 169
  if (par_empty_pack) {
    {
    {
#line 170
    tmp___0 = mpeg_buf_write_clear(& pack, (FILE *)mpeg->ext);
    }
    }
#line 170
    if (tmp___0) {
#line 171
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_end(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 181
  if (par_no_end) {
#line 182
    return (0);
  }
  {
  {
#line 185
  tmp = mpeg_copy(mpeg, (FILE *)mpeg->ext, 4U);
  }
  }
#line 185
  if (tmp) {
#line 186
    return (1);
  }
#line 189
  if (par_split) {
    {
    {
#line 190
    tmp___0 = mpeg_remux_next_fp(mpeg);
    }
    }
#line 190
    if (tmp___0) {
#line 191
      return (1);
    }
  }
#line 195
  return (0);
}
}
#line 198 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
int mpeg_remux(FILE *inp , FILE *out ) 
{ 
  int r ;
  mpeg_demux_t *mpeg ;
  int tmp ;
  unsigned char buf[4] ;
  void *__cil_tmp7 ;

  {
  {
  {
#line 203
  mpeg = mpegd_open_fp((mpeg_demux_t *)((void *)0), inp, 0);
  }
  }
#line 204
  if ((unsigned long )mpeg == (unsigned long )((void *)0)) {
#line 205
    return (1);
  }
#line 208
  if (par_split) {
    {
#line 209
    mpeg->ext = (void *)0;
#line 210
    sequence = 0U;
    {
#line 212
    tmp = mpeg_remux_next_fp(mpeg);
    }
    }
#line 212
    if (tmp) {
#line 213
      return (1);
    }
  } else {
#line 217
    mpeg->ext = (void *)out;
  }
  {
#line 220
  mpeg->mpeg_skip = & mpeg_remux_skip;
#line 221
  mpeg->mpeg_system_header = & mpeg_remux_system_header;
#line 222
  mpeg->mpeg_pack = & mpeg_remux_pack;
#line 223
  mpeg->mpeg_packet = & mpeg_remux_packet;
#line 224
  mpeg->mpeg_packet_check = & mpeg_packet_check;
#line 225
  mpeg->mpeg_end = & mpeg_remux_end;
  {
#line 227
  mpeg_buf_init(& shdr);
  }
  {
#line 228
  mpeg_buf_init(& pack);
  }
  {
#line 229
  mpeg_buf_init(& packet___1);
  }
  {
#line 231
  r = mpegd_parse(mpeg);
  }
  }
#line 233
  if (par_no_end) {
    {
#line 236
    buf[0] = (unsigned char )((441 >> 24) & 255);
#line 237
    buf[1] = (unsigned char )((441 >> 16) & 255);
#line 238
    buf[2] = (unsigned char )((441 >> 8) & 255);
#line 239
    buf[3] = (unsigned char)185;
    {
#line 241
    fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4, (FILE */* __restrict  */)((FILE *)mpeg->ext));
    }
    }
  }
#line 244
  if (par_split) {
    {
    {
#line 245
    fclose((FILE *)mpeg->ext);
    }
#line 246
    mpeg->ext = (void *)0;
    }
  }
  {
  {
#line 249
  mpegd_close(mpeg);
  }
  {
#line 251
  mpeg_buf_free(& shdr);
  }
  {
#line 252
  mpeg_buf_free(& pack);
  }
  {
#line 253
  mpeg_buf_free(& packet___1);
  }
  }
#line 255
  return (r);
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 188 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
unsigned char par_stream[256]  ;
#line 40 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
unsigned char par_substream[256]  ;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
unsigned char par_stream_map[256]  ;
#line 42 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.h"
unsigned char par_substream_map[256]  ;
#line 52
int par_scan ;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static unsigned int par_mode  =    0U;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static FILE *par_inp  =    (FILE *)((void *)0);
#line 42 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static FILE *par_out  =    (FILE *)((void *)0);
#line 50 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_no_shdr  =    0;
#line 51 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_no_pack  =    0;
#line 52 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_no_packet  =    0;
#line 53 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_no_end  =    0;
#line 54 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_empty_pack  =    0;
#line 55 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_remux_skipped  =    0;
#line 56 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_split  =    0;
#line 57 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_drop  =    1;
#line 58 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_scan  =    0;
#line 59 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_first_pts  =    0;
#line 60 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_dvdac3  =    0;
#line 61 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int par_dvdsub  =    0;
#line 62 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
char *par_demux_name  =    (char *)((void *)0);
#line 63 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
unsigned int par_packet_max  =    0U;
#line 66 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static void prt_help(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 69
  fputs((char const   */* __restrict  */)"usage: mpegdemux [options] [input [output]]\n  -a, --ac3                    Assume DVD AC3 headers in private streams\n  -b, --base-name name         Set the base name for demuxed streams\n  -c, --scan                   Scan the stream [default]\n  -d, --demux                  Demultiplex streams\n  -D, --no-drop                Don\'t drop incomplete packets\n  -e, --no-end                 Don\'t list end codes [no]\n  -E, --empty-packs            Remux empty packs [no]\n  -F, --first-pts              Print packet with lowest PTS [no]\n  -h, --no-system-headers      Don\'t list system headers\n  -i, --invalid id             Select invalid streams [none]\n  -k, --no-packs               Don\'t list packs\n  -K, --remux-skipped          Copy skipped bytes when remuxing [no]\n  -l, --list                   List the stream contents\n  -m, --packet-max-size int    Set the maximum packet size [0]\n  -p, --substream id           Select substreams [none]\n  -P, --substream-map id1 id2  Remap substream id1 to id2\n  -r, --remux                  Copy modified input to output\n  -s, --stream id              Select streams [none]\n  -S, --stream-map id1 id2     Remap stream id1 to id2\n  -t, --no-packets             Don\'t list packets\n  -u, --spu                    Assume DVD subtitles in private streams\n  -x, --split                  Split sequences while remuxing [no]\n",
        (FILE */* __restrict  */)stdout);
  }
  }
#line 95
  return;
}
}
#line 97 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static void prt_version(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 100
  fputs((char const   */* __restrict  */)"mpegdemux version 0.1.3\n\nCopyright (C) 2003-2009 Hampa Hug <hampa@hampa.ch>\n",
        (FILE */* __restrict  */)stdout);
  }
  }
#line 106
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static char *str_clone(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 113
  tmp = strlen(str);
  }
  {
#line 113
  tmp___0 = malloc(tmp + 1U);
  }
#line 113
  ret = (char *)tmp___0;
  }
#line 114
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 115
    return ((char *)((void *)0));
  }
  {
  {
#line 118
  strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
  }
#line 120
  return (ret);
}
}
#line 123 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static int str_isarg(char const   *str , char const   *arg1 , char const   *arg2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 126
  if ((unsigned long )arg1 != (unsigned long )((void *)0)) {
    {
    {
#line 126
    tmp = strcmp(str, arg1);
    }
    }
#line 126
    if (tmp == 0) {
#line 127
      return (1);
    }
  }
#line 130
  if ((unsigned long )arg2 != (unsigned long )((void *)0)) {
    {
    {
#line 130
    tmp___0 = strcmp(str, arg2);
    }
    }
#line 130
    if (tmp___0 == 0) {
#line 131
      return (1);
    }
  }
#line 134
  return (0);
}
}
#line 137 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static char const   *str_skip_white(char const   *str ) 
{ 


  {
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((int const   )*str == 32)) {
#line 140
      if (! ((int const   )*str == 9)) {
#line 140
        goto while_break;
      }
    }
#line 141
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (str);
}
}
#line 147 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static int str_get_streams(char const   *str , unsigned char *stm , unsigned int msk ) 
{ 
  unsigned int i ;
  int incl ;
  char *tmp ;
  unsigned int stm1 ;
  unsigned int stm2 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 155
  incl = 1;
  {
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((int const   )*str != 0)) {
#line 157
      goto while_break;
    }
    {
    {
#line 158
    str = str_skip_white(str);
    }
    }
#line 160
    if ((int const   )*str == 43) {
#line 161
      str ++;
#line 162
      incl = 1;
    } else
#line 164
    if ((int const   )*str == 45) {
#line 165
      str ++;
#line 166
      incl = 0;
    } else {
#line 169
      incl = 1;
    }
    {
    {
#line 172
    tmp___3 = strncmp(str, "all", (size_t )3);
    }
    }
#line 172
    if (tmp___3 == 0) {
#line 173
      str += 3;
#line 174
      stm1 = 0U;
#line 175
      stm2 = 255U;
    } else {
      {
      {
#line 177
      tmp___2 = strncmp(str, "none", (size_t )4);
      }
      }
#line 177
      if (tmp___2 == 0) {
#line 178
        str += 4;
#line 179
        stm1 = 0U;
#line 180
        stm2 = 255U;
#line 181
        incl = ! incl;
      } else {
        {
        {
#line 184
        tmp___0 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
                          0);
        }
#line 184
        stm1 = (unsigned int )tmp___0;
        }
#line 185
        if ((unsigned long )tmp == (unsigned long )str) {
#line 186
          return (1);
        }
#line 189
        str = (char const   *)tmp;
#line 191
        if ((int const   )*str == 45) {
          {
#line 192
          str ++;
          {
#line 193
          tmp___1 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
                            0);
          }
#line 193
          stm2 = (unsigned int )tmp___1;
          }
#line 194
          if ((unsigned long )tmp == (unsigned long )str) {
#line 195
            return (1);
          }
#line 197
          str = (char const   *)tmp;
        } else {
#line 200
          stm2 = stm1;
        }
      }
    }
#line 204
    if (incl) {
#line 205
      i = stm1;
      {
      {
#line 205
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 205
        if (! (i <= stm2)) {
#line 205
          goto while_break___0;
        }
#line 206
        *(stm + i) = (unsigned char )((unsigned int )*(stm + i) | msk);
#line 205
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 210
      i = stm1;
      {
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 210
        if (! (i <= stm2)) {
#line 210
          goto while_break___1;
        }
#line 211
        *(stm + i) = (unsigned char )((unsigned int )*(stm + i) & ~ msk);
#line 210
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 215
    str = str_skip_white(str);
    }
    }
#line 217
    if ((int const   )*str == 47) {
#line 218
      str ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (0);
}
}
#line 225 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
char *mpeg_get_name(char const   *base , unsigned int sid ) 
{ 
  unsigned int n ;
  unsigned int dig ;
  char *ret ;
  void *tmp ;
  char *__cil_tmp7 ;

  {
#line 231
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 232
    base = "stream_##.dat";
  }
#line 235
  n = 0U;
  {
  {
#line 236
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 236
    if (! ((int const   )*(base + n) != 0)) {
#line 236
      goto while_break;
    }
#line 237
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  n ++;
  {
#line 242
  tmp = malloc(n);
  }
#line 242
  ret = (char *)tmp;
  }
#line 243
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 244
    return ((char *)((void *)0));
  }
  {
  {
#line 247
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 247
    if (! (n > 0U)) {
#line 247
      goto while_break___0;
    }
#line 248
    n --;
#line 249
    *(ret + n) = (char )*(base + n);
#line 251
    if ((int )*(ret + n) == 35) {
#line 252
      dig = sid % 16U;
#line 253
      sid /= 16U;
#line 254
      if (dig < 10U) {
#line 255
        *(ret + n) = (char )(48U + dig);
      } else {
#line 258
        *(ret + n) = (char )((97U + dig) - 10U);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 263
  return (ret);
}
}
#line 266 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int mpeg_stream_excl(unsigned char sid , unsigned char ssid ) 
{ 


  {
#line 268
  if (((int )par_stream[sid] & 1) == 0) {
#line 269
    return (1);
  }
#line 272
  if ((int )sid == 189) {
#line 273
    if (((int )par_substream[ssid] & 1) == 0) {
#line 274
      return (1);
    }
  }
#line 278
  return (0);
}
}
#line 282 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int mpeg_packet_check(mpeg_demux_t *mpeg ) 
{ 


  {
#line 284
  if (par_packet_max > 0U) {
#line 284
    if (mpeg->packet.size > par_packet_max) {
#line 285
      return (1);
    }
  }
#line 288
  if ((int )par_stream[mpeg->packet.sid] & 2) {
#line 289
    return (1);
  }
#line 292
  return (0);
}
}
#line 295 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
void mpeg_print_stats(mpeg_demux_t *mpeg , FILE *fp___1 ) 
{ 
  unsigned int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 299
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"System headers: %lu\nPacks:          %lu\nPackets:        %lu\nEnd codes:      %lu\nSkipped:        %lu bytes\n",
          mpeg->shdr_cnt, mpeg->pack_cnt, mpeg->packet_cnt, mpeg->end_cnt, mpeg->skip_cnt);
  }
#line 309
  i = 0U;
  }
  {
  {
#line 309
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < 256U)) {
#line 309
      goto while_break;
    }
#line 310
    if (mpeg->streams[i].packet_cnt > 0UL) {
      {
      {
#line 311
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"Stream %02x:      %lu packets / %llu bytes\n",
              i, mpeg->streams[i].packet_cnt, mpeg->streams[i].size);
      }
      }
    }
#line 309
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  i = 0U;
  {
  {
#line 317
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (i < 256U)) {
#line 317
      goto while_break___0;
    }
#line 318
    if (mpeg->substreams[i].packet_cnt > 0UL) {
      {
      {
#line 319
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"Substream %02x:   %lu packets / %llu bytes\n",
              i, mpeg->substreams[i].packet_cnt, mpeg->substreams[i].size);
      }
      }
    }
#line 317
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 325
  fflush(fp___1);
  }
  }
#line 326
  return;
}
}
#line 328 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int mpeg_copy(mpeg_demux_t *mpeg , FILE *fp___1 , unsigned int n ) 
{ 
  unsigned char buf[4096] ;
  unsigned int i ;
  unsigned int j ;
  size_t tmp ;
  void *__cil_tmp8 ;

  {
  {
  {
#line 333
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 333
    if (! (n > 0U)) {
#line 333
      goto while_break;
    }
#line 334
    if (n < 4096U) {
#line 334
      i = n;
    } else {
#line 334
      i = 4096U;
    }
    {
    {
#line 336
    j = mpegd_read(mpeg, (void *)(buf), i);
    }
    }
#line 338
    if (j > 0U) {
      {
      {
#line 339
      tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, j, (FILE */* __restrict  */)fp___1);
      }
      }
#line 339
      if (tmp != j) {
#line 340
        return (1);
      }
    }
#line 344
    if (i != j) {
#line 345
      return (1);
    }
#line 348
    n -= i;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return (0);
}
}
#line 354 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
int main(int argc , char **argv ) 
{ 
  int argi ;
  unsigned int i ;
  int r ;
  int tmp ;
  int tmp___0 ;
  unsigned int i___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long tmp___5 ;
  unsigned int id1 ;
  unsigned int id2 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned int id1___0 ;
  unsigned int id2___0 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;

  {
#line 360
  if (argc == 2) {
    {
    {
#line 361
    tmp___0 = str_isarg((char const   *)*(argv + 1), (char const   *)((void *)0),
                        "--version");
    }
    }
#line 361
    if (tmp___0) {
      {
      {
#line 362
      prt_version();
      }
      }
#line 363
      return (0);
    } else {
      {
      {
#line 365
      tmp = str_isarg((char const   *)*(argv + 1), (char const   *)((void *)0), "--help");
      }
      }
#line 365
      if (tmp) {
        {
        {
#line 366
        prt_help();
        }
        }
#line 367
        return (0);
      }
    }
  }
#line 371
  i = 0U;
  {
  {
#line 371
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 371
    if (! (i < 256U)) {
#line 371
      goto while_break;
    }
#line 372
    par_stream[i] = (unsigned char)0;
#line 373
    par_substream[i] = (unsigned char)0;
#line 374
    par_stream_map[i] = (unsigned char )i;
#line 375
    par_substream_map[i] = (unsigned char )i;
#line 371
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  argi = 1;
  {
  {
#line 379
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 379
    if (! (argi < argc)) {
#line 379
      goto while_break___0;
    }
    {
    {
#line 380
    tmp___33 = str_isarg((char const   *)*(argv + argi), "-c", "--scan");
    }
    }
#line 380
    if (tmp___33) {
#line 383
      par_mode = 0U;
#line 385
      i___0 = 0U;
      {
      {
#line 385
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 385
        if (! (i___0 < 256U)) {
#line 385
          goto while_break___1;
        }
#line 386
        par_stream[i___0] = (unsigned char )((int )par_stream[i___0] | 1);
#line 387
        par_substream[i___0] = (unsigned char )((int )par_substream[i___0] | 1);
#line 385
        i___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 390
      tmp___32 = str_isarg((char const   *)*(argv + argi), "-l", "--list");
      }
      }
#line 390
      if (tmp___32) {
#line 391
        par_mode = 1U;
      } else {
        {
        {
#line 393
        tmp___31 = str_isarg((char const   *)*(argv + argi), "-r", "--remux");
        }
        }
#line 393
        if (tmp___31) {
#line 394
          par_mode = 2U;
        } else {
          {
          {
#line 396
          tmp___30 = str_isarg((char const   *)*(argv + argi), "-d", "--demux");
          }
          }
#line 396
          if (tmp___30) {
#line 397
            par_mode = 3U;
          } else {
            {
            {
#line 399
            tmp___29 = str_isarg((char const   *)*(argv + argi), "-s", "--stream");
            }
            }
#line 399
            if (tmp___29) {
#line 400
              argi ++;
#line 401
              if (argi >= argc) {
                {
                {
#line 402
                prt_err("%s: missing stream id\n", *(argv + 0));
                }
                }
#line 403
                return (1);
              }
              {
              {
#line 406
              tmp___1 = str_get_streams((char const   *)*(argv + argi), (unsigned char *)(par_stream),
                                        1U);
              }
              }
#line 406
              if (tmp___1) {
                {
                {
#line 407
                prt_err("%s: bad stream id (%s)\n", *(argv + 0), *(argv + argi));
                }
                }
#line 408
                return (1);
              }
            } else {
              {
              {
#line 411
              tmp___28 = str_isarg((char const   *)*(argv + argi), "-p", "--substream");
              }
              }
#line 411
              if (tmp___28) {
#line 412
                argi ++;
#line 413
                if (argi >= argc) {
                  {
                  {
#line 414
                  prt_err("%s: missing substream id\n", *(argv + 0));
                  }
                  }
#line 415
                  return (1);
                }
                {
                {
#line 418
                tmp___2 = str_get_streams((char const   *)*(argv + argi), (unsigned char *)(par_substream),
                                          1U);
                }
                }
#line 418
                if (tmp___2) {
                  {
                  {
#line 419
                  prt_err("%s: bad substream id (%s)\n", *(argv + 0), *(argv + argi));
                  }
                  }
#line 420
                  return (1);
                }
              } else {
                {
                {
#line 423
                tmp___27 = str_isarg((char const   *)*(argv + argi), "-i", "--invalid");
                }
                }
#line 423
                if (tmp___27) {
#line 424
                  argi ++;
#line 425
                  if (argi >= argc) {
                    {
                    {
#line 426
                    prt_err("%s: missing invalid stream id\n", *(argv + 0));
                    }
                    }
#line 427
                    return (1);
                  }
                  {
                  {
#line 430
                  tmp___4 = strcmp((char const   *)*(argv + argi), "-");
                  }
                  }
#line 430
                  if (tmp___4 == 0) {
#line 431
                    i = 0U;
                    {
                    {
#line 431
                    while (1) {
                      while_continue___6: /* CIL Label */ ;
                      while_continue___2: /* CIL Label */ ;
#line 431
                      if (! (i < 256U)) {
#line 431
                        goto while_break___2;
                      }
#line 432
                      if ((int )par_stream[i] & 1) {
#line 433
                        par_stream[i] = (unsigned char )((int )par_stream[i] & -3);
                      } else {
#line 436
                        par_stream[i] = (unsigned char )((int )par_stream[i] | 2);
                      }
#line 431
                      i ++;
                    }
                    while_break___6: /* CIL Label */ ;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
                  } else {
                    {
                    {
#line 441
                    tmp___3 = str_get_streams((char const   *)*(argv + argi), (unsigned char *)(par_stream),
                                              2U);
                    }
                    }
#line 441
                    if (tmp___3) {
                      {
                      {
#line 442
                      prt_err("%s: bad stream id (%s)\n", *(argv + 0), *(argv + argi));
                      }
                      }
#line 443
                      return (1);
                    }
                  }
                } else {
                  {
                  {
#line 447
                  tmp___26 = str_isarg((char const   *)*(argv + argi), "-b", "--base-name");
                  }
                  }
#line 447
                  if (tmp___26) {
#line 448
                    argi ++;
#line 449
                    if (argi >= argc) {
                      {
                      {
#line 450
                      prt_err("%s: missing base name\n", *(argv + 0));
                      }
                      }
#line 451
                      return (1);
                    }
#line 454
                    if ((unsigned long )par_demux_name != (unsigned long )((void *)0)) {
                      {
                      {
#line 455
                      free((void *)par_demux_name);
                      }
                      }
                    }
                    {
                    {
#line 458
                    par_demux_name = str_clone((char const   *)*(argv + argi));
                    }
                    }
                  } else {
                    {
                    {
#line 460
                    tmp___25 = str_isarg((char const   *)*(argv + argi), "-m", "--packet-max-size");
                    }
                    }
#line 460
                    if (tmp___25) {
#line 461
                      argi ++;
#line 462
                      if (argi >= argc) {
                        {
                        {
#line 463
                        prt_err("%s: missing maximum packet size\n", *(argv + 0));
                        }
                        }
#line 464
                        return (1);
                      }
                      {
                      {
#line 467
                      tmp___5 = strtoul((char const   */* __restrict  */)*(argv + argi),
                                        (char **/* __restrict  */)((void *)0), 0);
                      }
#line 467
                      par_packet_max = (unsigned int )tmp___5;
                      }
                    } else {
                      {
                      {
#line 469
                      tmp___24 = str_isarg((char const   *)*(argv + argi), "-S", "--stream-map");
                      }
                      }
#line 469
                      if (tmp___24) {
#line 472
                        if (argi + 2 >= argc) {
                          {
                          {
#line 473
                          prt_err("%s: missing stream id\n", *(argv + 0));
                          }
                          }
#line 474
                          return (1);
                        }
                        {
                        {
#line 477
                        tmp___6 = strtoul((char const   */* __restrict  */)*(argv + (argi + 1)),
                                          (char **/* __restrict  */)((void *)0), 0);
                        }
#line 477
                        id1 = (unsigned int )tmp___6;
                        {
#line 478
                        tmp___7 = strtoul((char const   */* __restrict  */)*(argv + (argi + 2)),
                                          (char **/* __restrict  */)((void *)0), 0);
                        }
#line 478
                        id2 = (unsigned int )tmp___7;
#line 480
                        par_stream_map[id1 & 255U] = (unsigned char )(id2 & 255U);
#line 482
                        argi += 2;
                        }
                      } else {
                        {
                        {
#line 484
                        tmp___23 = str_isarg((char const   *)*(argv + argi), "-P",
                                             "--substream-map");
                        }
                        }
#line 484
                        if (tmp___23) {
#line 487
                          if (argi + 2 >= argc) {
                            {
                            {
#line 488
                            prt_err("%s: missing substream id\n", *(argv + 0));
                            }
                            }
#line 489
                            return (1);
                          }
                          {
                          {
#line 492
                          tmp___8 = strtoul((char const   */* __restrict  */)*(argv + (argi + 1)),
                                            (char **/* __restrict  */)((void *)0),
                                            0);
                          }
#line 492
                          id1___0 = (unsigned int )tmp___8;
                          {
#line 493
                          tmp___9 = strtoul((char const   */* __restrict  */)*(argv + (argi + 2)),
                                            (char **/* __restrict  */)((void *)0),
                                            0);
                          }
#line 493
                          id2___0 = (unsigned int )tmp___9;
#line 495
                          par_substream_map[id1___0 & 255U] = (unsigned char )(id2___0 & 255U);
#line 497
                          argi += 2;
                          }
                        } else {
                          {
                          {
#line 499
                          tmp___22 = str_isarg((char const   *)*(argv + argi), "-x",
                                               "--split");
                          }
                          }
#line 499
                          if (tmp___22) {
#line 500
                            par_split = 1;
                          } else {
                            {
                            {
#line 502
                            tmp___21 = str_isarg((char const   *)*(argv + argi), "-h",
                                                 "--no-system-headers");
                            }
                            }
#line 502
                            if (tmp___21) {
#line 503
                              par_no_shdr = 1;
                            } else {
                              {
                              {
#line 505
                              tmp___20 = str_isarg((char const   *)*(argv + argi),
                                                   "-k", "--no-packs");
                              }
                              }
#line 505
                              if (tmp___20) {
#line 506
                                par_no_pack = 1;
                              } else {
                                {
                                {
#line 508
                                tmp___19 = str_isarg((char const   *)*(argv + argi),
                                                     "-K", "--remux-skipped");
                                }
                                }
#line 508
                                if (tmp___19) {
#line 509
                                  par_remux_skipped = 1;
                                } else {
                                  {
                                  {
#line 511
                                  tmp___18 = str_isarg((char const   *)*(argv + argi),
                                                       "-t", "--no-packets");
                                  }
                                  }
#line 511
                                  if (tmp___18) {
#line 512
                                    par_no_packet = 1;
                                  } else {
                                    {
                                    {
#line 514
                                    tmp___17 = str_isarg((char const   *)*(argv + argi),
                                                         "-e", "--no-end");
                                    }
                                    }
#line 514
                                    if (tmp___17) {
#line 515
                                      par_no_end = 1;
                                    } else {
                                      {
                                      {
#line 517
                                      tmp___16 = str_isarg((char const   *)*(argv + argi),
                                                           "-E", "--empty-packs");
                                      }
                                      }
#line 517
                                      if (tmp___16) {
#line 518
                                        par_empty_pack = 1;
                                      } else {
                                        {
                                        {
#line 520
                                        tmp___15 = str_isarg((char const   *)*(argv + argi),
                                                             "-D", "--no-drop");
                                        }
                                        }
#line 520
                                        if (tmp___15) {
#line 521
                                          par_drop = 0;
                                        } else {
                                          {
                                          {
#line 523
                                          tmp___14 = str_isarg((char const   *)*(argv + argi),
                                                               "-F", "--first-pts");
                                          }
                                          }
#line 523
                                          if (tmp___14) {
#line 524
                                            par_first_pts = 1;
                                          } else {
                                            {
                                            {
#line 526
                                            tmp___13 = str_isarg((char const   *)*(argv + argi),
                                                                 "-a", "--ac3");
                                            }
                                            }
#line 526
                                            if (tmp___13) {
#line 527
                                              par_dvdac3 = 1;
                                            } else {
                                              {
                                              {
#line 529
                                              tmp___12 = str_isarg((char const   *)*(argv + argi),
                                                                   "-u", "--spu");
                                              }
                                              }
#line 529
                                              if (tmp___12) {
#line 530
                                                par_dvdsub = 1;
                                              } else
#line 532
                                              if ((int )*(*(argv + argi) + 0) != 45) {
#line 532
                                                goto _L;
                                              } else
#line 532
                                              if ((int )*(*(argv + argi) + 1) == 0) {
                                                _L: /* CIL Label */ 
#line 533
                                                if ((unsigned long )par_inp == (unsigned long )((void *)0)) {
                                                  {
                                                  {
#line 534
                                                  tmp___10 = strcmp((char const   *)*(argv + argi),
                                                                    "-");
                                                  }
                                                  }
#line 534
                                                  if (tmp___10 == 0) {
#line 535
                                                    par_inp = stdin;
                                                  } else {
                                                    {
                                                    {
#line 538
                                                    par_inp = fopen((char const   */* __restrict  */)*(argv + argi),
                                                                    (char const   */* __restrict  */)"rb");
                                                    }
                                                    }
                                                  }
#line 540
                                                  if ((unsigned long )par_inp == (unsigned long )((void *)0)) {
                                                    {
                                                    {
#line 541
                                                    prt_err("%s: can\'t open input file (%s)\n",
                                                            *(argv + 0), *(argv + argi));
                                                    }
                                                    }
#line 542
                                                    return (1);
                                                  }
                                                } else
#line 545
                                                if ((unsigned long )par_out == (unsigned long )((void *)0)) {
                                                  {
                                                  {
#line 546
                                                  tmp___11 = strcmp((char const   *)*(argv + argi),
                                                                    "-");
                                                  }
                                                  }
#line 546
                                                  if (tmp___11 == 0) {
#line 547
                                                    par_out = stdout;
                                                  } else {
                                                    {
                                                    {
#line 550
                                                    par_out = fopen((char const   */* __restrict  */)*(argv + argi),
                                                                    (char const   */* __restrict  */)"wb");
                                                    }
                                                    }
                                                  }
#line 552
                                                  if ((unsigned long )par_out == (unsigned long )((void *)0)) {
                                                    {
                                                    {
#line 553
                                                    prt_err("%s: can\'t open output file (%s)\n",
                                                            *(argv + 0), *(argv + argi));
                                                    }
                                                    }
#line 554
                                                    return (1);
                                                  }
                                                } else {
                                                  {
                                                  {
#line 558
                                                  prt_err("%s: too many files (%s)\n",
                                                          *(argv + 0), *(argv + argi));
                                                  }
                                                  }
#line 559
                                                  return (1);
                                                }
                                              } else {
                                                {
                                                {
#line 563
                                                prt_err("%s: unknown parameter (%s)\n",
                                                        *(argv + 0), *(argv + argi));
                                                }
                                                }
#line 564
                                                return (1);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 567
    argi ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 571
  if ((unsigned long )par_inp == (unsigned long )((void *)0)) {
#line 572
    par_inp = stdin;
  }
#line 575
  if ((unsigned long )par_out == (unsigned long )((void *)0)) {
#line 576
    par_out = stdout;
  }
  {
#line 580
  if (par_mode == 0U) {
#line 580
    goto case_0;
  }
#line 584
  if (par_mode == 1U) {
#line 584
    goto case_1;
  }
#line 588
  if (par_mode == 2U) {
#line 588
    goto case_2;
  }
#line 592
  if (par_mode == 3U) {
#line 592
    goto case_3;
  }
#line 596
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 581
  r = mpeg_scan(par_inp, par_out);
  }
  }
#line 582
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 585
  r = mpeg_list(par_inp, par_out);
  }
  }
#line 586
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 589
  r = mpeg_remux(par_inp, par_out);
  }
  }
#line 590
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 593
  r = mpeg_demux(par_inp, par_out);
  }
  }
#line 594
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 597
  r = 1;
#line 598
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 601
  if (r) {
#line 602
    return (1);
  }
#line 605
  return (0);
}
}
#line 110 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_buffer_fill___0(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;
  unsigned int n ;
  size_t r ;

  {
#line 116
  if (mpeg->buf_i > 0U) {
#line 116
    if (mpeg->buf_n > 0U) {
#line 117
      i = 0U;
      {
      {
#line 117
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 117
        if (! (i < mpeg->buf_n)) {
#line 117
          goto while_break;
        }
#line 118
        mpeg->buf[i] = mpeg->buf[mpeg->buf_i + i];
#line 117
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 122
  mpeg->buf_i = 0U;
#line 124
  n = 4096U - mpeg->buf_n;
#line 126
  if (n > 0U) {
    {
    {
#line 127
    r = fread((void */* __restrict  */)(mpeg->buf + mpeg->buf_n), (size_t )1, n, (FILE */* __restrict  */)mpeg->fp);
    }
    }
#line 128
    if (r < 0U) {
#line 129
      return (1);
    }
#line 132
    mpeg->buf_n += r;
  }
#line 135
  return (0);
}
}
#line 138 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_need_bits___0(mpeg_demux_t *mpeg , unsigned int n ) 
{ 


  {
#line 141
  n = (n + 7U) / 8U;
#line 143
  if (n > mpeg->buf_n) {
    {
    {
#line 144
    mpegd_buffer_fill___0(mpeg);
    }
    }
  }
#line 147
  if (n > mpeg->buf_n) {
#line 148
    return (1);
  }
#line 151
  return (0);
}
}
#line 279 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_seek_header___0(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  {
  {
#line 284
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 284
    tmp___1 = mpegd_get_bits(mpeg, 0U, 24U);
    }
    }
#line 284
    if (! (tmp___1 != 1UL)) {
#line 284
      goto while_break;
    }
#line 285
    ofs = mpeg->ofs + 1ULL;
#line 287
    if ((unsigned long )mpeg->mpeg_skip != (unsigned long )((void *)0)) {
      {
      {
#line 288
      tmp = (*(mpeg->mpeg_skip))(mpeg);
      }
      }
#line 288
      if (tmp) {
#line 289
        return (1);
      }
    }
    {
    {
#line 293
    tmp___0 = mpegd_set_offset(mpeg, ofs);
    }
    }
#line 293
    if (tmp___0) {
#line 294
      return (1);
    }
#line 297
    (mpeg->skip_cnt) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  return (0);
}
}
#line 303 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_system_header___0(mpeg_demux_t *mpeg ) 
{ 
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 308
  tmp = mpegd_get_bits(mpeg, 32U, 16U);
  }
#line 308
  mpeg->shdr.size = (unsigned int )(tmp + 6UL);
  {
#line 310
  tmp___0 = mpegd_get_bits(mpeg, 78U, 1U);
  }
#line 310
  mpeg->shdr.fixed = (int )tmp___0;
  {
#line 311
  tmp___1 = mpegd_get_bits(mpeg, 79U, 1U);
  }
#line 311
  mpeg->shdr.csps = (int )tmp___1;
#line 313
  (mpeg->shdr_cnt) ++;
#line 315
  ofs = mpeg->ofs + (unsigned long long )mpeg->shdr.size;
  }
#line 317
  if ((unsigned long )mpeg->mpeg_system_header != (unsigned long )((void *)0)) {
    {
    {
#line 318
    tmp___2 = (*(mpeg->mpeg_system_header))(mpeg);
    }
    }
#line 318
    if (tmp___2) {
#line 319
      return (1);
    }
  }
  {
  {
#line 323
  mpegd_set_offset(mpeg, ofs);
  }
  }
#line 325
  return (0);
}
}
#line 328 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_packet1___0(mpeg_demux_t *mpeg , unsigned int i ) 
{ 
  unsigned int val ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  {
#line 334
  mpeg->packet.type = 1U;
  {
#line 336
  tmp___0 = mpegd_get_bits(mpeg, i, 2U);
  }
  }
#line 336
  if (tmp___0 == 1UL) {
#line 337
    i += 16U;
  }
  {
  {
#line 340
  tmp___1 = mpegd_get_bits(mpeg, i, 8U);
  }
#line 340
  val = (unsigned int )tmp___1;
  }
#line 342
  if ((val & 240U) == 32U) {
    {
    {
#line 343
    tmp___2 = mpegd_get_bits(mpeg, i + 4U, 3U);
    }
#line 343
    tmp = (unsigned long long )tmp___2;
    {
#line 344
    tmp___3 = mpegd_get_bits(mpeg, i + 8U, 15U);
    }
#line 344
    tmp = (tmp << 15) | (unsigned long long )tmp___3;
    {
#line 345
    tmp___4 = mpegd_get_bits(mpeg, i + 24U, 15U);
    }
#line 345
    tmp = (tmp << 15) | (unsigned long long )tmp___4;
#line 347
    mpeg->packet.have_pts = (char)1;
#line 348
    mpeg->packet.pts = tmp;
#line 350
    i += 40U;
    }
  } else
#line 352
  if ((val & 240U) == 48U) {
    {
    {
#line 353
    tmp___5 = mpegd_get_bits(mpeg, i + 4U, 3U);
    }
#line 353
    tmp = (unsigned long long )tmp___5;
    {
#line 354
    tmp___6 = mpegd_get_bits(mpeg, i + 8U, 15U);
    }
#line 354
    tmp = (tmp << 15) | (unsigned long long )tmp___6;
    {
#line 355
    tmp___7 = mpegd_get_bits(mpeg, i + 24U, 15U);
    }
#line 355
    tmp = (tmp << 15) | (unsigned long long )tmp___7;
#line 357
    mpeg->packet.have_pts = (char)1;
#line 358
    mpeg->packet.pts = tmp;
    {
#line 360
    tmp___8 = mpegd_get_bits(mpeg, i + 44U, 3U);
    }
#line 360
    tmp = (unsigned long long )tmp___8;
    {
#line 361
    tmp___9 = mpegd_get_bits(mpeg, i + 48U, 15U);
    }
#line 361
    tmp = (tmp << 15) | (unsigned long long )tmp___9;
    {
#line 362
    tmp___10 = mpegd_get_bits(mpeg, i + 64U, 15U);
    }
#line 362
    tmp = (tmp << 15) | (unsigned long long )tmp___10;
#line 364
    mpeg->packet.have_dts = (char)1;
#line 365
    mpeg->packet.dts = tmp;
#line 367
    i += 80U;
    }
  } else
#line 369
  if (val == 15U) {
#line 370
    i += 8U;
  }
#line 373
  mpeg->packet.offset = i / 8U;
#line 375
  return (0);
}
}
#line 378 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_packet2___0(mpeg_demux_t *mpeg , unsigned int i ) 
{ 
  unsigned int pts_dts_flag ;
  unsigned int cnt ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;

  {
  {
#line 385
  mpeg->packet.type = 2U;
  {
#line 387
  tmp___0 = mpegd_get_bits(mpeg, i + 8U, 2U);
  }
#line 387
  pts_dts_flag = (unsigned int )tmp___0;
  {
#line 388
  tmp___1 = mpegd_get_bits(mpeg, i + 16U, 8U);
  }
#line 388
  cnt = (unsigned int )tmp___1;
  }
#line 390
  if (pts_dts_flag == 2U) {
    {
    {
#line 391
    tmp___5 = mpegd_get_bits(mpeg, i + 24U, 4U);
    }
    }
#line 391
    if (tmp___5 == 2UL) {
      {
      {
#line 392
      tmp___2 = mpegd_get_bits(mpeg, i + 28U, 3U);
      }
#line 392
      tmp = (unsigned long long )tmp___2;
      {
#line 393
      tmp___3 = mpegd_get_bits(mpeg, i + 32U, 15U);
      }
#line 393
      tmp = (tmp << 15) | (unsigned long long )tmp___3;
      {
#line 394
      tmp___4 = mpegd_get_bits(mpeg, i + 48U, 15U);
      }
#line 394
      tmp = (tmp << 15) | (unsigned long long )tmp___4;
#line 396
      mpeg->packet.have_pts = (char)1;
#line 397
      mpeg->packet.pts = tmp;
      }
    }
  } else
#line 400
  if ((pts_dts_flag & 3U) == 3U) {
    {
    {
#line 401
    tmp___9 = mpegd_get_bits(mpeg, i + 24U, 4U);
    }
    }
#line 401
    if (tmp___9 == 3UL) {
      {
      {
#line 402
      tmp___6 = mpegd_get_bits(mpeg, i + 28U, 3U);
      }
#line 402
      tmp = (unsigned long long )tmp___6;
      {
#line 403
      tmp___7 = mpegd_get_bits(mpeg, i + 32U, 15U);
      }
#line 403
      tmp = (tmp << 15) | (unsigned long long )tmp___7;
      {
#line 404
      tmp___8 = mpegd_get_bits(mpeg, i + 48U, 15U);
      }
#line 404
      tmp = (tmp << 15) | (unsigned long long )tmp___8;
#line 406
      mpeg->packet.have_pts = (char)1;
#line 407
      mpeg->packet.pts = tmp;
      }
    }
    {
    {
#line 410
    tmp___13 = mpegd_get_bits(mpeg, i + 64U, 4U);
    }
    }
#line 410
    if (tmp___13 == 1UL) {
      {
      {
#line 411
      tmp___10 = mpegd_get_bits(mpeg, i + 68U, 3U);
      }
#line 411
      tmp = (unsigned long long )tmp___10;
      {
#line 412
      tmp___11 = mpegd_get_bits(mpeg, i + 72U, 15U);
      }
#line 412
      tmp = (tmp << 15) | (unsigned long long )tmp___11;
      {
#line 413
      tmp___12 = mpegd_get_bits(mpeg, i + 88U, 15U);
      }
#line 413
      tmp = (tmp << 15) | (unsigned long long )tmp___12;
#line 415
      mpeg->packet.have_dts = (char)1;
#line 416
      mpeg->packet.dts = tmp;
      }
    }
  }
#line 420
  i += 8U * (cnt + 3U);
#line 422
  mpeg->packet.offset = i / 8U;
#line 424
  return (0);
}
}
#line 427 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_packet___0(mpeg_demux_t *mpeg ) 
{ 
  unsigned int i ;
  unsigned int sid ;
  unsigned int ssid ;
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 434
  mpeg->packet.type = 0U;
  {
#line 436
  tmp = mpegd_get_bits(mpeg, 24U, 8U);
  }
#line 436
  sid = (unsigned int )tmp;
#line 437
  ssid = 0U;
#line 439
  mpeg->packet.sid = sid;
#line 440
  mpeg->packet.ssid = ssid;
  {
#line 442
  tmp___0 = mpegd_get_bits(mpeg, 32U, 16U);
  }
#line 442
  mpeg->packet.size = (unsigned int )(tmp___0 + 6UL);
#line 443
  mpeg->packet.offset = 6U;
#line 445
  mpeg->packet.have_pts = (char)0;
#line 446
  mpeg->packet.pts = 0ULL;
#line 448
  mpeg->packet.have_dts = (char)0;
#line 449
  mpeg->packet.dts = 0ULL;
#line 451
  i = 48U;
  }
#line 453
  if (sid >= 192U) {
#line 453
    if (sid < 240U) {
#line 453
      goto _L;
    } else {
#line 453
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 453
  if (sid == 189U) {
    _L: /* CIL Label */ 
    {
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 454
      tmp___1 = mpegd_get_bits(mpeg, i, 8U);
      }
      }
#line 454
      if (! (tmp___1 == 255UL)) {
#line 454
        goto while_break;
      }
#line 455
      if (i > 176U) {
#line 456
        goto while_break;
      }
#line 458
      i += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 461
    tmp___4 = mpegd_get_bits(mpeg, i, 2U);
    }
    }
#line 461
    if (tmp___4 == 2UL) {
      {
      {
#line 462
      tmp___2 = mpegd_parse_packet2___0(mpeg, i);
      }
      }
#line 462
      if (tmp___2) {
#line 463
        return (1);
      }
    } else {
      {
      {
#line 467
      tmp___3 = mpegd_parse_packet1___0(mpeg, i);
      }
      }
#line 467
      if (tmp___3) {
#line 468
        return (1);
      }
    }
  } else
#line 472
  if (sid == 190U) {
#line 473
    mpeg->packet.type = 1U;
  }
#line 476
  if (sid == 189U) {
    {
    {
#line 477
    tmp___5 = mpegd_get_bits(mpeg, 8U * mpeg->packet.offset, 8U);
    }
#line 477
    ssid = (unsigned int )tmp___5;
#line 478
    mpeg->packet.ssid = ssid;
    }
  }
#line 481
  if ((unsigned long )mpeg->mpeg_packet_check != (unsigned long )((void *)0)) {
    {
    {
#line 481
    tmp___8 = (*(mpeg->mpeg_packet_check))(mpeg);
    }
    }
#line 481
    if (tmp___8) {
      {
      {
#line 482
      tmp___6 = mpegd_skip(mpeg, 1U);
      }
      }
#line 482
      if (tmp___6) {
#line 483
        return (1);
      }
    } else {
#line 481
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 487
    (mpeg->packet_cnt) ++;
#line 488
    (mpeg->streams[sid].packet_cnt) ++;
#line 489
    mpeg->streams[sid].size += (unsigned long long )(mpeg->packet.size - mpeg->packet.offset);
#line 491
    if (sid == 189U) {
#line 492
      (mpeg->substreams[ssid].packet_cnt) ++;
#line 493
      mpeg->substreams[ssid].size += (unsigned long long )(mpeg->packet.size - mpeg->packet.offset);
    }
#line 496
    ofs = mpeg->ofs + (unsigned long long )mpeg->packet.size;
#line 498
    if ((unsigned long )mpeg->mpeg_packet != (unsigned long )((void *)0)) {
      {
      {
#line 499
      tmp___7 = (*(mpeg->mpeg_packet))(mpeg);
      }
      }
#line 499
      if (tmp___7) {
#line 500
        return (1);
      }
    }
    {
    {
#line 504
    mpegd_set_offset(mpeg, ofs);
    }
    }
  }
#line 507
  return (0);
}
}
#line 510 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_parse.c"
static int mpegd_parse_pack___0(mpeg_demux_t *mpeg ) 
{ 
  unsigned int sid ;
  unsigned long long ofs ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;

  {
  {
  {
#line 516
  tmp___7 = mpegd_get_bits(mpeg, 32U, 4U);
  }
  }
#line 516
  if (tmp___7 == 2UL) {
    {
#line 517
    mpeg->pack.type = 1U;
    {
#line 518
    tmp = mpegd_get_bits(mpeg, 36U, 3U);
    }
#line 518
    mpeg->pack.scr = (unsigned long long )tmp;
    {
#line 519
    tmp___0 = mpegd_get_bits(mpeg, 40U, 15U);
    }
#line 519
    mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___0;
    {
#line 520
    tmp___1 = mpegd_get_bits(mpeg, 56U, 15U);
    }
#line 520
    mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___1;
    {
#line 521
    mpeg->pack.mux_rate = mpegd_get_bits(mpeg, 73U, 22U);
    }
#line 522
    mpeg->pack.stuff = 0U;
#line 523
    mpeg->pack.size = 12U;
    }
  } else {
    {
    {
#line 525
    tmp___6 = mpegd_get_bits(mpeg, 32U, 2U);
    }
    }
#line 525
    if (tmp___6 == 1UL) {
      {
#line 526
      mpeg->pack.type = 2U;
      {
#line 527
      tmp___2 = mpegd_get_bits(mpeg, 34U, 3U);
      }
#line 527
      mpeg->pack.scr = (unsigned long long )tmp___2;
      {
#line 528
      tmp___3 = mpegd_get_bits(mpeg, 38U, 15U);
      }
#line 528
      mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___3;
      {
#line 529
      tmp___4 = mpegd_get_bits(mpeg, 54U, 15U);
      }
#line 529
      mpeg->pack.scr = (mpeg->pack.scr << 15) | (unsigned long long )tmp___4;
      {
#line 530
      mpeg->pack.mux_rate = mpegd_get_bits(mpeg, 80U, 22U);
      }
      {
#line 531
      tmp___5 = mpegd_get_bits(mpeg, 109U, 3U);
      }
#line 531
      mpeg->pack.stuff = (unsigned int )tmp___5;
#line 532
      mpeg->pack.size = 14U + mpeg->pack.stuff;
      }
    } else {
#line 535
      mpeg->pack.type = 0U;
#line 536
      mpeg->pack.scr = 0ULL;
#line 537
      mpeg->pack.mux_rate = 0UL;
#line 538
      mpeg->pack.size = 4U;
    }
  }
#line 541
  ofs = mpeg->ofs + (unsigned long long )mpeg->pack.size;
#line 543
  (mpeg->pack_cnt) ++;
#line 545
  if ((unsigned long )mpeg->mpeg_pack != (unsigned long )((void *)0)) {
    {
    {
#line 546
    tmp___8 = (*(mpeg->mpeg_pack))(mpeg);
    }
    }
#line 546
    if (tmp___8) {
#line 547
      return (1);
    }
  }
  {
  {
#line 551
  mpegd_set_offset(mpeg, ofs);
  }
  {
#line 553
  mpegd_seek_header___0(mpeg);
  }
  {
#line 555
  tmp___10 = mpegd_get_bits(mpeg, 0U, 32U);
  }
  }
#line 555
  if (tmp___10 == 443UL) {
    {
    {
#line 556
    tmp___9 = mpegd_parse_system_header___0(mpeg);
    }
    }
#line 556
    if (tmp___9) {
#line 557
      return (1);
    }
    {
    {
#line 560
    mpegd_seek_header___0(mpeg);
    }
    }
  }
  {
  {
#line 563
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 563
    tmp___12 = mpegd_get_bits(mpeg, 0U, 24U);
    }
    }
#line 563
    if (! (tmp___12 == 1UL)) {
#line 563
      goto while_break;
    }
    {
    {
#line 564
    tmp___11 = mpegd_get_bits(mpeg, 24U, 8U);
    }
#line 564
    sid = (unsigned int )tmp___11;
    }
#line 566
    if (sid == 186U) {
#line 567
      goto while_break;
    } else
#line 566
    if (sid == 185U) {
#line 567
      goto while_break;
    } else
#line 566
    if (sid == 187U) {
#line 567
      goto while_break;
    } else {
      {
      {
#line 570
      mpegd_parse_packet___0(mpeg);
      }
      }
    }
    {
    {
#line 573
    mpegd_seek_header___0(mpeg);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return (0);
}
}
#line 35 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static unsigned long long skip_ofs___0  =    0ULL;
#line 36 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static unsigned long skip_cnt___0  =    0UL;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static void mpeg_list_print_skip___0(FILE *fp___1 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 42
  if (skip_cnt___0 > 0UL) {
    {
    {
#line 43
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: skip %lu\n",
            skip_ofs___0, skip_cnt___0);
    }
#line 45
    skip_cnt___0 = 0UL;
    }
  }
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_skip___0(mpeg_demux_t *mpeg ) 
{ 


  {
#line 52
  if (skip_cnt___0 == 0UL) {
#line 53
    skip_ofs___0 = mpeg->ofs;
  }
#line 56
  skip_cnt___0 ++;
#line 58
  return (0);
}
}
#line 61 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_system_header___0(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 66
  if (par_no_shdr) {
#line 67
    return (0);
  }
  {
#line 70
  fp___1 = (FILE *)mpeg->ext;
  {
#line 72
  mpeg_list_print_skip___0(fp___1);
  }
  {
#line 74
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: system header[%lu]: size=%u fixed=%d csps=%d\n",
          mpeg->ofs, mpeg->shdr_cnt - 1UL, mpeg->shdr.size, mpeg->shdr.fixed, mpeg->shdr.csps);
  }
  }
#line 79
  return (0);
}
}
#line 82 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_packet___0(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  unsigned int sid ;
  unsigned int ssid ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 88
  if (par_no_packet) {
#line 89
    return (0);
  }
  {
#line 92
  sid = mpeg->packet.sid;
#line 93
  ssid = mpeg->packet.ssid;
  {
#line 95
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 95
  if (tmp) {
#line 96
    return (0);
  }
  {
#line 99
  fp___1 = (FILE *)mpeg->ext;
  {
#line 101
  mpeg_list_print_skip___0(fp___1);
  }
  {
#line 103
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: packet[%lu]: sid=%02x",
          mpeg->ofs, mpeg->streams[sid].packet_cnt - 1UL, sid);
  }
  }
#line 110
  if (sid == 189U) {
    {
    {
#line 111
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[%02x]",
            ssid);
    }
    }
  } else {
    {
    {
#line 114
    fputs((char const   */* __restrict  */)"    ", (FILE */* __restrict  */)fp___1);
    }
    }
  }
#line 117
  if (mpeg->packet.type == 1U) {
    {
    {
#line 118
    fputs((char const   */* __restrict  */)" MPEG1", (FILE */* __restrict  */)fp___1);
    }
    }
  } else
#line 120
  if (mpeg->packet.type == 2U) {
    {
    {
#line 121
    fputs((char const   */* __restrict  */)" MPEG2", (FILE */* __restrict  */)fp___1);
    }
    }
  } else {
    {
    {
#line 124
    fputs((char const   */* __restrict  */)" UNKWN", (FILE */* __restrict  */)fp___1);
    }
    }
  }
  {
  {
#line 127
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" size=%u",
          mpeg->packet.size);
  }
  }
#line 129
  if (mpeg->packet.have_pts) {
    {
    {
#line 130
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" pts=%llu[%.4f] dts=%llu[%.4f]",
            mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0, mpeg->packet.dts,
            (double )mpeg->packet.dts / 90000.0);
    }
    }
  } else
#line 129
  if (mpeg->packet.have_dts) {
    {
    {
#line 130
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" pts=%llu[%.4f] dts=%llu[%.4f]",
            mpeg->packet.pts, (double )mpeg->packet.pts / 90000.0, mpeg->packet.dts,
            (double )mpeg->packet.dts / 90000.0);
    }
    }
  }
  {
  {
#line 137
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)fp___1);
  }
  }
#line 139
  return (0);
}
}
#line 142 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_pack___0(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 147
  if (par_no_pack) {
#line 148
    return (0);
  }
  {
#line 151
  fp___1 = (FILE *)mpeg->ext;
  {
#line 153
  mpeg_list_print_skip___0(fp___1);
  }
  {
#line 155
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: pack[%lu]: type=%u scr=%llu[%.4f] mux=%lu[%.2f] stuff=%u\n",
          mpeg->ofs, mpeg->pack_cnt - 1UL, mpeg->pack.type, mpeg->pack.scr, (double )mpeg->pack.scr / 90000.0,
          mpeg->pack.mux_rate, 50.0 * (double )mpeg->pack.mux_rate, mpeg->pack.stuff);
  }
  {
#line 163
  fflush(fp___1);
  }
  }
#line 165
  return (0);
}
}
#line 168 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_list.c"
static int mpeg_list_end___0(mpeg_demux_t *mpeg ) 
{ 
  FILE *fp___1 ;
  char *__cil_tmp3 ;

  {
#line 173
  if (par_no_end) {
#line 174
    return (0);
  }
  {
#line 177
  fp___1 = (FILE *)mpeg->ext;
  {
#line 179
  mpeg_list_print_skip___0(fp___1);
  }
  {
#line 181
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%08llx: end\n",
          mpeg->ofs);
  }
  }
#line 183
  return (0);
}
}
#line 32 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/message.c"
static unsigned int msg_level___0  =    3U;
#line 39 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static unsigned int par_mode___0  =    0U;
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static FILE *par_inp___0  =    (FILE *)((void *)0);
#line 42 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static FILE *par_out___0  =    (FILE *)((void *)0);
#line 66 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static void prt_help___0(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 69
  fputs((char const   */* __restrict  */)"usage: mpegdemux [options] [input [output]]\n  -a, --ac3                    Assume DVD AC3 headers in private streams\n  -b, --base-name name         Set the base name for demuxed streams\n  -c, --scan                   Scan the stream [default]\n  -d, --demux                  Demultiplex streams\n  -D, --no-drop                Don\'t drop incomplete packets\n  -e, --no-end                 Don\'t list end codes [no]\n  -E, --empty-packs            Remux empty packs [no]\n  -F, --first-pts              Print packet with lowest PTS [no]\n  -h, --no-system-headers      Don\'t list system headers\n  -i, --invalid id             Select invalid streams [none]\n  -k, --no-packs               Don\'t list packs\n  -K, --remux-skipped          Copy skipped bytes when remuxing [no]\n  -l, --list                   List the stream contents\n  -m, --packet-max-size int    Set the maximum packet size [0]\n  -p, --substream id           Select substreams [none]\n  -P, --substream-map id1 id2  Remap substream id1 to id2\n  -r, --remux                  Copy modified input to output\n  -s, --stream id              Select streams [none]\n  -S, --stream-map id1 id2     Remap stream id1 to id2\n  -t, --no-packets             Don\'t list packets\n  -u, --spu                    Assume DVD subtitles in private streams\n  -x, --split                  Split sequences while remuxing [no]\n",
        (FILE */* __restrict  */)stdout);
  }
  }
#line 95
  return;
}
}
#line 97 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static void prt_version___0(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 100
  fputs((char const   */* __restrict  */)"mpegdemux version 0.1.3\n\nCopyright (C) 2003-2009 Hampa Hug <hampa@hampa.ch>\n",
        (FILE */* __restrict  */)stdout);
  }
  }
#line 106
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static char *str_clone___0(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 113
  tmp = strlen(str);
  }
  {
#line 113
  tmp___0 = malloc(tmp + 1U);
  }
#line 113
  ret = (char *)tmp___0;
  }
#line 114
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 115
    return ((char *)((void *)0));
  }
  {
  {
#line 118
  strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
  }
#line 120
  return (ret);
}
}
#line 123 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static int str_isarg___0(char const   *str , char const   *arg1 , char const   *arg2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 126
  if ((unsigned long )arg1 != (unsigned long )((void *)0)) {
    {
    {
#line 126
    tmp = strcmp(str, arg1);
    }
    }
#line 126
    if (tmp == 0) {
#line 127
      return (1);
    }
  }
#line 130
  if ((unsigned long )arg2 != (unsigned long )((void *)0)) {
    {
    {
#line 130
    tmp___0 = strcmp(str, arg2);
    }
    }
#line 130
    if (tmp___0 == 0) {
#line 131
      return (1);
    }
  }
#line 134
  return (0);
}
}
#line 137 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static char const   *str_skip_white___0(char const   *str ) 
{ 


  {
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((int const   )*str == 32)) {
#line 140
      if (! ((int const   )*str == 9)) {
#line 140
        goto while_break;
      }
    }
#line 141
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return (str);
}
}
#line 147 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpegdemux.c"
static int str_get_streams___0(char const   *str , unsigned char *stm , unsigned int msk ) 
{ 
  unsigned int i ;
  int incl ;
  char *tmp ;
  unsigned int stm1 ;
  unsigned int stm2 ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 155
  incl = 1;
  {
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 157
    if (! ((int const   )*str != 0)) {
#line 157
      goto while_break;
    }
    {
    {
#line 158
    str = str_skip_white___0(str);
    }
    }
#line 160
    if ((int const   )*str == 43) {
#line 161
      str ++;
#line 162
      incl = 1;
    } else
#line 164
    if ((int const   )*str == 45) {
#line 165
      str ++;
#line 166
      incl = 0;
    } else {
#line 169
      incl = 1;
    }
    {
    {
#line 172
    tmp___3 = strncmp(str, "all", (size_t )3);
    }
    }
#line 172
    if (tmp___3 == 0) {
#line 173
      str += 3;
#line 174
      stm1 = 0U;
#line 175
      stm2 = 255U;
    } else {
      {
      {
#line 177
      tmp___2 = strncmp(str, "none", (size_t )4);
      }
      }
#line 177
      if (tmp___2 == 0) {
#line 178
        str += 4;
#line 179
        stm1 = 0U;
#line 180
        stm2 = 255U;
#line 181
        incl = ! incl;
      } else {
        {
        {
#line 184
        tmp___0 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
                          0);
        }
#line 184
        stm1 = (unsigned int )tmp___0;
        }
#line 185
        if ((unsigned long )tmp == (unsigned long )str) {
#line 186
          return (1);
        }
#line 189
        str = (char const   *)tmp;
#line 191
        if ((int const   )*str == 45) {
          {
#line 192
          str ++;
          {
#line 193
          tmp___1 = strtoul((char const   */* __restrict  */)str, (char **/* __restrict  */)(& tmp),
                            0);
          }
#line 193
          stm2 = (unsigned int )tmp___1;
          }
#line 194
          if ((unsigned long )tmp == (unsigned long )str) {
#line 195
            return (1);
          }
#line 197
          str = (char const   *)tmp;
        } else {
#line 200
          stm2 = stm1;
        }
      }
    }
#line 204
    if (incl) {
#line 205
      i = stm1;
      {
      {
#line 205
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 205
        if (! (i <= stm2)) {
#line 205
          goto while_break___0;
        }
#line 206
        *(stm + i) = (unsigned char )((unsigned int )*(stm + i) | msk);
#line 205
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 210
      i = stm1;
      {
      {
#line 210
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 210
        if (! (i <= stm2)) {
#line 210
          goto while_break___1;
        }
#line 211
        *(stm + i) = (unsigned char )((unsigned int )*(stm + i) & ~ msk);
#line 210
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
    {
#line 215
    str = str_skip_white___0(str);
    }
    }
#line 217
    if ((int const   )*str == 47) {
#line 218
      str ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (0);
}
}
#line 40 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static mpeg_buffer_t shdr___0  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 41 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static mpeg_buffer_t pack___0  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 42 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static mpeg_buffer_t packet___2  =    {(unsigned char *)((void *)0), 0U, 0U};
#line 44 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static unsigned int sequence___0  =    0U;
#line 47 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_next_fp___0(mpeg_demux_t *mpeg ) 
{ 
  char *fname ;
  FILE *fp___1 ;
  char *__cil_tmp4 ;

  {
#line 53
  fp___1 = (FILE *)mpeg->ext;
#line 54
  if ((unsigned long )fp___1 != (unsigned long )((void *)0)) {
    {
    {
#line 55
    fclose(fp___1);
    }
#line 56
    mpeg->ext = (void *)0;
    }
  }
  {
  {
#line 59
  fname = mpeg_get_name((char const   *)par_demux_name, sequence___0);
  }
  }
#line 60
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 61
    return (1);
  }
  {
#line 64
  sequence___0 ++;
  {
#line 66
  fp___1 = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"wb");
  }
  {
#line 68
  free((void *)fname);
  }
  }
#line 70
  if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
#line 71
    return (1);
  }
#line 74
  mpeg->ext = (void *)fp___1;
#line 76
  return (0);
}
}
#line 79 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_skip___0(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;

  {
#line 82
  if (par_remux_skipped == 0) {
#line 83
    return (0);
  }
  {
  {
#line 86
  tmp = mpeg_copy(mpeg, (FILE *)mpeg->ext, 1U);
  }
  }
#line 86
  if (tmp) {
#line 87
    return (1);
  }
#line 90
  return (0);
}
}
#line 93 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_system_header___0(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 96
  if (par_no_shdr) {
#line 96
    if (mpeg->shdr_cnt > 1UL) {
#line 97
      return (0);
    }
  }
  {
  {
#line 100
  tmp = mpeg_buf_write_clear(& pack___0, (FILE *)mpeg->ext);
  }
  }
#line 100
  if (tmp) {
#line 101
    return (1);
  }
  {
  {
#line 104
  tmp___0 = mpeg_buf_read(& shdr___0, mpeg, mpeg->shdr.size);
  }
  }
#line 104
  if (tmp___0) {
#line 105
    return (1);
  }
  {
  {
#line 108
  tmp___1 = mpeg_buf_write_clear(& shdr___0, (FILE *)mpeg->ext);
  }
  }
#line 108
  if (tmp___1) {
#line 109
    return (1);
  }
#line 112
  return (0);
}
}
#line 115 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_packet___0(mpeg_demux_t *mpeg ) 
{ 
  int r ;
  unsigned int sid ;
  unsigned int ssid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 121
  sid = mpeg->packet.sid;
#line 122
  ssid = mpeg->packet.ssid;
  {
#line 124
  tmp = mpeg_stream_excl((unsigned char )sid, (unsigned char )ssid);
  }
  }
#line 124
  if (tmp) {
#line 125
    return (0);
  }
  {
#line 128
  r = 0;
  {
#line 130
  tmp___0 = mpeg_buf_read(& packet___2, mpeg, mpeg->packet.size);
  }
  }
#line 130
  if (tmp___0) {
    {
    {
#line 131
    prt_msg("remux: incomplete packet (sid=%02x size=%u/%u)\n", sid, packet___2.cnt,
            mpeg->packet.size);
    }
    }
#line 135
    if (par_drop) {
      {
      {
#line 136
      mpeg_buf_clear(& packet___2);
      }
      }
#line 137
      return (1);
    }
#line 140
    r = 1;
  }
#line 143
  if (packet___2.cnt >= 4U) {
#line 144
    *(packet___2.buf + 3) = par_stream_map[sid];
#line 146
    if (sid == 189U) {
#line 146
      if (packet___2.cnt > mpeg->packet.offset) {
#line 147
        *(packet___2.buf + mpeg->packet.offset) = par_substream_map[ssid];
      }
    }
  }
  {
  {
#line 151
  tmp___1 = mpeg_buf_write_clear(& pack___0, (FILE *)mpeg->ext);
  }
  }
#line 151
  if (tmp___1) {
#line 152
    return (1);
  }
  {
  {
#line 155
  tmp___2 = mpeg_buf_write_clear(& packet___2, (FILE *)mpeg->ext);
  }
  }
#line 155
  if (tmp___2) {
#line 156
    return (1);
  }
#line 159
  return (r);
}
}
#line 162 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_pack___0(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 165
  tmp = mpeg_buf_read(& pack___0, mpeg, mpeg->pack.size);
  }
  }
#line 165
  if (tmp) {
#line 166
    return (1);
  }
#line 169
  if (par_empty_pack) {
    {
    {
#line 170
    tmp___0 = mpeg_buf_write_clear(& pack___0, (FILE *)mpeg->ext);
    }
    }
#line 170
    if (tmp___0) {
#line 171
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/home/wslee/benchmarks/sound/mpegdemux-0.1.3/src/mpeg_remux.c"
static int mpeg_remux_end___0(mpeg_demux_t *mpeg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 181
  if (par_no_end) {
#line 182
    return (0);
  }
  {
  {
#line 185
  tmp = mpeg_copy(mpeg, (FILE *)mpeg->ext, 4U);
  }
  }
#line 185
  if (tmp) {
#line 186
    return (1);
  }
#line 189
  if (par_split) {
    {
    {
#line 190
    tmp___0 = mpeg_remux_next_fp___0(mpeg);
    }
    }
#line 190
    if (tmp___0) {
#line 191
      return (1);
    }
  }
#line 195
  return (0);
}
}
