/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 77 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 34 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_vertex_23 {
   float x ;
   float y ;
   float z ;
};
#line 34 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_vertex_23 stl_vertex;
#line 41 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_normal_24 {
   float x ;
   float y ;
   float z ;
};
#line 41 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_normal_24 stl_normal;
#line 48 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef char stl_extra[2];
#line 50 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_facet_25 {
   stl_normal normal ;
   stl_vertex vertex[3] ;
   stl_extra extra ;
};
#line 50 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_facet_25 stl_facet;
#line 58
enum __anonenum_stl_type_26 {
    binary = 0,
    ascii = 1
} ;
#line 58 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef enum __anonenum_stl_type_26 stl_type;
#line 60 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_edge_27 {
   stl_vertex p1 ;
   stl_vertex p2 ;
   int facet_number ;
};
#line 60 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_edge_27 stl_edge;
#line 67 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct stl_hash_edge {
   unsigned int key[6] ;
   int facet_number ;
   int which_edge ;
   struct stl_hash_edge *next ;
};
#line 67 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct stl_hash_edge stl_hash_edge;
#line 75 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_neighbors_28 {
   int neighbor[3] ;
   char which_vertex_not[3] ;
};
#line 75 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_neighbors_28 stl_neighbors;
#line 81 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_v_indices_struct_29 {
   int vertex[3] ;
};
#line 81 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_v_indices_struct_29 v_indices_struct;
#line 86 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_stats_30 {
   char header[81] ;
   stl_type type ;
   int number_of_facets ;
   stl_vertex max ;
   stl_vertex min ;
   stl_vertex size ;
   float bounding_diameter ;
   float shortest_edge ;
   float volume ;
   unsigned int number_of_blocks ;
   int connected_edges ;
   int connected_facets_1_edge ;
   int connected_facets_2_edge ;
   int connected_facets_3_edge ;
   int facets_w_1_bad_edge ;
   int facets_w_2_bad_edge ;
   int facets_w_3_bad_edge ;
   int original_num_facets ;
   int edges_fixed ;
   int degenerate_facets ;
   int facets_removed ;
   int facets_added ;
   int facets_reversed ;
   int backwards_edges ;
   int normals_fixed ;
   int number_of_parts ;
   int malloced ;
   int freed ;
   int facets_malloced ;
   int collisions ;
   int shared_vertices ;
   int shared_malloced ;
};
#line 86 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_stats_30 stl_stats;
#line 122 "/home/wslee/benchmarks/admesh-0.95/stl.h"
struct __anonstruct_stl_file_31 {
   FILE *fp ;
   stl_facet *facet_start ;
   stl_edge *edge_start ;
   stl_hash_edge **heads ;
   stl_hash_edge *tail ;
   int M ;
   stl_neighbors *neighbors_start ;
   v_indices_struct *v_indices ;
   stl_vertex *v_shared ;
   stl_stats stats ;
};
#line 122 "/home/wslee/benchmarks/admesh-0.95/stl.h"
typedef struct __anonstruct_stl_file_31 stl_file;
#line 99 "/home/wslee/benchmarks/admesh-0.95/normals.c"
struct stl_normal {
   int facet_num ;
   struct stl_normal *next ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 206 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
union __anonunion_value_32 {
   int int_value ;
   char char_value[4] ;
};
#line 225 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
union __anonunion_value_33 {
   float float_value ;
   char char_value[4] ;
};
#line 206 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
union __anonunion_value_32___0 {
   int int_value ;
   char char_value[4] ;
};
#line 225 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
union __anonunion_value_33___0 {
   float float_value ;
   char char_value[4] ;
};
#line 64 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
union __anonunion_value_34 {
   int int_value ;
   float float_value ;
};
#line 64 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
union __anonunion_value_34___0 {
   int int_value ;
   float float_value ;
};
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 415
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
#line 31 "./getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 106
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 145 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 148
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 137 "/home/wslee/benchmarks/admesh-0.95/stl.h"
void stl_open(stl_file *stl , char *file ) ;
#line 138
void stl_close(stl_file *stl ) ;
#line 139
void stl_stats_out(stl_file *stl , FILE *file , char *input_file ) ;
#line 142
void stl_write_ascii(stl_file *stl , char *file , char *label ) ;
#line 143
void stl_write_binary(stl_file *stl , char *file , char *label ) ;
#line 144
void stl_check_facets_exact(stl_file *stl ) ;
#line 145
void stl_check_facets_nearby(stl_file *stl , float tolerance ) ;
#line 146
void stl_remove_unconnected_facets(stl_file *stl ) ;
#line 152
void stl_verify_neighbors(stl_file *stl ) ;
#line 153
void stl_fill_holes(stl_file *stl ) ;
#line 154
void stl_fix_normal_directions(stl_file *stl ) ;
#line 155
void stl_fix_normal_values(stl_file *stl ) ;
#line 156
void stl_reverse_all_facets(stl_file *stl ) ;
#line 157
void stl_translate(stl_file *stl , float x , float y , float z ) ;
#line 158
void stl_scale(stl_file *stl , float factor ) ;
#line 159
void stl_rotate_x(stl_file *stl , float angle ) ;
#line 160
void stl_rotate_y(stl_file *stl , float angle ) ;
#line 161
void stl_rotate_z(stl_file *stl , float angle ) ;
#line 162
void stl_mirror_xy(stl_file *stl ) ;
#line 163
void stl_mirror_yz(stl_file *stl ) ;
#line 164
void stl_mirror_xz(stl_file *stl ) ;
#line 165
void stl_open_merge(stl_file *stl , char *file ) ;
#line 166
void stl_generate_shared_vertices(stl_file *stl ) ;
#line 167
void stl_write_off(stl_file *stl , char *file ) ;
#line 168
void stl_write_dxf(stl_file *stl , char *file , char *label ) ;
#line 169
void stl_write_vrml(stl_file *stl , char *file ) ;
#line 172
void stl_calculate_volume(stl_file *stl ) ;
#line 28 "/home/wslee/benchmarks/admesh-0.95/admesh.c"
static void usage(int status , char *program_name ) ;
#line 30 "/home/wslee/benchmarks/admesh-0.95/admesh.c"
void main(int argc , char **argv ) 
{ 
  stl_file stl_in ;
  int i ;
  int last_edges_fixed ;
  float tolerance ;
  float increment ;
  float x_trans ;
  float y_trans ;
  float z_trans ;
  float scale_factor ;
  float rotate_x_angle ;
  float rotate_y_angle ;
  float rotate_z_angle ;
  int c ;
  char *program_name ;
  char *binary_name ;
  char *ascii_name ;
  char *merge_name ;
  char *off_name ;
  char *dxf_name ;
  char *vrml_name ;
  int fixall_flag ;
  int exact_flag ;
  int tolerance_flag ;
  int nearby_flag ;
  int remove_unconnected_flag ;
  int fill_holes_flag ;
  int normal_directions_flag ;
  int normal_values_flag ;
  int reverse_all_flag ;
  int write_binary_stl_flag ;
  int write_ascii_stl_flag ;
  int generate_shared_vertices_flag ;
  int write_off_flag ;
  int write_dxf_flag ;
  int write_vrml_flag ;
  int translate_flag ;
  int scale_flag ;
  int rotate_x_flag ;
  int rotate_y_flag ;
  int rotate_z_flag ;
  int mirror_xy_flag ;
  int mirror_yz_flag ;
  int mirror_xz_flag ;
  int merge_flag ;
  int help_flag ;
  int version_flag ;
  int iterations ;
  int increment_flag ;
  char *input_file ;
  struct option long_options[28] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  void *__cil_tmp59 ;
  int __cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;

  {
#line 35
  last_edges_fixed = 0;
#line 36
  tolerance = (float )0;
#line 37
  increment = (float )0;
#line 41
  scale_factor = (float )0;
#line 42
  rotate_x_angle = (float )0;
#line 43
  rotate_y_angle = (float )0;
#line 44
  rotate_z_angle = (float )0;
#line 47
  binary_name = (char *)((void *)0);
#line 48
  ascii_name = (char *)((void *)0);
#line 49
  merge_name = (char *)((void *)0);
#line 50
  off_name = (char *)((void *)0);
#line 51
  dxf_name = (char *)((void *)0);
#line 52
  vrml_name = (char *)((void *)0);
#line 53
  fixall_flag = 1;
#line 54
  exact_flag = 0;
#line 55
  tolerance_flag = 0;
#line 56
  nearby_flag = 0;
#line 57
  remove_unconnected_flag = 0;
#line 58
  fill_holes_flag = 0;
#line 59
  normal_directions_flag = 0;
#line 60
  normal_values_flag = 0;
#line 61
  reverse_all_flag = 0;
#line 62
  write_binary_stl_flag = 0;
#line 63
  write_ascii_stl_flag = 0;
#line 64
  generate_shared_vertices_flag = 0;
#line 65
  write_off_flag = 0;
#line 66
  write_dxf_flag = 0;
#line 67
  write_vrml_flag = 0;
#line 68
  translate_flag = 0;
#line 69
  scale_flag = 0;
#line 70
  rotate_x_flag = 0;
#line 71
  rotate_y_flag = 0;
#line 72
  rotate_z_flag = 0;
#line 73
  mirror_xy_flag = 0;
#line 74
  mirror_yz_flag = 0;
#line 75
  mirror_xz_flag = 0;
#line 76
  merge_flag = 0;
#line 77
  help_flag = 0;
#line 78
  version_flag = 0;
#line 80
  iterations = 2;
#line 81
  increment_flag = 0;
#line 82
  input_file = (char *)((void *)0);
#line 88
  long_options[0].name = "exact";
#line 88
  long_options[0].has_arg = 0;
#line 88
  long_options[0].flag = (int *)((void *)0);
#line 88
  long_options[0].val = 'e';
#line 88
  long_options[1].name = "nearby";
#line 88
  long_options[1].has_arg = 0;
#line 88
  long_options[1].flag = (int *)((void *)0);
#line 88
  long_options[1].val = 'n';
#line 88
  long_options[2].name = "tolerance";
#line 88
  long_options[2].has_arg = 1;
#line 88
  long_options[2].flag = (int *)((void *)0);
#line 88
  long_options[2].val = 't';
#line 88
  long_options[3].name = "iterations";
#line 88
  long_options[3].has_arg = 1;
#line 88
  long_options[3].flag = (int *)((void *)0);
#line 88
  long_options[3].val = 'i';
#line 88
  long_options[4].name = "increment";
#line 88
  long_options[4].has_arg = 1;
#line 88
  long_options[4].flag = (int *)((void *)0);
#line 88
  long_options[4].val = 'm';
#line 88
  long_options[5].name = "remove-unconnected";
#line 88
  long_options[5].has_arg = 0;
#line 88
  long_options[5].flag = (int *)((void *)0);
#line 88
  long_options[5].val = 'u';
#line 88
  long_options[6].name = "fill-holes";
#line 88
  long_options[6].has_arg = 0;
#line 88
  long_options[6].flag = (int *)((void *)0);
#line 88
  long_options[6].val = 'f';
#line 88
  long_options[7].name = "normal-directions";
#line 88
  long_options[7].has_arg = 0;
#line 88
  long_options[7].flag = (int *)((void *)0);
#line 88
  long_options[7].val = 'd';
#line 88
  long_options[8].name = "normal-values";
#line 88
  long_options[8].has_arg = 0;
#line 88
  long_options[8].flag = (int *)((void *)0);
#line 88
  long_options[8].val = 'v';
#line 88
  long_options[9].name = "no-check";
#line 88
  long_options[9].has_arg = 0;
#line 88
  long_options[9].flag = (int *)((void *)0);
#line 88
  long_options[9].val = 'c';
#line 88
  long_options[10].name = "reverse-all";
#line 88
  long_options[10].has_arg = 0;
#line 88
  long_options[10].flag = (int *)((void *)0);
#line 88
  long_options[10].val = 1011;
#line 88
  long_options[11].name = "write-binary-stl";
#line 88
  long_options[11].has_arg = 1;
#line 88
  long_options[11].flag = (int *)((void *)0);
#line 88
  long_options[11].val = 'b';
#line 88
  long_options[12].name = "write-ascii-stl";
#line 88
  long_options[12].has_arg = 1;
#line 88
  long_options[12].flag = (int *)((void *)0);
#line 88
  long_options[12].val = 'a';
#line 88
  long_options[13].name = "write-off";
#line 88
  long_options[13].has_arg = 1;
#line 88
  long_options[13].flag = (int *)((void *)0);
#line 88
  long_options[13].val = 1012;
#line 88
  long_options[14].name = "write-dxf";
#line 88
  long_options[14].has_arg = 1;
#line 88
  long_options[14].flag = (int *)((void *)0);
#line 88
  long_options[14].val = 1013;
#line 88
  long_options[15].name = "write-vrml";
#line 88
  long_options[15].has_arg = 1;
#line 88
  long_options[15].flag = (int *)((void *)0);
#line 88
  long_options[15].val = 1014;
#line 88
  long_options[16].name = "translate";
#line 88
  long_options[16].has_arg = 1;
#line 88
  long_options[16].flag = (int *)((void *)0);
#line 88
  long_options[16].val = 1010;
#line 88
  long_options[17].name = "scale";
#line 88
  long_options[17].has_arg = 1;
#line 88
  long_options[17].flag = (int *)((void *)0);
#line 88
  long_options[17].val = 1009;
#line 88
  long_options[18].name = "x-rotate";
#line 88
  long_options[18].has_arg = 1;
#line 88
  long_options[18].flag = (int *)((void *)0);
#line 88
  long_options[18].val = 1000;
#line 88
  long_options[19].name = "y-rotate";
#line 88
  long_options[19].has_arg = 1;
#line 88
  long_options[19].flag = (int *)((void *)0);
#line 88
  long_options[19].val = 1001;
#line 88
  long_options[20].name = "z-rotate";
#line 88
  long_options[20].has_arg = 1;
#line 88
  long_options[20].flag = (int *)((void *)0);
#line 88
  long_options[20].val = 1002;
#line 88
  long_options[21].name = "xy-mirror";
#line 88
  long_options[21].has_arg = 0;
#line 88
  long_options[21].flag = (int *)((void *)0);
#line 88
  long_options[21].val = 1006;
#line 88
  long_options[22].name = "yz-mirror";
#line 88
  long_options[22].has_arg = 0;
#line 88
  long_options[22].flag = (int *)((void *)0);
#line 88
  long_options[22].val = 1007;
#line 88
  long_options[23].name = "xz-mirror";
#line 88
  long_options[23].has_arg = 0;
#line 88
  long_options[23].flag = (int *)((void *)0);
#line 88
  long_options[23].val = 1008;
#line 88
  long_options[24].name = "merge";
#line 88
  long_options[24].has_arg = 1;
#line 88
  long_options[24].flag = (int *)((void *)0);
#line 88
  long_options[24].val = 1003;
#line 88
  long_options[25].name = "help";
#line 88
  long_options[25].has_arg = 0;
#line 88
  long_options[25].flag = (int *)((void *)0);
#line 88
  long_options[25].val = 1004;
#line 88
  long_options[26].name = "version";
#line 88
  long_options[26].has_arg = 0;
#line 88
  long_options[26].flag = (int *)((void *)0);
#line 88
  long_options[26].val = 1005;
#line 88
  long_options[27].name = (char const   *)((void *)0);
#line 88
  long_options[27].has_arg = 0;
#line 88
  long_options[27].flag = (int *)((void *)0);
#line 88
  long_options[27].val = 0;
#line 120
  program_name = *(argv + 0);
  {
  {
#line 121
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 121
    c = getopt_long(argc, (char * const  *)argv, "et:i:m:nufdcvb:a:", (struct option  const  *)(long_options),
                    (int *)0);
    }
    }
#line 121
    if (! (c != -1)) {
#line 121
      goto while_break;
    }
    {
#line 126
    if (c == 0) {
#line 126
      goto case_0;
    }
#line 128
    if (c == 101) {
#line 128
      goto case_101;
    }
#line 132
    if (c == 110) {
#line 132
      goto case_110;
    }
#line 136
    if (c == 116) {
#line 136
      goto case_116;
    }
#line 140
    if (c == 105) {
#line 140
      goto case_105;
    }
#line 143
    if (c == 109) {
#line 143
      goto case_109;
    }
#line 147
    if (c == 117) {
#line 147
      goto case_117;
    }
#line 151
    if (c == 102) {
#line 151
      goto case_102;
    }
#line 155
    if (c == 100) {
#line 155
      goto case_100;
    }
#line 159
    if (c == 118) {
#line 159
      goto case_118;
    }
#line 163
    if (c == 99) {
#line 163
      goto case_99;
    }
#line 166
    if (c == 1011) {
#line 166
      goto case_1011;
    }
#line 170
    if (c == 98) {
#line 170
      goto case_98;
    }
#line 174
    if (c == 97) {
#line 174
      goto case_97;
    }
#line 178
    if (c == 1012) {
#line 178
      goto case_1012;
    }
#line 183
    if (c == 1014) {
#line 183
      goto case_1014;
    }
#line 188
    if (c == 1013) {
#line 188
      goto case_1013;
    }
#line 192
    if (c == 1010) {
#line 192
      goto case_1010;
    }
#line 196
    if (c == 1009) {
#line 196
      goto case_1009;
    }
#line 200
    if (c == 1000) {
#line 200
      goto case_1000;
    }
#line 204
    if (c == 1001) {
#line 204
      goto case_1001;
    }
#line 208
    if (c == 1002) {
#line 208
      goto case_1002;
    }
#line 212
    if (c == 1006) {
#line 212
      goto case_1006;
    }
#line 215
    if (c == 1007) {
#line 215
      goto case_1007;
    }
#line 218
    if (c == 1008) {
#line 218
      goto case_1008;
    }
#line 221
    if (c == 1003) {
#line 221
      goto case_1003;
    }
#line 225
    if (c == 1004) {
#line 225
      goto case_1004;
    }
#line 228
    if (c == 1005) {
#line 228
      goto case_1005;
    }
#line 231
    goto switch_default;
    case_0: /* CIL Label */ 
#line 127
    goto switch_break;
    case_101: /* CIL Label */ 
#line 129
    exact_flag = 1;
#line 130
    fixall_flag = 0;
#line 131
    goto switch_break;
    case_110: /* CIL Label */ 
#line 133
    nearby_flag = 1;
#line 134
    fixall_flag = 0;
#line 135
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 137
    tolerance_flag = 1;
    {
#line 138
    tmp = atof((char const   *)optarg);
    }
#line 138
    tolerance = (float )tmp;
    }
#line 139
    goto switch_break;
    case_105: /* CIL Label */ 
    {
    {
#line 141
    iterations = atoi((char const   *)optarg);
    }
    }
#line 142
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 144
    increment_flag = 1;
    {
#line 145
    tmp___0 = atof((char const   *)optarg);
    }
#line 145
    increment = (float )tmp___0;
    }
#line 146
    goto switch_break;
    case_117: /* CIL Label */ 
#line 148
    remove_unconnected_flag = 1;
#line 149
    fixall_flag = 0;
#line 150
    goto switch_break;
    case_102: /* CIL Label */ 
#line 152
    fill_holes_flag = 1;
#line 153
    fixall_flag = 0;
#line 154
    goto switch_break;
    case_100: /* CIL Label */ 
#line 156
    normal_directions_flag = 1;
#line 157
    fixall_flag = 0;
#line 158
    goto switch_break;
    case_118: /* CIL Label */ 
#line 160
    normal_values_flag = 1;
#line 161
    fixall_flag = 0;
#line 162
    goto switch_break;
    case_99: /* CIL Label */ 
#line 164
    fixall_flag = 0;
#line 165
    goto switch_break;
    case_1011: /* CIL Label */ 
#line 167
    reverse_all_flag = 1;
#line 168
    fixall_flag = 0;
#line 169
    goto switch_break;
    case_98: /* CIL Label */ 
#line 171
    write_binary_stl_flag = 1;
#line 172
    binary_name = optarg;
#line 173
    goto switch_break;
    case_97: /* CIL Label */ 
#line 175
    write_ascii_stl_flag = 1;
#line 176
    ascii_name = optarg;
#line 177
    goto switch_break;
    case_1012: /* CIL Label */ 
#line 179
    generate_shared_vertices_flag = 1;
#line 180
    write_off_flag = 1;
#line 181
    off_name = optarg;
#line 182
    goto switch_break;
    case_1014: /* CIL Label */ 
#line 184
    generate_shared_vertices_flag = 1;
#line 185
    write_vrml_flag = 1;
#line 186
    vrml_name = optarg;
#line 187
    goto switch_break;
    case_1013: /* CIL Label */ 
#line 189
    write_dxf_flag = 1;
#line 190
    dxf_name = optarg;
#line 191
    goto switch_break;
    case_1010: /* CIL Label */ 
    {
#line 193
    translate_flag = 1;
    {
#line 194
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%f,%f,%f",
           & x_trans, & y_trans, & z_trans);
    }
    }
#line 195
    goto switch_break;
    case_1009: /* CIL Label */ 
    {
#line 197
    scale_flag = 1;
    {
#line 198
    tmp___1 = atof((char const   *)optarg);
    }
#line 198
    scale_factor = (float )tmp___1;
    }
#line 199
    goto switch_break;
    case_1000: /* CIL Label */ 
    {
#line 201
    rotate_x_flag = 1;
    {
#line 202
    tmp___2 = atof((char const   *)optarg);
    }
#line 202
    rotate_x_angle = (float )tmp___2;
    }
#line 203
    goto switch_break;
    case_1001: /* CIL Label */ 
    {
#line 205
    rotate_y_flag = 1;
    {
#line 206
    tmp___3 = atof((char const   *)optarg);
    }
#line 206
    rotate_y_angle = (float )tmp___3;
    }
#line 207
    goto switch_break;
    case_1002: /* CIL Label */ 
    {
#line 209
    rotate_z_flag = 1;
    {
#line 210
    tmp___4 = atof((char const   *)optarg);
    }
#line 210
    rotate_z_angle = (float )tmp___4;
    }
#line 211
    goto switch_break;
    case_1006: /* CIL Label */ 
#line 213
    mirror_xy_flag = 1;
#line 214
    goto switch_break;
    case_1007: /* CIL Label */ 
#line 216
    mirror_yz_flag = 1;
#line 217
    goto switch_break;
    case_1008: /* CIL Label */ 
#line 219
    mirror_xz_flag = 1;
#line 220
    goto switch_break;
    case_1003: /* CIL Label */ 
#line 222
    merge_flag = 1;
#line 223
    merge_name = optarg;
#line 224
    goto switch_break;
    case_1004: /* CIL Label */ 
#line 226
    help_flag = 1;
#line 227
    goto switch_break;
    case_1005: /* CIL Label */ 
#line 229
    version_flag = 1;
#line 230
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 232
    usage(1, program_name);
    }
    }
#line 233
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  if (help_flag) {
    {
    {
#line 239
    usage(0, program_name);
    }
    }
  }
#line 241
  if (version_flag) {
    {
    {
#line 243
    printf((char const   */* __restrict  */)"ADMesh - version 0.95\n");
    }
    {
#line 244
    exit(0);
    }
    }
  }
#line 247
  if (optind == argc) {
    {
    {
#line 249
    printf((char const   */* __restrict  */)"No input file name given.\n");
    }
    {
#line 250
    usage(1, program_name);
    }
    }
  } else {
#line 254
    input_file = *(argv + optind);
  }
  {
  {
#line 257
  printf((char const   */* __restrict  */)"ADMesh version 0.95, Copyright (C) 1995, 1996 Anthony D. Martin\nADMesh comes with NO WARRANTY.  This is free software, and you are welcome to\nredistribute it under certain conditions.  See the file COPYING for details.\n");
  }
  {
#line 263
  printf((char const   */* __restrict  */)"Opening %s\n", input_file);
  }
  {
#line 264
  stl_open(& stl_in, input_file);
  }
  }
#line 266
  if (rotate_x_flag) {
    {
    {
#line 268
    printf((char const   */* __restrict  */)"Rotating about the x axis by %f degrees...\n",
           (double )rotate_x_angle);
    }
    {
#line 269
    stl_rotate_x(& stl_in, rotate_x_angle);
    }
    }
  }
#line 271
  if (rotate_y_flag) {
    {
    {
#line 273
    printf((char const   */* __restrict  */)"Rotating about the y axis by %f degrees...\n",
           (double )rotate_y_angle);
    }
    {
#line 274
    stl_rotate_y(& stl_in, rotate_y_angle);
    }
    }
  }
#line 276
  if (rotate_z_flag) {
    {
    {
#line 278
    printf((char const   */* __restrict  */)"Rotating about the z axis by %f degrees...\n",
           (double )rotate_z_angle);
    }
    {
#line 279
    stl_rotate_z(& stl_in, rotate_z_angle);
    }
    }
  }
#line 281
  if (mirror_xy_flag) {
    {
    {
#line 283
    printf((char const   */* __restrict  */)"Mirroring about the xy plane...\n");
    }
    {
#line 284
    stl_mirror_xy(& stl_in);
    }
    }
  }
#line 286
  if (mirror_yz_flag) {
    {
    {
#line 288
    printf((char const   */* __restrict  */)"Mirroring about the yz plane...\n");
    }
    {
#line 289
    stl_mirror_yz(& stl_in);
    }
    }
  }
#line 291
  if (mirror_xz_flag) {
    {
    {
#line 293
    printf((char const   */* __restrict  */)"Mirroring about the xz plane...\n");
    }
    {
#line 294
    stl_mirror_xz(& stl_in);
    }
    }
  }
#line 297
  if (scale_flag) {
    {
    {
#line 299
    printf((char const   */* __restrict  */)"Scaling by factor %f...\n", (double )scale_factor);
    }
    {
#line 300
    stl_scale(& stl_in, scale_factor);
    }
    }
  }
#line 302
  if (translate_flag) {
    {
    {
#line 304
    printf((char const   */* __restrict  */)"Translating to %f, %f, %f ...\n", (double )x_trans,
           (double )y_trans, (double )z_trans);
    }
    {
#line 305
    stl_translate(& stl_in, x_trans, y_trans, z_trans);
    }
    }
  }
#line 307
  if (merge_flag) {
    {
    {
#line 309
    printf((char const   */* __restrict  */)"Merging %s with %s\n", input_file, merge_name);
    }
    {
#line 310
    stl_open_merge(& stl_in, merge_name);
    }
    }
  }
#line 313
  if (exact_flag) {
#line 313
    goto _L;
  } else
#line 313
  if (fixall_flag) {
#line 313
    goto _L;
  } else
#line 313
  if (nearby_flag) {
#line 313
    goto _L;
  } else
#line 313
  if (remove_unconnected_flag) {
#line 313
    goto _L;
  } else
#line 313
  if (fill_holes_flag) {
#line 313
    goto _L;
  } else
#line 313
  if (normal_directions_flag) {
    _L: /* CIL Label */ 
    {
    {
#line 316
    printf((char const   */* __restrict  */)"Checking exact...\n");
    }
#line 317
    exact_flag = 1;
    {
#line 318
    stl_check_facets_exact(& stl_in);
    }
#line 319
    stl_in.stats.facets_w_1_bad_edge = stl_in.stats.connected_facets_2_edge - stl_in.stats.connected_facets_3_edge;
#line 322
    stl_in.stats.facets_w_2_bad_edge = stl_in.stats.connected_facets_1_edge - stl_in.stats.connected_facets_2_edge;
#line 325
    stl_in.stats.facets_w_3_bad_edge = stl_in.stats.number_of_facets - stl_in.stats.connected_facets_1_edge;
    }
  }
#line 330
  if (nearby_flag) {
#line 330
    goto _L___0;
  } else
#line 330
  if (fixall_flag) {
    _L___0: /* CIL Label */ 
#line 332
    if (! tolerance_flag) {
#line 334
      tolerance = stl_in.stats.shortest_edge;
    }
#line 336
    if (! increment_flag) {
#line 338
      increment = (float )((double )stl_in.stats.bounding_diameter / 10000.0);
    }
#line 341
    if (stl_in.stats.connected_facets_3_edge < stl_in.stats.number_of_facets) {
#line 343
      i = 0;
      {
      {
#line 343
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 343
        if (! (i < iterations)) {
#line 343
          goto while_break___0;
        }
#line 345
        if (stl_in.stats.connected_facets_3_edge < stl_in.stats.number_of_facets) {
          {
          {
#line 348
          printf((char const   */* __restrict  */)"Checking nearby. Tolerance= %f Iteration=%d of %d...",
                 (double )tolerance, i + 1, iterations);
          }
          {
#line 351
          stl_check_facets_nearby(& stl_in, tolerance);
          }
          {
#line 352
          printf((char const   */* __restrict  */)"  Fixed %d edges.\n", stl_in.stats.edges_fixed - last_edges_fixed);
          }
#line 354
          last_edges_fixed = stl_in.stats.edges_fixed;
#line 355
          tolerance += increment;
          }
        } else {
          {
          {
#line 359
          printf((char const   */* __restrict  */)"All facets connected.  No further nearby check necessary.\n");
          }
          }
#line 361
          goto while_break___0;
        }
#line 343
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 367
      printf((char const   */* __restrict  */)"All facets connected.  No nearby check necessary.\n");
      }
      }
    }
  }
#line 371
  if (remove_unconnected_flag) {
#line 371
    goto _L___1;
  } else
#line 371
  if (fixall_flag) {
#line 371
    goto _L___1;
  } else
#line 371
  if (fill_holes_flag) {
    _L___1: /* CIL Label */ 
#line 373
    if (stl_in.stats.connected_facets_3_edge < stl_in.stats.number_of_facets) {
      {
      {
#line 375
      printf((char const   */* __restrict  */)"Removing unconnected facets...\n");
      }
      {
#line 376
      stl_remove_unconnected_facets(& stl_in);
      }
      }
    } else {
      {
      {
#line 379
      printf((char const   */* __restrict  */)"No unconnected need to be removed.\n");
      }
      }
    }
  }
#line 382
  if (fill_holes_flag) {
#line 382
    goto _L___2;
  } else
#line 382
  if (fixall_flag) {
    _L___2: /* CIL Label */ 
#line 384
    if (stl_in.stats.connected_facets_3_edge < stl_in.stats.number_of_facets) {
      {
      {
#line 386
      printf((char const   */* __restrict  */)"Filling holes...\n");
      }
      {
#line 387
      stl_fill_holes(& stl_in);
      }
      }
    } else {
      {
      {
#line 390
      printf((char const   */* __restrict  */)"No holes need to be filled.\n");
      }
      }
    }
  }
#line 393
  if (reverse_all_flag) {
    {
    {
#line 395
    printf((char const   */* __restrict  */)"Reversing all facets...\n");
    }
    {
#line 396
    stl_reverse_all_facets(& stl_in);
    }
    }
  }
#line 399
  if (normal_directions_flag) {
    {
    {
#line 401
    printf((char const   */* __restrict  */)"Checking normal directions...\n");
    }
    {
#line 402
    stl_fix_normal_directions(& stl_in);
    }
    }
  } else
#line 399
  if (fixall_flag) {
    {
    {
#line 401
    printf((char const   */* __restrict  */)"Checking normal directions...\n");
    }
    {
#line 402
    stl_fix_normal_directions(& stl_in);
    }
    }
  }
#line 405
  if (normal_values_flag) {
    {
    {
#line 407
    printf((char const   */* __restrict  */)"Checking normal values...\n");
    }
    {
#line 408
    stl_fix_normal_values(& stl_in);
    }
    }
  } else
#line 405
  if (fixall_flag) {
    {
    {
#line 407
    printf((char const   */* __restrict  */)"Checking normal values...\n");
    }
    {
#line 408
    stl_fix_normal_values(& stl_in);
    }
    }
  }
  {
  {
#line 412
  printf((char const   */* __restrict  */)"Calculating volume...\n");
  }
  {
#line 413
  stl_calculate_volume(& stl_in);
  }
  }
#line 415
  if (exact_flag) {
    {
    {
#line 417
    printf((char const   */* __restrict  */)"Verifying neighbors...\n");
    }
    {
#line 418
    stl_verify_neighbors(& stl_in);
    }
    }
  }
#line 421
  if (generate_shared_vertices_flag) {
    {
    {
#line 423
    printf((char const   */* __restrict  */)"Generating shared vertices...\n");
    }
    {
#line 424
    stl_generate_shared_vertices(& stl_in);
    }
    }
  }
#line 427
  if (write_off_flag) {
    {
    {
#line 429
    printf((char const   */* __restrict  */)"Writing OFF file %s\n", off_name);
    }
    {
#line 430
    stl_write_off(& stl_in, off_name);
    }
    }
  }
#line 433
  if (write_dxf_flag) {
    {
    {
#line 435
    printf((char const   */* __restrict  */)"Writing DXF file %s\n", dxf_name);
    }
    {
#line 436
    stl_write_dxf(& stl_in, dxf_name, (char *)"Created by ADMesh version 0.95");
    }
    }
  }
#line 439
  if (write_vrml_flag) {
    {
    {
#line 441
    printf((char const   */* __restrict  */)"Writing VRML file %s\n", vrml_name);
    }
    {
#line 442
    stl_write_vrml(& stl_in, vrml_name);
    }
    }
  }
#line 445
  if (write_ascii_stl_flag) {
    {
    {
#line 447
    printf((char const   */* __restrict  */)"Writing ascii file %s\n", ascii_name);
    }
    {
#line 448
    stl_write_ascii(& stl_in, ascii_name, (char *)"Processed by ADMesh version 0.95");
    }
    }
  }
#line 452
  if (write_binary_stl_flag) {
    {
    {
#line 454
    printf((char const   */* __restrict  */)"Writing binary file %s\n", binary_name);
    }
    {
#line 455
    stl_write_binary(& stl_in, binary_name, (char *)"Processed by ADMesh version 0.95");
    }
    }
  }
#line 459
  if (exact_flag) {
    {
    {
#line 461
    stl_stats_out(& stl_in, stdout, input_file);
    }
    }
  }
  {
  {
#line 464
  stl_close(& stl_in);
  }
  {
#line 466
  exit(0);
  }
  }
}
}
#line 469 "/home/wslee/benchmarks/admesh-0.95/admesh.c"
static void usage(int status , char *program_name ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 472
  if (status != 0) {
    {
    {
#line 474
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
            program_name);
    }
    }
  } else {
    {
    {
#line 478
    printf((char const   */* __restrict  */)"\nADMesh version 0.95\nCopyright (C) 1995, 1996  Anthony D. Martin\nUsage: %s [OPTION]... file\n",
           program_name);
    }
    {
#line 482
    printf((char const   */* __restrict  */)"\n     --x-rotate=angle     Rotate CCW about x-axis by angle degrees\n     --y-rotate=angle     Rotate CCW about y-axis by angle degrees\n     --z-rotate=angle     Rotate CCW about z-axis by angle degrees\n     --xy-mirror          Mirror about the xy plane\n     --yz-mirror          Mirror about the yz plane\n     --xz-mirror          Mirror about the xz plane\n     --scale=factor       Scale the file by factor (multiply by factor)\n     --translate=x,y,z    Translate the file to x, y, and z\n     --merge=name         Merge file called name with input file\n -e, --exact              Only check for perfectly matched edges\n -n, --nearby             Find and connect nearby facets. Correct bad facets\n -t, --tolerance=tol      Initial tolerance to use for nearby check = tol\n -i, --iterations=i       Number of iterations for nearby check = i\n -m, --increment=inc      Amount to increment tolerance after iteration=inc\n -u, --remove-unconnected Remove facets that have 0 neighbors\n -f, --fill-holes         Add facets to fill holes\n -d, --normal-directions  Check and fix direction of normals(ie cw, ccw)\n     --reverse-all        Reverse the directions of all facets and normals\n -v, --normal-values      Check and fix normal values\n -c, --no-check           Don\'t do any check on input file\n -b, --write-binary-stl=name   Output a binary STL file called name\n -a, --write-ascii-stl=name    Output an ascii STL file called name\n     --write-off=name     Output a Geomview OFF format file called name\n     --write-dxf=name     Output a DXF format file called name\n     --write-vrml=name    Output a VRML format file called name\n     --help               Display this help and exit\n     --version            Output version information and exit\n\nThe functions are executed in the same order as the options shown here.\nSo check here to find what happens if, for example, --translate and --merge\noptions are specified together.  The order of the options specified on the\ncommand line is not important.\n");
    }
    }
  }
  {
  {
#line 516
  exit(status);
  }
  }
}
}
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 157 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 170 "/home/wslee/benchmarks/admesh-0.95/stl.h"
void stl_calculate_normal(float *normal , stl_facet *facet ) ;
#line 171
void stl_normalize_vector(float *v ) ;
#line 28 "/home/wslee/benchmarks/admesh-0.95/normals.c"
static void stl_reverse_facet(stl_file *stl , int facet_num ) ;
#line 30
static void stl_reverse_vector(float *v ) ;
#line 31
int stl_check_normal_vector(stl_file *stl , int facet_num , int normal_fix_flag ) ;
#line 33 "/home/wslee/benchmarks/admesh-0.95/normals.c"
static void stl_reverse_facet(stl_file *stl , int facet_num ) 
{ 
  stl_vertex tmp_vertex ;
  int neighbor[3] ;
  int vnot[3] ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 41
  (stl->stats.facets_reversed) ++;
#line 43
  neighbor[0] = (stl->neighbors_start + facet_num)->neighbor[0];
#line 44
  neighbor[1] = (stl->neighbors_start + facet_num)->neighbor[1];
#line 45
  neighbor[2] = (stl->neighbors_start + facet_num)->neighbor[2];
#line 46
  vnot[0] = (int )(stl->neighbors_start + facet_num)->which_vertex_not[0];
#line 47
  vnot[1] = (int )(stl->neighbors_start + facet_num)->which_vertex_not[1];
#line 48
  vnot[2] = (int )(stl->neighbors_start + facet_num)->which_vertex_not[2];
#line 51
  tmp_vertex = (stl->facet_start + facet_num)->vertex[0];
#line 52
  (stl->facet_start + facet_num)->vertex[0] = (stl->facet_start + facet_num)->vertex[1];
#line 54
  (stl->facet_start + facet_num)->vertex[1] = tmp_vertex;
#line 57
  if (neighbor[0] != -1) {
#line 58
    (stl->neighbors_start + neighbor[0])->which_vertex_not[(vnot[0] + 1) % 3] = (char )(((int )(stl->neighbors_start + neighbor[0])->which_vertex_not[(vnot[0] + 1) % 3] + 3) % 6);
  }
#line 61
  if (neighbor[1] != -1) {
#line 62
    (stl->neighbors_start + neighbor[1])->which_vertex_not[(vnot[1] + 1) % 3] = (char )(((int )(stl->neighbors_start + neighbor[1])->which_vertex_not[(vnot[1] + 1) % 3] + 4) % 6);
  }
#line 65
  if (neighbor[2] != -1) {
#line 66
    (stl->neighbors_start + neighbor[2])->which_vertex_not[(vnot[2] + 1) % 3] = (char )(((int )(stl->neighbors_start + neighbor[2])->which_vertex_not[(vnot[2] + 1) % 3] + 2) % 6);
  }
#line 71
  (stl->neighbors_start + facet_num)->neighbor[1] = neighbor[2];
#line 72
  (stl->neighbors_start + facet_num)->neighbor[2] = neighbor[1];
#line 75
  (stl->neighbors_start + facet_num)->which_vertex_not[1] = (char )vnot[2];
#line 76
  (stl->neighbors_start + facet_num)->which_vertex_not[2] = (char )vnot[1];
#line 79
  (stl->neighbors_start + facet_num)->which_vertex_not[0] = (char )(((int )(stl->neighbors_start + facet_num)->which_vertex_not[0] + 3) % 6);
#line 81
  (stl->neighbors_start + facet_num)->which_vertex_not[1] = (char )(((int )(stl->neighbors_start + facet_num)->which_vertex_not[1] + 3) % 6);
#line 83
  (stl->neighbors_start + facet_num)->which_vertex_not[2] = (char )(((int )(stl->neighbors_start + facet_num)->which_vertex_not[2] + 3) % 6);
#line 85
  return;
}
}
#line 87 "/home/wslee/benchmarks/admesh-0.95/normals.c"
void stl_fix_normal_directions(stl_file *stl ) 
{ 
  char *norm_sw ;
  int checked ;
  int facet_num ;
  int i ;
  int j ;
  int checked_before ;
  struct stl_normal *head ;
  struct stl_normal *tail ;
  struct stl_normal *new ;
  struct stl_normal *temp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 93
  checked = 0;
#line 98
  checked_before = 0;
  {
#line 111
  tmp = malloc((size_t )sizeof(struct stl_normal ));
  }
#line 111
  head = (struct stl_normal *)tmp;
  }
#line 112
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    {
    {
#line 112
    perror("stl_fix_normal_directions");
    }
    }
  }
  {
  {
#line 113
  tmp___0 = malloc((size_t )sizeof(struct stl_normal ));
  }
#line 113
  tail = (struct stl_normal *)tmp___0;
  }
#line 114
  if ((unsigned long )tail == (unsigned long )((void *)0)) {
    {
    {
#line 114
    perror("stl_fix_normal_directions");
    }
    }
  }
  {
#line 115
  head->next = tail;
#line 116
  tail->next = tail;
  {
#line 119
  tmp___1 = calloc((size_t )stl->stats.number_of_facets, (size_t )sizeof(char ));
  }
#line 119
  norm_sw = (char *)tmp___1;
  }
#line 120
  if ((unsigned long )norm_sw == (unsigned long )((void *)0)) {
    {
    {
#line 120
    perror("stl_fix_normal_directions");
    }
    }
  }
  {
#line 123
  facet_num = 0;
  {
#line 124
  tmp___2 = stl_check_normal_vector(stl, 0, 0);
  }
  }
#line 124
  if (tmp___2 == 2) {
    {
    {
#line 125
    stl_reverse_facet(stl, 0);
    }
    }
  }
#line 127
  *(norm_sw + facet_num) = (char)1;
#line 131
  checked ++;
  {
  {
#line 133
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 136
    j = 0;
    {
    {
#line 136
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (j < 3)) {
#line 136
        goto while_break___0;
      }
#line 139
      if ((int )(stl->neighbors_start + facet_num)->which_vertex_not[j] > 2) {
#line 141
        if ((stl->neighbors_start + facet_num)->neighbor[j] != -1) {
          {
          {
#line 143
          stl_reverse_facet(stl, (stl->neighbors_start + facet_num)->neighbor[j]);
          }
          }
        }
      }
#line 147
      if ((stl->neighbors_start + facet_num)->neighbor[j] != -1) {
#line 149
        if ((int )*(norm_sw + (stl->neighbors_start + facet_num)->neighbor[j]) != 1) {
          {
          {
#line 152
          tmp___3 = malloc((size_t )sizeof(struct stl_normal ));
          }
#line 152
          new = (struct stl_normal *)tmp___3;
          }
#line 153
          if ((unsigned long )new == (unsigned long )((void *)0)) {
            {
            {
#line 153
            perror("stl_fix_normal_directions");
            }
            }
          }
#line 154
          new->facet_num = (stl->neighbors_start + facet_num)->neighbor[j];
#line 155
          new->next = head->next;
#line 156
          head->next = new;
        }
      }
#line 136
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 161
    if ((unsigned long )head->next != (unsigned long )tail) {
#line 163
      facet_num = (head->next)->facet_num;
#line 164
      if ((int )*(norm_sw + facet_num) != 1) {
#line 166
        *(norm_sw + facet_num) = (char)1;
#line 167
        checked ++;
      }
      {
#line 169
      temp = head->next;
#line 170
      head->next = (head->next)->next;
      {
#line 171
      free((void *)temp);
      }
      }
    } else {
#line 176
      (stl->stats.number_of_parts) ++;
#line 179
      checked_before = checked;
#line 180
      if (checked == stl->stats.number_of_facets) {
#line 183
        goto while_break;
      } else {
#line 188
        i = 0;
        {
        {
#line 188
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 188
          if (! (i < stl->stats.number_of_facets)) {
#line 188
            goto while_break___1;
          }
#line 190
          if ((int )*(norm_sw + i) == 0) {
            {
#line 192
            facet_num = i;
            {
#line 193
            tmp___4 = stl_check_normal_vector(stl, i, 0);
            }
            }
#line 193
            if (tmp___4 == 2) {
              {
              {
#line 195
              stl_reverse_facet(stl, i);
              }
              }
            }
#line 198
            *(norm_sw + facet_num) = (char)1;
#line 199
            checked ++;
#line 200
            goto while_break___1;
          }
#line 188
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 206
  free((void *)head);
  }
  {
#line 207
  free((void *)tail);
  }
  {
#line 208
  free((void *)norm_sw);
  }
  }
#line 209
  return;
}
}
#line 211 "/home/wslee/benchmarks/admesh-0.95/normals.c"
int stl_check_normal_vector(stl_file *stl , int facet_num , int normal_fix_flag ) 
{ 
  float normal[3] ;
  float test_norm[3] ;
  stl_facet *facet ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;
  float tmp___7 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;

  {
  {
#line 223
  facet = stl->facet_start + facet_num;
  {
#line 225
  stl_calculate_normal(normal, facet);
  }
  {
#line 226
  stl_normalize_vector(normal);
  }
  }
#line 228
  if (normal[0] - facet->normal.x < (float )0) {
#line 228
    tmp = - (normal[0] - facet->normal.x);
  } else {
#line 228
    tmp = normal[0] - facet->normal.x;
  }
#line 228
  if ((double )tmp < 0.001) {
#line 228
    if (normal[1] - facet->normal.y < (float )0) {
#line 228
      tmp___0 = - (normal[1] - facet->normal.y);
    } else {
#line 228
      tmp___0 = normal[1] - facet->normal.y;
    }
#line 228
    if ((double )tmp___0 < 0.001) {
#line 228
      if (normal[2] - facet->normal.z < (float )0) {
#line 228
        tmp___1 = - (normal[2] - facet->normal.z);
      } else {
#line 228
        tmp___1 = normal[2] - facet->normal.z;
      }
#line 228
      if ((double )tmp___1 < 0.001) {
#line 234
        facet->normal.x = normal[0];
#line 235
        facet->normal.y = normal[1];
#line 236
        facet->normal.z = normal[2];
#line 237
        return (0);
      }
    }
  }
  {
#line 240
  test_norm[0] = facet->normal.x;
#line 241
  test_norm[1] = facet->normal.y;
#line 242
  test_norm[2] = facet->normal.z;
  {
#line 244
  stl_normalize_vector(test_norm);
  }
  }
#line 245
  if (normal[0] - test_norm[0] < (float )0) {
#line 245
    tmp___2 = - (normal[0] - test_norm[0]);
  } else {
#line 245
    tmp___2 = normal[0] - test_norm[0];
  }
#line 245
  if ((double )tmp___2 < 0.001) {
#line 245
    if (normal[1] - test_norm[1] < (float )0) {
#line 245
      tmp___3 = - (normal[1] - test_norm[1]);
    } else {
#line 245
      tmp___3 = normal[1] - test_norm[1];
    }
#line 245
    if ((double )tmp___3 < 0.001) {
#line 245
      if (normal[2] - test_norm[2] < (float )0) {
#line 245
        tmp___4 = - (normal[2] - test_norm[2]);
      } else {
#line 245
        tmp___4 = normal[2] - test_norm[2];
      }
#line 245
      if ((double )tmp___4 < 0.001) {
#line 249
        if (normal_fix_flag) {
#line 251
          facet->normal.x = normal[0];
#line 252
          facet->normal.y = normal[1];
#line 253
          facet->normal.z = normal[2];
#line 254
          (stl->stats.normals_fixed) ++;
        }
#line 256
        return (1);
      }
    }
  }
  {
  {
#line 259
  stl_reverse_vector(test_norm);
  }
  }
#line 260
  if (normal[0] - test_norm[0] < (float )0) {
#line 260
    tmp___5 = - (normal[0] - test_norm[0]);
  } else {
#line 260
    tmp___5 = normal[0] - test_norm[0];
  }
#line 260
  if ((double )tmp___5 < 0.001) {
#line 260
    if (normal[1] - test_norm[1] < (float )0) {
#line 260
      tmp___6 = - (normal[1] - test_norm[1]);
    } else {
#line 260
      tmp___6 = normal[1] - test_norm[1];
    }
#line 260
    if ((double )tmp___6 < 0.001) {
#line 260
      if (normal[2] - test_norm[2] < (float )0) {
#line 260
        tmp___7 = - (normal[2] - test_norm[2]);
      } else {
#line 260
        tmp___7 = normal[2] - test_norm[2];
      }
#line 260
      if ((double )tmp___7 < 0.001) {
#line 265
        if (normal_fix_flag) {
#line 267
          facet->normal.x = normal[0];
#line 268
          facet->normal.y = normal[1];
#line 269
          facet->normal.z = normal[2];
#line 270
          (stl->stats.normals_fixed) ++;
        }
#line 272
        return (2);
      }
    }
  }
#line 274
  if (normal_fix_flag) {
#line 276
    facet->normal.x = normal[0];
#line 277
    facet->normal.y = normal[1];
#line 278
    facet->normal.z = normal[2];
#line 279
    (stl->stats.normals_fixed) ++;
  }
#line 281
  return (4);
}
}
#line 284 "/home/wslee/benchmarks/admesh-0.95/normals.c"
static void stl_reverse_vector(float *v ) 
{ 


  {
#line 287
  *(v + 0) *= (float )-1;
#line 288
  *(v + 1) *= (float )-1;
#line 289
  *(v + 2) *= (float )-1;
#line 290
  return;
}
}
#line 293 "/home/wslee/benchmarks/admesh-0.95/normals.c"
void stl_calculate_normal(float *normal , stl_facet *facet ) 
{ 
  float v1[3] ;
  float v2[3] ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 299
  v1[0] = facet->vertex[1].x - facet->vertex[0].x;
#line 300
  v1[1] = facet->vertex[1].y - facet->vertex[0].y;
#line 301
  v1[2] = facet->vertex[1].z - facet->vertex[0].z;
#line 302
  v2[0] = facet->vertex[2].x - facet->vertex[0].x;
#line 303
  v2[1] = facet->vertex[2].y - facet->vertex[0].y;
#line 304
  v2[2] = facet->vertex[2].z - facet->vertex[0].z;
#line 306
  *(normal + 0) = (float )((double )((float )((double )v1[1] * (double )v2[2])) - (double )v1[2] * (double )v2[1]);
#line 307
  *(normal + 1) = (float )((double )((float )((double )v1[2] * (double )v2[0])) - (double )v1[0] * (double )v2[2]);
#line 308
  *(normal + 2) = (float )((double )((float )((double )v1[0] * (double )v2[1])) - (double )v1[1] * (double )v2[0]);
#line 309
  return;
}
}
#line 343 "/home/wslee/benchmarks/admesh-0.95/normals.c"
void stl_normalize_vector(float *v ) 
{ 
  double length ;
  double factor ;
  float min_normal_length ;

  {
  {
  {
#line 349
  length = sqrt(((double )*(v + 0) * (double )*(v + 0) + (double )*(v + 1) * (double )*(v + 1)) + (double )*(v + 2) * (double )*(v + 2));
  }
#line 350
  min_normal_length = (float )0.000000000001;
  }
#line 351
  if (length < (double )min_normal_length) {
#line 353
    *(v + 0) = (float )1.0;
#line 354
    *(v + 1) = (float )0.0;
#line 355
    *(v + 2) = (float )0.0;
#line 356
    return;
  }
#line 358
  factor = 1.0 / length;
#line 359
  *(v + 0) = (float )((double )*(v + 0) * factor);
#line 360
  *(v + 1) = (float )((double )*(v + 1) * factor);
#line 361
  *(v + 2) = (float )((double )*(v + 2) * factor);
#line 362
  return;
}
}
#line 364 "/home/wslee/benchmarks/admesh-0.95/normals.c"
void stl_fix_normal_values(stl_file *stl ) 
{ 
  int i ;

  {
#line 369
  i = 0;
  {
  {
#line 369
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i < stl->stats.number_of_facets)) {
#line 369
      goto while_break;
    }
    {
    {
#line 371
    stl_check_normal_vector(stl, i, 1);
    }
#line 369
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return;
}
}
#line 375 "/home/wslee/benchmarks/admesh-0.95/normals.c"
void stl_reverse_all_facets(stl_file *stl ) 
{ 
  int i ;
  float normal[3] ;
  void *__cil_tmp4 ;

  {
#line 381
  i = 0;
  {
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < stl->stats.number_of_facets)) {
#line 381
      goto while_break;
    }
    {
    {
#line 383
    stl_reverse_facet(stl, i);
    }
    {
#line 384
    stl_calculate_normal(normal, stl->facet_start + i);
    }
    {
#line 385
    stl_normalize_vector(normal);
    }
#line 386
    (stl->facet_start + i)->normal.x = normal[0];
#line 387
    (stl->facet_start + i)->normal.y = normal[1];
#line 388
    (stl->facet_start + i)->normal.z = normal[2];
#line 381
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 461 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 140 "/home/wslee/benchmarks/admesh-0.95/stl.h"
void stl_print_edges(stl_file *stl , FILE *file ) ;
#line 141
void stl_print_neighbors(stl_file *stl , char *file ) ;
#line 147
void stl_write_vertex(stl_file *stl , int facet , int vertex ) ;
#line 148
void stl_write_facet(stl_file *stl , char *label , int facet ) ;
#line 149
void stl_write_edge(stl_file *stl , char *label , stl_hash_edge edge ) ;
#line 150
void stl_write_neighbor(stl_file *stl , int facet ) ;
#line 151
void stl_write_quad_object(stl_file *stl , char *file ) ;
#line 30 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
static void stl_put_little_int(FILE *fp , int value_in ) ;
#line 31
static void stl_put_little_float(FILE *fp , float value_in ) ;
#line 33 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_print_edges(stl_file *stl , FILE *file ) 
{ 
  int i ;
  int edges_allocated ;
  char *__cil_tmp5 ;

  {
#line 39
  edges_allocated = stl->stats.number_of_facets * 3;
#line 40
  i = 0;
  {
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < edges_allocated)) {
#line 40
      goto while_break;
    }
    {
    {
#line 42
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d, %f, %f, %f, %f, %f, %f\n",
            (stl->edge_start + i)->facet_number, (double )(stl->edge_start + i)->p1.x,
            (double )(stl->edge_start + i)->p1.y, (double )(stl->edge_start + i)->p1.z,
            (double )(stl->edge_start + i)->p2.x, (double )(stl->edge_start + i)->p2.y,
            (double )(stl->edge_start + i)->p2.z);
    }
#line 40
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 51 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_stats_out(stl_file *stl , FILE *file , char *input_file ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
  {
#line 54
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n================= Results produced by ADMesh version 0.95 ================\n");
  }
  {
#line 56
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Input file         : %s\n",
          input_file);
  }
  }
#line 58
  if ((unsigned int )stl->stats.type == 0U) {
    {
    {
#line 60
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"File type          : Binary STL file\n");
    }
    }
  } else {
    {
    {
#line 65
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"File type          : ASCII STL file\n");
    }
    }
  }
  {
  {
#line 68
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Header             : %s\n",
          stl->stats.header);
  }
  {
#line 70
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"============== Size ==============\n");
  }
  {
#line 71
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Min X = % f, Max X = % f\n",
          (double )stl->stats.min.x, (double )stl->stats.max.x);
  }
  {
#line 73
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Min Y = % f, Max Y = % f\n",
          (double )stl->stats.min.y, (double )stl->stats.max.y);
  }
  {
#line 75
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Min Z = % f, Max Z = % f\n",
          (double )stl->stats.min.z, (double )stl->stats.max.z);
  }
  {
#line 78
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"========= Facet Status ========== Original ============ Final ====\n");
  }
  {
#line 80
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Number of facets                 : %5d               %5d\n",
          stl->stats.original_num_facets, stl->stats.number_of_facets);
  }
  {
#line 83
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Facets with 1 disconnected edge  : %5d               %5d\n",
          stl->stats.facets_w_1_bad_edge, stl->stats.connected_facets_2_edge - stl->stats.connected_facets_3_edge);
  }
  {
#line 87
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Facets with 2 disconnected edges : %5d               %5d\n",
          stl->stats.facets_w_2_bad_edge, stl->stats.connected_facets_1_edge - stl->stats.connected_facets_2_edge);
  }
  {
#line 91
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Facets with 3 disconnected edges : %5d               %5d\n",
          stl->stats.facets_w_3_bad_edge, stl->stats.number_of_facets - stl->stats.connected_facets_1_edge);
  }
  {
#line 95
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Total disconnected facets        : %5d               %5d\n",
          (stl->stats.facets_w_1_bad_edge + stl->stats.facets_w_2_bad_edge) + stl->stats.facets_w_3_bad_edge,
          stl->stats.number_of_facets - stl->stats.connected_facets_3_edge);
  }
  {
#line 101
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"=== Processing Statistics ===     ===== Other Statistics =====\n");
  }
  {
#line 103
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Number of parts       : %5d        Volume   : % f\n",
          stl->stats.number_of_parts, (double )stl->stats.volume);
  }
  {
#line 106
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Degenerate facets     : %5d\n",
          stl->stats.degenerate_facets);
  }
  {
#line 108
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Edges fixed           : %5d\n",
          stl->stats.edges_fixed);
  }
  {
#line 110
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Facets removed        : %5d\n",
          stl->stats.facets_removed);
  }
  {
#line 112
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Facets added          : %5d\n",
          stl->stats.facets_added);
  }
  {
#line 114
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Facets reversed       : %5d\n",
          stl->stats.facets_reversed);
  }
  {
#line 116
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Backwards edges       : %5d\n",
          stl->stats.backwards_edges);
  }
  {
#line 118
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Normals fixed         : %5d\n",
          stl->stats.normals_fixed);
  }
  }
#line 120
  return;
}
}
#line 134
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 122 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_ascii(stl_file *stl , char *file , char *label ) 
{ 
  int i ;
  FILE *fp ;
  char *error_msg ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 131
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 132
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 134
    tmp = (int )strlen(file);
    }
    {
#line 134
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 134
    error_msg = (char *)tmp___0;
    {
#line 136
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_write_ascii: Couldn\'t open %s for writing",
            file);
    }
    {
#line 138
    perror((char const   *)error_msg);
    }
    {
#line 139
    free((void *)error_msg);
    }
    {
#line 140
    exit(1);
    }
    }
  }
  {
  {
#line 143
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"solid  %s\n",
          label);
  }
#line 145
  i = 0;
  }
  {
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < stl->stats.number_of_facets)) {
#line 145
      goto while_break;
    }
    {
    {
#line 147
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  facet normal % .8E % .8E % .8E\n",
            (double )(stl->facet_start + i)->normal.x, (double )(stl->facet_start + i)->normal.y,
            (double )(stl->facet_start + i)->normal.z);
    }
    {
#line 150
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    outer loop\n");
    }
    {
#line 151
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"      vertex % .8E % .8E % .8E\n",
            (double )(stl->facet_start + i)->vertex[0].x, (double )(stl->facet_start + i)->vertex[0].y,
            (double )(stl->facet_start + i)->vertex[0].z);
    }
    {
#line 154
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"      vertex % .8E % .8E % .8E\n",
            (double )(stl->facet_start + i)->vertex[1].x, (double )(stl->facet_start + i)->vertex[1].y,
            (double )(stl->facet_start + i)->vertex[1].z);
    }
    {
#line 157
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"      vertex % .8E % .8E % .8E\n",
            (double )(stl->facet_start + i)->vertex[2].x, (double )(stl->facet_start + i)->vertex[2].y,
            (double )(stl->facet_start + i)->vertex[2].z);
    }
    {
#line 160
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    endloop\n");
    }
    {
#line 161
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  endfacet\n");
    }
#line 145
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 164
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"endsolid  %s\n",
          label);
  }
  {
#line 166
  fclose(fp);
  }
  }
#line 167
  return;
}
}
#line 169 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_print_neighbors(stl_file *stl , char *file ) 
{ 
  int i ;
  FILE *fp ;
  char *error_msg ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 177
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 178
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 180
    tmp = (int )strlen(file);
    }
    {
#line 180
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 180
    error_msg = (char *)tmp___0;
    {
#line 182
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_print_neighbors: Couldn\'t open %s for writing",
            file);
    }
    {
#line 184
    perror((char const   *)error_msg);
    }
    {
#line 185
    free((void *)error_msg);
    }
    {
#line 186
    exit(1);
    }
    }
  }
#line 189
  i = 0;
  {
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < stl->stats.number_of_facets)) {
#line 189
      goto while_break;
    }
    {
    {
#line 191
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d, %d,%d, %d,%d, %d,%d\n",
            i, (stl->neighbors_start + i)->neighbor[0], (int )(stl->neighbors_start + i)->which_vertex_not[0],
            (stl->neighbors_start + i)->neighbor[1], (int )(stl->neighbors_start + i)->which_vertex_not[1],
            (stl->neighbors_start + i)->neighbor[2], (int )(stl->neighbors_start + i)->which_vertex_not[2]);
    }
#line 189
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 202 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
static void stl_put_little_int(FILE *fp , int value_in ) 
{ 
  int new_value ;
  union __anonunion_value_32 value ;

  {
  {
#line 212
  value.int_value = value_in;
#line 214
  new_value = (int )value.char_value[0] & 255;
#line 215
  new_value |= ((int )value.char_value[1] & 255) << 8;
#line 216
  new_value |= ((int )value.char_value[2] & 255) << 16;
#line 217
  new_value |= ((int )value.char_value[3] & 255) << 24;
  {
#line 218
  fwrite((void const   */* __restrict  */)(& new_value), (size_t )sizeof(int ), (size_t )1,
         (FILE */* __restrict  */)fp);
  }
  }
#line 219
  return;
}
}
#line 221 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
static void stl_put_little_float(FILE *fp , float value_in ) 
{ 
  int new_value ;
  union __anonunion_value_33 value ;

  {
  {
#line 231
  value.float_value = value_in;
#line 233
  new_value = (int )value.char_value[0] & 255;
#line 234
  new_value |= ((int )value.char_value[1] & 255) << 8;
#line 235
  new_value |= ((int )value.char_value[2] & 255) << 16;
#line 236
  new_value |= ((int )value.char_value[3] & 255) << 24;
  {
#line 237
  fwrite((void const   */* __restrict  */)(& new_value), (size_t )sizeof(int ), (size_t )1,
         (FILE */* __restrict  */)fp);
  }
  }
#line 238
  return;
}
}
#line 241 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_binary(stl_file *stl , char *file , char *label ) 
{ 
  FILE *fp ;
  int i ;
  char *error_msg ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 250
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 251
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 253
    tmp = (int )strlen(file);
    }
    {
#line 253
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 253
    error_msg = (char *)tmp___0;
    {
#line 255
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_write_binary: Couldn\'t open %s for writing",
            file);
    }
    {
#line 257
    perror((char const   *)error_msg);
    }
    {
#line 258
    free((void *)error_msg);
    }
    {
#line 259
    exit(1);
    }
    }
  }
  {
  {
#line 262
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", label);
  }
  {
#line 263
  i = (int )strlen(label);
  }
  }
  {
  {
#line 263
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i < 80)) {
#line 263
      goto while_break;
    }
    {
    {
#line 263
    _IO_putc(0, fp);
    }
#line 263
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 265
  fseek(fp, 80L, 0);
  }
  {
#line 267
  stl_put_little_int(fp, stl->stats.number_of_facets);
  }
#line 269
  i = 0;
  }
  {
  {
#line 269
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 269
    if (! (i < stl->stats.number_of_facets)) {
#line 269
      goto while_break___0;
    }
    {
    {
#line 271
    stl_put_little_float(fp, (stl->facet_start + i)->normal.x);
    }
    {
#line 272
    stl_put_little_float(fp, (stl->facet_start + i)->normal.y);
    }
    {
#line 273
    stl_put_little_float(fp, (stl->facet_start + i)->normal.z);
    }
    {
#line 274
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[0].x);
    }
    {
#line 275
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[0].y);
    }
    {
#line 276
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[0].z);
    }
    {
#line 277
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[1].x);
    }
    {
#line 278
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[1].y);
    }
    {
#line 279
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[1].z);
    }
    {
#line 280
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[2].x);
    }
    {
#line 281
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[2].y);
    }
    {
#line 282
    stl_put_little_float(fp, (stl->facet_start + i)->vertex[2].z);
    }
    {
#line 283
    fputc((int )(stl->facet_start + i)->extra[0], fp);
    }
    {
#line 284
    fputc((int )(stl->facet_start + i)->extra[1], fp);
    }
#line 269
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 287
  fclose(fp);
  }
  }
#line 288
  return;
}
}
#line 290 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_vertex(stl_file *stl , int facet , int vertex ) 
{ 
  char *__cil_tmp4 ;

  {
  {
  {
#line 293
  printf((char const   */* __restrict  */)"  vertex %d/%d % .8E % .8E % .8E\n", vertex,
         facet, (double )(stl->facet_start + facet)->vertex[vertex].x, (double )(stl->facet_start + facet)->vertex[vertex].y,
         (double )(stl->facet_start + facet)->vertex[vertex].z);
  }
  }
#line 297
  return;
}
}
#line 299 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_facet(stl_file *stl , char *label , int facet ) 
{ 
  char *__cil_tmp4 ;

  {
  {
  {
#line 302
  printf((char const   */* __restrict  */)"facet (%d)/ %s\n", facet, label);
  }
  {
#line 303
  stl_write_vertex(stl, facet, 0);
  }
  {
#line 304
  stl_write_vertex(stl, facet, 1);
  }
  {
#line 305
  stl_write_vertex(stl, facet, 2);
  }
  }
#line 306
  return;
}
}
#line 308 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_edge(stl_file *stl , char *label , stl_hash_edge edge ) 
{ 
  char *__cil_tmp4 ;

  {
  {
  {
#line 311
  printf((char const   */* __restrict  */)"edge (%d)/(%d) %s\n", edge.facet_number,
         edge.which_edge, label);
  }
  }
#line 312
  if (edge.which_edge < 3) {
    {
    {
#line 314
    stl_write_vertex(stl, edge.facet_number, edge.which_edge % 3);
    }
    {
#line 315
    stl_write_vertex(stl, edge.facet_number, (edge.which_edge + 1) % 3);
    }
    }
  } else {
    {
    {
#line 319
    stl_write_vertex(stl, edge.facet_number, (edge.which_edge + 1) % 3);
    }
    {
#line 320
    stl_write_vertex(stl, edge.facet_number, edge.which_edge % 3);
    }
    }
  }
#line 322
  return;
}
}
#line 324 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_neighbor(stl_file *stl , int facet ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 327
  printf((char const   */* __restrict  */)"Neighbors %d: %d, %d, %d ;  %d, %d, %d\n",
         facet, (stl->neighbors_start + facet)->neighbor[0], (stl->neighbors_start + facet)->neighbor[1],
         (stl->neighbors_start + facet)->neighbor[2], (int )(stl->neighbors_start + facet)->which_vertex_not[0],
         (int )(stl->neighbors_start + facet)->which_vertex_not[1], (int )(stl->neighbors_start + facet)->which_vertex_not[2]);
  }
  }
#line 334
  return;
}
}
#line 336 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_quad_object(stl_file *stl , char *file ) 
{ 
  FILE *fp ;
  int i ;
  int j ;
  char *error_msg ;
  stl_vertex connect_color ;
  stl_vertex uncon_1_color ;
  stl_vertex uncon_2_color ;
  stl_vertex uncon_3_color ;
  stl_vertex color ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 350
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 351
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 353
    tmp = (int )strlen(file);
    }
    {
#line 353
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 353
    error_msg = (char *)tmp___0;
    {
#line 355
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_write_quad_object: Couldn\'t open %s for writing",
            file);
    }
    {
#line 357
    perror((char const   *)error_msg);
    }
    {
#line 358
    free((void *)error_msg);
    }
    {
#line 359
    exit(1);
    }
    }
  }
  {
#line 362
  connect_color.x = (float )0.0;
#line 363
  connect_color.y = (float )0.0;
#line 364
  connect_color.z = (float )1.0;
#line 365
  uncon_1_color.x = (float )0.0;
#line 366
  uncon_1_color.y = (float )1.0;
#line 367
  uncon_1_color.z = (float )0.0;
#line 368
  uncon_2_color.x = (float )1.0;
#line 369
  uncon_2_color.y = (float )1.0;
#line 370
  uncon_2_color.z = (float )1.0;
#line 371
  uncon_3_color.x = (float )1.0;
#line 372
  uncon_3_color.y = (float )0.0;
#line 373
  uncon_3_color.z = (float )0.0;
  {
#line 375
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"CQUAD\n");
  }
#line 376
  i = 0;
  }
  {
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < stl->stats.number_of_facets)) {
#line 376
      goto while_break;
    }
#line 378
    j = (((stl->neighbors_start + i)->neighbor[0] == -1) + ((stl->neighbors_start + i)->neighbor[1] == -1)) + ((stl->neighbors_start + i)->neighbor[2] == -1);
#line 381
    if (j == 0) {
#line 383
      color = connect_color;
    } else
#line 385
    if (j == 1) {
#line 387
      color = uncon_1_color;
    } else
#line 389
    if (j == 2) {
#line 391
      color = uncon_2_color;
    } else {
#line 395
      color = uncon_3_color;
    }
    {
    {
#line 397
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f %f %f    %1.1f %1.1f %1.1f 1\n",
            (double )(stl->facet_start + i)->vertex[0].x, (double )(stl->facet_start + i)->vertex[0].y,
            (double )(stl->facet_start + i)->vertex[0].z, (double )color.x, (double )color.y,
            (double )color.z);
    }
    {
#line 401
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f %f %f    %1.1f %1.1f %1.1f 1\n",
            (double )(stl->facet_start + i)->vertex[1].x, (double )(stl->facet_start + i)->vertex[1].y,
            (double )(stl->facet_start + i)->vertex[1].z, (double )color.x, (double )color.y,
            (double )color.z);
    }
    {
#line 405
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f %f %f    %1.1f %1.1f %1.1f 1\n",
            (double )(stl->facet_start + i)->vertex[2].x, (double )(stl->facet_start + i)->vertex[2].y,
            (double )(stl->facet_start + i)->vertex[2].z, (double )color.x, (double )color.y,
            (double )color.z);
    }
    {
#line 409
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%f %f %f    %1.1f %1.1f %1.1f 1\n",
            (double )(stl->facet_start + i)->vertex[2].x, (double )(stl->facet_start + i)->vertex[2].y,
            (double )(stl->facet_start + i)->vertex[2].z, (double )color.x, (double )color.y,
            (double )color.z);
    }
#line 376
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 414
  fclose(fp);
  }
  }
#line 415
  return;
}
}
#line 417 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
void stl_write_dxf(stl_file *stl , char *file , char *label ) 
{ 
  int i ;
  FILE *fp ;
  char *error_msg ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 426
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 427
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 429
    tmp = (int )strlen(file);
    }
    {
#line 429
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 429
    error_msg = (char *)tmp___0;
    {
#line 431
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_write_ascii: Couldn\'t open %s for writing",
            file);
    }
    {
#line 433
    perror((char const   *)error_msg);
    }
    {
#line 434
    free((void *)error_msg);
    }
    {
#line 435
    exit(1);
    }
    }
  }
  {
  {
#line 438
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"999\n%s\n",
          label);
  }
  {
#line 439
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0\nSECTION\n2\nHEADER\n0\nENDSEC\n");
  }
  {
#line 440
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0\nSECTION\n2\nTABLES\n0\nTABLE\n2\nLAYER\n70\n1\n0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n0\nENDTAB\n0\nENDSEC\n");
  }
  {
#line 442
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n");
  }
  {
#line 444
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0\nSECTION\n2\nENTITIES\n");
  }
#line 446
  i = 0;
  }
  {
  {
#line 446
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < stl->stats.number_of_facets)) {
#line 446
      goto while_break;
    }
    {
    {
#line 448
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0\n3DFACE\n8\n0\n");
    }
    {
#line 449
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"10\n%f\n20\n%f\n30\n%f\n",
            (double )(stl->facet_start + i)->vertex[0].x, (double )(stl->facet_start + i)->vertex[0].y,
            (double )(stl->facet_start + i)->vertex[0].z);
    }
    {
#line 452
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"11\n%f\n21\n%f\n31\n%f\n",
            (double )(stl->facet_start + i)->vertex[1].x, (double )(stl->facet_start + i)->vertex[1].y,
            (double )(stl->facet_start + i)->vertex[1].z);
    }
    {
#line 455
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"12\n%f\n22\n%f\n32\n%f\n",
            (double )(stl->facet_start + i)->vertex[2].x, (double )(stl->facet_start + i)->vertex[2].y,
            (double )(stl->facet_start + i)->vertex[2].z);
    }
    {
#line 458
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"13\n%f\n23\n%f\n33\n%f\n",
            (double )(stl->facet_start + i)->vertex[2].x, (double )(stl->facet_start + i)->vertex[2].y,
            (double )(stl->facet_start + i)->vertex[2].z);
    }
#line 446
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 463
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"0\nENDSEC\n0\nEOF\n");
  }
  {
#line 465
  fclose(fp);
  }
  }
#line 466
  return;
}
}
#line 28 "/home/wslee/benchmarks/admesh-0.95/normals.c"
static void stl_reverse_facet___0(stl_file *stl , int facet_num ) ;
#line 30
static void stl_reverse_vector___0(float *v ) ;
#line 33 "/home/wslee/benchmarks/admesh-0.95/normals.c"
static void stl_reverse_facet___0(stl_file *stl , int facet_num ) 
{ 
  stl_vertex tmp_vertex ;
  int neighbor[3] ;
  int vnot[3] ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 41
  (stl->stats.facets_reversed) ++;
#line 43
  neighbor[0] = (stl->neighbors_start + facet_num)->neighbor[0];
#line 44
  neighbor[1] = (stl->neighbors_start + facet_num)->neighbor[1];
#line 45
  neighbor[2] = (stl->neighbors_start + facet_num)->neighbor[2];
#line 46
  vnot[0] = (int )(stl->neighbors_start + facet_num)->which_vertex_not[0];
#line 47
  vnot[1] = (int )(stl->neighbors_start + facet_num)->which_vertex_not[1];
#line 48
  vnot[2] = (int )(stl->neighbors_start + facet_num)->which_vertex_not[2];
#line 51
  tmp_vertex = (stl->facet_start + facet_num)->vertex[0];
#line 52
  (stl->facet_start + facet_num)->vertex[0] = (stl->facet_start + facet_num)->vertex[1];
#line 54
  (stl->facet_start + facet_num)->vertex[1] = tmp_vertex;
#line 57
  if (neighbor[0] != -1) {
#line 58
    (stl->neighbors_start + neighbor[0])->which_vertex_not[(vnot[0] + 1) % 3] = (char )(((int )(stl->neighbors_start + neighbor[0])->which_vertex_not[(vnot[0] + 1) % 3] + 3) % 6);
  }
#line 61
  if (neighbor[1] != -1) {
#line 62
    (stl->neighbors_start + neighbor[1])->which_vertex_not[(vnot[1] + 1) % 3] = (char )(((int )(stl->neighbors_start + neighbor[1])->which_vertex_not[(vnot[1] + 1) % 3] + 4) % 6);
  }
#line 65
  if (neighbor[2] != -1) {
#line 66
    (stl->neighbors_start + neighbor[2])->which_vertex_not[(vnot[2] + 1) % 3] = (char )(((int )(stl->neighbors_start + neighbor[2])->which_vertex_not[(vnot[2] + 1) % 3] + 2) % 6);
  }
#line 71
  (stl->neighbors_start + facet_num)->neighbor[1] = neighbor[2];
#line 72
  (stl->neighbors_start + facet_num)->neighbor[2] = neighbor[1];
#line 75
  (stl->neighbors_start + facet_num)->which_vertex_not[1] = (char )vnot[2];
#line 76
  (stl->neighbors_start + facet_num)->which_vertex_not[2] = (char )vnot[1];
#line 79
  (stl->neighbors_start + facet_num)->which_vertex_not[0] = (char )(((int )(stl->neighbors_start + facet_num)->which_vertex_not[0] + 3) % 6);
#line 81
  (stl->neighbors_start + facet_num)->which_vertex_not[1] = (char )(((int )(stl->neighbors_start + facet_num)->which_vertex_not[1] + 3) % 6);
#line 83
  (stl->neighbors_start + facet_num)->which_vertex_not[2] = (char )(((int )(stl->neighbors_start + facet_num)->which_vertex_not[2] + 3) % 6);
#line 85
  return;
}
}
#line 284 "/home/wslee/benchmarks/admesh-0.95/normals.c"
static void stl_reverse_vector___0(float *v ) 
{ 


  {
#line 287
  *(v + 0) *= (float )-1;
#line 288
  *(v + 1) *= (float )-1;
#line 289
  *(v + 2) *= (float )-1;
#line 290
  return;
}
}
#line 28 "/home/wslee/benchmarks/admesh-0.95/admesh.c"
static void usage___0(int status , char *program_name ) ;
#line 469 "/home/wslee/benchmarks/admesh-0.95/admesh.c"
static void usage___0(int status , char *program_name ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 472
  if (status != 0) {
    {
    {
#line 474
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try \'%s --help\' for more information.\n",
            program_name);
    }
    }
  } else {
    {
    {
#line 478
    printf((char const   */* __restrict  */)"\nADMesh version 0.95\nCopyright (C) 1995, 1996  Anthony D. Martin\nUsage: %s [OPTION]... file\n",
           program_name);
    }
    {
#line 482
    printf((char const   */* __restrict  */)"\n     --x-rotate=angle     Rotate CCW about x-axis by angle degrees\n     --y-rotate=angle     Rotate CCW about y-axis by angle degrees\n     --z-rotate=angle     Rotate CCW about z-axis by angle degrees\n     --xy-mirror          Mirror about the xy plane\n     --yz-mirror          Mirror about the yz plane\n     --xz-mirror          Mirror about the xz plane\n     --scale=factor       Scale the file by factor (multiply by factor)\n     --translate=x,y,z    Translate the file to x, y, and z\n     --merge=name         Merge file called name with input file\n -e, --exact              Only check for perfectly matched edges\n -n, --nearby             Find and connect nearby facets. Correct bad facets\n -t, --tolerance=tol      Initial tolerance to use for nearby check = tol\n -i, --iterations=i       Number of iterations for nearby check = i\n -m, --increment=inc      Amount to increment tolerance after iteration=inc\n -u, --remove-unconnected Remove facets that have 0 neighbors\n -f, --fill-holes         Add facets to fill holes\n -d, --normal-directions  Check and fix direction of normals(ie cw, ccw)\n     --reverse-all        Reverse the directions of all facets and normals\n -v, --normal-values      Check and fix normal values\n -c, --no-check           Don\'t do any check on input file\n -b, --write-binary-stl=name   Output a binary STL file called name\n -a, --write-ascii-stl=name    Output an ascii STL file called name\n     --write-off=name     Output a Geomview OFF format file called name\n     --write-dxf=name     Output a DXF format file called name\n     --write-vrml=name    Output a VRML format file called name\n     --help               Display this help and exit\n     --version            Output version information and exit\n\nThe functions are executed in the same order as the options shown here.\nSo check here to find what happens if, for example, --translate and --merge\noptions are specified together.  The order of the options specified on the\ncommand line is not important.\n");
    }
    }
  }
  {
  {
#line 516
  exit(status);
  }
  }
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 26 "/home/wslee/benchmarks/admesh-0.95/shared.c"
void stl_generate_shared_vertices(stl_file *stl ) 
{ 
  int i ;
  int j ;
  int first_facet ;
  int direction ;
  int facet_num ;
  int vnot ;
  int next_edge ;
  int pivot_vertex ;
  int next_facet ;
  int reversed ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 40
  tmp = calloc((size_t )stl->stats.number_of_facets, (size_t )sizeof(v_indices_struct ));
  }
#line 40
  stl->v_indices = (v_indices_struct *)tmp;
  }
#line 42
  if ((unsigned long )stl->v_indices == (unsigned long )((void *)0)) {
    {
    {
#line 42
    perror("stl_generate_shared_vertices");
    }
    }
  }
  {
  {
#line 43
  tmp___0 = calloc((size_t )(stl->stats.number_of_facets / 2), (size_t )sizeof(stl_vertex ));
  }
#line 43
  stl->v_shared = (stl_vertex *)tmp___0;
  }
#line 45
  if ((unsigned long )stl->v_shared == (unsigned long )((void *)0)) {
    {
    {
#line 45
    perror("stl_generate_shared_vertices");
    }
    }
  }
#line 46
  stl->stats.shared_malloced = stl->stats.number_of_facets / 2;
#line 47
  stl->stats.shared_vertices = 0;
#line 49
  i = 0;
  {
  {
#line 49
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 49
    if (! (i < stl->stats.number_of_facets)) {
#line 49
      goto while_break;
    }
#line 51
    (stl->v_indices + i)->vertex[0] = -1;
#line 52
    (stl->v_indices + i)->vertex[1] = -1;
#line 53
    (stl->v_indices + i)->vertex[2] = -1;
#line 49
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  i = 0;
  {
  {
#line 57
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 57
    if (! (i < stl->stats.number_of_facets)) {
#line 57
      goto while_break___0;
    }
#line 59
    first_facet = i;
#line 60
    j = 0;
    {
    {
#line 60
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 60
      if (! (j < 3)) {
#line 60
        goto while_break___1;
      }
#line 62
      if ((stl->v_indices + i)->vertex[j] != -1) {
#line 64
        goto __Cont;
      }
#line 66
      if (stl->stats.shared_vertices == stl->stats.shared_malloced) {
        {
#line 68
        stl->stats.shared_malloced += 1024;
        {
#line 69
        tmp___1 = realloc((void *)stl->v_shared, (size_t )((unsigned long )stl->stats.shared_malloced * sizeof(stl_vertex )));
        }
#line 69
        stl->v_shared = (stl_vertex *)tmp___1;
        }
#line 71
        if ((unsigned long )stl->v_shared == (unsigned long )((void *)0)) {
          {
          {
#line 71
          perror("stl_generate_shared_vertices");
          }
          }
        }
      }
#line 74
      *(stl->v_shared + stl->stats.shared_vertices) = (stl->facet_start + i)->vertex[j];
#line 77
      direction = 0;
#line 78
      reversed = 0;
#line 79
      facet_num = i;
#line 80
      vnot = (j + 2) % 3;
      {
      {
#line 82
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 84
        if (vnot > 2) {
#line 86
          if (direction == 0) {
#line 88
            pivot_vertex = (vnot + 2) % 3;
#line 89
            next_edge = pivot_vertex;
#line 90
            direction = 1;
          } else {
#line 94
            pivot_vertex = (vnot + 1) % 3;
#line 95
            next_edge = vnot % 3;
#line 96
            direction = 0;
          }
        } else
#line 101
        if (direction == 0) {
#line 103
          pivot_vertex = (vnot + 1) % 3;
#line 104
          next_edge = vnot;
        } else {
#line 108
          pivot_vertex = (vnot + 2) % 3;
#line 109
          next_edge = pivot_vertex;
        }
#line 112
        (stl->v_indices + facet_num)->vertex[pivot_vertex] = stl->stats.shared_vertices;
#line 115
        next_facet = (stl->neighbors_start + facet_num)->neighbor[next_edge];
#line 116
        if (next_facet == -1) {
#line 118
          if (reversed) {
#line 120
            goto while_break___2;
          } else {
#line 124
            direction = 1;
#line 125
            vnot = (j + 1) % 3;
#line 126
            reversed = 1;
#line 127
            facet_num = first_facet;
          }
        } else
#line 130
        if (next_facet != first_facet) {
#line 132
          vnot = (int )(stl->neighbors_start + facet_num)->which_vertex_not[next_edge];
#line 134
          facet_num = next_facet;
        } else {
#line 138
          goto while_break___2;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 141
      (stl->stats.shared_vertices) ++;
      __Cont: /* CIL Label */ 
#line 60
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 57
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 146 "/home/wslee/benchmarks/admesh-0.95/shared.c"
void stl_write_off(stl_file *stl , char *file ) 
{ 
  int i ;
  FILE *fp ;
  char *error_msg ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 155
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 156
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 158
    tmp = (int )strlen(file);
    }
    {
#line 158
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 158
    error_msg = (char *)tmp___0;
    {
#line 160
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_write_ascii: Couldn\'t open %s for writing",
            file);
    }
    {
#line 162
    perror((char const   *)error_msg);
    }
    {
#line 163
    free((void *)error_msg);
    }
    {
#line 164
    exit(1);
    }
    }
  }
  {
  {
#line 167
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"OFF\n");
  }
  {
#line 168
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d %d 0\n",
          stl->stats.shared_vertices, stl->stats.number_of_facets);
  }
#line 171
  i = 0;
  }
  {
  {
#line 171
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < stl->stats.shared_vertices)) {
#line 171
      goto while_break;
    }
    {
    {
#line 173
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t%f %f %f\n",
            (double )(stl->v_shared + i)->x, (double )(stl->v_shared + i)->y, (double )(stl->v_shared + i)->z);
    }
#line 171
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  i = 0;
  {
  {
#line 176
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 176
    if (! (i < stl->stats.number_of_facets)) {
#line 176
      goto while_break___0;
    }
    {
    {
#line 178
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t3 %d %d %d\n",
            (stl->v_indices + i)->vertex[0], (stl->v_indices + i)->vertex[1], (stl->v_indices + i)->vertex[2]);
    }
#line 176
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 181
  fclose(fp);
  }
  }
#line 182
  return;
}
}
#line 184 "/home/wslee/benchmarks/admesh-0.95/shared.c"
void stl_write_vrml(stl_file *stl , char *file ) 
{ 
  int i ;
  FILE *fp ;
  char *error_msg ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 193
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
  }
#line 194
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 196
    tmp = (int )strlen(file);
    }
    {
#line 196
    tmp___0 = malloc((size_t )(81 + tmp));
    }
#line 196
    error_msg = (char *)tmp___0;
    {
#line 198
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_write_ascii: Couldn\'t open %s for writing",
            file);
    }
    {
#line 200
    perror((char const   *)error_msg);
    }
    {
#line 201
    free((void *)error_msg);
    }
    {
#line 202
    exit(1);
    }
    }
  }
  {
  {
#line 205
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#VRML V1.0 ascii\n\n");
  }
  {
#line 206
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Separator {\n");
  }
  {
#line 207
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tDEF STLShape ShapeHints {\n");
  }
  {
#line 208
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tvertexOrdering COUNTERCLOCKWISE\n");
  }
  {
#line 209
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tfaceType CONVEX\n");
  }
  {
#line 210
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tshapeType SOLID\n");
  }
  {
#line 211
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tcreaseAngle 0.0\n");
  }
  {
#line 212
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t}\n");
  }
  {
#line 213
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\tDEF STLModel Separator {\n");
  }
  {
#line 214
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tDEF STLColor Material {\n");
  }
  {
#line 215
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\temissiveColor 0.700000 0.700000 0.000000\n");
  }
  {
#line 216
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t}\n");
  }
  {
#line 217
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tDEF STLVertices Coordinate3 {\n");
  }
  {
#line 218
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\tpoint [\n");
  }
#line 220
  i = 0;
  }
  {
  {
#line 220
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < stl->stats.shared_vertices - 1)) {
#line 220
      goto while_break;
    }
    {
    {
#line 222
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\t\t%f %f %f,\n",
            (double )(stl->v_shared + i)->x, (double )(stl->v_shared + i)->y, (double )(stl->v_shared + i)->z);
    }
#line 220
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 225
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\t\t%f %f %f]\n",
          (double )(stl->v_shared + i)->x, (double )(stl->v_shared + i)->y, (double )(stl->v_shared + i)->z);
  }
  {
#line 227
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t}\n");
  }
  {
#line 228
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\tDEF STLTriangles IndexedFaceSet {\n");
  }
  {
#line 229
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\tcoordIndex [\n");
  }
#line 231
  i = 0;
  }
  {
  {
#line 231
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 231
    if (! (i < stl->stats.number_of_facets - 1)) {
#line 231
      goto while_break___0;
    }
    {
    {
#line 233
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\t\t%d, %d, %d, -1,\n",
            (stl->v_indices + i)->vertex[0], (stl->v_indices + i)->vertex[1], (stl->v_indices + i)->vertex[2]);
    }
#line 231
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 236
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t\t\t%d, %d, %d, -1]\n",
          (stl->v_indices + i)->vertex[0], (stl->v_indices + i)->vertex[1], (stl->v_indices + i)->vertex[2]);
  }
  {
#line 238
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t\t}\n");
  }
  {
#line 239
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t}\n");
  }
  {
#line 240
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"}\n");
  }
  {
#line 241
  fclose(fp);
  }
  }
#line 242
  return;
}
}
#line 30 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
static void stl_put_little_int___0(FILE *fp , int value_in ) ;
#line 31
static void stl_put_little_float___0(FILE *fp , float value_in ) ;
#line 202 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
static void stl_put_little_int___0(FILE *fp , int value_in ) 
{ 
  int new_value ;
  union __anonunion_value_32___0 value ;

  {
  {
#line 212
  value.int_value = value_in;
#line 214
  new_value = (int )value.char_value[0] & 255;
#line 215
  new_value |= ((int )value.char_value[1] & 255) << 8;
#line 216
  new_value |= ((int )value.char_value[2] & 255) << 16;
#line 217
  new_value |= ((int )value.char_value[3] & 255) << 24;
  {
#line 218
  fwrite((void const   */* __restrict  */)(& new_value), (size_t )sizeof(int ), (size_t )1,
         (FILE */* __restrict  */)fp);
  }
  }
#line 219
  return;
}
}
#line 221 "/home/wslee/benchmarks/admesh-0.95/stl_io.c"
static void stl_put_little_float___0(FILE *fp , float value_in ) 
{ 
  int new_value ;
  union __anonunion_value_33___0 value ;

  {
  {
#line 231
  value.float_value = value_in;
#line 233
  new_value = (int )value.char_value[0] & 255;
#line 234
  new_value |= ((int )value.char_value[1] & 255) << 8;
#line 235
  new_value |= ((int )value.char_value[2] & 255) << 16;
#line 236
  new_value |= ((int )value.char_value[3] & 255) << 24;
  {
#line 237
  fwrite((void const   */* __restrict  */)(& new_value), (size_t )sizeof(int ), (size_t )1,
         (FILE */* __restrict  */)fp);
  }
  }
#line 238
  return;
}
}
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 67
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 29 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_match_neighbors_exact(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) ;
#line 31
static void stl_match_neighbors_nearby(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) ;
#line 33
static void stl_record_neighbors(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) ;
#line 35
static void stl_initialize_facet_check_exact(stl_file *stl ) ;
#line 36
static void stl_initialize_facet_check_nearby(stl_file *stl ) ;
#line 37
static void stl_load_edge_exact(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                stl_vertex *b ) ;
#line 39
static int stl_load_edge_nearby(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                stl_vertex *b , float tolerance ) ;
#line 41
static void insert_hash_edge(stl_file *stl , stl_hash_edge edge , void (*match_neighbors)(stl_file *stl ,
                                                                                          stl_hash_edge *edge_a ,
                                                                                          stl_hash_edge *edge_b ) ) ;
#line 44
static int stl_get_hash_for_edge(int M , stl_hash_edge *edge ) ;
#line 45
static int stl_compare_function(stl_hash_edge *edge_a , stl_hash_edge *edge_b ) ;
#line 46
static void stl_free_edges(stl_file *stl ) ;
#line 47
static void stl_remove_facet(stl_file *stl , int facet_number ) ;
#line 48
static void stl_change_vertices(stl_file *stl , int facet_num , int vnot , stl_vertex new_vertex ) ;
#line 50
static void stl_which_vertices_to_change(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ,
                                         int *facet1 , int *vertex1 , int *facet2 ,
                                         int *vertex2 , stl_vertex *new_vertex1 ,
                                         stl_vertex *new_vertex2 ) ;
#line 54
static void stl_remove_degenerate(stl_file *stl , int facet ) ;
#line 55
static void stl_add_facet(stl_file *stl , stl_facet *new_facet ) ;
#line 58
static void stl_update_connects_remove_1(stl_file *stl , int facet_num ) ;
#line 61 "/home/wslee/benchmarks/admesh-0.95/connect.c"
void stl_check_facets_exact(stl_file *stl ) 
{ 
  stl_hash_edge edge ;
  stl_facet facet ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 74
  stl->stats.connected_edges = 0;
#line 75
  stl->stats.connected_facets_1_edge = 0;
#line 76
  stl->stats.connected_facets_2_edge = 0;
#line 77
  stl->stats.connected_facets_3_edge = 0;
  {
#line 79
  stl_initialize_facet_check_exact(stl);
  }
#line 81
  i = 0;
  }
  {
  {
#line 81
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < stl->stats.number_of_facets)) {
#line 81
      goto while_break;
    }
    {
#line 83
    facet = *(stl->facet_start + i);
    {
#line 85
    tmp = memcmp((void const   *)(& facet.vertex[0]), (void const   *)(& facet.vertex[1]),
                 (size_t )sizeof(stl_vertex ));
    }
    }
#line 85
    if (tmp) {
      {
      {
#line 85
      tmp___0 = memcmp((void const   *)(& facet.vertex[1]), (void const   *)(& facet.vertex[2]),
                       (size_t )sizeof(stl_vertex ));
      }
      }
#line 85
      if (tmp___0) {
        {
        {
#line 85
        tmp___1 = memcmp((void const   *)(& facet.vertex[0]), (void const   *)(& facet.vertex[2]),
                         (size_t )sizeof(stl_vertex ));
        }
        }
#line 85
        if (! tmp___1) {
          {
#line 92
          (stl->stats.degenerate_facets) ++;
          {
#line 93
          stl_remove_facet(stl, i);
          }
#line 94
          i --;
          }
#line 95
          goto __Cont;
        }
      } else {
        {
#line 92
        (stl->stats.degenerate_facets) ++;
        {
#line 93
        stl_remove_facet(stl, i);
        }
#line 94
        i --;
        }
#line 95
        goto __Cont;
      }
    } else {
      {
#line 92
      (stl->stats.degenerate_facets) ++;
      {
#line 93
      stl_remove_facet(stl, i);
      }
#line 94
      i --;
      }
#line 95
      goto __Cont;
    }
#line 98
    j = 0;
    {
    {
#line 98
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (j < 3)) {
#line 98
        goto while_break___0;
      }
      {
#line 100
      edge.facet_number = i;
#line 101
      edge.which_edge = j;
      {
#line 102
      stl_load_edge_exact(stl, & edge, & facet.vertex[j], & facet.vertex[(j + 1) % 3]);
      }
      {
#line 105
      insert_hash_edge(stl, edge, & stl_match_neighbors_exact);
      }
#line 98
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 81
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 108
  stl_free_edges(stl);
  }
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_load_edge_exact(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                stl_vertex *b ) 
{ 
  float diff_x ;
  float diff_y ;
  float diff_z ;
  float max_diff ;

  {
#line 122
  if (a->x - b->x < (float )0) {
#line 122
    diff_x = - (a->x - b->x);
  } else {
#line 122
    diff_x = a->x - b->x;
  }
#line 123
  if (a->y - b->y < (float )0) {
#line 123
    diff_y = - (a->y - b->y);
  } else {
#line 123
    diff_y = a->y - b->y;
  }
#line 124
  if (a->z - b->z < (float )0) {
#line 124
    diff_z = - (a->z - b->z);
  } else {
#line 124
    diff_z = a->z - b->z;
  }
#line 125
  if (diff_x > diff_y) {
#line 125
    max_diff = diff_x;
  } else {
#line 125
    max_diff = diff_y;
  }
#line 126
  if (diff_z > max_diff) {
#line 126
    max_diff = diff_z;
  } else {
#line 126
    max_diff = max_diff;
  }
#line 127
  if (max_diff < stl->stats.shortest_edge) {
#line 127
    stl->stats.shortest_edge = max_diff;
  } else {
#line 127
    stl->stats.shortest_edge = stl->stats.shortest_edge;
  }
#line 129
  if (diff_x == max_diff) {
#line 131
    if (a->x > b->x) {
      {
      {
#line 133
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 134
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 138
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 139
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
#line 140
      edge->which_edge += 3;
      }
    }
  } else
#line 143
  if (diff_y == max_diff) {
#line 145
    if (a->y > b->y) {
      {
      {
#line 147
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 148
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 152
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 153
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
#line 154
      edge->which_edge += 3;
      }
    }
  } else
#line 159
  if (a->z > b->z) {
    {
    {
#line 161
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)a,
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 162
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)b,
           (size_t )sizeof(stl_vertex ));
    }
    }
  } else {
    {
    {
#line 166
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)b,
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 167
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)a,
           (size_t )sizeof(stl_vertex ));
    }
#line 168
    edge->which_edge += 3;
    }
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_initialize_facet_check_exact(stl_file *stl ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 178
  stl->stats.malloced = 0;
#line 179
  stl->stats.freed = 0;
#line 180
  stl->stats.collisions = 0;
#line 183
  stl->M = 81397;
#line 185
  i = 0;
  {
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < stl->stats.number_of_facets)) {
#line 185
      goto while_break;
    }
#line 188
    (stl->neighbors_start + i)->neighbor[0] = -1;
#line 189
    (stl->neighbors_start + i)->neighbor[1] = -1;
#line 190
    (stl->neighbors_start + i)->neighbor[2] = -1;
#line 185
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 193
  tmp = calloc((size_t )stl->M, (size_t )sizeof(*(stl->heads)));
  }
#line 193
  stl->heads = (stl_hash_edge **)tmp;
  }
#line 194
  if ((unsigned long )stl->heads == (unsigned long )((void *)0)) {
    {
    {
#line 194
    perror("stl_initialize_facet_check_exact");
    }
    }
  }
  {
  {
#line 196
  tmp___0 = malloc((size_t )sizeof(stl_hash_edge ));
  }
#line 196
  stl->tail = (stl_hash_edge *)tmp___0;
  }
#line 197
  if ((unsigned long )stl->tail == (unsigned long )((void *)0)) {
    {
    {
#line 197
    perror("stl_initialize_facet_check_exact");
    }
    }
  }
#line 199
  (stl->tail)->next = stl->tail;
#line 201
  i = 0;
  {
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (i < stl->M)) {
#line 201
      goto while_break___0;
    }
#line 203
    *(stl->heads + i) = stl->tail;
#line 201
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void insert_hash_edge(stl_file *stl , stl_hash_edge edge , void (*match_neighbors)(stl_file *stl ,
                                                                                          stl_hash_edge *edge_a ,
                                                                                          stl_hash_edge *edge_b ) ) 
{ 
  stl_hash_edge *link ;
  stl_hash_edge *new_edge ;
  stl_hash_edge *temp ;
  int chain_number ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 217
  chain_number = stl_get_hash_for_edge(stl->M, & edge);
  }
#line 219
  link = *(stl->heads + chain_number);
  }
#line 221
  if ((unsigned long )link == (unsigned long )stl->tail) {
    {
    {
#line 224
    tmp = malloc((size_t )sizeof(stl_hash_edge ));
    }
#line 224
    new_edge = (stl_hash_edge *)tmp;
    }
#line 225
    if ((unsigned long )new_edge == (unsigned long )((void *)0)) {
      {
      {
#line 225
      perror("insert_hash_edge");
      }
      }
    }
#line 226
    (stl->stats.malloced) ++;
#line 227
    *new_edge = edge;
#line 228
    new_edge->next = stl->tail;
#line 229
    *(stl->heads + chain_number) = new_edge;
#line 230
    return;
  } else {
    {
    {
#line 232
    tmp___2 = stl_compare_function(& edge, link);
    }
    }
#line 232
    if (tmp___2) {
      {
      {
#line 244
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 246
        if ((unsigned long )link->next == (unsigned long )stl->tail) {
          {
          {
#line 249
          tmp___0 = malloc((size_t )sizeof(stl_hash_edge ));
          }
#line 249
          new_edge = (stl_hash_edge *)tmp___0;
          }
#line 250
          if ((unsigned long )new_edge == (unsigned long )((void *)0)) {
            {
            {
#line 250
            perror("insert_hash_edge");
            }
            }
          }
#line 251
          (stl->stats.malloced) ++;
#line 252
          *new_edge = edge;
#line 253
          new_edge->next = stl->tail;
#line 254
          link->next = new_edge;
#line 255
          (stl->stats.collisions) ++;
#line 256
          return;
        } else {
          {
          {
#line 258
          tmp___1 = stl_compare_function(& edge, link->next);
          }
          }
#line 258
          if (tmp___1) {
#line 273
            link = link->next;
#line 274
            (stl->stats.collisions) ++;
          } else {
            {
            {
#line 261
            (*match_neighbors)(stl, & edge, link->next);
            }
#line 264
            temp = link->next;
#line 265
            link->next = (link->next)->next;
            {
#line 266
            free((void *)temp);
            }
#line 267
            (stl->stats.freed) ++;
            }
#line 268
            return;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 235
      (*match_neighbors)(stl, & edge, link);
      }
#line 237
      *(stl->heads + chain_number) = link->next;
      {
#line 238
      free((void *)link);
      }
#line 239
      (stl->stats.freed) ++;
      }
#line 240
      return;
    }
  }
}
}
#line 281 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static int stl_get_hash_for_edge(int M , stl_hash_edge *edge ) 
{ 


  {
#line 284
  return ((int )((((((edge->key[0] / 23U + edge->key[1] / 19U) + edge->key[2] / 17U) + edge->key[3] / 13U) + edge->key[4] / 11U) + edge->key[5] / 7U) % (unsigned int )M));
}
}
#line 288 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static int stl_compare_function(stl_hash_edge *edge_a , stl_hash_edge *edge_b ) 
{ 
  int tmp ;

  {
#line 291
  if (edge_a->facet_number == edge_b->facet_number) {
#line 293
    return (1);
  } else {
    {
    {
#line 297
    tmp = memcmp((void const   *)edge_a, (void const   *)edge_b, (size_t )24);
    }
    }
#line 297
    return (tmp);
  }
}
}
#line 301 "/home/wslee/benchmarks/admesh-0.95/connect.c"
void stl_check_facets_nearby(stl_file *stl , float tolerance ) 
{ 
  stl_hash_edge edge[3] ;
  stl_facet facet ;
  int i ;
  int j ;
  int tmp ;
  void *__cil_tmp8 ;

  {
#line 310
  if (stl->stats.connected_facets_1_edge == stl->stats.number_of_facets) {
#line 310
    if (stl->stats.connected_facets_2_edge == stl->stats.number_of_facets) {
#line 310
      if (stl->stats.connected_facets_3_edge == stl->stats.number_of_facets) {
#line 315
        return;
      }
    }
  }
  {
  {
#line 318
  stl_initialize_facet_check_nearby(stl);
  }
#line 320
  i = 0;
  }
  {
  {
#line 320
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 320
    if (! (i < stl->stats.number_of_facets)) {
#line 320
      goto while_break;
    }
#line 322
    facet = *(stl->facet_start + i);
#line 323
    j = 0;
    {
    {
#line 323
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! (j < 3)) {
#line 323
        goto while_break___0;
      }
#line 325
      if ((stl->neighbors_start + i)->neighbor[j] == -1) {
        {
#line 327
        edge[j].facet_number = i;
#line 328
        edge[j].which_edge = j;
        {
#line 329
        tmp = stl_load_edge_nearby(stl, & edge[j], & facet.vertex[j], & facet.vertex[(j + 1) % 3],
                                   tolerance);
        }
        }
#line 329
        if (tmp) {
          {
          {
#line 334
          insert_hash_edge(stl, edge[j], & stl_match_neighbors_nearby);
          }
          }
        }
      }
#line 323
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 320
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 340
  stl_free_edges(stl);
  }
  }
#line 341
  return;
}
}
#line 343 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static int stl_load_edge_nearby(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                stl_vertex *b , float tolerance ) 
{ 
  float diff_x ;
  float diff_y ;
  float diff_z ;
  float max_diff ;
  unsigned int vertex1[3] ;
  unsigned int vertex2[3] ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 355
  if (a->x - b->x < (float )0) {
#line 355
    diff_x = - (a->x - b->x);
  } else {
#line 355
    diff_x = a->x - b->x;
  }
#line 356
  if (a->y - b->y < (float )0) {
#line 356
    diff_y = - (a->y - b->y);
  } else {
#line 356
    diff_y = a->y - b->y;
  }
#line 357
  if (a->z - b->z < (float )0) {
#line 357
    diff_z = - (a->z - b->z);
  } else {
#line 357
    diff_z = a->z - b->z;
  }
#line 358
  if (diff_x > diff_y) {
#line 358
    max_diff = diff_x;
  } else {
#line 358
    max_diff = diff_y;
  }
#line 359
  if (diff_z > max_diff) {
#line 359
    max_diff = diff_z;
  } else {
#line 359
    max_diff = max_diff;
  }
#line 361
  vertex1[0] = (unsigned int )((a->x - stl->stats.min.x) / tolerance);
#line 362
  vertex1[1] = (unsigned int )((a->y - stl->stats.min.y) / tolerance);
#line 363
  vertex1[2] = (unsigned int )((a->z - stl->stats.min.z) / tolerance);
#line 364
  vertex2[0] = (unsigned int )((b->x - stl->stats.min.x) / tolerance);
#line 365
  vertex2[1] = (unsigned int )((b->y - stl->stats.min.y) / tolerance);
#line 366
  vertex2[2] = (unsigned int )((b->z - stl->stats.min.z) / tolerance);
#line 368
  if (vertex1[0] == vertex2[0]) {
#line 368
    if (vertex1[1] == vertex2[1]) {
#line 368
      if (vertex1[2] == vertex2[2]) {
#line 373
        return (0);
      }
    }
  }
#line 376
  if (diff_x == max_diff) {
#line 378
    if (a->x > b->x) {
      {
      {
#line 380
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 381
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 385
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 386
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
#line 387
      edge->which_edge += 3;
      }
    }
  } else
#line 390
  if (diff_y == max_diff) {
#line 392
    if (a->y > b->y) {
      {
      {
#line 394
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 395
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 399
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 400
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
#line 401
      edge->which_edge += 3;
      }
    }
  } else
#line 406
  if (a->z > b->z) {
    {
    {
#line 408
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex1),
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 409
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex2),
           (size_t )sizeof(stl_vertex ));
    }
    }
  } else {
    {
    {
#line 413
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex2),
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 414
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex1),
           (size_t )sizeof(stl_vertex ));
    }
#line 415
    edge->which_edge += 3;
    }
  }
#line 418
  return (1);
}
}
#line 421 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_free_edges(stl_file *stl ) 
{ 
  int i ;
  stl_hash_edge *temp ;

  {
#line 427
  if (stl->stats.malloced != stl->stats.freed) {
#line 429
    i = 0;
    {
    {
#line 429
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 429
      if (! (i < stl->M)) {
#line 429
        goto while_break;
      }
#line 431
      temp = *(stl->heads + i);
      {
      {
#line 431
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 431
        if (! ((unsigned long )*(stl->heads + i) != (unsigned long )stl->tail)) {
#line 431
          goto while_break___0;
        }
        {
#line 434
        *(stl->heads + i) = (*(stl->heads + i))->next;
        {
#line 435
        free((void *)temp);
        }
#line 436
        (stl->stats.freed) ++;
#line 431
        temp = *(stl->heads + i);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 429
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 440
  free((void *)stl->heads);
  }
  {
#line 441
  free((void *)stl->tail);
  }
  }
#line 442
  return;
}
}
#line 444 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_initialize_facet_check_nearby(stl_file *stl ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 449
  stl->stats.malloced = 0;
#line 450
  stl->stats.freed = 0;
#line 451
  stl->stats.collisions = 0;
#line 457
  stl->M = 81397;
  {
#line 459
  tmp = calloc((size_t )stl->M, (size_t )sizeof(*(stl->heads)));
  }
#line 459
  stl->heads = (stl_hash_edge **)tmp;
  }
#line 460
  if ((unsigned long )stl->heads == (unsigned long )((void *)0)) {
    {
    {
#line 460
    perror("stl_initialize_facet_check_nearby");
    }
    }
  }
  {
  {
#line 462
  tmp___0 = malloc((size_t )sizeof(stl_hash_edge ));
  }
#line 462
  stl->tail = (stl_hash_edge *)tmp___0;
  }
#line 463
  if ((unsigned long )stl->tail == (unsigned long )((void *)0)) {
    {
    {
#line 463
    perror("stl_initialize_facet_check_nearby");
    }
    }
  }
#line 465
  (stl->tail)->next = stl->tail;
#line 467
  i = 0;
  {
  {
#line 467
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 467
    if (! (i < stl->M)) {
#line 467
      goto while_break;
    }
#line 469
    *(stl->heads + i) = stl->tail;
#line 467
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  return;
}
}
#line 475 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_record_neighbors(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) 
{ 
  int i ;
  int j ;

  {
#line 483
  (stl->neighbors_start + edge_a->facet_number)->neighbor[edge_a->which_edge % 3] = edge_b->facet_number;
#line 486
  (stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] = (char )((edge_b->which_edge + 2) % 3);
#line 491
  (stl->neighbors_start + edge_b->facet_number)->neighbor[edge_b->which_edge % 3] = edge_a->facet_number;
#line 494
  (stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] = (char )((edge_a->which_edge + 2) % 3);
#line 498
  if (edge_a->which_edge < 3) {
#line 498
    if (edge_b->which_edge < 3) {
#line 503
      (stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] + 3);
#line 505
      (stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] + 3);
    } else {
#line 498
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 498
  if (edge_a->which_edge > 2) {
#line 498
    if (edge_b->which_edge > 2) {
#line 503
      (stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] + 3);
#line 505
      (stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] + 3);
    }
  }
#line 512
  stl->stats.connected_edges += 2;
#line 514
  i = (((stl->neighbors_start + edge_a->facet_number)->neighbor[0] == -1) + ((stl->neighbors_start + edge_a->facet_number)->neighbor[1] == -1)) + ((stl->neighbors_start + edge_a->facet_number)->neighbor[2] == -1);
#line 517
  j = (((stl->neighbors_start + edge_b->facet_number)->neighbor[0] == -1) + ((stl->neighbors_start + edge_b->facet_number)->neighbor[1] == -1)) + ((stl->neighbors_start + edge_b->facet_number)->neighbor[2] == -1);
#line 520
  if (i == 2) {
#line 522
    (stl->stats.connected_facets_1_edge) ++;
  } else
#line 524
  if (i == 1) {
#line 526
    (stl->stats.connected_facets_2_edge) ++;
  } else {
#line 530
    (stl->stats.connected_facets_3_edge) ++;
  }
#line 532
  if (j == 2) {
#line 534
    (stl->stats.connected_facets_1_edge) ++;
  } else
#line 536
  if (j == 1) {
#line 538
    (stl->stats.connected_facets_2_edge) ++;
  } else {
#line 542
    (stl->stats.connected_facets_3_edge) ++;
  }
#line 544
  return;
}
}
#line 546 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_match_neighbors_exact(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) 
{ 


  {
  {
  {
#line 550
  stl_record_neighbors(stl, edge_a, edge_b);
  }
  }
#line 551
  return;
}
}
#line 553 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_match_neighbors_nearby(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) 
{ 
  int facet1 ;
  int facet2 ;
  int vertex1 ;
  int vertex2 ;
  int vnot1 ;
  int vnot2 ;
  stl_vertex new_vertex1 ;
  stl_vertex new_vertex2 ;

  {
  {
  {
#line 566
  stl_record_neighbors(stl, edge_a, edge_b);
  }
  {
#line 567
  stl_which_vertices_to_change(stl, edge_a, edge_b, & facet1, & vertex1, & facet2,
                               & vertex2, & new_vertex1, & new_vertex2);
  }
  }
#line 569
  if (facet1 != -1) {
#line 571
    if (facet1 == edge_a->facet_number) {
#line 573
      vnot1 = (edge_a->which_edge + 2) % 3;
    } else {
#line 577
      vnot1 = (edge_b->which_edge + 2) % 3;
    }
#line 579
    if ((vnot1 + 2) % 3 == vertex1) {
#line 581
      vnot1 += 3;
    }
    {
    {
#line 583
    stl_change_vertices(stl, facet1, vnot1, new_vertex1);
    }
    }
  }
#line 585
  if (facet2 != -1) {
#line 587
    if (facet2 == edge_a->facet_number) {
#line 589
      vnot2 = (edge_a->which_edge + 2) % 3;
    } else {
#line 593
      vnot2 = (edge_b->which_edge + 2) % 3;
    }
#line 595
    if ((vnot2 + 2) % 3 == vertex2) {
#line 597
      vnot2 += 3;
    }
    {
    {
#line 599
    stl_change_vertices(stl, facet2, vnot2, new_vertex2);
    }
    }
  }
#line 601
  stl->stats.edges_fixed += 2;
#line 602
  return;
}
}
#line 605 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_change_vertices(stl_file *stl , int facet_num , int vnot , stl_vertex new_vertex ) 
{ 
  int first_facet ;
  int direction ;
  int next_edge ;
  int pivot_vertex ;
  char *__cil_tmp9 ;

  {
#line 614
  first_facet = facet_num;
#line 615
  direction = 0;
  {
  {
#line 617
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 619
    if (vnot > 2) {
#line 621
      if (direction == 0) {
#line 623
        pivot_vertex = (vnot + 2) % 3;
#line 624
        next_edge = pivot_vertex;
#line 625
        direction = 1;
      } else {
#line 629
        pivot_vertex = (vnot + 1) % 3;
#line 630
        next_edge = vnot % 3;
#line 631
        direction = 0;
      }
    } else
#line 636
    if (direction == 0) {
#line 638
      pivot_vertex = (vnot + 1) % 3;
#line 639
      next_edge = vnot;
    } else {
#line 643
      pivot_vertex = (vnot + 2) % 3;
#line 644
      next_edge = pivot_vertex;
    }
#line 647
    (stl->facet_start + facet_num)->vertex[pivot_vertex] = new_vertex;
#line 648
    vnot = (int )(stl->neighbors_start + facet_num)->which_vertex_not[next_edge];
#line 649
    facet_num = (stl->neighbors_start + facet_num)->neighbor[next_edge];
#line 651
    if (facet_num == -1) {
#line 653
      goto while_break;
    }
#line 656
    if (facet_num == first_facet) {
      {
      {
#line 659
      printf((char const   */* __restrict  */)"Back to the first facet changing vertices: probably a mobius part.\nTry using a smaller tolerance or don\'t do a nearby check\n");
      }
      {
#line 662
      exit(1);
      }
      }
#line 663
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  return;
}
}
#line 669 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_which_vertices_to_change(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ,
                                         int *facet1 , int *vertex1 , int *facet2 ,
                                         int *vertex2 , stl_vertex *new_vertex1 ,
                                         stl_vertex *new_vertex2 ) 
{ 
  int v1a ;
  int v1b ;
  int v2a ;
  int v2b ;
  int tmp ;
  int tmp___0 ;

  {
#line 682
  if (edge_a->which_edge < 3) {
#line 684
    v1a = edge_a->which_edge;
#line 685
    v2a = (edge_a->which_edge + 1) % 3;
  } else {
#line 689
    v2a = edge_a->which_edge % 3;
#line 690
    v1a = (edge_a->which_edge + 1) % 3;
  }
#line 692
  if (edge_b->which_edge < 3) {
#line 694
    v1b = edge_b->which_edge;
#line 695
    v2b = (edge_b->which_edge + 1) % 3;
  } else {
#line 699
    v2b = edge_b->which_edge % 3;
#line 700
    v1b = (edge_b->which_edge + 1) % 3;
  }
  {
  {
#line 704
  tmp = memcmp((void const   *)(& (stl->facet_start + edge_a->facet_number)->vertex[v1a]),
               (void const   *)(& (stl->facet_start + edge_b->facet_number)->vertex[v1b]),
               (size_t )sizeof(stl_vertex ));
  }
  }
#line 704
  if (tmp) {
#line 713
    if ((stl->neighbors_start + edge_a->facet_number)->neighbor[v1a] == -1) {
#line 713
      if ((stl->neighbors_start + edge_a->facet_number)->neighbor[(v1a + 2) % 3] == -1) {
#line 718
        *facet1 = edge_a->facet_number;
#line 719
        *vertex1 = v1a;
#line 720
        *new_vertex1 = (stl->facet_start + edge_b->facet_number)->vertex[v1b];
      } else {
#line 724
        *facet1 = edge_b->facet_number;
#line 725
        *vertex1 = v1b;
#line 726
        *new_vertex1 = (stl->facet_start + edge_a->facet_number)->vertex[v1a];
      }
    } else {
#line 724
      *facet1 = edge_b->facet_number;
#line 725
      *vertex1 = v1b;
#line 726
      *new_vertex1 = (stl->facet_start + edge_a->facet_number)->vertex[v1a];
    }
  } else {
#line 709
    *facet1 = -1;
  }
  {
  {
#line 731
  tmp___0 = memcmp((void const   *)(& (stl->facet_start + edge_a->facet_number)->vertex[v2a]),
                   (void const   *)(& (stl->facet_start + edge_b->facet_number)->vertex[v2b]),
                   (size_t )sizeof(stl_vertex ));
  }
  }
#line 731
  if (tmp___0) {
#line 740
    if ((stl->neighbors_start + edge_a->facet_number)->neighbor[v2a] == -1) {
#line 740
      if ((stl->neighbors_start + edge_a->facet_number)->neighbor[(v2a + 2) % 3] == -1) {
#line 745
        *facet2 = edge_a->facet_number;
#line 746
        *vertex2 = v2a;
#line 747
        *new_vertex2 = (stl->facet_start + edge_b->facet_number)->vertex[v2b];
      } else {
#line 751
        *facet2 = edge_b->facet_number;
#line 752
        *vertex2 = v2b;
#line 753
        *new_vertex2 = (stl->facet_start + edge_a->facet_number)->vertex[v2a];
      }
    } else {
#line 751
      *facet2 = edge_b->facet_number;
#line 752
      *vertex2 = v2b;
#line 753
      *new_vertex2 = (stl->facet_start + edge_a->facet_number)->vertex[v2a];
    }
  } else {
#line 736
    *facet2 = -1;
  }
#line 756
  return;
}
}
#line 758 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_remove_facet(stl_file *stl , int facet_number ) 
{ 
  int neighbor[3] ;
  int vnot[3] ;
  int i ;
  int j ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 766
  (stl->stats.facets_removed) ++;
#line 768
  j = (((stl->neighbors_start + facet_number)->neighbor[0] == -1) + ((stl->neighbors_start + facet_number)->neighbor[1] == -1)) + ((stl->neighbors_start + facet_number)->neighbor[2] == -1);
#line 771
  if (j == 2) {
#line 773
    (stl->stats.connected_facets_1_edge) --;
  } else
#line 775
  if (j == 1) {
#line 777
    (stl->stats.connected_facets_2_edge) --;
#line 778
    (stl->stats.connected_facets_1_edge) --;
  } else
#line 780
  if (j == 0) {
#line 782
    (stl->stats.connected_facets_3_edge) --;
#line 783
    (stl->stats.connected_facets_2_edge) --;
#line 784
    (stl->stats.connected_facets_1_edge) --;
  }
#line 787
  *(stl->facet_start + facet_number) = *(stl->facet_start + (stl->stats.number_of_facets - 1));
#line 790
  *(stl->neighbors_start + facet_number) = *(stl->neighbors_start + (stl->stats.number_of_facets - 1));
#line 792
  (stl->stats.number_of_facets) --;
#line 794
  i = 0;
  {
  {
#line 794
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 794
    if (! (i < 3)) {
#line 794
      goto while_break;
    }
#line 796
    neighbor[i] = (stl->neighbors_start + facet_number)->neighbor[i];
#line 797
    vnot[i] = (int )(stl->neighbors_start + facet_number)->which_vertex_not[i];
#line 794
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  i = 0;
  {
  {
#line 800
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 800
    if (! (i < 3)) {
#line 800
      goto while_break___0;
    }
#line 802
    if (neighbor[i] != -1) {
#line 804
      if ((stl->neighbors_start + neighbor[i])->neighbor[(vnot[i] + 1) % 3] != stl->stats.number_of_facets) {
        {
        {
#line 807
        printf((char const   */* __restrict  */)"in stl_remove_facet: neighbor = %d numfacets = %d this is wrong\n",
               (stl->neighbors_start + neighbor[i])->neighbor[(vnot[i] + 1) % 3],
               stl->stats.number_of_facets);
        }
        {
#line 811
        exit(1);
        }
        }
      }
#line 813
      (stl->neighbors_start + neighbor[i])->neighbor[(vnot[i] + 1) % 3] = facet_number;
    }
#line 800
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 817
  return;
}
}
#line 819 "/home/wslee/benchmarks/admesh-0.95/connect.c"
void stl_remove_unconnected_facets(stl_file *stl ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 831
  i = 0;
  {
  {
#line 831
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 831
    if (! (i < stl->stats.number_of_facets)) {
#line 831
      goto while_break;
    }
    {
    {
#line 833
    tmp = memcmp((void const   *)(& (stl->facet_start + i)->vertex[0]), (void const   *)(& (stl->facet_start + i)->vertex[1]),
                 (size_t )sizeof(stl_vertex ));
    }
    }
#line 833
    if (tmp) {
      {
      {
#line 833
      tmp___0 = memcmp((void const   *)(& (stl->facet_start + i)->vertex[1]), (void const   *)(& (stl->facet_start + i)->vertex[2]),
                       (size_t )sizeof(stl_vertex ));
      }
      }
#line 833
      if (tmp___0) {
        {
        {
#line 833
        tmp___1 = memcmp((void const   *)(& (stl->facet_start + i)->vertex[0]), (void const   *)(& (stl->facet_start + i)->vertex[2]),
                         (size_t )sizeof(stl_vertex ));
        }
        }
#line 833
        if (! tmp___1) {
          {
          {
#line 840
          stl_remove_degenerate(stl, i);
          }
#line 841
          i --;
          }
        }
      } else {
        {
        {
#line 840
        stl_remove_degenerate(stl, i);
        }
#line 841
        i --;
        }
      }
    } else {
      {
      {
#line 840
      stl_remove_degenerate(stl, i);
      }
#line 841
      i --;
      }
    }
#line 831
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  if (stl->stats.connected_facets_1_edge < stl->stats.number_of_facets) {
#line 848
    i = 0;
    {
    {
#line 848
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 848
      if (! (i < stl->stats.number_of_facets)) {
#line 848
        goto while_break___0;
      }
#line 850
      if ((stl->neighbors_start + i)->neighbor[0] == -1) {
#line 850
        if ((stl->neighbors_start + i)->neighbor[1] == -1) {
#line 850
          if ((stl->neighbors_start + i)->neighbor[2] == -1) {
            {
            {
#line 855
            stl_remove_facet(stl, i);
            }
#line 856
            i --;
            }
          }
        }
      }
#line 848
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 860
  return;
}
}
#line 862 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_remove_degenerate(stl_file *stl , int facet ) 
{ 
  int edge1 ;
  int edge2 ;
  int edge3 ;
  int neighbor1 ;
  int neighbor2 ;
  int neighbor3 ;
  int vnot1 ;
  int vnot2 ;
  int vnot3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 875
  tmp = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[0]), (void const   *)(& (stl->facet_start + facet)->vertex[1]),
               (size_t )sizeof(stl_vertex ));
  }
  }
#line 875
  if (! tmp) {
    {
    {
#line 875
    tmp___0 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[1]), (void const   *)(& (stl->facet_start + facet)->vertex[2]),
                     (size_t )sizeof(stl_vertex ));
    }
    }
#line 875
    if (! tmp___0) {
      {
      {
#line 882
      printf((char const   */* __restrict  */)"removing a facet in stl_remove_degenerate\n");
      }
      {
#line 884
      stl_remove_facet(stl, facet);
      }
      }
#line 885
      return;
    }
  }
  {
  {
#line 888
  tmp___3 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[0]), (void const   *)(& (stl->facet_start + facet)->vertex[1]),
                   (size_t )sizeof(stl_vertex ));
  }
  }
#line 888
  if (tmp___3) {
    {
    {
#line 895
    tmp___2 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[1]), (void const   *)(& (stl->facet_start + facet)->vertex[2]),
                     (size_t )sizeof(stl_vertex ));
    }
    }
#line 895
    if (tmp___2) {
      {
      {
#line 902
      tmp___1 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[2]),
                       (void const   *)(& (stl->facet_start + facet)->vertex[0]),
                       (size_t )sizeof(stl_vertex ));
      }
      }
#line 902
      if (tmp___1) {
#line 912
        return;
      } else {
#line 905
        edge1 = 0;
#line 906
        edge2 = 1;
#line 907
        edge3 = 2;
      }
    } else {
#line 898
      edge1 = 0;
#line 899
      edge2 = 2;
#line 900
      edge3 = 1;
    }
  } else {
#line 891
    edge1 = 1;
#line 892
    edge2 = 2;
#line 893
    edge3 = 0;
  }
#line 914
  neighbor1 = (stl->neighbors_start + facet)->neighbor[edge1];
#line 915
  neighbor2 = (stl->neighbors_start + facet)->neighbor[edge2];
#line 917
  if (neighbor1 == -1) {
    {
    {
#line 919
    stl_update_connects_remove_1(stl, neighbor2);
    }
    }
  }
#line 921
  if (neighbor2 == -1) {
    {
    {
#line 923
    stl_update_connects_remove_1(stl, neighbor1);
    }
    }
  }
  {
#line 927
  neighbor3 = (stl->neighbors_start + facet)->neighbor[edge3];
#line 928
  vnot1 = (int )(stl->neighbors_start + facet)->which_vertex_not[edge1];
#line 929
  vnot2 = (int )(stl->neighbors_start + facet)->which_vertex_not[edge2];
#line 930
  vnot3 = (int )(stl->neighbors_start + facet)->which_vertex_not[edge3];
#line 932
  (stl->neighbors_start + neighbor1)->neighbor[(vnot1 + 1) % 3] = neighbor2;
#line 933
  (stl->neighbors_start + neighbor2)->neighbor[(vnot2 + 1) % 3] = neighbor1;
#line 934
  (stl->neighbors_start + neighbor1)->which_vertex_not[(vnot1 + 1) % 3] = (char )vnot2;
#line 935
  (stl->neighbors_start + neighbor2)->which_vertex_not[(vnot2 + 1) % 3] = (char )vnot1;
  {
#line 937
  stl_remove_facet(stl, facet);
  }
  }
#line 939
  if (neighbor3 != -1) {
    {
    {
#line 941
    stl_update_connects_remove_1(stl, neighbor3);
    }
#line 942
    (stl->neighbors_start + neighbor3)->neighbor[(vnot3 + 1) % 3] = -1;
    }
  }
#line 944
  return;
}
}
#line 946 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_update_connects_remove_1(stl_file *stl , int facet_num ) 
{ 
  int j ;

  {
#line 952
  j = (((stl->neighbors_start + facet_num)->neighbor[0] == -1) + ((stl->neighbors_start + facet_num)->neighbor[1] == -1)) + ((stl->neighbors_start + facet_num)->neighbor[2] == -1);
#line 955
  if (j == 0) {
#line 957
    (stl->stats.connected_facets_3_edge) --;
  } else
#line 959
  if (j == 1) {
#line 961
    (stl->stats.connected_facets_2_edge) --;
  } else
#line 963
  if (j == 2) {
#line 965
    (stl->stats.connected_facets_1_edge) --;
  }
#line 967
  return;
}
}
#line 969 "/home/wslee/benchmarks/admesh-0.95/connect.c"
void stl_fill_holes(stl_file *stl ) 
{ 
  stl_facet facet ;
  stl_facet new_facet ;
  int neighbors_initial[3] ;
  stl_hash_edge edge ;
  int first_facet ;
  int direction ;
  int facet_num ;
  int vnot ;
  int next_edge ;
  int pivot_vertex ;
  int next_facet ;
  int i ;
  int j ;
  int k ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 988
  stl_initialize_facet_check_nearby(stl);
  }
#line 989
  i = 0;
  }
  {
  {
#line 989
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 989
    if (! (i < stl->stats.number_of_facets)) {
#line 989
      goto while_break;
    }
#line 991
    facet = *(stl->facet_start + i);
#line 992
    j = 0;
    {
    {
#line 992
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 992
      if (! (j < 3)) {
#line 992
        goto while_break___0;
      }
#line 994
      if ((stl->neighbors_start + i)->neighbor[j] != -1) {
#line 994
        goto __Cont;
      }
      {
#line 995
      edge.facet_number = i;
#line 996
      edge.which_edge = j;
      {
#line 997
      stl_load_edge_exact(stl, & edge, & facet.vertex[j], & facet.vertex[(j + 1) % 3]);
      }
      {
#line 1000
      insert_hash_edge(stl, edge, & stl_match_neighbors_exact);
      }
      }
      __Cont: /* CIL Label */ 
#line 992
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 989
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  i = 0;
  {
  {
#line 1004
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1004
    if (! (i < stl->stats.number_of_facets)) {
#line 1004
      goto while_break___1;
    }
#line 1006
    facet = *(stl->facet_start + i);
#line 1007
    neighbors_initial[0] = (stl->neighbors_start + i)->neighbor[0];
#line 1008
    neighbors_initial[1] = (stl->neighbors_start + i)->neighbor[1];
#line 1009
    neighbors_initial[2] = (stl->neighbors_start + i)->neighbor[2];
#line 1010
    first_facet = i;
#line 1011
    j = 0;
    {
    {
#line 1011
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1011
      if (! (j < 3)) {
#line 1011
        goto while_break___2;
      }
#line 1013
      if ((stl->neighbors_start + i)->neighbor[j] != -1) {
#line 1013
        goto __Cont___0;
      }
#line 1015
      new_facet.vertex[0] = facet.vertex[j];
#line 1016
      new_facet.vertex[1] = facet.vertex[(j + 1) % 3];
#line 1017
      if (neighbors_initial[(j + 2) % 3] == -1) {
#line 1019
        direction = 1;
      } else {
#line 1023
        direction = 0;
      }
#line 1026
      facet_num = i;
#line 1027
      vnot = (j + 2) % 3;
      {
      {
#line 1029
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 1031
        if (vnot > 2) {
#line 1033
          if (direction == 0) {
#line 1035
            pivot_vertex = (vnot + 2) % 3;
#line 1036
            next_edge = pivot_vertex;
#line 1037
            direction = 1;
          } else {
#line 1041
            pivot_vertex = (vnot + 1) % 3;
#line 1042
            next_edge = vnot % 3;
#line 1043
            direction = 0;
          }
        } else
#line 1048
        if (direction == 0) {
#line 1050
          pivot_vertex = (vnot + 1) % 3;
#line 1051
          next_edge = vnot;
        } else {
#line 1055
          pivot_vertex = (vnot + 2) % 3;
#line 1056
          next_edge = pivot_vertex;
        }
#line 1059
        next_facet = (stl->neighbors_start + facet_num)->neighbor[next_edge];
#line 1061
        if (next_facet == -1) {
          {
#line 1063
          new_facet.vertex[2] = (stl->facet_start + facet_num)->vertex[vnot % 3];
          {
#line 1065
          stl_add_facet(stl, & new_facet);
          }
#line 1066
          k = 0;
          }
          {
          {
#line 1066
          while (1) {
            while_continue___10: /* CIL Label */ ;
            while_continue___4: /* CIL Label */ ;
#line 1066
            if (! (k < 3)) {
#line 1066
              goto while_break___4;
            }
            {
#line 1068
            edge.facet_number = stl->stats.number_of_facets - 1;
#line 1069
            edge.which_edge = k;
            {
#line 1070
            stl_load_edge_exact(stl, & edge, & new_facet.vertex[k], & new_facet.vertex[(k + 1) % 3]);
            }
            {
#line 1073
            insert_hash_edge(stl, edge, & stl_match_neighbors_exact);
            }
#line 1066
            k ++;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1075
          goto while_break___3;
        } else {
#line 1079
          vnot = (int )(stl->neighbors_start + facet_num)->which_vertex_not[next_edge];
#line 1081
          facet_num = next_facet;
        }
#line 1084
        if (facet_num == first_facet) {
          {
          {
#line 1087
          printf((char const   */* __restrict  */)"Back to the first facet filling holes: probably a mobius part.\nTry using a smaller tolerance or don\'t do a nearby check\n");
          }
          {
#line 1090
          exit(1);
          }
          }
#line 1091
          goto while_break___3;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 1011
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1004
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1096
  return;
}
}
#line 1098 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_add_facet(stl_file *stl , stl_facet *new_facet ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1101
  (stl->stats.facets_added) ++;
#line 1102
  if (stl->stats.facets_malloced < stl->stats.number_of_facets + 1) {
    {
    {
#line 1104
    tmp = realloc((void *)stl->facet_start, (size_t )(sizeof(stl_facet ) * (unsigned long )(stl->stats.facets_malloced + 256)));
    }
#line 1104
    stl->facet_start = (stl_facet *)tmp;
    }
#line 1106
    if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
      {
      {
#line 1106
      perror("stl_add_facet");
      }
      }
    }
    {
    {
#line 1107
    tmp___0 = realloc((void *)stl->neighbors_start, (size_t )(sizeof(stl_neighbors ) * (unsigned long )(stl->stats.facets_malloced + 256)));
    }
#line 1107
    stl->neighbors_start = (stl_neighbors *)tmp___0;
    }
#line 1109
    if ((unsigned long )stl->neighbors_start == (unsigned long )((void *)0)) {
      {
      {
#line 1109
      perror("stl_add_facet");
      }
      }
    }
#line 1110
    stl->stats.facets_malloced += 256;
  }
#line 1112
  *(stl->facet_start + stl->stats.number_of_facets) = *new_facet;
#line 1115
  (stl->facet_start + stl->stats.number_of_facets)->normal.x = (float )0.0;
#line 1116
  (stl->facet_start + stl->stats.number_of_facets)->normal.y = (float )0.0;
#line 1117
  (stl->facet_start + stl->stats.number_of_facets)->normal.z = (float )0.0;
#line 1119
  (stl->neighbors_start + stl->stats.number_of_facets)->neighbor[0] = -1;
#line 1120
  (stl->neighbors_start + stl->stats.number_of_facets)->neighbor[1] = -1;
#line 1121
  (stl->neighbors_start + stl->stats.number_of_facets)->neighbor[2] = -1;
#line 1122
  (stl->stats.number_of_facets) ++;
#line 1123
  return;
}
}
#line 61 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 28 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void stl_rotate(float *x , float *y , float angle ) ;
#line 29
static void stl_get_size(stl_file *stl ) ;
#line 30
static float get_area(stl_facet *facet ) ;
#line 31
static float get_volume(stl_file *stl ) ;
#line 34 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_verify_neighbors(stl_file *stl ) 
{ 
  int i ;
  int j ;
  stl_edge edge_a ;
  stl_edge edge_b ;
  int neighbor ;
  int vnot ;
  int tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 44
  stl->stats.backwards_edges = 0;
#line 46
  i = 0;
  {
  {
#line 46
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < stl->stats.number_of_facets)) {
#line 46
      goto while_break;
    }
#line 48
    j = 0;
    {
    {
#line 48
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 48
      if (! (j < 3)) {
#line 48
        goto while_break___0;
      }
#line 50
      edge_a.p1 = (stl->facet_start + i)->vertex[j];
#line 51
      edge_a.p2 = (stl->facet_start + i)->vertex[(j + 1) % 3];
#line 52
      neighbor = (stl->neighbors_start + i)->neighbor[j];
#line 53
      vnot = (int )(stl->neighbors_start + i)->which_vertex_not[j];
#line 55
      if (neighbor == -1) {
#line 56
        goto __Cont;
      }
#line 57
      if (vnot < 3) {
#line 59
        edge_b.p1 = (stl->facet_start + neighbor)->vertex[(vnot + 2) % 3];
#line 60
        edge_b.p2 = (stl->facet_start + neighbor)->vertex[(vnot + 1) % 3];
      } else {
#line 64
        (stl->stats.backwards_edges) ++;
#line 65
        edge_b.p1 = (stl->facet_start + neighbor)->vertex[(vnot + 1) % 3];
#line 66
        edge_b.p2 = (stl->facet_start + neighbor)->vertex[(vnot + 2) % 3];
      }
      {
      {
#line 68
      tmp = memcmp((void const   *)(& edge_a), (void const   *)(& edge_b), (size_t )24);
      }
      }
#line 68
      if (tmp != 0) {
        {
        {
#line 71
        printf((char const   */* __restrict  */)"edge %d of facet %d doesn\'t match edge %d of facet %d\n",
               j, i, vnot + 1, neighbor);
        }
        {
#line 73
        stl_write_facet(stl, (char *)"first facet", i);
        }
        {
#line 74
        stl_write_facet(stl, (char *)"second facet", neighbor);
        }
        }
      }
      __Cont: /* CIL Label */ 
#line 48
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 46
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_translate(stl_file *stl , float x , float y , float z ) 
{ 
  int i ;
  int j ;

  {
#line 86
  i = 0;
  {
  {
#line 86
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < stl->stats.number_of_facets)) {
#line 86
      goto while_break;
    }
#line 88
    j = 0;
    {
    {
#line 88
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (j < 3)) {
#line 88
        goto while_break___0;
      }
#line 90
      (stl->facet_start + i)->vertex[j].x -= stl->stats.min.x - x;
#line 91
      (stl->facet_start + i)->vertex[j].y -= stl->stats.min.y - y;
#line 92
      (stl->facet_start + i)->vertex[j].z -= stl->stats.min.z - z;
#line 88
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 86
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  stl->stats.max.x -= stl->stats.min.x - x;
#line 96
  stl->stats.max.y -= stl->stats.min.y - y;
#line 97
  stl->stats.max.z -= stl->stats.min.z - z;
#line 98
  stl->stats.min.x = x;
#line 99
  stl->stats.min.y = y;
#line 100
  stl->stats.min.z = z;
#line 101
  return;
}
}
#line 103 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_scale(stl_file *stl , float factor ) 
{ 
  int i ;
  int j ;

  {
#line 109
  stl->stats.min.x *= factor;
#line 110
  stl->stats.min.y *= factor;
#line 111
  stl->stats.min.z *= factor;
#line 112
  stl->stats.max.x *= factor;
#line 113
  stl->stats.max.y *= factor;
#line 114
  stl->stats.max.z *= factor;
#line 116
  i = 0;
  {
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < stl->stats.number_of_facets)) {
#line 116
      goto while_break;
    }
#line 118
    j = 0;
    {
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 118
      if (! (j < 3)) {
#line 118
        goto while_break___0;
      }
#line 120
      (stl->facet_start + i)->vertex[j].x *= factor;
#line 121
      (stl->facet_start + i)->vertex[j].y *= factor;
#line 122
      (stl->facet_start + i)->vertex[j].z *= factor;
#line 118
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void calculate_normals(stl_file *stl ) 
{ 
  long i ;
  float normal[3] ;
  void *__cil_tmp4 ;

  {
#line 132
  i = 0L;
  {
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < (long )stl->stats.number_of_facets)) {
#line 132
      goto while_break;
    }
    {
    {
#line 133
    stl_calculate_normal(normal, stl->facet_start + i);
    }
    {
#line 134
    stl_normalize_vector(normal);
    }
#line 135
    (stl->facet_start + i)->normal.x = normal[0];
#line 136
    (stl->facet_start + i)->normal.y = normal[1];
#line 137
    (stl->facet_start + i)->normal.z = normal[2];
#line 132
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 141 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_rotate_x(stl_file *stl , float angle ) 
{ 
  int i ;
  int j ;

  {
#line 147
  i = 0;
  {
  {
#line 147
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 147
    if (! (i < stl->stats.number_of_facets)) {
#line 147
      goto while_break;
    }
#line 149
    j = 0;
    {
    {
#line 149
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 149
      if (! (j < 3)) {
#line 149
        goto while_break___0;
      }
      {
      {
#line 151
      stl_rotate(& (stl->facet_start + i)->vertex[j].y, & (stl->facet_start + i)->vertex[j].z,
                 angle);
      }
#line 149
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 147
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 155
  stl_get_size(stl);
  }
  {
#line 156
  calculate_normals(stl);
  }
  }
#line 157
  return;
}
}
#line 159 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_rotate_y(stl_file *stl , float angle ) 
{ 
  int i ;
  int j ;

  {
#line 165
  i = 0;
  {
  {
#line 165
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 165
    if (! (i < stl->stats.number_of_facets)) {
#line 165
      goto while_break;
    }
#line 167
    j = 0;
    {
    {
#line 167
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! (j < 3)) {
#line 167
        goto while_break___0;
      }
      {
      {
#line 169
      stl_rotate(& (stl->facet_start + i)->vertex[j].z, & (stl->facet_start + i)->vertex[j].x,
                 angle);
      }
#line 167
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 165
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 173
  stl_get_size(stl);
  }
  {
#line 174
  calculate_normals(stl);
  }
  }
#line 175
  return;
}
}
#line 177 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_rotate_z(stl_file *stl , float angle ) 
{ 
  int i ;
  int j ;

  {
#line 183
  i = 0;
  {
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < stl->stats.number_of_facets)) {
#line 183
      goto while_break;
    }
#line 185
    j = 0;
    {
    {
#line 185
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 185
      if (! (j < 3)) {
#line 185
        goto while_break___0;
      }
      {
      {
#line 187
      stl_rotate(& (stl->facet_start + i)->vertex[j].x, & (stl->facet_start + i)->vertex[j].y,
                 angle);
      }
#line 185
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 183
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 191
  stl_get_size(stl);
  }
  {
#line 192
  calculate_normals(stl);
  }
  }
#line 193
  return;
}
}
#line 197 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void stl_rotate(float *x , float *y , float angle ) 
{ 
  double r ;
  double theta ;
  double radian_angle ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 204
  radian_angle = ((double )angle / 180.0) * 3.14159265358979323846;
  {
#line 206
  r = sqrt((double )(*x * *x + *y * *y));
  }
  {
#line 207
  theta = atan2((double )*y, (double )*x);
  }
  {
#line 208
  tmp = cos(theta + radian_angle);
  }
#line 208
  *x = (float )(r * tmp);
  {
#line 209
  tmp___0 = sin(theta + radian_angle);
  }
#line 209
  *y = (float )(r * tmp___0);
  }
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void stl_get_size(stl_file *stl ) 
{ 
  int i ;
  int j ;

  {
#line 218
  stl->stats.min.x = (stl->facet_start + 0)->vertex[0].x;
#line 219
  stl->stats.min.y = (stl->facet_start + 0)->vertex[0].y;
#line 220
  stl->stats.min.z = (stl->facet_start + 0)->vertex[0].z;
#line 221
  stl->stats.max.x = (stl->facet_start + 0)->vertex[0].x;
#line 222
  stl->stats.max.y = (stl->facet_start + 0)->vertex[0].y;
#line 223
  stl->stats.max.z = (stl->facet_start + 0)->vertex[0].z;
#line 225
  i = 0;
  {
  {
#line 225
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < stl->stats.number_of_facets)) {
#line 225
      goto while_break;
    }
#line 227
    j = 0;
    {
    {
#line 227
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (j < 3)) {
#line 227
        goto while_break___0;
      }
#line 229
      if (stl->stats.min.x < (stl->facet_start + i)->vertex[j].x) {
#line 229
        stl->stats.min.x = stl->stats.min.x;
      } else {
#line 229
        stl->stats.min.x = (stl->facet_start + i)->vertex[j].x;
      }
#line 231
      if (stl->stats.min.y < (stl->facet_start + i)->vertex[j].y) {
#line 231
        stl->stats.min.y = stl->stats.min.y;
      } else {
#line 231
        stl->stats.min.y = (stl->facet_start + i)->vertex[j].y;
      }
#line 233
      if (stl->stats.min.z < (stl->facet_start + i)->vertex[j].z) {
#line 233
        stl->stats.min.z = stl->stats.min.z;
      } else {
#line 233
        stl->stats.min.z = (stl->facet_start + i)->vertex[j].z;
      }
#line 235
      if (stl->stats.max.x > (stl->facet_start + i)->vertex[j].x) {
#line 235
        stl->stats.max.x = stl->stats.max.x;
      } else {
#line 235
        stl->stats.max.x = (stl->facet_start + i)->vertex[j].x;
      }
#line 237
      if (stl->stats.max.y > (stl->facet_start + i)->vertex[j].y) {
#line 237
        stl->stats.max.y = stl->stats.max.y;
      } else {
#line 237
        stl->stats.max.y = (stl->facet_start + i)->vertex[j].y;
      }
#line 239
      if (stl->stats.max.z > (stl->facet_start + i)->vertex[j].z) {
#line 239
        stl->stats.max.z = stl->stats.max.z;
      } else {
#line 239
        stl->stats.max.z = (stl->facet_start + i)->vertex[j].z;
      }
#line 227
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 225
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 245 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_mirror_xy(stl_file *stl ) 
{ 
  int i ;
  int j ;
  float temp_size ;

  {
#line 252
  i = 0;
  {
  {
#line 252
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < stl->stats.number_of_facets)) {
#line 252
      goto while_break;
    }
#line 254
    j = 0;
    {
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! (j < 3)) {
#line 254
        goto while_break___0;
      }
#line 256
      (stl->facet_start + i)->vertex[j].z = (float )((double )(stl->facet_start + i)->vertex[j].z * - 1.0);
#line 254
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 252
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  temp_size = stl->stats.min.z;
#line 260
  stl->stats.min.z = stl->stats.max.z;
#line 261
  stl->stats.max.z = temp_size;
#line 262
  stl->stats.min.z = (float )((double )stl->stats.min.z * - 1.0);
#line 263
  stl->stats.max.z = (float )((double )stl->stats.max.z * - 1.0);
#line 264
  return;
}
}
#line 266 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_mirror_yz(stl_file *stl ) 
{ 
  int i ;
  int j ;
  float temp_size ;

  {
#line 273
  i = 0;
  {
  {
#line 273
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < stl->stats.number_of_facets)) {
#line 273
      goto while_break;
    }
#line 275
    j = 0;
    {
    {
#line 275
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! (j < 3)) {
#line 275
        goto while_break___0;
      }
#line 277
      (stl->facet_start + i)->vertex[j].x = (float )((double )(stl->facet_start + i)->vertex[j].x * - 1.0);
#line 275
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  temp_size = stl->stats.min.x;
#line 281
  stl->stats.min.x = stl->stats.max.x;
#line 282
  stl->stats.max.x = temp_size;
#line 283
  stl->stats.min.x = (float )((double )stl->stats.min.x * - 1.0);
#line 284
  stl->stats.max.x = (float )((double )stl->stats.max.x * - 1.0);
#line 285
  return;
}
}
#line 287 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_mirror_xz(stl_file *stl ) 
{ 
  int i ;
  int j ;
  float temp_size ;

  {
#line 294
  i = 0;
  {
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < stl->stats.number_of_facets)) {
#line 294
      goto while_break;
    }
#line 296
    j = 0;
    {
    {
#line 296
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 296
      if (! (j < 3)) {
#line 296
        goto while_break___0;
      }
#line 298
      (stl->facet_start + i)->vertex[j].y = (float )((double )(stl->facet_start + i)->vertex[j].y * - 1.0);
#line 296
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 294
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  temp_size = stl->stats.min.y;
#line 302
  stl->stats.min.y = stl->stats.max.y;
#line 303
  stl->stats.max.y = temp_size;
#line 304
  stl->stats.min.y = (float )((double )stl->stats.min.y * - 1.0);
#line 305
  stl->stats.max.y = (float )((double )stl->stats.max.y * - 1.0);
#line 306
  return;
}
}
#line 308 "/home/wslee/benchmarks/admesh-0.95/util.c"
static float get_volume(stl_file *stl ) 
{ 
  long i ;
  stl_vertex p0 ;
  stl_vertex p ;
  stl_normal n ;
  float height ;
  float area ;
  float volume ;

  {
#line 316
  volume = (float )0.0;
#line 319
  p0.x = (stl->facet_start + 0)->vertex[0].x;
#line 320
  p0.y = (stl->facet_start + 0)->vertex[0].y;
#line 321
  p0.z = (stl->facet_start + 0)->vertex[0].z;
#line 323
  i = 0L;
  {
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < (long )stl->stats.number_of_facets)) {
#line 323
      goto while_break;
    }
    {
#line 324
    p.x = (stl->facet_start + i)->vertex[0].x - p0.x;
#line 325
    p.y = (stl->facet_start + i)->vertex[0].y - p0.y;
#line 326
    p.z = (stl->facet_start + i)->vertex[0].z - p0.z;
#line 328
    n = (stl->facet_start + i)->normal;
#line 329
    height = (n.x * p.x + n.y * p.y) + n.z * p.z;
    {
#line 330
    area = get_area(stl->facet_start + i);
    }
#line 331
    volume = (float )((double )volume + (double )(area * height) / 3.0);
#line 323
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return (volume);
}
}
#line 336 "/home/wslee/benchmarks/admesh-0.95/util.c"
void stl_calculate_volume(stl_file *stl ) 
{ 


  {
  {
  {
#line 338
  stl->stats.volume = get_volume(stl);
  }
  }
#line 339
  if ((double )stl->stats.volume < 0.0) {
    {
    {
#line 340
    stl_reverse_all_facets(stl);
    }
#line 341
    stl->stats.volume = - stl->stats.volume;
    }
  }
#line 343
  return;
}
}
#line 345 "/home/wslee/benchmarks/admesh-0.95/util.c"
static float get_area(stl_facet *facet ) 
{ 
  float cross[3][3] ;
  float sum[3] ;
  float n[3] ;
  float area ;
  int i ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 353
  i = 0;
  {
  {
#line 353
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < 3)) {
#line 353
      goto while_break;
    }
#line 354
    cross[i][0] = facet->vertex[i].y * facet->vertex[(i + 1) % 3].z - facet->vertex[i].z * facet->vertex[(i + 1) % 3].y;
#line 356
    cross[i][1] = facet->vertex[i].z * facet->vertex[(i + 1) % 3].x - facet->vertex[i].x * facet->vertex[(i + 1) % 3].z;
#line 358
    cross[i][2] = facet->vertex[i].x * facet->vertex[(i + 1) % 3].y - facet->vertex[i].y * facet->vertex[(i + 1) % 3].x;
#line 353
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  sum[0] = (cross[0][0] + cross[1][0]) + cross[2][0];
#line 363
  sum[1] = (cross[0][1] + cross[1][1]) + cross[2][1];
#line 364
  sum[2] = (cross[0][2] + cross[1][2]) + cross[2][2];
  {
#line 367
  stl_calculate_normal(n, facet);
  }
  {
#line 368
  stl_normalize_vector(n);
  }
#line 370
  area = (float )(0.5 * (double )((n[0] * sum[0] + n[1] * sum[1]) + n[2] * sum[2]));
  }
#line 371
  return (area);
}
}
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 407 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 732
extern void rewind(FILE *__stream ) ;
#line 34 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_initialize(stl_file *stl , char *file ) ;
#line 35
static void stl_allocate(stl_file *stl ) ;
#line 36
static void stl_read(stl_file *stl , int first_facet , int first ) ;
#line 37
static void stl_reallocate(stl_file *stl ) ;
#line 38
static int stl_get_little_int(FILE *fp ) ;
#line 39
static float stl_get_little_float(FILE *fp ) ;
#line 41 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
void stl_open(stl_file *stl , char *file ) 
{ 


  {
  {
  {
#line 44
  stl_initialize(stl, file);
  }
  {
#line 45
  stl_allocate(stl);
  }
  {
#line 46
  stl_read(stl, 0, 1);
  }
  {
#line 47
  fclose(stl->fp);
  }
  }
#line 48
  return;
}
}
#line 50 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static int stl_get_little_int(FILE *fp ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 54
  tmp = fgetc(fp);
  }
#line 54
  value = tmp & 255;
  {
#line 55
  tmp___0 = fgetc(fp);
  }
#line 55
  value |= (tmp___0 & 255) << 8;
  {
#line 56
  tmp___1 = fgetc(fp);
  }
#line 56
  value |= (tmp___1 & 255) << 16;
  {
#line 57
  tmp___2 = fgetc(fp);
  }
#line 57
  value |= (tmp___2 & 255) << 24;
  }
#line 58
  return (value);
}
}
#line 61 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static float stl_get_little_float(FILE *fp ) 
{ 
  union __anonunion_value_34 value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 70
  tmp = fgetc(fp);
  }
#line 70
  value.int_value = tmp & 255;
  {
#line 71
  tmp___0 = fgetc(fp);
  }
#line 71
  value.int_value |= (tmp___0 & 255) << 8;
  {
#line 72
  tmp___1 = fgetc(fp);
  }
#line 72
  value.int_value |= (tmp___1 & 255) << 16;
  {
#line 73
  tmp___2 = fgetc(fp);
  }
#line 73
  value.int_value |= (tmp___2 & 255) << 24;
  }
#line 74
  return (value.float_value);
}
}
#line 78 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_initialize(stl_file *stl , char *file ) 
{ 
  long file_size ;
  int header_num_facets ;
  int num_facets ;
  int i ;
  int j ;
  unsigned char chtest[128] ;
  int num_lines ;
  char *error_msg ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 86
  num_lines = 1;
#line 89
  stl->stats.degenerate_facets = 0;
#line 90
  stl->stats.edges_fixed = 0;
#line 91
  stl->stats.facets_added = 0;
#line 92
  stl->stats.facets_removed = 0;
#line 93
  stl->stats.facets_reversed = 0;
#line 94
  stl->stats.normals_fixed = 0;
#line 95
  stl->stats.number_of_parts = 0;
#line 96
  stl->stats.original_num_facets = 0;
#line 97
  stl->stats.number_of_facets = 0;
#line 98
  stl->stats.volume = (float )(- 1.0);
#line 100
  stl->neighbors_start = (stl_neighbors *)((void *)0);
#line 101
  stl->facet_start = (stl_facet *)((void *)0);
#line 102
  stl->v_indices = (v_indices_struct *)((void *)0);
#line 103
  stl->v_shared = (stl_vertex *)((void *)0);
  {
#line 107
  stl->fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
  }
#line 108
  if ((unsigned long )stl->fp == (unsigned long )((void *)0)) {
    {
    {
#line 110
    tmp = strlen((char const   *)file);
    }
    {
#line 110
    tmp___0 = malloc(81U + tmp);
    }
#line 110
    error_msg = (char *)tmp___0;
    {
#line 112
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_initialize: Couldn\'t open %s for reading",
            file);
    }
    {
#line 114
    perror((char const   *)error_msg);
    }
    {
#line 115
    free((void *)error_msg);
    }
    {
#line 116
    exit(1);
    }
    }
  }
  {
  {
#line 119
  fseek(stl->fp, 0L, 2);
  }
  {
#line 120
  file_size = ftell(stl->fp);
  }
  {
#line 123
  fseek(stl->fp, 84L, 0);
  }
  {
#line 124
  fread((void */* __restrict  */)(chtest), (size_t )sizeof(chtest), (size_t )1, (FILE */* __restrict  */)stl->fp);
  }
#line 125
  stl->stats.type = (stl_type )1;
#line 126
  i = 0;
  }
  {
  {
#line 126
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )i < sizeof(chtest))) {
#line 126
      goto while_break;
    }
#line 128
    if ((int )chtest[i] > 127) {
#line 130
      stl->stats.type = (stl_type )0;
#line 131
      goto while_break;
    }
#line 126
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  rewind(stl->fp);
  }
  }
#line 138
  if ((unsigned int )stl->stats.type == 0U) {
#line 141
    if ((file_size - 84L) % 50L != 0L) {
      {
      {
#line 144
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file %s has the wrong size.\n",
              file);
      }
      {
#line 145
      exit(1);
      }
      }
    } else
#line 141
    if (file_size < 284L) {
      {
      {
#line 144
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file %s has the wrong size.\n",
              file);
      }
      {
#line 145
      exit(1);
      }
      }
    }
    {
#line 147
    num_facets = (int )((file_size - 84L) / 50L);
    {
#line 150
    fread((void */* __restrict  */)(stl->stats.header), (size_t )80, (size_t )1, (FILE */* __restrict  */)stl->fp);
    }
#line 151
    stl->stats.header[80] = (char )'\000';
    {
#line 154
    header_num_facets = stl_get_little_int(stl->fp);
    }
    }
#line 155
    if (num_facets != header_num_facets) {
      {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: File size doesn\'t match number of facets in the header\n");
      }
      }
    }
  } else {
#line 165
    j = 0;
#line 166
    i = 0;
    {
    {
#line 166
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! ((long )i < file_size)) {
#line 166
        goto while_break___0;
      }
      {
#line 168
      j ++;
      {
#line 169
      tmp___1 = _IO_getc(stl->fp);
      }
      }
#line 169
      if (tmp___1 == 10) {
#line 171
        if (j > 4) {
#line 173
          num_lines ++;
        }
#line 175
        j = 0;
      }
#line 166
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 178
    rewind(stl->fp);
    }
#line 181
    i = 0;
    }
    {
    {
#line 181
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 181
      if (i < 80) {
        {
        {
#line 181
        tmp___3 = _IO_getc(stl->fp);
        }
#line 181
        tmp___2 = (char )tmp___3;
#line 181
        stl->stats.header[i] = tmp___2;
        }
#line 181
        if (! ((int )tmp___2 != 10)) {
#line 181
          goto while_break___1;
        }
      } else {
#line 181
        goto while_break___1;
      }
#line 181
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 183
    stl->stats.header[i] = (char )'\000';
#line 184
    stl->stats.header[80] = (char )'\000';
#line 186
    num_facets = num_lines / 7;
  }
#line 188
  stl->stats.number_of_facets += num_facets;
#line 189
  stl->stats.original_num_facets = stl->stats.number_of_facets;
#line 190
  return;
}
}
#line 192 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_allocate(stl_file *stl ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 196
  tmp = calloc((size_t )stl->stats.number_of_facets, (size_t )sizeof(stl_facet ));
  }
#line 196
  stl->facet_start = (stl_facet *)tmp;
  }
#line 198
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 198
    perror("stl_initialize");
    }
    }
  }
  {
#line 199
  stl->stats.facets_malloced = stl->stats.number_of_facets;
  {
#line 202
  tmp___0 = calloc((size_t )stl->stats.number_of_facets, (size_t )sizeof(stl_neighbors ));
  }
#line 202
  stl->neighbors_start = (stl_neighbors *)tmp___0;
  }
#line 204
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 204
    perror("stl_initialize");
    }
    }
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
void stl_open_merge(stl_file *stl , char *file ) 
{ 
  int first_facet ;

  {
  {
#line 212
  first_facet = stl->stats.number_of_facets;
  {
#line 213
  stl_initialize(stl, file);
  }
  {
#line 214
  stl_reallocate(stl);
  }
  {
#line 215
  stl_read(stl, first_facet, 0);
  }
  }
#line 216
  return;
}
}
#line 218 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_reallocate(stl_file *stl ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 222
  tmp = realloc((void *)stl->facet_start, (size_t )((unsigned long )stl->stats.number_of_facets * sizeof(stl_facet )));
  }
#line 222
  stl->facet_start = (stl_facet *)tmp;
  }
#line 224
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 224
    perror("stl_initialize");
    }
    }
  }
  {
#line 225
  stl->stats.facets_malloced = stl->stats.number_of_facets;
  {
#line 228
  tmp___0 = realloc((void *)stl->neighbors_start, (size_t )((unsigned long )stl->stats.number_of_facets * sizeof(stl_neighbors )));
  }
#line 228
  stl->neighbors_start = (stl_neighbors *)tmp___0;
  }
#line 231
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 231
    perror("stl_initialize");
    }
    }
  }
#line 232
  return;
}
}
#line 234 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_read(stl_file *stl , int first_facet , int first ) 
{ 
  stl_facet facet ;
  int i ;
  float diff_x ;
  float diff_y ;
  float diff_z ;
  float max_diff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 245
  if ((unsigned int )stl->stats.type == 0U) {
    {
    {
#line 247
    fseek(stl->fp, 84L, 0);
    }
    }
  } else {
    {
    {
#line 251
    rewind(stl->fp);
    }
    }
    {
    {
#line 253
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 253
      tmp = _IO_getc(stl->fp);
      }
      }
#line 253
      if (! (tmp != 10)) {
#line 253
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 256
  i = first_facet;
  {
  {
#line 256
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! (i < stl->stats.number_of_facets)) {
#line 256
      goto while_break___0;
    }
#line 258
    if ((unsigned int )stl->stats.type == 0U) {
      {
      {
#line 261
      facet.normal.x = stl_get_little_float(stl->fp);
      }
      {
#line 262
      facet.normal.y = stl_get_little_float(stl->fp);
      }
      {
#line 263
      facet.normal.z = stl_get_little_float(stl->fp);
      }
      {
#line 264
      facet.vertex[0].x = stl_get_little_float(stl->fp);
      }
      {
#line 265
      facet.vertex[0].y = stl_get_little_float(stl->fp);
      }
      {
#line 266
      facet.vertex[0].z = stl_get_little_float(stl->fp);
      }
      {
#line 267
      facet.vertex[1].x = stl_get_little_float(stl->fp);
      }
      {
#line 268
      facet.vertex[1].y = stl_get_little_float(stl->fp);
      }
      {
#line 269
      facet.vertex[1].z = stl_get_little_float(stl->fp);
      }
      {
#line 270
      facet.vertex[2].x = stl_get_little_float(stl->fp);
      }
      {
#line 271
      facet.vertex[2].y = stl_get_little_float(stl->fp);
      }
      {
#line 272
      facet.vertex[2].z = stl_get_little_float(stl->fp);
      }
      {
#line 273
      tmp___0 = fgetc(stl->fp);
      }
#line 273
      facet.extra[0] = (char )tmp___0;
      {
#line 274
      tmp___1 = fgetc(stl->fp);
      }
#line 274
      facet.extra[1] = (char )tmp___1;
      }
    } else {
      {
      {
#line 279
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %*s %f %f %f\n",
             & facet.normal.x, & facet.normal.y, & facet.normal.z);
      }
      {
#line 281
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %*s");
      }
      {
#line 282
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %f %f %f\n",
             & facet.vertex[0].x, & facet.vertex[0].y, & facet.vertex[0].z);
      }
      {
#line 284
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %f %f %f\n",
             & facet.vertex[1].x, & facet.vertex[1].y, & facet.vertex[1].z);
      }
      {
#line 286
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %f %f %f\n",
             & facet.vertex[2].x, & facet.vertex[2].y, & facet.vertex[2].z);
      }
      {
#line 288
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s");
      }
      {
#line 289
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s");
      }
      }
    }
#line 292
    *(stl->facet_start + i) = facet;
#line 298
    if (first) {
#line 300
      stl->stats.max.x = facet.vertex[0].x;
#line 301
      stl->stats.min.x = facet.vertex[0].x;
#line 302
      stl->stats.max.y = facet.vertex[0].y;
#line 303
      stl->stats.min.y = facet.vertex[0].y;
#line 304
      stl->stats.max.z = facet.vertex[0].z;
#line 305
      stl->stats.min.z = facet.vertex[0].z;
#line 307
      if (facet.vertex[0].x - facet.vertex[1].x < (float )0) {
#line 307
        diff_x = - (facet.vertex[0].x - facet.vertex[1].x);
      } else {
#line 307
        diff_x = facet.vertex[0].x - facet.vertex[1].x;
      }
#line 308
      if (facet.vertex[0].y - facet.vertex[1].y < (float )0) {
#line 308
        diff_y = - (facet.vertex[0].y - facet.vertex[1].y);
      } else {
#line 308
        diff_y = facet.vertex[0].y - facet.vertex[1].y;
      }
#line 309
      if (facet.vertex[0].z - facet.vertex[1].z < (float )0) {
#line 309
        diff_z = - (facet.vertex[0].z - facet.vertex[1].z);
      } else {
#line 309
        diff_z = facet.vertex[0].z - facet.vertex[1].z;
      }
#line 310
      if (diff_x > diff_y) {
#line 310
        max_diff = diff_x;
      } else {
#line 310
        max_diff = diff_y;
      }
#line 311
      if (diff_z > max_diff) {
#line 311
        max_diff = diff_z;
      } else {
#line 311
        max_diff = max_diff;
      }
#line 312
      stl->stats.shortest_edge = max_diff;
#line 314
      first = 0;
    }
#line 317
    if (stl->stats.max.x > facet.vertex[0].x) {
#line 317
      stl->stats.max.x = stl->stats.max.x;
    } else {
#line 317
      stl->stats.max.x = facet.vertex[0].x;
    }
#line 318
    if (stl->stats.min.x < facet.vertex[0].x) {
#line 318
      stl->stats.min.x = stl->stats.min.x;
    } else {
#line 318
      stl->stats.min.x = facet.vertex[0].x;
    }
#line 319
    if (stl->stats.max.y > facet.vertex[0].y) {
#line 319
      stl->stats.max.y = stl->stats.max.y;
    } else {
#line 319
      stl->stats.max.y = facet.vertex[0].y;
    }
#line 320
    if (stl->stats.min.y < facet.vertex[0].y) {
#line 320
      stl->stats.min.y = stl->stats.min.y;
    } else {
#line 320
      stl->stats.min.y = facet.vertex[0].y;
    }
#line 321
    if (stl->stats.max.z > facet.vertex[0].z) {
#line 321
      stl->stats.max.z = stl->stats.max.z;
    } else {
#line 321
      stl->stats.max.z = facet.vertex[0].z;
    }
#line 322
    if (stl->stats.min.z < facet.vertex[0].z) {
#line 322
      stl->stats.min.z = stl->stats.min.z;
    } else {
#line 322
      stl->stats.min.z = facet.vertex[0].z;
    }
#line 324
    if (stl->stats.max.x > facet.vertex[1].x) {
#line 324
      stl->stats.max.x = stl->stats.max.x;
    } else {
#line 324
      stl->stats.max.x = facet.vertex[1].x;
    }
#line 325
    if (stl->stats.min.x < facet.vertex[1].x) {
#line 325
      stl->stats.min.x = stl->stats.min.x;
    } else {
#line 325
      stl->stats.min.x = facet.vertex[1].x;
    }
#line 326
    if (stl->stats.max.y > facet.vertex[1].y) {
#line 326
      stl->stats.max.y = stl->stats.max.y;
    } else {
#line 326
      stl->stats.max.y = facet.vertex[1].y;
    }
#line 327
    if (stl->stats.min.y < facet.vertex[1].y) {
#line 327
      stl->stats.min.y = stl->stats.min.y;
    } else {
#line 327
      stl->stats.min.y = facet.vertex[1].y;
    }
#line 328
    if (stl->stats.max.z > facet.vertex[1].z) {
#line 328
      stl->stats.max.z = stl->stats.max.z;
    } else {
#line 328
      stl->stats.max.z = facet.vertex[1].z;
    }
#line 329
    if (stl->stats.min.z < facet.vertex[1].z) {
#line 329
      stl->stats.min.z = stl->stats.min.z;
    } else {
#line 329
      stl->stats.min.z = facet.vertex[1].z;
    }
#line 331
    if (stl->stats.max.x > facet.vertex[2].x) {
#line 331
      stl->stats.max.x = stl->stats.max.x;
    } else {
#line 331
      stl->stats.max.x = facet.vertex[2].x;
    }
#line 332
    if (stl->stats.min.x < facet.vertex[2].x) {
#line 332
      stl->stats.min.x = stl->stats.min.x;
    } else {
#line 332
      stl->stats.min.x = facet.vertex[2].x;
    }
#line 333
    if (stl->stats.max.y > facet.vertex[2].y) {
#line 333
      stl->stats.max.y = stl->stats.max.y;
    } else {
#line 333
      stl->stats.max.y = facet.vertex[2].y;
    }
#line 334
    if (stl->stats.min.y < facet.vertex[2].y) {
#line 334
      stl->stats.min.y = stl->stats.min.y;
    } else {
#line 334
      stl->stats.min.y = facet.vertex[2].y;
    }
#line 335
    if (stl->stats.max.z > facet.vertex[2].z) {
#line 335
      stl->stats.max.z = stl->stats.max.z;
    } else {
#line 335
      stl->stats.max.z = facet.vertex[2].z;
    }
#line 336
    if (stl->stats.min.z < facet.vertex[2].z) {
#line 336
      stl->stats.min.z = stl->stats.min.z;
    } else {
#line 336
      stl->stats.min.z = facet.vertex[2].z;
    }
#line 256
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 338
  stl->stats.size.x = stl->stats.max.x - stl->stats.min.x;
#line 339
  stl->stats.size.y = stl->stats.max.y - stl->stats.min.y;
#line 340
  stl->stats.size.z = stl->stats.max.z - stl->stats.min.z;
  {
#line 341
  tmp___2 = sqrt((double )((stl->stats.size.x * stl->stats.size.x + stl->stats.size.y * stl->stats.size.y) + stl->stats.size.z * stl->stats.size.z));
  }
#line 341
  stl->stats.bounding_diameter = (float )tmp___2;
  }
#line 345
  return;
}
}
#line 348 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
void stl_close(stl_file *stl ) 
{ 


  {
#line 351
  if ((unsigned long )stl->neighbors_start != (unsigned long )((void *)0)) {
    {
    {
#line 352
    free((void *)stl->neighbors_start);
    }
    }
  }
#line 353
  if ((unsigned long )stl->facet_start != (unsigned long )((void *)0)) {
    {
    {
#line 354
    free((void *)stl->facet_start);
    }
    }
  }
#line 355
  if ((unsigned long )stl->v_indices != (unsigned long )((void *)0)) {
    {
    {
#line 356
    free((void *)stl->v_indices);
    }
    }
  }
#line 357
  if ((unsigned long )stl->v_shared != (unsigned long )((void *)0)) {
    {
    {
#line 358
    free((void *)stl->v_shared);
    }
    }
  }
#line 359
  return;
}
}
#line 34
static void stl_initialize___0(stl_file *stl , char *file ) ;
#line 35
static void stl_allocate___0(stl_file *stl ) ;
#line 36
static void stl_read___0(stl_file *stl , int first_facet , int first ) ;
#line 37
static void stl_reallocate___0(stl_file *stl ) ;
#line 38
static int stl_get_little_int___0(FILE *fp ) ;
#line 39
static float stl_get_little_float___0(FILE *fp ) ;
#line 50 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static int stl_get_little_int___0(FILE *fp ) 
{ 
  int value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 54
  tmp = fgetc(fp);
  }
#line 54
  value = tmp & 255;
  {
#line 55
  tmp___0 = fgetc(fp);
  }
#line 55
  value |= (tmp___0 & 255) << 8;
  {
#line 56
  tmp___1 = fgetc(fp);
  }
#line 56
  value |= (tmp___1 & 255) << 16;
  {
#line 57
  tmp___2 = fgetc(fp);
  }
#line 57
  value |= (tmp___2 & 255) << 24;
  }
#line 58
  return (value);
}
}
#line 61 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static float stl_get_little_float___0(FILE *fp ) 
{ 
  union __anonunion_value_34___0 value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 70
  tmp = fgetc(fp);
  }
#line 70
  value.int_value = tmp & 255;
  {
#line 71
  tmp___0 = fgetc(fp);
  }
#line 71
  value.int_value |= (tmp___0 & 255) << 8;
  {
#line 72
  tmp___1 = fgetc(fp);
  }
#line 72
  value.int_value |= (tmp___1 & 255) << 16;
  {
#line 73
  tmp___2 = fgetc(fp);
  }
#line 73
  value.int_value |= (tmp___2 & 255) << 24;
  }
#line 74
  return (value.float_value);
}
}
#line 78 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_initialize___0(stl_file *stl , char *file ) 
{ 
  long file_size ;
  int header_num_facets ;
  int num_facets ;
  int i ;
  int j ;
  unsigned char chtest[128] ;
  int num_lines ;
  char *error_msg ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 86
  num_lines = 1;
#line 89
  stl->stats.degenerate_facets = 0;
#line 90
  stl->stats.edges_fixed = 0;
#line 91
  stl->stats.facets_added = 0;
#line 92
  stl->stats.facets_removed = 0;
#line 93
  stl->stats.facets_reversed = 0;
#line 94
  stl->stats.normals_fixed = 0;
#line 95
  stl->stats.number_of_parts = 0;
#line 96
  stl->stats.original_num_facets = 0;
#line 97
  stl->stats.number_of_facets = 0;
#line 98
  stl->stats.volume = (float )(- 1.0);
#line 100
  stl->neighbors_start = (stl_neighbors *)((void *)0);
#line 101
  stl->facet_start = (stl_facet *)((void *)0);
#line 102
  stl->v_indices = (v_indices_struct *)((void *)0);
#line 103
  stl->v_shared = (stl_vertex *)((void *)0);
  {
#line 107
  stl->fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
  }
#line 108
  if ((unsigned long )stl->fp == (unsigned long )((void *)0)) {
    {
    {
#line 110
    tmp = strlen((char const   *)file);
    }
    {
#line 110
    tmp___0 = malloc(81U + tmp);
    }
#line 110
    error_msg = (char *)tmp___0;
    {
#line 112
    sprintf((char */* __restrict  */)error_msg, (char const   */* __restrict  */)"stl_initialize: Couldn\'t open %s for reading",
            file);
    }
    {
#line 114
    perror((char const   *)error_msg);
    }
    {
#line 115
    free((void *)error_msg);
    }
    {
#line 116
    exit(1);
    }
    }
  }
  {
  {
#line 119
  fseek(stl->fp, 0L, 2);
  }
  {
#line 120
  file_size = ftell(stl->fp);
  }
  {
#line 123
  fseek(stl->fp, 84L, 0);
  }
  {
#line 124
  fread((void */* __restrict  */)(chtest), (size_t )sizeof(chtest), (size_t )1, (FILE */* __restrict  */)stl->fp);
  }
#line 125
  stl->stats.type = (stl_type )1;
#line 126
  i = 0;
  }
  {
  {
#line 126
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )i < sizeof(chtest))) {
#line 126
      goto while_break;
    }
#line 128
    if ((int )chtest[i] > 127) {
#line 130
      stl->stats.type = (stl_type )0;
#line 131
      goto while_break;
    }
#line 126
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 134
  rewind(stl->fp);
  }
  }
#line 138
  if ((unsigned int )stl->stats.type == 0U) {
#line 141
    if ((file_size - 84L) % 50L != 0L) {
      {
      {
#line 144
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file %s has the wrong size.\n",
              file);
      }
      {
#line 145
      exit(1);
      }
      }
    } else
#line 141
    if (file_size < 284L) {
      {
      {
#line 144
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The file %s has the wrong size.\n",
              file);
      }
      {
#line 145
      exit(1);
      }
      }
    }
    {
#line 147
    num_facets = (int )((file_size - 84L) / 50L);
    {
#line 150
    fread((void */* __restrict  */)(stl->stats.header), (size_t )80, (size_t )1, (FILE */* __restrict  */)stl->fp);
    }
#line 151
    stl->stats.header[80] = (char )'\000';
    {
#line 154
    header_num_facets = stl_get_little_int___0(stl->fp);
    }
    }
#line 155
    if (num_facets != header_num_facets) {
      {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: File size doesn\'t match number of facets in the header\n");
      }
      }
    }
  } else {
#line 165
    j = 0;
#line 166
    i = 0;
    {
    {
#line 166
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 166
      if (! ((long )i < file_size)) {
#line 166
        goto while_break___0;
      }
      {
#line 168
      j ++;
      {
#line 169
      tmp___1 = _IO_getc(stl->fp);
      }
      }
#line 169
      if (tmp___1 == 10) {
#line 171
        if (j > 4) {
#line 173
          num_lines ++;
        }
#line 175
        j = 0;
      }
#line 166
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 178
    rewind(stl->fp);
    }
#line 181
    i = 0;
    }
    {
    {
#line 181
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 181
      if (i < 80) {
        {
        {
#line 181
        tmp___3 = _IO_getc(stl->fp);
        }
#line 181
        tmp___2 = (char )tmp___3;
#line 181
        stl->stats.header[i] = tmp___2;
        }
#line 181
        if (! ((int )tmp___2 != 10)) {
#line 181
          goto while_break___1;
        }
      } else {
#line 181
        goto while_break___1;
      }
#line 181
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 183
    stl->stats.header[i] = (char )'\000';
#line 184
    stl->stats.header[80] = (char )'\000';
#line 186
    num_facets = num_lines / 7;
  }
#line 188
  stl->stats.number_of_facets += num_facets;
#line 189
  stl->stats.original_num_facets = stl->stats.number_of_facets;
#line 190
  return;
}
}
#line 192 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_allocate___0(stl_file *stl ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 196
  tmp = calloc((size_t )stl->stats.number_of_facets, (size_t )sizeof(stl_facet ));
  }
#line 196
  stl->facet_start = (stl_facet *)tmp;
  }
#line 198
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 198
    perror("stl_initialize");
    }
    }
  }
  {
#line 199
  stl->stats.facets_malloced = stl->stats.number_of_facets;
  {
#line 202
  tmp___0 = calloc((size_t )stl->stats.number_of_facets, (size_t )sizeof(stl_neighbors ));
  }
#line 202
  stl->neighbors_start = (stl_neighbors *)tmp___0;
  }
#line 204
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 204
    perror("stl_initialize");
    }
    }
  }
#line 205
  return;
}
}
#line 218 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_reallocate___0(stl_file *stl ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 222
  tmp = realloc((void *)stl->facet_start, (size_t )((unsigned long )stl->stats.number_of_facets * sizeof(stl_facet )));
  }
#line 222
  stl->facet_start = (stl_facet *)tmp;
  }
#line 224
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 224
    perror("stl_initialize");
    }
    }
  }
  {
#line 225
  stl->stats.facets_malloced = stl->stats.number_of_facets;
  {
#line 228
  tmp___0 = realloc((void *)stl->neighbors_start, (size_t )((unsigned long )stl->stats.number_of_facets * sizeof(stl_neighbors )));
  }
#line 228
  stl->neighbors_start = (stl_neighbors *)tmp___0;
  }
#line 231
  if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
    {
    {
#line 231
    perror("stl_initialize");
    }
    }
  }
#line 232
  return;
}
}
#line 234 "/home/wslee/benchmarks/admesh-0.95/stlinit.c"
static void stl_read___0(stl_file *stl , int first_facet , int first ) 
{ 
  stl_facet facet ;
  int i ;
  float diff_x ;
  float diff_y ;
  float diff_z ;
  float max_diff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 245
  if ((unsigned int )stl->stats.type == 0U) {
    {
    {
#line 247
    fseek(stl->fp, 84L, 0);
    }
    }
  } else {
    {
    {
#line 251
    rewind(stl->fp);
    }
    }
    {
    {
#line 253
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 253
      tmp = _IO_getc(stl->fp);
      }
      }
#line 253
      if (! (tmp != 10)) {
#line 253
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 256
  i = first_facet;
  {
  {
#line 256
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 256
    if (! (i < stl->stats.number_of_facets)) {
#line 256
      goto while_break___0;
    }
#line 258
    if ((unsigned int )stl->stats.type == 0U) {
      {
      {
#line 261
      facet.normal.x = stl_get_little_float___0(stl->fp);
      }
      {
#line 262
      facet.normal.y = stl_get_little_float___0(stl->fp);
      }
      {
#line 263
      facet.normal.z = stl_get_little_float___0(stl->fp);
      }
      {
#line 264
      facet.vertex[0].x = stl_get_little_float___0(stl->fp);
      }
      {
#line 265
      facet.vertex[0].y = stl_get_little_float___0(stl->fp);
      }
      {
#line 266
      facet.vertex[0].z = stl_get_little_float___0(stl->fp);
      }
      {
#line 267
      facet.vertex[1].x = stl_get_little_float___0(stl->fp);
      }
      {
#line 268
      facet.vertex[1].y = stl_get_little_float___0(stl->fp);
      }
      {
#line 269
      facet.vertex[1].z = stl_get_little_float___0(stl->fp);
      }
      {
#line 270
      facet.vertex[2].x = stl_get_little_float___0(stl->fp);
      }
      {
#line 271
      facet.vertex[2].y = stl_get_little_float___0(stl->fp);
      }
      {
#line 272
      facet.vertex[2].z = stl_get_little_float___0(stl->fp);
      }
      {
#line 273
      tmp___0 = fgetc(stl->fp);
      }
#line 273
      facet.extra[0] = (char )tmp___0;
      {
#line 274
      tmp___1 = fgetc(stl->fp);
      }
#line 274
      facet.extra[1] = (char )tmp___1;
      }
    } else {
      {
      {
#line 279
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %*s %f %f %f\n",
             & facet.normal.x, & facet.normal.y, & facet.normal.z);
      }
      {
#line 281
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %*s");
      }
      {
#line 282
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %f %f %f\n",
             & facet.vertex[0].x, & facet.vertex[0].y, & facet.vertex[0].z);
      }
      {
#line 284
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %f %f %f\n",
             & facet.vertex[1].x, & facet.vertex[1].y, & facet.vertex[1].z);
      }
      {
#line 286
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s %f %f %f\n",
             & facet.vertex[2].x, & facet.vertex[2].y, & facet.vertex[2].z);
      }
      {
#line 288
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s");
      }
      {
#line 289
      fscanf((FILE */* __restrict  */)stl->fp, (char const   */* __restrict  */)"%*s");
      }
      }
    }
#line 292
    *(stl->facet_start + i) = facet;
#line 298
    if (first) {
#line 300
      stl->stats.max.x = facet.vertex[0].x;
#line 301
      stl->stats.min.x = facet.vertex[0].x;
#line 302
      stl->stats.max.y = facet.vertex[0].y;
#line 303
      stl->stats.min.y = facet.vertex[0].y;
#line 304
      stl->stats.max.z = facet.vertex[0].z;
#line 305
      stl->stats.min.z = facet.vertex[0].z;
#line 307
      if (facet.vertex[0].x - facet.vertex[1].x < (float )0) {
#line 307
        diff_x = - (facet.vertex[0].x - facet.vertex[1].x);
      } else {
#line 307
        diff_x = facet.vertex[0].x - facet.vertex[1].x;
      }
#line 308
      if (facet.vertex[0].y - facet.vertex[1].y < (float )0) {
#line 308
        diff_y = - (facet.vertex[0].y - facet.vertex[1].y);
      } else {
#line 308
        diff_y = facet.vertex[0].y - facet.vertex[1].y;
      }
#line 309
      if (facet.vertex[0].z - facet.vertex[1].z < (float )0) {
#line 309
        diff_z = - (facet.vertex[0].z - facet.vertex[1].z);
      } else {
#line 309
        diff_z = facet.vertex[0].z - facet.vertex[1].z;
      }
#line 310
      if (diff_x > diff_y) {
#line 310
        max_diff = diff_x;
      } else {
#line 310
        max_diff = diff_y;
      }
#line 311
      if (diff_z > max_diff) {
#line 311
        max_diff = diff_z;
      } else {
#line 311
        max_diff = max_diff;
      }
#line 312
      stl->stats.shortest_edge = max_diff;
#line 314
      first = 0;
    }
#line 317
    if (stl->stats.max.x > facet.vertex[0].x) {
#line 317
      stl->stats.max.x = stl->stats.max.x;
    } else {
#line 317
      stl->stats.max.x = facet.vertex[0].x;
    }
#line 318
    if (stl->stats.min.x < facet.vertex[0].x) {
#line 318
      stl->stats.min.x = stl->stats.min.x;
    } else {
#line 318
      stl->stats.min.x = facet.vertex[0].x;
    }
#line 319
    if (stl->stats.max.y > facet.vertex[0].y) {
#line 319
      stl->stats.max.y = stl->stats.max.y;
    } else {
#line 319
      stl->stats.max.y = facet.vertex[0].y;
    }
#line 320
    if (stl->stats.min.y < facet.vertex[0].y) {
#line 320
      stl->stats.min.y = stl->stats.min.y;
    } else {
#line 320
      stl->stats.min.y = facet.vertex[0].y;
    }
#line 321
    if (stl->stats.max.z > facet.vertex[0].z) {
#line 321
      stl->stats.max.z = stl->stats.max.z;
    } else {
#line 321
      stl->stats.max.z = facet.vertex[0].z;
    }
#line 322
    if (stl->stats.min.z < facet.vertex[0].z) {
#line 322
      stl->stats.min.z = stl->stats.min.z;
    } else {
#line 322
      stl->stats.min.z = facet.vertex[0].z;
    }
#line 324
    if (stl->stats.max.x > facet.vertex[1].x) {
#line 324
      stl->stats.max.x = stl->stats.max.x;
    } else {
#line 324
      stl->stats.max.x = facet.vertex[1].x;
    }
#line 325
    if (stl->stats.min.x < facet.vertex[1].x) {
#line 325
      stl->stats.min.x = stl->stats.min.x;
    } else {
#line 325
      stl->stats.min.x = facet.vertex[1].x;
    }
#line 326
    if (stl->stats.max.y > facet.vertex[1].y) {
#line 326
      stl->stats.max.y = stl->stats.max.y;
    } else {
#line 326
      stl->stats.max.y = facet.vertex[1].y;
    }
#line 327
    if (stl->stats.min.y < facet.vertex[1].y) {
#line 327
      stl->stats.min.y = stl->stats.min.y;
    } else {
#line 327
      stl->stats.min.y = facet.vertex[1].y;
    }
#line 328
    if (stl->stats.max.z > facet.vertex[1].z) {
#line 328
      stl->stats.max.z = stl->stats.max.z;
    } else {
#line 328
      stl->stats.max.z = facet.vertex[1].z;
    }
#line 329
    if (stl->stats.min.z < facet.vertex[1].z) {
#line 329
      stl->stats.min.z = stl->stats.min.z;
    } else {
#line 329
      stl->stats.min.z = facet.vertex[1].z;
    }
#line 331
    if (stl->stats.max.x > facet.vertex[2].x) {
#line 331
      stl->stats.max.x = stl->stats.max.x;
    } else {
#line 331
      stl->stats.max.x = facet.vertex[2].x;
    }
#line 332
    if (stl->stats.min.x < facet.vertex[2].x) {
#line 332
      stl->stats.min.x = stl->stats.min.x;
    } else {
#line 332
      stl->stats.min.x = facet.vertex[2].x;
    }
#line 333
    if (stl->stats.max.y > facet.vertex[2].y) {
#line 333
      stl->stats.max.y = stl->stats.max.y;
    } else {
#line 333
      stl->stats.max.y = facet.vertex[2].y;
    }
#line 334
    if (stl->stats.min.y < facet.vertex[2].y) {
#line 334
      stl->stats.min.y = stl->stats.min.y;
    } else {
#line 334
      stl->stats.min.y = facet.vertex[2].y;
    }
#line 335
    if (stl->stats.max.z > facet.vertex[2].z) {
#line 335
      stl->stats.max.z = stl->stats.max.z;
    } else {
#line 335
      stl->stats.max.z = facet.vertex[2].z;
    }
#line 336
    if (stl->stats.min.z < facet.vertex[2].z) {
#line 336
      stl->stats.min.z = stl->stats.min.z;
    } else {
#line 336
      stl->stats.min.z = facet.vertex[2].z;
    }
#line 256
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 338
  stl->stats.size.x = stl->stats.max.x - stl->stats.min.x;
#line 339
  stl->stats.size.y = stl->stats.max.y - stl->stats.min.y;
#line 340
  stl->stats.size.z = stl->stats.max.z - stl->stats.min.z;
  {
#line 341
  tmp___2 = sqrt((double )((stl->stats.size.x * stl->stats.size.x + stl->stats.size.y * stl->stats.size.y) + stl->stats.size.z * stl->stats.size.z));
  }
#line 341
  stl->stats.bounding_diameter = (float )tmp___2;
  }
#line 345
  return;
}
}
#line 29 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_match_neighbors_exact___0(stl_file *stl , stl_hash_edge *edge_a ,
                                          stl_hash_edge *edge_b ) ;
#line 31
static void stl_match_neighbors_nearby___0(stl_file *stl , stl_hash_edge *edge_a ,
                                           stl_hash_edge *edge_b ) ;
#line 33
static void stl_record_neighbors___0(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) ;
#line 35
static void stl_initialize_facet_check_exact___0(stl_file *stl ) ;
#line 36
static void stl_initialize_facet_check_nearby___0(stl_file *stl ) ;
#line 37
static void stl_load_edge_exact___0(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                    stl_vertex *b ) ;
#line 39
static int stl_load_edge_nearby___0(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                    stl_vertex *b , float tolerance ) ;
#line 41
static void insert_hash_edge___0(stl_file *stl , stl_hash_edge edge , void (*match_neighbors)(stl_file *stl ,
                                                                                              stl_hash_edge *edge_a ,
                                                                                              stl_hash_edge *edge_b ) ) ;
#line 44
static int stl_get_hash_for_edge___0(int M , stl_hash_edge *edge ) ;
#line 45
static int stl_compare_function___0(stl_hash_edge *edge_a , stl_hash_edge *edge_b ) ;
#line 46
static void stl_free_edges___0(stl_file *stl ) ;
#line 47
static void stl_remove_facet___0(stl_file *stl , int facet_number ) ;
#line 48
static void stl_change_vertices___0(stl_file *stl , int facet_num , int vnot , stl_vertex new_vertex ) ;
#line 50
static void stl_which_vertices_to_change___0(stl_file *stl , stl_hash_edge *edge_a ,
                                             stl_hash_edge *edge_b , int *facet1 ,
                                             int *vertex1 , int *facet2 , int *vertex2 ,
                                             stl_vertex *new_vertex1 , stl_vertex *new_vertex2 ) ;
#line 54
static void stl_remove_degenerate___0(stl_file *stl , int facet ) ;
#line 55
static void stl_add_facet___0(stl_file *stl , stl_facet *new_facet ) ;
#line 58
static void stl_update_connects_remove_1___0(stl_file *stl , int facet_num ) ;
#line 111 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_load_edge_exact___0(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                    stl_vertex *b ) 
{ 
  float diff_x ;
  float diff_y ;
  float diff_z ;
  float max_diff ;

  {
#line 122
  if (a->x - b->x < (float )0) {
#line 122
    diff_x = - (a->x - b->x);
  } else {
#line 122
    diff_x = a->x - b->x;
  }
#line 123
  if (a->y - b->y < (float )0) {
#line 123
    diff_y = - (a->y - b->y);
  } else {
#line 123
    diff_y = a->y - b->y;
  }
#line 124
  if (a->z - b->z < (float )0) {
#line 124
    diff_z = - (a->z - b->z);
  } else {
#line 124
    diff_z = a->z - b->z;
  }
#line 125
  if (diff_x > diff_y) {
#line 125
    max_diff = diff_x;
  } else {
#line 125
    max_diff = diff_y;
  }
#line 126
  if (diff_z > max_diff) {
#line 126
    max_diff = diff_z;
  } else {
#line 126
    max_diff = max_diff;
  }
#line 127
  if (max_diff < stl->stats.shortest_edge) {
#line 127
    stl->stats.shortest_edge = max_diff;
  } else {
#line 127
    stl->stats.shortest_edge = stl->stats.shortest_edge;
  }
#line 129
  if (diff_x == max_diff) {
#line 131
    if (a->x > b->x) {
      {
      {
#line 133
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 134
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 138
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 139
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
#line 140
      edge->which_edge += 3;
      }
    }
  } else
#line 143
  if (diff_y == max_diff) {
#line 145
    if (a->y > b->y) {
      {
      {
#line 147
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 148
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 152
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)b,
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 153
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)a,
             (size_t )sizeof(stl_vertex ));
      }
#line 154
      edge->which_edge += 3;
      }
    }
  } else
#line 159
  if (a->z > b->z) {
    {
    {
#line 161
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)a,
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 162
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)b,
           (size_t )sizeof(stl_vertex ));
    }
    }
  } else {
    {
    {
#line 166
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)b,
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 167
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)a,
           (size_t )sizeof(stl_vertex ));
    }
#line 168
    edge->which_edge += 3;
    }
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_initialize_facet_check_exact___0(stl_file *stl ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 178
  stl->stats.malloced = 0;
#line 179
  stl->stats.freed = 0;
#line 180
  stl->stats.collisions = 0;
#line 183
  stl->M = 81397;
#line 185
  i = 0;
  {
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < stl->stats.number_of_facets)) {
#line 185
      goto while_break;
    }
#line 188
    (stl->neighbors_start + i)->neighbor[0] = -1;
#line 189
    (stl->neighbors_start + i)->neighbor[1] = -1;
#line 190
    (stl->neighbors_start + i)->neighbor[2] = -1;
#line 185
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 193
  tmp = calloc((size_t )stl->M, (size_t )sizeof(*(stl->heads)));
  }
#line 193
  stl->heads = (stl_hash_edge **)tmp;
  }
#line 194
  if ((unsigned long )stl->heads == (unsigned long )((void *)0)) {
    {
    {
#line 194
    perror("stl_initialize_facet_check_exact");
    }
    }
  }
  {
  {
#line 196
  tmp___0 = malloc((size_t )sizeof(stl_hash_edge ));
  }
#line 196
  stl->tail = (stl_hash_edge *)tmp___0;
  }
#line 197
  if ((unsigned long )stl->tail == (unsigned long )((void *)0)) {
    {
    {
#line 197
    perror("stl_initialize_facet_check_exact");
    }
    }
  }
#line 199
  (stl->tail)->next = stl->tail;
#line 201
  i = 0;
  {
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 201
    if (! (i < stl->M)) {
#line 201
      goto while_break___0;
    }
#line 203
    *(stl->heads + i) = stl->tail;
#line 201
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void insert_hash_edge___0(stl_file *stl , stl_hash_edge edge , void (*match_neighbors)(stl_file *stl ,
                                                                                              stl_hash_edge *edge_a ,
                                                                                              stl_hash_edge *edge_b ) ) 
{ 
  stl_hash_edge *link ;
  stl_hash_edge *new_edge ;
  stl_hash_edge *temp ;
  int chain_number ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 217
  chain_number = stl_get_hash_for_edge___0(stl->M, & edge);
  }
#line 219
  link = *(stl->heads + chain_number);
  }
#line 221
  if ((unsigned long )link == (unsigned long )stl->tail) {
    {
    {
#line 224
    tmp = malloc((size_t )sizeof(stl_hash_edge ));
    }
#line 224
    new_edge = (stl_hash_edge *)tmp;
    }
#line 225
    if ((unsigned long )new_edge == (unsigned long )((void *)0)) {
      {
      {
#line 225
      perror("insert_hash_edge");
      }
      }
    }
#line 226
    (stl->stats.malloced) ++;
#line 227
    *new_edge = edge;
#line 228
    new_edge->next = stl->tail;
#line 229
    *(stl->heads + chain_number) = new_edge;
#line 230
    return;
  } else {
    {
    {
#line 232
    tmp___2 = stl_compare_function___0(& edge, link);
    }
    }
#line 232
    if (tmp___2) {
      {
      {
#line 244
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 246
        if ((unsigned long )link->next == (unsigned long )stl->tail) {
          {
          {
#line 249
          tmp___0 = malloc((size_t )sizeof(stl_hash_edge ));
          }
#line 249
          new_edge = (stl_hash_edge *)tmp___0;
          }
#line 250
          if ((unsigned long )new_edge == (unsigned long )((void *)0)) {
            {
            {
#line 250
            perror("insert_hash_edge");
            }
            }
          }
#line 251
          (stl->stats.malloced) ++;
#line 252
          *new_edge = edge;
#line 253
          new_edge->next = stl->tail;
#line 254
          link->next = new_edge;
#line 255
          (stl->stats.collisions) ++;
#line 256
          return;
        } else {
          {
          {
#line 258
          tmp___1 = stl_compare_function___0(& edge, link->next);
          }
          }
#line 258
          if (tmp___1) {
#line 273
            link = link->next;
#line 274
            (stl->stats.collisions) ++;
          } else {
            {
            {
#line 261
            (*match_neighbors)(stl, & edge, link->next);
            }
#line 264
            temp = link->next;
#line 265
            link->next = (link->next)->next;
            {
#line 266
            free((void *)temp);
            }
#line 267
            (stl->stats.freed) ++;
            }
#line 268
            return;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 235
      (*match_neighbors)(stl, & edge, link);
      }
#line 237
      *(stl->heads + chain_number) = link->next;
      {
#line 238
      free((void *)link);
      }
#line 239
      (stl->stats.freed) ++;
      }
#line 240
      return;
    }
  }
}
}
#line 281 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static int stl_get_hash_for_edge___0(int M , stl_hash_edge *edge ) 
{ 


  {
#line 284
  return ((int )((((((edge->key[0] / 23U + edge->key[1] / 19U) + edge->key[2] / 17U) + edge->key[3] / 13U) + edge->key[4] / 11U) + edge->key[5] / 7U) % (unsigned int )M));
}
}
#line 288 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static int stl_compare_function___0(stl_hash_edge *edge_a , stl_hash_edge *edge_b ) 
{ 
  int tmp ;

  {
#line 291
  if (edge_a->facet_number == edge_b->facet_number) {
#line 293
    return (1);
  } else {
    {
    {
#line 297
    tmp = memcmp((void const   *)edge_a, (void const   *)edge_b, (size_t )24);
    }
    }
#line 297
    return (tmp);
  }
}
}
#line 343 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static int stl_load_edge_nearby___0(stl_file *stl , stl_hash_edge *edge , stl_vertex *a ,
                                    stl_vertex *b , float tolerance ) 
{ 
  float diff_x ;
  float diff_y ;
  float diff_z ;
  float max_diff ;
  unsigned int vertex1[3] ;
  unsigned int vertex2[3] ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;

  {
#line 355
  if (a->x - b->x < (float )0) {
#line 355
    diff_x = - (a->x - b->x);
  } else {
#line 355
    diff_x = a->x - b->x;
  }
#line 356
  if (a->y - b->y < (float )0) {
#line 356
    diff_y = - (a->y - b->y);
  } else {
#line 356
    diff_y = a->y - b->y;
  }
#line 357
  if (a->z - b->z < (float )0) {
#line 357
    diff_z = - (a->z - b->z);
  } else {
#line 357
    diff_z = a->z - b->z;
  }
#line 358
  if (diff_x > diff_y) {
#line 358
    max_diff = diff_x;
  } else {
#line 358
    max_diff = diff_y;
  }
#line 359
  if (diff_z > max_diff) {
#line 359
    max_diff = diff_z;
  } else {
#line 359
    max_diff = max_diff;
  }
#line 361
  vertex1[0] = (unsigned int )((a->x - stl->stats.min.x) / tolerance);
#line 362
  vertex1[1] = (unsigned int )((a->y - stl->stats.min.y) / tolerance);
#line 363
  vertex1[2] = (unsigned int )((a->z - stl->stats.min.z) / tolerance);
#line 364
  vertex2[0] = (unsigned int )((b->x - stl->stats.min.x) / tolerance);
#line 365
  vertex2[1] = (unsigned int )((b->y - stl->stats.min.y) / tolerance);
#line 366
  vertex2[2] = (unsigned int )((b->z - stl->stats.min.z) / tolerance);
#line 368
  if (vertex1[0] == vertex2[0]) {
#line 368
    if (vertex1[1] == vertex2[1]) {
#line 368
      if (vertex1[2] == vertex2[2]) {
#line 373
        return (0);
      }
    }
  }
#line 376
  if (diff_x == max_diff) {
#line 378
    if (a->x > b->x) {
      {
      {
#line 380
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 381
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 385
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 386
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
#line 387
      edge->which_edge += 3;
      }
    }
  } else
#line 390
  if (diff_y == max_diff) {
#line 392
    if (a->y > b->y) {
      {
      {
#line 394
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 395
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      }
    } else {
      {
      {
#line 399
      memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex2),
             (size_t )sizeof(stl_vertex ));
      }
      {
#line 400
      memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex1),
             (size_t )sizeof(stl_vertex ));
      }
#line 401
      edge->which_edge += 3;
      }
    }
  } else
#line 406
  if (a->z > b->z) {
    {
    {
#line 408
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex1),
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 409
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex2),
           (size_t )sizeof(stl_vertex ));
    }
    }
  } else {
    {
    {
#line 413
    memcpy((void */* __restrict  */)(& edge->key[0]), (void const   */* __restrict  */)(vertex2),
           (size_t )sizeof(stl_vertex ));
    }
    {
#line 414
    memcpy((void */* __restrict  */)(& edge->key[3]), (void const   */* __restrict  */)(vertex1),
           (size_t )sizeof(stl_vertex ));
    }
#line 415
    edge->which_edge += 3;
    }
  }
#line 418
  return (1);
}
}
#line 421 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_free_edges___0(stl_file *stl ) 
{ 
  int i ;
  stl_hash_edge *temp ;

  {
#line 427
  if (stl->stats.malloced != stl->stats.freed) {
#line 429
    i = 0;
    {
    {
#line 429
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 429
      if (! (i < stl->M)) {
#line 429
        goto while_break;
      }
#line 431
      temp = *(stl->heads + i);
      {
      {
#line 431
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 431
        if (! ((unsigned long )*(stl->heads + i) != (unsigned long )stl->tail)) {
#line 431
          goto while_break___0;
        }
        {
#line 434
        *(stl->heads + i) = (*(stl->heads + i))->next;
        {
#line 435
        free((void *)temp);
        }
#line 436
        (stl->stats.freed) ++;
#line 431
        temp = *(stl->heads + i);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 429
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 440
  free((void *)stl->heads);
  }
  {
#line 441
  free((void *)stl->tail);
  }
  }
#line 442
  return;
}
}
#line 444 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_initialize_facet_check_nearby___0(stl_file *stl ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 449
  stl->stats.malloced = 0;
#line 450
  stl->stats.freed = 0;
#line 451
  stl->stats.collisions = 0;
#line 457
  stl->M = 81397;
  {
#line 459
  tmp = calloc((size_t )stl->M, (size_t )sizeof(*(stl->heads)));
  }
#line 459
  stl->heads = (stl_hash_edge **)tmp;
  }
#line 460
  if ((unsigned long )stl->heads == (unsigned long )((void *)0)) {
    {
    {
#line 460
    perror("stl_initialize_facet_check_nearby");
    }
    }
  }
  {
  {
#line 462
  tmp___0 = malloc((size_t )sizeof(stl_hash_edge ));
  }
#line 462
  stl->tail = (stl_hash_edge *)tmp___0;
  }
#line 463
  if ((unsigned long )stl->tail == (unsigned long )((void *)0)) {
    {
    {
#line 463
    perror("stl_initialize_facet_check_nearby");
    }
    }
  }
#line 465
  (stl->tail)->next = stl->tail;
#line 467
  i = 0;
  {
  {
#line 467
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 467
    if (! (i < stl->M)) {
#line 467
      goto while_break;
    }
#line 469
    *(stl->heads + i) = stl->tail;
#line 467
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  return;
}
}
#line 475 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_record_neighbors___0(stl_file *stl , stl_hash_edge *edge_a , stl_hash_edge *edge_b ) 
{ 
  int i ;
  int j ;

  {
#line 483
  (stl->neighbors_start + edge_a->facet_number)->neighbor[edge_a->which_edge % 3] = edge_b->facet_number;
#line 486
  (stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] = (char )((edge_b->which_edge + 2) % 3);
#line 491
  (stl->neighbors_start + edge_b->facet_number)->neighbor[edge_b->which_edge % 3] = edge_a->facet_number;
#line 494
  (stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] = (char )((edge_a->which_edge + 2) % 3);
#line 498
  if (edge_a->which_edge < 3) {
#line 498
    if (edge_b->which_edge < 3) {
#line 503
      (stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] + 3);
#line 505
      (stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] + 3);
    } else {
#line 498
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 498
  if (edge_a->which_edge > 2) {
#line 498
    if (edge_b->which_edge > 2) {
#line 503
      (stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_a->facet_number)->which_vertex_not[edge_a->which_edge % 3] + 3);
#line 505
      (stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] = (char )((int )(stl->neighbors_start + edge_b->facet_number)->which_vertex_not[edge_b->which_edge % 3] + 3);
    }
  }
#line 512
  stl->stats.connected_edges += 2;
#line 514
  i = (((stl->neighbors_start + edge_a->facet_number)->neighbor[0] == -1) + ((stl->neighbors_start + edge_a->facet_number)->neighbor[1] == -1)) + ((stl->neighbors_start + edge_a->facet_number)->neighbor[2] == -1);
#line 517
  j = (((stl->neighbors_start + edge_b->facet_number)->neighbor[0] == -1) + ((stl->neighbors_start + edge_b->facet_number)->neighbor[1] == -1)) + ((stl->neighbors_start + edge_b->facet_number)->neighbor[2] == -1);
#line 520
  if (i == 2) {
#line 522
    (stl->stats.connected_facets_1_edge) ++;
  } else
#line 524
  if (i == 1) {
#line 526
    (stl->stats.connected_facets_2_edge) ++;
  } else {
#line 530
    (stl->stats.connected_facets_3_edge) ++;
  }
#line 532
  if (j == 2) {
#line 534
    (stl->stats.connected_facets_1_edge) ++;
  } else
#line 536
  if (j == 1) {
#line 538
    (stl->stats.connected_facets_2_edge) ++;
  } else {
#line 542
    (stl->stats.connected_facets_3_edge) ++;
  }
#line 544
  return;
}
}
#line 546 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_match_neighbors_exact___0(stl_file *stl , stl_hash_edge *edge_a ,
                                          stl_hash_edge *edge_b ) 
{ 


  {
  {
  {
#line 550
  stl_record_neighbors___0(stl, edge_a, edge_b);
  }
  }
#line 551
  return;
}
}
#line 553 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_match_neighbors_nearby___0(stl_file *stl , stl_hash_edge *edge_a ,
                                           stl_hash_edge *edge_b ) 
{ 
  int facet1 ;
  int facet2 ;
  int vertex1 ;
  int vertex2 ;
  int vnot1 ;
  int vnot2 ;
  stl_vertex new_vertex1 ;
  stl_vertex new_vertex2 ;

  {
  {
  {
#line 566
  stl_record_neighbors___0(stl, edge_a, edge_b);
  }
  {
#line 567
  stl_which_vertices_to_change___0(stl, edge_a, edge_b, & facet1, & vertex1, & facet2,
                                   & vertex2, & new_vertex1, & new_vertex2);
  }
  }
#line 569
  if (facet1 != -1) {
#line 571
    if (facet1 == edge_a->facet_number) {
#line 573
      vnot1 = (edge_a->which_edge + 2) % 3;
    } else {
#line 577
      vnot1 = (edge_b->which_edge + 2) % 3;
    }
#line 579
    if ((vnot1 + 2) % 3 == vertex1) {
#line 581
      vnot1 += 3;
    }
    {
    {
#line 583
    stl_change_vertices___0(stl, facet1, vnot1, new_vertex1);
    }
    }
  }
#line 585
  if (facet2 != -1) {
#line 587
    if (facet2 == edge_a->facet_number) {
#line 589
      vnot2 = (edge_a->which_edge + 2) % 3;
    } else {
#line 593
      vnot2 = (edge_b->which_edge + 2) % 3;
    }
#line 595
    if ((vnot2 + 2) % 3 == vertex2) {
#line 597
      vnot2 += 3;
    }
    {
    {
#line 599
    stl_change_vertices___0(stl, facet2, vnot2, new_vertex2);
    }
    }
  }
#line 601
  stl->stats.edges_fixed += 2;
#line 602
  return;
}
}
#line 605 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_change_vertices___0(stl_file *stl , int facet_num , int vnot , stl_vertex new_vertex ) 
{ 
  int first_facet ;
  int direction ;
  int next_edge ;
  int pivot_vertex ;
  char *__cil_tmp9 ;

  {
#line 614
  first_facet = facet_num;
#line 615
  direction = 0;
  {
  {
#line 617
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 619
    if (vnot > 2) {
#line 621
      if (direction == 0) {
#line 623
        pivot_vertex = (vnot + 2) % 3;
#line 624
        next_edge = pivot_vertex;
#line 625
        direction = 1;
      } else {
#line 629
        pivot_vertex = (vnot + 1) % 3;
#line 630
        next_edge = vnot % 3;
#line 631
        direction = 0;
      }
    } else
#line 636
    if (direction == 0) {
#line 638
      pivot_vertex = (vnot + 1) % 3;
#line 639
      next_edge = vnot;
    } else {
#line 643
      pivot_vertex = (vnot + 2) % 3;
#line 644
      next_edge = pivot_vertex;
    }
#line 647
    (stl->facet_start + facet_num)->vertex[pivot_vertex] = new_vertex;
#line 648
    vnot = (int )(stl->neighbors_start + facet_num)->which_vertex_not[next_edge];
#line 649
    facet_num = (stl->neighbors_start + facet_num)->neighbor[next_edge];
#line 651
    if (facet_num == -1) {
#line 653
      goto while_break;
    }
#line 656
    if (facet_num == first_facet) {
      {
      {
#line 659
      printf((char const   */* __restrict  */)"Back to the first facet changing vertices: probably a mobius part.\nTry using a smaller tolerance or don\'t do a nearby check\n");
      }
      {
#line 662
      exit(1);
      }
      }
#line 663
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  return;
}
}
#line 669 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_which_vertices_to_change___0(stl_file *stl , stl_hash_edge *edge_a ,
                                             stl_hash_edge *edge_b , int *facet1 ,
                                             int *vertex1 , int *facet2 , int *vertex2 ,
                                             stl_vertex *new_vertex1 , stl_vertex *new_vertex2 ) 
{ 
  int v1a ;
  int v1b ;
  int v2a ;
  int v2b ;
  int tmp ;
  int tmp___0 ;

  {
#line 682
  if (edge_a->which_edge < 3) {
#line 684
    v1a = edge_a->which_edge;
#line 685
    v2a = (edge_a->which_edge + 1) % 3;
  } else {
#line 689
    v2a = edge_a->which_edge % 3;
#line 690
    v1a = (edge_a->which_edge + 1) % 3;
  }
#line 692
  if (edge_b->which_edge < 3) {
#line 694
    v1b = edge_b->which_edge;
#line 695
    v2b = (edge_b->which_edge + 1) % 3;
  } else {
#line 699
    v2b = edge_b->which_edge % 3;
#line 700
    v1b = (edge_b->which_edge + 1) % 3;
  }
  {
  {
#line 704
  tmp = memcmp((void const   *)(& (stl->facet_start + edge_a->facet_number)->vertex[v1a]),
               (void const   *)(& (stl->facet_start + edge_b->facet_number)->vertex[v1b]),
               (size_t )sizeof(stl_vertex ));
  }
  }
#line 704
  if (tmp) {
#line 713
    if ((stl->neighbors_start + edge_a->facet_number)->neighbor[v1a] == -1) {
#line 713
      if ((stl->neighbors_start + edge_a->facet_number)->neighbor[(v1a + 2) % 3] == -1) {
#line 718
        *facet1 = edge_a->facet_number;
#line 719
        *vertex1 = v1a;
#line 720
        *new_vertex1 = (stl->facet_start + edge_b->facet_number)->vertex[v1b];
      } else {
#line 724
        *facet1 = edge_b->facet_number;
#line 725
        *vertex1 = v1b;
#line 726
        *new_vertex1 = (stl->facet_start + edge_a->facet_number)->vertex[v1a];
      }
    } else {
#line 724
      *facet1 = edge_b->facet_number;
#line 725
      *vertex1 = v1b;
#line 726
      *new_vertex1 = (stl->facet_start + edge_a->facet_number)->vertex[v1a];
    }
  } else {
#line 709
    *facet1 = -1;
  }
  {
  {
#line 731
  tmp___0 = memcmp((void const   *)(& (stl->facet_start + edge_a->facet_number)->vertex[v2a]),
                   (void const   *)(& (stl->facet_start + edge_b->facet_number)->vertex[v2b]),
                   (size_t )sizeof(stl_vertex ));
  }
  }
#line 731
  if (tmp___0) {
#line 740
    if ((stl->neighbors_start + edge_a->facet_number)->neighbor[v2a] == -1) {
#line 740
      if ((stl->neighbors_start + edge_a->facet_number)->neighbor[(v2a + 2) % 3] == -1) {
#line 745
        *facet2 = edge_a->facet_number;
#line 746
        *vertex2 = v2a;
#line 747
        *new_vertex2 = (stl->facet_start + edge_b->facet_number)->vertex[v2b];
      } else {
#line 751
        *facet2 = edge_b->facet_number;
#line 752
        *vertex2 = v2b;
#line 753
        *new_vertex2 = (stl->facet_start + edge_a->facet_number)->vertex[v2a];
      }
    } else {
#line 751
      *facet2 = edge_b->facet_number;
#line 752
      *vertex2 = v2b;
#line 753
      *new_vertex2 = (stl->facet_start + edge_a->facet_number)->vertex[v2a];
    }
  } else {
#line 736
    *facet2 = -1;
  }
#line 756
  return;
}
}
#line 758 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_remove_facet___0(stl_file *stl , int facet_number ) 
{ 
  int neighbor[3] ;
  int vnot[3] ;
  int i ;
  int j ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 766
  (stl->stats.facets_removed) ++;
#line 768
  j = (((stl->neighbors_start + facet_number)->neighbor[0] == -1) + ((stl->neighbors_start + facet_number)->neighbor[1] == -1)) + ((stl->neighbors_start + facet_number)->neighbor[2] == -1);
#line 771
  if (j == 2) {
#line 773
    (stl->stats.connected_facets_1_edge) --;
  } else
#line 775
  if (j == 1) {
#line 777
    (stl->stats.connected_facets_2_edge) --;
#line 778
    (stl->stats.connected_facets_1_edge) --;
  } else
#line 780
  if (j == 0) {
#line 782
    (stl->stats.connected_facets_3_edge) --;
#line 783
    (stl->stats.connected_facets_2_edge) --;
#line 784
    (stl->stats.connected_facets_1_edge) --;
  }
#line 787
  *(stl->facet_start + facet_number) = *(stl->facet_start + (stl->stats.number_of_facets - 1));
#line 790
  *(stl->neighbors_start + facet_number) = *(stl->neighbors_start + (stl->stats.number_of_facets - 1));
#line 792
  (stl->stats.number_of_facets) --;
#line 794
  i = 0;
  {
  {
#line 794
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 794
    if (! (i < 3)) {
#line 794
      goto while_break;
    }
#line 796
    neighbor[i] = (stl->neighbors_start + facet_number)->neighbor[i];
#line 797
    vnot[i] = (int )(stl->neighbors_start + facet_number)->which_vertex_not[i];
#line 794
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 800
  i = 0;
  {
  {
#line 800
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 800
    if (! (i < 3)) {
#line 800
      goto while_break___0;
    }
#line 802
    if (neighbor[i] != -1) {
#line 804
      if ((stl->neighbors_start + neighbor[i])->neighbor[(vnot[i] + 1) % 3] != stl->stats.number_of_facets) {
        {
        {
#line 807
        printf((char const   */* __restrict  */)"in stl_remove_facet: neighbor = %d numfacets = %d this is wrong\n",
               (stl->neighbors_start + neighbor[i])->neighbor[(vnot[i] + 1) % 3],
               stl->stats.number_of_facets);
        }
        {
#line 811
        exit(1);
        }
        }
      }
#line 813
      (stl->neighbors_start + neighbor[i])->neighbor[(vnot[i] + 1) % 3] = facet_number;
    }
#line 800
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 817
  return;
}
}
#line 862 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_remove_degenerate___0(stl_file *stl , int facet ) 
{ 
  int edge1 ;
  int edge2 ;
  int edge3 ;
  int neighbor1 ;
  int neighbor2 ;
  int neighbor3 ;
  int vnot1 ;
  int vnot2 ;
  int vnot3 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 875
  tmp = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[0]), (void const   *)(& (stl->facet_start + facet)->vertex[1]),
               (size_t )sizeof(stl_vertex ));
  }
  }
#line 875
  if (! tmp) {
    {
    {
#line 875
    tmp___0 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[1]), (void const   *)(& (stl->facet_start + facet)->vertex[2]),
                     (size_t )sizeof(stl_vertex ));
    }
    }
#line 875
    if (! tmp___0) {
      {
      {
#line 882
      printf((char const   */* __restrict  */)"removing a facet in stl_remove_degenerate\n");
      }
      {
#line 884
      stl_remove_facet___0(stl, facet);
      }
      }
#line 885
      return;
    }
  }
  {
  {
#line 888
  tmp___3 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[0]), (void const   *)(& (stl->facet_start + facet)->vertex[1]),
                   (size_t )sizeof(stl_vertex ));
  }
  }
#line 888
  if (tmp___3) {
    {
    {
#line 895
    tmp___2 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[1]), (void const   *)(& (stl->facet_start + facet)->vertex[2]),
                     (size_t )sizeof(stl_vertex ));
    }
    }
#line 895
    if (tmp___2) {
      {
      {
#line 902
      tmp___1 = memcmp((void const   *)(& (stl->facet_start + facet)->vertex[2]),
                       (void const   *)(& (stl->facet_start + facet)->vertex[0]),
                       (size_t )sizeof(stl_vertex ));
      }
      }
#line 902
      if (tmp___1) {
#line 912
        return;
      } else {
#line 905
        edge1 = 0;
#line 906
        edge2 = 1;
#line 907
        edge3 = 2;
      }
    } else {
#line 898
      edge1 = 0;
#line 899
      edge2 = 2;
#line 900
      edge3 = 1;
    }
  } else {
#line 891
    edge1 = 1;
#line 892
    edge2 = 2;
#line 893
    edge3 = 0;
  }
#line 914
  neighbor1 = (stl->neighbors_start + facet)->neighbor[edge1];
#line 915
  neighbor2 = (stl->neighbors_start + facet)->neighbor[edge2];
#line 917
  if (neighbor1 == -1) {
    {
    {
#line 919
    stl_update_connects_remove_1___0(stl, neighbor2);
    }
    }
  }
#line 921
  if (neighbor2 == -1) {
    {
    {
#line 923
    stl_update_connects_remove_1___0(stl, neighbor1);
    }
    }
  }
  {
#line 927
  neighbor3 = (stl->neighbors_start + facet)->neighbor[edge3];
#line 928
  vnot1 = (int )(stl->neighbors_start + facet)->which_vertex_not[edge1];
#line 929
  vnot2 = (int )(stl->neighbors_start + facet)->which_vertex_not[edge2];
#line 930
  vnot3 = (int )(stl->neighbors_start + facet)->which_vertex_not[edge3];
#line 932
  (stl->neighbors_start + neighbor1)->neighbor[(vnot1 + 1) % 3] = neighbor2;
#line 933
  (stl->neighbors_start + neighbor2)->neighbor[(vnot2 + 1) % 3] = neighbor1;
#line 934
  (stl->neighbors_start + neighbor1)->which_vertex_not[(vnot1 + 1) % 3] = (char )vnot2;
#line 935
  (stl->neighbors_start + neighbor2)->which_vertex_not[(vnot2 + 1) % 3] = (char )vnot1;
  {
#line 937
  stl_remove_facet___0(stl, facet);
  }
  }
#line 939
  if (neighbor3 != -1) {
    {
    {
#line 941
    stl_update_connects_remove_1___0(stl, neighbor3);
    }
#line 942
    (stl->neighbors_start + neighbor3)->neighbor[(vnot3 + 1) % 3] = -1;
    }
  }
#line 944
  return;
}
}
#line 946 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_update_connects_remove_1___0(stl_file *stl , int facet_num ) 
{ 
  int j ;

  {
#line 952
  j = (((stl->neighbors_start + facet_num)->neighbor[0] == -1) + ((stl->neighbors_start + facet_num)->neighbor[1] == -1)) + ((stl->neighbors_start + facet_num)->neighbor[2] == -1);
#line 955
  if (j == 0) {
#line 957
    (stl->stats.connected_facets_3_edge) --;
  } else
#line 959
  if (j == 1) {
#line 961
    (stl->stats.connected_facets_2_edge) --;
  } else
#line 963
  if (j == 2) {
#line 965
    (stl->stats.connected_facets_1_edge) --;
  }
#line 967
  return;
}
}
#line 1098 "/home/wslee/benchmarks/admesh-0.95/connect.c"
static void stl_add_facet___0(stl_file *stl , stl_facet *new_facet ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1101
  (stl->stats.facets_added) ++;
#line 1102
  if (stl->stats.facets_malloced < stl->stats.number_of_facets + 1) {
    {
    {
#line 1104
    tmp = realloc((void *)stl->facet_start, (size_t )(sizeof(stl_facet ) * (unsigned long )(stl->stats.facets_malloced + 256)));
    }
#line 1104
    stl->facet_start = (stl_facet *)tmp;
    }
#line 1106
    if ((unsigned long )stl->facet_start == (unsigned long )((void *)0)) {
      {
      {
#line 1106
      perror("stl_add_facet");
      }
      }
    }
    {
    {
#line 1107
    tmp___0 = realloc((void *)stl->neighbors_start, (size_t )(sizeof(stl_neighbors ) * (unsigned long )(stl->stats.facets_malloced + 256)));
    }
#line 1107
    stl->neighbors_start = (stl_neighbors *)tmp___0;
    }
#line 1109
    if ((unsigned long )stl->neighbors_start == (unsigned long )((void *)0)) {
      {
      {
#line 1109
      perror("stl_add_facet");
      }
      }
    }
#line 1110
    stl->stats.facets_malloced += 256;
  }
#line 1112
  *(stl->facet_start + stl->stats.number_of_facets) = *new_facet;
#line 1115
  (stl->facet_start + stl->stats.number_of_facets)->normal.x = (float )0.0;
#line 1116
  (stl->facet_start + stl->stats.number_of_facets)->normal.y = (float )0.0;
#line 1117
  (stl->facet_start + stl->stats.number_of_facets)->normal.z = (float )0.0;
#line 1119
  (stl->neighbors_start + stl->stats.number_of_facets)->neighbor[0] = -1;
#line 1120
  (stl->neighbors_start + stl->stats.number_of_facets)->neighbor[1] = -1;
#line 1121
  (stl->neighbors_start + stl->stats.number_of_facets)->neighbor[2] = -1;
#line 1122
  (stl->stats.number_of_facets) ++;
#line 1123
  return;
}
}
#line 28 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void stl_rotate___0(float *x , float *y , float angle ) ;
#line 29
static void stl_get_size___0(stl_file *stl ) ;
#line 30
static float get_area___0(stl_facet *facet ) ;
#line 31
static float get_volume___0(stl_file *stl ) ;
#line 127 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void calculate_normals___0(stl_file *stl ) 
{ 
  long i ;
  float normal[3] ;
  void *__cil_tmp4 ;

  {
#line 132
  i = 0L;
  {
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < (long )stl->stats.number_of_facets)) {
#line 132
      goto while_break;
    }
    {
    {
#line 133
    stl_calculate_normal(normal, stl->facet_start + i);
    }
    {
#line 134
    stl_normalize_vector(normal);
    }
#line 135
    (stl->facet_start + i)->normal.x = normal[0];
#line 136
    (stl->facet_start + i)->normal.y = normal[1];
#line 137
    (stl->facet_start + i)->normal.z = normal[2];
#line 132
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return;
}
}
#line 197 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void stl_rotate___0(float *x , float *y , float angle ) 
{ 
  double r ;
  double theta ;
  double radian_angle ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 204
  radian_angle = ((double )angle / 180.0) * 3.14159265358979323846;
  {
#line 206
  r = sqrt((double )(*x * *x + *y * *y));
  }
  {
#line 207
  theta = atan2((double )*y, (double )*x);
  }
  {
#line 208
  tmp = cos(theta + radian_angle);
  }
#line 208
  *x = (float )(r * tmp);
  {
#line 209
  tmp___0 = sin(theta + radian_angle);
  }
#line 209
  *y = (float )(r * tmp___0);
  }
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/admesh-0.95/util.c"
static void stl_get_size___0(stl_file *stl ) 
{ 
  int i ;
  int j ;

  {
#line 218
  stl->stats.min.x = (stl->facet_start + 0)->vertex[0].x;
#line 219
  stl->stats.min.y = (stl->facet_start + 0)->vertex[0].y;
#line 220
  stl->stats.min.z = (stl->facet_start + 0)->vertex[0].z;
#line 221
  stl->stats.max.x = (stl->facet_start + 0)->vertex[0].x;
#line 222
  stl->stats.max.y = (stl->facet_start + 0)->vertex[0].y;
#line 223
  stl->stats.max.z = (stl->facet_start + 0)->vertex[0].z;
#line 225
  i = 0;
  {
  {
#line 225
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < stl->stats.number_of_facets)) {
#line 225
      goto while_break;
    }
#line 227
    j = 0;
    {
    {
#line 227
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 227
      if (! (j < 3)) {
#line 227
        goto while_break___0;
      }
#line 229
      if (stl->stats.min.x < (stl->facet_start + i)->vertex[j].x) {
#line 229
        stl->stats.min.x = stl->stats.min.x;
      } else {
#line 229
        stl->stats.min.x = (stl->facet_start + i)->vertex[j].x;
      }
#line 231
      if (stl->stats.min.y < (stl->facet_start + i)->vertex[j].y) {
#line 231
        stl->stats.min.y = stl->stats.min.y;
      } else {
#line 231
        stl->stats.min.y = (stl->facet_start + i)->vertex[j].y;
      }
#line 233
      if (stl->stats.min.z < (stl->facet_start + i)->vertex[j].z) {
#line 233
        stl->stats.min.z = stl->stats.min.z;
      } else {
#line 233
        stl->stats.min.z = (stl->facet_start + i)->vertex[j].z;
      }
#line 235
      if (stl->stats.max.x > (stl->facet_start + i)->vertex[j].x) {
#line 235
        stl->stats.max.x = stl->stats.max.x;
      } else {
#line 235
        stl->stats.max.x = (stl->facet_start + i)->vertex[j].x;
      }
#line 237
      if (stl->stats.max.y > (stl->facet_start + i)->vertex[j].y) {
#line 237
        stl->stats.max.y = stl->stats.max.y;
      } else {
#line 237
        stl->stats.max.y = (stl->facet_start + i)->vertex[j].y;
      }
#line 239
      if (stl->stats.max.z > (stl->facet_start + i)->vertex[j].z) {
#line 239
        stl->stats.max.z = stl->stats.max.z;
      } else {
#line 239
        stl->stats.max.z = (stl->facet_start + i)->vertex[j].z;
      }
#line 227
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 225
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 308 "/home/wslee/benchmarks/admesh-0.95/util.c"
static float get_volume___0(stl_file *stl ) 
{ 
  long i ;
  stl_vertex p0 ;
  stl_vertex p ;
  stl_normal n ;
  float height ;
  float area ;
  float volume ;

  {
#line 316
  volume = (float )0.0;
#line 319
  p0.x = (stl->facet_start + 0)->vertex[0].x;
#line 320
  p0.y = (stl->facet_start + 0)->vertex[0].y;
#line 321
  p0.z = (stl->facet_start + 0)->vertex[0].z;
#line 323
  i = 0L;
  {
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < (long )stl->stats.number_of_facets)) {
#line 323
      goto while_break;
    }
    {
#line 324
    p.x = (stl->facet_start + i)->vertex[0].x - p0.x;
#line 325
    p.y = (stl->facet_start + i)->vertex[0].y - p0.y;
#line 326
    p.z = (stl->facet_start + i)->vertex[0].z - p0.z;
#line 328
    n = (stl->facet_start + i)->normal;
#line 329
    height = (n.x * p.x + n.y * p.y) + n.z * p.z;
    {
#line 330
    area = get_area___0(stl->facet_start + i);
    }
#line 331
    volume = (float )((double )volume + (double )(area * height) / 3.0);
#line 323
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return (volume);
}
}
#line 345 "/home/wslee/benchmarks/admesh-0.95/util.c"
static float get_area___0(stl_facet *facet ) 
{ 
  float cross[3][3] ;
  float sum[3] ;
  float n[3] ;
  float area ;
  int i ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;

  {
#line 353
  i = 0;
  {
  {
#line 353
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < 3)) {
#line 353
      goto while_break;
    }
#line 354
    cross[i][0] = facet->vertex[i].y * facet->vertex[(i + 1) % 3].z - facet->vertex[i].z * facet->vertex[(i + 1) % 3].y;
#line 356
    cross[i][1] = facet->vertex[i].z * facet->vertex[(i + 1) % 3].x - facet->vertex[i].x * facet->vertex[(i + 1) % 3].z;
#line 358
    cross[i][2] = facet->vertex[i].x * facet->vertex[(i + 1) % 3].y - facet->vertex[i].y * facet->vertex[(i + 1) % 3].x;
#line 353
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  sum[0] = (cross[0][0] + cross[1][0]) + cross[2][0];
#line 363
  sum[1] = (cross[0][1] + cross[1][1]) + cross[2][1];
#line 364
  sum[2] = (cross[0][2] + cross[1][2]) + cross[2][2];
  {
#line 367
  stl_calculate_normal(n, facet);
  }
  {
#line 368
  stl_normalize_vector(n);
  }
#line 370
  area = (float )(0.5 * (double )((n[0] * sum[0] + n[1] * sum[1]) + n[2] * sum[2]));
  }
#line 371
  return (area);
}
}
